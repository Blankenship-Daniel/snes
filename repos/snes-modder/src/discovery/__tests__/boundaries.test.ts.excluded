/**
 * Error Boundary Test Patterns
 * Sam's error testing: Test failure modes, recovery patterns, edge cases
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

import {
  DiscoveryError,
  ValidationError,
  NotFoundError,
  DuplicateError,
  CorruptionError,
  tryCatch,
  tryCatchAsync,
  withRetry,
  withFallback,
  CircuitBreaker,
  AggregateError,
  ErrorCollector,
  validateInput,
  validateBatch
} from '../errors/boundaries';

// ============================================
// CUSTOM ERROR TESTS
// ============================================

describe('Custom Error Classes', () => {
  describe('DiscoveryError', () => {
    it('should create proper error instances', () => {
      const error = new DiscoveryError('Test message', 'TEST_CODE', { detail: 'info' });
      
      expect(error).toBeInstanceOf(Error);
      expect(error).toBeInstanceOf(DiscoveryError);
      expect(error.name).toBe('DiscoveryError');
      expect(error.message).toBe('Test message');
      expect(error.code).toBe('TEST_CODE');
      expect(error.details).toEqual({ detail: 'info' });
    });

    it('should maintain proper stack trace', () => {
      const error = new DiscoveryError('Test', 'CODE');
      expect(error.stack).toContain('DiscoveryError');
    });
  });

  describe('Specialized Error Types', () => {
    it('should create ValidationError correctly', () => {
      const error = new ValidationError('Invalid data', { field: 'name' });
      expect(error).toBeInstanceOf(ValidationError);
      expect(error.code).toBe('VALIDATION_ERROR');
      expect(error.name).toBe('ValidationError');
    });

    it('should create NotFoundError correctly', () => {
      const error = new NotFoundError('Discovery', 'test-id');
      expect(error).toBeInstanceOf(NotFoundError);
      expect(error.message).toBe('Discovery not found: test-id');
      expect(error.code).toBe('NOT_FOUND');
    });

    it('should create DuplicateError correctly', () => {
      const error = new DuplicateError('Discovery', 'test-id');
      expect(error.message).toBe('Discovery already exists: test-id');
      expect(error.code).toBe('DUPLICATE');
    });

    it('should create CorruptionError correctly', () => {
      const error = new CorruptionError('Data corrupted', { bytes: [1, 2, 3] });
      expect(error.code).toBe('DATA_CORRUPTION');
      expect(error.details).toEqual({ bytes: [1, 2, 3] });
    });
  });
});

// ============================================
// ERROR BOUNDARY WRAPPER TESTS
// ============================================

describe('Error Boundary Wrappers', () => {
  describe('tryCatch', () => {
    it('should return success result for valid operations', () => {
      const result = tryCatch(() => 42);
      
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.value).toBe(42);
      }
    });

    it('should return error result for throwing operations', () => {
      const result = tryCatch(() => {
        throw new Error('Test error');
      });
      
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.message).toBe('Test error');
      }
    });

    it('should handle error transformation', () => {
      const result = tryCatch(
        () => { throw new Error('Original'); },
        (error) => new ValidationError(`Transformed: ${error.message}`)
      );
      
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(ValidationError);
        expect(result.error.message).toBe('Transformed: Original');
      }
    });

    it('should handle non-Error throws', () => {
      const result = tryCatch(() => {
        throw 'string error';
      });
      
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error).toBeInstanceOf(Error);
        expect(result.error.message).toBe('string error');
      }
    });
  });

  describe('tryCatchAsync', () => {
    it('should handle successful async operations', async () => {
      const result = await tryCatchAsync(async () => {
        await new Promise(resolve => setTimeout(resolve, 1));
        return 'success';
      });
      
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.value).toBe('success');
      }
    });

    it('should handle rejected promises', async () => {
      const result = await tryCatchAsync(async () => {
        throw new Error('Async error');
      });
      
      expect(result.success).toBe(false);
      if (!result.success) {
        expect(result.error.message).toBe('Async error');
      }
    });
  });
});

// ============================================
// RETRY MECHANISM TESTS
// ============================================

describe('Retry Mechanism', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should succeed on first attempt', async () => {
    const fn = vi.fn().mockResolvedValue('success');
    
    const promise = withRetry(fn);
    vi.runAllTimers();
    const result = await promise;
    
    expect(result).toBe('success');
    expect(fn).toHaveBeenCalledTimes(1);
  });

  it('should retry on failure and eventually succeed', async () => {
    const fn = vi.fn()
      .mockRejectedValueOnce(new Error('Fail 1'))
      .mockRejectedValueOnce(new Error('Fail 2'))
      .mockResolvedValue('success');
    
    const promise = withRetry(fn, { maxAttempts: 3, delayMs: 100 });
    vi.runAllTimers();
    const result = await promise;
    
    expect(result).toBe('success');
    expect(fn).toHaveBeenCalledTimes(3);
  });

  it('should respect maxAttempts limit', async () => {
    const fn = vi.fn().mockRejectedValue(new Error('Always fails'));
    
    const promise = withRetry(fn, { maxAttempts: 2 });
    vi.runAllTimers();
    
    await expect(promise).rejects.toThrow('Always fails');
    expect(fn).toHaveBeenCalledTimes(2);
  });

  it('should use exponential backoff', async () => {
    const fn = vi.fn()
      .mockRejectedValueOnce(new Error('Fail 1'))
      .mockRejectedValueOnce(new Error('Fail 2'))
      .mockResolvedValue('success');
    
    const promise = withRetry(fn, { 
      maxAttempts: 3, 
      delayMs: 100, 
      backoff: 'exponential' 
    });
    
    // Should delay 100ms, then 200ms
    vi.advanceTimersByTime(100);
    vi.advanceTimersByTime(200);
    vi.runAllTimers();
    
    const result = await promise;
    expect(result).toBe('success');
  });

  it('should respect shouldRetry condition', async () => {
    const fn = vi.fn().mockRejectedValue(new ValidationError('Invalid'));
    
    const promise = withRetry(fn, {
      maxAttempts: 3,
      shouldRetry: (error) => !(error instanceof ValidationError)
    });
    
    vi.runAllTimers();
    
    await expect(promise).rejects.toThrow('Invalid');
    expect(fn).toHaveBeenCalledTimes(1); // No retries for ValidationError
  });
});

// ============================================
// FALLBACK STRATEGY TESTS
// ============================================

describe('Fallback Strategy', () => {
  it('should return function result when successful', () => {
    const result = withFallback(() => 'success', 'fallback');
    expect(result).toBe('success');
  });

  it('should return fallback when function throws', () => {
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
    
    const result = withFallback(() => {
      throw new Error('Failed');
    }, 'fallback');
    
    expect(result).toBe('fallback');
    expect(consoleSpy).toHaveBeenCalled();
    
    consoleSpy.mockRestore();
  });

  it('should respect logError option', () => {
    const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
    
    withFallback(() => {
      throw new Error('Failed');
    }, 'fallback', false);
    
    expect(consoleSpy).not.toHaveBeenCalled();
    consoleSpy.mockRestore();
  });
});

// ============================================
// CIRCUIT BREAKER TESTS
// ============================================

describe('Circuit Breaker', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('should start in closed state', async () => {
    const breaker = new CircuitBreaker();
    const fn = vi.fn().mockResolvedValue('success');
    
    const result = await breaker.execute(fn);
    expect(result).toBe('success');
    expect(fn).toHaveBeenCalledTimes(1);
  });

  it('should open after threshold failures', async () => {
    const breaker = new CircuitBreaker(2, 1000); // threshold: 2, reset: 1s
    const fn = vi.fn().mockRejectedValue(new Error('Failed'));
    
    // First failure
    await expect(breaker.execute(fn)).rejects.toThrow('Failed');
    
    // Second failure - should open circuit
    await expect(breaker.execute(fn)).rejects.toThrow('Failed');
    
    // Third call - should be rejected immediately
    await expect(breaker.execute(fn)).rejects.toThrow('Circuit breaker is open');
    
    expect(fn).toHaveBeenCalledTimes(2);
  });

  it('should transition to half-open after reset time', async () => {
    const breaker = new CircuitBreaker(1, 1000);
    const fn = vi.fn()
      .mockRejectedValueOnce(new Error('Failed'))
      .mockResolvedValue('success');
    
    // Cause failure to open circuit
    await expect(breaker.execute(fn)).rejects.toThrow('Failed');
    
    // Immediate retry should fail
    await expect(breaker.execute(fn)).rejects.toThrow('Circuit breaker is open');
    
    // Advance time past reset threshold
    vi.advanceTimersByTime(1500);
    
    // Should now allow one test call (half-open)
    const result = await breaker.execute(fn);
    expect(result).toBe('success');
    expect(fn).toHaveBeenCalledTimes(2);
  });
});

// ============================================
// ERROR AGGREGATION TESTS
// ============================================

describe('Error Aggregation', () => {
  describe('AggregateError', () => {
    it('should aggregate multiple errors', () => {
      const errors = [
        new Error('Error 1'),
        new ValidationError('Error 2'),
        new NotFoundError('Resource', 'id')
      ];
      
      const aggregate = new AggregateError(errors);
      
      expect(aggregate.errors).toHaveLength(3);
      expect(aggregate.errors).toEqual(errors);
      expect(aggregate.name).toBe('AggregateError');
    });

    it('should format toString properly', () => {
      const errors = [
        new Error('First error'),
        new Error('Second error')
      ];
      
      const aggregate = new AggregateError(errors, 'Multiple failures');
      const string = aggregate.toString();
      
      expect(string).toContain('Multiple failures');
      expect(string).toContain('1. First error');
      expect(string).toContain('2. Second error');
    });
  });

  describe('ErrorCollector', () => {
    it('should collect errors without throwing', () => {
      const collector = new ErrorCollector();
      
      expect(collector.hasErrors()).toBe(false);
      
      collector.add(new Error('Error 1'));
      collector.add(new ValidationError('Error 2'));
      
      expect(collector.hasErrors()).toBe(true);
      expect(collector.getErrors()).toHaveLength(2);
    });

    it('should throw single error when only one collected', () => {
      const collector = new ErrorCollector();
      const error = new Error('Single error');
      
      collector.add(error);
      
      expect(() => collector.throwIfAny()).toThrow(error);
    });

    it('should throw AggregateError when multiple collected', () => {
      const collector = new ErrorCollector();
      
      collector.add(new Error('Error 1'));
      collector.add(new Error('Error 2'));
      
      expect(() => collector.throwIfAny()).toThrow(AggregateError);
    });

    it('should clear errors', () => {
      const collector = new ErrorCollector();
      
      collector.add(new Error('Error'));
      expect(collector.hasErrors()).toBe(true);
      
      collector.clear();
      expect(collector.hasErrors()).toBe(false);
      expect(collector.getErrors()).toHaveLength(0);
    });
  });
});

// ============================================
// VALIDATION BOUNDARY TESTS
// ============================================

describe('Validation Boundaries', () => {
  const isString = (value: unknown): value is string => typeof value === 'string';

  describe('validateInput', () => {
    it('should return validated input when valid', () => {
      const result = validateInput('hello', isString);
      expect(result).toBe('hello');
    });

    it('should throw ValidationError when invalid', () => {
      expect(() => validateInput(123, isString)).toThrow(ValidationError);
    });

    it('should use custom error message', () => {
      expect(() => validateInput(123, isString, 'Must be string'))
        .toThrow('Must be string');
    });
  });

  describe('validateBatch', () => {
    it('should separate valid and invalid items', () => {
      const items = ['hello', 123, 'world', true];
      const result = validateBatch(items, isString);
      
      expect(result.valid).toEqual(['hello', 'world']);
      expect(result.errors).toHaveLength(2);
      expect(result.errors[0].index).toBe(1);
      expect(result.errors[1].index).toBe(3);
    });

    it('should handle empty arrays', () => {
      const result = validateBatch([], isString);
      
      expect(result.valid).toHaveLength(0);
      expect(result.errors).toHaveLength(0);
    });

    it('should handle validation errors gracefully', () => {
      const throwingValidator = (value: unknown): value is string => {
        if (typeof value === 'number') {
          throw new Error('Numbers not allowed');
        }
        return typeof value === 'string';
      };
      
      const items = ['hello', 123, 'world'];
      const result = validateBatch(items, throwingValidator);
      
      expect(result.valid).toEqual(['hello', 'world']);
      expect(result.errors).toHaveLength(1);
      expect(result.errors[0].error.message).toBe('Numbers not allowed');
    });
  });
});