/**
 * UNIFIED ADDRESS SYSTEM
 * 
 * Resolves the critical address space confusion between:
 * - ROM file offsets (0x274EC) - used by Morgan's working code
 * - SNES memory addresses (0x7EF36C) - used in documentation
 * 
 * This system provides a single source of truth with automatic translation
 * between address spaces, ensuring validation accuracy and code compatibility.
 * 
 * @author Sam (Code Custodian) & Alex (Architect)
 * @critical This fixes the root cause of validation false positives
 */

// ============================================================================
// Address Space Types - Branded for Type Safety
// ============================================================================

/** ROM file offset (0x000000 - 0x100000 for 1MB ROM) */
export type ROMOffset = number & { readonly __brand: 'ROMOffset' };

/** SNES memory address (0x7E0000 - 0x7FFFFF for WRAM) */
export type SNESAddress = number & { readonly __brand: 'SNESAddress' };

/** Save initialization offset in ROM (0x274C6 region) */
export type SaveInitOffset = number & { readonly __brand: 'SaveInitOffset' };

// ============================================================================
// Address Translation Core
// ============================================================================

export class AddressTranslator {
  /**
   * Critical discovery: Save initialization data in ROM at 0x274C6+
   * maps to SNES SRAM addresses 0x7EF000+ when game loads
   */
  private static readonly SAVE_INIT_ROM_BASE = 0x274C6;
  private static readonly SNES_SRAM_BASE = 0x7EF000;
  
  /**
   * Convert SNES memory address to ROM file offset
   * This is the critical mapping that was causing validation failures
   */
  static snesAddressToROMOffset(snesAddr: SNESAddress): ROMOffset {
    // Handle save RAM addresses (0x7EF000 - 0x7EF4FF)
    if (snesAddr >= 0x7EF000 && snesAddr < 0x7EF500) {
      const sramOffset = snesAddr - this.SNES_SRAM_BASE;
      // Save init data starts at 0x274C6 in ROM
      return (this.SAVE_INIT_ROM_BASE + sramOffset) as ROMOffset;
    }
    
    // Handle other memory regions as needed
    throw new Error(`Cannot translate SNES address 0x${snesAddr.toString(16)} to ROM offset`);
  }
  
  /**
   * Convert ROM file offset to SNES memory address
   * Used for documentation and debugging
   */
  static romOffsetToSNESAddress(romOffset: ROMOffset): SNESAddress {
    // Handle save initialization region
    if (romOffset >= this.SAVE_INIT_ROM_BASE && romOffset < this.SAVE_INIT_ROM_BASE + 0x500) {
      const offset = romOffset - this.SAVE_INIT_ROM_BASE;
      return (this.SNES_SRAM_BASE + offset) as SNESAddress;
    }
    
    // Handle other ROM regions as needed
    throw new Error(`Cannot translate ROM offset 0x${romOffset.toString(16)} to SNES address`);
  }
  
  /**
   * Validate if an address is in the correct space
   */
  static isROMOffset(addr: number): addr is ROMOffset {
    return addr >= 0 && addr < 0x100000; // 1MB ROM max
  }
  
  static isSNESAddress(addr: number): addr is SNESAddress {
    // WRAM or SRAM ranges
    return (addr >= 0x7E0000 && addr < 0x800000) || 
           (addr >= 0x700000 && addr < 0x780000);
  }
}

// ============================================================================
// Unified Address Registry - Single Source of Truth
// ============================================================================

export class UnifiedAddressRegistry {
  /**
   * All addresses stored with BOTH representations
   * This ensures compatibility with existing code while fixing validation
   */
  private static readonly ADDRESSES = {
    HEALTH_CAPACITY: {
      snes: 0x7EF36C as SNESAddress,
      rom: 0x274F2 as ROMOffset,  // Morgan's verified working offset
      description: 'Maximum health (0x18=3 hearts, 0xA0=20 hearts)'
    },
    HEALTH_CURRENT: {
      snes: 0x7EF36D as SNESAddress,
      rom: 0x274F3 as ROMOffset,  // Morgan's verified working offset
      description: 'Current health'
    },
    RUPEES_LOW: {
      snes: 0x7EF360 as SNESAddress,
      rom: 0x274E6 as ROMOffset,
      description: 'Rupees low byte (little-endian)'
    },
    RUPEES_HIGH: {
      snes: 0x7EF361 as SNESAddress,
      rom: 0x274E7 as ROMOffset,
      description: 'Rupees high byte'
    },
    BOMBS: {
      snes: 0x7EF343 as SNESAddress,
      rom: 0x274C9 as ROMOffset,
      description: 'Bomb count'
    },
    ARROWS: {
      snes: 0x7EF377 as SNESAddress,
      rom: 0x274FD as ROMOffset,
      description: 'Arrow count'
    },
    MAGIC: {
      snes: 0x7EF36E as SNESAddress,
      rom: 0x274F4 as ROMOffset,
      description: 'Magic power (0x00=empty, 0x80=full)'
    }
  } as const;
  
  /**
   * Get address in the format needed by the caller
   * This allows existing code to work unchanged
   */
  static getAddress(item: keyof typeof UnifiedAddressRegistry.ADDRESSES, format: 'rom'): ROMOffset;
  static getAddress(item: keyof typeof UnifiedAddressRegistry.ADDRESSES, format: 'snes'): SNESAddress;
  static getAddress(item: keyof typeof UnifiedAddressRegistry.ADDRESSES, format: 'rom' | 'snes') {
    const entry = this.ADDRESSES[item];
    return format === 'rom' ? entry.rom : entry.snes;
  }
  
  /**
   * Get all addresses in a specific format
   * Used for validation and documentation
   */
  static getAllAddresses(format: 'rom' | 'snes') {
    const result: Record<string, number> = {};
    for (const [key, value] of Object.entries(this.ADDRESSES)) {
      result[key] = format === 'rom' ? value.rom : value.snes;
    }
    return result;
  }
  
  /**
   * Validate an address exists in our registry
   */
  static isKnownAddress(addr: number): boolean {
    for (const entry of Object.values(this.ADDRESSES)) {
      if (entry.rom === addr || entry.snes === addr) {
        return true;
      }
    }
    return false;
  }
}

// ============================================================================
// Migration Helpers - Safe Transition from Old Code
// ============================================================================

export class AddressMigration {
  /**
   * Detect which address space old code is using
   * Critical for safe migration without breaking existing mods
   */
  static detectAddressSpace(addr: number): 'rom' | 'snes' | 'unknown' {
    // ROM offsets in save init region
    if (addr >= 0x274C6 && addr < 0x27500) {
      return 'rom';
    }
    
    // SNES SRAM addresses
    if (addr >= 0x7EF000 && addr < 0x7EF500) {
      return 'snes';
    }
    
    // Could be either - need context
    if (addr < 0x8000) {
      return 'unknown';
    }
    
    return AddressTranslator.isSNESAddress(addr) ? 'snes' : 'rom';
  }
  
  /**
   * Migrate old address to unified system
   * Preserves functionality while fixing validation
   */
  static migrateAddress(oldAddr: number, knownSpace?: 'rom' | 'snes'): {
    rom: ROMOffset;
    snes: SNESAddress;
    confidence: 'high' | 'medium' | 'low';
  } {
    const space = knownSpace || this.detectAddressSpace(oldAddr);
    
    if (space === 'rom') {
      return {
        rom: oldAddr as ROMOffset,
        snes: AddressTranslator.romOffsetToSNESAddress(oldAddr as ROMOffset),
        confidence: 'high'
      };
    }
    
    if (space === 'snes') {
      return {
        rom: AddressTranslator.snesAddressToROMOffset(oldAddr as SNESAddress),
        snes: oldAddr as SNESAddress,
        confidence: 'high'
      };
    }
    
    // Unknown space - make best guess
    return {
      rom: oldAddr as ROMOffset,
      snes: (0x7E0000 + oldAddr) as SNESAddress,
      confidence: 'low'
    };
  }
}

// ============================================================================
// Validation System Fix
// ============================================================================

export class UnifiedValidator {
  /**
   * Validate ROM modifications using correct address space
   * This fixes the false positive issue in our validation reports
   */
  static validateModification(
    originalROM: Buffer,
    modifiedROM: Buffer,
    expectedChanges: Array<{ address: number; value: number; space?: 'rom' | 'snes' }>
  ): {
    passed: boolean;
    issues: string[];
  } {
    const issues: string[] = [];
    
    for (const change of expectedChanges) {
      // Detect or use specified address space
      const space = change.space || AddressMigration.detectAddressSpace(change.address);
      
      // Get ROM offset for validation
      let romOffset: number;
      if (space === 'snes') {
        try {
          romOffset = AddressTranslator.snesAddressToROMOffset(change.address as SNESAddress);
        } catch (e) {
          issues.push(`Cannot translate SNES address 0x${change.address.toString(16)} to ROM offset`);
          continue;
        }
      } else {
        romOffset = change.address;
      }
      
      // Validate the change at the correct offset
      const actualValue = modifiedROM[romOffset];
      if (actualValue !== change.value) {
        issues.push(
          `Address 0x${change.address.toString(16)} (${space}): ` +
          `expected ${change.value}, got ${actualValue} at ROM offset 0x${romOffset.toString(16)}`
        );
      }
    }
    
    return {
      passed: issues.length === 0,
      issues
    };
  }
}

// ============================================================================
// Export Compatibility Layer
// ============================================================================

/**
 * Compatibility exports for existing code
 * Allows gradual migration without breaking changes
 */
export const ROMAddresses = UnifiedAddressRegistry.getAllAddresses('rom');
export const SNESAddresses = UnifiedAddressRegistry.getAllAddresses('snes');

/**
 * Helper to create properly typed addresses
 */
export function toROMOffset(addr: number): ROMOffset {
  if (!AddressTranslator.isROMOffset(addr)) {
    throw new Error(`Invalid ROM offset: 0x${addr.toString(16)}`);
  }
  return addr as ROMOffset;
}

export function toSNESAddress(addr: number): SNESAddress {
  if (!AddressTranslator.isSNESAddress(addr)) {
    throw new Error(`Invalid SNES address: 0x${addr.toString(16)}`);
  }
  return addr as SNESAddress;
}

// Default export for convenience
export default {
  AddressTranslator,
  UnifiedAddressRegistry,
  AddressMigration,
  UnifiedValidator,
  toROMOffset,
  toSNESAddress
};