.BANK 17 SLOT 0
.ORG $0000

.SECTION "Bank17" FORCE

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00000F.l		; 0F 0F 00 00 ; OR accumulator with memory (long) $00000F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $D020.w		; 20 20 D0 ; Jump to subroutine at $D020.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $68		; 10 68 ; Branch if plus to $10, $68 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $003F00.l,X		; 1F 00 3F 00 ; Logical OR long $003F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $001F00.l,X		; 3F 00 1F 00 ; AND accumulator with memory (long,X) $001F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F3F3F.l,X		; 1F 3F 3F 1F ; Logical OR long $1F3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0D1F02.l		; 0F 02 1F 0D ; OR accumulator with memory (long) $0D1F02.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $0019.w,Y		; 39 19 00 ; AND accumulator with memory $0019.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($15.b)		; 12 15 ; OR accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $48		; B0 48 ; Branch if carry set to $B0, $48 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sty $34.b		; 84 34 ; Store Y register to $34.b [Reads: Y Index]
	cmp $2A.b,X		; D5 2A ; Compare accumulator $2A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cmp #$95.b		; C9 95 ; Compare #$95.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	.db $62, $C5, $B9		; 62 C5 B9 ; Push effective relative address $62, $C5, $B9 [Writes: Stack Pointer]
	jmp ($1044.w,X)		; 7C 44 10 ; Jump indirect indexed to ($1044.w,X) [Reads: X Index] [Flow: jump]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $2838.w,X		; 7E 38 28 ; Rotate right $2838.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $D6C9.w,Y		; 39 C9 D6 ; AND accumulator with memory $D6C9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $38.b,X		; 36 38 ; Rotate left $38.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $01202F.l		; 0F 2F 20 01 ; OR accumulator with memory (long) $01202F.l [Writes: Accumulator] [Flags: ZN]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsr ($E1F0.w,X)		; FC F0 E1 ; Jump to subroutine indirect indexed ($E1F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc [$7F.b],Y		; F7 7F ; Subtract with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $C3041E.l,X		; 1F 1E 04 C3 ; Logical OR long $C3041E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stz $6F00.w		; 9C 00 6F ; Store zero to $6F00.w
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	eor [$54.b]		; 47 54 ; Exclusive OR accumulator with memory (long) [$54.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta ($8B.b,S),Y		; 93 8B ; Store accumulator (stack relative indirect indexed) ($8B.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $EFFFFF.l,X		; 7F FF FF EF ; Add long $EFFFFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$8F.b]		; E7 8F ; Subtract with carry (long) [$8F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Accumulator, X Index, Direct Page]
	ldx #$21.b		; A2 21 ; Load #$21.b into X register [Writes: X Index] [Flags: ZN]
	eor $3282.w		; 4D 82 32 ; Exclusive OR $3282.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cpy $718D.w		; CC 8D 71 ; Compare $718D.w with Y register [Reads: Y Index] [Flags: ZNC]
	adc ($02.b)		; 72 02 ; Add with carry (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $FEFFFF.l,X		; DF FF FF FE ; Compare accumulator (long,X) $FEFFFF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	jsr ($20F8.w,X)		; FC F8 20 ; Jump to subroutine indirect indexed ($20F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr $501F.w		; 20 1F 50 ; Jump to subroutine at $501F.w [Writes: Stack Pointer] [Flow: call]
	jmp $5C60.w		; 4C 60 5C ; Jump to $5C60.w [Flow: jump]
	ldy $9B.b		; A4 9B ; Load $9B.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	wai		; CB ; Wait for interrupt
	.db $30, $08		; 30 08 ; Branch if minus to $30, $08 [Flow: branch]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	sbc $3F3FFF.l,X		; FF FF 3F 3F ; Subtract with carry (long,X) $3F3FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $A7FFFF.l,X		; 7F FF FF A7 ; Add long $A7FFFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($69.b,X)		; 21 69 ; Logical AND ($69.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	lda $55.b		; A5 55 ; Load $55.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit #$0A.b		; 89 0A ; Test bits #$0A.b with accumulator [Reads: Accumulator] [Flags: Z]
	sbc ($C4.b)		; F2 C4 ; Subtract with carry (indirect) ($C4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	.db $70, $C0		; 70 C0 ; Branch if overflow set to $70, $C0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	dec $FEDE.w		; CE DE FE ; Decrement $FEDE.w [Flags: ZN]
	jsr ($80F8.w,X)		; FC F8 80 ; Jump to subroutine indirect indexed ($80F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	eor ($4E.b),Y		; 51 4E ; Exclusive OR accumulator with memory ($4E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ldx #$9C.b		; A2 9C ; Load #$9C.b into X register [Writes: X Index] [Flags: ZN]
	eor $39.b		; 45 39 ; Exclusive OR $39.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($14.b)		; 72 14 ; Add with carry (indirect) ($14.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $14.b		; E4 14 ; Compare $14.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx $29.b		; E4 29 ; Compare $29.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	eor ($91.b)		; 52 91 ; Exclusive OR accumulator with memory (indirect) ($91.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $FCFE7F.l,X		; 3F 7F FE FC ; AND accumulator with memory (long,X) $FCFE7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $E7F3.w,Y		; F9 F3 E7 ; Subtract with carry $E7F3.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $66.b,Y		; 96 66 ; Store X register $66.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	trb $24.b		; 14 24 ; Test and reset bits $24.b [Reads: Accumulator] [Flags: Z]
	trb $24.b		; 14 24 ; Test and reset bits $24.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	ldy #$20.b		; A0 20 ; Load #$20.b into Y register [Writes: Y Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: ZNC]
	sta $509FA0.l,X		; 9F A0 9F 50 ; Store accumulator (long,X) $509FA0.l,X [Reads: Accumulator, X Index]
	eor $2C4758.l		; 4F 58 47 2C ; Exclusive OR accumulator with memory (long) $2C4758.l [Writes: Accumulator] [Flags: ZN]
	and $13.b,S		; 23 13 ; AND accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	adc $3F3F7F.l,X		; 7F 7F 3F 3F ; Add long $3F3F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00030F.l,X		; 1F 0F 03 00 ; Logical OR long $00030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $F9.b		; 05 F9 ; Logical OR $F9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $F9.b		; 05 F9 ; Logical OR $F9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc ($1A.b)		; F2 1A ; Subtract with carry (indirect) ($1A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
.ACCU 8
.INDEX 8
	sep #$34		; E2 34
	cpy $C8.b		; C4 C8 ; Compare $C8.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	inc $FCFE.w,X		; FE FE FC ; Increment memory $FCFE.w,X [Reads: X Index] [Flags: ZN]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	trb $13.b		; 14 13 ; Test and reset bits $13.b [Reads: Accumulator] [Flags: Z]
	asl $11.b,X		; 16 11 ; Arithmetic shift left $11.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03070F.l		; 0F 0F 07 03 ; OR accumulator with memory (long) $03070F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	jsr $C020.w		; 20 20 C0 ; Jump to subroutine at $C020.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1B3B.w		; 1C 3B 1B ; Test and reset bits $1B3B.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $1F0C.w		; 1C 0C 1F ; Test and reset bits $1F0C.w [Reads: Accumulator] [Flags: Z]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $27.b		; 24 27 ; Test bits $27.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	bit $DC08.w		; 2C 08 DC ; Test bits $DC08.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	trb $3818.w		; 1C 18 38 ; Test and reset bits $3818.w [Reads: Accumulator] [Flags: Z]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E4.b		; 24 E4 ; Test bits $E4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$19.b		; 09 19 ; Logical OR #$19.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $1C		; 90 1C ; Branch if carry clear to $90, $1C [Flow: branch]
	ora ($26.b,S),Y		; 13 26 ; OR accumulator (stack relative indirect indexed) ($26.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($12.b,X)		; 21 12 ; Logical AND ($12.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($0B.b),Y		; 11 0B ; OR accumulator with memory ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $2D		; 10 2D ; Branch if plus to $10, $2D [Flow: branch]
	jsr $2A37.w		; 20 37 2A ; Jump to subroutine at $2A37.w [Writes: Stack Pointer] [Flow: call]
	and $170F1F.l		; 2F 1F 0F 17 ; AND accumulator with memory (long) $170F1F.l [Writes: Accumulator] [Flags: ZN]
	and $5D1F2F.l,X		; 3F 2F 1F 5D ; AND accumulator with memory (long,X) $5D1F2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cmp ($3E.b)		; D2 3E ; Compare accumulator (indirect) ($3E.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	rep #$05		; C2 05 ; Reset processor status bits #$05 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc ($12.b,X)		; E1 12 ; Subtract with carry ($12.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
.INDEX 8
	sep #$94		; E2 94
	stz $99.b		; 64 99 ; Store zero to $99.b
	adc ($8D.b,X)		; 61 8D ; Add with carry ($8D.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($0D.b),Y		; 71 0D ; Add with carry ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($FC.b),Y		; F1 FC ; Subtract with carry ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($FCFE.w,X)		; FC FE FC ; Jump to subroutine indirect indexed ($FCFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	inc $FEFE.w,X		; FE FE FE ; Increment memory $FEFE.w,X [Reads: X Index] [Flags: ZN]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	jsl $020A22.l		; 22 22 0A 02 ; Jump to subroutine long $020A22.l [Writes: Stack Pointer] [Flow: call]
	sta ($8C.b,S),Y		; 93 8C ; Store accumulator (stack relative indirect indexed) ($8C.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$75.b]		; 07 75 ; OR accumulator with memory (long) [$75.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and ($0D.b,S),Y		; 33 0D ; AND accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b)		; 12 0C ; OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $7F3D.w		; 1C 3D 7F ; Test and reset bits $7F3D.w [Reads: Accumulator] [Flags: Z]
	sbc $7F7EFF.l,X		; FF FF 7E 7F ; Subtract with carry (long,X) $7F7EFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	stz $14.b		; 64 14 ; Store zero to $14.b
	ldy $84.b,X		; B4 84 ; Load Y register $84.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,X		; 35 00 ; Logical AND $00.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $370005.l		; 0F 05 00 37 ; OR accumulator with memory (long) $370005.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $54.b		; A5 54 ; Load $54.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($00.b),Y		; 51 00 ; Exclusive OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $03.b,S		; 83 03 ; Store accumulator (stack relative) $03.b,S [Reads: Accumulator, Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $29		; 80 29 ; Branch always to $80, $29 [Flow: branch]
	eor ($2C.b,X)		; 41 2C ; Exclusive OR accumulator with memory ($2C.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $048C.w		; 20 8C 04 ; Jump to subroutine at $048C.w [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $6ECEFC.l,X		; 7F FC CE 6E ; Add long $6ECEFC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $8AAC.w		; 2E AC 8A ; Rotate left $8AAC.w [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $10.b,X		; 16 10 ; Arithmetic shift left $10.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $12.b,X		; 15 12 ; OR accumulator with memory $12.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	and #$26.b		; 29 26 ; Logical AND #$26.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $170F.w		; 0E 0F 17 ; Arithmetic shift left $170F.w [Flags: ZNC]
	ora $C01F1F.l		; 0F 1F 1F C0 ; OR accumulator with memory (long) $C01F1F.l [Writes: Accumulator] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $A4		; 50 A4 ; Branch if overflow clear to $50, $A4 [Flow: branch]
	sty $52.b		; 84 52 ; Store Y register to $52.b [Reads: Y Index]
	jsl $286098.l		; 22 98 60 28 ; Jump to subroutine long $286098.l [Writes: Stack Pointer] [Flow: call]
	.db $D0, $DA		; D0 DA ; Branch if not equal to $D0, $DA [Flow: branch]
	jsl $A0E000.l		; 22 00 E0 A0 ; Jump to subroutine long $A0E000.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($0F0F.w,X)		; FC 0F 0F ; Jump to subroutine indirect indexed ($0F0F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and ($30.b)		; 32 30 ; AND accumulator with memory (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $2420.w		; 2E 20 24 ; Rotate left $2420.w [Flags: ZNC]
	jsr $1212.w		; 20 12 12 ; Jump to subroutine at $1212.w [Writes: Stack Pointer] [Flow: call]
	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C1F1F.l		; 0F 1F 1F 0C ; OR accumulator with memory (long) $0C1F1F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $AA.b,X		; B4 AA ; Load Y register $AA.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $ED.b,X		; F5 ED ; Subtract $ED.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda #$A9.b		; A9 A9 ; Load #$A9.b into accumulator [Writes: Accumulator] [Flags: ZN]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	ldy #$80.b		; A0 80 ; Load #$80.b into Y register [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $1A.b,X		; 74 1A ; Store zero to $1A.b,X [Reads: X Index]
	lsr $18.b,X		; 56 18 ; Logical shift right $18.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora #$1C.b		; 09 1C ; Logical OR #$1C.b with accumulator [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $A0.b		; 04 A0 ; Test and set bits $A0.b [Reads: Accumulator] [Flags: Z]
	jsr $9010.w		; 20 10 90 ; Jump to subroutine at $9010.w [Writes: Stack Pointer] [Flow: call]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: ZN]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$B0.b		; A0 B0 ; Load #$B0.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $70, $28		; 70 28 ; Branch if overflow set to $70, $28 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0020.w		; 20 20 00 ; Jump to subroutine at $0020.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2070.w		; 20 70 20 ; Jump to subroutine at $2070.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0A70.w		; 20 70 0A ; Jump to subroutine at $0A70.w [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $24.b		; 25 24 ; Logical AND $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and ($5D.b,X)		; 21 5D ; Logical AND ($5D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $42, $5A		; 42 5A ; Reserved instruction
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $64.b		; 65 64 ; Add $64.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	trb $031C.w		; 1C 1C 03 ; Test and reset bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $31.b,S		; 03 31 ; OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $1B3F3F.l,X		; 1F 3F 3F 1B ; Logical OR long $1B3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	ldx $46.b,Y		; B6 46 ; Load X register $46.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $82, $66, $66		; 82 66 66 ; Branch always long to $82, $66, $66 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $90, $D0		; 90 D0 ; Branch if carry clear to $90, $D0 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jmp ($8098.w,X)		; 7C 98 80 ; Jump indirect indexed to ($8098.w,X) [Reads: X Index] [Flow: jump]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $454A.w		; 8D 4A 45 ; Store accumulator to $454A.w [Reads: Accumulator]
	eor $8D42.w,X		; 5D 42 8D ; Exclusive OR accumulator with memory $8D42.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $82, $5E, $41		; 82 5E 41 ; Branch always long to $82, $5E, $41 [Flow: branch]
	jsl $191920.l		; 22 20 19 19 ; Jump to subroutine long $191920.l [Writes: Stack Pointer] [Flow: call]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $7F3F3F.l,X		; 7F 3F 3F 7F ; Add long $7F3F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00061F.l,X		; 3F 1F 06 00 ; AND accumulator with memory (long,X) $00061F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $52		; 80 52 ; Branch always to $80, $52 [Flow: branch]
	.db $82, $AA, $42		; 82 AA 42 ; Branch always long to $82, $AA, $42 [Flow: branch]
	ora $21.b,X		; 15 21 ; OR accumulator with memory $21.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	stx $240E.w		; 8E 0E 24 ; Store X register to $240E.w [Reads: X Index]
	bit $B8.b		; 24 B8 ; Test bits $B8.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	inc $FCFC.w,X		; FE FC FC ; Increment memory $FCFC.w,X [Reads: X Index] [Flags: ZN]
	inc $D8F0.w,X		; FE F0 D8 ; Increment memory $D8F0.w,X [Reads: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	ora [$9C.b]		; 07 9C ; OR accumulator with memory (long) [$9C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	jsl $404921.l		; 22 21 49 40 ; Jump to subroutine long $404921.l [Writes: Stack Pointer] [Flow: call]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc ($6E.b),Y		; 71 6E ; Add with carry ($6E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor [$3F.b]		; 47 3F ; Exclusive OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3FDF07.l,X		; 1F 07 DF 3F ; Logical OR long $3FDF07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $983F1F.l,X		; 7F 1F 3F 98 ; Add long $983F1F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	bit $C4.b,X		; 34 C4 ; Test bits $C4.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $C4.b,X		; 34 C4 ; Test bits $C4.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	.db $62, $56, $26		; 62 56 26 ; Push effective relative address $62, $56, $26 [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $F4E8F0.l		; 22 F0 E8 F4 ; Jump to subroutine long $F4E8F0.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	jsr ($FCF8.w,X)		; FC F8 FC ; Jump to subroutine indirect indexed ($FCF8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	trb $11.b		; 14 11 ; Test and reset bits $11.b [Reads: Accumulator] [Flags: Z]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: ZNC]
	ora $90.b,S		; 03 90 ; OR accumulator with stack relative $90.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$1050]		; DC 50 10 ; Jump long indirect [$1050] [Flow: jump]
	jsl $000004.l		; 22 04 00 00 ; Jump to subroutine long $000004.l [Writes: Stack Pointer] [Flow: call]
	cpy #$2B.b		; C0 2B ; Compare #$2B.b with Y register [Reads: Y Index] [Flags: ZNC]
	bit $14.b		; 24 14 ; Test bits $14.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: ZNC]
	.db $10, $39		; 10 39 ; Branch if plus to $10, $39 [Flow: branch]
	jsr $0814.w		; 20 14 08 ; Jump to subroutine at $0814.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01060F.l,X		; 1F 0F 06 01 ; Logical OR long $01060F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $1F3E.w,X		; 1D 3E 1F ; OR accumulator with memory $1F3E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $04.b,X		; 34 04 ; Test bits $04.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	stz $04.b,X		; 74 04 ; Store zero to $04.b,X [Reads: X Index]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $D4		; 80 D4 ; Branch always to $80, $D4 [Flow: branch]
	mvp $08,$08		; 44 08 08 ; Move block positive $08,$08 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	jsr ($B87E.w,X)		; FC 7E B8 ; Jump to subroutine indirect indexed ($B87E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $B0, $30		; B0 30 ; Branch if carry set to $B0, $30 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0104.w		; 20 04 01 ; Jump to subroutine at $0104.w [Writes: Stack Pointer] [Flow: call]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $183C.w		; 0C 3C 18 ; Test and set bits $183C.w [Reads: Accumulator] [Flags: Z]
	ora $000E.w,X		; 1D 0E 00 ; OR accumulator with memory $000E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $4000.w		; 20 00 40 ; Jump to subroutine at $4000.w [Writes: Stack Pointer] [Flow: call]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1050.w		; 20 50 10 ; Jump to subroutine at $1050.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $80.b		; 02 80 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $08011C.l		; 22 1C 01 08 ; Jump to subroutine long $08011C.l [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and ($54.b,X)		; 21 54 ; Logical AND ($54.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F3F3F.l		; 0F 3F 3F 1F ; OR accumulator with memory (long) $1F3F3F.l [Writes: Accumulator] [Flags: ZN]
	and $800000.l,X		; 3F 00 00 80 ; AND accumulator with memory (long,X) $800000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sty $74.b		; 84 74 ; Store Y register to $74.b [Reads: Y Index]
	mvn $2A,$A4		; 54 A4 2A ; Move block negative $2A,$A4 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	rep #$00		; C2 00 ; Reset processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $13.b		; 14 13 ; Test and reset bits $13.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	and [$28.b]		; 27 28 ; AND accumulator with memory (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3C1F1F.l		; 0F 1F 1F 3C ; OR accumulator with memory (long) $3C1F1F.l [Writes: Accumulator] [Flags: ZN]
	bit $C3C3.w,X		; 3C C3 C3 ; Test bits $C3C3.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $C300.w,X		; 3C 00 C3 ; Test bits $C300.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $FF00.w,X		; 3C 00 FF ; Test bits $FF00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora #$14.b		; 09 14 ; Logical OR #$14.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($28.b,S),Y		; 13 28 ; OR accumulator (stack relative indirect indexed) ($28.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $700F0F.l,X		; 1F 0F 0F 70 ; Logical OR long $700F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $8F		; 70 8F ; Branch if overflow set to $70, $8F [Flow: branch]
	.db $80, $70		; 80 70 ; Branch always to $80, $70 [Flow: branch]
	ora $007F80.l		; 0F 80 7F 00 ; OR accumulator with memory (long) $007F80.l [Writes: Accumulator] [Flags: ZN]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7F0F00.l,X		; FF 00 0F 7F ; Subtract with carry (long,X) $7F0F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $14.b,S		; 23 14 ; AND accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0001.w		; 0C 01 00 ; Test and set bits $0001.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and [$0B.b],Y		; 37 0B ; AND accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0303.w,X		; 1D 03 03 ; OR accumulator with memory $0303.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $4B0C.w		; 2C 0C 4B ; Test bits $4B0C.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	.db $30, $1C		; 30 1C ; Branch if minus to $30, $1C [Flow: branch]
	and $60.b,S		; 23 60 ; AND accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $6080.w		; 1C 80 60 ; Test and reset bits $6080.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $80, $14		; 80 14 ; Branch always to $80, $14 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr $FF33.w		; 20 33 FF ; Jump to subroutine at $FF33.w [Writes: Stack Pointer] [Flow: call]
	sbc $88E8FC.l,X		; FF FC E8 88 ; Subtract with carry (long,X) $88E8FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $0000.w,X		; 3E 00 00 ; Rotate left $0000.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $08001C.l		; 22 1C 00 08 ; Jump to subroutine long $08001C.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $000808.l,X		; 7F 08 08 00 ; Add long $000808.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $00001C.l		; 22 1C 00 00 ; Jump to subroutine long $00001C.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $000000.l,X		; 7F 00 00 00 ; Add long $000000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $44		; 10 44 ; Branch if plus to $10, $44 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	jmp ($1010.w,X)		; 7C 10 10 ; Jump indirect indexed to ($1010.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $44		; 10 44 ; Branch if plus to $10, $44 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $003F00.l,X		; 1F 00 3F 00 ; Logical OR long $003F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $001F00.l,X		; 3F 00 1F 00 ; AND accumulator with memory (long,X) $001F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F3F3F.l,X		; 1F 3F 3F 1F ; Logical OR long $1F3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0D1F02.l		; 0F 02 1F 0D ; OR accumulator with memory (long) $0D1F02.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $0019.w,Y		; 39 19 00 ; AND accumulator with memory $0019.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($15.b)		; 12 15 ; OR accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $48		; B0 48 ; Branch if carry set to $B0, $48 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sty $54.b		; 84 54 ; Store Y register to $54.b [Reads: Y Index]
	eor $2A.b,S		; 43 2A ; Exclusive OR accumulator with stack relative $2A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($28.b,X)		; 21 28 ; Logical AND ($28.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($14.b,X)		; 21 14 ; Logical AND ($14.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($08.b,S),Y		; 13 08 ; OR accumulator (stack relative indirect indexed) ($08.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $070F1F.l,X		; 1F 1F 0F 07 ; Logical OR long $070F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.INDEX 16
	rep #$54		; C2 54
	sty $94.b		; 84 94 ; Store Y register to $94.b [Reads: Y Index]
	tsb $68.b		; 04 68 ; Test and set bits $68.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	sty $38.b		; 84 38 ; Store Y register to $38.b [Reads: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $90		; 70 90 ; Branch if overflow set to $70, $90 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $A04F50.l		; 4F 50 4F A0 ; Exclusive OR accumulator with memory (long) $A04F50.l [Writes: Accumulator] [Flags: ZN]
	sta $A09FA0.l,X		; 9F A0 9F A0 ; Store accumulator (long,X) $A09FA0.l,X [Reads: Accumulator, X Index]
	sta $509FA0.l,X		; 9F A0 9F 50 ; Store accumulator (long,X) $509FA0.l,X [Reads: Accumulator, X Index]
	eor $3F4F50.l		; 4F 50 4F 3F ; Exclusive OR accumulator with memory (long) $3F4F50.l [Writes: Accumulator] [Flags: ZN]
	and $7F7F7F.l,X		; 3F 7F 7F 7F ; AND accumulator with memory (long,X) $7F7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $003F3F.l,X		; 7F 3F 3F 00 ; Add long $003F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $28FFFF.l,X		; FF FF FF 28 ; Subtract with carry (long,X) $28FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$50.b]		; 27 50 ; AND accumulator with memory (long) [$50.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $504F50.l		; 4F 50 4F 50 ; Exclusive OR accumulator with memory (long) $504F50.l [Writes: Accumulator] [Flags: ZN]
	eor $A09FA0.l		; 4F A0 9F A0 ; Exclusive OR accumulator with memory (long) $A09FA0.l [Writes: Accumulator] [Flags: ZN]
	sta $A09FA0.l,X		; 9F A0 9F A0 ; Store accumulator (long,X) $A09FA0.l,X [Reads: Accumulator, X Index]
	sta $3F3F1F.l,X		; 9F 1F 3F 3F ; Store accumulator (long,X) $3F3F1F.l,X [Reads: Accumulator, X Index]
	and $7F7F7F.l,X		; 3F 7F 7F 7F ; AND accumulator with memory (long,X) $7F7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $0CFC03.l,X		; 7F 03 FC 0C ; Add long $0CFC03.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	cpx #$C020.w		; E0 20 C0 ; Compare #$C020.w with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($E0F0.w,X)		; FC F0 E0 ; Jump to subroutine indirect indexed ($E0F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$80C0.w		; C0 C0 80 ; Compare #$80C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $1C		; 80 1C ; Branch always to $80, $1C [Flow: branch]
	ora ($28.b)		; 12 28 ; OR accumulator with memory (indirect) ($28.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $49.b		; 24 49 ; Test bits $49.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $B2.b		; 04 B2 ; Test and set bits $B2.b [Reads: Accumulator] [Flags: Z]
	eor #$51.b		; 49 51 ; Exclusive OR #$51.b with accumulator [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	ldy #$A090.w		; A0 90 A0 ; Load #$A090.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $90, $0E		; 90 0E ; Branch if carry clear to $90, $0E [Flow: branch]
	ora $FF7D.w,X		; 1D 7D FF ; OR accumulator with memory $FF7D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $7079.w,Y		; 79 79 70 ; Add $7079.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $0A		; 70 0A ; Branch if overflow set to $70, $0A [Flow: branch]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $50		; 10 50 ; Branch if plus to $10, $50 [Flow: branch]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $50F812.l		; 0F 12 F8 50 ; OR accumulator with memory (long) $50F812.l [Writes: Accumulator] [Flags: ZN]
	cpx #$0040.w		; E0 40 00 ; Compare #$0040.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $0020.w		; 20 20 00 ; Jump to subroutine at $0020.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$20.b]		; 27 20 ; AND accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr $0020.w		; 20 20 00 ; Jump to subroutine at $0020.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	cpy #$8000.w		; C0 00 80 ; Compare #$8000.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $40.b,S		; 03 40 ; OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($A1.b,X)		; 01 A1 ; Logical OR ($A1.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor ($E1.b,X)		; 41 E1 ; Exclusive OR accumulator with memory ($E1.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1B3B.w		; 1C 3B 1B ; Test and reset bits $1B3B.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $1F0C.w		; 1C 0C 1F ; Test and reset bits $1F0C.w [Reads: Accumulator] [Flags: Z]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $27.b		; 24 27 ; Test bits $27.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	bit $DC08.w		; 2C 08 DC ; Test bits $DC08.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	trb $3818.w		; 1C 18 38 ; Test and reset bits $3818.w [Reads: Accumulator] [Flags: Z]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($24.b)		; D4 24 ; Push effective indirect address ($24.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cpx $C8.b		; E4 C8 ; Compare $C8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $00,$00		; 44 00 00 ; Move block positive $00,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0020.w		; 20 20 00 ; Jump to subroutine at $0020.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsl $081414.l		; 22 14 14 08 ; Jump to subroutine long $081414.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0008.w		; 1C 08 00 ; Test and reset bits $0008.w [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $D020.w		; 20 20 D0 ; Jump to subroutine at $D020.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $E8		; 90 E8 ; Branch if carry clear to $90, $E8 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pei ($04.b)		; D4 04 ; Push effective indirect address ($04.b) [Reads: Direct Page] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $10.b		; 14 10 ; Test and reset bits $10.b [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	and $2A.b,S		; 23 2A ; AND accumulator with stack relative $2A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $00222A.l		; 22 2A 22 00 ; Jump to subroutine long $00222A.l [Writes: Stack Pointer] [Flow: call]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $1C1C.w		; 1C 1C 1C ; Test and reset bits $1C1C.w [Reads: Accumulator] [Flags: Z]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	clv		; B8 ; Clear overflow flag [Flags: V]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy $04.b		; C4 04 ; Compare $04.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	cop $4D.b		; 02 4D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($B5.b,X)		; 41 B5 ; Exclusive OR accumulator with memory ($B5.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda ($15.b),Y		; B1 15 ; Load accumulator ($15.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0EBE.w,X)		; FC BE 0E ; Jump to subroutine indirect indexed ($0EBE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $70700F.l		; 0F 0F 70 70 ; OR accumulator with memory (long) $70700F.l [Writes: Accumulator] [Flags: ZN]
	sta $000080.l		; 8F 80 00 00 ; Store accumulator (long) $000080.l [Reads: Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00007F.l		; 0F 7F 00 00 ; OR accumulator with memory (long) $00007F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $21.b		; 25 21 ; Logical AND $21.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $42, $BA		; 42 BA ; Reserved instruction
	.db $82, $54, $44		; 82 54 44 ; Branch always long to $82, $54, $44 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $7C3C.w,X		; 1E 3C 7C ; Arithmetic shift left $7C3C.w,X [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	pei ($C4.b)		; D4 C4 ; Push effective indirect address ($C4.b) [Reads: Direct Page] [Writes: Stack Pointer]
	mvn $54,$44		; 54 44 54 ; Move block negative $54,$44 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	mvp $22,$2A		; 44 2A 22 ; Move block positive $22,$2A [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsl $F8F0E0.l		; 22 E0 F0 F8 ; Jump to subroutine long $F8F0E0.l [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $041C.w		; 1C 1C 04 ; Test and reset bits $041C.w [Reads: Accumulator] [Flags: Z]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cop $15.b		; 02 15 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($15.b),Y		; 11 15 ; OR accumulator with memory ($15.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($2A.b),Y		; 11 2A ; OR accumulator with memory ($2A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $202A.w		; 20 2A 20 ; Jump to subroutine at $202A.w [Writes: Stack Pointer] [Flow: call]
	eor ($40.b)		; 52 40 ; Exclusive OR accumulator with memory (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	asl $1F1F.w		; 0E 1F 1F ; Arithmetic shift left $1F1F.w [Flags: ZNC]
	and $04047F.l,X		; 3F 7F 04 04 ; AND accumulator with memory (long,X) $04047F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $000E.w		; 0E 0E 00 ; Arithmetic shift left $000E.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2C.b,S),Y		; 13 2C ; OR accumulator (stack relative indirect indexed) ($2C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $405F.w		; 20 5F 40 ; Jump to subroutine at $405F.w [Writes: Stack Pointer] [Flow: call]
	eor ($40.b),Y		; 51 40 ; Exclusive OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $44.b,X		; 55 44 ; Exclusive OR accumulator with memory $44.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $05.b,X		; 75 05 ; Add $05.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda #$89.b		; A9 89 ; Load #$89.b into accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $3F1F.w		; 0C 1F 3F ; Test and set bits $3F1F.w [Reads: Accumulator] [Flags: Z]
	and $F8713B.l,X		; 3F 3B 71 F8 ; AND accumulator with memory (long,X) $F8713B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy #$A020.w		; A0 20 A0 ; Load #$A020.w into Y register [Writes: Y Index] [Flags: ZN]
	jsr $1050.w		; 20 50 10 ; Jump to subroutine at $1050.w [Writes: Stack Pointer] [Flow: call]
	.db $50, $10		; 50 10 ; Branch if overflow clear to $50, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$E0C0.w		; C0 C0 E0 ; Compare #$E0C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$0000.w		; E0 00 00 ; Compare #$0000.w with X register [Reads: X Index] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $24.b		; 25 24 ; Logical AND $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc $40.b		; 65 40 ; Add $40.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cop $B5.b		; 02 B5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $1078FD.l,X		; 3F FD 78 10 ; AND accumulator with memory (long,X) $1078FD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$2828.w		; C0 28 28 ; Compare #$2828.w with Y register [Reads: Y Index] [Flags: ZNC]
	pei ($14.b)		; D4 14 ; Push effective indirect address ($14.b) [Reads: Direct Page] [Writes: Stack Pointer]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cop $DD.b		; 02 DD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($2A.b,X)		; C1 2A ; Compare accumulator ($2A.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	jsl $000000.l		; 22 00 00 00 ; Jump to subroutine long $000000.l [Writes: Stack Pointer] [Flow: call]
	cpy #$FCE8.w		; C0 E8 FC ; Compare #$FCE8.w with Y register [Reads: Y Index] [Flags: ZNC]
	rol $011C.w,X		; 3E 1C 01 ; Rotate left $011C.w,X [Reads: X Index] [Flags: ZNC]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $20.b		; 24 20 ; Test bits $20.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $42, $B8		; 42 B8 ; Reserved instruction
	.db $80, $90		; 80 90 ; Branch always to $80, $90 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $787C.w,X		; 3C 7C 78 ; Test bits $787C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $06.b,X		; F6 06 ; Increment memory $06.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	dec $D0.b,X		; D6 D0 ; Decrement memory $D0.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	and [$30.b],Y		; 37 30 ; AND accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	jsr $F8F0.w		; 20 F0 F8 ; Jump to subroutine at $F8F0.w [Writes: Stack Pointer] [Flow: call]
	inc $0F2F.w,X		; FE 2F 0F ; Increment memory $0F2F.w,X [Reads: X Index] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsl $4A222A.l		; 22 2A 22 4A ; Jump to subroutine long $4A222A.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $B4		; 42 B4 ; Reserved instruction
	sty $F4.b		; 84 F4 ; Store Y register to $F4.b [Reads: Y Index]
	sty $28.b		; 84 28 ; Store Y register to $28.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $3C1C.w		; 1C 1C 3C ; Test and reset bits $3C1C.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $2A		; F0 2A ; Branch if equal to $F0, $2A [Flow: branch]
	jsl $15C2CA.l		; 22 CA C2 15 ; Jump to subroutine long $15C2CA.l [Writes: Stack Pointer] [Flow: call]
	ora ($0A.b),Y		; 11 0A ; OR accumulator with memory ($0A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$10.b],Y		; 17 10 ; OR accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp.w [$0E1C]		; DC 1C 0E ; Jump long indirect [$0E1C] [Flow: jump]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $540207.l		; 0F 07 02 54 ; OR accumulator with memory (long) $540207.l [Writes: Accumulator] [Flags: ZN]
	mvp $44,$54		; 44 54 44 ; Move block positive $44,$54 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	trb $A90C.w		; 1C 0C A9 ; Test and reset bits $A90C.w [Reads: Accumulator] [Flags: Z]
	bit #$2A.b		; 89 2A ; Test bits #$2A.b with accumulator [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	eor ($11.b),Y		; 51 11 ; Exclusive OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $50, $10		; 50 10 ; Branch if overflow clear to $50, $10 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	sbc ($E0.b),Y		; F1 E0 ; Subtract with carry ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$11.b],Y		; 17 11 ; OR accumulator with memory (long indexed) [$11.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sta [$90.b],Y		; 97 90 ; Store accumulator (long indexed) [$90.b],Y [Reads: Accumulator, Direct Page, Y Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $070E.w		; 0E 0E 07 ; Arithmetic shift left $070E.w [Flags: ZNC]
	sta [$C7.b]		; 87 C7 ; Store accumulator (long) [$C7.b] [Reads: Accumulator, Direct Page]
	sta [$0F.b]		; 87 0F ; Store accumulator (long) [$0F.b] [Reads: Accumulator, Direct Page]
	ora [$70.b]		; 07 70 ; OR accumulator with memory (long) [$70.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $C03030.l		; 0F 30 30 C0 ; OR accumulator with memory (long) $C03030.l [Writes: Accumulator] [Flags: ZN]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00C0F0.l,X		; FF F0 C0 00 ; Subtract with carry (long,X) $00C0F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsl $2A222A.l		; 22 2A 22 2A ; Jump to subroutine long $2A222A.l [Writes: Stack Pointer] [Flow: call]
	jsl $3F2125.l		; 22 25 21 3F ; Jump to subroutine long $3F2125.l [Writes: Stack Pointer] [Flow: call]
	and ($5F.b),Y		; 31 5F ; AND accumulator with memory ($5F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $151531.l,X		; 3F 31 15 15 ; AND accumulator with memory (long,X) $151531.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $1C1C.w		; 1C 1C 1C ; Test and reset bits $1C1C.w [Reads: Accumulator] [Flags: Z]
	asl $3F0E.w,X		; 1E 0E 3F ; Arithmetic shift left $3F0E.w,X [Reads: X Index] [Flags: ZNC]
	asl $550A.w		; 0E 0A 55 ; Arithmetic shift left $550A.w [Flags: ZNC]
	mvp $2C,$2D		; 44 2D 2C ; Move block positive $2C,$2D [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$7040.w		; C0 40 70 ; Compare #$7040.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $B8		; 30 B8 ; Branch if minus to $30, $B8 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	mvn $2A,$44		; 54 44 2A ; Move block negative $2A,$44 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	jsl $2A011D.l		; 22 1D 01 2A ; Jump to subroutine long $2A011D.l [Writes: Stack Pointer] [Flow: call]
	jsl $C08080.l		; 22 80 80 C0 ; Jump to subroutine long $C08080.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	trb $1C3E.w		; 1C 3E 1C ; Test and reset bits $1C3E.w [Reads: Accumulator] [Flags: Z]
	eor ($51.b),Y		; 51 51 ; Exclusive OR accumulator with memory ($51.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	tsb $50.b		; 04 50 ; Test and set bits $50.b [Reads: Accumulator] [Flags: Z]
	.db $10, $50		; 10 50 ; Branch if plus to $10, $50 [Flow: branch]
	.db $10, $50		; 10 50 ; Branch if plus to $10, $50 [Flow: branch]
	.db $10, $68		; 10 68 ; Branch if plus to $10, $68 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $84.b,X		; 94 84 ; Store Y register $84.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	.db $82, $54, $44		; 82 54 44 ; Branch always long to $82, $54, $44 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cpx #$E0E0.w		; E0 E0 E0 ; Compare #$E0E0.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	jmp ($1038.w,X)		; 7C 38 10 ; Jump indirect indexed to ($1038.w,X) [Reads: X Index] [Flow: jump]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	lsr $46.b,X		; 56 46 ; Logical shift right $46.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and #$21.b		; 29 21 ; Logical AND #$21.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $10.b,X		; 16 10 ; Arithmetic shift left $10.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx #$70F0.w		; E0 F0 70 ; Compare #$70F0.w with X register [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $070F.w,X		; 1E 0F 07 ; Arithmetic shift left $070F.w,X [Reads: X Index] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy #$A020.w		; A0 20 A0 ; Load #$A020.w into Y register [Writes: Y Index] [Flags: ZN]
	jsr $20A0.w		; 20 A0 20 ; Jump to subroutine at $20A0.w [Writes: Stack Pointer] [Flow: call]
	ldy #$0020.w		; A0 20 00 ; Load #$0020.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpy #$C0C0.w		; C0 C0 C0 ; Compare #$C0C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $70, $30		; 70 30 ; Branch if overflow set to $70, $30 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	.db $50, $10		; 50 10 ; Branch if overflow clear to $50, $10 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	mvn $BA,$44		; 54 44 BA ; Move block negative $BA,$44 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $82, $40, $C0		; 82 40 C0 ; Branch always long to $82, $40, $C0 [Flow: branch]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpx #$3870.w		; E0 70 38 ; Compare #$3870.w with X register [Reads: X Index] [Flags: ZNC]
	jmp ($0000.w,X)		; 7C 00 00 ; Jump indirect indexed to ($0000.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$20C0.w		; C0 C0 20 ; Compare #$20C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $1050.w		; 20 50 10 ; Jump to subroutine at $1050.w [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsl $000109.l		; 22 09 01 00 ; Jump to subroutine long $000109.l [Writes: Stack Pointer] [Flow: call]
	cpy #$F0E0.w		; C0 E0 F0 ; Compare #$F0E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $7C		; F0 7C ; Branch if equal to $F0, $7C [Flow: branch]
	trb $001E.w		; 1C 1E 00 ; Test and reset bits $001E.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsl $001414.l		; 22 14 14 00 ; Jump to subroutine long $001414.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $6008.w		; 1C 08 60 ; Test and reset bits $6008.w [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $50, $10		; 50 10 ; Branch if overflow clear to $50, $10 [Flow: branch]
	cpx $620C.w		; EC 0C 62 ; Compare $620C.w with X register [Reads: X Index] [Flags: ZNC]
	cop $9D.b		; 02 9D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($62.b,X)		; 81 62 ; Store accumulator ($62.b,X) [Reads: Accumulator, X Index, Direct Page]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $021C.w,X		; 1D 1C 02 ; OR accumulator with memory $021C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $80.b		; 02 80 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$FCF0.w		; E0 F0 FC ; Compare #$FCF0.w with X register [Reads: X Index] [Flags: ZNC]
	ror $031F.w,X		; 7E 1F 03 ; Rotate right $031F.w,X [Reads: X Index] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	mvp $80,$44		; 44 44 80 ; Move block positive $80,$44 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	tsb $80.b		; 04 80 ; Test and set bits $80.b [Reads: Accumulator] [Flags: Z]
	cpy #$0848.w		; C0 48 08 ; Compare #$0848.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $03.b,S		; E3 03 ; Subtract stack-relative $03.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$5C5C.w		; A0 5C 5C ; Load #$5C5C.w into Y register [Writes: Y Index] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	sbc $00035F.l,X		; FF 5F 03 00 ; Subtract with carry (long,X) $00035F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$10E0.w		; E0 E0 10 ; Compare #$10E0.w with X register [Reads: X Index] [Flags: ZNC]
	.db $10, $E8		; 10 E8 ; Branch if plus to $10, $E8 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	nop		; EA ; No operation
.ACCU 8
	sep #$2A		; E2 2A
	jsl $000000.l		; 22 00 00 00 ; Jump to subroutine long $000000.l [Writes: Stack Pointer] [Flow: call]
	cpx #$F8F0.w		; E0 F0 F8 ; Compare #$F8F0.w with X register [Reads: X Index] [Flags: ZNC]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $071F3F.l,X		; 3F 3F 1F 07 ; AND accumulator with memory (long,X) $071F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$FCF8.w		; E0 F8 FC ; Compare #$FCF8.w with X register [Reads: X Index] [Flags: ZNC]
	jsr ($E0F8.w,X)		; FC F8 E0 ; Jump to subroutine indirect indexed ($E0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A1B.w		; 0D 1B 0A ; Logical OR $0A1B.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $0019.w,Y		; 39 19 00 ; AND accumulator with memory $0019.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($15.b)		; 12 15 ; OR accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $48		; B0 48 ; Branch if carry set to $B0, $48 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sty $0A.b		; 84 0A ; Store Y register to $0A.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy $04.b		; C4 04 ; Compare $04.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cop $CD.b		; 02 CD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($12.b,X)		; C1 12 ; Compare accumulator ($12.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	.db $10, $0B		; 10 0B ; Branch if plus to $10, $0B [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$FCF8.w		; C0 F8 FC ; Compare #$FCF8.w with Y register [Reads: Y Index] [Flags: ZNC]
	rol $070F.w,X		; 3E 0F 07 ; Rotate left $070F.w,X [Reads: X Index] [Flags: ZNC]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	mvp $4A,$44		; 44 44 4A ; Move block positive $4A,$44 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	eor $51.b,X		; 55 51 ; Exclusive OR accumulator with memory $51.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	mvp $40,$44		; 44 44 40 ; Move block positive $40,$44 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $84		; 80 84 ; Branch always to $80, $84 [Flow: branch]
	stx $8084.w		; 8E 84 80 ; Store X register to $8084.w [Reads: X Index]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $54		; 80 54 ; Branch always to $80, $54 [Flow: branch]
	mvp $44,$54		; 44 54 44 ; Move block positive $44,$54 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	eor ($11.b),Y		; 51 11 ; Exclusive OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $50, $10		; 50 10 ; Branch if overflow clear to $50, $10 [Flow: branch]
	ldy #$40A0.w		; A0 A0 40 ; Load #$40A0.w into Y register [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $10		; 50 10 ; Branch if overflow clear to $50, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0E0.w		; E0 E0 E0 ; Compare #$E0E0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($15.b),Y		; 11 15 ; OR accumulator with memory ($15.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($2E.b),Y		; 11 2E ; OR accumulator with memory ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $3135.w		; 20 35 31 ; Jump to subroutine at $3135.w [Writes: Stack Pointer] [Flow: call]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $42, $B4		; 42 B4 ; Reserved instruction
	sty $74.b		; 84 74 ; Store Y register to $74.b [Reads: Y Index]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $1F0E.w		; 0E 0E 1F ; Arithmetic shift left $1F0E.w [Flags: ZNC]
	asl $783C.w		; 0E 3C 78 ; Arithmetic shift left $783C.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy $80.b		; A4 80 ; Load $80.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $A4.b,S		; 03 A4 ; OR accumulator with stack relative $A4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sty $01.b		; 84 01 ; Store Y register to $01.b [Reads: Y Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $E078FC.l,X		; 7F FC 78 E0 ; Add long $E078FC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $08E8.w		; 20 E8 08 ; Jump to subroutine at $08E8.w [Writes: Stack Pointer] [Flow: call]
	.db $50, $10		; 50 10 ; Branch if overflow clear to $50, $10 [Flow: branch]
	ldy #$4020.w		; A0 20 40 ; Load #$4020.w into Y register [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0F0.w		; C0 F0 E0 ; Compare #$E0F0.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$0080.w		; C0 80 00 ; Compare #$0080.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $28,$44		; 54 44 28 ; Move block negative $28,$44 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldy $43BC.w,X		; BC BC 43 ; Load Y register $43BC.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $5DFCFF.l,X		; FF FF FC 5D ; Subtract with carry (long,X) $5DFCFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($2A.b,X)		; 41 2A ; Exclusive OR accumulator with memory ($2A.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $D44454.l		; 22 54 44 D4 ; Jump to subroutine long $D44454.l [Writes: Stack Pointer] [Flow: call]
	cpy $34.b		; C4 34 ; Compare $34.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	tsb $E8.b		; 04 E8 ; Test and set bits $E8.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	cpx #$3EE0.w		; E0 E0 3E ; Compare #$3EE0.w with X register [Reads: X Index] [Flags: ZNC]
	trb $3838.w		; 1C 38 38 ; Test and reset bits $3838.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1B3B.w		; 1C 3B 1B ; Test and reset bits $1B3B.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $1F0C.w		; 1C 0C 1F ; Test and reset bits $1F0C.w [Reads: Accumulator] [Flags: Z]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $27.b		; 24 27 ; Test bits $27.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	bit $DC08.w		; 2C 08 DC ; Test bits $DC08.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	trb $3818.w		; 1C 18 38 ; Test and reset bits $3818.w [Reads: Accumulator] [Flags: Z]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($24.b)		; D4 24 ; Push effective indirect address ($24.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cpx $C8.b		; E4 C8 ; Compare $C8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3E3E.w		; 1C 3E 3E ; Test and reset bits $3E3E.w [Reads: Accumulator] [Flags: Z]
	eor ($7F.b,X)		; 41 7F ; Exclusive OR accumulator with memory ($7F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $777F.w,X		; 3E 7F 77 ; Rotate left $777F.w,X [Reads: X Index] [Flags: ZNC]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3E3E.w		; 1C 3E 3E ; Test and reset bits $3E3E.w [Reads: Accumulator] [Flags: Z]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $7F3E.w,X		; 3E 3E 7F ; Rotate left $7F3E.w,X [Reads: X Index] [Flags: ZNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $77.b,S		; 63 77 ; Add with carry (stack relative) $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $007F00.l,X		; 7F 00 7F 00 ; Add long $007F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $6B7F7F.l,X		; 7F 7F 7F 6B ; Add long $6B7F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $7F7F7F.l,X		; 7F 7F 7F 7F ; Add long $7F7F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $70707F.l,X		; 7F 7F 70 70 ; Add long $70707F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $7E		; 70 7E ; Branch if overflow set to $70, $7E [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3E1C.w		; 1C 1C 3E ; Test and reset bits $3E1C.w [Reads: Accumulator] [Flags: Z]
	rol $7F41.w,X		; 3E 41 7F ; Rotate left $7F41.w,X [Reads: X Index] [Flags: ZNC]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $777F.w,X		; 3E 7F 77 ; Rotate left $777F.w,X [Reads: X Index] [Flags: ZNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($7E7E.w,X)		; 7C 7E 7E ; Jump indirect indexed to ($7E7E.w,X) [Reads: X Index] [Flow: jump]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $777F.w,X		; 7E 7F 77 ; Rotate right $777F.w,X [Reads: X Index] [Flags: ZNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $0000.w,X		; 7E 00 00 ; Rotate right $0000.w,X [Reads: X Index] [Flags: ZNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C1300.l,X		; 1F 00 13 0C ; Logical OR long $0C1300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $021F1D.l		; 22 1D 1F 02 ; Jump to subroutine long $021F1D.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	jsl $000F1F.l		; 22 1F 0F 00 ; Jump to subroutine long $000F1F.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $E018.w		; 20 18 E0 ; Jump to subroutine at $E018.w [Writes: Stack Pointer] [Flow: call]
	trb $E0.b		; 14 E0 ; Test and reset bits $E0.b [Reads: Accumulator] [Flags: Z]
	ldx #$DA40.w		; A2 40 DA ; Load #$DA40.w into X register [Writes: X Index] [Flags: ZN]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	jsr $10D0.w		; 20 D0 10 ; Jump to subroutine at $10D0.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldy $01FC.w,X		; BC FC 01 ; Load Y register $01FC.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $11.b		; 06 11 ; Arithmetic shift left $11.b [Reads: Direct Page] [Flags: ZNC]
	asl $1F20.w		; 0E 20 1F ; Arithmetic shift left $1F20.w [Flags: ZNC]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	ora ($20.b),Y		; 11 20 ; OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0C0000.l		; 0F 00 00 0C ; OR accumulator with memory (long) $0C0000.l [Writes: Accumulator] [Flags: ZN]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $4C		; 80 4C ; Branch always to $80, $4C [Flow: branch]
	.db $B0, $10		; B0 10 ; Branch if carry set to $B0, $10 [Flow: branch]
	cpx #$C03C.w		; E0 3C C0 ; Compare #$C03C.w with X register [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $70		; 80 70 ; Branch always to $80, $70 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	trb $FC22.w		; 1C 22 FC ; Test and reset bits $FC22.w [Reads: Accumulator] [Flags: Z]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0A15.w,X		; 1E 15 0A ; Arithmetic shift left $0A15.w,X [Reads: X Index] [Flags: ZNC]
	asl $1B05.w,X		; 1E 05 1B ; Arithmetic shift left $1B05.w,X [Reads: X Index] [Flags: ZNC]
	asl $060B.w		; 0E 0B 06 ; Arithmetic shift left $060B.w [Flags: ZNC]
	sta [$01.b]		; 87 01 ; Store accumulator (long) [$01.b] [Reads: Accumulator, Direct Page]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $1E15.w		; 20 15 1E ; Jump to subroutine at $1E15.w [Writes: Stack Pointer] [Flow: call]
	ora $4C060F.l,X		; 1F 0F 06 4C ; Logical OR long $4C060F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	cpx #$C03C.w		; E0 3C C0 ; Compare #$C03C.w with X register [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jsr $3876.w		; 20 76 38 ; Jump to subroutine at $3876.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $2A		; D0 2A ; Branch if not equal to $D0, $2A [Flow: branch]
	trb $FC32.w		; 1C 32 FC ; Test and reset bits $FC32.w [Reads: Accumulator] [Flags: Z]
	inc $0017.w,X		; FE 17 00 ; Increment memory $0017.w,X [Reads: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0A15.w,X		; 1E 15 0A ; Arithmetic shift left $0A15.w,X [Reads: X Index] [Flags: ZNC]
	asl $1B05.w,X		; 1E 05 1B ; Arithmetic shift left $1B05.w,X [Reads: X Index] [Flags: ZNC]
	asl $060B.w		; 0E 0B 06 ; Arithmetic shift left $060B.w [Flags: ZNC]
	sta [$01.b]		; 87 01 ; Store accumulator (long) [$01.b] [Reads: Accumulator, Direct Page]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $1E15.w		; 20 15 1E ; Jump to subroutine at $1E15.w [Writes: Stack Pointer] [Flow: call]
	ora $40060F.l,X		; 1F 0F 06 40 ; Logical OR long $40060F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F00C.w		; C0 0C F0 ; Compare #$F00C.w with Y register [Reads: Y Index] [Flags: ZNC]
	and ($C0.b)		; 32 C0 ; AND accumulator with memory (indirect) ($C0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsr $3876.w		; 20 76 38 ; Jump to subroutine at $3876.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0830.w		; C0 30 08 ; Compare #$0830.w with Y register [Reads: Y Index] [Flags: ZNC]
	bit $FEFC.w,X		; 3C FC FE ; Test bits $FEFC.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($7F.b,X)		; 41 7F ; Exclusive OR accumulator with memory ($7F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $1C3E.w,X		; 3E 3E 1C ; Rotate left $1C3E.w,X [Reads: X Index] [Flags: ZNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	adc [$73.b],Y		; 77 73 ; Add with carry (long indexed) [$73.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($77.b,S),Y		; 73 77 ; Add with carry (stack relative indirect indexed) ($77.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $001C3E.l,X		; 7F 3E 1C 00 ; Add long $001C3E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $77777F.l,X		; 7F 7F 77 77 ; Add long $77777F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $63.b,S		; 63 63 ; Add with carry (stack relative) $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc $63.b,S		; 63 63 ; Add with carry (stack relative) $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $63.b,S		; 63 63 ; Add with carry (stack relative) $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc $63.b,S		; 63 63 ; Add with carry (stack relative) $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc $63.b,S		; 63 63 ; Add with carry (stack relative) $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	adc $7F7F7F.l,X		; 7F 7F 7F 7F ; Add long $7F7F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $7E0000.l,X		; 7F 00 00 7E ; Add long $7E0000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	.db $70, $7F		; 70 7F ; Branch if overflow set to $70, $7F [Flow: branch]
	adc $00007F.l,X		; 7F 7F 00 00 ; Add long $00007F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$41.b],Y		; 77 41 ; Add with carry (long indexed) [$41.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $1C3E3E.l,X		; 7F 3E 3E 1C ; Add long $1C3E3E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $001C3E.l,X		; 7F 3E 1C 00 ; Add long $001C3E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1C1C3E.l		; 22 3E 1C 1C ; Jump to subroutine long $1C1C3E.l [Writes: Stack Pointer] [Flow: call]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$36.b],Y		; 77 36 ; Add with carry (long indexed) [$36.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $1C3E.w,X		; 3E 3E 1C ; Rotate left $1C3E.w,X [Reads: X Index] [Flags: ZNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FE.b		; 06 FE ; Arithmetic shift left $FE.b [Reads: Direct Page] [Flags: ZNC]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $000C06.l		; 0F 06 0C 00 ; OR accumulator with memory (long) $000C06.l [Writes: Accumulator] [Flags: ZN]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc ($CE.b),Y		; F1 CE ; Subtract with carry ($CE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $1860.w		; AE 60 18 ; Load $1860.w into X register [Writes: X Index] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $EC		; 10 EC ; Branch if plus to $10, $EC [Flow: branch]
	.db $50, $6A		; 50 6A ; Branch if overflow clear to $50, $6A [Flow: branch]
	bit $2C.b,X		; 34 2C ; Test bits $2C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	and $F8FCDE.l,X		; 3F DE FC F8 ; AND accumulator with memory (long,X) $F8FCDE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($3C7E.w,X)		; FC 7E 3C ; Jump to subroutine indirect indexed ($3C7E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $D7.b		; 04 D7 ; Test and set bits $D7.b [Reads: Accumulator] [Flags: Z]
	asl $083F.w		; 0E 3F 08 ; Arithmetic shift left $083F.w [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $180F1F.l		; 0F 1F 0F 18 ; OR accumulator with memory (long) $180F1F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc ($CE.b),Y		; F1 CE ; Subtract with carry ($CE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $1860.w		; AE 60 18 ; Load $1860.w into X register [Writes: X Index] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $EC		; 10 EC ; Branch if plus to $10, $EC [Flow: branch]
	.db $50, $6A		; 50 6A ; Branch if overflow clear to $50, $6A [Flow: branch]
	bit $2C.b,X		; 34 2C ; Test bits $2C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	and $F8FCDE.l,X		; 3F DE FC F8 ; AND accumulator with memory (long,X) $F8FCDE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($3C7E.w,X)		; FC 7E 3C ; Jump to subroutine indirect indexed ($3C7E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $37.b		; 04 37 ; Test and set bits $37.b [Reads: Accumulator] [Flags: Z]
	tsb $182D.w		; 0C 2D 18 ; Test and set bits $182D.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00183D.l,X		; 1F 3D 18 00 ; Logical OR long $00183D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $60AE.w		; CE AE 60 ; Decrement $60AE.w [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $EC		; 10 EC ; Branch if plus to $10, $EC [Flow: branch]
	.db $50, $6A		; 50 6A ; Branch if overflow clear to $50, $6A [Flow: branch]
	bit $2C.b,X		; 34 2C ; Test bits $2C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $F8F8.w,X		; DE F8 F8 ; Decrement memory $F8F8.w,X [Reads: X Index] [Flags: ZN]
	jsr ($3C7E.w,X)		; FC 7E 3C ; Jump to subroutine indirect indexed ($3C7E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $4A		; 10 4A ; Branch if plus to $10, $4A [Flow: branch]
	tsb $37.b		; 04 37 ; Test and set bits $37.b [Reads: Accumulator] [Flags: Z]
	tsb $182D.w		; 0C 2D 18 ; Test and set bits $182D.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00183D.l,X		; 1F 3D 18 00 ; Logical OR long $00183D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $60AE.w		; CE AE 60 ; Decrement $60AE.w [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $EC		; 10 EC ; Branch if plus to $10, $EC [Flow: branch]
	.db $50, $6A		; 50 6A ; Branch if overflow clear to $50, $6A [Flow: branch]
	bit $2C.b,X		; 34 2C ; Test bits $2C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $F8FC.w,X		; DE FC F8 ; Decrement memory $F8FC.w,X [Reads: X Index] [Flags: ZN]
	jsr ($3C7E.w,X)		; FC 7E 3C ; Jump to subroutine indirect indexed ($3C7E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2D12.w		; 0C 12 2D ; Test and set bits $2D12.w [Reads: Accumulator] [Flags: Z]
	lsr $2E52.w,X		; 5E 52 2E ; Logical shift right $2E52.w,X [Reads: X Index] [Flags: ZNC]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $88		; [PATTERN: Memory clearing operation] 70 88 ; Branch if overflow set to $70, $88 [Flow: branch]
	stz $EA.b,X		; 74 EA ; Store zero to $EA.b,X [Reads: X Index]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	nop		; EA ; No operation
	stz $00.b		; 64 00 ; Store zero to $00.b
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $80.b		; 02 80 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $2020.w		; 20 20 20 ; Jump to subroutine at $2020.w [Writes: Stack Pointer] [Flow: call]
	jsr $2020.w		; 20 20 20 ; Jump to subroutine at $2020.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $0008.w,Y		; 19 08 00 ; OR accumulator with memory $0008.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	asl $160E.w		; 0E 0E 16 ; Arithmetic shift left $160E.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$C000.w		; C0 00 C0 ; Compare #$C000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $3020.w		; 20 20 30 ; Jump to subroutine at $3020.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F1C03.l		; 0F 03 1C 0F ; OR accumulator with memory (long) $0F1C03.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $1837.w		; 0C 37 18 ; Test and set bits $1837.w [Reads: Accumulator] [Flags: Z]
	and [$18.b],Y		; 37 18 ; AND accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3C381C.l,X		; 1F 1C 38 3C ; Logical OR long $3C381C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F000.w		; C0 00 F0 ; Compare #$F000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F038.w		; C0 38 F0 ; Compare #$F038.w with Y register [Reads: Y Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $30, $EC		; 30 EC ; Branch if minus to $30, $EC [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $0018.w		; EC 18 00 ; Compare $0018.w with X register [Reads: X Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $443C.w		; 1C 3C 44 ; Test and reset bits $443C.w [Reads: Accumulator] [Flags: Z]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $EE,$EE		; 44 EE EE ; Move block positive $EE,$EE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	jmp ($387C.w,X)		; 7C 7C 38 ; Jump indirect indexed to ($387C.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($EE7C.w,X)		; 7C 7C EE ; Jump indirect indexed to ($EE7C.w,X) [Reads: X Index] [Flow: jump]
	inc $4444.w		; EE 44 44 ; Increment $4444.w [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $D820.w		; 20 20 D8 ; Jump to subroutine at $D820.w [Writes: Stack Pointer] [Flow: call]
	jsr $0A26.w		; 20 26 0A ; Jump to subroutine at $0A26.w [Writes: Stack Pointer] [Flow: call]
	ora $0002.w		; 0D 02 00 ; Logical OR $0002.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $4040.w		; 20 40 40 ; Jump to subroutine at $4040.w [Writes: Stack Pointer] [Flow: call]
	jsr $4008.w		; 20 08 40 ; Jump to subroutine at $4008.w [Writes: Stack Pointer] [Flow: call]
	jsr $2ADC.w		; 20 DC 2A ; Jump to subroutine at $2ADC.w [Writes: Stack Pointer] [Flow: call]
	rol $0D.b		; 26 0D ; Rotate left $0D.b [Reads: Direct Page] [Flags: ZNC]
	cop $82.b		; 02 82 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1C06.w,X		; 3C 06 1C ; Test bits $1C06.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	bit $3C00.w,X		; 3C 00 3C ; Test bits $3C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $6C2C.w		; 1C 2C 6C ; Test and reset bits $6C2C.w [Reads: Accumulator] [Flags: Z]
	jmp ($0C7E.w)		; 6C 7E 0C ; Jump indirect to ($0C7E.w) [Flow: jump]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3C30.w,X		; 3C 30 3C ; Test bits $3C30.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	bit $3C00.w,X		; 3C 00 3C ; Test bits $3C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $7C30.w		; 1C 30 7C ; Test and reset bits $7C30.w [Reads: Accumulator] [Flags: Z]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: ZNC]
	bit $0700.w,X		; 3C 00 07 ; Test bits $0700.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0B0E.w		; 0D 0E 0B ; Logical OR $0B0E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	.db $50, $00		; 50 00 ; Branch if overflow clear to $50, $00 [Flow: branch]
	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	cpx #$C0C0.w		; E0 C0 C0 ; Compare #$C0C0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	.db $B0, $D0		; B0 D0 ; Branch if carry set to $B0, $D0 [Flow: branch]
	jsr $00C0.w		; 20 C0 00 ; Jump to subroutine at $00C0.w [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpx #$E080.w		; E0 80 E0 ; Compare #$E080.w with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$C0E0.w		; E0 E0 C0 ; Compare #$C0E0.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$C0C0.w		; E0 C0 C0 ; Compare #$C0C0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $10F0.w		; 20 F0 10 ; Jump to subroutine at $10F0.w [Writes: Stack Pointer] [Flow: call]
	jsr $C020.w		; 20 20 C0 ; Jump to subroutine at $C020.w [Writes: Stack Pointer] [Flow: call]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $060E.w		; 0C 0E 06 ; Test and set bits $060E.w [Reads: Accumulator] [Flags: Z]
	asl $0606.w		; 0E 06 06 ; Arithmetic shift left $0606.w [Flags: ZNC]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$09.b		; 09 09 ; Logical OR #$09.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$C0E0.w		; E0 E0 C0 ; Compare #$C0E0.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$0080.w		; C0 80 00 ; Compare #$0080.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and [$18.b],Y		; 37 18 ; AND accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0C1F.w,X		; 3E 1F 0C ; Rotate left $0C1F.w,X [Reads: X Index] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $1818.w		; EC 18 18 ; Compare $1818.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$20D0.w		; E0 D0 20 ; Compare #$20D0.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpx #$0000.w		; E0 00 00 ; Compare #$0000.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($30F8.w,X)		; 7C F8 30 ; Jump indirect indexed to ($30F8.w,X) [Reads: X Index] [Flow: jump]
	.db $50, $E0		; 50 E0 ; Branch if overflow clear to $50, $E0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7C,$EE		; 44 EE 7C ; Move block positive $7C,$EE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($44EE.w,X)		; 7C EE 44 ; Jump indirect indexed to ($44EE.w,X) [Reads: X Index] [Flow: jump]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $180C.w		; 0C 0C 18 ; Test and set bits $180C.w [Reads: Accumulator] [Flags: Z]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5020.w		; 20 20 50 ; Jump to subroutine at $5020.w [Writes: Stack Pointer] [Flow: call]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5020.w		; 20 20 50 ; Jump to subroutine at $5020.w [Writes: Stack Pointer] [Flow: call]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $2050.w		; 20 50 20 ; Jump to subroutine at $2050.w [Writes: Stack Pointer] [Flow: call]
	bit $7E00.w,X		; 3C 00 7E ; Test bits $7E00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0C04.w,X		; 3C 04 0C ; Test bits $0C04.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3C66.w,X		; 3C 66 3C ; Test bits $3C66.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: ZNC]
	bit $3C00.w,X		; 3C 00 3C ; Test bits $3C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $6666.w,X		; 3C 66 66 ; Test bits $6666.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	rol $380C.w,X		; 3E 0C 38 ; Rotate left $380C.w,X [Reads: X Index] [Flags: ZNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $54		; 10 54 ; Branch if plus to $10, $54 [Flow: branch]
	jmp ($1000.w)		; 6C 00 10 ; Jump indirect to ($1000.w) [Flow: jump]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	jmp ($1010.w)		; 6C 10 10 ; Jump indirect to ($1010.w) [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1818.w		; 20 18 18 ; Jump to subroutine at $1818.w [Writes: Stack Pointer] [Flow: call]
	trb $0E16.w		; 1C 16 0E ; Test and reset bits $0E16.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1418.w		; 20 18 14 ; Jump to subroutine at $1418.w [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	jsr $0020.w		; 20 20 00 ; Jump to subroutine at $0020.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $1858.w		; 20 58 18 ; Jump to subroutine at $1858.w [Writes: Stack Pointer] [Flow: call]
	bit $371C.w		; 2C 1C 37 ; Test bits $371C.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $0D061B.l		; 0F 1B 06 0D ; OR accumulator with memory (long) $0D061B.l [Writes: Accumulator] [Flags: ZN]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0B.b		; 14 0B ; Test and reset bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and [$04.b],Y		; 37 04 ; AND accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $877CBB.l,X		; BF BB 7C 87 ; Load long $877CBB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $00F2.w		; 4D F2 00 ; Exclusive OR $00F2.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,S),Y		; 13 07 ; OR accumulator (stack relative indirect indexed) ($07.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $C2B8.w,X		; 3C B8 C2 ; Test bits $C2B8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1D0E.w		; 0E 0E 1D ; Arithmetic shift left $1D0E.w [Flags: ZNC]
	ora ($3E.b,S),Y		; 13 3E ; OR accumulator (stack relative indirect indexed) ($3E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($3E.b,X)		; 21 3E ; Logical AND ($3E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($7F.b,X)		; 21 7F ; Logical AND ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor ($5E.b,X)		; 41 5E ; Exclusive OR accumulator with memory ($5E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $4C.b,S		; 63 4C ; Add with carry (stack relative) $4C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $2113.w		; 0E 13 21 ; Arithmetic shift left $2113.w [Flags: ZNC]
	and ($41.b,X)		; 21 41 ; Logical AND ($41.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $77.b,S		; 63 77 ; Add with carry (stack relative) $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jmp ($7CC4.w,X)		; 7C C4 7C ; Jump indirect indexed to ($7CC4.w,X) [Reads: X Index] [Flow: jump]
	cpy $BE.b		; C4 BE ; Compare $BE.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
.ACCU 16
.INDEX 16
	rep #$72		; C2 72
	stx $1CFC.w		; 8E FC 1C ; Store X register to $1CFC.w [Reads: X Index]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpy $C4.b		; C4 C4 ; Compare $C4.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	rep #$8E		; C2 8E ; Reset processor status bits #$8E [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1B.b		; 04 1B ; Test and set bits $1B.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$BC.b]		; 07 BC ; OR accumulator with memory (long) [$BC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	cpy #$8000.w		; C0 00 80 ; Compare #$8000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $80		; 30 80 ; Branch if minus to $30, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $332D1F.l,X		; 1F 1F 2D 33 ; Logical OR long $332D1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $7E21.w,X		; 3E 21 7E ; Rotate left $7E21.w,X [Reads: X Index] [Flags: ZNC]
	eor ($5D.b,X)		; 41 5D ; Exclusive OR accumulator with memory ($5D.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $62, $00, $01		; 62 00 01 ; Push effective relative address $62, $00, $01 [Writes: Stack Pointer]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($21.b,S),Y		; 33 21 ; AND accumulator (stack relative indirect indexed) ($21.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor ($62.b,X)		; 41 62 ; Exclusive OR accumulator with memory ($62.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $960C.w		; 0C 0C 96 ; Test and set bits $960C.w [Reads: Accumulator] [Flags: Z]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	bit $262C.w,X		; 3C 2C 26 ; Test bits $262C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ldx $9CB2.w		; AE B2 9C ; Load $9CB2.w into X register [Writes: X Index] [Flags: ZN]
	stz $8080.w		; [PATTERN: Memory clearing operation] 9C 80 80 ; Store zero to $8080.w
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	bit $B23A.w		; 2C 3A B2 ; Test bits $B23A.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	stz $0080.w		; 9C 80 00 ; Store zero to $0080.w
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $032F14.l,X		; 1F 14 2F 03 ; Logical OR long $032F14.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $3817.w,X		; 3C 17 38 ; Test bits $3817.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $702F70.l		; 2F 70 2F 70 ; AND accumulator with memory (long) $702F70.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $3018.w		; 0C 18 30 ; Test and set bits $3018.w [Reads: Accumulator] [Flags: Z]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp $B67C.w		; 4C 7C B6 ; Jump to $B67C.w [Flow: jump]
	dec $DEA6.w		; CE A6 DE ; Decrement $DEA6.w [Flags: ZN]
	dec $7CFE.w		; CE FE 7C ; Decrement $7CFE.w [Flags: ZN]
	jmp ($3838.w,X)		; 7C 38 38 ; Jump indirect indexed to ($3838.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($DECE.w,X)		; 7C CE DE ; Jump indirect indexed to ($DECE.w,X) [Reads: X Index] [Flow: jump]
	inc $387C.w,X		; FE 7C 38 ; Increment memory $387C.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc [$01.b]		; E7 01 ; Subtract with carry (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor [$01.b]		; 47 01 ; Exclusive OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl $0400.w		; 0E 00 04 ; Arithmetic shift left $0400.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pea $EE44.w		; F4 44 EE ; Push absolute address $EE44.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00C4.w		; E0 C4 00 ; Compare #$00C4.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $02.b		; 14 02 ; Test and reset bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	inc $387C.w,X		; FE 7C 38 ; Increment memory $387C.w,X [Reads: X Index] [Flags: ZN]
	jmp ($0044.w,X)		; 7C 44 00 ; Jump indirect indexed to ($0044.w,X) [Reads: X Index] [Flow: jump]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Accumulator, X Index, Direct Page]
	.db $42, $66		; 42 66 ; Reserved instruction
	bit $245A.w,X		; 3C 5A 24 ; Test bits $245A.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $3C24.w,X		; 3C 24 3C ; Test bits $3C24.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $425A.w,X		; 3C 5A 42 ; Test bits $425A.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ror $81.b		; 66 81 ; Rotate right $81.b [Reads: Direct Page] [Flags: ZNC]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Accumulator, X Index, Direct Page]
	.db $42, $18		; 42 18 ; Reserved instruction
	bit $183C.w,X		; 3C 3C 18 ; Test bits $183C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $42, $81		; 42 81 ; Reserved instruction
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $4000.w		; 20 00 40 ; Jump to subroutine at $4000.w [Writes: Stack Pointer] [Flow: call]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	ora $040701.l		; 0F 01 07 04 ; OR accumulator with memory (long) $040701.l [Writes: Accumulator] [Flags: ZN]
	ora $152718.l,X		; 1F 18 27 15 ; Logical OR long $152718.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $1E05.w		; 2E 05 1E ; Rotate left $1E05.w [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $1C0B.w		; 1C 0B 1C ; Test and reset bits $1C0B.w [Reads: Accumulator] [Flags: Z]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: ZNC]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	tsb $B30C.w		; 0C 0C B3 ; Test and set bits $B30C.w [Reads: Accumulator] [Flags: Z]
	jmp ($9C6B.w,X)		; 7C 6B 9C ; Jump indirect indexed to ($9C6B.w,X) [Reads: X Index] [Flow: jump]
	sbc ($9E.b),Y		; F1 9E ; Subtract with carry ($9E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda [$F8.b],Y		; B7 F8 ; Load accumulator (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phk		; [PATTERN: Memory clearing operation] 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	pea $E817.w		; F4 17 E8 ; Push absolute address $E817.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cmp $00FF20.l,X		; DF 20 FF 00 ; Compare accumulator (long,X) $00FF20.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	stz $9C.b,X		; 74 9C ; Store zero to $9C.b,X [Reads: X Index]
	stz $74F8.w,X		; 9E F8 74 ; Store zero to $74F8.w,X [Reads: X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jsr $2400.w		; 20 00 24 ; Jump to subroutine at $2400.w [Writes: Stack Pointer] [Flow: call]
	and $1F3E25.l,X		; 3F 25 3E 1F ; AND accumulator with memory (long,X) $1F3E25.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and $253A20.l,X		; 3F 20 3A 25 ; AND accumulator with memory (long,X) $253A20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $000707.l,X		; 1F 07 07 00 ; Logical OR long $000707.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $201A.w,X		; 3E 1A 20 ; Rotate left $201A.w,X [Reads: X Index] [Flags: ZNC]
	and $1F.b		; 25 1F ; Logical AND $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx $3C.b		; E4 3C ; Compare $3C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $FA.b		; 06 FA ; Arithmetic shift left $FA.b [Reads: Direct Page] [Flags: ZNC]
	asl $26.b		; 06 26 ; Arithmetic shift left $26.b [Reads: Direct Page] [Flags: ZNC]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	sty $FC.b		; 84 FC ; Store Y register to $FC.b [Reads: Y Index]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr $0020.w		; 20 20 00 ; Jump to subroutine at $0020.w [Writes: Stack Pointer] [Flow: call]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsr ($20F8.w,X)		; FC F8 20 ; Jump to subroutine indirect indexed ($20F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($10.b,S),Y		; 33 10 ; AND accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $4020.w		; 20 20 40 ; Jump to subroutine at $4020.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	cpx #$4000.w		; E0 00 40 ; Compare #$4000.w with X register [Reads: X Index] [Flags: ZNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $001E1E.l,X		; 3F 1E 1E 00 ; AND accumulator with memory (long,X) $001E1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $131D.w		; 0E 1D 13 ; Arithmetic shift left $131D.w [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	asl $0C.b,X		; 16 0C ; Arithmetic shift left $0C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	and $0E001E.l,X		; 3F 1E 00 0E ; AND accumulator with memory (long,X) $0E001E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($16.b,S),Y		; 13 16 ; OR accumulator (stack relative indirect indexed) ($16.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0600.w		; 0C 00 06 ; Test and set bits $0600.w [Reads: Accumulator] [Flags: Z]
	asl $6F.b		; 06 6F ; Arithmetic shift left $6F.b [Reads: Direct Page] [Flags: ZNC]
	adc #$9BFF.w		; 69 FF 9B ; Add #$9BFF.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	mvn $28,$7C		; 54 7C 28 ; Move block negative $28,$7C [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	asl $69.b		; 06 69 ; Arithmetic shift left $69.b [Reads: Direct Page] [Flags: ZNC]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	jmp ($3628.w,X)		; 7C 28 36 ; Jump indirect indexed to ($3628.w,X) [Reads: X Index] [Flow: jump]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $2C.b,X		; 34 2C ; Test bits $2C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $183C.w		; 2C 3C 18 ; Test bits $183C.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $183C.w		; 2C 3C 18 ; Test bits $183C.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	rol $3F14.w,X		; 3E 14 3F ; Rotate left $3F14.w,X [Reads: X Index] [Flags: ZNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	adc $0F.b,X		; 75 0F ; Add $0F.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $17		; 30 17 ; Branch if minus to $30, $17 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1A.b,S),Y		; 13 1A ; OR accumulator (stack relative indirect indexed) ($1A.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $181035.l,X		; 1F 35 10 18 ; Logical OR long $181035.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx $A0.b		; E4 A0 ; Compare $A0.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	bit $3CC8.w,X		; 3C C8 3C ; Test bits $3CC8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $B0, $4C		; B0 4C ; Branch if carry set to $B0, $4C [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	trb $38E0.w		; 1C E0 38 ; Test and reset bits $38E0.w [Reads: Accumulator] [Flags: Z]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$2860.w		; C0 60 28 ; Compare #$2860.w with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $476F04.l		; 0F 04 6F 47 ; OR accumulator with memory (long) $476F04.l [Writes: Accumulator] [Flags: ZN]
	sbc $7621.w,X		; FD 21 76 ; Subtract with carry $7621.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	adc $22.b		; 65 22 ; Add $22.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldy $FC88.w,X		; BC 88 FC ; Load Y register $FC88.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $90, $78		; 90 78 ; Branch if carry clear to $90, $78 [Flow: branch]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $10		; 70 10 ; Branch if overflow set to $70, $10 [Flow: branch]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	bit $7E0D.w,X		; 3C 0D 7E ; Test bits $7E0D.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	rol $0002.w		; 2E 02 00 ; Rotate left $0002.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $40.b		; C4 40 ; Compare $40.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	inc $DE0C.w		; EE 0C DE ; Increment $DE0C.w [Flags: ZN]
	.db $80, $4C		; 80 4C ; Branch always to $80, $4C [Flow: branch]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $8C.b		; C4 8C ; Compare $8C.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $020D06.l		; 0F 06 0D 02 ; OR accumulator with memory (long) $020D06.l [Writes: Accumulator] [Flags: ZN]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $82, $00		; 82 82 00 ; Branch always long to $82, $82, $00 [Flow: branch]
	mvp $28,$00		; 44 00 28 ; Move block positive $28,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $82, $00		; 82 82 00 ; Branch always long to $82, $82, $00 [Flow: branch]
	.db $82, $44, $28		; 82 44 28 ; Branch always long to $82, $44, $28 [Flow: branch]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $10,$82		; 44 82 10 ; Move block positive $10,$82 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jmp ($CEB0.w)		; 6C B0 CE ; Jump indirect to ($CEB0.w) [Flow: jump]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	jmp ($3800.w,X)		; 7C 00 38 ; Jump indirect indexed to ($3800.w,X) [Reads: X Index] [Flow: jump]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp ($F34F.w,X)		; 7C 4F F3 ; Jump indirect indexed to ($F34F.w,X) [Reads: X Index] [Flow: jump]
	stz $B0EF.w		; 9C EF B0 ; Store zero to $B0EF.w
	adc $6E5F74.l		; 6F 74 5F 6E ; Add with carry (long) $6E5F74.l [Writes: Accumulator] [Flags: ZVNC]
	eor $3B006E.l,X		; 5F 6E 00 3B ; Exclusive OR accumulator with memory (long,X) $3B006E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $74B09C.l		; 4F 9C B0 74 ; Exclusive OR accumulator with memory (long) $74B09C.l [Writes: Accumulator] [Flags: ZN]
	ror $006E.w		; 6E 6E 00 ; Rotate right $006E.w [Flags: ZNC]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	jmp $827C.w		; 4C 7C 82 ; Jump to $827C.w [Flow: jump]
	ror $FFA9.w,X		; 7E A9 FF ; Rotate right $FFA9.w,X [Reads: X Index] [Flags: ZNC]
	cmp $7F.b		; C5 7F ; Compare $7F.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	bit #$4A3E.w		; 89 3E 4A ; Test bits #$4A3E.w with accumulator [Reads: Accumulator] [Flags: Z]
	trb $34.b		; 14 34 ; Test and reset bits $34.b [Reads: Accumulator] [Flags: Z]
	.db $30, $4C		; 30 4C ; Branch if minus to $30, $4C [Flow: branch]
	.db $82, $A9, $C5		; 82 A9 C5 ; Branch always long to $82, $A9, $C5 [Flow: branch]
	bit #$344A.w		; 89 4A 34 ; Test bits #$344A.w with accumulator [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0600.w		; 09 00 06 ; Logical OR #$0600.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $400000.l		; 0F 00 00 40 ; OR accumulator with memory (long) $400000.l [Writes: Accumulator] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $A2		; 80 A2 ; Branch always to $80, $A2 [Flow: branch]
	cpy #$E0D8.w		; C0 D8 E0 ; Compare #$E0D8.w with Y register [Reads: Y Index] [Flags: ZNC]
	ldy $D8.b		; A4 D8 ; Load $D8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpx #$00D8.w		; E0 D8 00 ; Compare #$00D8.w with X register [Reads: X Index] [Flags: ZNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $50, $60		; 50 60 ; Branch if overflow clear to $50, $60 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	and ($01.b),Y		; 31 01 ; AND accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $8319.w,X		; 1D 19 83 ; OR accumulator with memory $8319.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and ($01.b),Y		; 31 01 ; AND accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0083.w,X		; 1D 83 00 ; OR accumulator with memory $0083.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sty $DAA4.w		; 8C A4 DA ; Store Y register to $DAA4.w [Reads: Y Index]
	.db $F0, $EC		; F0 EC ; Branch if equal to $F0, $EC [Flow: branch]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	.db $70, $10		; 70 10 ; Branch if overflow set to $70, $10 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $84		; 10 84 ; Branch if plus to $10, $84 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx $7C.b		; E4 7C ; Compare $7C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	.db $80, $A0		; 80 A0 ; Branch always to $80, $A0 [Flow: branch]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $0E0F44.l		; 22 44 0F 0E ; Jump to subroutine long $0E0F44.l [Writes: Stack Pointer] [Flow: call]
	cop $47.b		; 02 47 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $A3		; 50 A3 ; Branch if overflow clear to $50, $A3 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $A043.w		; 0E 43 A0 ; Arithmetic shift left $A043.w [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	mvn $20,$60		; 54 60 20 ; Move block negative $20,$60 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	bit $1E.b,X		; 34 1E ; Test bits $1E.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	stz $9654.w		; 9C 54 96 ; Store zero to $9654.w
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $28.b		; 14 28 ; Test and reset bits $28.b [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $9C.b,X		; 34 9C ; Test bits $9C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0B1E.w		; 09 1E 0B ; Logical OR #$0B1E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $3817.w		; 1C 17 38 ; Test and reset bits $3817.w [Reads: Accumulator] [Flags: Z]
	asl $39.b,X		; 16 39 ; Arithmetic shift left $39.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $1C0738.l,X		; 1F 38 07 1C ; Logical OR long $1C0738.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	tsb $1918.w		; 0C 18 19 ; Test and set bits $1918.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cpx #$C030.w		; E0 30 C0 ; Compare #$C030.w with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	jmp $A8DC68.l		; 5C 68 DC A8 ; Jump long to $A8DC68.l [Flow: jump]
	jmp ($E840.w,X)		; 7C 40 E8 ; Jump indirect indexed to ($E840.w,X) [Reads: X Index] [Flow: jump]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1060.w		; 20 60 10 ; Jump to subroutine at $1060.w [Writes: Stack Pointer] [Flow: call]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cld		; D8 ; Clear decimal flag [Flags: D]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b)		; 12 3F ; OR accumulator with memory (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and [$0E.b],Y		; 37 0E ; AND accumulator with memory (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $1C0B.w,Y		; 19 0B 1C ; OR accumulator with memory $1C0B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	asl $09.b,X		; 16 09 ; Arithmetic shift left $09.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $0006.w		; 0C 06 00 ; Test and set bits $0006.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	jmp ($EE10.w,X)		; 7C 10 EE ; Jump indirect indexed to ($EE10.w,X) [Reads: X Index] [Flow: jump]
	cpx $C81E.w		; EC 1E C8 ; Compare $C81E.w with X register [Reads: X Index] [Flags: ZNC]
	bit $7CD8.w,X		; 3C D8 7C ; Test bits $7CD8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	stz $1C.b		; 64 1C ; Store zero to $1C.b
	sec		; 38 ; Set carry flag [Flags: C]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	rol $15.b,X		; 36 15 ; Rotate left $15.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $0605.w		; 0D 05 06 ; Logical OR $0605.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $1B36.w,X		; 3C 36 1B ; Test bits $1B36.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $0006.w		; 0D 06 00 ; Logical OR $0006.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	cpy #$60A0.w		; C0 A0 60 ; Compare #$60A0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0060.w		; C0 60 00 ; Compare #$0060.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $28,$00		; 44 00 28 ; Move block positive $28,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $00,$44		; 44 44 00 ; Move block positive $00,$44 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $00,$00		; 44 00 00 ; Move block positive $00,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $92		; 10 92 ; Branch if plus to $10, $92 [Flow: branch]
	inc $1000.w		; EE 00 10 ; Increment $1000.w [Flags: ZN]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	inc $1010.w		; EE 10 10 ; Increment $1010.w [Flags: ZN]
	.db $10, $57		; 10 57 ; Branch if plus to $10, $57 [Flow: branch]
	ror $4679.w		; 6E 79 46 ; Rotate right $4679.w [Flags: ZNC]
	and $507F30.l,X		; 3F 30 7F 50 ; AND accumulator with memory (long,X) $507F30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $99FFB1.l,X		; FF B1 FF 99 ; Subtract with carry (long,X) $99FFB1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $383847.l,X		; 7F 47 38 38 ; Add long $383847.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $3046.w		; 6E 46 30 ; Rotate right $3046.w [Flags: ZNC]
	.db $50, $B1		; 50 B1 ; Branch if overflow clear to $50, $B1 [Flow: branch]
	sta $3847.w,Y		; 99 47 38 ; Store accumulator to $3847.w,Y [Reads: Accumulator, Y Index]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1050.w		; 20 50 10 ; Jump to subroutine at $1050.w [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	.db $50, $28		; 50 28 ; Branch if overflow clear to $50, $28 [Flow: branch]
	trb $0A.b		; 14 0A ; Test and reset bits $0A.b [Reads: Accumulator] [Flags: Z]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora ($0D.b)		; 12 0D ; OR accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0403.w		; 0D 03 04 ; Logical OR $0403.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $C8		; F0 C8 ; Branch if equal to $F0, $C8 [Flow: branch]
	.db $F0, $AC		; F0 AC ; Branch if equal to $F0, $AC [Flow: branch]
	.db $D0, $70		; D0 70 ; Branch if not equal to $D0, $70 [Flow: branch]
	.db $80, $90		; 80 90 ; Branch always to $80, $90 [Flow: branch]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $D0		; F0 D0 ; Branch if equal to $F0, $D0 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($01.b,S),Y		; 53 01 ; XOR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $2B6F40.l		; 8F 40 6F 2B ; Store accumulator (long) $2B6F40.l [Reads: Accumulator]
	jmp $017E31.l		; 5C 31 7E 01 ; Jump long to $017E31.l [Flow: jump]
	and $00C500.l,X		; 3F 00 C5 00 ; AND accumulator with memory (long,X) $00C500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor ($89.b,S),Y		; 53 89 ; XOR accumulator (stack relative indirect indexed) ($89.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $3C58.w		; 6E 58 3C ; Rotate right $3C58.w [Flags: ZNC]
	ora [$C4.b]		; 07 C4 ; OR accumulator with memory (long) [$C4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpy $AC38.w		; CC 38 AC ; Compare $AC38.w with Y register [Reads: Y Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	lda ($FC.b)		; B2 FC ; Load accumulator (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	pea $5084.w		; F4 84 50 ; Push absolute address $5084.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	cpx #$C000.w		; E0 00 C0 ; Compare #$C000.w with X register [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	jsr $05C0.w		; 20 C0 05 ; Jump to subroutine at $05C0.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0E1E.w,Y		; 19 1E 0E ; OR accumulator with memory $0E1E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $180D01.l,X		; 1F 01 0D 18 ; Logical OR long $180D01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $0438.w		; 20 38 04 ; Jump to subroutine at $0438.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $010F.w,X		; 1E 0F 01 ; Arithmetic shift left $010F.w,X [Reads: X Index] [Flags: ZNC]
	jsr $0038.w		; 20 38 00 ; Jump to subroutine at $0038.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sty $0684.w		; 8C 84 06 ; Store Y register to $0684.w [Reads: Y Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5040.w		; 20 40 50 ; Jump to subroutine at $5040.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $0206.w		; 8C 06 02 ; Store Y register to $0206.w [Reads: Y Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $53		; 70 53 ; Branch if overflow set to $70, $53 [Flow: branch]
	jsr $C470.w		; 20 70 C4 ; Jump to subroutine at $C470.w [Writes: Stack Pointer] [Flow: call]
	ldy #$4000.w		; A0 00 40 ; Load #$4000.w into Y register [Writes: Y Index] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	.db $30, $80		; 30 80 ; Branch if minus to $30, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $A040.w		; 20 40 A0 ; Jump to subroutine at $A040.w [Writes: Stack Pointer] [Flow: call]
	cpy #$4140.w		; C0 40 41 ; Compare #$4140.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($C2.b,X)		; 01 C2 ; Logical OR ($C2.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $8645.w		; 0C 45 86 ; Test and set bits $8645.w [Reads: Accumulator] [Flags: Z]
	.db $82, $00, $00		; 82 00 00 ; Branch always long to $82, $00, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$4241.w		; C0 41 42 ; Compare #$4241.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora $82.b		; 05 82 ; Logical OR $82.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $0303.w,X		; 1E 03 03 ; Arithmetic shift left $0303.w,X [Reads: X Index] [Flags: ZNC]
	and ($3E.b),Y		; 31 3E ; AND accumulator with memory ($3E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $333C00.l,X		; FF 00 3C 33 ; Subtract with carry (long,X) $333C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$823C]		; DC 3C 82 ; Jump long indirect [$823C] [Flow: jump]
	inc $13ED.w,X		; FE ED 13 ; Increment memory $13ED.w,X [Reads: X Index] [Flags: ZN]
	lda $E943.w,X		; BD 43 E9 ; Load $E943.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$86.b],Y		; 17 86 ; OR accumulator with memory (long indexed) [$86.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $7870.w,X		; FE 70 78 ; Increment memory $7870.w,X [Reads: X Index] [Flags: ZN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $4313.w,X		; FE 13 43 ; Increment memory $4313.w,X [Reads: X Index] [Flags: ZN]
	ora [$FE.b],Y		; 17 FE ; OR accumulator with memory (long indexed) [$FE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$98E0.w		; E0 E0 98 ; Compare #$98E0.w with X register [Reads: X Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx $9C.b		; E4 9C ; Compare $9C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ror $5A.b		; 66 5A ; Rotate right $5A.b [Reads: Direct Page] [Flags: ZNC]
	ror $2D.b		; 66 2D ; Rotate right $2D.b [Reads: Direct Page] [Flags: ZNC]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stz $6666.w		; 9C 66 66 ; Store zero to $6666.w
	and ($B0.b,S),Y		; 33 B0 ; AND accumulator (stack relative indirect indexed) ($B0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $A8		; 70 A8 ; Branch if overflow set to $70, $A8 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	mvn $2A,$6C		; 54 6C 2A ; Move block negative $2A,$6C [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	rol $2A.b,X		; 36 2A ; Rotate left $2A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $2A.b,X		; 36 2A ; Rotate left $2A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $15.b,X		; 36 15 ; Rotate left $15.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $1B.b,X		; 15 1B ; OR accumulator with memory $1B.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $70, $D8		; 70 D8 ; Branch if overflow set to $70, $D8 [Flow: branch]
	jmp ($3636.w)		; 6C 36 36 ; Jump indirect to ($3636.w) [Flow: jump]
	rol $1B.b,X		; 36 1B ; Rotate left $1B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $7414.w		; 1C 14 74 ; Test and reset bits $7414.w [Reads: Accumulator] [Flags: Z]
	jmp ($EC94.w)		; 6C 94 EC ; Jump indirect to ($EC94.w) [Flow: jump]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $90, $70		; 90 70 ; Branch if carry clear to $90, $70 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$8080.w		; E0 80 80 ; Compare #$8080.w with X register [Reads: X Index] [Flags: ZNC]
	trb $6C.b		; 14 6C ; Test and reset bits $6C.b [Reads: Accumulator] [Flags: Z]
	cpx $1898.w		; EC 98 18 ; Compare $1898.w with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $4D3C.w,X		; 3D 3C 4D ; AND accumulator with memory $4D3C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	mvp $77,$77		; 44 77 77 ; Move block positive $77,$77 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $647E3A.l,X		; 3F 3A 7E 64 ; AND accumulator with memory (long,X) $647E3A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $59.b		; 02 59 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $BB43.w		; 0E 43 BB ; Arithmetic shift left $BB43.w [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $1A.b		; C5 1A ; Compare $1A.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	rol $392C.w		; 2E 2C 39 ; Rotate left $392C.w [Flags: ZNC]
	and ($26.b),Y		; 31 26 ; AND accumulator with memory ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $77.b		; 26 77 ; Rotate left $77.b [Reads: Direct Page] [Flags: ZNC]
	adc $7D.b,X		; 75 7D ; Add $7D.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc #$0E3E.w		; 69 3E 0E ; Add #$0E3E.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $0E52.w		; 2C 52 0E ; Test bits $0E52.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	eor $968A.w,Y		; 59 8A 96 ; Exclusive OR accumulator with memory $968A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $CC		; 10 CC ; Branch if plus to $10, $CC [Flow: branch]
	cpy $3C3C.w		; CC 3C 3C ; Compare $3C3C.w with Y register [Reads: Y Index] [Flags: ZNC]
	ror $62.b		; 66 62 ; Rotate right $62.b [Reads: Direct Page] [Flags: ZNC]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	eor $2E3E.w,Y		; 59 3E 2E ; Exclusive OR accumulator with memory $2E3E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and $01.b,X		; 35 01 ; Logical AND $01.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $4A		; 10 4A ; Branch if plus to $10, $4A [Flow: branch]
	.db $30, $42		; 30 42 ; Branch if minus to $30, $42 [Flow: branch]
	sta $5126.w,X		; 9D 26 51 ; Store accumulator to $5126.w,X [Reads: Accumulator, X Index]
	bit $0001.w,X		; 3C 01 00 ; Test bits $0001.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $14.b		; 04 14 ; Test and set bits $14.b [Reads: Accumulator] [Flags: Z]
	asl $1F2A.w		; 0E 2A 1F ; Arithmetic shift left $1F2A.w [Flags: ZNC]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	trb $0044.w		; 1C 44 00 ; Test and reset bits $0044.w [Reads: Accumulator] [Flags: Z]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $2A.b		; 14 2A ; Test and reset bits $2A.b [Reads: Accumulator] [Flags: Z]
	and ($4A.b),Y		; 31 4A ; AND accumulator with memory ($4A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	mvp $00,$00		; 44 00 00 ; Move block positive $00,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: ZNC]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $30, $28		; 30 28 ; Branch if minus to $30, $28 [Flow: branch]
	trb $0C.b		; 14 0C ; Test and reset bits $0C.b [Reads: Accumulator] [Flags: Z]
	asl $12.b		; 06 12 ; Arithmetic shift left $12.b [Reads: Direct Page] [Flags: ZNC]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	jsr $5080.w		; 20 80 50 ; Jump to subroutine at $5080.w [Writes: Stack Pointer] [Flow: call]
	stz $60.b		; 64 60 ; Store zero to $60.b
	asl $2200.w,X		; 1E 00 22 ; Arithmetic shift left $2200.w,X [Reads: X Index] [Flags: ZNC]
	trb $7413.w		; 1C 13 74 ; Test and reset bits $7413.w [Reads: Accumulator] [Flags: Z]
	ora $46.b		; 05 46 ; Logical OR $46.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $60		; 50 60 ; Branch if overflow clear to $50, $60 [Flow: branch]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $46.b,X		; 74 46 ; Store zero to $46.b,X [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	bit $6200.w		; 2C 00 62 ; Test bits $6200.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	tsb $708A.w		; 0C 8A 70 ; Test and set bits $708A.w [Reads: Accumulator] [Flags: Z]
	ldy $78.b,X		; B4 78 ; Load Y register $78.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stx $8204.w		; 8E 04 82 ; Store X register to $8204.w [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	stx $0082.w		; 8E 82 00 ; Store X register to $0082.w [Reads: X Index]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $E0,$A4		; 44 A4 E0 ; Move block positive $E0,$A4 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $40,$E0		; 44 E0 40 ; Move block positive $40,$E0 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	jmp ($4654.w)		; 6C 54 46 ; Jump indirect to ($4654.w) [Flow: jump]
	adc $7D2A.w,X		; 7D 2A 7D ; Add $7D2A.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $143F.w		; 6D 3F 14 ; Add $143F.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	and $06271A.l,X		; 3F 1A 27 06 ; AND accumulator with memory (long,X) $06271A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0200.w,Y		; 19 00 02 ; OR accumulator with memory $0200.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	mvp $3D,$7C		; 44 7C 3D ; Move block positive $3D,$7C [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $000216.l,X		; 3F 16 02 00 ; AND accumulator with memory (long,X) $000216.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $9A.b		; 00 9A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $DC.b,X		; 36 DC ; Rotate left $DC.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jmp ($F814.w)		; 6C 14 F8 ; Jump indirect to ($F814.w) [Flow: jump]
	bit $F4.b		; 24 F4 ; Test bits $F4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	stz $00.b		; 64 00 ; Store zero to $00.b
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $6C.b,X		; 16 6C ; Arithmetic shift left $6C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $F0, $E4		; F0 E4 ; Branch if equal to $F0, $E4 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $FBC5.w,X		; 3D C5 FB ; AND accumulator with memory $FBC5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	dec $C4.b		; C6 C4 ; Decrement $C4.b [Reads: Direct Page] [Flags: ZN]
	bit $F838.w,X		; 3C 38 F8 ; Test bits $F838.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpy #$02C0.w		; C0 C0 02 ; Compare #$02C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora [$3D.b]		; 07 3D ; OR accumulator with memory (long) [$3D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	dec $3C.b		; C6 3C ; Decrement $3C.b [Reads: Direct Page] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$0010.w		; C0 10 00 ; Compare #$0010.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sec		; 38 ; Set carry flag [Flags: C]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $30, $0A		; 30 0A ; Branch if minus to $30, $0A [Flow: branch]
	.db $F0, $4A		; F0 4A ; Branch if equal to $F0, $4A [Flow: branch]
	pei ($6E.b)		; D4 6E ; Push effective indirect address ($6E.b) [Reads: Direct Page] [Writes: Stack Pointer]
	jmp $000064.l		; 5C 64 00 00 ; Jump long to $000064.l [Flow: jump]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ror $7E64.w		; 6E 64 7E ; Rotate right $7E64.w [Flags: ZNC]
	mvp $D4,$AA		; 44 AA D4 ; Move block positive $D4,$AA [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	clv		; B8 ; Clear overflow flag [Flags: V]
	dec $92.b		; C6 92 ; Decrement $92.b [Reads: Direct Page] [Flags: ZN]
	inc $C63A.w		; EE 3A C6 ; Increment $C63A.w [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ror $44.b		; 66 44 ; Rotate right $44.b [Reads: Direct Page] [Flags: ZNC]
	jmp ($3838.w,X)		; 7C 38 38 ; Jump indirect indexed to ($3838.w,X) [Reads: X Index] [Flow: jump]
	mvp $C6,$D4		; 44 D4 C6 ; Move block positive $C6,$D4 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	inc $66C6.w		; EE C6 66 ; Increment $66C6.w [Flags: ZN]
	jmp ($0138.w,X)		; 7C 38 01 ; Jump indirect indexed to ($0138.w,X) [Reads: X Index] [Flow: jump]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	rol $08.b		; 26 08 ; Rotate left $08.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $0C		; 30 0C ; Branch if minus to $30, $0C [Flow: branch]
	.db $50, $30		; 50 30 ; Branch if overflow clear to $50, $30 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1A.b]		; 07 1A ; OR accumulator with memory (long) [$1A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: ZNC]
	tsb $4030.w		; 0C 30 40 ; Test and set bits $4030.w [Reads: Accumulator] [Flags: Z]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $2C5775.l		; 22 75 57 2C ; Jump to subroutine long $2C5775.l [Writes: Stack Pointer] [Flow: call]
	and $37342B.l,X		; 3F 2B 34 37 ; AND accumulator with memory (long,X) $37342B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $302F70.l		; 4F 70 2F 30 ; Exclusive OR accumulator with memory (long) $302F70.l [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$3F.b],Y		; 57 3F ; Exclusive OR accumulator with memory (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $38.b,X		; 34 38 ; Test bits $38.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $70, $30		; 70 30 ; Branch if overflow set to $70, $30 [Flow: branch]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldx $3E.b		; A6 3E ; Load $3E.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	cmp ($7C.b,X)		; C1 7C ; Compare accumulator ($7C.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sta $18.b,S		; 83 18 ; Store accumulator (stack relative) $18.b,S [Reads: Accumulator, Stack Pointer]
	adc $08.b		; 65 08 ; Add $08.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $A628.w		; 1C 28 A6 ; Test and reset bits $A628.w [Reads: Accumulator] [Flags: Z]
	cmp ($83.b,X)		; C1 83 ; Compare accumulator ($83.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	adc $14.b		; 65 14 ; Add $14.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $70, $D0		; 70 D0 ; Branch if overflow set to $70, $D0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	inc $BE62.w,X		; FE 62 BE ; Increment memory $BE62.w,X [Reads: X Index] [Flags: ZN]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	asl $097F.w		; 0E 7F 09 ; Arithmetic shift left $097F.w [Flags: ZNC]
	sta $D05028.l,X		; 9F 28 50 D0 ; Store accumulator (long,X) $D05028.l,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	rol $11.b		; 26 11 ; Rotate left $11.b [Reads: Direct Page] [Flags: ZNC]
	asl $080F.w,X		; 1E 0F 08 ; Arithmetic shift left $080F.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	.db $90, $F8		; 90 F8 ; Branch if carry clear to $90, $F8 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	inc $EF5E.w,X		; FE 5E EF ; Increment memory $EF5E.w,X [Reads: X Index] [Flags: ZN]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $186F60.l,X		; 7F 60 6F 18 ; Add long $186F60.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $B0		; 30 B0 ; Branch if minus to $30, $B0 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $2347.w		; 4E 47 23 ; Logical shift right $2347.w [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	jsr $50F0.w		; 20 F0 50 ; Jump to subroutine at $50F0.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	jmp $570A6F.l		; 5C 6F 0A 57 ; Jump long to $570A6F.l [Flow: jump]
	ora $EF.b,S		; 03 EF ; OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $30		; 70 30 ; Branch if overflow set to $70, $30 [Flow: branch]
	jmp $2346.w		; 4C 46 23 ; Jump to $2346.w [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $10, $6C		; 10 6C ; Branch if plus to $10, $6C [Flow: branch]
	tsb $1733.w		; 0C 33 17 ; Test and set bits $1733.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $030F06.l,X		; 1F 06 0F 03 ; Logical OR long $030F06.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($3833.w)		; 6C 33 38 ; Jump indirect to ($3833.w) [Flow: jump]
	ora $00030F.l,X		; 1F 0F 03 00 ; Logical OR long $00030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl $12.b,X		; 16 12 ; Arithmetic shift left $12.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ror $CC34.w		; 6E 34 CC ; Rotate right $CC34.w [Flags: ZNC]
	pei ($2C.b)		; D4 2C ; Push effective indirect address ($2C.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $2CCC.w		; 6E CC 2C ; Rotate right $2CCC.w [Flags: ZNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $19.b,S		; 43 19 ; Exclusive OR accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc ($28.b,X)		; 61 28 ; Add with carry ($28.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	and ($0B.b),Y		; 31 0B ; AND accumulator with memory ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $03.b		; 14 03 ; Test and reset bits $03.b [Reads: Accumulator] [Flags: Z]
	asl $0300.w		; 0E 00 03 ; Arithmetic shift left $0300.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $61.b,S		; 43 61 ; Exclusive OR accumulator with stack relative $61.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $31		; 30 31 ; Branch if minus to $30, $31 [Flow: branch]
	trb $0E.b		; [PATTERN: Memory clearing operation] 14 0E ; Test and reset bits $0E.b [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	stz $02.b		; 64 02 ; Store zero to $02.b
	stz $9444.w		; 9C 44 94 ; Store zero to $9444.w
	tsb $58A8.w		; 0C A8 58 ; Test and set bits $58A8.w [Reads: Accumulator] [Flags: Z]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $44.b		; 02 44 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $F058.w		; 0C 58 F0 ; Test and set bits $F058.w [Reads: Accumulator] [Flags: Z]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $7D.b		; 06 7D ; Arithmetic shift left $7D.b [Reads: Direct Page] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $393E.w		; 1C 3E 39 ; Test and reset bits $393E.w [Reads: Accumulator] [Flags: Z]
	rol $35.b,X		; 36 35 ; Rotate left $35.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx $00E0.w,Y		; BE E0 00 ; Load X register $00E0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($6C9C.w,X)		; 7C 9C 6C ; Jump indirect indexed to ($6C9C.w,X) [Reads: X Index] [Flow: jump]
	ldy $0000.w		; AC 00 00 ; Load $0000.w into Y register [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr $1034.w		; 20 34 10 ; Jump to subroutine at $1034.w [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0002.w		; 0E 02 00 ; Arithmetic shift left $0002.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0C16.w		; 2C 16 0C ; Test bits $0C16.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$7800.w		; C0 00 78 ; Compare #$7800.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $BF		; 30 BF ; Branch if minus to $30, $BF [Flow: branch]
	jsr $1867.w		; 20 67 18 ; Jump to subroutine at $1867.w [Writes: Stack Pointer] [Flow: call]
	and $2706.w,Y		; 39 06 27 ; AND accumulator with memory $2706.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	inc $60F1.w,X		; FE F1 60 ; Increment memory $60F1.w,X [Reads: X Index] [Flags: ZN]
	ora $0006.w,Y		; 19 06 00 ; OR accumulator with memory $0006.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $0D1301.l		; 0F 01 13 0D ; OR accumulator with memory (long) $0D1301.l [Writes: Accumulator] [Flags: ZN]
	and [$19.b]		; 27 19 ; AND accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $2612.w		; 0E 12 26 ; Arithmetic shift left $2612.w [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $30, $E8		; 30 E8 ; Branch if minus to $30, $E8 [Flow: branch]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$D0E0.w		; C0 E0 D0 ; Compare #$D0E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $98		; 80 98 ; Branch always to $80, $98 [Flow: branch]
	sbc ($4E.b,X)		; E1 4E ; Subtract with carry ($4E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($62.b,S),Y		; 73 62 ; Add with carry (stack relative indirect indexed) ($62.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $3D1B.w,X		; 7D 1B 3D ; Add $3D1B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $040E.w		; 0D 0E 04 ; Logical OR $040E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $E18000.l		; 0F 00 80 E1 ; OR accumulator with memory (long) $E18000.l [Writes: Accumulator] [Flags: ZN]
	adc ($7D.b,S),Y		; 73 7D ; Add with carry (stack relative indirect indexed) ($7D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $0F0E.w,X		; 3D 0E 0F ; AND accumulator with memory $0F0E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $70, $4C		; 70 4C ; Branch if overflow set to $70, $4C [Flow: branch]
	cmp $B0.b,S		; C3 B0 ; Compare accumulator (stack relative) $B0.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	.db $42, $A1		; 42 A1 ; Reserved instruction
	tsb $E3.b		; 04 E3 ; Test and set bits $E3.b [Reads: Accumulator] [Flags: Z]
	tsb $C2.b		; 04 C2 ; Test and set bits $C2.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp $A1B0.w		; 4C B0 A1 ; Jump to $A1B0.w [Flow: jump]
	sbc $C2.b,S		; E3 C2 ; Subtract stack-relative $C2.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	and $3F6000.l,X		; 3F 00 60 3F ; AND accumulator with memory (long,X) $3F6000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $D0, $7F		; D0 7F ; Branch if not equal to $D0, $7F [Flow: branch]
	lda $7F907F.l		; AF 7F 90 7F ; Load long $7F907F.l into accumulator [Writes: Accumulator] [Flags: ZN]
	sta [$78.b],Y		; 97 78 ; Store accumulator (long indexed) [$78.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sta [$78.b],Y		; 97 78 ; Store accumulator (long indexed) [$78.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sta [$78.b],Y		; 97 78 ; Store accumulator (long indexed) [$78.b],Y [Reads: Accumulator, Direct Page, Y Index]
	and $BFF060.l,X		; 3F 60 F0 BF ; AND accumulator with memory (long,X) $BFF060.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $989898.l,X		; 9F 98 98 98 ; Store accumulator (long,X) $989898.l,X [Reads: Accumulator, X Index]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0A15.w,X		; 1E 15 0A ; Arithmetic shift left $0A15.w,X [Reads: X Index] [Flags: ZNC]
	asl $1B05.w,X		; 1E 05 1B ; Arithmetic shift left $1B05.w,X [Reads: X Index] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $87.b		; 02 87 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $1A15.w		; 20 15 1A ; Jump to subroutine at $1A15.w [Writes: Stack Pointer] [Flow: call]
	ora $0D.b,X		; 15 0D ; OR accumulator with memory $0D.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$4C.b]		; 07 4C ; OR accumulator with memory (long) [$4C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($10.b)		; D2 10 ; Compare accumulator (indirect) ($10.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	cpx $C23C.w		; EC 3C C2 ; Compare $C23C.w with X register [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	tsb $76.b		; 04 76 ; Test and set bits $76.b [Reads: Accumulator] [Flags: Z]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	trb $FC32.w		; 1C 32 FC ; Test and reset bits $FC32.w [Reads: Accumulator] [Flags: Z]
	dec $0017.w		; CE 17 00 ; Decrement $0017.w [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0A15.w,X		; 1E 15 0A ; Arithmetic shift left $0A15.w,X [Reads: X Index] [Flags: ZNC]
	asl $1B05.w,X		; 1E 05 1B ; Arithmetic shift left $1B05.w,X [Reads: X Index] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $87.b		; 02 87 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $1A15.w		; 20 15 1A ; Jump to subroutine at $1A15.w [Writes: Stack Pointer] [Flow: call]
	ora $0D.b,X		; 15 0D ; OR accumulator with memory $0D.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$40.b]		; 07 40 ; OR accumulator with memory (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F00C.w		; C0 0C F0 ; Compare #$F00C.w with Y register [Reads: Y Index] [Flags: ZNC]
	and ($CC.b)		; 32 CC ; AND accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tsb $76.b		; 04 76 ; Test and set bits $76.b [Reads: Accumulator] [Flags: Z]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $08		; 30 08 ; Branch if minus to $30, $08 [Flow: branch]
	bit $CEFC.w,X		; 3C FC CE ; Test bits $CEFC.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	and [$2B.b]		; 27 2B ; AND accumulator with memory (long) [$2B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $267E.w,Y		; 19 7E 26 ; OR accumulator with memory $267E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor $DE35FF.l		; 4F FF 35 DE ; Exclusive OR accumulator with memory (long) $DE35FF.l [Writes: Accumulator] [Flags: ZN]
	and #$495E.w		; 29 5E 49 ; Logical AND #$495E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ldx $10.b,Y		; B6 10 ; Load X register $10.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	and $5A.b,S		; 23 5A ; AND accumulator with stack relative $5A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda ($7F.b,S),Y		; B3 7F ; Load accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $4E.b,X		; 56 4E ; Logical shift right $4E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	lda [$40.b]		; A7 40 ; Load accumulator (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy #$F830.w		; A0 30 F8 ; Load #$F830.w into Y register [Writes: Y Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	and $CE34.w,X		; 3D 34 CE ; AND accumulator with memory $CE34.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $FE		; 80 FE ; Branch always to $80, $FE [Flow: branch]
	pea $163A.w		; F4 3A 16 ; Push absolute address $163A.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $7F8C.w		; ED 8C 7F ; Subtract $7F8C.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	ldy #$1930.w		; A0 30 19 ; Load #$1930.w into Y register [Writes: Y Index] [Flags: ZN]
	cpy $328C.w		; CC 8C 32 ; Compare $328C.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx $FE.b		; E4 FE ; Compare $FE.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	bit $3E07.w,X		; 3C 07 3E ; Test bits $3E07.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $0306.w		; 0D 06 03 ; Logical OR $0306.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$C07C.w		; E0 7C C0 ; Compare #$C07C.w with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $B0, $60		; B0 60 ; Branch if carry set to $B0, $60 [Flow: branch]
	cpy #$0080.w		; C0 80 00 ; Compare #$0080.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1052.w		; 0C 52 10 ; Test and set bits $1052.w [Reads: Accumulator] [Flags: Z]
	stz $20.b		; 64 20 ; Store zero to $20.b
	sed		; F8 ; Set decimal flag [Flags: D]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $321F.w		; 0D 1F 32 ; Logical OR $321F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ror $985C.w		; 6E 5C 98 ; Rotate right $985C.w [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $1076.w		; 20 76 10 ; Jump to subroutine at $1076.w [Writes: Stack Pointer] [Flow: call]
	and $2C3E10.l,X		; 3F 10 3E 2C ; AND accumulator with memory (long,X) $2C3E10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $5A.b,X		; 76 5A ; Rotate right $5A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc [$7E.b]		; E7 7E ; Subtract with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: ZNC]
	bit $1624.w,X		; 3C 24 16 ; Test bits $1624.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	trb $6634.w		; 1C 34 66 ; Test and reset bits $6634.w [Reads: Accumulator] [Flags: Z]
	.db $42, $24		; 42 24 ; Reserved instruction
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $BE		; 30 BE ; Branch if minus to $30, $BE [Flow: branch]
	jsr $1A65.w		; 20 65 1A ; Jump to subroutine at $1A65.w [Writes: Stack Pointer] [Flow: call]
	and $2706.w,Y		; 39 06 27 ; AND accumulator with memory $2706.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $F0		; 50 F0 ; Branch if overflow clear to $50, $F0 [Flow: branch]
	sbc ($65.b)		; F2 65 ; Subtract with carry (indirect) ($65.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $0006.w,Y		; 19 06 00 ; OR accumulator with memory $0006.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	ora #$0606.w		; 09 06 06 ; Logical OR #$0606.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora #$0006.w		; 09 06 00 ; Logical OR #$0006.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	.db $F0, $48		; F0 48 ; Branch if equal to $F0, $48 [Flow: branch]
	.db $B0, $A8		; B0 A8 ; Branch if carry set to $B0, $A8 [Flow: branch]
	.db $F0, $D0		; F0 D0 ; Branch if equal to $F0, $D0 [Flow: branch]
	cpx #$E010.w		; E0 10 E0 ; Compare #$E010.w with X register [Reads: X Index] [Flags: ZNC]
	jsr $C0C0.w		; 20 C0 C0 ; Jump to subroutine at $C0C0.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	jsr $00C0.w		; 20 C0 00 ; Jump to subroutine at $00C0.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $0406.w		; 0C 06 04 ; Test and set bits $0406.w [Reads: Accumulator] [Flags: Z]
	jsr $0002.w		; 20 02 00 ; Jump to subroutine at $0002.w [Writes: Stack Pointer] [Flow: call]
	jsr $7804.w		; 20 04 78 ; Jump to subroutine at $7804.w [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: ZNC]
	tsb $0204.w		; 0C 04 02 ; Test and set bits $0204.w [Reads: Accumulator] [Flags: Z]
	jsr $0078.w		; 20 78 00 ; Jump to subroutine at $0078.w [Writes: Stack Pointer] [Flow: call]
	ora ($C1.b,S),Y		; 13 C1 ; OR accumulator (stack relative indirect indexed) ($C1.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($80.b)		; 12 80 ; OR accumulator with memory (indirect) ($80.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $80		; 10 80 ; Branch if plus to $10, $80 [Flow: branch]
	jsr $2210.w		; 20 10 22 ; Jump to subroutine at $2210.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $40		; 10 40 ; Branch if plus to $10, $40 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $60.b		; 14 60 ; Test and reset bits $60.b [Reads: Accumulator] [Flags: Z]
	cpx #$C100.w		; E0 00 C1 ; Compare #$C100.w with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $C03F.w		; 0C 3F C0 ; Test and set bits $C03F.w [Reads: Accumulator] [Flags: Z]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$020C.w		; C0 0C 02 ; Compare #$020C.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($37.b,X)		; 01 37 ; Logical OR ($37.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $2D.b		; 04 2D ; Test and set bits $2D.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $18.b,X		; 35 18 ; Logical AND $18.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($C0.b),Y		; F1 C0 ; Subtract with carry ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $1830.w		; AE 30 18 ; Load $1830.w into X register [Writes: X Index] [Flags: ZN]
	cpx #$10F8.w		; E0 F8 10 ; Compare #$10F8.w with X register [Reads: X Index] [Flags: ZNC]
	cpx $6A40.w		; EC 40 6A ; Compare $6A40.w with X register [Reads: X Index] [Flags: ZNC]
	jsr $002C.w		; 20 2C 00 ; Jump to subroutine at $002C.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sbc $E8F8FE.l,X		; FF FE F8 E8 ; Subtract with carry (long,X) $E8F8FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy $3C5E.w,X		; BC 5E 3C ; Load Y register $3C5E.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $10, $4A		; 10 4A ; Branch if plus to $10, $4A [Flow: branch]
	ora ($37.b,X)		; 01 37 ; Logical OR ($37.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $2D.b		; 04 2D ; Test and set bits $2D.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $18.b,X		; 35 18 ; Logical AND $18.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($C0.b),Y		; F1 C0 ; Subtract with carry ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $1830.w		; AE 30 18 ; Load $1830.w into X register [Writes: X Index] [Flags: ZN]
	cpx $F8.b		; E4 F8 ; Compare $F8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $10, $EC		; 10 EC ; Branch if plus to $10, $EC [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsr $002C.w		; 20 2C 00 ; Jump to subroutine at $002C.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sbc $E8FCFE.l,X		; FF FE FC E8 ; Subtract with carry (long,X) $E8FCFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy $3C5E.w,X		; BC 5E 3C ; Load Y register $3C5E.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	inc $AF.b,X		; F6 AF ; Increment memory $AF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cmp $DFA5.w,Y		; D9 A5 DF ; Compare accumulator $DFA5.w,Y [Reads: Y Index] [Flags: ZNC]
	sta ($6F.b)		; 92 6F ; Store accumulator (indirect) ($6F.b) [Reads: Accumulator, Direct Page]
	ora $7F4677.l		; 0F 77 46 7F ; OR accumulator with memory (long) $7F4677.l [Writes: Accumulator] [Flags: ZN]
	ora ($1E.b),Y		; 11 1E ; OR accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$E7.b]		; 07 E7 ; OR accumulator with memory (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp #$2FDF.w		; C9 DF 2F ; Compare #$2FDF.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	and [$47.b]		; 27 47 ; AND accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	cmp #$A93E.w		; C9 3E A9 ; Compare #$A93E.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	cmp $6ACEB7.l,X		; DF B7 CE 6A ; Compare accumulator (long,X) $6ACEB7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sty $92.b,X		; 94 92 ; Store Y register $92.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	inc $1AE4.w		; EE E4 1A ; Increment $1AE4.w [Flags: ZN]
	.db $B0, $7C		; B0 7C ; Branch if carry set to $B0, $7C [Flow: branch]
	jsr $BCE0.w		; 20 E0 BC ; Jump to subroutine at $BCE0.w [Writes: Stack Pointer] [Flow: call]
	cmp $80CE.w,X		; DD CE 80 ; Compare accumulator $80CE.w,X [Reads: X Index] [Flags: ZNC]
	stx $18.b		; 86 18 ; Store X register to $18.b [Reads: X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr $0038.w		; 20 38 00 ; Jump to subroutine at $0038.w [Writes: Stack Pointer] [Flow: call]
	jmp ($FE38.w,X)		; 7C 38 FE ; Jump indirect indexed to ($FE38.w,X) [Reads: X Index] [Flow: jump]
	mvp $18,$BA		; 44 BA 18 ; Move block positive $18,$BA [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	jmp ($3844.w,X)		; 7C 44 38 ; Jump indirect indexed to ($3844.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$01.b],Y		; 77 01 ; Add with carry (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $40.b,X		; 76 40 ; Rotate right $40.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and [$04.b],Y		; 37 04 ; AND accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($03.b,S),Y		; 33 03 ; AND accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $DF00.w		; 8E 00 DF ; Store X register to $DF00.w [Reads: X Index]
	tsb $DB.b		; 04 DB ; Test and set bits $DB.b [Reads: Accumulator] [Flags: Z]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $CF		; 10 CF ; Branch if plus to $10, $CF [Flow: branch]
	tsb $41CF.w		; 0C CF 41 ; Test and set bits $41CF.w [Reads: Accumulator] [Flags: Z]
	stx $008E.w		; 8E 8E 00 ; Store X register to $008E.w [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $6C		; 10 6C ; Branch if plus to $10, $6C [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $7804.w,X		; 3C 04 78 ; Test bits $7804.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp ($7C00.w,X)		; 7C 00 7C ; Jump indirect indexed to ($7C00.w,X) [Reads: X Index] [Flow: jump]
	jmp ($0000.w,X)		; 7C 00 00 ; Jump indirect indexed to ($0000.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $3D00.w,Y		; 39 00 3D ; AND accumulator with memory $3D00.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and [$04.b],Y		; 37 04 ; AND accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($02.b,S),Y		; 33 02 ; AND accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($31.b),Y		; 31 31 ; AND accumulator with memory ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($1000.w,X)		; 7C 00 10 ; Jump indirect indexed to ($1000.w,X) [Reads: X Index] [Flow: jump]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF1FFF.l		; 0F FF 1F FF ; OR accumulator with memory (long) $FF1FFF.l [Writes: Accumulator] [Flags: ZN]
	and $F03FFF.l,X		; 3F FF 3F F0 ; AND accumulator with memory (long,X) $F03FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $003FE0.l,X		; 3F E0 3F 00 ; AND accumulator with memory (long,X) $003FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7F7F1F.l,X		; 5F 1F 7F 7F ; Exclusive OR accumulator with memory (long,X) $7F7F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FF7F7F.l,X		; 7F 7F 7F FF ; Add long $FF7F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $CFCFFF.l,X		; FF FF CF CF ; Subtract with carry (long,X) $CFCFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy $FC.b,X		; B4 FC ; Load Y register $FC.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	sta $85.b,S		; 83 85 ; Store accumulator (stack relative) $85.b,S [Reads: Accumulator, Stack Pointer]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	stz $8B.b,X		; 74 8B ; Store zero to $8B.b,X [Reads: X Index]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FCCFFF.l,X		; FF FF CF FC ; Subtract with carry (long,X) $FCCFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $F4.b		; 85 F4 ; Store accumulator to $F4.b [Reads: Accumulator]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7FFFFF.l,X		; FF FF FF 7F ; Subtract with carry (long,X) $7FFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $ED1E9E.l,X		; 7F 9E 1E ED ; Add long $ED1E9E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($AD.b)		; 52 AD ; Exclusive OR accumulator with memory (indirect) ($AD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $EA.b,X		; 15 EA ; OR accumulator with memory $EA.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1E7FFF.l,X		; FF FF 7F 1E ; Subtract with carry (long,X) $1E7FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $FF1D.w,X		; 5E 1D FF ; Logical shift right $FF1D.w,X [Reads: X Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $111FFF.l,X		; FF FF 1F 11 ; Subtract with carry (long,X) $111FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $2DD2.w		; EE D2 2D ; Increment $2DD2.w [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00FFDE.l,X		; 1F DE FF 00 ; Logical OR long $00FFDE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $EE111E.l,X		; FF 1E 11 EE ; Subtract with carry (long,X) $EE111E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc #$0016.w		; E9 16 00 ; Subtract #$0016.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFEF1F.l,X		; FF 1F EF FF ; Subtract with carry (long,X) $FFEF1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($BB7C.w,X)		; 7C 7C BB ; Jump indirect indexed to ($BB7C.w,X) [Reads: X Index] [Flow: jump]
	eor [$B8.b]		; 47 B8 ; Exclusive OR accumulator with memory (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($787F.w,X)		; 7C 7F 78 ; Jump indirect indexed to ($787F.w,X) [Reads: X Index] [Flow: jump]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $EF1F1F.l,X		; FF 1F 1F EF ; Subtract with carry (long,X) $EF1F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	pea $FF00.w		; F4 00 FF ; Push absolute address $FF00.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $1FFFFF.l,X		; FF FF FF 1F ; Subtract with carry (long,X) $1FFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF0F.l,X		; FF 0F FF 00 ; Subtract with carry (long,X) $00FF0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C8FFFF.l,X		; FF FF FF C8 ; Subtract with carry (long,X) $C8FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	lda [$DF.b],Y		; B7 DF ; Load accumulator (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	jsr $00DF.w		; 20 DF 00 ; Jump to subroutine at $00DF.w [Writes: Stack Pointer] [Flow: call]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cmp $00FF3F.l,X		; DF 3F FF 00 ; Compare accumulator (long,X) $00FF3F.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1FFFFF.l,X		; FF FF FF 1F ; Subtract with carry (long,X) $1FFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $2ED1EF.l,X		; 1F EF D1 2E ; Logical OR long $2ED1EF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor [$A8.b],Y		; 57 A8 ; Exclusive OR accumulator with memory (long indexed) [$A8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1FFFFF.l,X		; FF FF FF 1F ; Subtract with carry (long,X) $1FFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $00FFDF.l,X		; DF DF FF 00 ; Compare accumulator (long,X) $00FFDF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7F80FE.l,X		; FF FE 80 7F ; Subtract with carry (long,X) $7F80FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $FF00A0.l,X		; 5F A0 00 FF ; Exclusive OR accumulator with memory (long,X) $FF00A0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00807F.l,X		; FF 7F 80 00 ; Subtract with carry (long,X) $00807F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	lda $00.b,X		; B5 00 ; Load $00.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda [$30.b],Y		; B7 30 ; Load accumulator (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda [$01.b],Y		; B7 01 ; Load accumulator (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ldx $00.b,Y		; B6 00 ; Load X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	ldx $00.b,Y		; B6 00 ; Load X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	ldx $B6.b,Y		; B6 B6 ; Load X register $B6.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $9E00.w		; 0C 00 9E ; Test and set bits $9E00.w [Reads: Accumulator] [Flags: Z]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($CC.b)		; 12 CC ; OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $0000.w		; CC 00 00 ; Compare $0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($00.b)		; 72 00 ; Add with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr $00FB.w		; 20 FB 00 ; Jump to subroutine at $00FB.w [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc ($80.b,S),Y		; F3 80 ; Subtract with carry (stack relative indirect indexed) ($80.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp ($00.b,X)		; C1 00 ; Compare accumulator ($00.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $006D82.l		; EF 82 6D 00 ; Subtract with carry (long) $006D82.l [Writes: Accumulator] [Flags: ZVNC]
	adc $676708.l		; 6F 08 67 67 ; Add with carry (long) $676708.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	stz $BE00.w		; 9C 00 BE ; Store zero to $BE00.w
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldx $00.b,Y		; B6 00 ; Load X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	ldx $00.b,Y		; B6 00 ; Load X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	ldx $9C22.w,Y		; BE 22 9C ; Load X register $9C22.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	stz $0000.w		; 9C 00 00 ; Store zero to $0000.w
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	cpy $B400.w		; CC 00 B4 ; Compare $B400.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $E03FE0.l,X		; 3F E0 3F E0 ; AND accumulator with memory (long,X) $E03FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $E030C0.l,X		; 3F C0 30 E0 ; AND accumulator with memory (long,X) $E030C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $7F7F7F.l,X		; 7F 7F 7F 7F ; Add long $7F7F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $005F1F.l,X		; 7F 1F 5F 00 ; Add long $005F1F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $8492.w		; 6D 92 84 ; Add $8492.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sty $29.b,X		; 94 29 ; Store Y register $29.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $EF.b		; 84 EF ; Store Y register to $EF.b [Reads: Y Index]
	sbc $FFFFFF.l		; EF FF FF FF ; Subtract with carry (long) $FFFFFF.l [Writes: Accumulator] [Flags: ZVNC]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $16.b		; A4 16 ; Load $16.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	sbc #$9E61.w		; E9 61 9E ; Subtract #$9E61.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $7F7F.w,X		; 1E 7F 7F ; Arithmetic shift left $7F7F.w,X [Reads: X Index] [Flags: ZNC]
	sbc $00FFFF.l,X		; FF FF FF 00 ; Subtract with carry (long,X) $00FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $AA.b,X		; 55 AA ; Exclusive OR accumulator with memory $AA.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $5A.b		; A5 5A ; Load $5A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $BA.b		; 45 BA ; Exclusive OR $BA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldx #$4145.w		; A2 45 41 ; Load #$4145.w into X register [Writes: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $BE7D.w,X		; BD 7D BE ; Load $BE7D.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00FFFF.l,X		; FF FF FF 00 ; Subtract with carry (long,X) $00FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $4A.b,X		; B5 4A ; Load $4A.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $4A.b,X		; B5 4A ; Load $4A.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $8A.b,X		; 55 8A ; Exclusive OR accumulator with memory $8A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda #$1014.w		; A9 14 10 ; Load #$1014.w into accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$77.b],Y		; B7 77 ; Load accumulator (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FFFFFF.l		; EF FF FF FF ; Subtract with carry (long) $FFFFFF.l [Writes: Accumulator] [Flags: ZVNC]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sta [$51.b],Y		; 97 51 ; Store accumulator (long indexed) [$51.b],Y [Reads: Accumulator, Direct Page, Y Index]
	ldx $8142.w		; AE 42 81 ; Load $8142.w into X register [Writes: X Index] [Flags: ZN]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Accumulator, X Index, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $7E7F6F.l,X		; 1F 6F 7F 7E ; Logical OR long $7E7F6F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00FFFF.l,X		; FF FF FF 00 ; Subtract with carry (long,X) $00FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $5313.w		; EC 13 53 ; Compare $5313.w with X register [Reads: X Index] [Flags: ZNC]
	ldy $5FA0.w		; AC A0 5F ; Load $5FA0.w into Y register [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $FF7FBF.l,X		; DF BF 7F FF ; Compare accumulator (long,X) $FF7FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $A000FF.l,X		; FF FF 00 A0 ; Subtract with carry (long,X) $A000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $A35FA0.l,X		; 5F A0 5F A3 ; Exclusive OR accumulator with memory (long,X) $A35FA0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp $4343A4.l		; 5C A4 43 43 ; Jump long to $4343A4.l [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $FFBCBF.l,X		; BF BF BC FF ; Load long $FFBCBF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $A800FF.l,X		; FF FF 00 A8 ; Subtract with carry (long,X) $A800FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor [$A6.b],Y		; 57 A6 ; Exclusive OR accumulator with memory (long indexed) [$A6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $BA45.w,Y		; 59 45 BA ; Exclusive OR accumulator with memory $BA45.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $FB7D.w,Y		; BE 7D FB ; Load X register $FB7D.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sbc $00FFFF.l,X		; FF FF FF 00 ; Subtract with carry (long,X) $00FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $5FDF.w		; 20 DF 5F ; Jump to subroutine at $5FDF.w [Writes: Stack Pointer] [Flow: call]
	ldy #$BE41.w		; A0 41 BE ; Load #$BE41.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $42, $81		; 42 81 ; Reserved instruction
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Accumulator, X Index, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $7F7F.w		; 20 7F 7F ; Jump to subroutine at $7F7F.w [Writes: Stack Pointer] [Flow: call]
	ror $FFFF.w,X		; 7E FF FF ; Rotate right $FFFF.w,X [Reads: X Index] [Flags: ZNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $07FFFF.l,X		; FF FF FF 07 ; Subtract with carry (long,X) $07FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$FB.b]		; 07 FB ; OR accumulator with memory (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pea $140B.w		; F4 0B 14 ; Push absolute address $140B.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $07FFFF.l,X		; FF FF FF 07 ; Subtract with carry (long,X) $07FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F8FFF0.l,X		; FF F0 FF F8 ; Subtract with carry (long,X) $F8FFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FCFFFC.l,X		; FF FC FF FC ; Subtract with carry (long,X) $FCFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FC07FC.l		; 0F FC 07 FC ; OR accumulator with memory (long) $FC07FC.l [Writes: Accumulator] [Flags: ZN]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $FEFE.w,X		; FE FE FE ; Increment memory $FEFE.w,X [Reads: X Index] [Flags: ZN]
	inc $01FE.w,X		; FE FE 01 ; Increment memory $01FE.w,X [Reads: X Index] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $F9.b		; 04 F9 ; Test and set bits $F9.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rol $0000.w,X		; 3E 00 00 ; Rotate left $0000.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $FCFFFC.l,X		; FF FC FF FC ; Subtract with carry (long,X) $FCFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $7C.b,S		; 83 7C ; Store accumulator (stack relative) $7C.b,S [Reads: Accumulator, Stack Pointer]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $FEFE.w,X		; FE FE FE ; Increment memory $FEFE.w,X [Reads: X Index] [Flags: ZN]
	inc $00FE.w,X		; FE FE 00 ; Increment memory $00FE.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9B.b		; 00 9B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $59.b		; 00 59 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CD.b		; 00 CD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $79.b		; 00 79 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $79.b		; 00 79 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$48.b],Y		; 57 48 ; Exclusive OR accumulator with memory (long indexed) [$48.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda [$B6.b],Y		; B7 B6 ; Load accumulator (long indexed) [$B6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor #$8649.w		; 49 49 86 ; Exclusive OR #$8649.w with accumulator [Writes: Accumulator] [Flags: ZN]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $79B7CF.l		; EF CF B7 79 ; Subtract with carry (long) $79B7CF.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FFFF.l,X		; FF FF FF 00 ; Subtract with carry (long,X) $00FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$FC.b]		; 07 FC ; OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$FC.b]		; 07 FC ; OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$FC.b]		; 07 FC ; OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00FF70.l		; 0F 70 FF 00 ; OR accumulator with memory (long) $00FF70.l [Writes: Accumulator] [Flags: ZN]
	sbc $FEFE00.l,X		; FF 00 FE FE ; Subtract with carry (long,X) $FEFE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FEFE.w,X		; FE FE FE ; Increment memory $FEFE.w,X [Reads: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$0080.w		; C0 80 00 ; Compare #$0080.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $BC43.w,X		; BC 43 BC ; Load Y register $BC43.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sta $7C.b,S		; 83 7C ; Store accumulator (stack relative) $7C.b,S [Reads: Accumulator, Stack Pointer]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00FF00.l		; 0F 00 FF 00 ; OR accumulator with memory (long) $00FF00.l [Writes: Accumulator] [Flags: ZN]
	sbc $7E7E00.l,X		; FF 00 7E 7E ; Subtract with carry (long,X) $7E7E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FEFE.w,X		; FE FE FE ; Increment memory $FEFE.w,X [Reads: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FBBFFD.l,X		; 7F FD BF FB ; Add long $FBBFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $007FBF.l,X		; DF BF 7F 00 ; Compare accumulator (long,X) $007FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D2.b		; 00 D2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$31.b]		; 07 31 ; OR accumulator with memory (long) [$31.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $4F366B.l,X		; 1F 6B 36 4F ; Logical OR long $4F366B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7F773F.l,X		; 1F 3F 77 7F ; Logical OR long $7F773F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	sty $3EF7.w		; 8C F7 3E ; Store Y register to $3EF7.w [Reads: Y Index]
	wai		; CB ; Wait for interrupt
	inc $37.b,X		; F6 37 ; Increment memory $37.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	dec $0000.w		; CE 00 00 ; Decrement $0000.w [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: ZN]
	sbc [$CF.b],Y		; F7 CF ; Subtract with carry (long indexed) [$CF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	adc ($1E.b,X)		; 61 1E ; Add with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lsr $2D.b,X		; 56 2D ; Logical shift right $2D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $77DF58.l		; EF 58 DF 77 ; Subtract with carry (long) $77DF58.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $33		; 10 33 ; Branch if plus to $10, $33 [Flow: branch]
	ror $DF6F.w,X		; 7E 6F DF ; Rotate right $DF6F.w,X [Reads: X Index] [Flags: ZNC]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	jmp ($C67C.w,X)		; 7C 7C C6 ; Jump indirect indexed to ($C67C.w,X) [Reads: X Index] [Flow: jump]
	inc $C73B.w,X		; FE 3B C7 ; Increment memory $C73B.w,X [Reads: X Index] [Flags: ZN]
	jmp ($0000.w,X)		; 7C 00 00 ; Jump indirect indexed to ($0000.w,X) [Reads: X Index] [Flow: jump]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($FFFE.w,X)		; 7C FE FF ; Jump indirect indexed to ($FFFE.w,X) [Reads: X Index] [Flow: jump]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $37.b		; 06 37 ; Arithmetic shift left $37.b [Reads: Direct Page] [Flags: ZNC]
	ora $1B7E.w,X		; 1D 7E 1B ; OR accumulator with memory $1B7E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $0036.w		; 6D 36 00 ; Add $0036.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $007E7F.l,X		; 3F 7F 7E 00 ; AND accumulator with memory (long,X) $007E7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $E000.w		; 20 00 E0 ; Jump to subroutine at $E000.w [Writes: Stack Pointer] [Flow: call]
	cpy #$F373.w		; C0 73 F3 ; Compare #$F373.w with Y register [Reads: Y Index] [Flags: ZNC]
	lda $BFCC7F.l,X		; BF 7F CC BF ; Load long $BFCC7F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $F3E0.w		; 20 E0 F3 ; Jump to subroutine at $F3E0.w [Writes: Stack Pointer] [Flow: call]
	sbc $007FFF.l,X		; FF FF 7F 00 ; Subtract with carry (long,X) $007FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: ZNC]
	asl $0C1B.w		; 0E 1B 0C ; Arithmetic shift left $0C1B.w [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0100.w		; 0C 00 01 ; Test and set bits $0100.w [Reads: Accumulator] [Flags: Z]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1C1E.w		; 0E 1E 1C ; Arithmetic shift left $1C1E.w [Flags: ZNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$7080.w		; E0 80 70 ; Compare #$7080.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$60B0.w		; E0 B0 60 ; Compare #$60B0.w with X register [Reads: X Index] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $D8		; 70 D8 ; Branch if overflow set to $70, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $F0, $70		; F0 70 ; Branch if equal to $F0, $70 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0C3306.l,X		; 1F 06 33 0C ; Logical OR long $0C3306.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $D430.w		; 6E 30 D4 ; Rotate right $D430.w [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $EC763F.l,X		; 1F 3F 76 EC ; Logical OR long $EC763F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $0FFC00.l		; 0F 00 FC 0F ; OR accumulator with memory (long) $0FFC00.l [Writes: Accumulator] [Flags: ZN]
	cmp $00F1F1.l		; CF F1 F1 00 ; Compare accumulator (long) $00F1F1.l [Reads: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F1FFFF.l		; 0F FF FF F1 ; OR accumulator with memory (long) $F1FFFF.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $00,$00		; 44 00 00 ; Move block positive $00,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($FF.b),Y		; 71 FF ; Add with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $5AF7.w		; 6E F7 5A ; Rotate right $5AF7.w [Flags: ZNC]
	adc $3D6735.l		; 6F 35 67 3D ; Add with carry (long) $3D6735.l [Writes: Accumulator] [Flags: ZVNC]
	and $001E1E.l,X		; 3F 1E 1E 00 ; AND accumulator with memory (long,X) $001E1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $77FBFF.l,X		; FF FF FB 77 ; Subtract with carry (long,X) $77FBFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $001E3F.l,X		; 7F 3F 1E 00 ; Add long $001E3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $6CD7C8.l,X		; BF C8 D7 6C ; Load long $6CD7C8.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda ($CE.b,S),Y		; B3 CE ; Load accumulator (stack relative indirect indexed) ($CE.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stx $9A.b		; 86 9A ; Store X register to $9A.b [Reads: X Index]
	cpx $C6.b		; E4 C6 ; Compare $C6.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	jmp ($18FC.w,X)		; 7C FC 18 ; Jump indirect indexed to ($18FC.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E687CF.l		; EF CF 87 E6 ; Subtract with carry (long) $E687CF.l [Writes: Accumulator] [Flags: ZVNC]
	inc $38FC.w,X		; FE FC 38 ; Increment memory $38FC.w,X [Reads: X Index] [Flags: ZN]
	cpx $E53F.w		; EC 3F E5 ; Compare $E53F.w with X register [Reads: X Index] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rol $77.b,X		; 36 77 ; Rotate left $77.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	trb $0E3F.w		; 1C 3F 0E ; Test and reset bits $0E3F.w [Reads: Accumulator] [Flags: Z]
	ora $000300.l,X		; 1F 00 03 00 ; Logical OR long $000300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7F77FB.l,X		; FF FB 77 7F ; Subtract with carry (long,X) $7F77FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00031F.l,X		; 3F 1F 03 00 ; AND accumulator with memory (long,X) $00031F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp ($EF.b,S),Y		; D3 EF ; Compare accumulator (stack relative indirect indexed) ($EF.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	wai		; CB ; Wait for interrupt
	and $CE7BF5.l,X		; 3F F5 7B CE ; AND accumulator with memory (long,X) $CE7BF5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($9A.b),Y		; F1 9A ; Subtract with carry ($9A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C4.b		; E5 C4 ; Subtract $C4.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $7F39FF.l,X		; 7F FF 39 7F ; Add long $7F39FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E5F1FB.l,X		; FF FB F1 E5 ; Subtract with carry (long,X) $E5F1FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $737FFF.l,X		; FF FF 7F 73 ; Subtract with carry (long,X) $737FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $3F3C67.l		; 2F 67 3C 3F ; AND accumulator with memory (long) $3F3C67.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $0F0B.w,X		; 1E 0B 0F ; Arithmetic shift left $0F0B.w,X [Reads: X Index] [Flags: ZNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0F1F3F.l,X		; 7F 3F 1F 0F ; Add long $0F1F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $BC.b,S		; C3 BC ; Compare accumulator (stack relative) $BC.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc [$39.b],Y		; F7 39 ; Subtract with carry (long indexed) [$39.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $7CBB.w		; EE BB 7C ; Increment $7CBB.w [Flags: ZN]
	lsr $D3B1.w		; 4E B1 D3 ; Logical shift right $D3B1.w [Flags: ZNC]
	sbc $7F3CFF.l,X		; FF FF 3C 7F ; Subtract with carry (long,X) $7F3CFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $B17CFE.l,X		; FF FE 7C B1 ; Subtract with carry (long,X) $B17CFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1B7FFF.l,X		; FF FF 7F 1B ; Subtract with carry (long,X) $1B7FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $0C1B.w		; 0C 1B 0C ; Test and set bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0C1B.w		; 0C 1B 0C ; Test and set bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0C1B.w		; 0C 1B 0C ; Test and set bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0C1B.w		; 0C 1B 0C ; Test and set bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	trb $1C1C.w		; 1C 1C 1C ; Test and reset bits $1C1C.w [Reads: Accumulator] [Flags: Z]
	trb $1C1C.w		; 1C 1C 1C ; Test and reset bits $1C1C.w [Reads: Accumulator] [Flags: Z]
	trb $D81C.w		; 1C 1C D8 ; Test and reset bits $D81C.w [Reads: Accumulator] [Flags: Z]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp $3CD770.l,X		; DF 70 D7 3C ; Compare accumulator (long,X) $3CD770.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $0F3932.l		; 6F 32 39 0F ; Add with carry (long) $0F3932.l [Writes: Accumulator] [Flags: ZVNC]
	ora $000706.l,X		; 1F 06 07 00 ; Logical OR long $000706.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3F73FF.l,X		; FF FF 73 3F ; Subtract with carry (long,X) $3F73FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $000007.l,X		; 1F 07 00 00 ; Logical OR long $000007.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Accumulator, X Index, Direct Page]
	sbc [$80.b],Y		; F7 80 ; Subtract with carry (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $F3E7.w,X		; FE E7 F3 ; Increment memory $F3E7.w,X [Reads: X Index] [Flags: ZN]
	jsr ($0FFE.w,X)		; FC FE 0F ; Jump to subroutine indirect indexed ($0FFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	sta ($F7.b,X)		; 81 F7 ; Store accumulator ($F7.b,X) [Reads: Accumulator, X Index, Direct Page]
	sbc $0FFFFC.l,X		; FF FC FF 0F ; Subtract with carry (long,X) $0FFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $00,$00		; 44 00 00 ; Move block positive $00,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: ZNC]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: ZNC]
	asl $00FF.w		; 0E FF 00 ; Arithmetic shift left $00FF.w [Flags: ZNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F3C03.l,X		; 1F 03 3C 0F ; Logical OR long $0F3C03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($1E.b,X)		; 61 1E ; Add with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lsr $2D.b,X		; 56 2D ; Logical shift right $2D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $77DF58.l		; EF 58 DF 77 ; Subtract with carry (long) $77DF58.l [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $6F7E3F.l,X		; 1F 3F 7E 6F ; Logical OR long $6F7E3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $003FFF.l,X		; DF FF 3F 00 ; Compare accumulator (long,X) $003FFF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	cmp #$377F.w		; C9 7F 37 ; Compare #$377F.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	sbc $40FF.w,Y		; F9 FF 40 ; Subtract with carry $40FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $807C8E.l,X		; 7F 8E 7C 80 ; Add long $807C8E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $C738.w,X		; FE 38 C7 ; Increment memory $C738.w,X [Reads: X Index] [Flags: ZN]
	jmp ($FF3F.w,X)		; 7C 3F FF ; Jump indirect indexed to ($FF3F.w,X) [Reads: X Index] [Flow: jump]
	sbc $FCFF7F.l,X		; FF 7F FF FC ; Subtract with carry (long,X) $FCFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $71FF.w,X		; FE FF 71 ; Increment memory $71FF.w,X [Reads: X Index] [Flags: ZN]
	rol $3E67.w,X		; 3E 67 3E ; Rotate left $3E67.w,X [Reads: X Index] [Flags: ZNC]
	cmp $F66F.w,Y		; D9 6F F6 ; Compare accumulator $F66F.w,Y [Reads: Y Index] [Flags: ZNC]
	eor #$60DF.w		; 49 DF 60 ; Exclusive OR #$60DF.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $48FF00.l,X		; 7F 00 FF 48 ; Add long $48FF00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7F7F57.l,X		; FF 57 7F 7F ; Subtract with carry (long,X) $7F7F57.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $62E0C9.l		; EF C9 E0 62 ; Subtract with carry (long) $62E0C9.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $3EF9DF.l		; CF DF F9 3E ; Compare accumulator (long) $3EF9DF.l [Reads: Accumulator] [Flags: ZNC]
	sbc $83FF04.l,X		; FF 04 FF 83 ; Subtract with carry (long,X) $83FF04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($B3EF.w,X)		; 7C EF B3 ; Jump indirect indexed to ($B3EF.w,X) [Reads: X Index] [Flow: jump]
	jmp $EF7897.l		; 5C 97 78 EF ; Jump long to $EF7897.l [Flow: jump]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($F078.w,X)		; 7C 78 F0 ; Jump indirect indexed to ($F078.w,X) [Reads: X Index] [Flow: jump]
	cpx #$0C1B.w		; E0 1B 0C ; Compare #$0C1B.w with X register [Reads: X Index] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0C1B.w		; 0C 1B 0C ; Test and set bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0C1B.w		; 0C 1B 0C ; Test and set bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0C1B.w		; 0C 1B 0C ; Test and set bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $1C1C.w		; 0C 1C 1C ; Test and set bits $1C1C.w [Reads: Accumulator] [Flags: Z]
	trb $1C1C.w		; 1C 1C 1C ; Test and reset bits $1C1C.w [Reads: Accumulator] [Flags: Z]
	trb $1C1C.w		; 1C 1C 1C ; Test and reset bits $1C1C.w [Reads: Accumulator] [Flags: Z]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1F7C03.l,X		; 1F 03 7C 1F ; Logical OR long $1F7C03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $7C.b,S		; E3 7C ; Subtract stack-relative $7C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sta $807FE0.l,X		; 9F E0 7F 80 ; Store accumulator (long,X) $807FE0.l,X [Reads: Accumulator, X Index]
	adc $00FF80.l,X		; 7F 80 FF 00 ; Add long $00FF80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $80E0FC.l,X		; 7F FC E0 80 ; Add long $80E0FC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: ZNC]
	ora ($1F.b,S),Y		; 13 1F ; OR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy #$A0E0.w		; C0 E0 A0 ; Compare #$A0E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$0100.w		; E0 00 01 ; Compare #$0100.w with X register [Reads: X Index] [Flags: ZNC]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $E078.w,X		; 3C 78 E0 ; Test bits $E078.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx #$3F3D.w		; E0 3D 3F ; Compare #$3F3D.w with X register [Reads: X Index] [Flags: ZNC]
	sta $FF.b,S		; 83 FF ; Store accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00F8FF.l,X		; 3F FF F8 00 ; AND accumulator with memory (long,X) $00F8FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $003F00.l,X		; 1F 00 3F 00 ; Logical OR long $003F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $001F00.l,X		; 3F 00 1F 00 ; AND accumulator with memory (long,X) $001F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F3F3F.l,X		; 1F 3F 3F 1F ; Logical OR long $1F3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F800.w		; E0 00 F8 ; Compare #$F800.w with X register [Reads: X Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$FCF8.w		; E0 F8 FC ; Compare #$FCF8.w with X register [Reads: X Index] [Flags: ZNC]
	jsr ($E0F8.w,X)		; FC F8 E0 ; Jump to subroutine indirect indexed ($E0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F807.w,X		; FE 07 F8 ; Increment memory $F807.w,X [Reads: X Index] [Flags: ZN]
	tsb $18F3.w		; 0C F3 18 ; Test and set bits $18F3.w [Reads: Accumulator] [Flags: Z]
	sbc [$30.b]		; E7 30 ; Subtract with carry (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $419F60.l		; CF 60 9F 41 ; Compare accumulator (long) $419F60.l [Reads: Accumulator] [Flags: ZNC]
	lda $FF3FC3.l,X		; BF C3 3F FF ; Load long $FF3FC3.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$80C0.w		; E0 C0 80 ; Compare #$80C0.w with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $60FF40.l,X		; FF 40 FF 60 ; Subtract with carry (long,X) $60FF40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFF73.l,X		; FF 73 FF FF ; Subtract with carry (long,X) $FFFF73.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $8CC0C0.l,X		; FF C0 C0 8C ; Subtract with carry (long,X) $8CC0C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $0000.w		; 8C 00 00 ; Store Y register to $0000.w [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $060D73.l,X		; 3F 73 0D 06 ; AND accumulator with memory (long,X) $060D73.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0D06.w		; 0D 06 0D ; Logical OR $0D06.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: ZNC]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: ZNC]
	asl $00FF.w		; 0E FF 00 ; Arithmetic shift left $00FF.w [Flags: ZNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $E53F.w		; EC 3F E5 ; Compare $E53F.w with X register [Reads: X Index] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rol $77.b,X		; 36 77 ; Rotate left $77.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	trb $0E3F.w		; 1C 3F 0E ; Test and reset bits $0E3F.w [Reads: Accumulator] [Flags: Z]
	ora $000300.l,X		; 1F 00 03 00 ; Logical OR long $000300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7F77FB.l,X		; FF FB 77 7F ; Subtract with carry (long,X) $7F77FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00031F.l,X		; 3F 1F 03 00 ; AND accumulator with memory (long,X) $00031F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp ($EF.b,S),Y		; D3 EF ; Compare accumulator (stack relative indirect indexed) ($EF.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	wai		; CB ; Wait for interrupt
	and $CE7BF5.l,X		; 3F F5 7B CE ; AND accumulator with memory (long,X) $CE7BF5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($9A.b),Y		; F1 9A ; Subtract with carry ($9A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C4.b		; E5 C4 ; Subtract $C4.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $7F39FF.l,X		; 7F FF 39 7F ; Add long $7F39FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E5F1FB.l,X		; FF FB F1 E5 ; Subtract with carry (long,X) $E5F1FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $EC7FFF.l,X		; FF FF 7F EC ; Subtract with carry (long,X) $EC7FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $6E3BE5.l,X		; 3F E5 3B 6E ; AND accumulator with memory (long,X) $6E3BE5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($77.b),Y		; 31 77 ; AND accumulator with memory ($77.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $1F0E.w,X		; 3D 0E 1F ; AND accumulator with memory $1F0E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc ($78.b),Y		; 71 78 ; Add with carry ($78.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $031F.w,X		; 3E 1F 03 ; Rotate left $031F.w,X [Reads: X Index] [Flags: ZNC]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($DE.b,X)		; A1 DE ; Load accumulator ($DE.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $FC.b,S		; 23 FC ; AND accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and [$FA.b],Y		; 37 FA ; AND accumulator with memory (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $C17E.w		; 8D 7E C1 ; Store accumulator to $C17E.w [Reads: Accumulator]
	inc $FFE7.w,X		; FE E7 FF ; Increment memory $FFE7.w,X [Reads: X Index] [Flags: ZN]
	and ($7F.b),Y		; 31 7F ; AND accumulator with memory ($7F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F9FDFF.l		; EF FF FD F9 ; Subtract with carry (long) $F9FDFF.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $1B7FFF.l,X		; FF FF 7F 1B ; Subtract with carry (long,X) $1B7FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $0C1B.w		; 0C 1B 0C ; Test and set bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0C1B.w		; 0C 1B 0C ; Test and set bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0C1B.w		; 0C 1B 0C ; Test and set bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0C1B.w		; 0C 1B 0C ; Test and set bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	trb $1C1C.w		; 1C 1C 1C ; Test and reset bits $1C1C.w [Reads: Accumulator] [Flags: Z]
	trb $1C1C.w		; 1C 1C 1C ; Test and reset bits $1C1C.w [Reads: Accumulator] [Flags: Z]
	trb $D81C.w		; 1C 1C D8 ; Test and reset bits $D81C.w [Reads: Accumulator] [Flags: Z]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	ora $0D06.w		; 0D 06 0D ; Logical OR $0D06.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: ZNC]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: ZNC]
	asl $FF0E.w		; 0E 0E FF ; Arithmetic shift left $FF0E.w [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0E0.w		; E0 E0 E0 ; Compare #$E0E0.w with X register [Reads: X Index] [Flags: ZNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and ($3F.b,S),Y		; 33 3F ; AND accumulator (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $071F.w		; 1C 1F 07 ; Test and reset bits $071F.w [Reads: Accumulator] [Flags: Z]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$3C78.w		; E0 78 3C ; Compare #$3C78.w with X register [Reads: X Index] [Flags: ZNC]
	and $00071F.l,X		; 3F 1F 07 00 ; AND accumulator with memory (long,X) $00071F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor [$BF.b]		; 47 BF ; Exclusive OR accumulator with memory (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0000FF.l,X		; BF FF 00 00 ; Load long $0000FF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7EBE7F.l,X		; FF 7F BE 7E ; Subtract with carry (long,X) $7EBE7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $7E.b		; 86 7E ; Store X register to $7E.b [Reads: X Index]
	.db $82, $7E, $82		; 82 7E 82 ; Branch always long to $82, $7E, $82 [Flow: branch]
	ror $7E82.w,X		; 7E 82 7E ; Rotate right $7E82.w,X [Reads: X Index] [Flags: ZNC]
	dec $3E.b		; C6 3E ; Decrement $3E.b [Reads: Direct Page] [Flags: ZN]
	lsr $BE.b		; 46 BE ; Logical shift right $BE.b [Reads: Direct Page] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Accumulator, X Index, Direct Page]
	asl $3F1E.w,X		; 1E 1E 3F ; Arithmetic shift left $3F1E.w,X [Reads: X Index] [Flags: ZNC]
	and $677F67.l,X		; 3F 67 7F 67 ; AND accumulator with memory (long,X) $677F67.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $393F3F.l,X		; 7F 3F 3F 39 ; Add long $393F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $7979.w,Y		; 39 79 79 ; AND accumulator with memory $7979.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $C0E17F.l,X		; 7F 7F E1 C0 ; Add long $C0E17F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$86C6.w		; C0 C6 86 ; Compare #$86C6.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0C1F12.l		; 0F 12 1F 0C ; OR accumulator with memory (long) $0C1F12.l [Writes: Accumulator] [Flags: ZN]
	ora $000303.l		; 0F 03 03 00 ; OR accumulator with memory (long) $000303.l [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00030F.l,X		; 1F 0F 03 00 ; Logical OR long $00030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0A0.w		; C0 A0 E0 ; Compare #$E0A0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F8F0.w		; E0 F0 F8 ; Compare #$F8F0.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: ZN]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FE7FBF.l,X		; DF BF 7F FE ; Compare accumulator (long,X) $FE7FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $FBBFFD.l,X		; 7F FD BF FB ; Add long $FBBFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $007FBF.l,X		; DF BF 7F 00 ; Compare accumulator (long,X) $007FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0000.w,Y		; 19 00 00 ; OR accumulator with memory $0000.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E000.w		; C0 00 E0 ; Compare #$E000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$2030.w		; C0 30 20 ; Compare #$2030.w with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00F8.w		; C0 F8 00 ; Compare #$00F8.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $E068.w		; 20 68 E0 ; Jump to subroutine at $E068.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $5E.b,X		; 34 5E ; Test bits $5E.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $28.b,X		; 34 28 ; Test bits $28.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr $182C.w		; 20 2C 18 ; Jump to subroutine at $182C.w [Writes: Stack Pointer] [Flow: call]
	asl $0C.b,X		; 16 0C ; Arithmetic shift left $0C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	asl $0002.w		; 0E 02 00 ; Arithmetic shift left $0002.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	adc $B87FB0.l,X		; 7F B0 7F B8 ; Add long $B87FB0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $8E7F9C.l,X		; 7F 9C 7F 8E ; Add long $8E7F9C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $827F87.l,X		; 7F 87 7F 82 ; Add long $827F87.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $300000.l,X		; 7F 00 00 30 ; Add long $300000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $070E.w		; 1C 0E 07 ; Test and reset bits $070E.w [Reads: Accumulator] [Flags: Z]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FD7FFE.l,X		; FF FE 7F FD ; Subtract with carry (long,X) $FD7FFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FE7FBF.l,X		; DF BF 7F FE ; Compare accumulator (long,X) $FE7FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $FBBFFD.l,X		; 7F FD BF FB ; Add long $FBBFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $007FBF.l,X		; DF BF 7F 00 ; Compare accumulator (long,X) $007FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and ($24.b)		; 32 24 ; AND accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $40		; 10 40 ; Branch if plus to $10, $40 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $4000.w		; 0C 00 40 ; Test and set bits $4000.w [Reads: Accumulator] [Flags: Z]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0740.w		; 0C 40 07 ; Test and set bits $0740.w [Reads: Accumulator] [Flags: Z]
	jsl $100900.l		; 22 00 09 10 ; Jump to subroutine long $100900.l [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	trb $6404.w		; 1C 04 64 ; Test and reset bits $6404.w [Reads: Accumulator] [Flags: Z]
	cpy #$E2E2.w		; C0 E2 E2 ; Compare #$E2E2.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc ($10.b)		; F2 10 ; Subtract with carry (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E264.w		; 1C 64 E2 ; Test and reset bits $E264.w [Reads: Accumulator] [Flags: Z]
	sbc ($1C.b)		; F2 1C ; Subtract with carry (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FBBFFD.l,X		; 7F FD BF FB ; Add long $FBBFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FE7FBF.l,X		; DF BF 7F FE ; Compare accumulator (long,X) $FE7FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $FBBFFD.l,X		; 7F FD BF FB ; Add long $FBBFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $2E7FBF.l,X		; DF BF 7F 2E ; Compare accumulator (long,X) $2E7FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($31.b),Y		; 11 31 ; OR accumulator with memory ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $1D		; 10 1D ; Branch if plus to $10, $1D [Flow: branch]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b),Y		; [PATTERN: Memory clearing operation] 11 03 ; OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0702.w		; 0E 02 07 ; Arithmetic shift left $0702.w [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	bit $8C88.w,X		; 3C 88 8C ; Test bits $8C88.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jsr $0010.w		; 20 10 00 ; Jump to subroutine at $0010.w [Writes: Stack Pointer] [Flow: call]
	.db $70, $20		; 70 20 ; Branch if overflow set to $70, $20 [Flow: branch]
	ldy #$8800.w		; A0 00 88 ; Load #$8800.w into Y register [Writes: Y Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpy #$4070.w		; C0 70 40 ; Compare #$4070.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$0080.w		; E0 80 00 ; Compare #$0080.w with X register [Reads: X Index] [Flags: ZNC]
	and $183F10.l,X		; 3F 10 3F 18 ; AND accumulator with memory (long,X) $183F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $3F17.w,X		; 3E 17 3F ; Rotate left $3F17.w,X [Reads: X Index] [Flags: ZNC]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	trb $070D.w		; 1C 0D 07 ; Test and reset bits $070D.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FC08.w,X)		; FC 08 FC ; Jump to subroutine indirect indexed ($FC08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp ($FCE8.w,X)		; 7C E8 FC ; Jump indirect indexed to ($FCE8.w,X) [Reads: X Index] [Flow: jump]
	cpy #$40F8.w		; C0 F8 40 ; Compare #$40F8.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpx #$0000.w		; E0 00 00 ; Compare #$0000.w with X register [Reads: X Index] [Flags: ZNC]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3890.w		; 20 90 38 ; Jump to subroutine at $3890.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $E0		; B0 E0 ; Branch if carry set to $B0, $E0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $82, $7C, $E2		; 82 7C E2 ; Branch always long to $82, $7C, $E2 [Flow: branch]
	trb $62FF.w		; 1C FF 62 ; Test and reset bits $62FF.w [Reads: Accumulator] [Flags: Z]
	ror $3C2C.w,X		; 7E 2C 3C ; Rotate right $3C2C.w,X [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($621C.w,X)		; 7C 1C 62 ; Jump indirect indexed to ($621C.w,X) [Reads: X Index] [Flow: jump]
	bit $0008.w		; 2C 08 00 ; Test bits $0008.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3600.w		; 1C 00 36 ; Test and reset bits $3600.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $5A20.w,X		; 7E 20 5A ; Rotate right $5A20.w,X [Reads: X Index] [Flags: ZNC]
	bit $64.b,X		; 34 64 ; Test bits $64.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $2C.b		; 14 2C ; Test and reset bits $2C.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Accumulator, X Index, Direct Page]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF3FFF.l,X		; 3F FF 3F FF ; AND accumulator with memory (long,X) $FF3FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $FF3FFF.l,X		; 3F FF 3F FF ; AND accumulator with memory (long,X) $FF3FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $FF3FFF.l,X		; 3F FF 3F FF ; AND accumulator with memory (long,X) $FF3FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: ZN]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FE7FBF.l,X		; DF BF 7F FE ; Compare accumulator (long,X) $FE7FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $FBBFFD.l,X		; 7F FD BF FB ; Add long $FBBFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $027FBF.l,X		; DF BF 7F 02 ; Compare accumulator (long,X) $027FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $F5.b		; 02 F5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $BA		; 42 BA ; Reserved instruction
	.db $70, $88		; 70 88 ; Branch if overflow set to $70, $88 [Flow: branch]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($6C.b,X)		; 01 6C ; Logical OR ($6C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	stz $8478.w		; 9C 78 84 ; Store zero to $8478.w
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lsr $3B30.w		; 4E 30 3B ; Logical shift right $3B30.w [Flags: ZNC]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3C.b,X		; 34 3C ; Test bits $3C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $72		; 10 72 ; Branch if plus to $10, $72 [Flow: branch]
	bit $62E3.w,X		; 3C E3 62 ; Test bits $62E3.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ror $34.b,X		; 76 34 ; Rotate right $34.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	bit $3C00.w,X		; 3C 00 3C ; Test bits $3C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $7E2C.w,X		; 3C 2C 7E ; Test bits $7E2C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta $3C4A.w,X		; 9D 4A 3C ; Store accumulator to $3C4A.w,X [Reads: Accumulator, X Index]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsr $1076.w		; 20 76 10 ; Jump to subroutine at $1076.w [Writes: Stack Pointer] [Flow: call]
	sbc $62.b,S		; E3 62 ; Subtract stack-relative $62.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc $62.b,S		; E3 62 ; Subtract stack-relative $62.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	.db $10, $68		; 10 68 ; Branch if plus to $10, $68 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $D0, $78		; D0 78 ; Branch if not equal to $D0, $78 [Flow: branch]
	ror $9D9D.w		; 6E 9D 9D ; Rotate right $9D9D.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $E300.w,X		; 7E 00 E3 ; Rotate right $E300.w,X [Reads: X Index] [Flags: ZNC]
	.db $62, $F7, $76		; 62 F7 76 ; Push effective relative address $62, $F7, $76 [Writes: Stack Pointer]
	ror $3C00.w,X		; 7E 00 3C ; Rotate right $3C00.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $7E89.w,X		; 9D 89 7E ; Store accumulator to $7E89.w,X [Reads: Accumulator, X Index]
	bit $2C.b		; 24 2C ; Test bits $2C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $0010.w		; 2C 10 00 ; Test bits $0010.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $28		; 30 28 ; Branch if minus to $30, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	stz $38.b,X		; 74 38 ; Store zero to $38.b,X [Reads: X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F1D02.l		; 0F 02 1D 0F ; OR accumulator with memory (long) $0F1D02.l [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00001F.l		; 0F 1F 00 00 ; OR accumulator with memory (long) $00001F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1A.b]		; 07 1A ; OR accumulator with memory (long) [$1A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $081E.w		; 0E 1E 08 ; Arithmetic shift left $081E.w [Flags: ZNC]
	ora $070200.l,X		; 1F 00 02 07 ; Logical OR long $070200.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0F07.w		; 0E 07 0F ; Arithmetic shift left $0F07.w [Flags: ZNC]
	asl $1018.w,X		; 1E 18 10 ; Arithmetic shift left $1018.w,X [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp ($6000.w,X)		; 7C 00 60 ; Jump indirect indexed to ($6000.w,X) [Reads: X Index] [Flow: jump]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $0004.w		; 0C 04 00 ; Test and set bits $0004.w [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	ora ($0A.b)		; 12 0A ; OR accumulator with memory (indirect) ($0A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F00.w,X		; 1E 00 3F ; Arithmetic shift left $3F00.w,X [Reads: X Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2E21.w,X		; 1E 21 2E ; Arithmetic shift left $2E21.w,X [Reads: X Index] [Flags: ZNC]
	and ($1D.b,X)		; 21 1D ; Logical AND ($1D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $7F00.w		; 2E 00 7F ; Rotate left $7F00.w [Flags: ZNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $5551.w		; 2E 51 55 ; Rotate left $5551.w [Flags: ZNC]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($2E.b),Y		; 51 2E ; Exclusive OR accumulator with memory ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: ZNC]
	sta $E166.w,Y		; 99 66 E1 ; Store accumulator to $E166.w,Y [Reads: Accumulator, Y Index]
	ror $66F9.w,X		; 7E F9 66 ; Rotate right $66F9.w,X [Reads: X Index] [Flags: ZNC]
	sbc $E166.w,Y		; F9 66 E1 ; Subtract with carry $E166.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C72.w,X		; 7E 72 3C ; Rotate right $3C72.w,X [Reads: X Index] [Flags: ZNC]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00007E.l,X		; FF 7E 00 00 ; Subtract with carry (long,X) $00007E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $003F00.l,X		; 1F 00 3F 00 ; Logical OR long $003F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $001F00.l,X		; 3F 00 1F 00 ; AND accumulator with memory (long,X) $001F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F3F3F.l,X		; 1F 3F 3F 1F ; Logical OR long $1F3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F800.w		; E0 00 F8 ; Compare #$F800.w with X register [Reads: X Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$FCF8.w		; E0 F8 FC ; Compare #$FCF8.w with X register [Reads: X Index] [Flags: ZNC]
	jsr ($E0F8.w,X)		; FC F8 E0 ; Jump to subroutine indirect indexed ($E0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A1B.w		; 0D 1B 0A ; Logical OR $0A1B.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $0019.w,Y		; 39 19 00 ; AND accumulator with memory $0019.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($15.b)		; 12 15 ; OR accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $48		; B0 48 ; Branch if carry set to $B0, $48 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sty $38.b		; 84 38 ; Store Y register to $38.b [Reads: Y Index]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	inc $74.b,X		; F6 74 ; Increment memory $74.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	inc $EE64.w,X		; FE 64 EE ; Increment memory $EE64.w,X [Reads: X Index] [Flags: ZN]
	.db $50, $77		; 50 77 ; Branch if overflow clear to $50, $77 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rol $08.b,X		; 36 08 ; Rotate left $08.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $9A,$8A		; 54 8A 9A ; Move block negative $9A,$8A [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ldx $59.b,Y		; B6 59 ; Load X register $59.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	rol $FB08.w,X		; 3E 08 FB ; Rotate left $FB08.w,X [Reads: X Index] [Flags: ZNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	inc $FC64.w,X		; FE 64 FC ; Increment memory $FC64.w,X [Reads: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp ($1E10.w)		; 6C 10 1E ; Jump indirect to ($1E10.w) [Flow: jump]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $25.b		; 14 25 ; Test and reset bits $25.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ldy $74.b		; A4 74 ; Load $74.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $007E1A.l,X		; 3F 1A 7E 00 ; AND accumulator with memory (long,X) $007E1A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $3C.b,X		; 76 3C ; Rotate right $3C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $7EFF42.l,X		; FF 42 FF 7E ; Subtract with carry (long,X) $7EFF42.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $42.b,S		; C3 42 ; Compare accumulator (stack relative) $42.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc [$66.b]		; E7 66 ; Subtract with carry (long) [$66.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C3C.w,X		; 7E 3C 3C ; Rotate right $3C3C.w,X [Reads: X Index] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $81BD.w,X		; 7E BD 81 ; Rotate right $81BD.w,X [Reads: X Index] [Flags: ZNC]
	lda $4299.w,X		; BD 99 42 ; Load $4299.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $1028.w,X		; 3C 28 10 ; Test bits $1028.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jmp ($AA10.w)		; 6C 10 AA ; Jump indirect to ($AA10.w) [Flow: jump]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	mvn $54,$EE		; 54 EE 54 ; Move block negative $54,$EE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	inc $9210.w		; EE 10 92 ; Increment $9210.w [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($BAFE.w,X)		; 7C FE BA ; Jump indirect indexed to ($BAFE.w,X) [Reads: X Index] [Flow: jump]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	inc $0092.w,X		; FE 92 00 ; Increment memory $0092.w,X [Reads: X Index] [Flags: ZN]
	and ($1E.b)		; 32 1E ; AND accumulator with memory (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $38.b		; 66 38 ; Rotate right $38.b [Reads: Direct Page] [Flags: ZNC]
	sbc [$78.b]		; E7 78 ; Subtract with carry (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$70.b]		; E7 70 ; Subtract with carry (long) [$70.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
.ACCU 8
.INDEX 8
	sep #$72		; E2 72
	adc ($39.b),Y		; 71 39 ; Add with carry ($39.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $000F0F.l,X		; 3F 0F 0F 00 ; AND accumulator with memory (long,X) $000F0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $FA78.w,X		; 3E 78 FA ; Rotate left $FA78.w,X [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $3F7F.w,X		; FE 7F 3F ; Increment memory $3F7F.w,X [Reads: X Index] [Flags: ZN]
	ora $3A3834.l		; 0F 34 38 3A ; OR accumulator with memory (long) $3A3834.l [Writes: Accumulator] [Flags: ZN]
	tsb $06F5.w		; 0C F5 06 ; Test and set bits $06F5.w [Reads: Accumulator] [Flags: Z]
	adc $06.b,X		; 75 06 ; Add $06.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora #$0E.b		; 09 0E ; Logical OR #$0E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($1C.b)		; 12 1C ; OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr ($F0F0.w,X)		; FC F0 F0 ; Jump to subroutine indirect indexed ($F0F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0727.w		; 0E 27 07 ; Arithmetic shift left $0727.w [Flags: ZNC]
	ora $F0FC1E.l		; 0F 1E FC F0 ; OR accumulator with memory (long) $F0FC1E.l [Writes: Accumulator] [Flags: ZN]
	and $183F10.l,X		; 3F 10 3F 18 ; AND accumulator with memory (long,X) $183F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stz $3C.b,X		; 74 3C ; Store zero to $3C.b,X [Reads: X Index]
	adc ($3A.b)		; 72 3A ; Add with carry (indirect) ($3A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $1C1D.w,Y		; 39 1D 1C ; AND accumulator with memory $1C1D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($3F7E.w,X)		; 7C 7E 3F ; Jump indirect indexed to ($3F7E.w,X) [Reads: X Index] [Flow: jump]
	ora $FC030F.l,X		; 1F 0F 03 FC ; Logical OR long $FC030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $1C12.w		; 0C 12 1C ; Test and set bits $1C12.w [Reads: Accumulator] [Flags: Z]
	cpx $38F8.w		; EC F8 38 ; Compare $38F8.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E0E.w		; 0C 0E 1E ; Test and set bits $1E0E.w [Reads: Accumulator] [Flags: Z]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $2A.b		; 14 2A ; Test and reset bits $2A.b [Reads: Accumulator] [Flags: Z]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and ($1A.b,X)		; 21 1A ; Logical AND ($1A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2D21.w,X		; 1E 21 2D ; Arithmetic shift left $2D21.w,X [Reads: X Index] [Flags: ZNC]
	and ($2D.b,X)		; 21 2D ; Logical AND ($2D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $130C.w		; 0C 0C 13 ; Test and set bits $130C.w [Reads: Accumulator] [Flags: Z]
	.db $10, $AF		; 10 AF ; Branch if plus to $10, $AF [Flow: branch]
	jsr $405F.w		; 20 5F 40 ; Jump to subroutine at $405F.w [Writes: Stack Pointer] [Flow: call]
	eor $80BF40.l,X		; 5F 40 BF 80 ; Exclusive OR accumulator with memory (long,X) $80BF40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $030080.l,X		; BF 80 00 03 ; Load long $030080.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $2010.w		; 0C 10 20 ; Test and set bits $2010.w [Reads: Accumulator] [Flags: Z]
	jsr $4040.w		; 20 40 40 ; Jump to subroutine at $4040.w [Writes: Stack Pointer] [Flow: call]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $3210.w,X		; 3C 10 32 ; Test bits $3210.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	trb $103C.w		; 1C 3C 10 ; Test and reset bits $103C.w [Reads: Accumulator] [Flags: Z]
	and ($1C.b)		; 32 1C ; AND accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $1010.w,X		; 3C 10 10 ; Test bits $1010.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3E3C.w,X		; 3C 3C 3E ; Test bits $3E3C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $3C3E.w,X		; 3C 3E 3C ; Test bits $3C3E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1B3B.w		; 1C 3B 1B ; Test and reset bits $1B3B.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $1F0C.w		; 1C 0C 1F ; Test and reset bits $1F0C.w [Reads: Accumulator] [Flags: Z]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $27.b		; 24 27 ; Test bits $27.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	bit $DC08.w		; 2C 08 DC ; Test bits $DC08.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	trb $3818.w		; 1C 18 38 ; Test and reset bits $3818.w [Reads: Accumulator] [Flags: Z]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E4.b		; 24 E4 ; Test bits $E4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0C1F12.l		; 0F 12 1F 0C ; OR accumulator with memory (long) $0C1F12.l [Writes: Accumulator] [Flags: ZN]
	ora $000303.l		; 0F 03 03 00 ; OR accumulator with memory (long) $000303.l [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00030F.l,X		; 1F 0F 03 00 ; Logical OR long $00030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $00FF00.l,X		; 7F 00 FF 00 ; Add long $00FF00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $010000.l,X		; 7F 00 00 01 ; Add long $010000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $7F7E.w,X		; 7D 7E 7F ; Add $7F7E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $BE		; 80 BE ; Branch always to $80, $BE [Flow: branch]
	ror $02FE.w,X		; 7E FE 02 ; Rotate right $02FE.w,X [Reads: X Index] [Flags: ZNC]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $501F28.l		; 0F 28 1F 50 ; OR accumulator with memory (long) $501F28.l [Writes: Accumulator] [Flags: ZN]
	and $5C3F50.l,X		; 3F 50 3F 5C ; AND accumulator with memory (long,X) $5C3F50.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $007F82.l,X		; 3F 82 7F 00 ; AND accumulator with memory (long,X) $007F82.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F1F1F.l		; 0F 1F 1F 1F ; OR accumulator with memory (long) $1F1F1F.l [Writes: Accumulator] [Flags: ZN]
	ora $1000E0.l,X		; 1F E0 00 10 ; Logical OR long $1000E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$28.b		; E0 28 ; Compare #$28.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsr ($FC0A.w,X)		; FC 0A FC ; Jump to subroutine indirect indexed ($FC0A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	jsr ($FE41.w,X)		; FC 41 FE ; Jump to subroutine indirect indexed ($FE41.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl $1300.w,X		; 1E 00 13 ; Arithmetic shift left $1300.w,X [Reads: X Index] [Flags: ZNC]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: ZNC]
	asl $9F.b		; 06 9F ; Arithmetic shift left $9F.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda $38FF38.l,X		; BF 38 FF 38 ; Load long $38FF38.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $0C0002.l,X		; 7F 02 00 0C ; Add long $0C0002.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $03.b,S		; 43 03 ; Exclusive OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($78.b,X)		; 01 78 ; Logical OR ($78.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $18F960.l,X		; FF 60 F9 18 ; Subtract with carry (long,X) $18F960.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF1C.w,X		; FD 1C FF ; Subtract with carry $FF1C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $40FE.w		; 1C FE 40 ; Test and reset bits $40FE.w [Reads: Accumulator] [Flags: Z]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	stx $C2.b		; 86 C2 ; Store X register to $C2.b [Reads: X Index]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $5E.b,X		; 34 5E ; Test bits $5E.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $28.b,X		; 34 28 ; Test bits $28.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr $1034.w		; 20 34 10 ; Jump to subroutine at $1034.w [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0002.w		; 0E 02 00 ; Arithmetic shift left $0002.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	tsb $1903.w		; 0C 03 19 ; Test and set bits $1903.w [Reads: Accumulator] [Flags: Z]
	ora [$33.b]		; 07 33 ; OR accumulator with memory (long) [$33.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $CE1F67.l		; 0F 67 1F CE ; OR accumulator with memory (long) $CE1F67.l [Writes: Accumulator] [Flags: ZN]
	and $000000.l,X		; 3F 00 00 00 ; AND accumulator with memory (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $DA00E7.l		; 0F E7 00 DA ; OR accumulator with memory (long) $DA00E7.l [Writes: Accumulator] [Flags: ZN]
	sbc [$C2.b]		; E7 C2 ; Subtract with carry (long) [$C2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $3DFF25.l,X		; FF 25 FF 3D ; Subtract with carry (long,X) $3DFF25.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF1C.l,X		; FF 1C FF 00 ; Subtract with carry (long,X) $00FF1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF63.l,X		; FF 63 FF 00 ; Subtract with carry (long,X) $00FF63.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rep #$C2		; C2 C2 ; Reset processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $18FFFF.l,X		; FF FF FF 18 ; Subtract with carry (long,X) $18FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $62, $3C, $F2		; 62 3C F2 ; Push effective relative address $62, $3C, $F2 [Writes: Stack Pointer]
	jmp $7E60FE.l		; 5C FE 60 7E ; Jump long to $7E60FE.l [Flow: jump]
	bit $003C.w		; 2C 3C 00 ; Test bits $003C.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $FE7E.w,X		; 3C 7E FE ; Test bits $FE7E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inc $3C7E.w,X		; FE 7E 3C ; Increment memory $3C7E.w,X [Reads: X Index] [Flags: ZN]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $000C.w		; 0C 0C 00 ; Test and set bits $000C.w [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta ($60.b)		; 92 60 ; Store accumulator (indirect) ($60.b) [Reads: Accumulator, Direct Page]
	.db $70, $20		; 70 20 ; Branch if overflow set to $70, $20 [Flow: branch]
	jsr $0C00.w		; 20 00 0C ; Jump to subroutine at $0C00.w [Writes: Stack Pointer] [Flow: call]
	asl $020C.w,X		; 1E 0C 02 ; Arithmetic shift left $020C.w,X [Reads: X Index] [Flags: ZNC]
	adc [$F2.b]		; 67 F2 ; Add with carry (long) [$F2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $20		; 70 20 ; Branch if overflow set to $70, $20 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $7F00.w,X		; 1E 00 7F ; Arithmetic shift left $7F00.w,X [Reads: X Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and ($24.b)		; 32 24 ; AND accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $28.b,X		; 34 28 ; Test bits $28.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $4000.w		; 0C 00 40 ; Test and set bits $4000.w [Reads: Accumulator] [Flags: Z]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0740.w		; 0C 40 07 ; Test and set bits $0740.w [Reads: Accumulator] [Flags: Z]
	jsl $100900.l		; 22 00 09 10 ; Jump to subroutine long $100900.l [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	trb $6404.w		; 1C 04 64 ; Test and reset bits $6404.w [Reads: Accumulator] [Flags: Z]
	cpy #$E2.b		; C0 E2 ; Compare #$E2.b with Y register [Reads: Y Index] [Flags: ZNC]
.ACCU 8
.INDEX 8
	sep #$F2		; E2 F2
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E264.w		; 1C 64 E2 ; Test and reset bits $E264.w [Reads: Accumulator] [Flags: Z]
	sbc ($1C.b)		; F2 1C ; Subtract with carry (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3F20.w		; 2D 20 3F ; Logical AND $3F20.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $FE00.w,X		; FE 00 FE ; Increment memory $FE00.w,X [Reads: X Index] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $04.b,X		; B4 04 ; Load Y register $04.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	jsr ($8000.w,X)		; FC 00 80 ; Jump to subroutine indirect indexed ($8000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	adc [$BD.b],Y		; 77 BD ; Add with carry (long indexed) [$BD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $AF.b,S		; 63 AF ; Add with carry (stack relative) $AF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	ror $5C.b,X		; 76 5C ; Rotate right $5C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and $351C6B.l,X		; 3F 6B 1C 35 ; AND accumulator with memory (long,X) $351C6B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $000702.l,X		; 1F 02 07 00 ; Logical OR long $000702.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($23.b,S),Y		; 33 23 ; AND accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $1D.b		; 26 1D ; Rotate left $1D.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $59.b		; 00 59 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $C6BD.w		; EE BD C6 ; Increment $C6BD.w [Flags: ZN]
	sbc $6E.b,X		; F5 6E ; Subtract $6E.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	jsr ($38D6.w,X)		; FC D6 38 ; Jump to subroutine indirect indexed ($38D6.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldy $F850.w		; AC 50 F8 ; Load $F850.w into Y register [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	cpy $64C4.w		; CC C4 64 ; Compare $64C4.w with Y register [Reads: Y Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $10, $40		; 10 40 ; Branch if plus to $10, $40 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3CBF.w,Y		; 39 BF 3C ; AND accumulator with memory $3CBF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $03FF1B.l,X		; 9F 1B FF 03 ; Store accumulator (long,X) $03FF1B.l,X [Reads: Accumulator, X Index]
	adc $2E19.w,X		; 7D 19 2E ; Add $2E19.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $000100.l,X		; 3F 00 01 00 ; AND accumulator with memory (long,X) $000100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $3CFD.w		; [PATTERN: Memory clearing operation] 9C FD 3C ; Store zero to $3CFD.w
	sbc $FFD8.w,Y		; F9 D8 FF ; Subtract with carry $FFD8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$BE.b		; C0 BE ; Compare #$BE.b with Y register [Reads: Y Index] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stz $10.b,X		; 74 10 ; Store zero to $10.b,X [Reads: X Index]
	jsr ($8000.w,X)		; FC 00 80 ; Jump to subroutine indirect indexed ($8000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $82, $7C, $E2		; 82 7C E2 ; Branch always long to $82, $7C, $E2 [Flow: branch]
	trb $62FF.w		; 1C FF 62 ; Test and reset bits $62FF.w [Reads: Accumulator] [Flags: Z]
	ror $3C2C.w,X		; 7E 2C 3C ; Rotate right $3C2C.w,X [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($621C.w,X)		; 7C 1C 62 ; Jump indirect indexed to ($621C.w,X) [Reads: X Index] [Flow: jump]
	bit $0008.w		; 2C 08 00 ; Test bits $0008.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $001102.l		; 0F 02 11 00 ; OR accumulator with memory (long) $001102.l [Writes: Accumulator] [Flags: ZN]
	rol $520C.w		; 2E 0C 52 ; Rotate left $520C.w [Flags: ZNC]
	.db $10, $64		; 10 64 ; Branch if plus to $10, $64 [Flow: branch]
	jsr $60F8.w		; 20 F8 60 ; Jump to subroutine at $60F8.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $2C		; 10 2C ; Branch if plus to $10, $2C [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$7F.b		; E0 7F ; Compare #$7F.b with X register [Reads: X Index] [Flags: ZNC]
	sbc ($7F.b,X)		; E1 7F ; Subtract with carry ($7F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $4D7F.w,Y		; 99 7F 4D ; Store accumulator to $4D7F.w,Y [Reads: Accumulator, Y Index]
	and $4C3F4C.l,X		; 3F 4C 3F 4C ; AND accumulator with memory (long,X) $4C3F4C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $997FE1.l,X		; 3F E1 7F 99 ; AND accumulator with memory (long,X) $997FE1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $1F7F7F.l,X		; 7F 7F 7F 1F ; Add long $1F7F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $7F0F0F.l		; 0F 0F 0F 7F ; OR accumulator with memory (long) $7F0F0F.l [Writes: Accumulator] [Flags: ZN]
	ora $F6FFFF.l,X		; 1F FF FF F6 ; Logical OR long $F6FFFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $A7FFFE.l,X		; FF FE FF A7 ; Subtract with carry (long,X) $A7FFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FDFFE7.l,X		; FF E7 FF FD ; Subtract with carry (long,X) $FDFFE7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $9FFFFF.l,X		; FF FF FF 9F ; Subtract with carry (long,X) $9FFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFF7FF.l,X		; FF FF F7 FF ; Subtract with carry (long,X) $FFF7FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $FFFDFF.l,X		; BF FF FD FF ; Load long $FFFDFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $42003C.l,X		; FF 3C 00 42 ; Subtract with carry (long,X) $42003C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $3EF1.w,X		; 3C F1 3E ; Test bits $3EF1.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $FF4E.w,X		; FD 4E FF ; Subtract with carry $FF4E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $7F		; 70 7F ; Branch if overflow set to $70, $7F [Flow: branch]
	rol $3E.b,X		; 36 3E ; Rotate left $3E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $001C.w		; 0C 1C 00 ; Test and set bits $001C.w [Reads: Accumulator] [Flags: Z]
	bit $FF7E.w,X		; 3C 7E FF ; Test bits $FF7E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $3E7FFF.l,X		; FF FF 7F 3E ; Subtract with carry (long,X) $3E7FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and ($1C.b)		; 32 1C ; AND accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $0808.w		; 1C 08 08 ; Test and reset bits $0808.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1C3E.w		; 1C 3E 1C ; Test and reset bits $1C3E.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($8D.b)		; 92 8D ; Store accumulator (indirect) ($8D.b) [Reads: Accumulator, Direct Page]
	lda $B4.b		; A5 B4 ; Load $B4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $74.b,X		; 94 74 ; Store Y register $74.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	ror $11.b		; 66 11 ; Rotate right $11.b [Reads: Direct Page] [Flags: ZNC]
	ldx $00C0.w		; AE C0 00 ; Load $00C0.w into X register [Writes: X Index] [Flags: ZN]
	bit $7600.w,X		; 3C 00 76 ; Test bits $7600.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $3C.b,X		; 34 3C ; Test bits $3C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $72		; 10 72 ; Branch if plus to $10, $72 [Flow: branch]
	bit $62E3.w,X		; 3C E3 62 ; Test bits $62E3.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ror $34.b,X		; 76 34 ; Rotate right $34.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	bit $3C00.w,X		; 3C 00 3C ; Test bits $3C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $7E2C.w,X		; 3C 2C 7E ; Test bits $7E2C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta $3C4A.w,X		; 9D 4A 3C ; Store accumulator to $3C4A.w,X [Reads: Accumulator, X Index]
	tsb $1E00.w		; 0C 00 1E ; Test and set bits $1E00.w [Reads: Accumulator] [Flags: Z]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($29.b)		; 12 29 ; OR accumulator with memory (indirect) ($29.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $6B61.w,Y		; 59 61 6B ; Exclusive OR accumulator with memory $6B61.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stx $0062.w		; 8E 62 00 ; Store X register to $0062.w [Reads: X Index]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $F7, $76		; 62 F7 76 ; Push effective relative address $62, $F7, $76 [Writes: Stack Pointer]
	ror $3C00.w,X		; 7E 00 3C ; Rotate right $3C00.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $7E89.w,X		; 9D 89 7E ; Store accumulator to $7E89.w,X [Reads: Accumulator, X Index]
	bit $2C.b		; 24 2C ; Test bits $2C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $0010.w		; 2C 10 00 ; Test bits $0010.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $28		; 30 28 ; Branch if minus to $30, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	stz $38.b,X		; 74 38 ; Store zero to $38.b,X [Reads: X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F1D02.l		; 0F 02 1D 0F ; OR accumulator with memory (long) $0F1D02.l [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00001F.l		; 0F 1F 00 00 ; OR accumulator with memory (long) $00001F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1A.b]		; 07 1A ; OR accumulator with memory (long) [$1A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $081E.w		; 0E 1E 08 ; Arithmetic shift left $081E.w [Flags: ZNC]
	ora $070200.l,X		; 1F 00 02 07 ; Logical OR long $070200.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0F07.w		; 0E 07 0F ; Arithmetic shift left $0F07.w [Flags: ZNC]
	asl $1018.w,X		; 1E 18 10 ; Arithmetic shift left $1018.w,X [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp ($6000.w,X)		; 7C 00 60 ; Jump indirect indexed to ($6000.w,X) [Reads: X Index] [Flow: jump]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $0004.w		; 0C 04 00 ; Test and set bits $0004.w [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	ora ($0A.b)		; 12 0A ; OR accumulator with memory (indirect) ($0A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F00.w,X		; 1E 00 3F ; Arithmetic shift left $3F00.w,X [Reads: X Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2E21.w,X		; 1E 21 2E ; Arithmetic shift left $2E21.w,X [Reads: X Index] [Flags: ZNC]
	and ($1D.b,X)		; 21 1D ; Logical AND ($1D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $7F00.w		; 2E 00 7F ; Rotate left $7F00.w [Flags: ZNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $5551.w		; 2E 51 55 ; Rotate left $5551.w [Flags: ZNC]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($2E.b),Y		; 51 2E ; Exclusive OR accumulator with memory ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: ZNC]
	sta $E166.w,Y		; 99 66 E1 ; Store accumulator to $E166.w,Y [Reads: Accumulator, Y Index]
	ror $66F9.w,X		; 7E F9 66 ; Rotate right $66F9.w,X [Reads: X Index] [Flags: ZNC]
	sbc $E166.w,Y		; F9 66 E1 ; Subtract with carry $E166.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C72.w,X		; 7E 72 3C ; Rotate right $3C72.w,X [Reads: X Index] [Flags: ZNC]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00007E.l,X		; FF 7E 00 00 ; Subtract with carry (long,X) $00007E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $003F00.l,X		; 1F 00 3F 00 ; Logical OR long $003F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $001F00.l,X		; 3F 00 1F 00 ; AND accumulator with memory (long,X) $001F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F3F3F.l,X		; 1F 3F 3F 1F ; Logical OR long $1F3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0D1F02.l		; 0F 02 1F 0D ; OR accumulator with memory (long) $0D1F02.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $0019.w,Y		; 39 19 00 ; AND accumulator with memory $0019.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($15.b)		; 12 15 ; OR accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $48		; B0 48 ; Branch if carry set to $B0, $48 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sty $BD.b		; 84 BD ; Store Y register to $BD.b [Reads: Y Index]
	.db $42, $99		; 42 99 ; Reserved instruction
	ror $FF.b		; 66 FF ; Rotate right $FF.b [Reads: Direct Page] [Flags: ZNC]
	.db $42, $BD		; 42 BD ; Reserved instruction
	.db $42, $DB		; 42 DB ; Reserved instruction
	bit $99.b		; 24 99 ; Test bits $99.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ror $3C42.w,X		; 7E 42 3C ; Rotate right $3C42.w,X [Reads: X Index] [Flags: ZNC]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jsr ($7E00.w,X)		; FC 00 7E ; Jump to subroutine indirect indexed ($7E00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $8E, $75		; 62 8E 75 ; Push effective relative address $62, $8E, $75 [Writes: Stack Pointer]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ror $7600.w,X		; 7E 00 76 ; Rotate right $7600.w,X [Reads: X Index] [Flags: ZNC]
	bit $42FF.w,X		; 3C FF 42 ; Test bits $42FF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $42C37E.l,X		; FF 7E C3 42 ; Subtract with carry (long,X) $42C37E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$66.b]		; E7 66 ; Subtract with carry (long) [$66.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C3C.w,X		; 7E 3C 3C ; Rotate right $3C3C.w,X [Reads: X Index] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $81BD.w,X		; 7E BD 81 ; Rotate right $81BD.w,X [Reads: X Index] [Flags: ZNC]
	lda $4299.w,X		; BD 99 42 ; Load $4299.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $1028.w,X		; 3C 28 10 ; Test bits $1028.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jmp ($AA10.w)		; 6C 10 AA ; Jump indirect to ($AA10.w) [Flow: jump]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	mvn $54,$EE		; 54 EE 54 ; Move block negative $54,$EE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	inc $9210.w		; EE 10 92 ; Increment $9210.w [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($BAFE.w,X)		; 7C FE BA ; Jump indirect indexed to ($BAFE.w,X) [Reads: X Index] [Flow: jump]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	inc $0092.w,X		; FE 92 00 ; Increment memory $0092.w,X [Reads: X Index] [Flags: ZN]
	and ($1E.b)		; 32 1E ; AND accumulator with memory (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $38.b		; 66 38 ; Rotate right $38.b [Reads: Direct Page] [Flags: ZNC]
	sbc [$78.b]		; E7 78 ; Subtract with carry (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$70.b]		; E7 70 ; Subtract with carry (long) [$70.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
.ACCU 8
.INDEX 8
	sep #$72		; E2 72
	adc ($39.b),Y		; 71 39 ; Add with carry ($39.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $000F0F.l,X		; 3F 0F 0F 00 ; AND accumulator with memory (long,X) $000F0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $FA78.w,X		; 3E 78 FA ; Rotate left $FA78.w,X [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $3F7F.w,X		; FE 7F 3F ; Increment memory $3F7F.w,X [Reads: X Index] [Flags: ZN]
	ora $3A3834.l		; 0F 34 38 3A ; OR accumulator with memory (long) $3A3834.l [Writes: Accumulator] [Flags: ZN]
	tsb $06F5.w		; 0C F5 06 ; Test and set bits $06F5.w [Reads: Accumulator] [Flags: Z]
	adc $06.b,X		; 75 06 ; Add $06.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora #$0E.b		; 09 0E ; Logical OR #$0E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($1C.b)		; 12 1C ; OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr ($F0F0.w,X)		; FC F0 F0 ; Jump to subroutine indirect indexed ($F0F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0727.w		; 0E 27 07 ; Arithmetic shift left $0727.w [Flags: ZNC]
	ora $F0FC1E.l		; 0F 1E FC F0 ; OR accumulator with memory (long) $F0FC1E.l [Writes: Accumulator] [Flags: ZN]
	and $183F10.l,X		; 3F 10 3F 18 ; AND accumulator with memory (long,X) $183F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stz $3C.b,X		; 74 3C ; Store zero to $3C.b,X [Reads: X Index]
	adc ($3A.b)		; 72 3A ; Add with carry (indirect) ($3A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $1C1D.w,Y		; 39 1D 1C ; AND accumulator with memory $1C1D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($3F7E.w,X)		; 7C 7E 3F ; Jump indirect indexed to ($3F7E.w,X) [Reads: X Index] [Flow: jump]
	ora $FC030F.l,X		; 1F 0F 03 FC ; Logical OR long $FC030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $1C12.w		; 0C 12 1C ; Test and set bits $1C12.w [Reads: Accumulator] [Flags: Z]
	cpx $38F8.w		; EC F8 38 ; Compare $38F8.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E0E.w		; 0C 0E 1E ; Test and set bits $1E0E.w [Reads: Accumulator] [Flags: Z]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $2A.b		; 14 2A ; Test and reset bits $2A.b [Reads: Accumulator] [Flags: Z]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and ($1A.b,X)		; 21 1A ; Logical AND ($1A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2D21.w,X		; 1E 21 2D ; Arithmetic shift left $2D21.w,X [Reads: X Index] [Flags: ZNC]
	and ($2D.b,X)		; 21 2D ; Logical AND ($2D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $130C.w		; 0C 0C 13 ; Test and set bits $130C.w [Reads: Accumulator] [Flags: Z]
	.db $10, $AF		; 10 AF ; Branch if plus to $10, $AF [Flow: branch]
	jsr $405F.w		; 20 5F 40 ; Jump to subroutine at $405F.w [Writes: Stack Pointer] [Flow: call]
	eor $80BF40.l,X		; 5F 40 BF 80 ; Exclusive OR accumulator with memory (long,X) $80BF40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $030080.l,X		; BF 80 00 03 ; Load long $030080.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $2010.w		; 0C 10 20 ; Test and set bits $2010.w [Reads: Accumulator] [Flags: Z]
	jsr $4040.w		; 20 40 40 ; Jump to subroutine at $4040.w [Writes: Stack Pointer] [Flow: call]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $3210.w,X		; 3C 10 32 ; Test bits $3210.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	trb $103C.w		; 1C 3C 10 ; Test and reset bits $103C.w [Reads: Accumulator] [Flags: Z]
	and ($1C.b)		; 32 1C ; AND accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $1010.w,X		; 3C 10 10 ; Test bits $1010.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3E3C.w,X		; 3C 3C 3E ; Test bits $3E3C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $3C3E.w,X		; 3C 3E 3C ; Test bits $3C3E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1B3B.w		; 1C 3B 1B ; Test and reset bits $1B3B.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $1F0C.w		; 1C 0C 1F ; Test and reset bits $1F0C.w [Reads: Accumulator] [Flags: Z]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $27.b		; 24 27 ; Test bits $27.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	bit $DC08.w		; 2C 08 DC ; Test bits $DC08.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	trb $3818.w		; 1C 18 38 ; Test and reset bits $3818.w [Reads: Accumulator] [Flags: Z]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E4.b		; 24 E4 ; Test bits $E4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $60F800.l,X		; FF 00 F8 60 ; Subtract with carry (long,X) $60F800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $A75F13.l		; 6F 13 5F A7 ; Add with carry (long) $A75F13.l [Writes: Accumulator] [Flags: ZVNC]
	adc $7D87.w		; 6D 87 7D ; Add $7D87.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	lda [$FD.b],Y		; B7 FD ; Load accumulator (long indexed) [$FD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$60.b],Y		; 37 60 ; AND accumulator with memory (long indexed) [$60.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $070900.l		; 0F 00 09 07 ; OR accumulator with memory (long) $070900.l [Writes: Accumulator] [Flags: ZN]
	and [$07.b],Y		; 37 07 ; AND accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $477D10.l,X		; FF 10 7D 47 ; Subtract with carry (long,X) $477D10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $183C.w,X		; 3C 3C 18 ; Test bits $183C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	eor $A342.w,Y		; 59 42 A3 ; Exclusive OR accumulator with memory $A342.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ldy $00.b		; A4 00 ; Load $00.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	inc $FC00.w,X		; FE 00 FC ; Increment memory $FC00.w,X [Reads: X Index] [Flags: ZN]
	sbc $58BCFF.l,X		; FF FF BC 58 ; Subtract with carry (long,X) $58BCFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $18.b,S		; 83 18 ; Store accumulator (stack relative) $18.b,S [Reads: Accumulator, Stack Pointer]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $23FD44.l,X		; FF 44 FD 23 ; Subtract with carry (long,X) $23FD44.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	and #$F2.b		; 29 F2 ; Logical AND #$F2.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($29E0.w,X)		; FC E0 29 ; Jump to subroutine indirect indexed ($29E0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	pea $0EF1.w		; F4 F1 0E ; Push absolute address $0EF1.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $7BF770.l,X		; FF 70 F7 7B ; Subtract with carry (long,X) $7BF770.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $BF		; 30 BF ; Branch if minus to $30, $BF [Flow: branch]
	and $BF3FB8.l,X		; 3F B8 3F BF ; AND accumulator with memory (long,X) $BF3FB8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $848000.l,X		; 3F 00 80 84 ; AND accumulator with memory (long,X) $848000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $50.b		; 04 50 ; Test and set bits $50.b [Reads: Accumulator] [Flags: Z]
	eor $0C5F4F.l		; 4F 4F 5F 0C ; Exclusive OR accumulator with memory (long) $0C5F4F.l [Writes: Accumulator] [Flags: ZN]
	sbc [$CC.b],Y		; F7 CC ; Subtract with carry (long indexed) [$CC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$FC.b],Y		; 37 FC ; AND accumulator with memory (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta [$9F.b]		; 87 9F ; Store accumulator (long) [$9F.b] [Reads: Accumulator, Direct Page]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp $FF19.w,X		; DD 19 FF ; Compare accumulator $FF19.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$4F.b		; C0 4F ; Compare #$4F.b with Y register [Reads: Y Index] [Flags: ZNC]
	dec $DEC5.w,X		; DE C5 DE ; Decrement memory $DEC5.w,X [Reads: X Index] [Flags: ZN]
	jsl $200400.l		; 22 00 04 20 ; Jump to subroutine long $200400.l [Writes: Stack Pointer] [Flow: call]
	jsl $ECEEC0.l		; 22 C0 EE EC ; Jump to subroutine long $ECEEC0.l [Writes: Stack Pointer] [Flow: call]
	eor $B0.b,S		; 43 B0 ; Exclusive OR accumulator with stack relative $B0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $3FBF0B.l,X		; 3F 0B BF 3F ; AND accumulator with memory (long,X) $3FBF0B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $3F		; B0 3F ; Branch if carry set to $B0, $3F [Flow: branch]
	lda ($3E.b),Y		; B1 3E ; Load accumulator ($3E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($3C.b)		; F2 3C ; Subtract with carry (indirect) ($3C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FD20.w,X		; FD 20 FD ; Subtract with carry $FD20.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $5F23.w,X		; 3C 23 5F ; Test bits $5F23.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr $425D.w,X		; 5E 5D 42 ; Logical shift right $425D.w,X [Reads: X Index] [Flags: ZNC]
	cop $4F.b		; 02 4F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $DE47.w,X		; DE 47 DE ; Decrement memory $DE47.w,X [Reads: X Index] [Flags: ZN]
	cmp [$83.b]		; C7 83 ; Compare accumulator (long) [$83.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta ($00.b),Y		; 91 00 ; Store accumulator ($00.b),Y [Reads: Accumulator, Direct Page, Y Index]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: ZNC]
	adc $0A8F42.l,X		; 7F 42 8F 0A ; Add long $0A8F42.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$02.b],Y		; F7 02 ; Subtract with carry (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $EC.b,S		; 23 EC ; AND accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $2C.b,S		; 03 2C ; OR accumulator with stack relative $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $70		; 80 70 ; Branch always to $80, $70 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	sbc $040025.l,X		; FF 25 00 04 ; Subtract with carry (long,X) $040025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E70000.l,X		; FF 00 00 E7 ; Subtract with carry (long,X) $E70000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $E7.b		; 45 E7 ; Exclusive OR $E7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $BC.b,S		; 43 BC ; Exclusive OR accumulator with stack relative $BC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $8C.b,S		; 63 8C ; Add with carry (stack relative) $8C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc ($BC.b,S),Y		; 73 BC ; Add with carry (stack relative indirect indexed) ($BC.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($3C.b,S),Y		; F3 3C ; Subtract with carry (stack relative indirect indexed) ($3C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $30.b		; 02 30 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $48.b		; 85 48 ; Store accumulator to $48.b [Reads: Accumulator]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $7B.b,S		; 83 7B ; Store accumulator (stack relative) $7B.b,S [Reads: Accumulator, Stack Pointer]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $588300.l,X		; FF 00 83 58 ; Subtract with carry (long,X) $588300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00D9.w,X		; 1D D9 00 ; OR accumulator with memory $00D9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FF00FF.l,X		; FF FF 00 FF ; Subtract with carry (long,X) $FF00FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $E00022.l		; 22 22 00 E0 ; Jump to subroutine long $E00022.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $7D		; 42 7D ; Reserved instruction
	lda [$EF.b],Y		; B7 EF ; Load accumulator (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$24.b],Y		; 17 24 ; OR accumulator with memory (long indexed) [$24.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	rol $FFDB.w,X		; 3E DB FF ; Rotate left $FFDB.w,X [Reads: X Index] [Flags: ZNC]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FF.b,S		; E3 FF ; Subtract stack-relative $FF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$EA.b],Y		; B7 EA ; Load accumulator (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$26.b],Y		; 17 26 ; OR accumulator with memory (long indexed) [$26.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $FE.b,S		; C3 FE ; Compare accumulator (stack relative) $FE.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	rol $FCDB.w,X		; 3E DB FC ; Rotate left $FCDB.w,X [Reads: X Index] [Flags: ZNC]
	cop $15.b		; 02 15 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF.b,S		; E3 FF ; Subtract stack-relative $FF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $1CE3.w,X		; BC E3 1C ; Load Y register $1CE3.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	and $C4.b,S		; 23 C4 ; AND accumulator with stack relative $C4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	trb $DC3B.w		; 1C 3B DC ; Test and reset bits $DC3B.w [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $13.b		; 04 13 ; Test and set bits $13.b [Reads: Accumulator] [Flags: Z]
	cpx $FB.b		; E4 FB ; Compare $FB.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $080A00.l		; 22 00 0A 08 ; Jump to subroutine long $080A00.l [Writes: Stack Pointer] [Flow: call]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $ED.b,Y		; B6 ED ; Load X register $ED.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	ora ($27.b),Y		; 11 27 ; OR accumulator with memory ($27.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $011187.l,X		; 3F 87 11 01 ; AND accumulator with memory (long,X) $011187.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0303.w,Y		; 19 03 03 ; OR accumulator with memory $0303.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($37.b,S),Y		; 93 37 ; Store accumulator (stack relative indirect indexed) ($37.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$6F.b],Y		; B7 6F ; Load accumulator (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta [$24.b],Y		; 97 24 ; Store accumulator (long indexed) [$24.b],Y [Reads: Accumulator, Direct Page, Y Index]
	cpy #$3C.b		; C0 3C ; Compare #$3C.b with Y register [Reads: Y Index] [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	inc $FF1B.w,X		; FE 1B FF ; Increment memory $FF1B.w,X [Reads: X Index] [Flags: ZN]
	sbc $16.b,S		; E3 16 ; Subtract stack-relative $16.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc $1F.b,S		; E3 1F ; Subtract stack-relative $1F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sta [$18.b]		; 87 18 ; Store accumulator (long) [$18.b] [Reads: Accumulator, Direct Page]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $D7.b,S		; 23 D7 ; AND accumulator with stack relative $D7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $50, $E7		; 50 E7 ; Branch if overflow clear to $50, $E7 [Flow: branch]
	ldy #$33.b		; A0 33 ; Load #$33.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $10, $49		; 10 49 ; Branch if plus to $10, $49 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sta $BD14.w,X		; 9D 14 BD ; Store accumulator to $BD14.w,X [Reads: Accumulator, X Index]
	jsr $5AFE.w		; 20 FE 5A ; Jump to subroutine at $5AFE.w [Writes: Stack Pointer] [Flow: call]
	sbc $982800.l,X		; FF 00 28 98 ; Subtract with carry (long,X) $982800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy $6236.w		; CC 36 62 ; Compare $6236.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $42, $01		; 42 01 ; Reserved instruction
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $FD		; F0 FD ; Branch if equal to $F0, $FD [Flow: branch]
	pea $0005.w		; F4 05 00 ; Push absolute address $0005.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $F8.b		; 05 F8 ; Logical OR $F8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stx $FA.b		; 86 FA ; Store X register to $FA.b [Reads: X Index]
	sbc $FF22F8.l,X		; FF F8 22 FF ; Subtract with carry (long,X) $FF22F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	pea $FAF2.w		; F4 F2 FA ; Push absolute address $FAF2.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cop $F9.b		; 02 F9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3F3F.w		; 0D 3F 3F ; Logical OR $3F3F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and ($31.b),Y		; 31 31 ; AND accumulator with memory ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $23.b,S		; 23 23 ; AND accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and [$27.b]		; 27 27 ; AND accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $3C2E.w		; 2E 2E 3C ; Rotate left $3C2E.w [Flags: ZNC]
	bit $7F00.w,X		; 3C 00 7F ; Test bits $7F00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $40.b		; 25 40 ; Logical AND $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $1E8000.l,X		; FF 00 80 1E ; Subtract with carry (long,X) $1E8000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $9F1F.w,X		; 9E 1F 9F ; Store zero to $9F1F.w,X [Reads: X Index]
	eor $3F.b		; 45 3F ; Exclusive OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $9F1F05.l,X		; BF 05 1F 9F ; Load long $9F1F05.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($60.b,X)		; 61 60 ; Add with carry ($60.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsl $600040.l		; 22 40 00 60 ; Jump to subroutine long $600040.l [Writes: Stack Pointer] [Flow: call]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $441000.l,X		; FF 00 10 44 ; Subtract with carry (long,X) $441000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $400400.l,X		; FF 00 04 40 ; Subtract with carry (long,X) $400400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF04.l,X		; FF 04 FF 00 ; Subtract with carry (long,X) $00FF04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc $1FE002.l,X		; FF 02 E0 1F ; Subtract with carry (long,X) $1FE002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $01FC83.l		; EF 83 FC 01 ; Subtract with carry (long) $01FC83.l [Writes: Accumulator] [Flags: ZVNC]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $010022.l,X		; FF 22 00 01 ; Subtract with carry (long,X) $010022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0025FF.l,X		; FF FF 25 00 ; Subtract with carry (long,X) $0025FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $80057F.l,X		; FF 7F 05 80 ; Subtract with carry (long,X) $80057F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $4300FF.l,X		; 3F FF 00 43 ; AND accumulator with memory (long,X) $4300FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $C0003F.l,X		; FF 3F 00 C0 ; Subtract with carry (long,X) $C0003F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $7F0000.l		; 22 00 00 7F ; Jump to subroutine long $7F0000.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b,S),Y		; 13 3F ; OR accumulator (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($BC.b,S),Y		; 73 BC ; Add with carry (stack relative indirect indexed) ($BC.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $9C.b,S		; 63 9C ; Add with carry (stack relative) $9C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	and $C4.b,S		; 23 C4 ; AND accumulator with stack relative $C4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp.w [$1CFB]		; DC FB 1C ; Jump long indirect [$1CFB] [Flow: jump]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cpx $13.b		; E4 13 ; Compare $13.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx $1B.b		; E4 1B ; Compare $1B.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx $0000.w		; EC 00 00 ; Compare $0000.w with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $081100.l		; 22 00 11 08 ; Jump to subroutine long $081100.l [Writes: Stack Pointer] [Flow: call]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($C6.b),Y		; 31 C6 ; AND accumulator with memory ($C6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sty $9977.w		; 8C 77 99 ; Store Y register to $9977.w [Reads: Y Index]
	ror $DC33.w		; 6E 33 DC ; Rotate right $DC33.w [Flags: ZNC]
	jmp ($F3B0.w)		; 6C B0 F3 ; Jump indirect to ($F3B0.w) [Flow: jump]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $0C0024.l,X		; 3F 24 00 0C ; AND accumulator with memory (long,X) $0C0024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$1F.b		; C0 1F ; Compare #$1F.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$75.b		; E0 75 ; Compare #$75.b with X register [Reads: X Index] [Flags: ZNC]
	stx $CE.b		; 86 CE ; Store X register to $CE.b [Reads: X Index]
	ora $253F3E.l		; 0F 3E 3F 25 ; OR accumulator with memory (long) $253F3E.l [Writes: Accumulator] [Flags: ZN]
	sbc $000004.l,X		; FF 04 00 00 ; Subtract with carry (long,X) $000004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	jsl $550500.l		; 22 00 05 55 ; Jump to subroutine long $550500.l [Writes: Stack Pointer] [Flow: call]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	cmp $2A.b,X		; D5 2A ; Compare accumulator $2A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $8982.w,X		; FD 82 89 ; Subtract with carry $8982.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: ZNC]
	jsl $738400.l		; 22 00 84 73 ; Jump to subroutine long $738400.l [Writes: Stack Pointer] [Flow: call]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $FE79C0.l,X		; BF C0 79 FE ; Load long $FE79C0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $FA.b,S		; 83 FA ; Store accumulator (stack relative) $FA.b,S [Reads: Accumulator, Stack Pointer]
	jsl $038300.l		; 22 00 83 03 ; Jump to subroutine long $038300.l [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $87.b		; 04 87 ; Test and set bits $87.b [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cop $86.b		; 02 86 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2222.w		; 20 22 22 ; Jump to subroutine at $2222.w [Writes: Stack Pointer] [Flow: call]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $BF		; 80 BF ; Branch always to $80, $BF [Flow: branch]
	ldx $7E7D.w,Y		; BE 7D 7E ; Load X register $7E7D.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	jsl $200400.l		; 22 00 04 20 ; Jump to subroutine long $200400.l [Writes: Stack Pointer] [Flow: call]
	jsl $B8DE80.l		; 22 80 DE B8 ; Jump to subroutine long $B8DE80.l [Writes: Stack Pointer] [Flow: call]
	stx $02B8.w		; 8E B8 02 ; Store X register to $02B8.w [Reads: X Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $130022.l		; 22 22 00 13 ; Jump to subroutine long $130022.l [Writes: Stack Pointer] [Flow: call]
	sbc $6FFA00.l,X		; FF 00 FA 6F ; Subtract with carry (long,X) $6FFA00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($6F.b)		; F2 6F ; Subtract with carry (indirect) ($6F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $6F.b,X		; F6 6F ; Increment memory $6F.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda [$6A.b]		; A7 6A ; Load accumulator (long) [$6A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta [$7A.b]		; 87 7A ; Store accumulator (long) [$7A.b] [Reads: Accumulator, Direct Page]
	lda [$FB.b],Y		; B7 FB ; Load accumulator (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$60.b],Y		; 37 60 ; AND accumulator with memory (long indexed) [$60.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$85.b]		; 07 85 ; OR accumulator with memory (long) [$85.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	eor [$9F.b]		; 47 9F ; Exclusive OR accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$06.b		; E0 06 ; Compare #$06.b with X register [Reads: X Index] [Flags: ZNC]
	cmp $A09FE0.l,X		; DF E0 9F A0 ; Compare accumulator (long,X) $A09FE0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	eor $250060.l,X		; 5F 60 00 25 ; Exclusive OR accumulator with memory (long,X) $250060.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $87		; 80 87 ; Branch always to $80, $87 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $7F9070.l		; CF 70 90 7F ; Compare accumulator (long) $7F9070.l [Reads: Accumulator] [Flags: ZNC]
	sbc $7F817F.l,X		; FF 7F 81 7F ; Subtract with carry (long,X) $7F817F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $E8.b		; 84 E8 ; Store Y register to $E8.b [Reads: Y Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $8A7F7F.l,X		; 1F 7F 7F 8A ; Logical OR long $8A7F7F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $02.b,S		; E3 02 ; Subtract stack-relative $02.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FB,$6F		; 44 6F FB ; Move block positive $FB,$6F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($55.b,X)		; 01 55 ; Logical OR ($55.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	lda $000A86.l		; AF 86 0A 00 ; Load long $000A86.l into accumulator [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $BB.b		; 84 BB ; Store Y register to $BB.b [Reads: Y Index]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF3F08.l,X		; FF 08 3F FF ; Subtract with carry (long,X) $FF3F08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $7F0FFF.l,X		; 1F FF 0F 7F ; Logical OR long $7F0FFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$9F.b]		; 07 9F ; OR accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $25.b,S		; 83 25 ; Store accumulator (stack relative) $25.b,S [Reads: Accumulator, Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	sta [$48.b]		; 87 48 ; Store accumulator (long) [$48.b] [Reads: Accumulator, Direct Page]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$78.b],Y		; B7 78 ; Load accumulator (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $7FB07F.l		; 8F 7F B0 7F ; Store accumulator (long) $7FB07F.l [Reads: Accumulator]
	lda $033F84.l,X		; BF 84 3F 03 ; Load long $033F84.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit #$60.b		; 89 60 ; Test bits #$60.b with accumulator [Reads: Accumulator] [Flags: Z]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($02.b,S),Y		; B3 02 ; Load accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $60.b,S		; 83 60 ; Store accumulator (stack relative) $60.b,S [Reads: Accumulator, Stack Pointer]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $6FFE6F.l,X		; FF 6F FE 6F ; Subtract with carry (long,X) $6FFE6F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp $8569A6.l		; 5C A6 69 85 ; Jump long to $8569A6.l [Flow: jump]
	adc $34FFB6.l,X		; 7F B6 FF 34 ; Add long $34FFB6.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $010100.l		; 22 00 01 01 ; Jump to subroutine long $010100.l [Writes: Stack Pointer] [Flow: call]
	and ($85.b)		; 32 85 ; AND accumulator with memory (indirect) ($85.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $03.b,X		; 76 03 ; Rotate right $03.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ror $3CFF.w,X		; 7E FF 3C ; Rotate right $3CFF.w,X [Reads: X Index] [Flags: ZNC]
	ror $BD99.w,X		; 7E 99 BD ; Rotate right $BD99.w,X [Reads: X Index] [Flags: ZNC]
	cmp $5A.b,S		; C3 5A ; Compare accumulator (stack relative) $5A.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc [$24.b]		; E7 24 ; Subtract with carry (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $002218.l,X		; FF 18 22 00 ; Subtract with carry (long,X) $002218.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $81.b,S		; 03 81 ; OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $42, $24		; 42 24 ; Reserved instruction
	clc		; 18 ; Clear carry flag [Flags: C]
	stx $D7.b		; 86 D7 ; Store X register to $D7.b [Reads: X Index]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $BF.b,S		; 03 BF ; OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $70, $BB		; 70 BB ; Branch if overflow set to $70, $BB [Flow: branch]
	adc $A77AB3.l,X		; 7F B3 7A A7 ; Add long $A77AB3.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $85.b,X		; 74 85 ; Store zero to $85.b,X [Reads: X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	bit #$60.b		; 89 60 ; Test bits #$60.b with accumulator [Reads: Accumulator] [Flags: Z]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2222.w		; 20 22 22 ; Jump to subroutine at $2222.w [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004300.l,X		; FF 00 43 00 ; Subtract with carry (long,X) $004300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF08.l,X		; FF 08 FF 00 ; Subtract with carry (long,X) $00FF08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $06.b		; C5 06 ; Compare $06.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	lda $7D823D.l,X		; BF 3D 82 7D ; Load long $7D823D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $010024.l,X		; FF 24 00 01 ; Subtract with carry (long,X) $010024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $8340.w,Y		; 79 40 83 ; Add $8340.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $080400.l,X		; FF 00 04 08 ; Subtract with carry (long,X) $080400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F708F7.l,X		; FF F7 08 F7 ; Subtract with carry (long,X) $F708F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $000024.l,X		; FF 24 00 00 ; Subtract with carry (long,X) $000024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$22.b],Y		; F7 22 ; Subtract with carry (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $01FE00.l,X		; FF 00 FE 01 ; Subtract with carry (long,X) $01FE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$F0.b]		; 07 F0 ; OR accumulator with memory (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $F91FE6.l		; 0F E6 1F F9 ; OR accumulator with memory (long) $F91FE6.l [Writes: Accumulator] [Flags: ZN]
	ora [$E6.b]		; 07 E6 ; OR accumulator with memory (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3EC1.w,Y		; 19 C1 3E ; OR accumulator with memory $3EC1.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $340FF8.l		; 0F F8 0F 34 ; OR accumulator with memory (long) $340FF8.l [Writes: Accumulator] [Flags: ZN]
	cmp $0DE71A.l		; CF 1A E7 0D ; Compare accumulator (long) $0DE71A.l [Reads: Accumulator] [Flags: ZNC]
	sbc ($06.b,S),Y		; F3 06 ; Subtract with carry (stack relative indirect indexed) ($06.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FC83.w,Y		; F9 83 FC ; Subtract with carry $FC83.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($FE.b,X)		; 61 FE ; Add with carry ($FE.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $080027.l,X		; 7F 27 00 08 ; Add long $080027.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $6DB6.w,X		; 7E B6 6D ; Rotate right $6DB6.w,X [Reads: X Index] [Flags: ZNC]
	sta ($27.b),Y		; 91 27 ; Store accumulator ($27.b),Y [Reads: Accumulator, Direct Page, Y Index]
	cmp $3F.b,S		; C3 3F ; Compare accumulator (stack relative) $3F.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc $018987.l,X		; FF 87 89 01 ; Subtract with carry (long,X) $018987.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $61.b		; 86 61 ; Store X register to $61.b [Reads: X Index]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp $EAD5E0.l,X		; DF E0 D5 EA ; Compare accumulator (long,X) $EAD5E0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc $50.b		; E5 50 ; Subtract $50.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $40DFA0.l		; EF A0 DF 40 ; Subtract with carry (long) $40DFA0.l [Writes: Accumulator] [Flags: ZVNC]
	lda $7F7FBF.l,X		; BF BF 7F 7F ; Load long $7F7FBF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $C0C040.l,X		; FF 40 C0 C0 ; Subtract with carry (long,X) $C0C040.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $857E.w,X		; FE 7E 85 ; Increment memory $857E.w,X [Reads: X Index] [Flags: ZN]
	adc $7F80.w,X		; 7D 80 7F ; Add $7F80.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $00257E.l,X		; 7F 7E 25 00 ; Add long $00257E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sbc $FBF5.w,X		; FD F5 FB ; Subtract with carry $FBF5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$F3.b],Y		; F7 F3 ; Subtract with carry (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $C35FA3.l		; 0F A3 5F C3 ; OR accumulator with memory (long) $C35FA3.l [Writes: Accumulator] [Flags: ZN]
	and $04D083.l,X		; 3F 83 D0 04 ; AND accumulator with memory (long,X) $04D083.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($70.b,X)		; 01 70 ; Logical OR ($70.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: ZNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $6AB7.w,X		; 7D B7 6A ; Add $6AB7.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta [$26.b],Y		; 97 26 ; Store accumulator (long indexed) [$26.b],Y [Reads: Accumulator, Direct Page, Y Index]
	cmp $3E.b,S		; C3 3E ; Compare accumulator (stack relative) $3E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	inc $FC1B.w,X		; FE 1B FC ; Increment memory $FC1B.w,X [Reads: X Index] [Flags: ZN]
.INDEX 8
	sep #$15		; E2 15
	sbc $1F.b,S		; E3 1F ; Subtract stack-relative $1F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sta [$30.b]		; 87 30 ; Store accumulator (long) [$30.b] [Reads: Accumulator, Direct Page]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $E3.b,S		; 23 E3 ; AND accumulator with stack relative $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FF.b,S		; E3 FF ; Subtract stack-relative $FF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc $1CFFBE.l,X		; FF BE FF 1C ; Subtract with carry (long,X) $1CFFBE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $5D49.w,Y		; BE 49 5D ; Load X register $5D49.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sbc $AA.b,S		; E3 AA ; Subtract stack-relative $AA.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc [$14.b],Y		; F7 14 ; Subtract with carry (long indexed) [$14.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $001C00.l,X		; FF 00 1C 00 ; Subtract with carry (long,X) $001C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$14.b		; A2 14 ; Load #$14.b into X register [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($BE.b,X)		; 61 BE ; Add with carry ($BE.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx $BF70.w,Y		; BE 70 BF ; Load X register $BF70.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda $7EBF7C.l,X		; BF 7C BF 7E ; Load long $7EBF7C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $BF.b,S		; 43 BF ; Exclusive OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $010202.l,X		; 7F 02 02 01 ; Add long $010202.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$F4.b]		; E7 F4 ; Subtract with carry (long) [$F4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $F4E7E8.l		; CF E8 E7 F4 ; Compare accumulator (long) $F4E7E8.l [Reads: Accumulator] [Flags: ZNC]
	adc ($7A.b,S),Y		; 73 7A ; Add with carry (stack relative indirect indexed) ($7A.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $737C.w,Y		; 79 7C 73 ; Add $737C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sta $28.b,S		; 83 28 ; Store accumulator (stack relative) $28.b,S [Reads: Accumulator, Stack Pointer]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	sty $82.b		; 84 82 ; Store Y register to $82.b [Reads: Y Index]
	sty $08.b		; 84 08 ; Store Y register to $08.b [Reads: Y Index]
	.db $10, $7B		; 10 7B ; Branch if plus to $10, $7B [Flow: branch]
	ldy $6B.b,X		; B4 6B ; Load Y register $6B.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	sty $85.b,X		; 94 85 ; Store Y register $85.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	mvp $00,$02		; 44 02 00 ; Move block positive $00,$02 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sta [$4B.b]		; 87 4B ; Store accumulator (long) [$4B.b] [Reads: Accumulator, Direct Page]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $55.b		; 00 55 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	eor $44.b,X		; 55 44 ; Exclusive OR accumulator with memory $44.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $8F.b		; 05 8F ; Logical OR $8F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	lda [$74.b]		; A7 74 ; Load accumulator (long) [$74.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda ($7A.b,S),Y		; B3 7A ; Load accumulator (stack relative indirect indexed) ($7A.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $B9.b,S		; 43 B9 ; Exclusive OR accumulator with stack relative $B9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $FC83.w,X		; 7D 83 FC ; Add $FC83.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $081068.l		; 8F 68 10 08 ; Store accumulator (long) $081068.l [Reads: Accumulator]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $87		; 10 87 ; Branch if plus to $10, $87 [Flow: branch]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	sta [$D0.b]		; 87 D0 ; Store accumulator (long) [$D0.b] [Reads: Accumulator, Direct Page]
	tsb $27.b		; 04 27 ; Test and set bits $27.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$68.b],Y		; 97 68 ; Store accumulator (long indexed) [$68.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sta $6648.w,X		; 9D 48 66 ; Store accumulator to $6648.w,X [Reads: Accumulator, X Index]
	sta $83.b,X		; 95 83 ; Store accumulator to $83.b,X [Reads: Accumulator, X Index]
	ldy #$05.b		; A0 05 ; Load #$05.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $08.b		; 24 08 ; Test bits $08.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor [$95.b]		; 47 95 ; Exclusive OR accumulator with memory (long) [$95.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $02.b		; 66 02 ; Rotate right $02.b [Reads: Direct Page] [Flags: ZNC]
	sta [$68.b],Y		; 97 68 ; Store accumulator (long indexed) [$68.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sta $6644.w,X		; 9D 44 66 ; Store accumulator to $6644.w,X [Reads: Accumulator, X Index]
	sta $23.b,X		; 95 23 ; Store accumulator to $23.b,X [Reads: Accumulator, X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $BE0B08.l		; 22 08 0B BE ; Jump to subroutine long $BE0B08.l [Writes: Stack Pointer] [Flow: call]
	adc $708F0F.l,X		; 7F 0F 8F 70 ; Add long $708F0F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FF23.w,X)		; FC 23 FF ; Jump to subroutine indirect indexed ($FF23.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $9E9F66.l		; 0F 66 9F 9E ; OR accumulator with memory (long) $9E9F66.l [Writes: Accumulator] [Flags: ZN]
	sbc ($E7.b,X)		; E1 E7 ; Subtract with carry ($E7.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $F21E.w,Y		; 19 1E F2 ; OR accumulator with memory $F21E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($FF.b,S),Y		; 13 FF ; OR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $FE		; F0 FE ; Branch if equal to $F0, $FE [Flow: branch]
	sbc $010022.l,X		; FF 22 00 01 ; Subtract with carry (long,X) $010022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$0C.b		; E0 0C ; Compare #$0C.b with X register [Reads: X Index] [Flags: ZNC]
	jsl $23FF00.l		; 22 00 FF 23 ; Jump to subroutine long $23FF00.l [Writes: Stack Pointer] [Flow: call]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($CCFC.w,X)		; FC FC CC ; Jump to subroutine indirect indexed ($CCFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy $8484.w		; CC 84 84 ; Compare $8484.w with Y register [Reads: Y Index] [Flags: ZNC]
	and $04.b		; 25 04 ; Logical AND $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $0225.w,X		; FE 25 02 ; Increment memory $0225.w,X [Reads: X Index] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	jsr $2120.w		; 20 20 21 ; Jump to subroutine at $2120.w [Writes: Stack Pointer] [Flow: call]
	and ($23.b,X)		; 21 23 ; Logical AND ($23.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $3F.b,S		; 23 3F ; AND accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $250023.l,X		; 3F 23 00 25 ; AND accumulator with memory (long,X) $250023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $44.b		; 24 44 ; Test bits $44.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	mvp $84,$84		; 44 84 84 ; Move block positive $84,$84 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $04.b,S		; 23 04 ; AND accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr ($0023.w,X)		; FC 23 00 ; Jump to subroutine indirect indexed ($0023.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $02.b		; 25 02 ; Logical AND $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($6D.b)		; 92 6D ; Store accumulator (indirect) ($6D.b) [Reads: Accumulator, Direct Page]
	ora ($93.b,X)		; 01 93 ; Logical OR ($93.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jmp ($9243.w)		; 6C 43 92 ; Jump indirect to ($9243.w) [Flow: jump]
	adc $F201.w		; 6D 01 F2 ; Add $F201.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	ora $0027.w		; 0D 27 00 ; Logical OR $0027.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $55.b		; 45 55 ; Exclusive OR $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	ora $5D.b,S		; 03 5D ; OR accumulator with stack relative $5D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldx #$D5.b		; A2 D5 ; Load #$D5.b into X register [Writes: X Index] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	eor $55.b		; 45 55 ; Exclusive OR $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $66.b		; 04 66 ; Test and set bits $66.b [Reads: Accumulator] [Flags: Z]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $200400.l		; 22 00 04 20 ; Jump to subroutine long $200400.l [Writes: Stack Pointer] [Flow: call]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3FC000.l,X		; FF 00 C0 3F ; Subtract with carry (long,X) $3FC000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy #$5F.b		; A0 5F ; Load #$5F.b into Y register [Writes: Y Index] [Flags: ZN]
	sta $679860.l,X		; 9F 60 98 67 ; Store accumulator (long,X) $679860.l,X [Reads: Accumulator, X Index]
	sty $6B.b,X		; 94 6B ; Store Y register $6B.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	eor $93.b,S		; 43 93 ; Exclusive OR accumulator with stack relative $93.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp ($0027.w)		; 6C 27 00 ; Jump indirect to ($0027.w) [Flow: jump]
	ora $7F7F80.l		; 0F 80 7F 7F ; OR accumulator with memory (long) $7F7F80.l [Writes: Accumulator] [Flags: ZN]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	sta $58A05F.l,X		; 9F 5F A0 58 ; Store accumulator (long,X) $58A05F.l,X [Reads: Accumulator, X Index]
	lda [$57.b]		; A7 57 ; Load accumulator (long) [$57.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	lsr $A9.b,X		; 56 A9 ; Logical shift right $A9.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $AA.b,X		; 55 AA ; Exclusive OR accumulator with memory $AA.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $A8.b,S		; 83 A8 ; Store accumulator (stack relative) $A8.b,S [Reads: Accumulator, Stack Pointer]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $9B.b		; 64 9B ; Store zero to $9B.b
	eor $A55AA0.l,X		; 5F A0 5A A5 ; Exclusive OR accumulator with memory (long,X) $A55AA0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$88.b],Y		; 77 88 ; Add with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $55A1.w,X		; 5E A1 55 ; Logical shift right $55A1.w,X [Reads: X Index] [Flags: ZNC]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $99F68D.l		; 0F 8D F6 99 ; OR accumulator with memory (long) $99F68D.l [Writes: Accumulator] [Flags: ZN]
	ror $9D72.w		; 6E 72 9D ; Rotate right $9D72.w [Flags: ZNC]
	stz $BB.b		; 64 BB ; Store zero to $BB.b
	cmp #$76.b		; C9 76 ; Compare #$76.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $2C.b		; E5 2C ; Subtract $2C.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp ($49.b,S),Y		; D3 49 ; Compare accumulator (stack relative indirect indexed) ($49.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	ldx $27.b,Y		; B6 27 ; Load X register $27.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($6C.b,S),Y		; 93 6C ; Store accumulator (stack relative indirect indexed) ($6C.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	rol $D9.b		; 26 D9 ; Rotate left $D9.b [Reads: Direct Page] [Flags: ZNC]
	eor $FBB2.w		; 4D B2 FB ; Exclusive OR $FBB2.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $36.b		; 04 36 ; Test and set bits $36.b [Reads: Accumulator] [Flags: Z]
	cmp #$6D.b		; C9 6D ; Compare #$6D.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	sta ($DF.b)		; 92 DF ; Store accumulator (indirect) ($DF.b) [Reads: Accumulator, Direct Page]
	jsr $49B6.w		; 20 B6 49 ; Jump to subroutine at $49B6.w [Writes: Stack Pointer] [Flow: call]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$ED.b]		; 07 ED ; OR accumulator with memory (long) [$ED.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($DB.b)		; 12 DB ; OR accumulator with memory (indirect) ($DB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $B6.b		; 24 B6 ; Test bits $B6.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	eor #$7D.b		; 49 7D ; Exclusive OR #$7D.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $82, $83, $0A		; 82 83 0A ; Branch always long to $82, $83, $0A [Flow: branch]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $DA92.w		; 6D 92 DA ; Add $DA92.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	and $27.b		; 25 27 ; Logical AND $27.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: ZNC]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	lda $C300.w,X		; BD 00 C3 ; Load $C300.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $42, $47		; 42 47 ; Reserved instruction
	lda $037E.w,X		; BD 7E 03 ; Load $037E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $233C.w,X		; 7E 3C 23 ; Rotate right $233C.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $810046.l,X		; FF 46 00 81 ; Subtract with carry (long,X) $810046.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $24.b,S		; 83 24 ; Store accumulator (stack relative) $24.b,S [Reads: Accumulator, Stack Pointer]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	lda $007E.w,X		; BD 7E 00 ; Load $007E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $3C00.w,X		; 7E 00 3C ; Rotate right $3C00.w,X [Reads: X Index] [Flags: ZNC]
	sta $8E.b,S		; 83 8E ; Store accumulator (stack relative) $8E.b,S [Reads: Accumulator, Stack Pointer]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $E6.b		; 46 E6 ; Logical shift right $E6.b [Reads: Direct Page] [Flags: ZNC]
	.db $42, $C2		; 42 C2 ; Reserved instruction
	and #$A9.b		; 29 A9 ; Logical AND #$A9.b with accumulator [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$06.b		; E0 06 ; Compare #$06.b with X register [Reads: X Index] [Flags: ZNC]
	stx $12.b		; 86 12 ; Store X register to $12.b [Reads: X Index]
	sta ($7F.b)		; 92 7F ; Store accumulator (indirect) ($7F.b) [Reads: Accumulator, Direct Page]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	ora $563D.w,Y		; 19 3D 56 ; OR accumulator with memory $563D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $7F6D79.l,X		; 1F 79 6D 7F ; Logical OR long $7F6D79.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $90.b,S		; 83 90 ; Store accumulator (stack relative) $90.b,S [Reads: Accumulator, Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $568900.l,X		; FF 00 89 56 ; Subtract with carry (long,X) $568900.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $01.b,S		; 63 01 ; Add with carry (stack relative) $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $00FF01.l,X		; FF 01 FF 00 ; Subtract with carry (long,X) $00FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $018083.l,X		; 7F 83 80 01 ; Add long $018083.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $86.b,S		; 83 86 ; Store accumulator (stack relative) $86.b,S [Reads: Accumulator, Stack Pointer]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $92.b		; 45 92 ; Exclusive OR $92.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $9301.w		; 6D 01 93 ; Add $9301.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	jmp ($9245.w)		; 6C 45 92 ; Jump indirect to ($9245.w) [Flow: jump]
	adc $9E01.w		; 6D 01 9E ; Add $9E01.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	adc ($27.b,X)		; 61 27 ; Add with carry ($27.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$A8.b],Y		; 57 A8 ; Exclusive OR accumulator with memory (long indexed) [$A8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $55.b,S		; 43 55 ; Exclusive OR accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	ora ($DD.b,X)		; 01 DD ; Logical OR ($DD.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $AA5545.l		; 22 45 55 AA ; Jump to subroutine long $AA5545.l [Writes: Stack Pointer] [Flow: call]
	ora ($77.b,X)		; 01 77 ; Logical OR ($77.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $000A00.l		; 22 00 0A 00 ; Jump to subroutine long $000A00.l [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $D80000.l		; 22 00 00 D8 ; Jump to subroutine long $D80000.l [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $126D12.l,X		; 3F 12 6D 12 ; AND accumulator with memory (long,X) $126D12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $CD12.w		; AD 12 CD ; Load $CD12.w into accumulator [Writes: Accumulator] [Flags: ZN]
.INDEX 8
	sep #$1D		; E2 1D
	cop $F5.b		; 02 F5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $F9.b		; 02 F9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0003.w,X)		; FC 03 00 ; Jump to subroutine indirect indexed ($0003.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $4080.w,X		; FE 80 40 ; Increment memory $4080.w,X [Reads: X Index] [Flags: ZN]
	jsr $0800.w		; 20 00 08 ; Jump to subroutine at $0800.w [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($57.b,X)		; 01 57 ; Logical OR ($57.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sta $6A.b,X		; 95 6A ; Store accumulator to $6A.b,X [Reads: Accumulator, X Index]
	eor $CA.b,X		; 55 CA ; Exclusive OR accumulator with memory $CA.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $1A.b		; E5 1A ; Subtract $1A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $F2.b		; 05 F2 ; Logical OR $F2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $8106.w,Y		; F9 06 81 ; Subtract with carry $8106.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($01FE.w,X)		; 7C FE 01 ; Jump indirect indexed to ($01FE.w,X) [Reads: X Index] [Flow: jump]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	jsr $0800.w		; 20 00 08 ; Jump to subroutine at $0800.w [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1D6897.l		; 22 97 68 1D ; Jump to subroutine long $1D6897.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$E7		; C2 E7
	clc		; 18 ; Clear carry flag [Flags: C]
	lda $52.b		; A5 52 ; Load $52.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $55.b		; 04 55 ; Test and set bits $55.b [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	sbc $388400.l,X		; FF 00 84 38 ; Subtract with carry (long,X) $388400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $EE0B00.l,X		; FF 00 0B EE ; Subtract with carry (long,X) $EE0B00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($B7.b),Y		; 11 B7 ; OR accumulator with memory ($B7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.INDEX 8
	sep #$1D		; E2 1D
	lda $CA4B.w,X		; BD 4B CA ; Load $CA4B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $9F.b,X		; 35 9F ; Logical AND $9F.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $EB01FE.l		; 0F FE 01 EB ; OR accumulator with memory (long) $EB01FE.l [Writes: Accumulator] [Flags: ZN]
	ora $FC.b,X		; 15 FC ; OR accumulator with memory $FC.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $D5.b,S		; 03 D5 ; OR accumulator with stack relative $D5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	sbc [$1D.b]		; E7 1D ; Subtract with carry (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $09.b,X		; F6 09 ; Increment memory $09.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $D7.b		; 05 D7 ; Logical OR $D7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $0027.w		; 2D 27 00 ; Logical AND $0027.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $E7C3FC.l		; 0F FC C3 E7 ; OR accumulator with memory (long) $E7C3FC.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $F8F9.w,X		; 9E F9 F8 ; Store zero to $F8F9.w,X [Reads: X Index]
	adc [$E1.b]		; 67 E1 ; Add with carry (long) [$E1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $0E6E9F.l,X		; 1F 9F 6E 0E ; Logical OR long $0E6E9F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($33.b),Y		; F1 33 ; Subtract with carry ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000029.l,X		; FF 29 00 00 ; Subtract with carry (long,X) $000029.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7EBD49.l,X		; FF 49 BD 7E ; Subtract with carry (long,X) $7EBD49.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $FD.b		; 45 FD ; Exclusive OR $FD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $0027.w,X		; 3E 27 00 ; Rotate left $0027.w,X [Reads: X Index] [Flags: ZNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $83.b		; 84 83 ; Store Y register to $83.b [Reads: Y Index]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	adc ($E1.b,X)		; 61 E1 ; Add with carry ($E1.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $89.b,S		; 83 89 ; Store accumulator (stack relative) $89.b,S [Reads: Accumulator, Stack Pointer]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $77.b,X		; 35 77 ; Logical AND $77.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $837F.w,X		; 1E 7F 83 ; Arithmetic shift left $837F.w,X [Reads: X Index] [Flags: ZNC]
	stx $0C01.w		; 8E 01 0C ; Store X register to $0C01.w [Reads: X Index]
	sbc $7EFFE6.l,X		; FF E6 FF 7E ; Subtract with carry (long,X) $7EFFE6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7BFFB3.l,X		; FF B3 FF 7B ; Subtract with carry (long,X) $7BFFB3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7F0000.l,X		; FF 00 00 7F ; Subtract with carry (long,X) $7F0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $830025.l,X		; FF 25 00 83 ; Subtract with carry (long,X) $830025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	sta $86.b,S		; 83 86 ; Store accumulator (stack relative) $86.b,S [Reads: Accumulator, Stack Pointer]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $F70800.l,X		; FF 00 08 F7 ; Subtract with carry (long,X) $F70800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FE0100.l,X		; FF 00 01 FE ; Subtract with carry (long,X) $FE0100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $850028.l,X		; FF 28 00 85 ; Subtract with carry (long,X) $850028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($88.b,X)		; 01 88 ; Logical OR ($88.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($3C.b,X)		; 41 3C ; Exclusive OR accumulator with memory ($3C.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $817E18.l,X		; FF 18 7E 81 ; Subtract with carry (long,X) $817E18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $DBC3.w,X		; BD C3 DB ; Load $DBC3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $EF.b,S		; E3 EF ; Subtract stack-relative $EF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc ($F7.b),Y		; F1 F7 ; Subtract with carry ($F7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jmp ($00FD.w,X)		; 7C FD 00 ; Jump indirect indexed to ($00FD.w,X) [Reads: X Index] [Flow: jump]
	sta ($42.b,X)		; 81 42 ; Store accumulator ($42.b,X) [Reads: Accumulator, X Index, Direct Page]
	bit $10.b		; 24 10 ; Test bits $10.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	jmp ($F87F.w,X)		; 7C 7F F8 ; Jump indirect indexed to ($F87F.w,X) [Reads: X Index] [Flow: jump]
	inc $FDF1.w,X		; FE F1 FD ; Increment memory $FDF1.w,X [Reads: X Index] [Flags: ZN]
	sbc $FB.b,S		; E3 FB ; Subtract stack-relative $FB.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sta ($E7.b,X)		; 81 E7 ; Store accumulator ($E7.b,X) [Reads: Accumulator, X Index, Direct Page]
	clc		; 18 ; Clear carry flag [Flags: C]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	bit $80BD.w,X		; 3C BD 80 ; Test bits $80BD.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $42.b		; 24 42 ; Test bits $42.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sbc $01FE00.l,X		; FF 00 FE 01 ; Subtract with carry (long,X) $01FE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $11DF11.l		; CF 11 DF 11 ; Compare accumulator (long) $11DF11.l [Reads: Accumulator] [Flags: ZNC]
	cmp [$19.b],Y		; D7 19 ; Compare accumulator (long indexed) [$19.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	dec $18.b,X		; D6 18 ; Decrement memory $18.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cmp ($1C.b)		; D2 1C ; Compare accumulator (indirect) ($1C.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	cmp ($1D.b)		; D2 1D ; Compare accumulator (indirect) ($1D.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $210220.l		; 22 20 02 21 ; Jump to subroutine long $210220.l [Writes: Stack Pointer] [Flow: call]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor $0C.b,S		; 43 0C ; Exclusive OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc [$10.b],Y		; 77 10 ; Add with carry (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $B0B7.w		; 8C B7 B0 ; Store Y register to $B0B7.w [Reads: Y Index]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and $C9DD.w		; 2D DD C9 ; Logical AND $C9DD.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $10EF.w,X		; 3E EF 10 ; Rotate left $10EF.w,X [Reads: X Index] [Flags: ZNC]
	sbc $8003.w,X		; FD 03 80 ; Subtract with carry $8003.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	jsl $D34500.l		; 22 00 45 D3 ; Jump to subroutine long $D34500.l [Writes: Stack Pointer] [Flow: call]
	trb $E305.w		; 1C 05 E3 ; Test and reset bits $E305.w [Reads: Accumulator] [Flags: Z]
	bit $14DB.w,X		; 3C DB 14 ; Test bits $14DB.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp [$18.b],Y		; D7 18 ; Compare accumulator (long indexed) [$18.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	eor $D3.b,S		; 43 D3 ; Exclusive OR accumulator with stack relative $D3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $2022.w		; 1C 22 20 ; Test and reset bits $2022.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3E.b,S),Y		; 13 3E ; OR accumulator (stack relative indirect indexed) ($3E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $743B3A.l,X		; 3F 3A 3B 74 ; AND accumulator with memory (long,X) $743B3A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$E9.b],Y		; 77 E9 ; Add with carry (long indexed) [$E9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $F9B7.w		; EE B7 F9 ; Increment $F9B7.w [Flags: ZN]
	jmp $C0BFE3.l		; 5C E3 BF C0 ; Jump long to $C0BFE3.l [Flow: jump]
	sbc $C4C000.l,X		; FF 00 C0 C4 ; Subtract with carry (long,X) $C4C000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $014300.l,X		; FF 00 43 01 ; Subtract with carry (long,X) $014300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FF01.w,X		; FE 01 FF ; Increment memory $FF01.w,X [Reads: X Index] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($6C.b,S),Y		; 93 6C ; Store accumulator (stack relative indirect indexed) ($6C.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	ora ($9F.b,X)		; 01 9F ; Logical OR ($9F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $93.b		; 45 93 ; Exclusive OR $93.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp ($F301.w)		; 6C 01 F3 ; Jump indirect to ($F301.w) [Flow: jump]
	tsb $0027.w		; 0C 27 00 ; Test and set bits $0027.w [Reads: Accumulator] [Flags: Z]
	sta $CA.b,S		; 83 CA ; Store accumulator (stack relative) $CA.b,S [Reads: Accumulator, Stack Pointer]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $1800.w,X		; 3C 00 18 ; Test bits $1800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc [$22.b]		; E7 22 ; Subtract with carry (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	and #$0F00.w		; 29 00 0F ; Logical AND #$0F00.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $30, $8A		; 30 8A ; Branch if minus to $30, $8A [Flow: branch]
	.db $10, $AA		; 10 AA ; Branch if plus to $10, $AA [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldx #$C8.b		; A2 C8 ; Load #$C8.b into X register [Writes: X Index] [Flags: ZN]
	jsl $00AA40.l		; 22 40 AA 00 ; Jump to subroutine long $00AA40.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	.db $10, $AA		; 10 AA ; Branch if plus to $10, $AA [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8028.w		; 20 28 80 ; Jump to subroutine at $8028.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $80, $A2		; 80 A2 ; Branch always to $80, $A2 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $21.b		; 84 21 ; Store Y register to $21.b [Reads: Y Index]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ldy #$28.b		; A0 28 ; Load #$28.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $453E.w,X		; FD 3E 45 ; Subtract with carry $453E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $433E.w,X		; DD 3E 43 ; Compare accumulator $433E.w,X [Reads: X Index] [Flags: ZNC]
	sbc $271E.w,X		; FD 1E 27 ; Subtract with carry $271E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF3700.l,X		; FF 00 37 FF ; Subtract with carry (long,X) $FF3700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $4E83.w		; 6D 83 4E ; Add $4E83.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DD00FF.l,X		; FF FF 00 DD ; Subtract with carry (long,X) $DD00FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $227FF7.l,X		; 7F F7 7F 22 ; Add long $227FF7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $830023.l,X		; 7F 23 00 83 ; Add long $830023.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	stz $DB7F.w,X		; 9E 7F DB ; Store zero to $DB7F.w,X [Reads: X Index]
	adc $807FF2.l,X		; 7F F2 7F 80 ; Add long $807FF2.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $03.b,S		; 83 03 ; Store accumulator (stack relative) $03.b,S [Reads: Accumulator, Stack Pointer]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $8D0022.l,X		; 7F 22 00 8D ; Add long $8D0022.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$A8.b],Y		; 57 A8 ; Exclusive OR accumulator with memory (long indexed) [$A8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $55.b,S		; 43 55 ; Exclusive OR accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	ora ($DD.b,X)		; 01 DD ; Logical OR ($DD.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $AA5545.l		; 22 45 55 AA ; Jump to subroutine long $AA5545.l [Writes: Stack Pointer] [Flow: call]
	ora ($77.b,X)		; 01 77 ; Logical OR ($77.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $59.b		; 05 59 ; Logical OR $59.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc [$2C.b]		; E7 2C ; Subtract with carry (long) [$2C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($3C.b,S),Y		; 73 3C ; Add with carry (stack relative indirect indexed) ($3C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($43.b,S),Y		; 33 43 ; AND accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $0739.w,X		; 5E 39 07 ; Logical shift right $0739.w,X [Reads: X Index] [Flags: ZNC]
	lda $BB73.w,X		; BD 73 BB ; Load $BB73.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$58.b],Y		; 77 58 ; Add with carry (long indexed) [$58.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$00.b]		; C7 00 ; Compare accumulator (long) [$00.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	cpy #$13.b		; C0 13 ; Compare #$13.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsr $431D.w		; 20 1D 43 ; Jump to subroutine at $431D.w [Writes: Stack Pointer] [Flow: call]
	sbc $EB.b,X		; F5 EB ; Subtract $EB.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta ($ED.b)		; 92 ED ; Store accumulator (indirect) ($ED.b) [Reads: Accumulator, Direct Page]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sta [$3A.b]		; 87 3A ; Store accumulator (long) [$3A.b] [Reads: Accumulator, Direct Page]
	cmp [$8B.b]		; C7 8B ; Compare accumulator (long) [$8B.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	lda [$C9.b],Y		; B7 C9 ; Load accumulator (long indexed) [$C9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$DD.b],Y		; D7 DD ; Compare accumulator (long indexed) [$DD.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	cmp ($A0.b,S),Y		; D3 A0 ; Compare accumulator (stack relative indirect indexed) ($A0.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($40.b)		; 12 40 ; OR accumulator with memory (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $6D20.w		; 20 20 6D ; Jump to subroutine at $6D20.w [Writes: Stack Pointer] [Flow: call]
	adc ($7C.b,S),Y		; 73 7C ; Add with carry (stack relative indirect indexed) ($7C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($74.b,S),Y		; 73 74 ; Add with carry (stack relative indirect indexed) ($74.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldx $A9.b		; A6 A9 ; Load $A9.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	cmp [$D8.b]		; C7 D8 ; Compare accumulator (long) [$D8.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta $8CB2.w		; 8D B2 8C ; Store accumulator to $8CB2.w [Reads: Accumulator]
	sbc ($1E.b,S),Y		; F3 1E ; Subtract with carry (stack relative indirect indexed) ($1E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc #$8022.w		; E9 22 80 ; Subtract #$8022.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	asl $50.b,X		; 16 50 ; Arithmetic shift left $50.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jsr $0040.w		; 20 40 00 ; Jump to subroutine at $0040.w [Writes: Stack Pointer] [Flow: call]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$D8.b]		; 07 D8 ; OR accumulator with memory (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	pea $EE11.w		; F4 11 EE ; Push absolute address $EE11.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $ECEB1C.l		; EF 1C EB EC ; Subtract with carry (long) $ECEB1C.l [Writes: Accumulator] [Flags: ZVNC]
	cop $F5.b		; 02 F5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $20C0F9.l		; 0F F9 C0 20 ; OR accumulator with memory (long) $20C0F9.l [Writes: Accumulator] [Flags: ZN]
	jsl $2EE000.l		; 22 00 E0 2E ; Jump to subroutine long $2EE000.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	brk $B1.b		; 00 B1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($DD.b)		; F2 DD ; Subtract with carry (indirect) ($DD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $BC83.w,X		; FE 83 BC ; Increment memory $BC83.w,X [Reads: X Index] [Flags: ZN]
	asl $D9.b		; 06 D9 ; Arithmetic shift left $D9.b [Reads: Direct Page] [Flags: ZNC]
	asl $67F1.w		; 0E F1 67 ; Arithmetic shift left $67F1.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $EC.b,S		; 63 EC ; Add with carry (stack relative) $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	ora ($D6.b),Y		; 11 D6 ; OR accumulator with memory ($D6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $4000.w		; 0C 00 40 ; Test and set bits $4000.w [Reads: Accumulator] [Flags: Z]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $3E35.w		; 0E 35 3E ; Arithmetic shift left $3E35.w [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($E8EF.w,X)		; FC EF E8 ; Jump to subroutine indirect indexed ($E8EF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp [$D8.b],Y		; D7 D8 ; Compare accumulator (long indexed) [$D8.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	lda $F4CBB0.l		; AF B0 CB F4 ; Load long $F4CBB0.l into accumulator [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpx $C0E0.w		; EC E0 C0 ; Compare $C0E0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $F4.b,S		; 83 F4 ; Store accumulator (stack relative) $F4.b,S [Reads: Accumulator, Stack Pointer]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	sbc $AA5500.l,X		; FF 00 55 AA ; Subtract with carry (long,X) $AA5500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	eor $44.b,X		; 55 44 ; Exclusive OR accumulator with memory $44.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $A3.b,S		; 03 A3 ; OR accumulator with stack relative $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $833FC3.l,X		; 5F C3 3F 83 ; Exclusive OR accumulator with memory (long,X) $833FC3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora $87.b		; 05 87 ; Logical OR $87.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora $27.b		; 05 27 ; Logical OR $27.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $42.b		; A5 42 ; Load $42.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	jsl $CE0000.l		; 22 00 00 CE ; Jump to subroutine long $CE0000.l [Writes: Stack Pointer] [Flow: call]
	jsl $180000.l		; 22 00 00 18 ; Jump to subroutine long $180000.l [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $110080.l,X		; 3F 80 00 11 ; AND accumulator with memory (long,X) $110080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stx $8020.w		; 8E 20 80 ; Store X register to $8020.w [Reads: X Index]
	ora ($A2.b,X)		; 01 A2 ; Logical OR ($A2.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $80, $28		; 80 28 ; Branch always to $80, $28 [Flow: branch]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora ($E8.b)		; 12 E8 ; OR accumulator with memory (indirect) ($E8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora ($14.b)		; 12 14 ; OR accumulator with memory (indirect) ($14.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	nop		; EA ; No operation
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $491E.w,X		; FD 1E 49 ; Subtract with carry $491E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $001E.w		; ED 1E 00 ; Subtract $001E.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	sbc $850028.l,X		; FF 28 00 85 ; Subtract with carry (long,X) $850028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($04.b)		; 72 04 ; Add with carry (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $AB.b		; 05 AB ; Logical OR $AB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $807FBF.l,X		; 7F BF 7F 80 ; Add long $807FBF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sta $8A.b,S		; 83 8A ; Store accumulator (stack relative) $8A.b,S [Reads: Accumulator, Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $070023.l,X		; 7F 23 00 07 ; Add long $070023.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $C20000.l,X		; 3F 00 00 C2 ; AND accumulator with memory (long,X) $C20000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $37C8.w,X		; 3D C8 37 ; AND accumulator with memory $37C8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$84.b		; C0 84 ; Compare #$84.b with Y register [Reads: Y Index] [Flags: ZNC]
	adc #$0401.w		; 69 01 04 ; Add #$0401.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	cpx $1B.b		; E4 1B ; Compare $1B.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $000022.l,X		; FF 22 00 00 ; Subtract with carry (long,X) $000022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF0024.l,X		; 3F 24 00 FF ; AND accumulator with memory (long,X) $FF0024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$33.b		; E0 33 ; Compare #$33.b with X register [Reads: X Index] [Flags: ZNC]
	cmp [$D9.b],Y		; D7 D9 ; Compare accumulator (long indexed) [$D9.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	lda $372FB3.l		; AF B3 2F 37 ; Load long $372FB3.l into accumulator [Writes: Accumulator] [Flags: ZN]
	lda $EDDFA7.l,X		; BF A7 DF ED ; Load long $EDDFA7.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $D52FED.l,X		; 9F ED 2F D5 ; Store accumulator (long,X) $D52FED.l,X [Reads: Accumulator, X Index]
	eor $21B7.w,X		; 5D B7 21 ; Exclusive OR accumulator with memory $21B7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $C7.b,S		; 43 C7 ; Exclusive OR accumulator with stack relative $C7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor [$0D.b]		; 47 0D ; Exclusive OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0705.w		; 0D 05 07 ; Logical OR $0705.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $0EBF00.l,X		; FF 00 BF 0E ; Subtract with carry (long,X) $0EBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $00CC04.l,X		; 9F 04 CC 00 ; Store accumulator (long,X) $00CC04.l,X [Reads: Accumulator, X Index]
	sbc [$A4.b]		; E7 A4 ; Subtract with carry (long) [$A4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($FB98.w,X)		; FC 98 FB ; Jump to subroutine indirect indexed ($FB98.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $90, $F7		; 90 F7 ; Branch if carry clear to $90, $F7 [Flow: branch]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	ror $3B74.w		; 6E 74 3B ; Rotate right $3B74.w [Flags: ZNC]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sta [$8C.b]		; 87 8C ; Store accumulator (long) [$8C.b] [Reads: Accumulator, Direct Page]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sbc $CEFF80.l,X		; FF 80 FF CE ; Subtract with carry (long,X) $CEFF80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	mvp $DE,$FF		; 44 FF DE ; Move block positive $DE,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$3E.b		; E0 3E ; Compare #$3E.b with X register [Reads: X Index] [Flags: ZNC]
	stz $98FF.w,X		; 9E FF 98 ; Store zero to $98FF.w,X [Reads: X Index]
	jsr ($FB80.w,X)		; FC 80 FB ; Jump to subroutine indirect indexed ($FB80.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $82, $80, $CE		; 82 80 CE ; Branch always long to $82, $80, $CE [Flow: branch]
	dec $9EDE.w,X		; DE DE 9E ; Decrement memory $9EDE.w,X [Reads: X Index] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $84.b,S		; 83 84 ; Store accumulator (stack relative) $84.b,S [Reads: Accumulator, Stack Pointer]
	jmp.w [$89DF]		; DC DF 89 ; Jump long indirect [$89DF] [Flow: jump]
	stx $7D72.w		; 8E 72 7D ; Store X register to $7D72.w [Reads: X Index]
	sta $7FE3.w,X		; 9D E3 7F ; Store accumulator to $7FE3.w,X [Reads: Accumulator, X Index]
	sty $3FFF.w		; 8C FF 3F ; Store Y register to $3FFF.w [Reads: Y Index]
	inc $FF71.w,X		; FE 71 FF ; Increment memory $FF71.w,X [Reads: X Index] [Flags: ZN]
	sbc $807020.l,X		; FF 20 70 80 ; Subtract with carry (long,X) $807020.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0BFF71.l,X		; 3F 71 FF 0B ; AND accumulator with memory (long,X) $0BFF71.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $37.b,S		; 03 37 ; OR accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $E3FFE0.l		; 0F E0 FF E3 ; OR accumulator with memory (long) $E3FFE0.l [Writes: Accumulator] [Flags: ZN]
	trb $A0FF.w		; 1C FF A0 ; Test and reset bits $A0FF.w [Reads: Accumulator] [Flags: Z]
	cmp $B6DFB4.l,X		; DF B4 DF B6 ; Compare accumulator (long,X) $B6DFB4.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$B4.b		; A0 B4 ; Load #$B4.b into Y register [Writes: Y Index] [Flags: ZN]
	ldx $22.b,Y		; B6 22 ; Load X register $22.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	sbc $FF7016.l,X		; FF 16 70 FF ; Subtract with carry (long,X) $FF7016.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7CFF.w,X		; 3C FF 7C ; Test bits $7CFF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inc $FD78.w,X		; FE 78 FD ; Increment memory $FD78.w,X [Reads: X Index] [Flags: ZN]
	adc $00FD.w,Y		; 79 FD 00 ; Add $00FD.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $3C0070.l,X		; FF 70 00 3C ; Subtract with carry (long,X) $3C0070.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($7A79.w,X)		; 7C 79 7A ; Jump indirect indexed to ($7A79.w,X) [Reads: X Index] [Flow: jump]
	cop $DF.b		; 02 DF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $43.b,Y		; B6 43 ; Load X register $43.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	dec $1131.w,X		; DE 31 11 ; Decrement memory $1131.w,X [Reads: X Index] [Flags: ZN]
	cmp $06FF34.l,X		; DF 34 FF 06 ; Compare accumulator (long,X) $06FF34.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	and $01C220.l,X		; 3F 20 C2 01 ; AND accumulator with memory (long,X) $01C220.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ora ($B6.b,X)		; 01 B6 ; Logical OR ($B6.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	bit $06.b,X		; 34 06 ; Test bits $06.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cpy #$3C.b		; C0 3C ; Compare #$3C.b with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $45.b		; 04 45 ; Test and set bits $45.b [Reads: Accumulator] [Flags: Z]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $0004FF.l		; 22 FF 04 00 ; Jump to subroutine long $0004FF.l [Writes: Stack Pointer] [Flow: call]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0025FF.l,X		; 7F FF 25 00 ; Add long $0025FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $FF.b,X		; 16 FF ; Arithmetic shift left $FF.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$D8.b],Y		; D7 D8 ; Compare accumulator (long indexed) [$D8.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	lda $302FB0.l		; AF B0 2F 30 ; Load long $302FB0.l into accumulator [Writes: Accumulator] [Flags: ZN]
	lda $E8D7A0.l,X		; BF A0 D7 E8 ; Load long $E8D7A0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta [$E8.b],Y		; 97 E8 ; Store accumulator (long indexed) [$E8.b],Y [Reads: Accumulator, Direct Page, Y Index]
	and [$D8.b]		; 27 D8 ; AND accumulator with memory (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$B8.b],Y		; 57 B8 ; Exclusive OR accumulator with memory (long indexed) [$B8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $C040.w		; 20 40 C0 ; Jump to subroutine at $C040.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta [$48.b]		; 87 48 ; Store accumulator (long) [$48.b] [Reads: Accumulator, Direct Page]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $8F		; 70 8F ; Branch if overflow set to $70, $8F [Flow: branch]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8070.w		; 20 70 80 ; Jump to subroutine at $8070.w [Writes: Stack Pointer] [Flow: call]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta [$60.b]		; 87 60 ; Store accumulator (long) [$60.b] [Reads: Accumulator, Direct Page]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $7C.b,S		; 83 7C ; Store accumulator (stack relative) $7C.b,S [Reads: Accumulator, Stack Pointer]
	inc $FC01.w,X		; FE 01 FC ; Increment memory $FC01.w,X [Reads: X Index] [Flags: ZN]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $70BF77.l,X		; 9F 77 BF 70 ; Store accumulator (long,X) $70BF77.l,X [Reads: Accumulator, X Index]
	jsr ($E777.w,X)		; FC 77 E7 ; Jump to subroutine indirect indexed ($E777.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc [$78.b]		; E7 78 ; Subtract with carry (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda [$7B.b],Y		; B7 7B ; Load accumulator (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $10EF31.l		; CF 31 EF 10 ; Compare accumulator (long) $10EF31.l [Reads: Accumulator] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc [$BB.b],Y		; 77 BB ; Add with carry (long indexed) [$BB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$F9.b],Y		; 77 F9 ; Add with carry (long indexed) [$F9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$43.b],Y		; 77 43 ; Add with carry (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $7B.b		; E4 7B ; Compare $7B.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $B6.b		; 05 B6 ; Logical OR $B6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $38C7.w,Y		; 79 C7 38 ; Add $38C7.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	ora [$27.b],Y		; 17 27 ; OR accumulator with memory (long indexed) [$27.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$78.b],Y		; 97 78 ; Store accumulator (long indexed) [$78.b],Y [Reads: Accumulator, Direct Page, Y Index]
	lda [$78.b],Y		; B7 78 ; Load accumulator (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$44.b],Y		; F7 44 ; Subtract with carry (long indexed) [$44.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc [$05.b]		; E7 05 ; Subtract with carry (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda [$78.b],Y		; B7 78 ; Load accumulator (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpy $3B.b		; C4 3B ; Compare $3B.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	ora [$27.b],Y		; 17 27 ; OR accumulator with memory (long indexed) [$27.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $BC75.w,X		; 9E 75 BC ; Store zero to $BC75.w,X [Reads: X Index]
	adc ($F9.b,S),Y		; 73 F9 ; Add with carry (stack relative indirect indexed) ($F9.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$E7.b],Y		; 77 E7 ; Add with carry (long indexed) [$E7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sbc [$79.b]		; E7 79 ; Subtract with carry (long) [$79.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda [$7B.b],Y		; B7 7B ; Load accumulator (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $10EF32.l		; CF 32 EF 10 ; Compare accumulator (long) $10EF32.l [Reads: Accumulator] [Flags: ZNC]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $85.b		; 02 85 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$01.b],Y		; 37 01 ; AND accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	mvp $E7,$78		; 44 78 E7 ; Move block positive $E7,$78 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sta $42.b		; 85 42 ; Store accumulator to $42.b [Reads: Accumulator]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $1F.b		; 46 1F ; Logical shift right $1F.b [Reads: Direct Page] [Flags: ZNC]
	ora [$1F.b],Y		; 17 1F ; OR accumulator with memory (long indexed) [$1F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $5C		; 10 5C ; Branch if plus to $10, $5C [Flow: branch]
	ora [$47.b],Y		; 17 47 ; OR accumulator with memory (long indexed) [$47.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda [$38.b]		; A7 38 ; Load accumulator (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc [$7B.b]		; 67 7B ; Add with carry (long) [$7B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F0CFF1.l		; EF F1 CF F0 ; Subtract with carry (long) $F0CFF1.l [Writes: Accumulator] [Flags: ZVNC]
	sbc [$E0.b]		; E7 E0 ; Subtract with carry (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$E3.b]		; E7 E3 ; Subtract with carry (long) [$E3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$83.b		; C0 83 ; Compare #$83.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc [$90.b],Y		; F7 90 ; Subtract with carry (long indexed) [$90.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$14.b],Y		; F7 14 ; Subtract with carry (long indexed) [$14.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	nop		; EA ; No operation
	sbc $EDC4.w,X		; FD C4 ED ; Subtract with carry $EDC4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp.w [$FF10]		; DC 10 FF ; Jump long indirect [$FF10] [Flow: jump]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	jsr ($8803.w,X)		; FC 03 88 ; Jump to subroutine indirect indexed ($8803.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx $D2.b		; E4 D2 ; Compare $D2.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	and ($63.b)		; 32 63 ; AND accumulator with memory (indirect) ($63.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FB		; 80 FB ; Branch always to $80, $FB [Flow: branch]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $F0FD.w		; F4 FD F0 ; Push absolute address $F0FD.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $FC00.w,X		; FD 00 FC ; Subtract with carry $FC00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $639C88.l,X		; FF 88 9C 63 ; Subtract with carry (long,X) $639C88.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $04.b		; 84 04 ; Store Y register to $04.b [Reads: Y Index]
	sbc ($F2.b)		; F2 F2 ; Subtract with carry (indirect) ($F2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cop $9B.b		; 02 9B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $3F3F.w		; 0D 3F 3F ; Logical OR $3F3F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and ($31.b),Y		; 31 31 ; AND accumulator with memory ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $23.b,S		; 23 23 ; AND accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and [$27.b]		; 27 27 ; AND accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $3C2E.w		; 2E 2E 3C ; Rotate left $3C2E.w [Flags: ZNC]
	bit $7F00.w,X		; 3C 00 7F ; Test bits $7F00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	rol $40.b		; 26 40 ; Rotate left $40.b [Reads: Direct Page] [Flags: ZNC]
	asl $BF.b		; 06 BF ; Arithmetic shift left $BF.b [Reads: Direct Page] [Flags: ZNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F9E.w,X		; 1E 9E 1F ; Arithmetic shift left $1F9E.w,X [Reads: X Index] [Flags: ZNC]
	sta $BF3F45.l,X		; 9F 45 3F BF ; Store accumulator (long,X) $BF3F45.l,X [Reads: Accumulator, X Index]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $617F00.l,X		; 9F 00 7F 61 ; Store accumulator (long,X) $617F00.l,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $600040.l		; 22 40 00 60 ; Jump to subroutine long $600040.l [Writes: Stack Pointer] [Flow: call]
	lsr $00FF.w		; 4E FF 00 ; Logical shift right $00FF.w [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $00FF10.l		; EF 10 FF 00 ; Subtract with carry (long) $00FF10.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $7FC07F.l,X		; FF 7F C0 7F ; Subtract with carry (long,X) $7FC07F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $010022.l,X		; FF 22 00 01 ; Subtract with carry (long,X) $010022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0025FF.l,X		; FF FF 25 00 ; Subtract with carry (long,X) $0025FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $80057F.l,X		; FF 7F 05 80 ; Subtract with carry (long,X) $80057F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $4300FF.l,X		; 3F FF 00 43 ; AND accumulator with memory (long,X) $4300FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $C0003F.l,X		; FF 3F 00 C0 ; Subtract with carry (long,X) $C0003F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $7F0000.l		; 22 00 00 7F ; Jump to subroutine long $7F0000.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($1C.b,S),Y		; 13 1C ; OR accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor ($1C.b,S),Y		; 53 1C ; XOR accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $1C.b,S		; 43 1C ; Exclusive OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda $3C.b,S		; A3 3C ; Load accumulator (stack relative) $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $7C.b,S		; 63 7C ; Add with carry (stack relative) $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	inc $F9.b		; E6 F9 ; Increment $F9.b [Reads: Direct Page] [Flags: ZN]
	cpy $23F3.w		; CC F3 23 ; Compare $23F3.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$13.b		; E0 13 ; Compare #$13.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $3BC631.l		; CF 31 C6 3B ; Compare accumulator (long) $3BC631.l [Reads: Accumulator] [Flags: ZNC]
	stz $BB6F.w		; 9C 6F BB ; Store zero to $BB6F.w
	jmp $69D834.l		; 5C 34 D8 69 ; Jump long to $69D834.l [Flow: jump]
	lda ($F3.b),Y		; B1 F3 ; Load accumulator ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $0C0023.l,X		; 3F 23 00 0C ; AND accumulator with memory (long,X) $0C0023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $3F00.w		; 0C 00 3F ; Test and set bits $3F00.w [Reads: Accumulator] [Flags: Z]
	cpy #$1F.b		; C0 1F ; Compare #$1F.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$65.b		; E0 65 ; Compare #$65.b with X register [Reads: X Index] [Flags: ZNC]
	stx $1E.b		; 86 1E ; Store X register to $1E.b [Reads: X Index]
	ora $FF26FE.l,X		; 1F FE 26 FF ; Logical OR long $FF26FE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FC3B00.l,X		; FF 00 3B FC ; Subtract with carry (long,X) $FC3B00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $E4FE.w,X		; 7D FE E4 ; Add $E4FE.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	adc [$00.b]		; 67 00 ; Add with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta $75.b,S		; 83 75 ; Store accumulator (stack relative) $75.b,S [Reads: Accumulator, Stack Pointer]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$0702.w		; 89 02 07 ; Test bits #$0702.w with accumulator [Reads: Accumulator] [Flags: Z]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	asl $C6E1.w,X		; 1E E1 C6 ; Arithmetic shift left $C6E1.w,X [Reads: X Index] [Flags: ZNC]
	sbc $FDE2.w,Y		; F9 E2 FD ; Subtract with carry $FDE2.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta [$88.b]		; 87 88 ; Store accumulator (long) [$88.b] [Reads: Accumulator, Direct Page]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $4301.w,X		; FE 01 43 ; Increment memory $4301.w,X [Reads: X Index] [Flags: ZN]
	jsr ($2703.w,X)		; FC 03 27 ; Jump to subroutine indirect indexed ($2703.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $769FA0.l,X		; DF A0 9F 76 ; Compare accumulator (long,X) $769FA0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	and $0024EC.l,X		; 3F EC 24 00 ; AND accumulator with memory (long,X) $0024EC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $A0.b		; 02 A0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $EC.b,X		; 76 EC ; Rotate right $EC.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($2703.w,X)		; FC 03 27 ; Jump to subroutine indirect indexed ($2703.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $A3		; 10 A3 ; Branch if plus to $10, $A3 [Flow: branch]
	cmp $EA9FEA.l,X		; DF EA 9F EA ; Compare accumulator (long,X) $EA9FEA.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	dec $5F.b,X		; D6 5F ; Decrement memory $5F.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	ldx $21.b,Y		; B6 21 ; Load X register $21.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	eor $C7.b,S		; 43 C7 ; Exclusive OR accumulator with stack relative $C7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $0A.b,S		; 43 0A ; Exclusive OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	mvp $60,$FF		; 44 FF 60 ; Move block positive $60,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $40.b		; 04 40 ; Test and set bits $40.b [Reads: Accumulator] [Flags: Z]
	cmp $20BF00.l,X		; DF 00 BF 20 ; Compare accumulator (long,X) $20BF00.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora #$A07F.w		; 09 7F A0 ; Logical OR #$A07F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $0040.w		; 20 40 00 ; Jump to subroutine at $0040.w [Writes: Stack Pointer] [Flow: call]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$0048.w		; 89 48 00 ; Test bits #$0048.w with accumulator [Reads: Accumulator] [Flags: Z]
	ora $FD.b		; 05 FD ; Logical OR $FD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $84F0FF.l,X		; 7F FF F0 84 ; Add long $84F0FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7F.b,S		; 23 7F ; AND accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $89		; F0 89 ; Branch if equal to $F0, $89 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $779FA0.l,X		; DF A0 9F 77 ; Compare accumulator (long,X) $779FA0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	and $7085EE.l,X		; 3F EE 85 70 ; AND accumulator with memory (long,X) $7085EE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$EE.b],Y		; 77 EE ; Add with carry (long indexed) [$EE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	pei ($DA.b)		; D4 DA ; Push effective indirect address ($DA.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	ldy $2C.b,X		; B4 2C ; Load Y register $2C.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	bit $B4.b,X		; 34 B4 ; Test bits $B4.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ldy $EED6.w		; AC D6 EE ; Load $EED6.w into Y register [Writes: Y Index] [Flags: ZN]
	sta [$EF.b],Y		; 97 EF ; Store accumulator (long indexed) [$EF.b],Y [Reads: Accumulator, Direct Page, Y Index]
	and $B75FD7.l		; 2F D7 5F B7 ; AND accumulator with memory (long) $B75FD7.l [Writes: Accumulator] [Flags: ZN]
	and ($43.b,X)		; 21 43 ; Logical AND ($43.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp $43.b,S		; C3 43 ; Compare accumulator (stack relative) $43.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora $003F00.l,X		; 1F 00 3F 00 ; Logical OR long $003F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	lsr $7F1E.w,X		; 5E 1E 7F ; Logical shift right $7F1E.w,X [Reads: X Index] [Flags: ZNC]
	ora $24077F.l		; 0F 7F 07 24 ; OR accumulator with memory (long) $24077F.l [Writes: Accumulator] [Flags: ZN]
	sbc $80E101.l,X		; FF 01 E1 80 ; Subtract with carry (long,X) $80E101.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	and $630A03.l		; 2F 03 0A 63 ; AND accumulator with memory (long) $630A03.l [Writes: Accumulator] [Flags: ZN]
	stz $7FBF.w		; 9C BF 7F ; Store zero to $7FBF.w
	ora $07078F.l		; 0F 8F 07 07 ; OR accumulator with memory (long) $07078F.l [Writes: Accumulator] [Flags: ZN]
	jsr $8070.w		; 20 70 80 ; Jump to subroutine at $8070.w [Writes: Stack Pointer] [Flow: call]
	jsl $700100.l		; 22 00 01 70 ; Jump to subroutine long $700100.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta [$60.b]		; 87 60 ; Store accumulator (long) [$60.b] [Reads: Accumulator, Direct Page]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $AC83E0.l,X		; 1F E0 83 AC ; Logical OR long $AC83E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta $C0.b,S		; 83 C0 ; Store accumulator (stack relative) $C0.b,S [Reads: Accumulator, Stack Pointer]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $BD31.w		; 2E 31 BD ; Rotate left $BD31.w [Flags: ZNC]
	lda $D5.b,S		; A3 D5 ; Load accumulator (stack relative) $D5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sta $EB.b,X		; 95 EB ; Store accumulator to $EB.b,X [Reads: Accumulator, X Index]
	bit $DB.b		; 24 DB ; Test bits $DB.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	mvn $83,$BB		; 54 BB 83 ; Move block negative $83,$BB [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($80.b)		; 12 80 ; OR accumulator with memory (indirect) ($80.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $9EC040.l,X		; 7F 40 C0 9E ; Add long $9EC040.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $3F77.w,X		; 9E 77 3F ; Store zero to $3F77.w,X [Reads: X Index]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $AD6F5D.l,X		; 5F 5D 6F AD ; Exclusive OR accumulator with memory (long,X) $AD6F5D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda [$71.b],Y		; B7 71 ; Load accumulator (long indexed) [$71.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $613F00.l,X		; FF 00 3F 61 ; Subtract with carry (long,X) $613F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $400080.l		; 22 80 00 40 ; Jump to subroutine long $400080.l [Writes: Stack Pointer] [Flow: call]
	sty $00D7.w		; 8C D7 00 ; Store Y register to $00D7.w [Reads: Y Index]
	asl $E0.b		; 06 E0 ; Arithmetic shift left $E0.b [Reads: Direct Page] [Flags: ZNC]
	ora $203FDC.l,X		; 1F DC 3F 20 ; Logical OR long $203FDC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit #$00F0.w		; 89 F0 00 ; Test bits #$00F0.w with accumulator [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	inc $7C01.w,X		; FE 01 7C ; Increment memory $7C01.w,X [Reads: X Index] [Flags: ZN]
	sta $FC.b,S		; 83 FC ; Store accumulator (stack relative) $FC.b,S [Reads: Accumulator, Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FFC3.w		; 2C C3 FF ; Test bits $FFC3.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cpy $93FF.w		; CC FF 93 ; Compare $93FF.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc ($54.b,S),Y		; F3 54 ; Subtract with carry (stack relative indirect indexed) ($54.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $5A		; 70 5A ; Branch if overflow set to $70, $5A [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy $85FC.w		; CC FC 85 ; Compare $85FC.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $FF03.w,X		; FD 03 FF ; Subtract with carry $FF03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $878F.w		; 0C 8F 87 ; Test and set bits $878F.w [Reads: Accumulator] [Flags: Z]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $D9FF3E.l,X		; FF 3E FF D9 ; Subtract with carry (long,X) $D9FF3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3C3C.w,Y		; D9 3C 3C ; Compare accumulator $3C3C.w,Y [Reads: Y Index] [Flags: ZNC]
	.db $62, $7E, $D9		; 62 7E D9 ; Push effective relative address $62, $7E, $D9 [Writes: Stack Pointer]
	sbc [$BC.b]		; E7 BC ; Subtract with carry (long) [$BC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $7F.b,S		; C3 7F ; Compare accumulator (stack relative) $7F.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $81.b,S		; C3 81 ; Compare accumulator (stack relative) $81.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	jsl $3F0300.l		; 22 00 03 3F ; Jump to subroutine long $3F0300.l [Writes: Stack Pointer] [Flow: call]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $83		; 80 83 ; Branch always to $80, $83 [Flow: branch]
	jsr ($0700.w,X)		; FC 00 07 ; Jump to subroutine indirect indexed ($0700.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$FB.b]		; 07 FB ; OR accumulator with memory (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$E6.b]		; 07 E6 ; OR accumulator with memory (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3CDB.w,Y		; 19 DB 3C ; OR accumulator with memory $3CDB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $F300FF.l		; 0F FF 00 F3 ; OR accumulator with memory (long) $F300FF.l [Writes: Accumulator] [Flags: ZN]
	tsb $C639.w		; 0C 39 C6 ; Test and set bits $C639.w [Reads: Accumulator] [Flags: Z]
	ora $0FE2.w,X		; 1D E2 0F ; OR accumulator with memory $0FE2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta ($FE.b,X)		; 81 FE ; Store accumulator ($FE.b,X) [Reads: Accumulator, X Index, Direct Page]
	sbc ($7E.b),Y		; F1 7E ; Subtract with carry ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$2C.b		; E0 2C ; Compare #$2C.b with X register [Reads: X Index] [Flags: ZNC]
	asl $1C15.w,X		; 1E 15 1C ; Arithmetic shift left $1C15.w,X [Reads: X Index] [Flags: ZNC]
	ora ($59.b,S),Y		; 13 59 ; OR accumulator (stack relative indirect indexed) ($59.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$47.b],Y		; 17 47 ; OR accumulator with memory (long indexed) [$47.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	lda [$39.b]		; A7 39 ; Load accumulator (long) [$39.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc [$7B.b]		; 67 7B ; Add with carry (long) [$7B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F2CFF3.l		; EF F3 CF F2 ; Subtract with carry (long) $F2CFF3.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $E3.b		; E5 E3 ; Subtract $E3.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$E2.b]		; E7 E2 ; Subtract with carry (long) [$E2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp ($83.b,X)		; C1 83 ; Compare accumulator ($83.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $80FFA0.l,X		; 7F A0 FF 80 ; Add long $80FFA0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $61FE20.l,X		; FF 20 FE 61 ; Subtract with carry (long,X) $61FE20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($4D.b)		; F2 4D ; Subtract with carry (indirect) ($4D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	jsr ($9903.w,X)		; FC 03 99 ; Jump to subroutine indirect indexed ($9903.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc [$80.b]		; 67 80 ; Add with carry (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsl $FE0500.l		; 22 00 05 FE ; Jump to subroutine long $FE0500.l [Writes: Stack Pointer] [Flow: call]
	ora ($F7.b,X)		; 01 F7 ; Logical OR ($F7.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $EF.b		; E6 EF ; Increment $EF.b [Reads: Direct Page] [Flags: ZN]
	cmp $00FF49.l		; CF 49 FF 00 ; Compare accumulator (long) $00FF49.l [Reads: Accumulator] [Flags: ZNC]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $D0, $24		; D0 24 ; Branch if not equal to $D0, $24 [Flow: branch]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $19FEC0.l,X		; 7F C0 FE 19 ; Add long $19FEC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FBB1.w,X		; FE B1 FB ; Increment memory $FBB1.w,X [Reads: X Index] [Flags: ZN]
	tsb $F3.b		; 04 F3 ; Test and set bits $F3.b [Reads: Accumulator] [Flags: Z]
	tsb $0DF2.w		; 0C F2 0D ; Test and set bits $0DF2.w [Reads: Accumulator] [Flags: Z]
	jsr ($E503.w,X)		; FC 03 E5 ; Jump to subroutine indirect indexed ($E503.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpy #$18.b		; C0 18 ; Compare #$18.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $24		; 30 24 ; Branch if minus to $30, $24 [Flow: branch]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $4417.w,Y		; 59 17 44 ; Exclusive OR accumulator with memory $4417.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $3B.b		; A4 3B ; Load $3B.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	ror $79.b		; 66 79 ; Rotate right $79.b [Reads: Direct Page] [Flags: ZNC]
	sbc [$F8.b]		; E7 F8 ; Subtract with carry (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpy $23F3.w		; CC F3 23 ; Compare $23F3.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$83.b		; E0 83 ; Compare #$83.b with X register [Reads: X Index] [Flags: ZNC]
	mvn $E0,$02		; 54 02 E0 ; Move block negative $E0,$02 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and ($3F.b,X)		; 21 3F ; Logical AND ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $5F.b,S		; 03 5F ; OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $6D.b,S		; 43 6D ; Exclusive OR accumulator with stack relative $6D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc ($F3.b,X)		; 61 F3 ; Add with carry ($F3.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($D7.b,S),Y		; F3 D7 ; Subtract with carry (stack relative indirect indexed) ($D7.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $BDD64A.l,X		; DF 4A D6 BD ; Compare accumulator (long,X) $BDD64A.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $7F.b,S		; 63 7F ; Add with carry (stack relative) $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	ldy #$92.b		; A0 92 ; Load #$92.b into Y register [Writes: Y Index] [Flags: ZN]
	tsb M7Y.w		; 0C 20 21 ; Test and set bits M7Y.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $37.b		; 04 37 ; Test and set bits $37.b [Reads: Accumulator] [Flags: Z]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: ZNC]
	and [$07.b],Y		; 37 07 ; AND accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $33.b		; 04 33 ; Test and set bits $33.b [Reads: Accumulator] [Flags: Z]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr ($23FC.w,X)		; FC FC 23 ; Jump to subroutine indirect indexed ($23FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	trb $1AFC.w		; 1C FC 1A ; Test and reset bits $1AFC.w [Reads: Accumulator] [Flags: Z]
	ora $7E7D.w,X		; 1D 7D 7E ; OR accumulator with memory $7E7D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda ($32.b,S),Y		; B3 32 ; Load accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	trb $08E7.w		; 1C E7 08 ; Test and reset bits $08E7.w [Reads: Accumulator] [Flags: Z]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $DEDD.w		; 0C DD DE ; Test and set bits $DEDD.w [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	jmp $1020.w		; 4C 20 10 ; Jump to $1020.w [Flow: jump]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	ora $1817.w,Y		; 19 17 18 ; OR accumulator with memory $1817.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	mvp $23,$02		; 44 02 23 ; Move block positive $23,$02 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$83.b		; E0 83 ; Compare #$83.b with X register [Reads: X Index] [Flags: ZNC]
	mvn $05,$02		; 54 02 05 ; Move block negative $05,$02 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $01FF.w,Y		; 39 FF 01 ; AND accumulator with memory $01FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $43738C.l,X		; FF 8C 73 43 ; Subtract with carry (long,X) $43738C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E30500.l,X		; FF 00 05 E3 ; Subtract with carry (long,X) $E30500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $C33C.w		; 1C 3C C3 ; Test and reset bits $C33C.w [Reads: Accumulator] [Flags: Z]
	sta $27E7.w,Y		; 99 E7 27 ; Store accumulator to $27E7.w,Y [Reads: Accumulator, Y Index]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$63.b		; A2 63 ; Load #$63.b into X register [Writes: X Index] [Flags: ZN]
	eor $CD.b,X		; 55 CD ; Exclusive OR accumulator with memory $CD.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sta [$3D.b],Y		; 97 3D ; Store accumulator (long indexed) [$3D.b],Y [Reads: Accumulator, Direct Page, Y Index]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	rol $36BD.w		; 2E BD 36 ; Rotate left $36BD.w [Flags: ZNC]
	lda $1FBF38.l,X		; BF 38 BF 1F ; Load long $1FBF38.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $60221C.l,X		; 9F 1C 22 60 ; Store accumulator (long,X) $60221C.l,X [Reads: Accumulator, X Index]
	and $40.b,S		; 23 40 ; AND accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $60		; 10 60 ; Branch if plus to $10, $60 [Flow: branch]
	and $1CC3.w,X		; 3D C3 1C ; AND accumulator with memory $1CC3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $9E.b,S		; E3 9E ; Subtract stack-relative $9E.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc ($9B.b,X)		; E1 9B ; Subtract with carry ($9B.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $BB.b		; E4 BB ; Compare $BB.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy $3A.b		; C4 3A ; Compare $3A.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	cmp $1C.b		; C5 1C ; Compare $1C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc $DD.b,S		; E3 DD ; Subtract stack-relative $DD.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc $27.b,S		; E3 27 ; Subtract stack-relative $27.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $E7.b		; E6 E7 ; Increment $E7.b [Reads: Direct Page] [Flags: ZN]
	jmp.w [$20FF]		; DC FF 20 ; Jump long indirect [$20FF] [Flow: jump]
	sbc $64FF78.l,X		; FF 78 FF 64 ; Subtract with carry (long,X) $64FF78.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$52.b]		; C7 52 ; Compare accumulator (long) [$52.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	cmp $A9.b,S		; C3 A9 ; Compare accumulator (stack relative) $A9.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc ($B3.b,X)		; E1 B3 ; Subtract with carry ($B3.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($18.b,S),Y		; F3 18 ; Subtract with carry (stack relative indirect indexed) ($18.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $380900.l		; 22 00 09 38 ; Jump to subroutine long $380900.l [Writes: Stack Pointer] [Flow: call]
	bit $0C1E.w,X		; 3C 1E 0C ; Test bits $0C1E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ldx $F7.b,Y		; B6 F7 ; Load X register $F7.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	lda $5BEE.w		; AD EE 5B ; Load $5BEE.w into accumulator [Writes: Accumulator] [Flags: ZN]
	jmp.w [$F743]		; DC 43 F7 ; Jump long indirect [$F743] [Flow: jump]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: ZNC]
	cmp ($5C.b,S),Y		; D3 5C ; Compare accumulator (stack relative indirect indexed) ($5C.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	bit #$C5CE.w		; 89 CE C5 ; Test bits #$C5CE.w with accumulator [Reads: Accumulator] [Flags: Z]
	inc $08.b		; E6 08 ; Increment $08.b [Reads: Direct Page] [Flags: ZN]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1830.w		; 20 30 18 ; Jump to subroutine at $1830.w [Writes: Stack Pointer] [Flow: call]
	stz $DF5F.w		; 9C 5F DF ; Store zero to $DF5F.w
	eor $C72FEF.l,X		; 5F EF 2F C7 ; Exclusive OR accumulator with memory (long,X) $C72FEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$80.b],Y		; 37 80 ; AND accumulator with memory (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $FCFFF0.l,X		; FF F0 FF FC ; Subtract with carry (long,X) $FCFFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $102020.l,X		; FF 20 20 10 ; Subtract with carry (long,X) $102020.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $CE311E.l		; EF 1E 31 CE ; Subtract with carry (long) $CE311E.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $FEF1F0.l		; CF F0 F1 FE ; Compare accumulator (long) $FEF1F0.l [Reads: Accumulator] [Flags: ZNC]
	adc $017C.w,X		; 7D 7C 01 ; Add $017C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $82, $43, $01		; 82 43 01 ; Branch always long to $82, $43, $01 [Flow: branch]
	inc $0023.w,X		; FE 23 00 ; Increment memory $0023.w,X [Reads: X Index] [Flags: ZN]
	ora $82.b,S		; 03 82 ; OR accumulator with stack relative $82.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp ($0000.w,X)		; 7C 00 00 ; Jump indirect indexed to ($0000.w,X) [Reads: X Index] [Flow: jump]
	sbc $050023.l,X		; FF 23 00 05 ; Subtract with carry (long,X) $050023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($CCFC.w,X)		; FC FC CC ; Jump to subroutine indirect indexed ($CCFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy $8484.w		; CC 84 84 ; Compare $8484.w with Y register [Reads: Y Index] [Flags: ZNC]
	and $04.b		; 25 04 ; Logical AND $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $0225.w,X		; FE 25 02 ; Increment memory $0225.w,X [Reads: X Index] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	jsr $2120.w		; 20 20 21 ; Jump to subroutine at $2120.w [Writes: Stack Pointer] [Flow: call]
	and ($23.b,X)		; 21 23 ; Logical AND ($23.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $3F.b,S		; 23 3F ; AND accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $250023.l,X		; 3F 23 00 25 ; AND accumulator with memory (long,X) $250023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $44.b		; 24 44 ; Test bits $44.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	mvp $84,$84		; 44 84 84 ; Move block positive $84,$84 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $04.b,S		; 23 04 ; AND accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr ($0023.w,X)		; FC 23 00 ; Jump to subroutine indirect indexed ($0023.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $02.b		; 25 02 ; Logical AND $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$2B.b		; E0 2B ; Compare #$2B.b with X register [Reads: X Index] [Flags: ZNC]
	inc $E200.w,X		; FE 00 E2 ; Increment memory $E200.w,X [Reads: X Index] [Flags: ZN]
	sbc ($1C.b,X)		; E1 1C ; Subtract with carry ($1C.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C605.w,Y		; F9 05 C6 ; Subtract with carry $C605.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sta $19.b,S		; 83 19 ; Store accumulator (stack relative) $19.b,S [Reads: Accumulator, Stack Pointer]
	sta ($C5.b,X)		; 81 C5 ; Store accumulator ($C5.b,X) [Reads: Accumulator, X Index, Direct Page]
	cmp ($E3.b,X)		; C1 E3 ; Compare accumulator ($E3.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc ($E7.b,X)		; E1 E7 ; Subtract with carry ($E7.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	asl $38.b		; 06 38 ; Arithmetic shift left $38.b [Reads: Direct Page] [Flags: ZNC]
	jmp ($3E7E.w,X)		; 7C 7E 3E ; Jump indirect indexed to ($3E7E.w,X) [Reads: X Index] [Flow: jump]
	asl $1D1E.w,X		; 1E 1E 1D ; Arithmetic shift left $1D1E.w,X [Reads: X Index] [Flags: ZNC]
	inc $DD3D.w		; EE 3D DD ; Increment $DD3D.w [Flags: ZN]
	inc $3E1E.w,X		; FE 1E 3E ; Increment memory $3E1E.w,X [Reads: X Index] [Flags: ZN]
	dec $EEDE.w,X		; DE DE EE ; Decrement memory $EEDE.w,X [Reads: X Index] [Flags: ZN]
	sbc $0DF4.w		; ED F4 0D ; Subtract $0DF4.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	inc $09.b,X		; F6 09 ; Increment memory $09.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	ora $B3FF73.l		; 0F 73 FF B3 ; OR accumulator with memory (long) $B3FF73.l [Writes: Accumulator] [Flags: ZN]
	sbc $00FFC3.l,X		; FF C3 FF 00 ; Subtract with carry (long,X) $00FFC3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00.b,S		; E3 00 ; Subtract stack-relative $00.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $E1		; F0 E1 ; Branch if equal to $F0, $E1 [Flow: branch]
	sbc ($22.b),Y		; F1 22 ; Subtract with carry ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1F1F.w		; 1C 1F 1F ; Test and reset bits $1F1F.w [Reads: Accumulator] [Flags: Z]
	ora $FF9F0E.l		; 0F 0E 9F FF ; OR accumulator with memory (long) $FF9F0E.l [Writes: Accumulator] [Flags: ZN]
	cmp $FCE3FF.l		; CF FF E3 FC ; Compare accumulator (long) $FCE3FF.l [Reads: Accumulator] [Flags: ZNC]
	cpx $D7F3.w		; EC F3 D7 ; Compare $D7F3.w with X register [Reads: X Index] [Flags: ZNC]
	sbc $ACEEDE.l		; EF DE EE AC ; Subtract with carry (long) $ACEEDE.l [Writes: Accumulator] [Flags: ZVNC]
	jmp.w [$D9A8]		; DC A8 D9 ; Jump long indirect [$D9A8] [Flow: jump]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $8DFE.w,X		; 3D FE 8D ; AND accumulator with memory $8DFE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $5CA3.w,X		; FE A3 5C ; Increment memory $5CA3.w,X [Reads: X Index] [Flags: ZN]
	cmp $E2DFE0.l,X		; DF E0 DF E2 ; Compare accumulator (long,X) $E2DFE0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	cmp $CC3FE6.l,X		; DF E6 3F CC ; Compare accumulator (long,X) $CC3FE6.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $0C0028.l,X		; FF 28 00 0C ; Subtract with carry (long,X) $0C0028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $9EFD.w,X		; FD FD 9E ; Subtract with carry $9EFD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FF8F.w,X		; FE 8F FF ; Increment memory $FF8F.w,X [Reads: X Index] [Flags: ZN]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	stx $8AFE.w		; 8E FE 8A ; Store X register to $8AFE.w [Reads: X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cmp ($22.b,X)		; C1 22 ; Compare accumulator ($22.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc ($1F.b),Y		; F1 1F ; Subtract with carry ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $C10E.w		; 0E 0E C1 ; Arithmetic shift left $C10E.w [Flags: ZNC]
	cpx #$82.b		; E0 82 ; Compare #$82.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$4D.b		; C0 4D ; Compare #$4D.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc ($23.b,X)		; E1 23 ; Subtract with carry ($23.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $5F0F30.l,X		; 3F 30 0F 5F ; AND accumulator with memory (long,X) $5F0F30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$B7.b]		; 27 B7 ; AND accumulator with memory (long) [$B7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $1E3F1F.l		; AF 1F 3F 1E ; Load long $1E3F1F.l into accumulator [Writes: Accumulator] [Flags: ZN]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $2FE0.w		; EE E0 2F ; Increment $2FE0.w [Flags: ZN]
	trb $6AEC.w		; 1C EC 6A ; Test and reset bits $6AEC.w [Reads: Accumulator] [Flags: Z]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	cpy $37.b		; C4 37 ; Compare $37.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc [$E7.b],Y		; F7 E7 ; Subtract with carry (long indexed) [$E7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	adc $79FF3F.l,X		; 7F 3F FF 79 ; Add long $79FF3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$C1.b		; C0 C1 ; Compare #$C1.b with Y register [Reads: Y Index] [Flags: ZNC]
	sta ($40.b,X)		; 81 40 ; Store accumulator ($40.b,X) [Reads: Accumulator, X Index, Direct Page]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($C7.b,X)		; 81 C7 ; Store accumulator ($C7.b,X) [Reads: Accumulator, X Index, Direct Page]
	cmp [$00.b]		; C7 00 ; Compare accumulator (long) [$00.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FFFF.w,X		; 7E FF FF ; Rotate right $FFFF.w,X [Reads: X Index] [Flags: ZNC]
	ror $3B38.w,X		; 7E 38 3B ; Rotate right $3B38.w,X [Reads: X Index] [Flags: ZNC]
	.db $82, $45, $01		; 82 45 01 ; Branch always long to $82, $45, $01 [Flow: branch]
	eor $82.b,S		; 43 82 ; Exclusive OR accumulator with stack relative $82.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: ZN]
	adc $3901.w,X		; 7D 01 39 ; Add $3901.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($93.b,X)		; 01 93 ; Logical OR ($93.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $7C.b,S		; 83 7C ; Store accumulator (stack relative) $7C.b,S [Reads: Accumulator, Stack Pointer]
	inc $FF22.w,X		; FE 22 FF ; Increment memory $FF22.w,X [Reads: X Index] [Flags: ZN]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: ZNC]
	inc $7CFE.w,X		; FE FE 7C ; Increment memory $7CFE.w,X [Reads: X Index] [Flags: ZN]
	and $C3.b,S		; 23 C3 ; AND accumulator with stack relative $C3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $98		; 80 98 ; Branch always to $80, $98 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta ($91.b),Y		; 91 91 ; Store accumulator ($91.b),Y [Reads: Accumulator, Direct Page, Y Index]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Accumulator, X Index, Direct Page]
	sty $BC80.w		; 8C 80 BC ; Store Y register to $BC80.w [Reads: Y Index]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $677F.w,X		; 3C 7F 67 ; Test bits $677F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ror $7F7E.w		; 6E 7E 7F ; Rotate right $7F7E.w [Flags: ZNC]
	adc $FF3F07.l,X		; 7F 07 3F FF ; Add long $FF3F07.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $18F8C0.l,X		; DF C0 F8 18 ; Compare accumulator (long,X) $18F8C0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $58.b		; 85 58 ; Store accumulator to $58.b [Reads: Accumulator]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc [$E0.b]		; E7 E0 ; Subtract with carry (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$EE.b]		; E7 EE ; Subtract with carry (long) [$EE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $7F7F.w,X		; 7E 7F 7F ; Rotate right $7F7F.w,X [Reads: X Index] [Flags: ZNC]
	ora $87FF87.l,X		; 1F 87 FF 87 ; Logical OR long $87FF87.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$83.b]		; E7 83 ; Subtract with carry (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $43.b,S		; C3 43 ; Compare accumulator (stack relative) $43.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora ($65.b,S),Y		; 13 65 ; OR accumulator (stack relative indirect indexed) ($65.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $3093.w		; 20 93 30 ; Jump to subroutine at $3093.w [Writes: Stack Pointer] [Flow: call]
	and $1800DF.l		; 2F DF 00 18 ; AND accumulator with memory (long) $1800DF.l [Writes: Accumulator] [Flags: ZN]
	bit $BFBF.w,X		; 3C BF BF ; Test bits $BFBF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp $8700CF.l,X		; DF CF 00 87 ; Compare accumulator (long,X) $8700CF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $83E7A7.l,X		; FF A7 E7 83 ; Subtract with carry (long,X) $83E7A7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $44.b,S		; 83 44 ; Store accumulator (stack relative) $44.b,S [Reads: Accumulator, Stack Pointer]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $30, $DB		; 30 DB ; Branch if minus to $30, $DB [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $009F.w		; EE 9F 00 ; Increment $009F.w [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp ($FFFF.w,X)		; 7C FF FF ; Jump indirect indexed to ($FFFF.w,X) [Reads: X Index] [Flow: jump]
	cmp $005087.l		; CF 87 50 00 ; Compare accumulator (long) $005087.l [Reads: Accumulator] [Flags: ZNC]
	cop $27.b		; 02 27 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and #$E1E3.w		; 29 E3 E1 ; Logical AND #$E1E3.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $C2.b,S		; 03 C2 ; OR accumulator with stack relative $C2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $1EC6.w,X		; 5D C6 1E ; Exclusive OR accumulator with memory $1EC6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta [$03.b]		; 87 03 ; Store accumulator (long) [$03.b] [Reads: Accumulator, Direct Page]
	sta $C1.b,S		; 83 C1 ; Store accumulator (stack relative) $C1.b,S [Reads: Accumulator, Stack Pointer]
	cmp ($E3.b,X)		; C1 E3 ; Compare accumulator ($E3.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc ($E2.b,X)		; E1 E2 ; Subtract with carry ($E2.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	bit $7838.w,X		; 3C 38 78 ; Test bits $7838.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jmp ($1E3E.w,X)		; 7C 3E 1E ; Jump indirect indexed to ($1E3E.w,X) [Reads: X Index] [Flow: jump]
	asl $CA39.w,X		; 1E 39 CA ; Arithmetic shift left $CA39.w,X [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $1DFC.w,Y		; 19 FC 1D ; OR accumulator with memory $1DFC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $DCDD.w,X		; 3C DD DC ; Test bits $DCDD.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $EBFA.w		; ED FA EB ; Subtract $EBFA.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	jsr ($10EF.w,X)		; FC EF 10 ; Jump to subroutine indirect indexed ($10EF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $220604.l		; EF 04 06 22 ; Subtract with carry (long) $220604.l [Writes: Accumulator] [Flags: ZVNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $39.b		; 04 39 ; Test and set bits $39.b [Reads: Accumulator] [Flags: Z]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rep #$C3		; C2 C3 ; Reset processor status bits #$C3 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cpy $0CC7.w		; CC C7 0C ; Compare $0CC7.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$6D.b]		; 07 6D ; OR accumulator with memory (long) [$6D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $7E7D.w		; 0E 7D 7E ; Arithmetic shift left $7E7D.w [Flags: ZNC]
	sta ($FE.b,X)		; 81 FE ; Store accumulator ($FE.b,X) [Reads: Accumulator, X Index, Direct Page]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $F838.w,X		; 3C 38 F8 ; Test bits $F838.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $43F7F4.l,X		; FF F4 F7 43 ; Subtract with carry (long,X) $43F7F4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F6.b,X		; F5 F6 ; Subtract $F6.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $86.b		; 85 86 ; Store accumulator to $86.b [Reads: Accumulator]
	adc $83FE.w,Y		; 79 FE 83 ; Add $83FE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($00FF.w,X)		; 7C FF 00 ; Jump indirect indexed to ($00FF.w,X) [Reads: X Index] [Flow: jump]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $8B0E00.l		; 22 00 0E 8B ; Jump to subroutine long $8B0E00.l [Writes: Stack Pointer] [Flow: call]
	jsr ($FC73.w,X)		; FC 73 FC ; Jump to subroutine indirect indexed ($FC73.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $FA.b		; 45 FA ; Exclusive OR $FA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $99E2.w,X		; 5D E2 99 ; Exclusive OR accumulator with memory $99E2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $31.b		; E6 31 ; Increment $31.b [Reads: Direct Page] [Flags: ZN]
	dec $3CC3.w		; CE C3 3C ; Decrement $3CC3.w [Flags: ZN]
	sbc $450028.l,X		; FF 28 00 45 ; Subtract with carry (long,X) $450028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F60900.l,X		; FF 00 09 F6 ; Subtract with carry (long,X) $F60900.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$1DE2.w		; 09 E2 1D ; Logical OR #$1DE2.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	bit $99C3.w,X		; 3C C3 99 ; Test bits $99C3.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc [$27.b]		; E7 27 ; Subtract with carry (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FC03.w,X		; FD 03 FC ; Subtract with carry $FC03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($F3.b,X)		; 01 F3 ; Logical OR ($F3.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $1CE3.w		; 0C E3 1C ; Test and set bits $1CE3.w [Reads: Accumulator] [Flags: Z]
	sbc ($0D.b)		; F2 0D ; Subtract with carry (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($E503.w,X)		; FC 03 E5 ; Jump to subroutine indirect indexed ($E503.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $E7C3FC.l		; 0F FC C3 E7 ; OR accumulator with memory (long) $E7C3FC.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $F8F9.w,X		; 9E F9 F8 ; Store zero to $F8F9.w,X [Reads: X Index]
	adc [$E1.b]		; 67 E1 ; Add with carry (long) [$E1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $0E6E9F.l,X		; 1F 9F 6E 0E ; Logical OR long $0E6E9F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($33.b),Y		; F1 33 ; Subtract with carry ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $020029.l,X		; FF 29 00 02 ; Subtract with carry (long,X) $020029.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $43EF6F.l,X		; FF 6F EF 43 ; Subtract with carry (long,X) $43EF6F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $0AFF.w,X		; 7E FF 0A ; Rotate right $0AFF.w,X [Reads: X Index] [Flags: ZNC]
	and $02FE.w,X		; 3D FE 02 ; AND accumulator with memory $02FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F36D.w,X		; FD 6D F3 ; Subtract with carry $F36D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $21BD.w,X		; 3D BD 21 ; AND accumulator with memory $21BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta ($10.b,X)		; 81 10 ; Store accumulator ($10.b,X) [Reads: Accumulator, X Index, Direct Page]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $42, $7E		; 42 7E ; Reserved instruction
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $47FF.w,X		; 3C FF 47 ; Test bits $47FF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp [$81.b]		; C7 81 ; Compare accumulator (long) [$81.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta ($85.b,X)		; 81 85 ; Store accumulator ($85.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta $F0.b		; 85 F0 ; Store accumulator to $F0.b [Reads: Accumulator]
	cpy #$2F.b		; C0 2F ; Compare #$2F.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $380000.l,X		; FF 00 00 38 ; Subtract with carry (long,X) $380000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $3F7A.w,X		; 7E 7A 3F ; Rotate right $3F7A.w,X [Reads: X Index] [Flags: ZNC]
	ora $02AB83.l,X		; 1F 83 AB 02 ; Logical OR long $02AB83.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $E6FF.w		; 0C FF E6 ; Test and set bits $E6FF.w [Reads: Accumulator] [Flags: Z]
	sbc $B3FF7E.l,X		; FF 7E FF B3 ; Subtract with carry (long,X) $B3FF7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C3FF7B.l,X		; FF 7B FF C3 ; Subtract with carry (long,X) $C3FF7B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $BC.b,S		; C3 BC ; Compare accumulator (stack relative) $BC.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ldy $0025.w,X		; BC 25 00 ; Load Y register $0025.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	ora ($3C.b,X)		; 01 3C ; Logical OR ($3C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $0BDF.w		; 2C DF 0B ; Test bits $0BDF.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	stz $8F.b,X		; 74 8F ; Store zero to $8F.b,X [Reads: X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$FF.b],Y		; 77 FF ; Add with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $38FF.w,X		; FE FF 38 ; Increment memory $38FF.w,X [Reads: X Index] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	cmp [$40.b]		; C7 40 ; Compare accumulator (long) [$40.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $6E.b,S		; 43 6E ; Exclusive OR accumulator with stack relative $6E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $0FF60B.l,X		; 9F 0B F6 0F ; Store accumulator (long,X) $0FF60B.l,X [Reads: Accumulator, X Index]
	sbc $FFFE70.l,X		; FF 70 FE FF ; Subtract with carry (long,X) $FFFE70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $87.b		; 04 87 ; Test and set bits $87.b [Reads: Accumulator] [Flags: Z]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$44.b		; E0 44 ; Compare #$44.b with X register [Reads: X Index] [Flags: ZNC]
	cpy $78.b		; C4 78 ; Compare $78.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $817E18.l,X		; FF 18 7E 81 ; Subtract with carry (long,X) $817E18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $DBC3.w,X		; BD C3 DB ; Load $DBC3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $EF.b,S		; E3 EF ; Subtract stack-relative $EF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc ($F7.b),Y		; F1 F7 ; Subtract with carry ($F7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jmp ($00FD.w,X)		; 7C FD 00 ; Jump indirect indexed to ($00FD.w,X) [Reads: X Index] [Flow: jump]
	sta ($42.b,X)		; 81 42 ; Store accumulator ($42.b,X) [Reads: Accumulator, X Index, Direct Page]
	bit $10.b		; 24 10 ; Test bits $10.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	jmp ($F87F.w,X)		; 7C 7F F8 ; Jump indirect indexed to ($F87F.w,X) [Reads: X Index] [Flow: jump]
	inc $FDF1.w,X		; FE F1 FD ; Increment memory $FDF1.w,X [Reads: X Index] [Flags: ZN]
	sbc $FB.b,S		; E3 FB ; Subtract stack-relative $FB.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sta ($E7.b,X)		; 81 E7 ; Store accumulator ($E7.b,X) [Reads: Accumulator, X Index, Direct Page]
	clc		; 18 ; Clear carry flag [Flags: C]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	bit $80BD.w,X		; 3C BD 80 ; Test bits $80BD.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $42.b		; 24 42 ; Test bits $42.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sbc $01FE00.l,X		; FF 00 FE 01 ; Subtract with carry (long,X) $01FE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $11DF11.l		; CF 11 DF 11 ; Compare accumulator (long) $11DF11.l [Reads: Accumulator] [Flags: ZNC]
	cmp [$19.b],Y		; D7 19 ; Compare accumulator (long indexed) [$19.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	dec $18.b,X		; D6 18 ; Decrement memory $18.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cmp ($1C.b)		; D2 1C ; Compare accumulator (indirect) ($1C.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	cmp ($1D.b)		; D2 1D ; Compare accumulator (indirect) ($1D.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $210C20.l		; 22 20 0C 21 ; Jump to subroutine long $210C20.l [Writes: Stack Pointer] [Flow: call]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $1F1F0F.l		; 0F 0F 1F 1F ; OR accumulator with memory (long) $1F1F0F.l [Writes: Accumulator] [Flags: ZN]
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: ZN]
	sbc $4307F8.l,X		; FF F8 07 43 ; Subtract with carry (long,X) $4307F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($0303.w,X)		; FC 03 03 ; Jump to subroutine indirect indexed ($0303.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $F003.w,X		; FD 03 F0 ; Subtract with carry $F003.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: ZNC]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($1C.b,S),Y		; D3 1C ; Compare accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	ora $E3.b		; 05 E3 ; Logical OR $E3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $14DB.w,X		; 3C DB 14 ; Test bits $14DB.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp [$18.b],Y		; D7 18 ; Compare accumulator (long indexed) [$18.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	eor $D3.b,S		; 43 D3 ; Exclusive OR accumulator with stack relative $D3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $2022.w		; 1C 22 20 ; Test and reset bits $2022.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $F5FBFA.l,X		; FF FA FB F5 ; Subtract with carry (long,X) $F5FBFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $02.b,X		; F6 02 ; Increment memory $02.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $FF47.w,X		; FD 47 FF ; Subtract with carry $FF47.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	trb $FF.b		; 14 FF ; Test and reset bits $FF.b [Reads: Accumulator] [Flags: Z]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($B4.b,X)		; C1 B4 ; Compare accumulator ($B4.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	ldy $2A.b,X		; B4 2A ; Load Y register $2A.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	rol $6E52.w,X		; 3E 52 6E ; Rotate left $6E52.w,X [Reads: X Index] [Flags: ZNC]
	lda $42C3.w,X		; BD C3 42 ; Load $42C3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Accumulator, X Index, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $C14B.w,X		; 3E 4B C1 ; Rotate left $C14B.w,X [Reads: X Index] [Flags: ZNC]
	sta ($22.b,X)		; 81 22 ; Store accumulator ($22.b,X) [Reads: Accumulator, X Index, Direct Page]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $46.b		; C5 46 ; Compare $46.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	trb $38A4.w		; 1C A4 38 ; Test and reset bits $38A4.w [Reads: Accumulator] [Flags: Z]
	sty $18.b,X		; 94 18 ; Store Y register $18.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	ldy $B430.w		; AC 30 B4 ; Load $B430.w into Y register [Writes: Y Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jmp $66E5.w		; 4C E5 66 ; Jump to $66E5.w [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $60.b,S		; 43 60 ; Exclusive OR accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora ($40.b),Y		; 11 40 ; OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	rol $3CC1.w,X		; 3E C1 3C ; Rotate left $3CC1.w,X [Reads: X Index] [Flags: ZNC]
	cmp $42.b,S		; C3 42 ; Compare accumulator (stack relative) $42.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	lda $3CC3.w,X		; BD C3 3C ; Load $3CC3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sta ($66.b,X)		; 81 66 ; Store accumulator ($66.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($C3.b,X)		; 81 C3 ; Store accumulator ($C3.b,X) [Reads: Accumulator, X Index, Direct Page]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($E6.b),Y		; 11 E6 ; OR accumulator with memory ($E6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$C0.b],Y		; 37 C0 ; AND accumulator with memory (long indexed) [$C0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $30, $43		; 30 43 ; Branch if minus to $30, $43 [Flow: branch]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	ora $CA.b		; 05 CA ; Logical OR $CA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $37		; 30 37 ; Branch if minus to $30, $37 [Flow: branch]
	cpy #$11.b		; C0 11 ; Compare #$11.b with Y register [Reads: Y Index] [Flags: ZNC]
	inc $29.b		; E6 29 ; Increment $29.b [Reads: Direct Page] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $600400.l		; 22 00 04 60 ; Jump to subroutine long $600400.l [Writes: Stack Pointer] [Flow: call]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	cmp $6E.b,S		; C3 6E ; Compare accumulator (stack relative) $6E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $DD7FBE.l		; EF BE 7F DD ; Subtract with carry (long) $DD7FBE.l [Writes: Accumulator] [Flags: ZVNC]
	rol $3FC0.w,X		; 3E C0 3F ; Rotate left $3FC0.w,X [Reads: X Index] [Flags: ZNC]
	lda $43827F.l,X		; BF 7F 82 43 ; Load long $43827F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldx $67.b		; A6 67 ; Load $67.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	bit $2310.w,X		; 3C 10 23 ; Test bits $2310.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7018.w,X		; 3C 18 70 ; Test bits $7018.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta $B9B04F.l		; 8F 4F B0 B9 ; Store accumulator (long) $B9B04F.l [Reads: Accumulator]
	adc $F0DF5F.l,X		; 7F 5F DF F0 ; Add long $F0DF5F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $8F		; F0 8F ; Branch if equal to $F0, $8F [Flow: branch]
	sta $7FFF00.l		; 8F 00 FF 7F ; Store accumulator (long) $7FFF00.l [Reads: Accumulator]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $700F.w		; 20 0F 70 ; Jump to subroutine at $700F.w [Writes: Stack Pointer] [Flow: call]
	jsl $7F0F00.l		; 22 00 0F 7F ; Jump to subroutine long $7F0F00.l [Writes: Stack Pointer] [Flow: call]
	and $BF4CC0.l,X		; 3F C0 4C BF ; AND accumulator with memory (long,X) $BF4CC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$3F.b],Y		; D7 3F ; Compare accumulator (long indexed) [$3F.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	inc $7F.b,X		; F6 7F ; Increment memory $7F.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cmp [$47.b]		; C7 47 ; Compare accumulator (long) [$47.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	.db $80, $38		; 80 38 ; Branch always to $80, $38 [Flow: branch]
	sbc $238000.l,X		; FF 00 80 23 ; Subtract with carry (long,X) $238000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Accumulator, Direct Page]
	cmp $877830.l		; CF 30 78 87 ; Compare accumulator (long) $877830.l [Reads: Accumulator] [Flags: ZNC]
	trb $EF.b		; 14 EF ; Test and reset bits $EF.b [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc [$BD.b]		; E7 BD ; Subtract with carry (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FE.b,S		; C3 FE ; Compare accumulator (stack relative) $FE.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $39.b		; C6 39 ; Decrement $39.b [Reads: Direct Page] [Flags: ZN]
	ror $99.b		; 66 99 ; Rotate right $99.b [Reads: Direct Page] [Flags: ZNC]
	lda $C03FC0.l,X		; BF C0 3F C0 ; Load long $C03FC0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $D691.w		; 6E 91 D6 ; Rotate right $D691.w [Flags: ZNC]
	and $CB43.w,Y		; 39 43 CB ; AND accumulator with memory $CB43.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $0027.w,X		; 3C 27 00 ; Test bits $0027.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $59.b		; 05 59 ; Logical OR $59.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc [$2C.b]		; E7 2C ; Subtract with carry (long) [$2C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($3C.b,S),Y		; 73 3C ; Add with carry (stack relative indirect indexed) ($3C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($43.b,S),Y		; 33 43 ; AND accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $0739.w,X		; 5E 39 07 ; Logical shift right $0739.w,X [Reads: X Index] [Flags: ZNC]
	lda $BB73.w,X		; BD 73 BB ; Load $BB73.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$58.b],Y		; 77 58 ; Add with carry (long indexed) [$58.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$00.b]		; C7 00 ; Compare accumulator (long) [$00.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	cpy #$13.b		; C0 13 ; Compare #$13.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsr $431D.w		; 20 1D 43 ; Jump to subroutine at $431D.w [Writes: Stack Pointer] [Flow: call]
	sbc $EB.b,X		; F5 EB ; Subtract $EB.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta ($ED.b)		; 92 ED ; Store accumulator (indirect) ($ED.b) [Reads: Accumulator, Direct Page]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sta [$3A.b]		; 87 3A ; Store accumulator (long) [$3A.b] [Reads: Accumulator, Direct Page]
	cmp [$8B.b]		; C7 8B ; Compare accumulator (long) [$8B.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	lda [$C9.b],Y		; B7 C9 ; Load accumulator (long indexed) [$C9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$DD.b],Y		; D7 DD ; Compare accumulator (long indexed) [$DD.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	cmp ($A0.b,S),Y		; D3 A0 ; Compare accumulator (stack relative indirect indexed) ($A0.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($40.b)		; 12 40 ; OR accumulator with memory (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $6D20.w		; 20 20 6D ; Jump to subroutine at $6D20.w [Writes: Stack Pointer] [Flow: call]
	adc ($7C.b,S),Y		; 73 7C ; Add with carry (stack relative indirect indexed) ($7C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($74.b,S),Y		; 73 74 ; Add with carry (stack relative indirect indexed) ($74.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldx $A9.b		; A6 A9 ; Load $A9.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	cmp [$D8.b]		; C7 D8 ; Compare accumulator (long) [$D8.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta $8CB2.w		; 8D B2 8C ; Store accumulator to $8CB2.w [Reads: Accumulator]
	sbc ($1E.b,S),Y		; F3 1E ; Subtract with carry (stack relative indirect indexed) ($1E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc #$8022.w		; E9 22 80 ; Subtract #$8022.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	tsb $50.b		; 04 50 ; Test and set bits $50.b [Reads: Accumulator] [Flags: Z]
	jsr $0040.w		; 20 40 00 ; Jump to subroutine at $0040.w [Writes: Stack Pointer] [Flow: call]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $6F0930.l		; 2F 30 09 6F ; AND accumulator with memory (long) $6F0930.l [Writes: Accumulator] [Flags: ZN]
	.db $70, $EF		; 70 EF ; Branch if overflow set to $70, $EF [Flow: branch]
	.db $F0, $E7		; F0 E7 ; Branch if equal to $F0, $E7 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: ZNC]
	cmp ($FF.b,X)		; C1 FF ; Compare accumulator ($FF.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	jsl $8000C0.l		; 22 C0 00 80 ; Jump to subroutine long $8000C0.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$B1.b],Y		; 17 B1 ; OR accumulator with memory (long indexed) [$B1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($DD.b)		; F2 DD ; Subtract with carry (indirect) ($DD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $BC83.w,X		; FE 83 BC ; Increment memory $BC83.w,X [Reads: X Index] [Flags: ZN]
	asl $D9.b		; 06 D9 ; Arithmetic shift left $D9.b [Reads: Direct Page] [Flags: ZNC]
	asl $67F1.w		; 0E F1 67 ; Arithmetic shift left $67F1.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $EC.b,S		; 63 EC ; Add with carry (stack relative) $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	ora ($D6.b),Y		; 11 D6 ; OR accumulator with memory ($D6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $4000.w		; 0C 00 40 ; Test and set bits $4000.w [Reads: Accumulator] [Flags: Z]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	eor [$EF.b]		; 47 EF ; Exclusive OR accumulator with memory (long) [$EF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	cmp $B0AFD0.l		; CF D0 AF B0 ; Compare accumulator (long) $B0AFD0.l [Reads: Accumulator] [Flags: ZNC]
	cmp $D02FE0.l,X		; DF E0 2F D0 ; Compare accumulator (long,X) $D02FE0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc $B711.w		; EE 11 B7 ; Increment $B711.w [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.INDEX 8
	sep #$1D		; E2 1D
	lda $CA4B.w,X		; BD 4B CA ; Load $CA4B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $9F.b,X		; 35 9F ; Logical AND $9F.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $EB01FE.l		; 0F FE 01 EB ; OR accumulator with memory (long) $EB01FE.l [Writes: Accumulator] [Flags: ZN]
	ora $FC.b,X		; 15 FC ; OR accumulator with memory $FC.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $D5.b,S		; 03 D5 ; OR accumulator with stack relative $D5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	sbc [$1D.b]		; E7 1D ; Subtract with carry (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $09.b,X		; F6 09 ; Increment memory $09.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $D7.b		; 05 D7 ; Logical OR $D7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $0027.w		; 2D 27 00 ; Logical AND $0027.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: ZNC]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	asl $C03F.w		; 0E 3F C0 ; Arithmetic shift left $C03F.w [Flags: ZNC]
	adc ($8C.b,S),Y		; 73 8C ; Add with carry (stack relative indirect indexed) ($8C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $609300.l,X		; FF 00 93 60 ; Subtract with carry (long,X) $609300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $CC00CC.l		; 22 CC 00 CC ; Jump to subroutine long $CC00CC.l [Writes: Stack Pointer] [Flow: call]
	jsl $100400.l		; 22 00 04 10 ; Jump to subroutine long $100400.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $E93F.w,X		; DE 3F E9 ; Decrement memory $E93F.w,X [Reads: X Index] [Flags: ZN]
	asl $21DE.w,X		; 1E DE 21 ; Arithmetic shift left $21DE.w,X [Reads: X Index] [Flags: ZNC]
	cmp $37D62F.l		; CF 2F D6 37 ; Compare accumulator (long) $37D62F.l [Reads: Accumulator] [Flags: ZNC]
	sbc ($5E.b,X)		; E1 5E ; Subtract with carry ($5E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda $3FDF60.l,X		; BF 60 DF 3F ; Load long $3FDF60.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $100100.l		; 22 00 01 10 ; Jump to subroutine long $100100.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $BE1200.l		; 22 00 12 BE ; Jump to subroutine long $BE1200.l [Writes: Stack Pointer] [Flow: call]
	adc $9CE363.l,X		; 7F 63 E3 9C ; Add long $9CE363.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $E31C.w		; 9C 1C E3 ; Store zero to $E31C.w
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	adc $F292FF.l,X		; 7F FF 92 F2 ; Add long $F292FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $22.b,S		; 63 22 ; Add with carry (stack relative) $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $C200.w		; 0D 00 C2 ; Logical OR $C200.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $3FD8.w,X		; 3D D8 3F ; AND accumulator with memory $3FD8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda [$7F.b]		; A7 7F ; Load accumulator (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	adc [$BF.b]		; 67 BF ; Add with carry (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $A737A0.l		; 0F A0 37 A7 ; OR accumulator with memory (long) $A737A0.l [Writes: Accumulator] [Flags: ZN]
	and $AE3FAF.l		; 2F AF 3F AE ; AND accumulator with memory (long) $AE3FAF.l [Writes: Accumulator] [Flags: ZN]
	rol $1C9C.w,X		; 3E 9C 1C ; Rotate left $1C9C.w,X [Reads: X Index] [Flags: ZNC]
	sta ($01.b,X)		; 81 01 ; Store accumulator ($01.b,X) [Reads: Accumulator, X Index, Direct Page]
	cmp $02.b,S		; C3 02 ; Compare accumulator (stack relative) $02.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $7F2500.l,X		; FF 00 25 7F ; Subtract with carry (long,X) $7F2500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FC0BFF.l		; 22 FF 0B FC ; Jump to subroutine long $FC0BFF.l [Writes: Stack Pointer] [Flow: call]
	jsr ($7E7E.w,X)		; FC 7E 7E ; Jump to subroutine indirect indexed ($7E7E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $803C.w,X		; 3C 3C 80 ; Test bits $803C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $FF2500.l,X		; FF 00 25 FF ; Subtract with carry (long,X) $FF2500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FF,$00		; 44 00 FF ; Move block positive $FF,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $31.b,S		; 03 31 ; OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($EC.b),Y		; 31 EC ; AND accumulator with memory ($EC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx $FF22.w		; EC 22 FF ; Compare $FF22.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $FF00.w		; 0C 00 FF ; Test and set bits $FF00.w [Reads: Accumulator] [Flags: Z]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $CEFFFF.l,X		; 3F FF FF CE ; AND accumulator with memory (long,X) $CEFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $43C0FF.l,X		; FF FF C0 43 ; Subtract with carry (long,X) $43C0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $860300.l,X		; FF 00 03 86 ; Subtract with carry (long,X) $860300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $41.b		; 86 41 ; Store X register to $41.b [Reads: X Index]
	eor ($22.b,X)		; 41 22 ; Exclusive OR accumulator with memory ($22.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $FF0002.l,X		; FF 02 00 FF ; Subtract with carry (long,X) $FF0002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BE7914.l,X		; FF 14 79 BE ; Subtract with carry (long,X) $BE7914.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7FC300.l,X		; FF 00 C3 7F ; Subtract with carry (long,X) $7FC300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$7F.b		; E0 7F ; Compare #$7F.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	ldy $BF5F.w,X		; BC 5F BF ; Load Y register $BF5F.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc $8F779F.l		; 6F 9F 77 8F ; Add with carry (long) $8F779F.l [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp [$22.b]		; C7 22 ; Compare accumulator (long) [$22.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	adc $5F3F05.l,X		; 7F 05 3F 5F ; Add long $5F3F05.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $7F7877.l		; 6F 77 78 7F ; Add with carry (long) $7F7877.l [Writes: Accumulator] [Flags: ZVNC]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $40FF4D.l,X		; 7F 4D FF 40 ; Add long $40FF4D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$7F.b]		; 27 7F ; AND accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $004CFF.l		; 22 FF 4C 00 ; Jump to subroutine long $004CFF.l [Writes: Stack Pointer] [Flow: call]
	sbc $09FF27.l,X		; FF 27 FF 09 ; Subtract with carry (long,X) $09FF27.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $C038F0.l		; 0F F0 38 C0 ; OR accumulator with memory (long) $C038F0.l [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta [$44.b]		; 87 44 ; Store accumulator (long) [$44.b] [Reads: Accumulator, Direct Page]
	sty $5B8A.w		; 8C 8A 5B ; Store Y register to $5B8A.w [Reads: Y Index]
	eor $84.b,S		; 43 84 ; Exclusive OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $1C.b,X		; 56 1C ; Logical shift right $1C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($24.b,S),Y		; 33 24 ; AND accumulator (stack relative indirect indexed) ($24.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and #$2429.w		; 29 29 24 ; Logical AND #$2429.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cpy $0C.b		; C4 0C ; Compare $0C.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	ldy #$47.b		; A0 47 ; Load #$47.b into Y register [Writes: Y Index] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $3FC978.l		; 8F 78 C9 3F ; Store accumulator (long) $3FC978.l [Reads: Accumulator]
	adc #$399F.w		; 69 9F 39 ; Add #$399F.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	cmp [$0F.b]		; C7 0F ; Compare accumulator (long) [$0F.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	.db $F0, $33		; F0 33 ; Branch if equal to $F0, $33 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	ora $BE3E9F.l,X		; 1F 9F 3E BE ; Logical OR long $BE3E9F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $38BD.w,X		; 3D BD 38 ; AND accumulator with memory $38BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $B011.w,Y		; B9 11 B0 ; Load $B011.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $BDB8.w,Y		; 19 B8 BD ; OR accumulator with memory $BDB8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $603F.w,X		; 3C 3F 60 ; Test bits $603F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	eor ($42.b,X)		; 41 42 ; Exclusive OR accumulator with memory ($42.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $4E.b		; 46 4E ; Logical shift right $4E.b [Reads: Direct Page] [Flags: ZNC]
	lsr $42.b		; 46 42 ; Logical shift right $42.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0000FF.l,X		; BF FF 00 00 ; Load long $0000FF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00FF48.l,X		; FF 48 FF 00 ; Subtract with carry (long,X) $00FF48.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $34.b		; E4 34 ; Compare $34.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $431C.w,X		; 9D 1C 43 ; Store accumulator to $431C.w,X [Reads: Accumulator, X Index]
	lda $013C.w,X		; BD 3C 01 ; Load $013C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $8318.w,Y		; 99 18 83 ; Store accumulator to $8318.w,Y [Reads: Accumulator, Y Index]
	mvn $83,$01		; 54 01 83 ; Move block negative $83,$01 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	mvn $01,$01		; 54 01 01 ; Move block negative $01,$01 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $62, $42, $45		; 62 42 45 ; Push effective relative address $62, $42, $45 [Writes: Stack Pointer]
	.db $42, $66		; 42 66 ; Reserved instruction
	eor $57.b		; 45 57 ; Exclusive OR $57.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy #$05.b		; C0 05 ; Compare #$05.b with Y register [Reads: Y Index] [Flags: ZNC]
	adc [$F0.b],Y		; 77 F0 ; Add with carry (long indexed) [$F0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $801FC8.l,X		; 3F C8 1F 80 ; AND accumulator with memory (long,X) $801FC8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $57.b,S		; 43 57 ; Exclusive OR accumulator with stack relative $57.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $4E.b,S		; 43 4E ; Exclusive OR accumulator with stack relative $4E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $37560D.l		; 2F 0D 56 37 ; AND accumulator with memory (long) $37560D.l [Writes: Accumulator] [Flags: ZN]
	lsr $37.b		; 46 37 ; Logical shift right $37.b [Reads: Direct Page] [Flags: ZNC]
	rol $17.b		; 26 17 ; Rotate left $17.b [Reads: Direct Page] [Flags: ZNC]
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	asl $0E0F.w		; 0E 0F 0E ; Arithmetic shift left $0E0F.w [Flags: ZNC]
	and $231010.l		; 2F 10 10 23 ; AND accumulator with memory (long) $231010.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $4F		; 10 4F ; Branch if plus to $10, $4F [Flow: branch]
	sbc $FF2700.l,X		; FF 00 27 FF ; Subtract with carry (long,X) $FF2700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	cpx $B757.w		; EC 57 B7 ; Compare $B757.w with X register [Reads: X Index] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF5DA2.l,X		; FF A2 5D FF ; Subtract with carry (long,X) $FF5DA2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx #$A2.b		; A2 A2 ; Load #$A2.b into X register [Writes: X Index] [Flags: ZN]
	sty $0D.b		; 84 0D ; Store Y register to $0D.b [Reads: Y Index]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $000280.l,X		; 7F 80 02 00 ; Add long $000280.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta $62.b,S		; 83 62 ; Store accumulator (stack relative) $62.b,S [Reads: Accumulator, Stack Pointer]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora $C7079F.l,X		; 1F 9F 07 C7 ; Logical OR long $C7079F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $3F7F00.l,X		; FF 00 7F 3F ; Subtract with carry (long,X) $3F7F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $3F7867.l,X		; 5F 67 78 3F ; Exclusive OR accumulator with memory (long,X) $3F7867.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $C34F00.l,X		; 1F 00 4F C3 ; Logical OR long $C34F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lsr $7E27.w,X		; 5E 27 7E ; Logical shift right $7E27.w,X [Reads: X Index] [Flags: ZNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $7F0040.l,X		; FF 40 00 7F ; Subtract with carry (long,X) $7F0040.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FF004A.l,X		; 7F 4A 00 FF ; Add long $FF004A.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $0002FF.l		; 22 FF 02 00 ; Jump to subroutine long $0002FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $FF2600.l,X		; FF 00 26 FF ; Subtract with carry (long,X) $FF2600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $0D17.w,X		; 1D 17 0D ; OR accumulator with memory $0D17.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$43.b],Y		; F7 43 ; Subtract with carry (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $FB.b		; 06 FB ; Arithmetic shift left $FB.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $FA03.w,X		; FE 03 FA ; Increment memory $FA03.w,X [Reads: X Index] [Flags: ZN]
	jsr ($FC03.w,X)		; FC 03 FC ; Jump to subroutine indirect indexed ($FC03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jmp.w [$EC05]		; DC 05 EC ; Jump long indirect [$EC05] [Flow: jump]
	.db $80, $F7		; 80 F7 ; Branch always to $80, $F7 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	adc $07FF22.l,X		; 7F 22 FF 07 ; Add long $07FF22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $132339.l,X		; FF 39 23 13 ; Subtract with carry (long,X) $132339.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $B11C.w,X		; 9D 1C B1 ; Store accumulator to $B11C.w,X [Reads: Accumulator, X Index]
	sty $53.b		; 84 53 ; Store Y register to $53.b [Reads: Y Index]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $C3.b,S		; 43 C3 ; Exclusive OR accumulator with stack relative $C3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $C101.w,X		; 7E 01 C1 ; Rotate right $C101.w,X [Reads: X Index] [Flags: ZNC]
	ror $6083.w,X		; 7E 83 60 ; Rotate right $6083.w,X [Reads: X Index] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $4AE4.w,X		; 7E E4 4A ; Rotate right $4AE4.w,X [Reads: X Index] [Flags: ZNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$C0.b],Y		; 57 C0 ; Exclusive OR accumulator with memory (long indexed) [$C0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($73.b)		; 12 73 ; OR accumulator with memory (indirect) ($73.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx $69.b		; E4 69 ; Compare $69.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
.ACCU 8
.INDEX 8
	sep #$74		; E2 74
	sbc ($32.b),Y		; F1 32 ; Subtract with carry ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $39		; F0 39 ; Branch if equal to $F0, $39 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $38387F.l,X		; 9F 7F 38 38 ; Store accumulator (long,X) $38387F.l,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $0F0E.w		; 1C 0E 0F ; Test and reset bits $0F0E.w [Reads: Accumulator] [Flags: Z]
	ora [$4A.b]		; 07 4A ; OR accumulator with memory (long) [$4A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $6F.b		; 05 6F ; Logical OR $6F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0023.w,X)		; FC 23 00 ; Jump to subroutine indirect indexed ($0023.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $F830.w		; 0D 30 F8 ; Logical OR $F830.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $008303.l,X		; FF 03 83 00 ; Subtract with carry (long,X) $008303.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $C3.b		; 24 C3 ; Test bits $C3.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $010022.l,X		; FF 22 00 01 ; Subtract with carry (long,X) $010022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $183F.w		; 0D 3F 18 ; Logical OR $183F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $382F30.l,X		; 1F 30 2F 38 ; Logical OR long $382F30.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$2D.b],Y		; 37 2D ; AND accumulator with memory (long indexed) [$2D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	eor [$0F.b]		; 47 0F ; Exclusive OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $25.b,X		; D5 25 ; Compare accumulator $25.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy #$11.b		; C0 11 ; Compare #$11.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$20.b		; A0 20 ; Load #$20.b into Y register [Writes: Y Index] [Flags: ZN]
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc $E3FFB6.l,X		; FF B6 FF E3 ; Subtract with carry (long,X) $E3FFB6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E3BE41.l,X		; FF 41 BE E3 ; Subtract with carry (long,X) $E3BE41.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $EBB6.w,X		; 5D B6 EB ; Exclusive OR accumulator with memory $EBB6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $14FF.w		; 1C FF 14 ; Test and reset bits $14FF.w [Reads: Accumulator] [Flags: Z]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $1B2716.l		; 2F 16 27 1B ; AND accumulator with memory (long) $1B2716.l [Writes: Accumulator] [Flags: ZN]
	adc ($3C.b,S),Y		; 73 3C ; Add with carry (stack relative indirect indexed) ($3C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $6983BC.l,X		; 5F BC 83 69 ; Exclusive OR accumulator with memory (long,X) $6983BC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp [$7C.b]		; C7 7C ; Compare accumulator (long) [$7C.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	dec $DB.b,X		; D6 DB ; Decrement memory $DB.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	ldy $6F5F.w,X		; BC 5F 6F ; Load Y register $6F5F.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc [$7B.b],Y		; 77 7B ; Add with carry (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($5EC1.w,X)		; 7C C1 5E ; Jump indirect indexed to ($5EC1.w,X) [Reads: X Index] [Flow: jump]
	cpy #$5F.b		; C0 5F ; Compare #$5F.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$6F.b		; C0 6F ; Compare #$6F.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $BF		; 70 BF ; Branch if overflow set to $70, $BF [Flow: branch]
	and $3F43DF.l,X		; 3F DF 43 3F ; AND accumulator with memory (long,X) $3F43DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	ror $7F22.w,X		; 7E 22 7F ; Rotate right $7F22.w,X [Reads: X Index] [Flags: ZNC]
	jsl $C002FF.l		; 22 FF 02 C0 ; Jump to subroutine long $C002FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $004400.l,X		; FF 00 44 00 ; Subtract with carry (long,X) $004400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $070009.l,X		; FF 09 00 07 ; Subtract with carry (long,X) $070009.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($FAFE.w,X)		; FC FE FA ; Jump to subroutine indirect indexed ($FAFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($FC01.w,X)		; FC 01 FC ; Jump to subroutine indirect indexed ($FC01.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $F0.b,S		; 43 F0 ; Exclusive OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $EB02.w		; 1C 02 EB ; Test and reset bits $EB02.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $1B43.w		; EC 43 1B ; Compare $1B43.w with X register [Reads: X Index] [Flags: ZNC]
	inc $0D07.w		; EE 07 0D ; Increment $0D07.w [Flags: ZN]
	sbc [$0D.b],Y		; F7 0D ; Subtract with carry (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$EF.b],Y		; 17 EF ; OR accumulator with memory (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $23E3E0.l		; EF E0 E3 23 ; Subtract with carry (long) $23E3E0.l [Writes: Accumulator] [Flags: ZVNC]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: ZNC]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1DFD07.l,X		; FF 07 FD 1D ; Subtract with carry (long,X) $1DFD07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($FD3C.w,X)		; FC 3C FD ; Jump to subroutine indirect indexed ($FD3C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $59D7.w,X		; 3D D7 59 ; AND accumulator with memory $59D7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $63.b,S		; 83 63 ; Store accumulator (stack relative) $63.b,S [Reads: Accumulator, Stack Pointer]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $383F3F.l,X		; 1F 3F 3F 38 ; Logical OR long $383F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $81.b,S		; 43 81 ; Exclusive OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $FF02.w,X		; 7E 02 FF ; Rotate right $FF02.w,X [Reads: X Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $C1,$3E		; 44 3E C1 ; Move block positive $C1,$3E [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sta $F4.b,S		; 83 F4 ; Store accumulator (stack relative) $F4.b,S [Reads: Accumulator, Stack Pointer]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $68C000.l,X		; FF 00 C0 68 ; Subtract with carry (long,X) $68C000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$57.b		; C0 57 ; Compare #$57.b with Y register [Reads: Y Index] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	adc $CF58C7.l		; 6F C7 58 CF ; Add with carry (long) $CF58C7.l [Writes: Accumulator] [Flags: ZVNC]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cmp $000847.l		; CF 47 08 00 ; Compare accumulator (long) $000847.l [Reads: Accumulator] [Flags: ZNC]
	and [$3B.b],Y		; 37 3B ; AND accumulator with memory (long indexed) [$3B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	and ($37.b,S),Y		; 33 37 ; AND accumulator (stack relative indirect indexed) ($37.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$FF.b],Y		; 37 FF ; AND accumulator with memory (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $15.b		; 85 15 ; Store accumulator to $15.b [Reads: Accumulator]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr ($FF43.w,X)		; FC 43 FF ; Jump to subroutine indirect indexed ($FF43.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $5C.b,S		; 83 5C ; Store accumulator (stack relative) $5C.b,S [Reads: Accumulator, Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$8E.b]		; 07 8E ; OR accumulator with memory (long) [$8E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $E13FC0.l,X		; 7F C0 3F E1 ; Add long $E13FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $07F8.w,X		; 1E F8 07 ; Arithmetic shift left $07F8.w,X [Reads: X Index] [Flags: ZNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0B0028.l,X		; FF 28 00 0B ; Subtract with carry (long,X) $0B0028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($FE.b)		; 32 FE ; AND accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $447F.w,Y		; 19 7F 44 ; OR accumulator with memory $447F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $FC7F80.l,X		; BF 80 7F FC ; Load long $FC7F80.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $010002.l,X		; FF 02 00 01 ; Subtract with carry (long,X) $010002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $E4		; 80 E4 ; Branch always to $80, $E4 [Flow: branch]
	and $2200.w,Y		; 39 00 22 ; AND accumulator with memory $2200.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $220024.l,X		; FF 24 00 22 ; Subtract with carry (long,X) $220024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $043084.l,X		; FF 84 30 04 ; Subtract with carry (long,X) $043084.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $63.b,S		; 83 63 ; Store accumulator (stack relative) $63.b,S [Reads: Accumulator, Stack Pointer]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $82.b,S		; 83 82 ; Store accumulator (stack relative) $82.b,S [Reads: Accumulator, Stack Pointer]
	adc $5D7C.w,X		; 7D 7C 5D ; Add $5D7C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp $5D7475.l		; 5C 75 74 5D ; Jump long to $5D7475.l [Flow: jump]
	jmp $837C7D.l		; 5C 7D 7C 83 ; Jump long to $837C7D.l [Flow: jump]
	.db $82, $FF, $00		; 82 FF 00 ; Branch always long to $82, $FF, $00 [Flow: branch]
	jmp ($FE24.w,X)		; 7C 24 FE ; Jump indirect indexed to ($FE24.w,X) [Reads: X Index] [Flow: jump]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $60.b		; E4 60 ; Compare $60.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $07F900.l,X		; FF 00 F9 07 ; Subtract with carry (long,X) $07F900.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1E.b,S		; E3 1E ; Subtract stack-relative $1E.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	dec $9C3C.w		; CE 3C 9C ; Decrement $9C3C.w [Flags: ZN]
	adc $F338.w,Y		; 79 38 F3 ; Add $F338.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($E6.b),Y		; 31 E6 ; AND accumulator with memory ($E6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor ($C4.b,S),Y		; 53 C4 ; XOR accumulator (stack relative indirect indexed) ($C4.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $FF2200.l,X		; FF 00 22 FF ; Subtract with carry (long,X) $FF2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $00FF44.l,X		; FF 44 FF 00 ; Subtract with carry (long,X) $00FF44.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $FF0000.l		; 22 00 00 FF ; Jump to subroutine long $FF0000.l [Writes: Stack Pointer] [Flow: call]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cmp ($3E.b,X)		; C1 3E ; Compare accumulator ($3E.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $9E7F80.l,X		; 7F 80 7F 9E ; Add long $9E7F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($DE.b,X)		; 21 DE ; Logical AND ($DE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $FF22E0.l,X		; 1F E0 22 FF ; Logical OR long $FF22E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $460347.l		; CF 47 03 46 ; Compare accumulator (long) $460347.l [Reads: Accumulator] [Flags: ZNC]
	dec $CD44.w		; CE 44 CD ; Decrement $CD44.w [Flags: ZN]
	eor $40.b,S		; 43 40 ; Exclusive OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cmp $4722E0.l		; CF E0 22 47 ; Compare accumulator (long) $4722E0.l [Reads: Accumulator] [Flags: ZNC]
	cmp $373747.l		; CF 47 37 37 ; Compare accumulator (long) $373747.l [Reads: Accumulator] [Flags: ZNC]
	rol $35.b,X		; 36 35 ; Rotate left $35.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and ($30.b)		; 32 30 ; AND accumulator with memory (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$37.b],Y		; 37 37 ; AND accumulator with memory (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $99.b		; 66 99 ; Rotate right $99.b [Reads: Direct Page] [Flags: ZNC]
	lda $5A.b		; A5 5A ; Load $5A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $C3.b		; 24 C3 ; Test bits $C3.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$DB.b]		; E7 DB ; Subtract with carry (long) [$DB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1818E7.l,X		; FF E7 18 18 ; Subtract with carry (long,X) $1818E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc [$3C.b]		; E7 3C ; Subtract with carry (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	cmp $E7.b,S		; C3 E7 ; Compare accumulator (stack relative) $E7.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	mvp $F8,$FF		; 44 FF F8 ; Move block positive $F8,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $10, $78		; 10 78 ; Branch if plus to $10, $78 [Flow: branch]
	adc $983F38.l,X		; 7F 38 3F 98 ; Add long $983F38.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FCFF3C.l,X		; FF 3C FF FC ; Subtract with carry (long,X) $FCFF3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FBFBFE.l,X		; FF FE FB FB ; Subtract with carry (long,X) $FBFBFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	and $FD62.w,X		; 3D 62 FD ; AND accumulator with memory $FD62.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $E040.w		; 0D 40 E0 ; Logical OR $E040.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $8241BE.l,X		; 3F BE 41 82 ; AND accumulator with memory (long,X) $8241BE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $7DC2.w,X		; 7D C2 7D ; Add $7DC2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $C07D.w,Y		; BE 7D C0 ; Load X register $C07D.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	and $0028FF.l,X		; 3F FF 28 00 ; AND accumulator with memory (long,X) $0028FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $0B.b,S		; 83 0B ; Store accumulator (stack relative) $0B.b,S [Reads: Accumulator, Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $4381.w,X		; 7E 81 43 ; Rotate right $4381.w,X [Reads: X Index] [Flags: ZNC]
	.db $42, $BD		; 42 BD ; Reserved instruction
	tsb $7E.b		; 04 7E ; Test and set bits $7E.b [Reads: Accumulator] [Flags: Z]
	lda $FF00.w,X		; BD 00 FF ; Load $FF00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FF0028.l,X		; FF 28 00 FF ; Subtract with carry (long,X) $FF0028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	adc $880F88.l,X		; 7F 88 0F 88 ; Add long $880F88.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $8C.b,S		; 03 8C ; OR accumulator with stack relative $8C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $88.b		; 04 88 ; Test and set bits $88.b [Reads: Accumulator] [Flags: Z]
	ora $49.b		; 05 49 ; Logical OR $49.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $237FFF.l,X		; FF FF 7F 23 ; Subtract with carry (long,X) $237FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$04.b],Y		; 77 04 ; Add with carry (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $C0.b,Y		; B6 C0 ; Load X register $C0.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	rol $01F0.w,X		; 3E F0 01 ; Rotate left $01F0.w,X [Reads: X Index] [Flags: ZNC]
	eor $F0.b,S		; 43 F0 ; Exclusive OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $DB1FD8.l		; 22 D8 1F DB ; Jump to subroutine long $DB1FD8.l [Writes: Stack Pointer] [Flow: call]
	tsb $DC.b		; 04 DC ; Test and set bits $DC.b [Reads: Accumulator] [Flags: Z]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($C1.b,X)		; 01 C1 ; Logical OR ($C1.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: ZN]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $00FFFE.l,X		; FF FE FF 00 ; Subtract with carry (long,X) $00FFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00847B.l,X		; FF 7B 84 00 ; Subtract with carry (long,X) $00847B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $75CA71.l,X		; FF 71 CA 75 ; Subtract with carry (long,X) $75CA71.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $EE75.w		; CE 75 EE ; Decrement $EE75.w [Flags: ZN]
	adc ($B0.b),Y		; 71 B0 ; Add with carry ($B0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $7B0000.l,X		; 7F 00 00 7B ; Add long $7B0000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $FF.b		; 14 FF ; Test and reset bits $FF.b [Reads: Accumulator] [Flags: Z]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	jmp.w [$E343]		; DC 43 E3 ; Jump long indirect [$E343] [Flow: jump]
	trb $EB1A.w		; 1C 1A EB ; Test and reset bits $EB1A.w [Reads: Accumulator] [Flags: Z]
	trb $00E3.w		; 1C E3 00 ; Test and reset bits $00E3.w [Reads: Accumulator] [Flags: Z]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc ($3F.b),Y		; F1 3F ; Subtract with carry ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $62, $BF, $70		; 62 BF 70 ; Push effective relative address $62, $BF, $70 [Writes: Stack Pointer]
	lda $D8BF50.l,X		; BF 50 BF D8 ; Load long $D8BF50.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $609F70.l,X		; 3F 70 9F 60 ; AND accumulator with memory (long,X) $609F70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $27807F.l,X		; 9F 7F 80 27 ; Store accumulator (long,X) $27807F.l,X [Reads: Accumulator, X Index]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $7FE3.w		; 1C E3 7F ; Test and reset bits $7FE3.w [Reads: Accumulator] [Flags: Z]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	ldx #$7F.b		; A2 7F ; Load #$7F.b into X register [Writes: X Index] [Flags: ZN]
	ldx $BE41.w,Y		; BE 41 BE ; Load X register $BE41.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	adc $FF0080.l,X		; 7F 80 00 FF ; Add long $FF0080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $080800.l,X		; FF 00 08 08 ; Subtract with carry (long,X) $080800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($0B.b,S),Y		; 13 0B ; OR accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($0D.b)		; F2 0D ; Subtract with carry (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	sbc #$15.b		; E9 15 ; Subtract #$15.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	inc $1E.b		; E6 1E ; Increment $1E.b [Reads: Direct Page] [Flags: ZN]
	sbc #$1C.b		; E9 1C ; Subtract #$1C.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	asl $FFF5.w		; 0E F5 FF ; Arithmetic shift left $FFF5.w [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b)		; 12 3F ; OR accumulator with memory (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$87.b		; A0 87 ; Load #$87.b into Y register [Writes: Y Index] [Flags: ZN]
	eor [$8F.b]		; 47 8F ; Exclusive OR accumulator with memory (long) [$8F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $8B4F8C.l		; 4F 8C 4F 8B ; Exclusive OR accumulator with memory (long) $8B4F8C.l [Writes: Accumulator] [Flags: ZN]
	eor $8A6FAB.l		; 4F AB 6F 8A ; Exclusive OR accumulator with memory (long) $8A6FAB.l [Writes: Accumulator] [Flags: ZN]
	adc $381F00.l		; 6F 00 1F 38 ; Add with carry (long) $381F00.l [Writes: Accumulator] [Flags: ZVNC]
	jsl $101630.l		; 22 30 16 10 ; Jump to subroutine long $101630.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $C7		; 10 C7 ; Branch if plus to $10, $C7 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	mvp $39,$01		; 44 01 39 ; Move block positive $39,$01 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sta $83.b,S		; 83 83 ; Store accumulator (stack relative) $83.b,S [Reads: Accumulator, Stack Pointer]
	lsr $C7.b		; 46 C7 ; Logical shift right $C7.b [Reads: Direct Page] [Flags: ZNC]
	lda $C3FF.w,X		; BD FF C3 ; Load $C3FF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00FF7E.l,X		; FF 7E FF 00 ; Subtract with carry (long,X) $00FF7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $C6.b,S		; 83 C6 ; Store accumulator (stack relative) $C6.b,S [Reads: Accumulator, Stack Pointer]
	jmp ($2238.w,X)		; 7C 38 22 ; Jump indirect indexed to ($2238.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $6F44.w		; AD 44 6F ; Load $6F44.w into accumulator [Writes: Accumulator] [Flags: ZN]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ora #$8C.b		; 09 8C ; Logical OR #$8C.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $A64F8F.l		; 4F 8F 4F A6 ; Exclusive OR accumulator with memory (long) $A64F8F.l [Writes: Accumulator] [Flags: ZN]
	ror $90.b		; 66 90 ; Rotate right $90.b [Reads: Direct Page] [Flags: ZNC]
	.db $70, $89		; 70 89 ; Branch if overflow set to $70, $89 [Flow: branch]
	adc $1022.w,Y		; 79 22 10 ; Add $1022.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $30.b		; 14 30 ; Test and reset bits $30.b [Reads: Accumulator] [Flags: Z]
	.db $30, $19		; 30 19 ; Branch if minus to $30, $19 [Flow: branch]
	ora $FFFE06.l		; 0F 06 FE FF ; OR accumulator with memory (long) $FFFE06.l [Writes: Accumulator] [Flags: ZN]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	and $FEFF.w,X		; 3D FF FE ; AND accumulator with memory $FEFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $730707.l,X		; FF 07 07 73 ; Subtract with carry (long,X) $730707.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($89.b,S),Y		; 73 89 ; Add with carry (stack relative indirect indexed) ($89.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FC04.w,Y		; F9 04 FC ; Subtract with carry $FC04.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $0306.w		; 8C 06 03 ; Store Y register to $0306.w [Reads: Y Index]
	cmp $5AC341.l		; CF 41 C3 5A ; Compare accumulator (long) $5AC341.l [Reads: Accumulator] [Flags: ZNC]
	cmp [$74.b]		; C7 74 ; Compare accumulator (long) [$74.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jmp ($1890.w)		; 6C 90 18 ; Jump indirect to ($1890.w) [Flow: jump]
	.db $B0, $3F		; B0 3F ; Branch if carry set to $B0, $3F [Flow: branch]
	sbc $00FF77.l		; EF 77 FF 00 ; Subtract with carry (long) $00FF77.l [Writes: Accumulator] [Flags: ZVNC]
	and ($2C.b),Y		; 31 2C ; AND accumulator with memory ($2C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($67.b,S),Y		; 33 67 ; AND accumulator (stack relative indirect indexed) ($67.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $230025.l,X		; FF 25 00 23 ; Subtract with carry (long,X) $230025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $008483.l,X		; FF 83 84 00 ; Subtract with carry (long,X) $008483.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $0000FF.l		; 22 FF 00 00 ; Jump to subroutine long $0000FF.l [Writes: Stack Pointer] [Flow: call]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FFC019.l,X		; FF 19 C0 FF ; Subtract with carry (long,X) $FFC019.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $102F24.l,X		; 1F 24 2F 10 ; Logical OR long $102F24.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp ($ED.b)		; D2 ED ; Compare accumulator (indirect) ($ED.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc $3F00FF.l,X		; FF FF 00 3F ; Subtract with carry (long,X) $3F00FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $D9F100.l		; CF 00 F1 D9 ; Compare accumulator (long) $D9F100.l [Reads: Accumulator] [Flags: ZNC]
	sbc $0000.w		; ED 00 00 ; Subtract $0000.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	cmp $00.b,S		; C3 00 ; Compare accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $00.b,S		; E3 00 ; Subtract stack-relative $00.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc ($44.b,S),Y		; F3 44 ; Subtract with carry (stack relative indirect indexed) ($44.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F3.b		; 05 F3 ; Logical OR $F3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FF02.w,X		; 7E 02 FF ; Rotate right $FF02.w,X [Reads: X Index] [Flags: ZNC]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FF,$00		; 44 00 FF ; Move block positive $FF,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $00CF00.l,X		; DF 00 CF 00 ; Compare accumulator (long,X) $00CF00.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	cmp [$00.b]		; C7 00 ; Compare accumulator (long) [$00.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	cmp $00.b,S		; C3 00 ; Compare accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $2FE0.w,X		; 7E E0 2F ; Rotate right $2FE0.w,X [Reads: X Index] [Flags: ZNC]
	eor ($B9.b,X)		; 41 B9 ; Exclusive OR accumulator with memory ($B9.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	sbc $14ED15.l		; EF 15 ED 14 ; Subtract with carry (long) $14ED15.l [Writes: Accumulator] [Flags: ZVNC]
	cpx $FE06.w		; EC 06 FE ; Compare $FE06.w with X register [Reads: X Index] [Flags: ZNC]
	ora $00FD.w		; 0D FD 00 ; Logical OR $00FD.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $C6.b		; 04 C6 ; Test and set bits $C6.b [Reads: Accumulator] [Flags: Z]
	sbc ($F0.b,S),Y		; F3 F0 ; Subtract with carry (stack relative indirect indexed) ($F0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($F3.b)		; F2 F3 ; Subtract with carry (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($F2.b),Y		; F1 F2 ; Subtract with carry ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7E		; 80 7E ; Branch always to $80, $7E [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldx $8618.w,Y		; BE 18 86 ; Load X register $8618.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	.db $42, $BE		; 42 BE ; Reserved instruction
	asl $047F.w,X		; 1E 7F 04 ; Arithmetic shift left $047F.w,X [Reads: X Index] [Flags: ZNC]
	bit $92.b		; 24 92 ; Test bits $92.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lda ($FF.b)		; B2 FF ; Load accumulator (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $017F7F.l,X		; FF 7F 7F 01 ; Subtract with carry (long,X) $017F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $DB		; 80 DB ; Branch always to $80, $DB [Flow: branch]
	eor $2E84.w		; 4D 84 2E ; Exclusive OR $2E84.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $34D728.l		; EF 28 D7 34 ; Subtract with carry (long) $34D728.l [Writes: Accumulator] [Flags: ZVNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	cmp $E695.w		; CD 95 E6 ; Compare $E695.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $010022.l,X		; FF 22 00 01 ; Subtract with carry (long,X) $010022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Accumulator, X Index, Direct Page]
	adc $111A71.l,X		; 7F 71 1A 11 ; Add long $111A71.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FB04C1.l		; CF C1 04 FB ; Compare accumulator (long) $FB04C1.l [Reads: Accumulator] [Flags: ZNC]
	sta $48.b,S		; 83 48 ; Store accumulator (stack relative) $48.b,S [Reads: Accumulator, Stack Pointer]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $E480.w,X		; 7E 80 E4 ; Rotate right $E480.w,X [Reads: X Index] [Flags: ZNC]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda [$68.b]		; A7 68 ; Load accumulator (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $70		; B0 70 ; Branch if carry set to $B0, $70 [Flow: branch]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	adc $A03FD1.l,X		; 7F D1 3F A0 ; Add long $A03FD1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $BF60DF.l,X		; 5F DF 60 BF ; Exclusive OR accumulator with memory (long,X) $BF60DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr $00FF.w		; 20 FF 00 ; Jump to subroutine at $00FF.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $40.b		; 02 40 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E70500.l		; 22 00 05 E7 ; Jump to subroutine long $E70500.l [Writes: Stack Pointer] [Flow: call]
	sbc $00FFC3.l,X		; FF C3 FF 00 ; Subtract with carry (long,X) $00FFC3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF45.l,X		; FF 45 FF 00 ; Subtract with carry (long,X) $00FF45.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $03003D.l,X		; FF 3D 00 03 ; Subtract with carry (long,X) $03003D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $451F96.l		; 4F 96 1F 45 ; Exclusive OR accumulator with memory (long) $451F96.l [Writes: Accumulator] [Flags: ZN]
	lda $073F.w		; AD 3F 07 ; Load $073F.w into accumulator [Writes: Accumulator] [Flags: ZN]
	ldx $3F.b,Y		; B6 3F ; Load X register $3F.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora $304FCD.l,X		; 1F CD 4F 30 ; Logical OR long $304FCD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $40.b,S		; 23 40 ; AND accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$60.b]		; 07 60 ; OR accumulator with memory (long) [$60.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $BD		; 30 BD ; Branch if minus to $30, $BD [Flow: branch]
	sbc $7DFFC2.l,X		; FF C2 FF 7D ; Subtract with carry (long,X) $7DFFC2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $1B43.w,X		; FE 43 1B ; Increment memory $1B43.w,X [Reads: X Index] [Flags: ZN]
	jsr ($7D05.w,X)		; FC 05 7D ; Jump to subroutine indirect indexed ($7D05.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FFC2.w,X		; FE C2 FF ; Increment memory $FFC2.w,X [Reads: X Index] [Flags: ZN]
	and $27FF.w,X		; 3D FF 27 ; AND accumulator with memory $27FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $F74300.l,X		; FF 00 43 F7 ; Subtract with carry (long,X) $F74300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $877803.l		; 0F 03 78 87 ; OR accumulator with memory (long) $877803.l [Writes: Accumulator] [Flags: ZN]
	and $0027C0.l,X		; 3F C0 27 00 ; AND accumulator with memory (long,X) $0027C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $FF03.w		; 0E 03 FF ; Arithmetic shift left $FF03.w [Flags: ZNC]
	.db $30, $CF		; 30 CF ; Branch if minus to $30, $CF [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	lda [$9C.b]		; A7 9C ; Load accumulator (long) [$9C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $DF.b,S		; 63 DF ; Add with carry (stack relative) $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$9F.b		; E0 9F ; Compare #$9F.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx $50.b		; E4 50 ; Compare $50.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sep #$01		; E2 01 ; Set processor status bits #$01 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc ($00.b),Y		; F1 00 ; Subtract with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $3FFF7F.l,X		; FF 7F FF 3F ; Subtract with carry (long,X) $3FFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $227E00.l,X		; FF 00 7E 22 ; Subtract with carry (long,X) $227E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $233F00.l,X		; 7F 00 3F 23 ; Add long $233F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3800FF.l,X		; FF FF 00 38 ; Subtract with carry (long,X) $3800FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000001.l,X		; FF 01 00 00 ; Subtract with carry (long,X) $000001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $3F0700.l		; 22 00 07 3F ; Jump to subroutine long $3F0700.l [Writes: Stack Pointer] [Flow: call]
	cpy #$57.b		; C0 57 ; Compare #$57.b with Y register [Reads: Y Index] [Flags: ZNC]
	lda [$A8.b],Y		; B7 A8 ; Load accumulator (long indexed) [$A8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $4368A7.l		; 6F A7 68 43 ; Add with carry (long) $4368A7.l [Writes: Accumulator] [Flags: ZVNC]
	lda $AC4367.l		; AF 67 43 AC ; Load long $AC4367.l into accumulator [Writes: Accumulator] [Flags: ZN]
	adc [$03.b]		; 67 03 ; Add with carry (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	and $17.b,S		; 23 17 ; AND accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stx $2E.b		; 86 2E ; Store X register to $2E.b [Reads: X Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0043.l,X		; FF 43 00 FF ; Subtract with carry (long,X) $FF0043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $2767AC.l		; 4F AC 67 27 ; Exclusive OR accumulator with memory (long) $2767AC.l [Writes: Accumulator] [Flags: ZN]
	ora [$4E.b],Y		; 17 4E ; OR accumulator with memory (long indexed) [$4E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc $250037.l,X		; FF 37 00 25 ; Subtract with carry (long,X) $250037.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $230000.l,X		; FF 00 00 23 ; Subtract with carry (long,X) $230000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $280000.l,X		; FF 00 00 28 ; Subtract with carry (long,X) $280000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $008483.l,X		; FF 83 84 00 ; Subtract with carry (long,X) $008483.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$77.b		; 09 77 ; Logical OR #$77.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $FF.b,X		; 55 FF ; Exclusive OR accumulator with memory $FF.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $55AAAA.l,X		; FF AA AA 55 ; Subtract with carry (long,X) $55AAAA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	eor $55.b,S		; 43 55 ; Exclusive OR accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $88AA01.l,X		; FF 01 AA 88 ; Subtract with carry (long,X) $88AA01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $440000.l		; 22 00 00 44 ; Jump to subroutine long $440000.l [Writes: Stack Pointer] [Flow: call]
	jsl $FC0700.l		; 22 00 07 FC ; Jump to subroutine long $FC0700.l [Writes: Stack Pointer] [Flow: call]
	sta [$C6.b],Y		; 97 C6 ; Store accumulator (long indexed) [$C6.b],Y [Reads: Accumulator, Direct Page, Y Index]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($CE96.w,X)		; FC 96 CE ; Jump to subroutine indirect indexed ($CE96.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta [$A8.b]		; 87 A8 ; Store accumulator (long) [$A8.b] [Reads: Accumulator, Direct Page]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $B8.b,S		; 83 B8 ; Store accumulator (stack relative) $B8.b,S [Reads: Accumulator, Stack Pointer]
	ora $14.b,S		; 03 14 ; OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr ($C496.w,X)		; FC 96 C4 ; Jump to subroutine indirect indexed ($C496.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor ($FB.b,S),Y		; 53 FB ; XOR accumulator (stack relative indirect indexed) ($FB.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sty $D7.b,X		; 94 D7 ; Store Y register $D7.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	adc #$ED.b		; 69 ED ; Add #$ED.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	sta ($F5.b,X)		; 81 F5 ; Store accumulator ($F5.b,X) [Reads: Accumulator, X Index, Direct Page]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	sbc $D5FF8A.l,X		; FF 8A FF D5 ; Subtract with carry (long,X) $D5FF8A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $26DFFF.l,X		; FF FF DF 26 ; Subtract with carry (long,X) $26DFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $24FB00.l,X		; FF 00 FB 24 ; Subtract with carry (long,X) $24FB00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $040027.l,X		; FF 27 00 04 ; Subtract with carry (long,X) $040027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $3FBF00.l,X		; FF 00 BF 3F ; Subtract with carry (long,X) $3FBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$48.b		; E0 48 ; Compare #$48.b with X register [Reads: X Index] [Flags: ZNC]
	adc $C703C0.l,X		; 7F C0 03 C7 ; Add long $C703C0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $244000.l,X		; 7F 00 40 24 ; Add long $244000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0A0026.l,X		; FF 26 00 0A ; Subtract with carry (long,X) $0A0026.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C87ECC.l,X		; FF CC 7E C8 ; Subtract with carry (long,X) $C87ECC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $7ECC.w,X		; 7E CC 7E ; Rotate right $7ECC.w,X [Reads: X Index] [Flags: ZNC]
	cmp $78C777.l		; CF 77 C7 78 ; Compare accumulator (long) $78C777.l [Reads: Accumulator] [Flags: ZNC]
	eor $C0.b		; 45 C0 ; Exclusive OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $000F22.l,X		; 7F 22 0F 00 ; Add long $000F22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E6.b		; E0 E6 ; Compare #$E6.b with X register [Reads: X Index] [Flags: ZNC]
	brk $79.b		; 00 79 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsl $0000FF.l		; 22 FF 00 00 ; Jump to subroutine long $0000FF.l [Writes: Stack Pointer] [Flow: call]
	mvp $FF,$00		; 44 00 FF ; Move block positive $FF,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $C0.b		; 05 C0 ; Logical OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $9F3FA0.l,X		; 7F A0 3F 9F ; Add long $9F3FA0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $7F8043.l,X		; 1F 43 80 7F ; Logical OR long $7F8043.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $1FE000.l,X		; FF 00 E0 1F ; Subtract with carry (long,X) $1FE000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $400080.l,X		; 7F 80 00 40 ; Add long $400080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0043.l,X		; FF 43 00 FF ; Subtract with carry (long,X) $FF0043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7FFE00.l,X		; FF 00 FE 7F ; Subtract with carry (long,X) $7FFE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FB7F.w,X		; FD 7F FB ; Subtract with carry $FB7F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $BF7F87.l,X		; 7F 87 7F BF ; Add long $BF7F87.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $EF7FDF.l,X		; 7F DF 7F EF ; Add long $EF7FDF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $170027.l,X		; 7F 27 00 17 ; Add long $170027.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7EFF00.l,X		; FF 00 FF 7E ; Subtract with carry (long,X) $7EFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7BFE7D.l,X		; FF 7D FE 7B ; Subtract with carry (long,X) $7BFE7D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F807.w,X)		; FC 07 F8 ; Jump to subroutine indirect indexed ($F807.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $F25CF0.l,X		; 3F F0 5C F2 ; AND accumulator with memory (long,X) $F25CF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($0000.w)		; 6C 00 00 ; Jump indirect to ($0000.w) [Flow: jump]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $4FE50D.l,X		; 1F 0D E5 4F ; Logical OR long $4FE50D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $FF004E.l,X		; FF 4E 00 FF ; Subtract with carry (long,X) $FF004E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $FCFF.w,X		; FE FF FC ; Increment memory $FCFF.w,X [Reads: X Index] [Flags: ZN]
	sbc $FCFFF9.l,X		; FF F9 FF FC ; Subtract with carry (long,X) $FCFFF9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF2EFE.l,X		; FF FE 2E FF ; Subtract with carry (long,X) $FF2EFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: ZNC]
	sbc $3C06.w,Y		; F9 06 3C ; Subtract with carry $3C06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C0FF07.l,X		; FF 07 FF C0 ; Subtract with carry (long,X) $C0FF07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF35F8.l,X		; FF F8 35 FF ; Subtract with carry (long,X) $FF35F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF2500.l,X		; FF 00 25 FF ; Subtract with carry (long,X) $FF2500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFF4FF.l,X		; FF FF F4 FF ; Subtract with carry (long,X) $FFF4FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FF.b		; E6 FF ; Increment $FF.b [Reads: Direct Page] [Flags: ZN]
	dec $FEFF.w		; CE FF FE ; Decrement $FEFF.w [Flags: ZN]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $7F.b		; 02 7F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF257F.l,X		; FF 7F 25 FF ; Subtract with carry (long,X) $FF257F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $00FF4F.l,X		; 7F 4F FF 00 ; Add long $00FF4F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $50, $00		; 50 00 ; Branch if overflow clear to $50, $00 [Flow: branch]
	sbc $603F01.l,X		; FF 01 3F 60 ; Subtract with carry (long,X) $603F01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $40.b		; 24 40 ; Test bits $40.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FC0307.l,X		; FF 07 03 FC ; Subtract with carry (long,X) $FC0307.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $E01FF0.l		; 0F F0 1F E0 ; OR accumulator with memory (long) $E01FF0.l [Writes: Accumulator] [Flags: ZN]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpy #$07.b		; C0 07 ; Compare #$07.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $47.b,S		; 63 47 ; Add with carry (stack relative) $47.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	eor $3F7F5F.l		; 4F 5F 7F 3F ; Exclusive OR accumulator with memory (long) $3F7F5F.l [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $C00004.l,X		; FF 04 00 C0 ; Subtract with carry (long,X) $C00004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $49609F.l,X		; 3F 9F 60 49 ; AND accumulator with memory (long,X) $49609F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $FF0240.l,X		; BF 40 02 FF ; Load long $FF0240.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$9F.b		; C0 9F ; Compare #$9F.b with Y register [Reads: Y Index] [Flags: ZNC]
	bit $BF.b		; 24 BF ; Test bits $BF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($06F9.w,X)		; FC F9 06 ; Jump to subroutine indirect indexed ($06F9.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor #$FD.b		; 49 FD ; Exclusive OR #$FD.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $24F903.l,X		; FF 03 F9 24 ; Subtract with carry (long,X) $24F903.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $060B.w,X		; FD 0B 06 ; Subtract with carry $060B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $EF1FF6.l		; 0F F6 1F EF ; OR accumulator with memory (long) $EF1FF6.l [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	inc $16FF.w,X		; FE FF 16 ; Increment memory $16FF.w,X [Reads: X Index] [Flags: ZN]
	sbc [$43.b],Y		; F7 43 ; Subtract with carry (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $041FFF.l,X		; 1F FF 1F 04 ; Logical OR long $041FFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cpx $00.b		; E4 00 ; Compare $00.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $DF		; 30 DF ; Branch if minus to $30, $DF [Flow: branch]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: ZNC]
	sbc ($EE.b),Y		; F1 EE ; Subtract with carry ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $FFFEF1.l,X		; 7F F1 FE FF ; Add long $FFFEF1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp.w [$F4FF]		; DC FF F4 ; Jump long indirect [$F4FF] [Flow: jump]
	sbc [$20.b],Y		; F7 20 ; Subtract with carry (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	jsr $4301.w		; 20 01 43 ; Jump to subroutine at $4301.w [Writes: Stack Pointer] [Flow: call]
	ora $309FFF.l,X		; 1F FF 9F 30 ; Logical OR long $309FFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $48FF00.l,X		; FF 00 FF 48 ; Subtract with carry (long,X) $48FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $02C3.w,X		; 7E C3 02 ; Rotate right $02C3.w,X [Reads: X Index] [Flags: ZNC]
	sbc $22FF7E.l,X		; FF 7E FF 22 ; Subtract with carry (long,X) $22FF7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0008.w,X		; 3C 08 00 ; Test bits $0008.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E6FFCE.l,X		; FF CE FF E6 ; Subtract with carry (long,X) $E6FFCE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF22F4.l,X		; FF F4 22 FF ; Subtract with carry (long,X) $FF22F4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	sbc $07FFC0.l,X		; FF C0 FF 07 ; Subtract with carry (long,X) $07FFC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc $FB060B.l,X		; FF 0B 06 FB ; Subtract with carry (long,X) $FB060B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $E710F7.l		; 0F F7 10 E7 ; OR accumulator with memory (long) $E710F7.l [Writes: Accumulator] [Flags: ZN]
	cpx #$0F.b		; E0 0F ; Compare #$0F.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$EF.b		; E0 EF ; Compare #$EF.b with X register [Reads: X Index] [Flags: ZNC]
	cop $ED.b		; 02 ED ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $08041F.l		; EF 1F 04 08 ; Subtract with carry (long) $08041F.l [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	cmp $10FFE0.l,X		; DF E0 FF 10 ; Compare accumulator (long,X) $10FFE0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $0FFE01.l,X		; FF 01 FE 0F ; Subtract with carry (long,X) $0FFE01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($0E.b),Y		; F1 0E ; Subtract with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$4C.b],Y		; F7 4C ; Subtract with carry (long indexed) [$4C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda [$0C.b],Y		; B7 0C ; Load accumulator (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$20.b],Y		; F7 20 ; Subtract with carry (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F801.w,X		; FE 01 F8 ; Increment memory $F801.w,X [Reads: X Index] [Flags: ZN]
	ora [$E0.b]		; 07 E0 ; OR accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $8F3CC3.l,X		; 1F C3 3C 8F ; Logical OR long $8F3CC3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $1F		; 70 1F ; Branch if overflow set to $70, $1F [Flow: branch]
	cpx #$27.b		; E0 27 ; Compare #$27.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $0FF009.l,X		; FF 09 F0 0F ; Subtract with carry (long,X) $0FF009.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$F1.b]		; C7 F1 ; Compare accumulator (long) [$F1.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	asl $E145.w		; 0E 45 E1 ; Arithmetic shift left $E145.w [Flags: ZNC]
	asl $FF27.w,X		; 1E 27 FF ; Arithmetic shift left $FF27.w,X [Reads: X Index] [Flags: ZNC]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $8EE1.w,X		; 1E E1 8E ; Arithmetic shift left $8EE1.w,X [Reads: X Index] [Flags: ZNC]
	adc ($C4.b),Y		; 71 C4 ; Add with carry ($C4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $E4.b,S		; 43 E4 ; Exclusive OR accumulator with stack relative $E4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($CF.b,X)		; 01 CF ; Logical OR ($CF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $30, $27		; 30 27 ; Branch if minus to $30, $27 [Flow: branch]
	sbc $E00037.l,X		; FF 37 00 E0 ; Subtract with carry (long,X) $E00037.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($D9.b,X)		; 21 D9 ; Logical AND ($D9.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rol $7CBB.w,X		; 3E BB 7C ; Rotate left $7CBB.w,X [Reads: X Index] [Flags: ZNC]
	adc [$F8.b],Y		; 77 F8 ; Add with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E0DFF0.l		; EF F0 DF E0 ; Subtract with carry (long) $E0DFF0.l [Writes: Accumulator] [Flags: ZVNC]
	lda $807FC0.l,X		; BF C0 7F 80 ; Load long $807FC0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $7C3E00.l,X		; FF 00 3E 7C ; Subtract with carry (long,X) $7C3E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E7F3.w,Y		; F9 F3 E7 ; Subtract with carry $E7F3.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FE3F9F.l		; CF 9F 3F FE ; Compare accumulator (long) $FE3F9F.l [Reads: Accumulator] [Flags: ZNC]
	ora ($C0.b,X)		; 01 C0 ; Logical OR ($C0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $B06798.l,X		; 3F 98 67 B0 ; AND accumulator with memory (long,X) $B06798.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $435FA0.l		; 4F A0 5F 43 ; Exclusive OR accumulator with memory (long) $435FA0.l [Writes: Accumulator] [Flags: ZN]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $98C3.w,X		; FE C3 98 ; Increment memory $98C3.w,X [Reads: X Index] [Flags: ZN]
	.db $B0, $A0		; B0 A0 ; Branch if carry set to $B0, $A0 [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $609F05.l,X		; BF 05 9F 60 ; Load long $609F05.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $BF2400.l,X		; FF 00 24 BF ; Subtract with carry (long,X) $BF2400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $9F.b		; 02 9F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: ZNC]
	eor #$FD.b		; 49 FD ; Exclusive OR #$FD.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0306.w,Y		; F9 06 03 ; Subtract with carry $0306.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($00FF.w,X)		; FC FF 00 ; Jump to subroutine indirect indexed ($00FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $FD.b		; 24 FD ; Test bits $FD.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $F9.b,X		; 15 F9 ; OR accumulator with memory $F9.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	inc $DF3F.w,X		; FE 3F DF ; Increment memory $DF3F.w,X [Reads: X Index] [Flags: ZN]
	sbc $FFFB3F.l,X		; FF 3F FB FF ; Subtract with carry (long,X) $FFFB3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FF07FF.l		; 0F FF 07 FF ; OR accumulator with memory (long) $FF07FF.l [Writes: Accumulator] [Flags: ZN]
	jsl $FF02DF.l		; 22 DF 02 FF ; Jump to subroutine long $FF02DF.l [Writes: Stack Pointer] [Flow: call]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FC00.w		; 20 00 FC ; Jump to subroutine at $FC00.w [Writes: Stack Pointer] [Flow: call]
	sbc $7FEFEC.l,X		; FF EC EF 7F ; Subtract with carry (long,X) $7FEFEC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($FF3F.w,X)		; FC 3F FF ; Jump to subroutine indirect indexed ($FF3F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $12FF90.l,X		; FF 90 FF 12 ; Subtract with carry (long,X) $12FF90.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF10.w,X		; FD 10 FF ; Subtract with carry $FF10.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($A0.b)		; 92 A0 ; Store accumulator (indirect) ($A0.b) [Reads: Accumulator, Direct Page]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $02.b,Y		; B6 02 ; Load X register $02.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	jsl $020700.l		; 22 00 07 02 ; Jump to subroutine long $020700.l [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $18CB.w		; 4C CB 18 ; Jump to $18CB.w [Flow: jump]
	eor $D3.b,S		; 43 D3 ; Exclusive OR accumulator with stack relative $D3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $08		; 30 08 ; Branch if minus to $30, $08 [Flow: branch]
	sbc ($10.b),Y		; F1 10 ; Subtract with carry ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $001C.w		; EC 1C 00 ; Compare $001C.w with X register [Reads: X Index] [Flags: ZNC]
	and ($67.b,S),Y		; 33 67 ; AND accumulator (stack relative indirect indexed) ($67.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $47044F.l		; 22 4F 04 47 ; Jump to subroutine long $47044F.l [Writes: Stack Pointer] [Flow: call]
	eor $FB.b,S		; 43 FB ; Exclusive OR accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol $E5.b		; 26 E5 ; Rotate left $E5.b [Reads: Direct Page] [Flags: ZNC]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $3C02.w,X		; FD 02 3C ; Subtract with carry $3C02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $81.b,S		; 43 81 ; Exclusive OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $FF06.w,X		; 7E 06 FF ; Rotate right $FF06.w,X [Reads: X Index] [Flags: ZNC]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $42, $42		; 42 42 ; Reserved instruction
	ror $0022.w,X		; 7E 22 00 ; Rotate right $0022.w,X [Reads: X Index] [Flags: ZNC]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $608000.l,X		; 7F 00 80 60 ; Add long $608000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	lda $C00A3F.l,X		; BF 3F 0A C0 ; Load long $C00A3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FF7F80.l,X		; 7F 80 7F FF ; Add long $FF7F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $40407F.l,X		; 7F 7F 40 40 ; Add long $40407F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $B50300.l		; 22 00 03 B5 ; Jump to subroutine long $B50300.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $E7		; 42 E7 ; Reserved instruction
	bit $4A.b		; 24 4A ; Test bits $4A.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lda $66.b		; A5 66 ; Load $66.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: ZNC]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: ZNC]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $64.b,S		; A3 64 ; Load accumulator (stack relative) $64.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx $23.b		; E4 23 ; Compare $23.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	jmp.w [$A07B]		; DC 7B A0 ; Jump long indirect [$A07B] [Flow: jump]
	and $FF40C0.l,X		; 3F C0 40 FF ; AND accumulator with memory (long,X) $FF40C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $1F00FF.l,X		; 3F FF 00 1F ; AND accumulator with memory (long,X) $1F00FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $A50000.l,X		; 3F 00 00 A5 ; AND accumulator with memory (long,X) $A50000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $E7.b		; 66 E7 ; Rotate right $E7.b [Reads: Direct Page] [Flags: ZNC]
	bit $DB.b		; 24 DB ; Test bits $DB.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $7EC3.w,X		; 3C C3 7E ; Test bits $7EC3.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc [$66.b]		; E7 66 ; Subtract with carry (long) [$66.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda $437E.w,X		; BD 7E 43 ; Load $437E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $180400.l,X		; FF 00 04 18 ; Subtract with carry (long,X) $180400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $400700.l		; 22 00 07 40 ; Jump to subroutine long $400700.l [Writes: Stack Pointer] [Flow: call]
	lda $E4DFA0.l,X		; BF A0 DF E4 ; Load long $E4DFA0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0EA2.w		; 0C A2 0E ; Test and set bits $0EA2.w [Reads: Accumulator] [Flags: Z]
	eor $B2.b,S		; 43 B2 ; Exclusive OR accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $07.b,X		; 56 07 ; Logical shift right $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldy $46.b,X		; B4 46 ; Load Y register $46.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $B0, $5A		; B0 5A ; Branch if carry set to $B0, $5A [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($51.b,S),Y		; 13 51 ; OR accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $450049.l		; 22 49 00 45 ; Jump to subroutine long $450049.l [Writes: Stack Pointer] [Flow: call]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($3F.b)		; 12 3F ; OR accumulator with memory (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $E42C.w		; EC 2C E4 ; Compare $E42C.w with X register [Reads: X Index] [Flags: ZNC]
	bit $F0.b		; 24 F0 ; Test bits $F0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	adc $5E4F40.l,X		; 7F 40 4F 5E ; Add long $5E4F40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($5B.b,S),Y		; 53 5B ; XOR accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $7FFF4E.l		; 4F 4E FF 7F ; Exclusive OR accumulator with memory (long) $7FFF4E.l [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	adc $9F1F43.l,X		; 7F 43 1F 9F ; Add long $9F1F43.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $3E.b,S		; 43 3E ; Exclusive OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldx $3F43.w,Y		; BE 43 3F ; Load X register $3F43.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	lda $BE3E0B.l,X		; BF 0B 3E BE ; Load long $BE3E0B.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $609C.w		; 1C 9C 60 ; Test and reset bits $609C.w [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor ($41.b,X)		; 41 41 ; Exclusive OR accumulator with memory ($41.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor $47.b,S		; 43 47 ; Exclusive OR accumulator with stack relative $47.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $FFFE43.l		; 6F 43 FE FF ; Add with carry (long) $FFFE43.l [Writes: Accumulator] [Flags: ZVNC]
	eor $7E.b,S		; 43 7E ; Exclusive OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $E1E003.l,X		; 7F 03 E0 E1 ; Add long $E1E003.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $85.b		; 86 85 ; Store X register to $85.b [Reads: X Index]
	eor $0C.b,S		; 43 0C ; Exclusive OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$11.b		; 09 11 ; Logical OR #$11.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $70, $12		; 70 12 ; Branch if overflow set to $70, $12 [Flow: branch]
	stx $BE.b		; 86 BE ; Store X register to $BE.b [Reads: X Index]
	inc $FAFC.w,X		; FE FC FA ; Increment memory $FAFC.w,X [Reads: X Index] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ora ($F6.b),Y		; 11 F6 ; OR accumulator with memory ($F6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp ($FC.b,S),Y		; D3 FC ; Compare accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $AA85FC.l		; 0F FC 85 AA ; OR accumulator with memory (long) $AA85FC.l [Writes: Accumulator] [Flags: ZN]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$2C.b		; 09 2C ; Logical OR #$2C.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cmp [$03.b]		; C7 03 ; Compare accumulator (long) [$03.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta $B4.b,S		; 83 B4 ; Store accumulator (stack relative) $B4.b,S [Reads: Accumulator, Stack Pointer]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $070303.l		; 2F 03 03 07 ; AND accumulator with memory (long) $070303.l [Writes: Accumulator] [Flags: ZN]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1D1D.w		; 0E 1D 1D ; Arithmetic shift left $1D1D.w [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $DFDFEF.l		; EF EF DF DF ; Subtract with carry (long) $DFDFEF.l [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F1F8.w,X)		; FC F8 F1 ; Jump to subroutine indirect indexed ($F1F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sep #$C4		; E2 C4 ; Set processor status bits #$C4 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jmp.w [$EEDC]		; DC DC EE ; Jump long indirect [$EEDC] [Flow: jump]
	inc $F7F7.w		; EE F7 F7 ; Increment $F7F7.w [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $478F1F.l,X		; 3F 1F 8F 47 ; AND accumulator with memory (long,X) $478F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $85.b		; 04 85 ; Test and set bits $85.b [Reads: Accumulator] [Flags: Z]
	jsr $0401.w		; 20 01 04 ; Jump to subroutine at $0401.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $10FFF0.l,X		; 1F F0 FF 10 ; Logical OR long $10FFF0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sty $C3.b		; 84 C3 ; Store Y register to $C3.b [Reads: Y Index]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	sta $CC.b,S		; 83 CC ; Store accumulator (stack relative) $CC.b,S [Reads: Accumulator, Stack Pointer]
	cop $85.b		; 02 85 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($EE.b),Y		; 31 EE ; AND accumulator with memory ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $FF0EF1.l,X		; 1F F1 0E FF ; Logical OR long $FF0EF1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	mvp $86,$BF		; 44 BF 86 ; Move block positive $86,$BF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cmp [$2F.b],Y		; D7 2F ; Compare accumulator (long indexed) [$2F.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and [$F7.b],Y		; 37 F7 ; AND accumulator with memory (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc [$07.b],Y		; F7 07 ; Subtract with carry (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $40C000.l,X		; BF 00 C0 40 ; Load long $40C000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00FF7F.l,X		; FF 7F FF 00 ; Subtract with carry (long,X) $00FF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $00003F.l,X		; 7F 3F 00 00 ; Add long $00003F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $80.b,X		; 95 80 ; Store accumulator to $80.b,X [Reads: Accumulator, X Index]
	tsb $27.b		; 04 27 ; Test and set bits $27.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $240022.l,X		; FF 22 00 24 ; Subtract with carry (long,X) $240022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $240000.l,X		; FF 00 00 24 ; Subtract with carry (long,X) $240000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $4F0022.l,X		; FF 22 00 4F ; Subtract with carry (long,X) $4F0022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $D0, $40		; D0 40 ; Branch if not equal to $D0, $40 [Flow: branch]
	and [$3F.b]		; 27 3F ; AND accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF0000.l		; 22 00 00 FF ; Jump to subroutine long $FF0000.l [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F047E0.l,X		; FF E0 47 F0 ; Subtract with carry (long,X) $F047E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $C31EE1.l		; 0F E1 1E C3 ; OR accumulator with memory (long) $C31EE1.l [Writes: Accumulator] [Flags: ZN]
	bit $7987.w,X		; 3C 87 79 ; Test bits $7987.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $1EF3.w		; 0E F3 1E ; Arithmetic shift left $1EF3.w [Flags: ZNC]
	sbc $3F.b,S		; E3 3F ; Subtract stack-relative $3F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp #$77.b		; C9 77 ; Compare #$77.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	stz $E0F0.w		; 9C F0 E0 ; Store zero to $E0F0.w
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$57.b		; A0 57 ; Load #$57.b into Y register [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $5F.b		; A5 5F ; Load $5F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $6F.b,X		; B5 6F ; Load $6F.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc [$BF.b],Y		; 77 BF ; Add with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	sbc $454800.l,X		; FF 00 48 45 ; Subtract with carry (long,X) $454800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	adc $20E000.l,X		; 7F 00 E0 20 ; Add long $20E000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: ZN]
	inc $36.b,X		; F6 36 ; Increment memory $36.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $7FBF00.l,X		; FF 00 BF 7F ; Subtract with carry (long,X) $7FBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	nop		; EA ; No operation
	eor $95.b,X		; 55 95 ; Exclusive OR accumulator with memory $95.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $5F40E0.l,X		; 3F E0 40 5F ; AND accumulator with memory (long,X) $5F40E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7F49.w,Y		; 59 49 7F ; Exclusive OR accumulator with memory $7F49.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $7FFF45.l,X		; 3F 45 FF 7F ; AND accumulator with memory (long,X) $7FFF45.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	adc $C0F008.l,X		; 7F 08 F0 C0 ; Add long $C0F008.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	adc $3E9C1C.l,X		; 7F 1C 9C 3E ; Add long $3E9C1C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $3F45.w,Y		; BE 45 3F ; Load X register $3F45.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	lda $BC3C0D.l,X		; BF 0D 3C BC ; Load long $BC3C0D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $1F9C.w		; 1C 9C 1F ; Test and reset bits $1F9C.w [Reads: Accumulator] [Flags: Z]
	sta $43476F.l,X		; 9F 6F 47 43 ; Store accumulator (long,X) $43476F.l,X [Reads: Accumulator, X Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor $63.b,S		; 43 63 ; Exclusive OR accumulator with stack relative $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $0C.b,S		; 43 0C ; Exclusive OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: ZN]
	stx $85.b		; 86 85 ; Store X register to $85.b [Reads: X Index]
	cpx #$E1.b		; E0 E1 ; Compare #$E1.b with X register [Reads: X Index] [Flags: ZNC]
	eor [$FE.b]		; 47 FE ; Exclusive OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $FAFA0F.l,X		; FF 0F FA FA ; Subtract with carry (long,X) $FAFA0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($3EFE.w,X)		; FC FE 3E ; Jump to subroutine indirect indexed ($3EFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl $12.b		; 06 12 ; Arithmetic shift left $12.b [Reads: Direct Page] [Flags: ZNC]
	.db $70, $0C		; 70 0C ; Branch if overflow set to $70, $0C [Flow: branch]
	sbc [$0C.b],Y		; F7 0C ; Subtract with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	ora $02C087.l		; 0F 87 C0 02 ; OR accumulator with memory (long) $02C087.l [Writes: Accumulator] [Flags: ZN]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($22.b,S),Y		; F3 22 ; Subtract with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0002.w,Y		; 39 02 00 ; AND accumulator with memory $0002.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $EFEFDF.l,X		; DF DF EF EF ; Compare accumulator (long,X) $EFEFDF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0E1D.w,X		; 1D 1D 0E ; OR accumulator with memory $0E1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0707.w		; 0E 07 07 ; Arithmetic shift left $0707.w [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr $8810.w		; 20 10 88 ; Jump to subroutine at $8810.w [Writes: Stack Pointer] [Flow: call]
	cpy $E2.b		; C4 E2 ; Compare $E2.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	sbc ($F8.b),Y		; F1 F8 ; Subtract with carry ($F8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($FBFB.w,X)		; FC FB FB ; Jump to subroutine indirect indexed ($FBFB.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $DCEE.w		; EE EE DC ; Increment $DCEE.w [Flags: ZN]
	jmp.w [$B8B8]		; DC B8 B8 ; Jump long indirect [$B8B8] [Flow: jump]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor [$8F.b]		; 47 8F ; Exclusive OR accumulator with memory (long) [$8F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $FF103F.l,X		; 1F 3F 10 FF ; Logical OR long $FF103F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($DE.b),Y		; 31 DE ; AND accumulator with memory ($DE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	and [$FC.b],Y		; 37 FC ; AND accumulator with memory (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta [$10.b]		; 87 10 ; Store accumulator (long) [$10.b] [Reads: Accumulator, Direct Page]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	pea $8E89.w		; F4 89 8E ; Push absolute address $8E89.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $E4FF00.l		; 4F 00 FF E4 ; Exclusive OR accumulator with memory (long) $E4FF00.l [Writes: Accumulator] [Flags: ZN]
	jsr $4E00.w		; 20 00 4E ; Jump to subroutine at $4E00.w [Writes: Stack Pointer] [Flow: call]
	sbc $002800.l,X		; FF 00 28 00 ; Subtract with carry (long,X) $002800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $00FF.w		; 4E FF 00 ; Logical shift right $00FF.w [Flags: ZNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	lsr $FD.b		; 46 FD ; Logical shift right $FD.b [Reads: Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: ZNC]
	sbc $01FE.w,X		; FD FE 01 ; Subtract with carry $01FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $240001.l,X		; FF 01 00 24 ; Subtract with carry (long,X) $240001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($0022.w,X)		; FC 22 00 ; Jump to subroutine indirect indexed ($0022.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $1F0200.l,X		; FF 00 02 1F ; Subtract with carry (long,X) $1F0200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF227F.l,X		; FF 7F 22 FF ; Subtract with carry (long,X) $FF227F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $2700FF.l		; 4F FF 00 27 ; Exclusive OR accumulator with memory (long) $2700FF.l [Writes: Accumulator] [Flags: ZN]
	sbc $00970F.l,X		; FF 0F 97 00 ; Subtract with carry (long,X) $00970F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00A400.l,X		; FF 00 A4 00 ; Subtract with carry (long,X) $00A400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $00.b,Y		; 96 00 ; Store X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	adc $003700.l,X		; 7F 00 37 00 ; Add long $003700.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $C800.w		; 4D 00 C8 ; Exclusive OR $C800.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $EF23E0.l,X		; FF E0 23 EF ; Subtract with carry (long,X) $EF23E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $36DB.w		; 1C DB 36 ; Test and reset bits $36DB.w [Reads: Accumulator] [Flags: Z]
	ldy $727B.w		; AC 7B 72 ; Load $727B.w into Y register [Writes: Y Index] [Flags: ZN]
	cmp $E5BA.w		; CD BA E5 ; Compare $E5BA.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ldy $EB.b,X		; B4 EB ; Load Y register $EB.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	trb $EF.b		; 14 EF ; Test and reset bits $EF.b [Reads: Accumulator] [Flags: Z]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	lda [$7B.b],Y		; B7 7B ; Load accumulator (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $B4E5.w		; CD E5 B4 ; Compare $B4E5.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	ora [$DB.b],Y		; 17 DB ; OR accumulator with memory (long indexed) [$DB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F60A.w,X		; FD 0A F6 ; Subtract with carry $F60A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and #$DF.b		; 29 DF ; Logical AND #$DF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jsr $01FE.w		; 20 FE 01 ; Jump to subroutine at $01FE.w [Writes: Stack Pointer] [Flow: call]
	sbc $F702.w,X		; FD 02 F7 ; Subtract with carry $F702.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda #$A6.b		; A9 A6 ; Load #$A6.b into accumulator [Writes: Accumulator] [Flags: ZN]
	sta $F3E9FE.l,X		; 9F FE E9 F3 ; Store accumulator (long,X) $F3E9FE.l,X [Reads: Accumulator, X Index]
	sbc $43C300.l,X		; FF 00 C3 43 ; Subtract with carry (long,X) $43C300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $1BBD.w,X		; 3C BD 1B ; Test bits $1BBD.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3D.b,X)		; 01 3D ; Logical OR ($3D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp $DB.b,S		; C3 DB ; Compare accumulator (stack relative) $DB.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc ($E9.b,X)		; E1 E9 ; Subtract with carry ($E9.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$DE.b		; C0 DE ; Compare #$DE.b with Y register [Reads: Y Index] [Flags: ZNC]
	bit $4242.w,X		; 3C 42 42 ; Test bits $4242.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $24C2.w,X		; 3D C2 24 ; AND accumulator with memory $24C2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $21.b,X		; 16 21 ; Arithmetic shift left $21.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $1CBE.w,X		; 3E BE 1C ; Rotate left $1CBE.w,X [Reads: X Index] [Flags: ZNC]
	sta $E300.w,X		; 9D 00 E3 ; Store accumulator to $E300.w,X [Reads: Accumulator, X Index]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $EB.b,S		; E3 EB ; Subtract stack-relative $EB.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	eor $F3.b		; 45 F3 ; Exclusive OR $F3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $41.b		; 04 41 ; Test and set bits $41.b [Reads: Accumulator] [Flags: Z]
	.db $62, $1C, $E3		; 62 1C E3 ; Push effective relative address $62, $1C, $E3 [Writes: Stack Pointer]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	tsb $E4.b		; 04 E4 ; Test and set bits $E4.b [Reads: Accumulator] [Flags: Z]
	eor $FE0000.l,X		; 5F 00 00 FE ; Exclusive OR accumulator with memory (long,X) $FE0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp $80FF.w		; 4C FF 80 ; Jump to $80FF.w [Flow: jump]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $00FE26.l,X		; FF 26 FE 00 ; Subtract with carry (long,X) $00FE26.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $97.b		; E4 97 ; Compare $97.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $DF.b,S		; 23 DF ; AND accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $76F9.w,X		; 3C F9 76 ; Test bits $76F9.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $CD32.w,X		; FD 32 CD ; Subtract with carry $CD32.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($A1.b)		; 32 A1 ; AND accumulator with memory (indirect) ($A1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $58A7.w,X		; 5E A7 58 ; Logical shift right $58A7.w,X [Reads: X Index] [Flags: ZNC]
	sta $50AF70.l		; 8F 70 AF 50 ; Store accumulator (long) $50AF70.l [Reads: Accumulator]
	lda $3276.w,X		; BD 76 32 ; Load $3276.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($5E.b)		; 32 5E ; AND accumulator with memory (indirect) ($5E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $5773.w,Y		; 59 73 57 ; Exclusive OR accumulator with memory $5773.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $42BD00.l,X		; FF 00 BD 42 ; Subtract with carry (long,X) $42BD00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpx $CF.b		; E4 CF ; Compare $CF.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $30, $E7		; 30 E7 ; Branch if minus to $30, $E7 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $E2.b		; 84 E2 ; Store Y register to $E2.b [Reads: Y Index]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $3BFD.w,X		; FE FD 3B ; Increment memory $3BFD.w,X [Reads: X Index] [Flags: ZN]
	sta $E7EBCF.l,X		; 9F CF EB E7 ; Store accumulator (long,X) $E7EBCF.l,X [Reads: Accumulator, X Index]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $45DE.w,X		; 1E DE 45 ; Arithmetic shift left $45DE.w,X [Reads: X Index] [Flags: ZNC]
	and $1E07BF.l,X		; 3F BF 07 1E ; AND accumulator with memory (long,X) $1E07BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec $C100.w,X		; DE 00 C1 ; Decrement memory $C100.w,X [Reads: X Index] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $2221.w,X		; DE 21 22 ; Decrement memory $2221.w,X [Reads: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	tsb $3E21.w		; 0C 21 3E ; Test and set bits $3E21.w [Reads: Accumulator] [Flags: Z]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $00.b		; 64 00 ; Store zero to $00.b
	sta $0C7300.l		; 8F 00 73 0C ; Store accumulator (long) $0C7300.l [Reads: Accumulator]
	adc $5E1E.w		; 6D 1E 5E ; Add $5E1E.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	eor $1E.b		; 45 1E ; Exclusive OR $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $9B04.w,X		; DE 04 9B ; Decrement memory $9B04.w,X [Reads: X Index] [Flags: ZN]
	.db $70, $8C		; 70 8C ; Branch if overflow set to $70, $8C [Flow: branch]
	sta ($A1.b)		; 92 A1 ; Store accumulator (indirect) ($A1.b) [Reads: Accumulator, Direct Page]
	jsl $77E421.l		; 22 21 E4 77 ; Jump to subroutine long $77E421.l [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	rol $E5.b		; 26 E5 ; Rotate left $E5.b [Reads: Direct Page] [Flags: ZNC]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $3C02.w,X		; FD 02 3C ; Subtract with carry $3C02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $81.b,S		; 43 81 ; Exclusive OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $FF06.w,X		; 7E 06 FF ; Rotate right $FF06.w,X [Reads: X Index] [Flags: ZNC]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $42, $42		; 42 42 ; Reserved instruction
	ror $0022.w,X		; 7E 22 00 ; Rotate right $0022.w,X [Reads: X Index] [Flags: ZNC]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $608000.l,X		; 7F 00 80 60 ; Add long $608000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	lda $C00A3F.l,X		; BF 3F 0A C0 ; Load long $C00A3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FF7F80.l,X		; 7F 80 7F FF ; Add long $FF7F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $40407F.l,X		; 7F 7F 40 40 ; Add long $40407F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $B50300.l		; 22 00 03 B5 ; Jump to subroutine long $B50300.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $E7		; 42 E7 ; Reserved instruction
	bit $4A.b		; 24 4A ; Test bits $4A.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lda $66.b		; A5 66 ; Load $66.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$77.b]		; 07 77 ; OR accumulator with memory (long) [$77.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $CF1EEF.l		; 8F EF 1E CF ; Store accumulator (long) $CF1EEF.l [Reads: Accumulator]
	ldy $44DB.w,X		; BC DB 44 ; Load Y register $44DB.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	ldy $E05B.w,X		; BC 5B E0 ; Load Y register $E05B.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $81.b,S		; 83 81 ; Store accumulator (stack relative) $81.b,S [Reads: Accumulator, Stack Pointer]
	.db $80, $5B		; 80 5B ; Branch always to $80, $5B [Flow: branch]
	ldy $BE49.w,X		; BC 49 BE ; Load Y register $BE49.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	stz $DF.b		; 64 DF ; Store zero to $DF.b
	.db $30, $CF		; 30 CF ; Branch if minus to $30, $CF [Flow: branch]
	ldy $FFE3.w,X		; BC E3 FF ; Load Y register $FFE3.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sbc [$BF.b]		; E7 BF ; Subtract with carry (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	lda $C08080.l,X		; BF 80 80 C0 ; Load long $C08080.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	lda $BF40BF.l,X		; BF BF 40 BF ; Load long $BF40BF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldy #$DF.b		; A0 DF ; Load #$DF.b into Y register [Writes: Y Index] [Flags: ZN]
	cpx $0C.b		; E4 0C ; Compare $0C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	ldx #$0E.b		; A2 0E ; Load #$0E.b into X register [Writes: X Index] [Flags: ZN]
	eor $B2.b,S		; 43 B2 ; Exclusive OR accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $07.b,X		; 56 07 ; Logical shift right $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldy $46.b,X		; B4 46 ; Load Y register $46.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $B0, $5A		; B0 5A ; Branch if carry set to $B0, $5A [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($51.b,S),Y		; 13 51 ; OR accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $450049.l		; 22 49 00 45 ; Jump to subroutine long $450049.l [Writes: Stack Pointer] [Flow: call]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($3F.b)		; 12 3F ; OR accumulator with memory (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $E42C.w		; EC 2C E4 ; Compare $E42C.w with X register [Reads: X Index] [Flags: ZNC]
	bit $F0.b		; 24 F0 ; Test bits $F0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	adc $5E4F40.l,X		; 7F 40 4F 5E ; Add long $5E4F40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($5B.b,S),Y		; 53 5B ; XOR accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $05FF23.l		; 4F 23 FF 05 ; Exclusive OR accumulator with memory (long) $05FF23.l [Writes: Accumulator] [Flags: ZN]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0F0200.l		; 22 00 02 0F ; Jump to subroutine long $0F0200.l [Writes: Stack Pointer] [Flow: call]
	and $FF227F.l,X		; 3F 7F 22 FF ; AND accumulator with memory (long,X) $FF227F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx $48.b		; E4 48 ; Compare $48.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1C0000.l,X		; FF 00 00 1C ; Subtract with carry (long,X) $1C0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $7B7F67.l,X		; 7F 67 7F 7B ; Add long $7B7F67.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $1C7F67.l,X		; 7F 67 7F 1C ; Add long $1C7F67.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $FF0043.l,X		; 7F 43 00 FF ; Add long $FF0043.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $80.b		; 24 80 ; Test bits $80.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta $2F.b,S		; 83 2F ; Store accumulator (stack relative) $2F.b,S [Reads: Accumulator, Stack Pointer]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($E6.b,X)		; 01 E6 ; Logical OR ($E6.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $DEFF38.l,X		; FF 38 FF DE ; Subtract with carry (long,X) $DEFF38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E6FF38.l,X		; FF 38 FF E6 ; Subtract with carry (long,X) $E6FF38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0025.w,X		; FE 25 00 ; Increment memory $0025.w,X [Reads: X Index] [Flags: ZN]
	ora ($BE.b)		; 12 BE ; OR accumulator with memory (indirect) ($BE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jmp $E96DE2.l		; 5C E2 6D E9 ; Jump long to $E96DE2.l [Flow: jump]
	ror $7DC7.w,X		; 7E C7 7D ; Rotate right $7DC7.w,X [Reads: X Index] [Flags: ZNC]
	sta [$7B.b]		; 87 7B ; Store accumulator (long) [$7B.b] [Reads: Accumulator, Direct Page]
	dec $7C26.w,X		; DE 26 7C ; Decrement memory $7C26.w,X [Reads: X Index] [Flags: ZN]
	sta $2141.w,X		; 9D 41 21 ; Store accumulator to $2141.w,X [Reads: Accumulator, X Index]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$38.b]		; 07 38 ; OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stz $3CE6.w,X		; 9E E6 3C ; Store zero to $3CE6.w,X [Reads: X Index]
	cmp $BB78.w,X		; DD 78 BB ; Compare accumulator $BB78.w,X [Reads: X Index] [Flags: ZNC]
	cpy $07.b		; C4 07 ; Compare $07.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	mvp $C4,$3F		; 44 3F C4 ; Move block positive $C4,$3F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	lda $C09E61.l,X		; BF 61 9E C0 ; Load long $C09E61.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $38.b		; 04 38 ; Test and set bits $38.b [Reads: Accumulator] [Flags: Z]
	.db $80, $E4		; 80 E4 ; Branch always to $80, $E4 [Flow: branch]
	sta ($00.b),Y		; 91 00 ; Store accumulator ($00.b),Y [Reads: Accumulator, Direct Page, Y Index]
	cpx #$32.b		; E0 32 ; Compare #$32.b with X register [Reads: X Index] [Flags: ZNC]
	ldy #$57.b		; A0 57 ; Load #$57.b into Y register [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $5F.b		; A5 5F ; Load $5F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $6F.b,X		; B5 6F ; Load $6F.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc [$BF.b],Y		; 77 BF ; Add with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	sbc $454800.l,X		; FF 00 48 45 ; Subtract with carry (long,X) $454800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	adc $20E000.l,X		; 7F 00 E0 20 ; Add long $20E000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: ZN]
	inc $36.b,X		; F6 36 ; Increment memory $36.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $7FBF00.l,X		; FF 00 BF 7F ; Subtract with carry (long,X) $7FBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	nop		; EA ; No operation
	eor $95.b,X		; 55 95 ; Exclusive OR accumulator with memory $95.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $5F40E0.l,X		; 3F E0 40 5F ; AND accumulator with memory (long,X) $5F40E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7F49.w,Y		; 59 49 7F ; Exclusive OR accumulator with memory $7F49.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $7F003F.l,X		; 3F 3F 00 7F ; AND accumulator with memory (long,X) $7F003F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp $FF00.w		; 4C 00 FF ; Jump to $FF00.w [Flow: jump]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx $48.b		; E4 48 ; Compare $48.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $4304.w,Y		; 39 04 43 ; AND accumulator with memory $4304.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FE0000.l,X		; FF 00 00 FE ; Subtract with carry (long,X) $FE0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	sty $0421.w		; 8C 21 04 ; Store Y register to $0421.w [Reads: Y Index]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $118024.l,X		; FF 24 80 11 ; Subtract with carry (long,X) $118024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $C0.b,S		; 83 C0 ; Store accumulator (stack relative) $C0.b,S [Reads: Accumulator, Stack Pointer]
	and $FFDEE1.l,X		; 3F E1 DE FF ; AND accumulator with memory (long,X) $FFDEE1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: ZNC]
	and $DD1F.w,X		; 3D 1F DD ; AND accumulator with memory $DD1F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$E9.b]		; 07 E9 ; OR accumulator with memory (long) [$E9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $223C01.l,X		; FF 01 3C 22 ; Subtract with carry (long,X) $223C01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$20.b		; C0 20 ; Compare #$20.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sbc $6BDB60.l,X		; FF 60 DB 6B ; Subtract with carry (long,X) $6BDB60.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $DE0D.w,X		; FD 0D DE ; Subtract with carry $DE0D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $D5CC.w		; CE CC D5 ; Decrement $D5CC.w [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cmp ($A8.b,S),Y		; D3 A8 ; Compare accumulator (stack relative indirect indexed) ($A8.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	lda [$49.b],Y		; B7 49 ; Load accumulator (long indexed) [$49.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $00.b,X		; 76 00 ; Rotate right $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $40.b		; 24 40 ; Test bits $40.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	ora $06FE13.l		; 0F 13 FE 06 ; OR accumulator with memory (long) $06FE13.l [Writes: Accumulator] [Flags: ZN]
	sbc $FB2C.w,X		; FD 2C FB ; Subtract with carry $FB2C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc [$38.b],Y		; F7 38 ; Subtract with carry (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$6C.b]		; E7 6C ; Subtract with carry (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $BD.b		; C6 BD ; Decrement $BD.b [Reads: Direct Page] [Flags: ZN]
	sta $7E.b,S		; 83 7E ; Store accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $8100.w		; 6D 00 81 ; Add $8100.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	brk $9D.b		; 00 9D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$42.b		; E0 42 ; Compare #$42.b with X register [Reads: X Index] [Flags: ZNC]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $F9.b,S		; 23 F9 ; AND accumulator with stack relative $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$F3.b]		; 07 F3 ; OR accumulator with memory (long) [$F3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $CF17E7.l		; 8F E7 17 CF ; Store accumulator (long) $CF17E7.l [Reads: Accumulator]
	and [$9F.b]		; 27 9F ; AND accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	sbc $FBFC.w,X		; FD FC FB ; Subtract with carry $FBFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $D3D7.w,Y		; F9 D7 D3 ; Subtract with carry $D3D7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$6F.b],Y		; 77 6F ; Add with carry (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$D8.b		; E0 D8 ; Compare #$D8.b with X register [Reads: X Index] [Flags: ZNC]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy $2EED.w,X		; BC ED 2E ; Load Y register $2EED.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $027D.w,X		; FE 7D 02 ; Increment memory $027D.w,X [Reads: X Index] [Flags: ZN]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	.db $90, $27		; 90 27 ; Branch if carry clear to $90, $27 [Flow: branch]
	eor $91.b,S		; 43 91 ; Exclusive OR accumulator with stack relative $91.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $C1.b		; 02 C1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($B963.w,X)		; 7C 63 B9 ; Jump indirect indexed to ($B963.w,X) [Reads: X Index] [Flow: jump]
	and [$D3.b],Y		; 37 D3 ; AND accumulator with memory (long indexed) [$D3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc [$C9.b]		; 67 C9 ; Add with carry (long) [$C9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and [$C4.b],Y		; 37 C4 ; AND accumulator with memory (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $FF01.w,X		; FE 01 FF ; Increment memory $FF01.w,X [Reads: X Index] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$F5.b],Y		; 17 F5 ; OR accumulator with memory (long indexed) [$F5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($CB.b,S),Y		; F3 CB ; Subtract with carry (stack relative indirect indexed) ($CB.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$14.b]		; C7 14 ; Compare accumulator (long) [$14.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tsb $1824.w		; 0C 24 18 ; Test and set bits $1824.w [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $67E6.w,X		; 3C E6 67 ; Test bits $67E6.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $F338.w		; 0C 38 F3 ; Test and set bits $F338.w [Reads: Accumulator] [Flags: Z]
	sbc [$C3.b]		; E7 C3 ; Subtract with carry (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $FE3E.w,Y		; 99 3E FE ; Store accumulator to $FE3E.w,Y [Reads: Accumulator, Y Index]
	eor $2700FF.l		; 4F FF 00 27 ; Exclusive OR accumulator with memory (long) $2700FF.l [Writes: Accumulator] [Flags: ZN]
	sbc $E00037.l,X		; FF 37 00 E0 ; Subtract with carry (long,X) $E00037.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $EF.b,S		; 23 EF ; AND accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $36DB.w		; 1C DB 36 ; Test and reset bits $36DB.w [Reads: Accumulator] [Flags: Z]
	ldy $727B.w		; AC 7B 72 ; Load $727B.w into Y register [Writes: Y Index] [Flags: ZN]
	cmp $E5BA.w		; CD BA E5 ; Compare $E5BA.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ldy $EB.b,X		; B4 EB ; Load Y register $EB.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	trb $EF.b		; 14 EF ; Test and reset bits $EF.b [Reads: Accumulator] [Flags: Z]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	lda [$7B.b],Y		; B7 7B ; Load accumulator (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $B4E5.w		; CD E5 B4 ; Compare $B4E5.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	ora [$DB.b],Y		; 17 DB ; OR accumulator with memory (long indexed) [$DB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F60A.w,X		; FD 0A F6 ; Subtract with carry $F60A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and #$DF.b		; 29 DF ; Logical AND #$DF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jsr $01FE.w		; 20 FE 01 ; Jump to subroutine at $01FE.w [Writes: Stack Pointer] [Flow: call]
	sbc $F702.w,X		; FD 02 F7 ; Subtract with carry $F702.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$46.b		; E0 46 ; Compare #$46.b with X register [Reads: X Index] [Flags: ZNC]
	lda #$A6.b		; A9 A6 ; Load #$A6.b into accumulator [Writes: Accumulator] [Flags: ZN]
	sta $F3E9FE.l,X		; 9F FE E9 F3 ; Store accumulator (long,X) $F3E9FE.l,X [Reads: Accumulator, X Index]
	sbc $787D7C.l,X		; FF 7C 7D 78 ; Subtract with carry (long,X) $787D7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $B6		; 30 B6 ; Branch if minus to $30, $B6 [Flow: branch]
	ora ($C9.b,X)		; 01 C9 ; Logical OR ($C9.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $36.b		; 06 36 ; Arithmetic shift left $36.b [Reads: Direct Page] [Flags: ZNC]
	cpy #$D0.b		; C0 D0 ; Compare #$D0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cmp ($D9.b,X)		; C1 D9 ; Compare accumulator ($D9.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	cpy #$DE.b		; C0 DE ; Compare #$DE.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $82, $84, $49		; 82 84 49 ; Branch always long to $82, $84, $49 [Flow: branch]
	rol $C9.b,X		; 36 C9 ; Rotate left $C9.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and $7C2126.l		; 2F 26 21 7C ; AND accumulator with memory (long) $7C2126.l [Writes: Accumulator] [Flags: ZN]
	adc $9D1C.w,X		; 7D 1C 9D ; Add $9D1C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($5D.b,X)		; 41 5D ; Exclusive OR accumulator with memory ($5D.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $AB.b,S		; A3 AB ; Load accumulator (stack relative) $AB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $6B.b,S		; 63 6B ; Add with carry (stack relative) $6B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	sbc $EB.b,S		; E3 EB ; Subtract stack-relative $EB.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	.db $82, $62, $9C		; 82 62 9C ; Branch always long to $82, $62, $9C [Flow: branch]
	cmp ($A2.b,X)		; C1 A2 ; Compare accumulator ($A2.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	mvn $14,$94		; 54 94 14 ; Move block negative $14,$94 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	adc $FF77FF.l,X		; 7F FF 77 FF ; Add long $FF77FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda [$7F.b],Y		; B7 7F ; Load accumulator (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $1F6E3F.l,X		; 5F 3F 6E 1F ; Exclusive OR accumulator with memory (long,X) $1F6E3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda ($8E.b),Y		; B1 8E ; Load accumulator ($8E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $0023C0.l,X		; DF C0 23 00 ; Compare accumulator (long,X) $0023C0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ora ($80.b,S),Y		; 13 80 ; OR accumulator (stack relative indirect indexed) ($80.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	jsr $FF7E.w		; 20 7E FF ; Jump to subroutine at $FF7E.w [Writes: Stack Pointer] [Flow: call]
	inc $BD7F.w,X		; FE 7F BD ; Increment memory $BD7F.w,X [Reads: X Index] [Flags: ZN]
	ror $3D52.w,X		; 7E 52 3D ; Rotate right $3D52.w,X [Reads: X Index] [Flags: ZNC]
	adc $B391.w		; 6D 91 B3 ; Add $B391.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	eor $2C.b,S		; 43 2C ; Exclusive OR accumulator with stack relative $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cmp $220FEC.l		; CF EC 0F 22 ; Compare accumulator (long) $220FEC.l [Reads: Accumulator] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	tsb $1010.w		; 0C 10 10 ; Test and set bits $1010.w [Reads: Accumulator] [Flags: Z]
	sta $230120.l		; 8F 20 01 23 ; Store accumulator (long) $230120.l [Reads: Accumulator]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	jsl $4B8400.l		; 22 00 84 4B ; Jump to subroutine long $4B8400.l [Writes: Stack Pointer] [Flow: call]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $C381.w,X		; 7E 81 C3 ; Rotate right $C381.w,X [Reads: X Index] [Flags: ZNC]
	ror $7EA5.w,X		; 7E A5 7E ; Rotate right $7EA5.w,X [Reads: X Index] [Flags: ZNC]
	lda $7E.b,S		; A3 7E ; Load accumulator (stack relative) $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit #$7E.b		; 89 7E ; Test bits #$7E.b with accumulator [Reads: Accumulator] [Flags: Z]
	lda ($7E.b,X)		; A1 7E ; Load accumulator ($7E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: ZNC]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $42, $F9		; 42 F9 ; Reserved instruction
	and [$F3.b],Y		; 37 F3 ; AND accumulator with memory (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $C3DBE7.l		; 6F E7 DB C3 ; Add with carry (long) $C3DBE7.l [Writes: Accumulator] [Flags: ZVNC]
	lda $3E7D99.l,X		; BF 99 7D 3E ; Load long $3E7D99.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $836F.w		; EE 6F 83 ; Increment $836F.w [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $42.b		; 24 42 ; Test bits $42.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta ($10.b,X)		; 81 10 ; Store accumulator ($10.b,X) [Reads: Accumulator, X Index, Direct Page]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cpy #$D7.b		; C0 D7 ; Compare #$D7.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FB.b,S		; 03 FB ; OR accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	mvp $37,$07		; 44 07 37 ; Move block positive $37,$07 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: ZNC]
	sbc [$06.b],Y		; F7 06 ; Subtract with carry (long indexed) [$06.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $A7.b,X		; F6 A7 ; Increment memory $A7.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	wai		; CB ; Wait for interrupt
	tsb $C8.b		; 04 C8 ; Test and set bits $C8.b [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	clv		; B8 ; Clear overflow flag [Flags: V]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	.db $F0, $F6		; F0 F6 ; Branch if equal to $F0, $F6 [Flow: branch]
	.db $F0, $F7		; F0 F7 ; Branch if equal to $F0, $F7 [Flow: branch]
	.db $D0, $D6		; D0 D6 ; Branch if not equal to $D0, $D6 [Flow: branch]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $45.b		; 04 45 ; Test and set bits $45.b [Reads: Accumulator] [Flags: Z]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and #$87.b		; 29 87 ; Logical AND #$87.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	mvp $37,$07		; 44 07 37 ; Move block positive $37,$07 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	lda $E001.w,X		; BD 01 E0 ; Load $E001.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($00.b),Y		; 91 00 ; Store accumulator ($00.b),Y [Reads: Accumulator, Direct Page, Y Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0393.w		; 0C 93 03 ; Test and set bits $0393.w [Reads: Accumulator] [Flags: Z]
	jsr ($3100.w,X)		; FC 00 31 ; Jump to subroutine indirect indexed ($3100.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$D1.b		; C0 D1 ; Compare #$D1.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$DF.b		; C0 DF ; Compare #$DF.b with Y register [Reads: Y Index] [Flags: ZNC]
	ror $6067.w		; 6E 67 60 ; Rotate right $6067.w [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $F020.w		; 2E 20 F0 ; Rotate left $F020.w [Flags: ZNC]
	inc $E0.b,X		; F6 E0 ; Increment memory $E0.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $041E00.l		; EF 00 1E 04 ; Subtract with carry (long) $041E00.l [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$F0.b],Y		; F7 F0 ; Subtract with carry (long indexed) [$F0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta [$E0.b],Y		; 97 E0 ; Store accumulator (long indexed) [$E0.b],Y [Reads: Accumulator, Direct Page, Y Index]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc ($01.b,X)		; E1 01 ; Subtract with carry ($01.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cmp $76F93C.l,X		; DF 3C F9 76 ; Compare accumulator (long,X) $76F93C.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $CD32.w,X		; FD 32 CD ; Subtract with carry $CD32.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($A1.b)		; 32 A1 ; AND accumulator with memory (indirect) ($A1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $58A7.w,X		; 5E A7 58 ; Logical shift right $58A7.w,X [Reads: X Index] [Flags: ZNC]
	sta $50AF70.l		; 8F 70 AF 50 ; Store accumulator (long) $50AF70.l [Reads: Accumulator]
	lda $3276.w,X		; BD 76 32 ; Load $3276.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($5E.b)		; 32 5E ; AND accumulator with memory (indirect) ($5E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $5773.w,Y		; 59 73 57 ; Exclusive OR accumulator with memory $5773.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $42BD00.l,X		; FF 00 BD 42 ; Subtract with carry (long,X) $42BD00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpx $CF.b		; E4 CF ; Compare $CF.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $30, $E7		; 30 E7 ; Branch if minus to $30, $E7 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $E2.b		; 84 E2 ; Store Y register to $E2.b [Reads: Y Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FDFE.w,X		; 3C FE FD ; Test bits $FDFE.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $E7EBCF.l,X		; 9F CF EB E7 ; Store accumulator (long,X) $E7EBCF.l,X [Reads: Accumulator, X Index]
	.db $80, $A1		; 80 A1 ; Branch always to $80, $A1 [Flow: branch]
	trb $54.b		; 14 54 ; Test and reset bits $54.b [Reads: Accumulator] [Flags: Z]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	and [$B7.b],Y		; 37 B7 ; AND accumulator with memory (long indexed) [$B7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$C7.b]		; 07 C7 ; OR accumulator with memory (long) [$C7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	lsr $55AB.w,X		; 5E AB 55 ; Logical shift right $55AB.w,X [Reads: X Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Accumulator, Direct Page]
	mvp $6B,$63		; 44 63 6B ; Move block positive $6B,$63 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($9D.b,X)		; 01 9D ; Logical OR ($9D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $72.b		; 00 72 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and #$18.b		; 29 18 ; Logical AND #$18.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and ($B3.b,S),Y		; 33 B3 ; AND accumulator (stack relative indirect indexed) ($B3.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $7F7F3F.l,X		; 3F 3F 7F 7F ; AND accumulator with memory (long,X) $7F7F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sty $62.b,X		; 94 62 ; Store Y register $62.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	sta $A7D6.w		; 8D D6 A7 ; Store accumulator to $A7D6.w [Reads: Accumulator]
	jmp $80C0.w		; 4C C0 80 ; Jump to $80C0.w [Flow: jump]
	nop		; EA ; No operation
	cpx $2D.b		; E4 2D ; Compare $2D.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc ($13.b),Y		; F1 13 ; Subtract with carry ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $43.b,S		; E3 43 ; Subtract stack-relative $43.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp [$E7.b],Y		; D7 E7 ; Compare accumulator (long indexed) [$E7.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: ZNC]
	lda #$CF.b		; A9 CF ; Load #$CF.b into accumulator [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sta $11BE3E.l,X		; 9F 3E BE 11 ; Store accumulator (long,X) $11BE3E.l,X [Reads: Accumulator, X Index]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	eor ($3F.b,X)		; 41 3F ; Exclusive OR accumulator with memory ($3F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $FDCFD3.l		; 0F D3 CF FD ; OR accumulator with memory (long) $FDCFD3.l [Writes: Accumulator] [Flags: ZN]
	cmp $A3.b,S		; C3 A3 ; Compare accumulator (stack relative) $A3.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	cmp ($AA.b,X)		; C1 AA ; Compare accumulator ($AA.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	cmp #$42.b		; C9 42 ; Compare #$42.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	sta $3C8D.w,Y		; 99 8D 3C ; Store accumulator to $3C8D.w,Y [Reads: Accumulator, Y Index]
	jsr ($C07D.w,X)		; FC 7D C0 ; Jump to subroutine indirect indexed ($C07D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $1C00.w		; 20 00 1C ; Jump to subroutine at $1C00.w [Writes: Stack Pointer] [Flow: call]
	trb $24.b		; 14 24 ; Test and reset bits $24.b [Reads: Accumulator] [Flags: Z]
	.db $42, $02		; 42 02 ; Reserved instruction
	sta $A0.b		; 85 A0 ; Store accumulator to $A0.b [Reads: Accumulator]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$E7.b],Y		; D7 E7 ; Compare accumulator (long indexed) [$E7.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	.db $F0, $25		; F0 25 ; Branch if equal to $F0, $25 [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $44CC80.l,X		; 7F 80 CC 44 ; Add long $44CC80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $4308.w,Y		; 99 08 43 ; Store accumulator to $4308.w,Y [Reads: Accumulator, Y Index]
	lda ($10.b,S),Y		; B3 10 ; Load accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda ($10.b),Y		; B1 10 ; Load accumulator ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $10		; B0 10 ; Branch if carry set to $B0, $10 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$23.b]		; 67 23 ; Add with carry (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $FB4703.l		; 4F 03 47 FB ; Exclusive OR accumulator with memory (long) $FB4703.l [Writes: Accumulator] [Flags: ZN]
	rol $E5.b		; 26 E5 ; Rotate left $E5.b [Reads: Direct Page] [Flags: ZNC]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $3C02.w,X		; FD 02 3C ; Subtract with carry $3C02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $81.b,S		; 43 81 ; Exclusive OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $FF06.w,X		; 7E 06 FF ; Rotate right $FF06.w,X [Reads: X Index] [Flags: ZNC]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $42, $42		; 42 42 ; Reserved instruction
	ror $0022.w,X		; 7E 22 00 ; Rotate right $0022.w,X [Reads: X Index] [Flags: ZNC]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $608000.l,X		; 7F 00 80 60 ; Add long $608000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	lda $C00A3F.l,X		; BF 3F 0A C0 ; Load long $C00A3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FF7F80.l,X		; 7F 80 7F FF ; Add long $FF7F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $40407F.l,X		; 7F 7F 40 40 ; Add long $40407F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $B50300.l		; 22 00 03 B5 ; Jump to subroutine long $B50300.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $E7		; 42 E7 ; Reserved instruction
	bit $4A.b		; 24 4A ; Test bits $4A.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lda $66.b		; A5 66 ; Load $66.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $3FC004.l,X		; 7F 04 C0 3F ; Add long $3FC004.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $83BF40.l,X		; FF 40 BF 83 ; Subtract with carry (long,X) $83BF40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $03.b,S		; 63 03 ; Add with carry (stack relative) $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $002780.l,X		; 7F 80 27 00 ; Add long $002780.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $6683.w,X		; FE 83 66 ; Increment memory $6683.w,X [Reads: X Index] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $E4DFA0.l,X		; BF A0 DF E4 ; Load long $E4DFA0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0EA2.w		; 0C A2 0E ; Test and set bits $0EA2.w [Reads: Accumulator] [Flags: Z]
	eor $B2.b,S		; 43 B2 ; Exclusive OR accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $07.b,X		; 56 07 ; Logical shift right $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldy $46.b,X		; B4 46 ; Load Y register $46.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $B0, $5A		; B0 5A ; Branch if carry set to $B0, $5A [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($51.b,S),Y		; 13 51 ; OR accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $450049.l		; 22 49 00 45 ; Jump to subroutine long $450049.l [Writes: Stack Pointer] [Flow: call]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $30F03F.l,X		; 1F 3F F0 30 ; Logical OR long $30F03F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $E42C.w		; EC 2C E4 ; Compare $E42C.w with X register [Reads: X Index] [Flags: ZNC]
	bit $F0.b		; 24 F0 ; Test bits $F0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	adc $5E4F40.l,X		; 7F 40 4F 5E ; Add long $5E4F40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($5B.b,S),Y		; 53 5B ; XOR accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $050602.l		; 4F 02 06 05 ; Exclusive OR accumulator with memory (long) $050602.l [Writes: Accumulator] [Flags: ZN]
	tsb $1007.w		; 0C 07 10 ; Test and set bits $1007.w [Reads: Accumulator] [Flags: Z]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3C42.w,Y		; 19 42 3C ; OR accumulator with memory $3C42.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FB00.w,X		; FD 00 FB ; Subtract with carry $FB00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $BE1F.w,X		; 9E 1F BE ; Store zero to $BE1F.w,X [Reads: X Index]
	mvp $B3,$3F		; 44 3F B3 ; Move block positive $B3,$3F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$26.b		; E0 26 ; Compare #$26.b with X register [Reads: X Index] [Flags: ZNC]
	ldx $8F3E.w,Y		; BE 3E 8F ; Load X register $8F3E.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	.db $70, $C1		; 70 C1 ; Branch if overflow set to $70, $C1 [Flow: branch]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc ($41.b,X)		; 61 41 ; Add with carry ($41.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jmp $414C.w		; 4C 4C 41 ; Jump to $414C.w [Flow: jump]
	adc ($3F.b),Y		; 71 3F ; Add with carry ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($F1.b,X)		; 01 F1 ; Logical OR ($F1.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $7EC1.w		; 6E C1 7E ; Rotate right $7EC1.w [Flags: ZNC]
	sta ($FE.b,X)		; 81 FE ; Store accumulator ($FE.b,X) [Reads: Accumulator, X Index, Direct Page]
	adc ($EE.b),Y		; 71 EE ; Add with carry ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $3DB6.w,Y		; 79 B6 3D ; Add $3DB6.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ora ($C2.b,X)		; 01 C2 ; Logical OR ($C2.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	bit $9F.b		; 24 9F ; Test bits $9F.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lda $CF9F7F.l,X		; BF 7F 9F CF ; Load long $CF9F7F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sta [$10.b],Y		; 97 10 ; Store accumulator (long indexed) [$10.b],Y [Reads: Accumulator, Direct Page, Y Index]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $E707EF.l		; 0F EF 07 E7 ; OR accumulator with memory (long) $E707EF.l [Writes: Accumulator] [Flags: ZN]
	ora ($F9.b,X)		; 01 F9 ; Logical OR ($F9.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$DE.b		; C0 DE ; Compare #$DE.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$EF.b		; E0 EF ; Compare #$EF.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $F7		; F0 F7 ; Branch if equal to $F0, $F7 [Flow: branch]
	.db $90, $F7		; 90 F7 ; Branch if carry clear to $90, $F7 [Flow: branch]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	asl $C3.b		; 06 C3 ; Arithmetic shift left $C3.b [Reads: Direct Page] [Flags: ZNC]
	and ($10.b,X)		; 21 10 ; Logical AND ($10.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $B0, $F7		; B0 F7 ; Branch if carry set to $B0, $F7 [Flow: branch]
	ldy #$AF.b		; A0 AF ; Load #$AF.b into Y register [Writes: Y Index] [Flags: ZN]
	cpy #$CC.b		; C0 CC ; Compare #$CC.b with Y register [Reads: Y Index] [Flags: ZNC]
	sta ($99.b,X)		; 81 99 ; Store accumulator ($99.b,X) [Reads: Accumulator, X Index, Direct Page]
	ora $3B.b,S		; 03 3B ; OR accumulator with stack relative $3B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $F3.b,S		; 03 F3 ; OR accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$E7.b]		; 07 E7 ; OR accumulator with memory (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $50088F.l		; 0F 8F 08 50 ; OR accumulator with memory (long) $50088F.l [Writes: Accumulator] [Flags: ZN]
	and ($66.b,S),Y		; 33 66 ; AND accumulator (stack relative indirect indexed) ($66.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpy $0C.b		; C4 0C ; Compare $0C.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cpy #$D8.b		; C0 D8 ; Compare #$D8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3B.b,S		; 03 3B ; OR accumulator with stack relative $3B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc [$E0.b],Y		; F7 E0 ; Subtract with carry (long indexed) [$E0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$A7.b],Y		; 37 A7 ; AND accumulator with memory (long indexed) [$A7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$C3.b]		; 27 C3 ; AND accumulator with memory (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cpy $08.b		; C4 08 ; Compare $08.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $7B.b,S		; 03 7B ; OR accumulator with stack relative $7B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $4B.b,S		; 03 4B ; OR accumulator with stack relative $4B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	.db $F0, $F6		; F0 F6 ; Branch if equal to $F0, $F6 [Flow: branch]
	sty $B4.b		; 84 B4 ; Store Y register to $B4.b [Reads: Y Index]
	lda ($00.b,S),Y		; B3 00 ; Load accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $4405.w,Y		; F9 05 44 ; Subtract with carry $4405.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$AC.b		; 09 AC ; Logical OR #$AC.b with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $2FB7.w		; 1C B7 2F ; Test and reset bits $2FB7.w [Reads: Accumulator] [Flags: Z]
	clv		; B8 ; Clear overflow flag [Flags: V]
	and [$9F.b],Y		; 37 9F ; AND accumulator with memory (long indexed) [$9F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $40FF0F.l		; 8F 0F FF 40 ; Store accumulator (long) $40FF0F.l [Reads: Accumulator]
	lda $68B970.l,X		; BF 70 B9 68 ; Load long $68B970.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $40.b,S		; 43 40 ; Exclusive OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $3F		; 70 3F ; Branch if overflow set to $70, $3F [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $0480.w		; 8C 80 04 ; Store Y register to $0480.w [Reads: Y Index]
	cop $7F.b		; 02 7F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	stx $90.b		; 86 90 ; Store X register to $90.b [Reads: X Index]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($45.b,X)		; 01 45 ; Logical OR ($45.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $24FF.w,X		; FE FF 24 ; Increment memory $24FF.w,X [Reads: X Index] [Flags: ZN]
	inc $0022.w,X		; FE 22 00 ; Increment memory $0022.w,X [Reads: X Index] [Flags: ZN]
	ora $B9.b,S		; 03 B9 ; OR accumulator with stack relative $B9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp $4738.w,Y		; D9 38 47 ; Compare accumulator $4738.w,Y [Reads: Y Index] [Flags: ZNC]
	sta $0378.w,Y		; 99 78 03 ; Store accumulator to $0378.w,Y [Reads: Accumulator, Y Index]
	stz $817E.w,X		; 9E 7E 81 ; Store zero to $817E.w,X [Reads: X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $07.b		; 25 07 ; Logical AND $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $23FFFE.l,X		; FF FE FF 23 ; Subtract with carry (long,X) $23FFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $2300.w,X		; FE 00 23 ; Increment memory $2300.w,X [Reads: X Index] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $22FE.w,X		; FE FE 22 ; Increment memory $22FE.w,X [Reads: X Index] [Flags: ZN]
	sbc $F054E0.l,X		; FF E0 54 F0 ; Subtract with carry (long,X) $F054E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $C31EE1.l		; 0F E1 1E C3 ; OR accumulator with memory (long) $C31EE1.l [Writes: Accumulator] [Flags: ZN]
	bit $7987.w,X		; 3C 87 79 ; Test bits $7987.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $1EF3.w		; 0E F3 1E ; Arithmetic shift left $1EF3.w [Flags: ZNC]
	sbc $3F.b,S		; E3 3F ; Subtract stack-relative $3F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp #$77.b		; C9 77 ; Compare #$77.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	stz $E0F0.w		; 9C F0 E0 ; Store zero to $E0F0.w
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$57.b		; A0 57 ; Load #$57.b into Y register [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $5F.b		; A5 5F ; Load $5F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $6F.b,X		; B5 6F ; Load $6F.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc [$BF.b],Y		; 77 BF ; Add with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	sbc $454800.l,X		; FF 00 48 45 ; Subtract with carry (long,X) $454800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	adc $20E000.l,X		; 7F 00 E0 20 ; Add long $20E000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: ZN]
	inc $36.b,X		; F6 36 ; Increment memory $36.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $7FBF00.l,X		; FF 00 BF 7F ; Subtract with carry (long,X) $7FBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	nop		; EA ; No operation
	eor $95.b,X		; 55 95 ; Exclusive OR accumulator with memory $95.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $5F40E0.l,X		; 3F E0 40 5F ; AND accumulator with memory (long,X) $5F40E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7F49.w,Y		; 59 49 7F ; Exclusive OR accumulator with memory $7F49.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $8C18E3.l,X		; 3F E3 18 8C ; AND accumulator with memory (long,X) $8C18E3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($18.b,S),Y		; 73 18 ; Add with carry (stack relative indirect indexed) ($18.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$28.b]		; E7 28 ; Subtract with carry (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$47.b],Y		; D7 47 ; Compare accumulator (long indexed) [$47.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sta $7E7F.w,X		; 9D 7F 7E ; Store accumulator to $7E7F.w,X [Reads: Accumulator, X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $012FE0.l,X		; FF E0 2F 01 ; Subtract with carry (long,X) $012FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $C171.w		; CE 71 C1 ; Decrement $C171.w [Flags: ZN]
	ora $B33E9F.l,X		; 1F 9F 3E B3 ; Logical OR long $B33E9F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $3E93.w,X		; 1E 93 3E ; Arithmetic shift left $3E93.w,X [Reads: X Index] [Flags: ZNC]
	lda $1FBE3F.l,X		; BF 3F BE 1F ; Load long $1FBE3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $603E31.l,X		; 9F 31 3E 60 ; Store accumulator (long,X) $603E31.l,X [Reads: Accumulator, X Index]
	eor $416D.w		; 4D 6D 41 ; Exclusive OR $416D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor ($60.b,X)		; 41 60 ; Exclusive OR accumulator with memory ($60.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	bit $21.b		; 24 21 ; Test bits $21.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
.INDEX 16
	rep #$9D		; C2 9D
	ror $BEC1.w		; 6E C1 BE ; Rotate right $BEC1.w [Flags: ZNC]
	adc $4DF2.w,X		; 7D F2 4D ; Add $4DF2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $D66D.w,X		; FE 6D D6 ; Increment memory $D66D.w,X [Reads: X Index] [Flags: ZN]
	sbc [$7E.b]		; E7 7E ; Subtract with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc $8F7FF3.l,X		; FF F3 7F 8F ; Subtract with carry (long,X) $8F7FF3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda ($BB.b,S),Y		; B3 BB ; Load accumulator (stack relative indirect indexed) ($BB.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $288B.w,Y		; 99 8B 28 ; Store accumulator to $288B.w,Y [Reads: Accumulator, Y Index]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$97.b]		; 07 97 ; OR accumulator with memory (long) [$97.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta [$38.b]		; 87 38 ; Store accumulator (long) [$38.b] [Reads: Accumulator, Direct Page]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $9B98.w		; 20 98 9B ; Jump to subroutine at $9B98.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $F0, $F3		; F0 F3 ; Branch if equal to $F0, $F3 [Flow: branch]
	cpy #$80CF.w		; C0 CF 80 ; Compare #$80CF.w with Y register [Reads: Y Index] [Flags: ZNC]
	ldx $7101.w,Y		; BE 01 71 ; Load X register $7101.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ora $DF1FEF.l		; 0F EF 1F DF ; OR accumulator with memory (long) $DF1FEF.l [Writes: Accumulator] [Flags: ZN]
	stz $04.b		; 64 04 ; Store zero to $04.b
	tsb $4130.w		; 0C 30 41 ; Test and set bits $4130.w [Reads: Accumulator] [Flags: Z]
	stx $2010.w		; 8E 10 20 ; Store X register to $2010.w [Reads: X Index]
	adc $5D7F.w,X		; 7D 7F 5D ; Add $5D7F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $5F5F.w,X		; 7D 5F 5F ; Add $5F5F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $43FF7F.l,X		; 7F 7F FF 43 ; Add long $43FF7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F714F7.l,X		; FF F7 14 F7 ; Subtract with carry (long,X) $F714F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $8280FF.l,X		; FF FF 80 82 ; Subtract with carry (long,X) $8280FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy #$0080.w		; A0 80 00 ; Load #$0080.w into Y register [Writes: Y Index] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$06.b],Y		; 97 06 ; Store accumulator (long indexed) [$06.b],Y [Reads: Accumulator, Direct Page, Y Index]
	stx $07.b,Y		; 96 07 ; Store X register $07.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Accumulator, Direct Page, Y Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $1A.b		; 85 1A ; Store accumulator to $1A.b [Reads: Accumulator]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	adc #$68.b		; 69 68 ; Add #$68.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	adc [$84.b]		; 67 84 ; Add with carry (long) [$84.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	bit $02.b		; 24 02 ; Test bits $02.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pea $D7D0.w		; F4 D0 D7 ; Push absolute address $D7D0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	cpx #$00EC.w		; E0 EC 00 ; Compare #$00EC.w with X register [Reads: X Index] [Flags: ZNC]
	ora $43F800.l,X		; 1F 00 F8 43 ; Logical OR long $43F800.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$97.b]		; 07 97 ; OR accumulator with memory (long) [$97.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($E0.b,S),Y		; 13 E0 ; OR accumulator (stack relative indirect indexed) ($E0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$68.b]		; 07 68 ; OR accumulator with memory (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sbc $FE130F.l,X		; FF 0F 13 FE ; Subtract with carry (long,X) $FE130F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $FD.b		; 06 FD ; Arithmetic shift left $FD.b [Reads: Direct Page] [Flags: ZNC]
	bit $18FB.w		; 2C FB 18 ; Test bits $18FB.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sbc [$38.b],Y		; F7 38 ; Subtract with carry (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$6C.b]		; E7 6C ; Subtract with carry (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $BD.b		; C6 BD ; Decrement $BD.b [Reads: Direct Page] [Flags: ZN]
	sta $7E.b,S		; 83 7E ; Store accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	inc $7D04.w,X		; FE 04 7D ; Increment memory $7D04.w,X [Reads: X Index] [Flags: ZN]
	brk $BB.b		; 00 BB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$0142.w		; E0 42 01 ; Compare #$0142.w with X register [Reads: X Index] [Flags: ZNC]
	jsr ($F923.w,X)		; FC 23 F9 ; Jump to subroutine indirect indexed ($F923.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$F3.b]		; 07 F3 ; OR accumulator with memory (long) [$F3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $CF17E7.l		; 8F E7 17 CF ; Store accumulator (long) $CF17E7.l [Reads: Accumulator]
	and [$9F.b]		; 27 9F ; AND accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	sbc $FBFC.w,X		; FD FC FB ; Subtract with carry $FBFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $D3D7.w,Y		; F9 D7 D3 ; Subtract with carry $D3D7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$6F.b],Y		; 77 6F ; Add with carry (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$DAD8.w		; E0 D8 DA ; Compare #$DAD8.w with X register [Reads: X Index] [Flags: ZNC]
	ldy $2EED.w,X		; BC ED 2E ; Load Y register $2EED.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $027D.w,X		; FE 7D 02 ; Increment memory $027D.w,X [Reads: X Index] [Flags: ZN]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	.db $90, $27		; 90 27 ; Branch if carry clear to $90, $27 [Flow: branch]
	eor $91.b,S		; 43 91 ; Exclusive OR accumulator with stack relative $91.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $C1.b		; 02 C1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($B963.w,X)		; 7C 63 B9 ; Jump indirect indexed to ($B963.w,X) [Reads: X Index] [Flow: jump]
	and [$D3.b],Y		; 37 D3 ; AND accumulator with memory (long indexed) [$D3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc [$C9.b]		; 67 C9 ; Add with carry (long) [$C9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and [$C4.b],Y		; 37 C4 ; AND accumulator with memory (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $FF01.w,X		; FE 01 FF ; Increment memory $FF01.w,X [Reads: X Index] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$F5.b],Y		; 17 F5 ; OR accumulator with memory (long indexed) [$F5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($CB.b,S),Y		; F3 CB ; Subtract with carry (stack relative indirect indexed) ($CB.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$14.b]		; C7 14 ; Compare accumulator (long) [$14.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tsb $1824.w		; 0C 24 18 ; Test and set bits $1824.w [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $67E6.w,X		; 3C E6 67 ; Test bits $67E6.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $F338.w		; 0C 38 F3 ; Test and set bits $F338.w [Reads: Accumulator] [Flags: Z]
	sbc [$C3.b]		; E7 C3 ; Subtract with carry (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $FE3E.w,Y		; 99 3E FE ; Store accumulator to $FE3E.w,Y [Reads: Accumulator, Y Index]
	eor $2700FF.l		; 4F FF 00 27 ; Exclusive OR accumulator with memory (long) $2700FF.l [Writes: Accumulator] [Flags: ZN]
	sbc $E00037.l,X		; FF 37 00 E0 ; Subtract with carry (long,X) $E00037.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $EF.b,S		; 23 EF ; AND accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $36DB.w		; 1C DB 36 ; Test and reset bits $36DB.w [Reads: Accumulator] [Flags: Z]
	ldy $727B.w		; AC 7B 72 ; Load $727B.w into Y register [Writes: Y Index] [Flags: ZN]
	cmp $E5BA.w		; CD BA E5 ; Compare $E5BA.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ldy $EB.b,X		; B4 EB ; Load Y register $EB.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	trb $EF.b		; 14 EF ; Test and reset bits $EF.b [Reads: Accumulator] [Flags: Z]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	lda [$7B.b],Y		; B7 7B ; Load accumulator (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $B4E5.w		; CD E5 B4 ; Compare $B4E5.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	ora [$DB.b],Y		; 17 DB ; OR accumulator with memory (long indexed) [$DB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F60A.w,X		; FD 0A F6 ; Subtract with carry $F60A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and #$DF.b		; 29 DF ; Logical AND #$DF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jsr $01FE.w		; 20 FE 01 ; Jump to subroutine at $01FE.w [Writes: Stack Pointer] [Flow: call]
	sbc $F702.w,X		; FD 02 F7 ; Subtract with carry $F702.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	asl $A6A9.w		; 0E A9 A6 ; Arithmetic shift left $A6A9.w [Flags: ZNC]
	sta $F3E9FE.l,X		; 9F FE E9 F3 ; Store accumulator (long,X) $F3E9FE.l,X [Reads: Accumulator, X Index]
	sbc $030000.l,X		; FF 00 00 03 ; Subtract with carry (long,X) $030000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $231F1F.l		; 0F 1F 1F 23 ; OR accumulator with memory (long) $231F1F.l [Writes: Accumulator] [Flags: ZN]
	and $7E7E15.l,X		; 3F 15 7E 7E ; AND accumulator with memory (long,X) $7E7E15.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($FF7C.w,X)		; 7C 7C FF ; Jump indirect indexed to ($FF7C.w,X) [Reads: X Index] [Flow: jump]
	jsr ($E0F0.w,X)		; FC F0 E0 ; Jump to subroutine indirect indexed ($E0F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$81C0.w		; C0 C0 81 ; Compare #$81C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	sta $7F.b,S		; 83 7F ; Store accumulator (stack relative) $7F.b,S [Reads: Accumulator, Stack Pointer]
	adc $F8FEFE.l,X		; 7F FE FE F8 ; Add long $F8FEFE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$80E0.w		; E0 E0 80 ; Compare #$80E0.w with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $25		; 80 25 ; Branch always to $80, $25 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $E0FF22.l,X		; 7F 22 FF E0 ; Add long $E0FF22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $F1FCFA.l		; 2F FA FC F1 ; AND accumulator with memory (long) $F1FCFA.l [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $E6.b,X		; F6 E6 ; Increment memory $E6.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $9FDFCF.l		; EF CF DF 9F ; Subtract with carry (long) $9FDFCF.l [Writes: Accumulator] [Flags: ZVNC]
	jmp.w [$ED3F]		; DC 3F ED ; Jump long indirect [$ED3F] [Flow: jump]
	asl $6C92.w,X		; 1E 92 6C ; Arithmetic shift left $6C92.w,X [Reads: X Index] [Flags: ZNC]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $B7E56E.l,X		; 1F 6E E5 B7 ; Logical OR long $B7E56E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($7B.b,S),Y		; 73 7B ; Add with carry (stack relative indirect indexed) ($7B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $304D.w,Y		; 39 4D 30 ; AND accumulator with memory $304D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($03.b)		; F2 03 ; Subtract with carry (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	stx $F60F.w		; 8E 0F F6 ; Store X register to $F60F.w [Reads: X Index]
	adc $0810E0.l,X		; 7F E0 10 08 ; Add long $0810E0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $82.b		; 84 82 ; Store Y register to $82.b [Reads: Y Index]
	tsb $0070.w		; 0C 70 00 ; Test and set bits $0070.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $2F		; F0 2F ; Branch if equal to $F0, $2F [Flow: branch]
	jsr $1001.w		; 20 01 10 ; Jump to subroutine at $1001.w [Writes: Stack Pointer] [Flow: call]
	ror $C381.w,X		; 7E 81 C3 ; Rotate right $C381.w,X [Reads: X Index] [Flags: ZNC]
	ror $7EA5.w,X		; 7E A5 7E ; Rotate right $7EA5.w,X [Reads: X Index] [Flags: ZNC]
	lda $7E.b,S		; A3 7E ; Load accumulator (stack relative) $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit #$7E.b		; 89 7E ; Test bits #$7E.b with accumulator [Reads: Accumulator] [Flags: Z]
	lda ($7E.b,X)		; A1 7E ; Load accumulator ($7E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: ZNC]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $42, $F9		; 42 F9 ; Reserved instruction
	and [$F3.b],Y		; 37 F3 ; AND accumulator with memory (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $C3DBE7.l		; 6F E7 DB C3 ; Add with carry (long) $C3DBE7.l [Writes: Accumulator] [Flags: ZVNC]
	lda $3E7D99.l,X		; BF 99 7D 3E ; Load long $3E7D99.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $836F.w		; EE 6F 83 ; Increment $836F.w [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $42.b		; 24 42 ; Test bits $42.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta ($10.b,X)		; 81 10 ; Store accumulator ($10.b,X) [Reads: Accumulator, X Index, Direct Page]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc ($F3.b,S),Y		; F3 F3 ; Subtract with carry (stack relative indirect indexed) ($F3.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $D9D9EF.l		; EF EF D9 D9 ; Subtract with carry (long) $D9D9EF.l [Writes: Accumulator] [Flags: ZVNC]
	lda $43BD.w,X		; BD BD 43 ; Load $43BD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $21E0BF.l,X		; 3F BF E0 21 ; AND accumulator with memory (long,X) $21E0BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $C7BE.w,X		; 3E BE C7 ; Rotate left $C7BE.w,X [Reads: X Index] [Flags: ZNC]
	tsb $2610.w		; 0C 10 26 ; Test and set bits $2610.w [Reads: Accumulator] [Flags: Z]
	.db $42, $40		; 42 40 ; Reserved instruction
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor ($1D.b,X)		; 41 1D ; Exclusive OR accumulator with memory ($1D.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $CFCF.w,X		; 1D CF CF ; OR accumulator with memory $CFCF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $ECF9.w,Y		; F9 F9 EC ; Subtract with carry $ECF9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FDFC.w		; ED FC FD ; Subtract $FDFC.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	jmp ($E27D.w,X)		; 7C 7D E2 ; Jump indirect indexed to ($E27D.w,X) [Reads: X Index] [Flow: jump]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $82, $89, $B0		; 82 89 B0 ; Branch always long to $82, $89, $B0 [Flow: branch]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $21F0BF.l,X		; 3F BF F0 21 ; AND accumulator with memory (long,X) $21F0BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldx $E001.w,Y		; BE 01 E0 ; Load X register $E001.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	eor ($3E.b,S),Y		; 53 3E ; XOR accumulator (stack relative indirect indexed) ($3E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ldx $CF0F.w,Y		; BE 0F CF ; Load X register $CF0F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ora $B7C7EF.l		; 0F EF C7 B7 ; OR accumulator with memory (long) $B7C7EF.l [Writes: Accumulator] [Flags: ZN]
	lda ($99.b,X)		; A1 99 ; Load accumulator ($99.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $90, $8F		; 90 8F ; Branch if carry clear to $90, $8F [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sbc [$67.b]		; E7 67 ; Subtract with carry (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor ($30.b,X)		; 41 30 ; Exclusive OR accumulator with memory ($30.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	lsr $60.b		; 46 60 ; Logical shift right $60.b [Reads: Direct Page] [Flags: ZNC]
	.db $10, $98		; 10 98 ; Branch if plus to $10, $98 [Flow: branch]
	jmp ($F07D.w,X)		; 7C 7D F0 ; Jump indirect indexed to ($F07D.w,X) [Reads: X Index] [Flow: jump]
	sbc ($F0.b,S),Y		; F3 F0 ; Subtract with carry (stack relative indirect indexed) ($F0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$E3.b],Y		; F7 E3 ; Subtract with carry (long indexed) [$E3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1905.w		; ED 05 19 ; Subtract $1905.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	ora #$F1.b		; 09 F1 ; Logical OR #$F1.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$E7.b],Y		; 17 E7 ; OR accumulator with memory (long indexed) [$E7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $0C820F.l		; EF 0F 82 0C ; Subtract with carry (long) $0C820F.l [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $E2		; 10 E2 ; Branch if plus to $10, $E2 [Flow: branch]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	bit $76F9.w,X		; 3C F9 76 ; Test bits $76F9.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $CD32.w,X		; FD 32 CD ; Subtract with carry $CD32.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($A1.b)		; 32 A1 ; AND accumulator with memory (indirect) ($A1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $58A7.w,X		; 5E A7 58 ; Logical shift right $58A7.w,X [Reads: X Index] [Flags: ZNC]
	sta $50AF70.l		; 8F 70 AF 50 ; Store accumulator (long) $50AF70.l [Reads: Accumulator]
	lda $3276.w,X		; BD 76 32 ; Load $3276.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($5E.b)		; 32 5E ; AND accumulator with memory (indirect) ($5E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $5773.w,Y		; 59 73 57 ; Exclusive OR accumulator with memory $5773.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $42BD00.l,X		; FF 00 BD 42 ; Subtract with carry (long,X) $42BD00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpx $CF.b		; E4 CF ; Compare $CF.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $30, $E7		; 30 E7 ; Branch if minus to $30, $E7 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $E2.b		; 84 E2 ; Store Y register to $E2.b [Reads: Y Index]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $3BFD.w,X		; FE FD 3B ; Increment memory $3BFD.w,X [Reads: X Index] [Flags: ZN]
	sta $E7EBCF.l,X		; 9F CF EB E7 ; Store accumulator (long,X) $E7EBCF.l,X [Reads: Accumulator, X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $F0.b,S		; 23 F0 ; AND accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $E0.b,S		; 23 E0 ; AND accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $C0.b,S		; 23 C0 ; AND accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $80.b		; 02 80 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $87		; 80 87 ; Branch always to $80, $87 [Flow: branch]
	sta $F4.b		; 85 F4 ; Store accumulator to $F4.b [Reads: Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $230023.l,X		; 7F 23 00 23 ; Add long $230023.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3F3F0F.l		; 0F 0F 3F 3F ; OR accumulator with memory (long) $3F3F0F.l [Writes: Accumulator] [Flags: ZN]
	sbc $FEFEFF.l,X		; FF FF FE FE ; Subtract with carry (long,X) $FEFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$718D.w		; C0 8D 71 ; Compare #$718D.w with Y register [Reads: Y Index] [Flags: ZNC]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	adc ($57.b,S),Y		; 73 57 ; Add with carry (stack relative indirect indexed) ($57.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$B7.b]		; 27 B7 ; AND accumulator with memory (long) [$B7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta [$D7.b]		; 87 D7 ; Store accumulator (long) [$D7.b] [Reads: Accumulator, Direct Page]
	cmp [$EB.b]		; C7 EB ; Compare accumulator (long) [$EB.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	cmp [$D4.b]		; C7 D4 ; Compare accumulator (long) [$D4.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta ($3B.b,S),Y		; 93 3B ; Store accumulator (stack relative indirect indexed) ($3B.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	mvp $3F,$7E		; 44 7E 3F ; Move block positive $3F,$7E [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	lda $80BF9E.l,X		; BF 9E BF 80 ; Load long $80BF9E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldx #$C5DC.w		; A2 DC C5 ; Load #$C5DC.w into X register [Writes: X Index] [Flags: ZN]
	lda $B3CB.w,Y		; B9 CB B3 ; Load $B3CB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	eor [$A7.b],Y		; 57 A7 ; Exclusive OR accumulator with memory (long indexed) [$A7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $40800F.l		; EF 0F 80 40 ; Subtract with carry (long) $40800F.l [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0502A0.l		; 2F A0 02 05 ; AND accumulator with memory (long) $0502A0.l [Writes: Accumulator] [Flags: ZN]
	adc $44CC80.l,X		; 7F 80 CC 44 ; Add long $44CC80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $4308.w,Y		; 99 08 43 ; Store accumulator to $4308.w,Y [Reads: Accumulator, Y Index]
	lda ($10.b,S),Y		; B3 10 ; Load accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda ($10.b),Y		; B1 10 ; Load accumulator ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $10		; B0 10 ; Branch if carry set to $B0, $10 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$23.b]		; 67 23 ; Add with carry (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $FB4703.l		; 4F 03 47 FB ; Exclusive OR accumulator with memory (long) $FB4703.l [Writes: Accumulator] [Flags: ZN]
	rol $E5.b		; 26 E5 ; Rotate left $E5.b [Reads: Direct Page] [Flags: ZNC]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $3C02.w,X		; FD 02 3C ; Subtract with carry $3C02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $81.b,S		; 43 81 ; Exclusive OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $FF06.w,X		; 7E 06 FF ; Rotate right $FF06.w,X [Reads: X Index] [Flags: ZNC]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $42, $42		; 42 42 ; Reserved instruction
	ror $0022.w,X		; 7E 22 00 ; Rotate right $0022.w,X [Reads: X Index] [Flags: ZNC]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $608000.l,X		; 7F 00 80 60 ; Add long $608000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	lda $C00A3F.l,X		; BF 3F 0A C0 ; Load long $C00A3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FF7F80.l,X		; 7F 80 7F FF ; Add long $FF7F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $40407F.l,X		; 7F 7F 40 40 ; Add long $40407F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $B50300.l		; 22 00 03 B5 ; Jump to subroutine long $B50300.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $E7		; 42 E7 ; Reserved instruction
	bit $4A.b		; 24 4A ; Test bits $4A.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lda $66.b		; A5 66 ; Load $66.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $3FC004.l,X		; 7F 04 C0 3F ; Add long $3FC004.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $83BF40.l,X		; FF 40 BF 83 ; Subtract with carry (long,X) $83BF40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $03.b,S		; 63 03 ; Add with carry (stack relative) $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $002780.l,X		; 7F 80 27 00 ; Add long $002780.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $6683.w,X		; FE 83 66 ; Increment memory $6683.w,X [Reads: X Index] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $E4DFA0.l,X		; BF A0 DF E4 ; Load long $E4DFA0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0EA2.w		; 0C A2 0E ; Test and set bits $0EA2.w [Reads: Accumulator] [Flags: Z]
	eor $B2.b,S		; 43 B2 ; Exclusive OR accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $07.b,X		; 56 07 ; Logical shift right $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldy $46.b,X		; B4 46 ; Load Y register $46.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $B0, $5A		; B0 5A ; Branch if carry set to $B0, $5A [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($51.b,S),Y		; 13 51 ; OR accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $450049.l		; 22 49 00 45 ; Jump to subroutine long $450049.l [Writes: Stack Pointer] [Flow: call]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $30F03F.l,X		; 1F 3F F0 30 ; Logical OR long $30F03F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $E42C.w		; EC 2C E4 ; Compare $E42C.w with X register [Reads: X Index] [Flags: ZNC]
	bit $F0.b		; 24 F0 ; Test bits $F0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	adc $5E4F40.l,X		; 7F 40 4F 5E ; Add long $5E4F40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($5B.b,S),Y		; 53 5B ; XOR accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $050602.l		; 4F 02 06 05 ; Exclusive OR accumulator with memory (long) $050602.l [Writes: Accumulator] [Flags: ZN]
	tsb $1007.w		; 0C 07 10 ; Test and set bits $1007.w [Reads: Accumulator] [Flags: Z]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3C42.w,Y		; 19 42 3C ; OR accumulator with memory $3C42.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FB00.w,X		; FD 00 FB ; Subtract with carry $FB00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$702F.w		; E0 2F 70 ; Compare #$702F.w with X register [Reads: X Index] [Flags: ZNC]
	sbc [$40.b],Y		; F7 40 ; Subtract with carry (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $00BF00.l,X		; DF 00 BF 00 ; Compare accumulator (long,X) $00BF00.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	inc $80.b,X		; F6 80 ; Increment memory $80.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sta [$5F.b]		; 87 5F ; Store accumulator (long) [$5F.b] [Reads: Accumulator, Direct Page]
	sta $0FF06F.l		; 8F 6F F0 0F ; Store accumulator (long) $0FF06F.l [Reads: Accumulator]
	ora $7F7F3F.l		; 0F 3F 7F 7F ; OR accumulator with memory (long) $7F7F3F.l [Writes: Accumulator] [Flags: ZN]
	sbc $F0F0F8.l,X		; FF F8 F0 F0 ; Subtract with carry (long,X) $F0F0F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $1EBF.w,X		; 3E BF 1E ; Rotate left $1EBF.w,X [Reads: X Index] [Flags: ZNC]
	sbc $097F08.l,X		; FF 08 7F 09 ; Subtract with carry (long,X) $097F08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FE11.w,X		; FE 11 FE ; Increment memory $FE11.w,X [Reads: X Index] [Flags: ZN]
	and ($FA.b,X)		; 21 FA ; Logical AND ($FA.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp ($F2.b,X)		; C1 F2 ; Compare accumulator ($F2.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	and ($CC.b,S),Y		; 33 CC ; AND accumulator (stack relative indirect indexed) ($CC.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$F6E0.w		; C0 E0 F6 ; Compare #$F6E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $97333F.l,X		; DF 3F 33 97 ; Compare accumulator (long,X) $97333F.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $188000.l,X		; FF 00 80 18 ; Subtract with carry (long,X) $188000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $39.b,S		; 43 39 ; Exclusive OR accumulator with stack relative $39.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda $0343.w,Y		; B9 43 03 ; Load $0343.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $E0.b,S		; 83 E0 ; Store accumulator (stack relative) $E0.b,S [Reads: Accumulator, Stack Pointer]
	and $9111.w		; 2D 11 91 ; Logical AND $9111.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$46.b]		; 67 46 ; Add with carry (long) [$46.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lsr $7C.b		; 46 7C ; Logical shift right $7C.b [Reads: Direct Page] [Flags: ZNC]
	jmp ($006E.w,X)		; 7C 6E 00 ; Jump indirect indexed to ($006E.w,X) [Reads: X Index] [Flow: jump]
	sbc $1C0100.l,X		; FF 00 01 1C ; Subtract with carry (long,X) $1C0100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $C9C8.w,X		; 1D C8 C9 ; OR accumulator with memory $C9C8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$38E1.w		; E0 E1 38 ; Compare #$38E1.w with X register [Reads: X Index] [Flags: ZNC]
	and $1110.w,Y		; 39 10 11 ; AND accumulator with memory $1110.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $90, $91		; 90 91 ; Branch if carry clear to $90, $91 [Flow: branch]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 8
.INDEX 8
	sep #$36		; E2 36
	asl $EEC6.w,X		; 1E C6 EE ; Arithmetic shift left $EEC6.w,X [Reads: X Index] [Flags: ZNC]
	ror $F8F0.w		; 6E F0 F8 ; Rotate right $F8F0.w [Flags: ZNC]
	sbc ($F1.b,X)		; E1 F1 ; Subtract with carry ($F1.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	wai		; CB ; Wait for interrupt
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sta $9919DF.l,X		; 9F DF 19 99 ; Store accumulator (long,X) $9919DF.l,X [Reads: Accumulator, X Index]
	and $43BD.w,X		; 3D BD 43 ; AND accumulator with memory $43BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $070FBF.l,X		; 3F BF 0F 07 ; AND accumulator with memory (long,X) $070FBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $2014.w		; 0E 14 20 ; Arithmetic shift left $2014.w [Flags: ZNC]
	ror $42.b		; 66 42 ; Rotate right $42.b [Reads: Direct Page] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora $E71D.w		; 0D 1D E7 ; Logical OR $E71D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $F1F7F3.l		; EF F3 F7 F1 ; Subtract with carry (long) $F1F7F3.l [Writes: Accumulator] [Flags: ZVNC]
	sbc ($43.b,S),Y		; F3 43 ; Subtract with carry (stack relative indirect indexed) ($43.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($43FD.w,X)		; FC FD 43 ; Jump to subroutine indirect indexed ($43FD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $1FED.w		; EC ED 1F ; Compare $1FED.w with X register [Reads: X Index] [Flags: ZNC]
.INDEX 8
	sep #$10		; E2 10
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $0202.w		; 0C 02 02 ; Test and set bits $0202.w [Reads: Accumulator] [Flags: Z]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy $B71C.w		; AC 1C B7 ; Load $B71C.w into Y register [Writes: Y Index] [Flags: ZN]
	and $9F37B8.l		; 2F B8 37 9F ; AND accumulator with memory (long) $9F37B8.l [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $40FF0F.l		; 8F 0F FF 40 ; Store accumulator (long) $40FF0F.l [Reads: Accumulator]
	lda $68B970.l,X		; BF 70 B9 68 ; Load long $68B970.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $40.b,S		; 43 40 ; Exclusive OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $3F		; 70 3F ; Branch if overflow set to $70, $3F [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $0480.w		; 8C 80 04 ; Store Y register to $0480.w [Reads: Y Index]
	cop $7F.b		; 02 7F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	stx $90.b		; 86 90 ; Store X register to $90.b [Reads: X Index]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($45.b,X)		; 01 45 ; Logical OR ($45.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $24FF.w,X		; FE FF 24 ; Increment memory $24FF.w,X [Reads: X Index] [Flags: ZN]
	inc $0022.w,X		; FE 22 00 ; Increment memory $0022.w,X [Reads: X Index] [Flags: ZN]
	ora $B9.b,S		; 03 B9 ; OR accumulator with stack relative $B9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp $4738.w,Y		; D9 38 47 ; Compare accumulator $4738.w,Y [Reads: Y Index] [Flags: ZNC]
	sta $0378.w,Y		; 99 78 03 ; Store accumulator to $0378.w,Y [Reads: Accumulator, Y Index]
	stz $817E.w,X		; 9E 7E 81 ; Store zero to $817E.w,X [Reads: X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $07.b		; 25 07 ; Logical AND $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $23FFFE.l,X		; FF FE FF 23 ; Subtract with carry (long,X) $23FFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $2300.w,X		; FE 00 23 ; Increment memory $2300.w,X [Reads: X Index] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $22FE.w,X		; FE FE 22 ; Increment memory $22FE.w,X [Reads: X Index] [Flags: ZN]
	sbc $F054E0.l,X		; FF E0 54 F0 ; Subtract with carry (long,X) $F054E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $C31EE1.l		; 0F E1 1E C3 ; OR accumulator with memory (long) $C31EE1.l [Writes: Accumulator] [Flags: ZN]
	bit $7987.w,X		; 3C 87 79 ; Test bits $7987.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $1EF3.w		; 0E F3 1E ; Arithmetic shift left $1EF3.w [Flags: ZNC]
	sbc $3F.b,S		; E3 3F ; Subtract stack-relative $3F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp #$77.b		; C9 77 ; Compare #$77.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	stz $E0F0.w		; 9C F0 E0 ; Store zero to $E0F0.w
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$57.b		; A0 57 ; Load #$57.b into Y register [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $5F.b		; A5 5F ; Load $5F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $6F.b,X		; B5 6F ; Load $6F.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc [$BF.b],Y		; 77 BF ; Add with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	sbc $454800.l,X		; FF 00 48 45 ; Subtract with carry (long,X) $454800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	adc $20E000.l,X		; 7F 00 E0 20 ; Add long $20E000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: ZN]
	inc $36.b,X		; F6 36 ; Increment memory $36.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $7FBF00.l,X		; FF 00 BF 7F ; Subtract with carry (long,X) $7FBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	nop		; EA ; No operation
	eor $95.b,X		; 55 95 ; Exclusive OR accumulator with memory $95.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $5F40E0.l,X		; 3F E0 40 5F ; AND accumulator with memory (long,X) $5F40E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7F49.w,Y		; 59 49 7F ; Exclusive OR accumulator with memory $7F49.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $8C18E3.l,X		; 3F E3 18 8C ; AND accumulator with memory (long,X) $8C18E3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($18.b,S),Y		; 73 18 ; Add with carry (stack relative indirect indexed) ($18.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$28.b]		; E7 28 ; Subtract with carry (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$47.b],Y		; D7 47 ; Compare accumulator (long indexed) [$47.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sta $7E7F.w,X		; 9D 7F 7E ; Store accumulator to $7E7F.w,X [Reads: Accumulator, X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $C02FE0.l,X		; FF E0 2F C0 ; Subtract with carry (long,X) $C02FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $0F7F8F.l,X		; 3F 8F 7F 0F ; AND accumulator with memory (long,X) $0F7F8F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $63FF47.l		; EF 47 FF 63 ; Subtract with carry (long) $63FF47.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $6DFF7F.l,X		; FF 7F FF 6D ; Subtract with carry (long,X) $6DFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF7F.w		; ED 7F FF ; Subtract $FF7F.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $38		; 70 38 ; Branch if overflow set to $70, $38 [Flow: branch]
	trb $1200.w		; 1C 00 12 ; Test and reset bits $1200.w [Reads: Accumulator] [Flags: Z]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$E0.b		; C9 E0 ; Compare #$E0.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	sbc $F9FFF8.l,X		; FF F8 FF F9 ; Subtract with carry (long,X) $F9FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $9E99.w,X		; FE 99 9E ; Increment memory $9E99.w,X [Reads: X Index] [Flags: ZN]
	stz $FC9F.w		; 9C 9F FC ; Store zero to $FC9F.w
	sbc $36FFFE.l,X		; FF FE FF 36 ; Subtract with carry (long,X) $36FFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0706.w,X		; 1E 06 07 ; Arithmetic shift left $0706.w,X [Reads: X Index] [Flags: ZNC]
	adc [$62.b]		; 67 62 ; Add with carry (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$28.b],Y		; 97 28 ; Store accumulator (long indexed) [$28.b],Y [Reads: Accumulator, Direct Page, Y Index]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($38.b),Y		; 31 38 ; AND accumulator with memory ($38.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	bit $26BC.w,X		; 3C BC 26 ; Test bits $26BC.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ldx $23.b		; A6 23 ; Load $23.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	lda $26.b,S		; A3 26 ; Load accumulator (stack relative) $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldx $0E.b		; A6 0E ; Load $0E.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	stx $8000.w		; 8E 00 80 ; Store X register to $8000.w [Reads: X Index]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$43.b]		; 47 43 ; Exclusive OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $595C.w,Y		; 59 5C 59 ; Exclusive OR accumulator with memory $595C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($7F.b),Y		; 71 7F ; Add with carry ($7F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1D1C.w,X		; FD 1C 1D ; Subtract with carry $1D1C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C1.b		; C0 C1 ; Compare #$C1.b with Y register [Reads: Y Index] [Flags: ZNC]
	jmp ($EC6D.w)		; 6C 6D EC ; Jump indirect to ($EC6D.w) [Flow: jump]
	sbc $0100.w		; ED 00 01 ; Subtract $0100.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $E2.b		; 02 E2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $923E.w,X		; FE 3E 92 ; Increment memory $923E.w,X [Reads: X Index] [Flags: ZN]
	ora ($FE.b)		; 12 FE ; OR accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $BE3E43.l,X		; BF 43 3E BE ; Load long $BE3E43.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $83AF8F.l		; 4F 8F AF 83 ; Exclusive OR accumulator with memory (long) $83AF8F.l [Writes: Accumulator] [Flags: ZN]
	sta ($E4.b,S),Y		; 93 E4 ; Store accumulator (stack relative indirect indexed) ($E4.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	cpx $6760.w		; EC 60 67 ; Compare $6760.w with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor ($41.b,X)		; 41 41 ; Exclusive OR accumulator with memory ($41.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $50		; B0 50 ; Branch if carry set to $B0, $50 [Flow: branch]
	jmp ($9813.w)		; 6C 13 98 ; Jump indirect to ($9813.w) [Flow: jump]
	jsr ($43FD.w,X)		; FC FD 43 ; Jump to subroutine indirect indexed ($43FD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp ($117D.w,X)		; 7C 7D 11 ; Jump indirect indexed to ($117D.w,X) [Reads: X Index] [Flow: jump]
	.db $F0, $F2		; F0 F2 ; Branch if equal to $F0, $F2 [Flow: branch]
	sbc ($F5.b),Y		; F1 F5 ; Subtract with carry ($F5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($E9.b,X)		; E1 E9 ; Subtract with carry ($E9.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor [$57.b]		; 47 57 ; Exclusive OR accumulator with memory (long) [$57.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $8202EF.l		; 0F EF 02 82 ; OR accumulator with memory (long) $8202EF.l [Writes: Accumulator] [Flags: ZN]
	.db $82, $0D, $0A		; 82 0D 0A ; Branch always long to $82, $0D, $0A [Flow: branch]
	asl $A8.b,X		; 16 A8 ; Arithmetic shift left $A8.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	ora $06FE13.l		; 0F 13 FE 06 ; OR accumulator with memory (long) $06FE13.l [Writes: Accumulator] [Flags: ZN]
	sbc $FB2C.w,X		; FD 2C FB ; Subtract with carry $FB2C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc [$38.b],Y		; F7 38 ; Subtract with carry (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$6C.b]		; E7 6C ; Subtract with carry (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $BD.b		; C6 BD ; Decrement $BD.b [Reads: Direct Page] [Flags: ZN]
	sta $7E.b,S		; 83 7E ; Store accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$5A.b		; E0 5A ; Compare #$5A.b with X register [Reads: X Index] [Flags: ZNC]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: ZN]
	cmp $9D00.w,Y		; D9 00 9D ; Compare accumulator $9D00.w,Y [Reads: Y Index] [Flags: ZNC]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9B.b		; 00 9B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $6E9D.w,Y		; D9 9D 6E ; Compare accumulator $6E9D.w,Y [Reads: Y Index] [Flags: ZNC]
	ror $B9.b,X		; 76 B9 ; Rotate right $B9.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc [$01.b]		; 67 01 ; Add with carry (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F923.w,X)		; FC 23 F9 ; Jump to subroutine indirect indexed ($F923.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$F3.b]		; 07 F3 ; OR accumulator with memory (long) [$F3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $CF17E7.l		; 8F E7 17 CF ; Store accumulator (long) $CF17E7.l [Reads: Accumulator]
	and [$9F.b]		; 27 9F ; AND accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	sbc $FBFC.w,X		; FD FC FB ; Subtract with carry $FBFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $D3D7.w,Y		; F9 D7 D3 ; Subtract with carry $D3D7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$6F.b],Y		; 77 6F ; Add with carry (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$D8.b		; E0 D8 ; Compare #$D8.b with X register [Reads: X Index] [Flags: ZNC]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy $2EED.w,X		; BC ED 2E ; Load Y register $2EED.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $027D.w,X		; FE 7D 02 ; Increment memory $027D.w,X [Reads: X Index] [Flags: ZN]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	.db $90, $27		; 90 27 ; Branch if carry clear to $90, $27 [Flow: branch]
	eor $91.b,S		; 43 91 ; Exclusive OR accumulator with stack relative $91.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $C1.b		; 02 C1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($B963.w,X)		; 7C 63 B9 ; Jump indirect indexed to ($B963.w,X) [Reads: X Index] [Flow: jump]
	and [$D3.b],Y		; 37 D3 ; AND accumulator with memory (long indexed) [$D3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc [$C9.b]		; 67 C9 ; Add with carry (long) [$C9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and [$C4.b],Y		; 37 C4 ; AND accumulator with memory (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $FF01.w,X		; FE 01 FF ; Increment memory $FF01.w,X [Reads: X Index] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $F3.b,X		; F5 F3 ; Subtract $F3.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	wai		; CB ; Wait for interrupt
	cmp [$14.b]		; C7 14 ; Compare accumulator (long) [$14.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tsb $1824.w		; 0C 24 18 ; Test and set bits $1824.w [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $67E6.w,X		; 3C E6 67 ; Test bits $67E6.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $F338.w		; 0C 38 F3 ; Test and set bits $F338.w [Reads: Accumulator] [Flags: Z]
	sbc [$C3.b]		; E7 C3 ; Subtract with carry (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $FE3E.w,Y		; 99 3E FE ; Store accumulator to $FE3E.w,Y [Reads: Accumulator, Y Index]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Accumulator, X Index, Direct Page]
	cmp $81.b,S		; C3 81 ; Compare accumulator (stack relative) $81.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ror $42.b		; 66 42 ; Rotate right $42.b [Reads: Direct Page] [Flags: ZNC]
	bit $1824.w,X		; 3C 24 18 ; Test bits $1824.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $24.b		; 66 24 ; Rotate right $24.b [Reads: Direct Page] [Flags: ZNC]
	cmp $42.b,S		; C3 42 ; Compare accumulator (stack relative) $42.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sta ($C3.b,X)		; 81 C3 ; Store accumulator ($C3.b,X) [Reads: Accumulator, X Index, Direct Page]
	ror $3C.b		; 66 3C ; Rotate right $3C.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $C366.w,X		; 3C 66 C3 ; Test bits $C366.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $36DB1C.l		; EF 1C DB 36 ; Subtract with carry (long) $36DB1C.l [Writes: Accumulator] [Flags: ZVNC]
	ldy $727B.w		; AC 7B 72 ; Load $727B.w into Y register [Writes: Y Index] [Flags: ZN]
	cmp $E5BA.w		; CD BA E5 ; Compare $E5BA.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ldy $EB.b,X		; B4 EB ; Load Y register $EB.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	trb $EF.b		; 14 EF ; Test and reset bits $EF.b [Reads: Accumulator] [Flags: Z]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	lda [$7B.b],Y		; B7 7B ; Load accumulator (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $B4E5.w		; CD E5 B4 ; Compare $B4E5.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	ora [$DB.b],Y		; 17 DB ; OR accumulator with memory (long indexed) [$DB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F60A.w,X		; FD 0A F6 ; Subtract with carry $F60A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and #$DF.b		; 29 DF ; Logical AND #$DF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jsr $01FE.w		; 20 FE 01 ; Jump to subroutine at $01FE.w [Writes: Stack Pointer] [Flow: call]
	sbc $F702.w,X		; FD 02 F7 ; Subtract with carry $F702.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	asl $A9.b,X		; 16 A9 ; Arithmetic shift left $A9.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldx $9F.b		; A6 9F ; Load $9F.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	inc $F3E9.w,X		; FE E9 F3 ; Increment memory $F3E9.w,X [Reads: X Index] [Flags: ZN]
	sbc $C30000.l,X		; FF 00 00 C3 ; Subtract with carry (long,X) $C30000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $F8EFFC.l,X		; 3F FC EF F8 ; AND accumulator with memory (long,X) $F8EFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor [$E8.b],Y		; 57 E8 ; Exclusive OR accumulator with memory (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$FB.b],Y		; D7 FB ; Compare accumulator (long indexed) [$FB.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sbc $0D0023.l		; EF 23 00 0D ; Subtract with carry (long) $0D0023.l [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	stz $FEEB.w		; 9C EB FE ; Store zero to $FEEB.w
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	asl $28F7.w,X		; 1E F7 28 ; Arithmetic shift left $28F7.w,X [Reads: X Index] [Flags: ZNC]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $2208EF.l,X		; BF EF 08 22 ; Load long $2208EF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cpx #$2E.b		; E0 2E ; Compare #$2E.b with X register [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	lda $C80B.w,Y		; B9 0B C8 ; Load $C80B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stz $02.b		; 64 02 ; Store zero to $02.b
	sta $FBA7.w,Y		; 99 A7 FB ; Store accumulator to $FBA7.w,Y [Reads: Accumulator, Y Index]
	sbc [$DF.b]		; E7 DF ; Subtract with carry (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $35.b,S		; E3 35 ; Subtract stack-relative $35.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	adc $1C.b,S		; 63 1C ; Add with carry (stack relative) $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	lsr $34.b		; 46 34 ; Logical shift right $34.b [Reads: Direct Page] [Flags: ZNC]
	sta $0040.w,Y		; 99 40 00 ; Store accumulator to $0040.w,Y [Reads: Accumulator, Y Index]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $18		; 80 18 ; Branch always to $80, $18 [Flow: branch]
	cmp $33B0.w,Y		; D9 B0 33 ; Compare accumulator $33B0.w,Y [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	stx $21.b		; 86 21 ; Store X register to $21.b [Reads: X Index]
	eor $A599.w,X		; 5D 99 A5 ; Exclusive OR accumulator with memory $A599.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stz $B2A0.w		; 9C A0 B2 ; Store zero to $B2A0.w
	cpy $1EE9.w		; CC E9 1E ; Compare $1EE9.w with Y register [Reads: Y Index] [Flags: ZNC]
	rol $4C.b		; 26 4C ; Rotate left $4C.b [Reads: Direct Page] [Flags: ZNC]
	and $4282.w,Y		; 39 82 42 ; AND accumulator with memory $4282.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $2F		; F0 2F ; Branch if equal to $F0, $2F [Flow: branch]
	ora $001101.l,X		; 1F 01 11 00 ; Logical OR long $001101.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $C381.w,X		; 7E 81 C3 ; Rotate right $C381.w,X [Reads: X Index] [Flags: ZNC]
	ror $7EA5.w,X		; 7E A5 7E ; Rotate right $7EA5.w,X [Reads: X Index] [Flags: ZNC]
	lda $7E.b,S		; A3 7E ; Load accumulator (stack relative) $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit #$7E.b		; 89 7E ; Test bits #$7E.b with accumulator [Reads: Accumulator] [Flags: Z]
	lda ($7E.b,X)		; A1 7E ; Load accumulator ($7E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: ZNC]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $42, $F9		; 42 F9 ; Reserved instruction
	and [$F3.b],Y		; 37 F3 ; AND accumulator with memory (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $C3DBE7.l		; 6F E7 DB C3 ; Add with carry (long) $C3DBE7.l [Writes: Accumulator] [Flags: ZVNC]
	lda $3E7D99.l,X		; BF 99 7D 3E ; Load long $3E7D99.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $836F.w		; EE 6F 83 ; Increment $836F.w [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($24.b,S),Y		; 33 24 ; AND accumulator (stack relative indirect indexed) ($24.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $42, $81		; 42 81 ; Reserved instruction
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	ora #$CD.b		; 09 CD ; Logical OR #$CD.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sta $EB.b,S		; 83 EB ; Store accumulator (stack relative) $EB.b,S [Reads: Accumulator, Stack Pointer]
	cmp $F3.b,S		; C3 F3 ; Compare accumulator (stack relative) $F3.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	cmp $EF.b,S		; C3 EF ; Compare accumulator (stack relative) $EF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sta ($D2.b)		; 92 D2 ; Store accumulator (indirect) ($D2.b) [Reads: Accumulator, Direct Page]
	asl $089F.w,X		; 1E 9F 08 ; Arithmetic shift left $089F.w,X [Reads: X Index] [Flags: ZNC]
	wai		; CB ; Wait for interrupt
	eor $32.b		; 45 32 ; Exclusive OR $32.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $0C.b		; 14 0C ; Test and reset bits $0C.b [Reads: Accumulator] [Flags: Z]
	.db $10, $2D		; 10 2D ; Branch if plus to $10, $2D [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $3E.b,X		; 34 3E ; Test bits $3E.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	adc $C3BF9F.l,X		; 7F 9F BF C3 ; Add long $C3BF9F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp ($83.b,S),Y		; D3 83 ; Compare accumulator (stack relative indirect indexed) ($83.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ora ($65.b,X)		; 01 65 ; Logical OR ($65.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda $4B48.w,Y		; B9 48 4B ; Load $4B48.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	bit $9A44.w		; 2C 44 9A ; Test bits $9A44.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	and $46.b		; 25 46 ; Logical AND $46.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy $F0.b,X		; B4 F0 ; Load Y register $F0.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	and $E001B0.l		; 2F B0 01 E0 ; AND accumulator with memory (long) $E001B0.l [Writes: Accumulator] [Flags: ZN]
	eor ($81.b,S),Y		; 53 81 ; XOR accumulator (stack relative indirect indexed) ($81.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$41.b]		; 67 41 ; Add with carry (long) [$41.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda $5B23.w,X		; BD 23 5B ; Load $5B23.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta ($AD.b),Y		; 91 AD ; Store accumulator ($AD.b),Y [Reads: Accumulator, Direct Page, Y Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	inc $E4.b,X		; F6 E4 ; Increment memory $E4.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc ($F5.b)		; F2 F5 ; Subtract with carry (indirect) ($F5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $18FA.w,Y		; F9 FA 18 ; Subtract with carry $18FA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $84.b		; 02 84 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $01		; 42 01 ; Reserved instruction
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	tsb $F1.b		; 04 F1 ; Test and set bits $F1.b [Reads: Accumulator] [Flags: Z]
	inc $E2.b,X		; F6 E2 ; Increment memory $E2.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $9A84.w		; ED 84 9A ; Subtract $9A84.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	bit #$B5.b		; 89 B5 ; Test bits #$B5.b with accumulator [Reads: Accumulator] [Flags: Z]
	ora ($6B.b,S),Y		; 13 6B ; OR accumulator (stack relative indirect indexed) ($6B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($DD.b,X)		; 21 DD ; Logical AND ($DD.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldx $7FBC.w,Y		; BE BC 7F ; Load X register $7FBC.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $61		; 10 61 ; Branch if plus to $10, $61 [Flow: branch]
	.db $42, $84		; 42 84 ; Reserved instruction
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $76F9.w,X		; 3C F9 76 ; Test bits $76F9.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $CD32.w,X		; FD 32 CD ; Subtract with carry $CD32.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($A1.b)		; 32 A1 ; AND accumulator with memory (indirect) ($A1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $58A7.w,X		; 5E A7 58 ; Logical shift right $58A7.w,X [Reads: X Index] [Flags: ZNC]
	sta $50AF70.l		; 8F 70 AF 50 ; Store accumulator (long) $50AF70.l [Reads: Accumulator]
	lda $3276.w,X		; BD 76 32 ; Load $3276.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($5E.b)		; 32 5E ; AND accumulator with memory (indirect) ($5E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $5773.w,Y		; 59 73 57 ; Exclusive OR accumulator with memory $5773.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $42BD00.l,X		; FF 00 BD 42 ; Subtract with carry (long,X) $42BD00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpx $CF.b		; E4 CF ; Compare $CF.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $30, $E7		; 30 E7 ; Branch if minus to $30, $E7 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $E2.b		; 84 E2 ; Store Y register to $E2.b [Reads: Y Index]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $3BFD.w,X		; FE FD 3B ; Increment memory $3BFD.w,X [Reads: X Index] [Flags: ZN]
	sta $E7EBCF.l,X		; 9F CF EB E7 ; Store accumulator (long,X) $E7EBCF.l,X [Reads: Accumulator, X Index]
	jsr ($38EF.w,X)		; FC EF 38 ; Jump to subroutine indirect indexed ($38EF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp [$28.b],Y		; D7 28 ; Compare accumulator (long indexed) [$28.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	brk $A9.b		; 00 A9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: ZNC]
	eor [$F8.b],Y		; 57 F8 ; Exclusive OR accumulator with memory (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $237F80.l		; 6F 80 7F 23 ; Add with carry (long) $237F80.l [Writes: Accumulator] [Flags: ZVNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $1CF7.w,Y		; F9 F7 1C ; Subtract with carry $1CF7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	stx $61.b,Y		; 96 61 ; Store X register $61.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	and $83FFEB.l,X		; 3F EB FF 83 ; AND accumulator with memory (long,X) $83FFEB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit #$02.b		; 89 02 ; Test bits #$02.b with accumulator [Reads: Accumulator] [Flags: Z]
	jsl $080100.l		; 22 00 01 08 ; Jump to subroutine long $080100.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $081300.l		; 22 00 13 08 ; Jump to subroutine long $081300.l [Writes: Stack Pointer] [Flow: call]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ldy $5C22.w,X		; BC 22 5C ; Load Y register $5C22.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ldy $AC92.w		; AC 92 AC ; Load $AC92.w into Y register [Writes: Y Index] [Flags: ZN]
	stz $22A0.w,X		; 9E A0 22 ; Store zero to $22A0.w,X [Reads: X Index]
	eor ($1D.b,X)		; 41 1D ; Exclusive OR accumulator with memory ($1D.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp.w [$0100]		; DC 00 01 ; Jump long indirect [$0100] [Flow: jump]
	sta ($22.b,X)		; 81 22 ; Store accumulator ($22.b,X) [Reads: Accumulator, X Index, Direct Page]
	eor ($19.b,X)		; 41 19 ; Exclusive OR accumulator with memory ($19.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	stz $2522.w		; 9C 22 25 ; Store zero to $2522.w
	asl $CED1.w,X		; 1E D1 CE ; Arithmetic shift left $CED1.w,X [Reads: X Index] [Flags: ZNC]
	inc $E9E0.w		; EE E0 E9 ; Increment $E9E0.w [Flags: ZN]
	sbc $E1.b		; E5 E1 ; Subtract $E1.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc #$C1.b		; E9 C1 ; Subtract #$C1.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	cmp $3600.w,X		; DD 00 36 ; Compare accumulator $3600.w,X [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	cpy #$20.b		; C0 20 ; Compare #$20.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $22.b,X		; 16 22 ; Arithmetic shift left $22.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cmp #$14.b		; C9 14 ; Compare #$14.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	sta ($A0.b)		; 92 A0 ; Store accumulator (indirect) ($A0.b) [Reads: Accumulator, Direct Page]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($99.b,X)		; 41 99 ; Exclusive OR accumulator with memory ($99.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldx $02.b,Y		; B6 02 ; Load X register $02.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	asl $7F.b		; 06 7F ; Arithmetic shift left $7F.b [Reads: Direct Page] [Flags: ZNC]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp $489B40.l		; CF 40 9B 48 ; Compare accumulator (long) $489B40.l [Reads: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $0002.w		; 9C 02 00 ; Store zero to $0002.w
	ora $672430.l,X		; 1F 30 24 67 ; Logical OR long $672430.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $E5.b		; 26 E5 ; Rotate left $E5.b [Reads: Direct Page] [Flags: ZNC]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $3C02.w,X		; FD 02 3C ; Subtract with carry $3C02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $81.b,S		; 43 81 ; Exclusive OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $FF06.w,X		; 7E 06 FF ; Rotate right $FF06.w,X [Reads: X Index] [Flags: ZNC]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $42, $42		; 42 42 ; Reserved instruction
	ror $0022.w,X		; 7E 22 00 ; Rotate right $0022.w,X [Reads: X Index] [Flags: ZNC]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $608000.l,X		; 7F 00 80 60 ; Add long $608000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	lda $C00A3F.l,X		; BF 3F 0A C0 ; Load long $C00A3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FF7F80.l,X		; 7F 80 7F FF ; Add long $FF7F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $40407F.l,X		; 7F 7F 40 40 ; Add long $40407F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $B50300.l		; 22 00 03 B5 ; Jump to subroutine long $B50300.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $E7		; 42 E7 ; Reserved instruction
	bit $4A.b		; 24 4A ; Test bits $4A.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lda $66.b		; A5 66 ; Load $66.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: ZNC]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	stz $807F.w		; 9C 7F 80 ; Store zero to $807F.w
	adc $FF3FC0.l,X		; 7F C0 3F FF ; Add long $FF3FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda ($83.b,S),Y		; B3 83 ; Load accumulator (stack relative indirect indexed) ($83.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $03.b,S		; 63 03 ; Add with carry (stack relative) $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $002780.l,X		; 7F 80 27 00 ; Add long $002780.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $FC03.w,X		; FE 03 FC ; Increment memory $FC03.w,X [Reads: X Index] [Flags: ZN]
	sbc $FE9F00.l,X		; FF 00 9F FE ; Subtract with carry (long,X) $FE9F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $E4DFA0.l,X		; BF A0 DF E4 ; Load long $E4DFA0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0EA2.w		; 0C A2 0E ; Test and set bits $0EA2.w [Reads: Accumulator] [Flags: Z]
	eor $B2.b,S		; 43 B2 ; Exclusive OR accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $07.b,X		; 56 07 ; Logical shift right $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldy $46.b,X		; B4 46 ; Load Y register $46.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $B0, $5A		; B0 5A ; Branch if carry set to $B0, $5A [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($51.b,S),Y		; 13 51 ; OR accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $450049.l		; 22 49 00 45 ; Jump to subroutine long $450049.l [Writes: Stack Pointer] [Flow: call]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $30F03F.l,X		; 1F 3F F0 30 ; Logical OR long $30F03F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $E42C.w		; EC 2C E4 ; Compare $E42C.w with X register [Reads: X Index] [Flags: ZNC]
	bit $F0.b		; 24 F0 ; Test bits $F0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	adc $5E4F40.l,X		; 7F 40 4F 5E ; Add long $5E4F40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($5B.b,S),Y		; 53 5B ; XOR accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $050602.l		; 4F 02 06 05 ; Exclusive OR accumulator with memory (long) $050602.l [Writes: Accumulator] [Flags: ZN]
	tsb $1007.w		; 0C 07 10 ; Test and set bits $1007.w [Reads: Accumulator] [Flags: Z]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3C42.w,Y		; 19 42 3C ; OR accumulator with memory $3C42.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FB00.w,X		; FD 00 FB ; Subtract with carry $FB00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: ZNC]
	and ($BF.b),Y		; 31 BF ; AND accumulator with memory ($BF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $BF.b,S		; 23 BF ; AND accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$BF.b]		; 07 BF ; OR accumulator with memory (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$BF.b]		; 27 BF ; AND accumulator with memory (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $FF0EDE.l,X		; 3F DE 0E FF ; AND accumulator with memory (long,X) $FF0EDE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $E23D.w,Y		; F9 3D E2 ; Subtract with carry $E23D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $785C.w		; 4E 5C 78 ; Logical shift right $785C.w [Flags: ZNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc ($71.b,X)		; 61 71 ; Add with carry ($71.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $F6F91D.l,X		; 3F 1D F9 F6 ; AND accumulator with memory (long,X) $F6F91D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($DE.b,X)		; E1 DE ; Subtract with carry ($DE.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta ($FE.b,X)		; 81 FE ; Store accumulator ($FE.b,X) [Reads: Accumulator, X Index, Direct Page]
	ora #$FE.b		; 09 FE ; Logical OR #$FE.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $0FFE.w		; 0D FE 0F ; Logical OR $0FFE.w with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $F140.w,X		; FE 40 F1 ; Increment memory $F140.w,X [Reads: X Index] [Flags: ZN]
	.db $90, $6F		; 90 6F ; Branch if carry clear to $90, $6F [Flow: branch]
	ora $F77F3F.l		; 0F 3F 7F F7 ; OR accumulator with memory (long) $F77F3F.l [Writes: Accumulator] [Flags: ZN]
	sbc ($F1.b,S),Y		; F3 F1 ; Subtract with carry (stack relative indirect indexed) ($F1.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $9790.w,Y		; BE 90 97 ; Load X register $9790.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	trb $FF.b		; 14 FF ; Test and reset bits $FF.b [Reads: Accumulator] [Flags: Z]
	sbc $5FBFBF.l,X		; FF BF BF 5F ; Subtract with carry (long,X) $5FBFBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $E0F939.l,X		; 7F 39 F9 E0 ; Add long $E0F939.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($EE.b),Y		; F1 EE ; Subtract with carry ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FDFEF0.l,X		; FF F0 FE FD ; Subtract with carry (long,X) $FDFEF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $4000.w,X		; FD 00 40 ; Subtract with carry $4000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $06		; 80 06 ; Branch always to $80, $06 [Flow: branch]
	asl $0062.w		; 0E 62 00 ; Arithmetic shift left $0062.w [Flags: ZNC]
	ora $E0.b,X		; 15 E0 ; OR accumulator with memory $E0.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $D1.b,S		; E3 D1 ; Subtract stack-relative $D1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp $47BFAF.l,X		; DF AF BF 47 ; Compare accumulator (long,X) $47BFAF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc [$27.b]		; 67 27 ; Add with carry (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $BE7E3E.l,X		; 7F 3E 7E BE ; Add long $BE7E3E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1CFF7F.l,X		; FF 7F FF 1C ; Subtract with carry (long,X) $1CFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $9840.w		; 20 40 98 ; Jump to subroutine at $9840.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $81		; 80 81 ; Branch always to $80, $81 [Flow: branch]
	sta $1E.b,S		; 83 1E ; Store accumulator (stack relative) $1E.b,S [Reads: Accumulator, Stack Pointer]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rol $CB08.w,X		; 3E 08 CB ; Rotate left $CB08.w,X [Reads: X Index] [Flags: ZNC]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($BD.b,X)		; 81 BD ; Store accumulator ($BD.b,X) [Reads: Accumulator, X Index, Direct Page]
	cmp $DB.b,S		; C3 DB ; Compare accumulator (stack relative) $DB.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	cmp ($DD.b,X)		; C1 DD ; Compare accumulator ($DD.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sta $B3.b,S		; 83 B3 ; Store accumulator (stack relative) $B3.b,S [Reads: Accumulator, Stack Pointer]
	asl $466E.w		; 0E 6E 46 ; Arithmetic shift left $466E.w [Flags: ZNC]
	bit $99.b,X		; 34 99 ; Test bits $99.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $42, $24		; 42 24 ; Reserved instruction
	jsl $3E914C.l		; 22 4C 91 3E ; Jump to subroutine long $3E914C.l [Writes: Stack Pointer] [Flow: call]
	sbc $1B9F1F.l,X		; FF 1F 9F 1B ; Subtract with carry (long,X) $1B9F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora $63.b,S		; 03 63 ; OR accumulator with stack relative $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($B9.b,X)		; 81 B9 ; Store accumulator ($B9.b,X) [Reads: Accumulator, X Index, Direct Page]
	.db $80, $BC		; 80 BC ; Branch always to $80, $BC [Flow: branch]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	wai		; CB ; Wait for interrupt
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $9C.b		; 24 9C ; Test bits $9C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lsr $43.b		; 46 43 ; Logical shift right $43.b [Reads: Direct Page] [Flags: ZNC]
	sta $9B34.w,Y		; 99 34 9B ; Store accumulator to $9B34.w,Y [Reads: Accumulator, Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $0F990F.l,X		; 9F 0F 99 0F ; Store accumulator (long,X) $0F990F.l,X [Reads: Accumulator, X Index]
	sta $40C010.l		; 8F 10 C0 40 ; Store accumulator (long) $40C010.l [Reads: Accumulator]
	sbc $70BF60.l,X		; FF 60 BF 70 ; Subtract with carry (long,X) $70BF60.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $676C.w		; 9C 6C 67 ; Store zero to $676C.w
	jsl $3F0360.l		; 22 60 03 3F ; Jump to subroutine long $3F0360.l [Writes: Stack Pointer] [Flow: call]
	ora $8C0300.l,X		; 1F 00 03 8C ; Logical OR long $8C0300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $677F.w		; 9C 7F 67 ; Store zero to $677F.w
	jsl $3F0460.l		; 22 60 04 3F ; Jump to subroutine long $3F0460.l [Writes: Stack Pointer] [Flow: call]
	ora $9F0000.l,X		; 1F 00 00 9F ; Logical OR long $9F0000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora ($33.b,X)		; 01 33 ; Logical OR ($33.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($43.b,S),Y		; 33 43 ; AND accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $01FF.w,X		; FE FF 01 ; Increment memory $01FF.w,X [Reads: X Index] [Flags: ZN]
	dec $23FF.w		; CE FF 23 ; Decrement $23FF.w [Flags: ZN]
	inc $CC00.w,X		; FE 00 CC ; Increment memory $CC00.w,X [Reads: X Index] [Flags: ZN]
	jsl $B10500.l		; 22 00 05 B1 ; Jump to subroutine long $B10500.l [Writes: Stack Pointer] [Flow: call]
	.db $50, $D9		; 50 D9 ; Branch if overflow clear to $50, $D9 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor $93.b,S		; 43 93 ; Exclusive OR accumulator with stack relative $93.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $70, $13		; 70 13 ; Branch if overflow set to $70, $13 [Flow: branch]
	sta $9E78.w,Y		; 99 78 9E ; Store accumulator to $9E78.w,Y [Reads: Accumulator, Y Index]
	ror $7881.w,X		; 7E 81 78 ; Rotate right $7881.w,X [Reads: X Index] [Flags: ZNC]
	ora $0F0707.l		; 0F 07 07 0F ; OR accumulator with memory (long) $0F0707.l [Writes: Accumulator] [Flags: ZN]
	ora $070107.l		; 0F 07 01 07 ; OR accumulator with memory (long) $070107.l [Writes: Accumulator] [Flags: ZN]
	sbc $FF0000.l,X		; FF 00 00 FF ; Subtract with carry (long,X) $FF0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $23FF.w,X		; FE FF 23 ; Increment memory $23FF.w,X [Reads: X Index] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc ($44.b,S),Y		; F3 44 ; Subtract with carry (stack relative indirect indexed) ($44.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $FE2400.l		; 22 00 24 FE ; Jump to subroutine long $FE2400.l [Writes: Stack Pointer] [Flow: call]
	cpx #$54.b		; E0 54 ; Compare #$54.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sta [$79.b]		; 87 79 ; Store accumulator (long) [$79.b] [Reads: Accumulator, Direct Page]
	asl $1EF3.w		; 0E F3 1E ; Arithmetic shift left $1EF3.w [Flags: ZNC]
	sbc $3F.b,S		; E3 3F ; Subtract stack-relative $3F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp #$77.b		; C9 77 ; Compare #$77.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	stz $E0F0.w		; 9C F0 E0 ; Store zero to $E0F0.w
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$57.b		; A0 57 ; Load #$57.b into Y register [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $5F.b		; A5 5F ; Load $5F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $6F.b,X		; B5 6F ; Load $6F.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc [$BF.b],Y		; 77 BF ; Add with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	sbc $454800.l,X		; FF 00 48 45 ; Subtract with carry (long,X) $454800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	adc $20E000.l,X		; 7F 00 E0 20 ; Add long $20E000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: ZN]
	inc $36.b,X		; F6 36 ; Increment memory $36.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $7FBF00.l,X		; FF 00 BF 7F ; Subtract with carry (long,X) $7FBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	nop		; EA ; No operation
	eor $95.b,X		; 55 95 ; Exclusive OR accumulator with memory $95.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $5F40E0.l,X		; 3F E0 40 5F ; AND accumulator with memory (long,X) $5F40E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7F49.w,Y		; 59 49 7F ; Exclusive OR accumulator with memory $7F49.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $8C18E3.l,X		; 3F E3 18 8C ; AND accumulator with memory (long,X) $8C18E3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($18.b,S),Y		; 73 18 ; Add with carry (stack relative indirect indexed) ($18.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$28.b]		; E7 28 ; Subtract with carry (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$47.b],Y		; D7 47 ; Compare accumulator (long indexed) [$47.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sta $7E7F.w,X		; 9D 7F 7E ; Store accumulator to $7E7F.w,X [Reads: Accumulator, X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $392FE0.l,X		; FF E0 2F 39 ; Subtract with carry (long,X) $392FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: ZN]
	sbc ($3E.b),Y		; F1 3E ; Subtract with carry ($3E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $03BE27.l,X		; DF 27 BE 03 ; Compare accumulator (long,X) $03BE27.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	lda $38BF23.l,X		; BF 23 BF 38 ; Load long $38BF23.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda [$3F.b],Y		; B7 3F ; Load accumulator (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $617F39.l,X		; BF 39 7F 61 ; Load long $617F39.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $5C78.w,Y		; 59 78 5C ; Exclusive OR accumulator with memory $5C78.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $7F8040.l		; 4F 40 80 7F ; Exclusive OR accumulator with memory (long) $7F8040.l [Writes: Accumulator] [Flags: ZN]
	ora ($82.b,X)		; 01 82 ; Logical OR ($82.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $38FE.w,Y		; 79 FE 38 ; Add $38FE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $8DFF18.l,X		; FF 18 FF 8D ; Subtract with carry (long,X) $8DFF18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $DFE2.w,X		; FE E2 DF ; Increment memory $DFE2.w,X [Reads: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc [$80.b],Y		; F7 80 ; Subtract with carry (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E6C687.l,X		; FF 87 C6 E6 ; Subtract with carry (long,X) $E6C687.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($3C.b,S),Y		; 73 3C ; Add with carry (stack relative indirect indexed) ($3C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $022897.l		; 0F 97 28 02 ; OR accumulator with memory (long) $022897.l [Writes: Accumulator] [Flags: ZN]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $39.b		; 84 39 ; Store Y register to $39.b [Reads: Y Index]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	eor $79307F.l,X		; 5F 7F 30 79 ; Exclusive OR accumulator with memory (long,X) $79307F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($7F.b),Y		; 31 7F ; AND accumulator with memory ($7F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $044585.l,X		; 3F 85 45 04 ; AND accumulator with memory (long,X) $044585.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$29.b		; E0 29 ; Compare #$29.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $86		; 80 86 ; Branch always to $80, $86 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$8B.b]		; E7 8B ; Subtract with carry (long) [$8B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $C7DF9B.l		; CF 9B DF C7 ; Compare accumulator (long) $C7DF9B.l [Reads: Accumulator] [Flags: ZNC]
	sbc $FDFDFC.l,X		; FF FC FD FD ; Subtract with carry (long,X) $FDFDFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $CCDE9E.l,X		; FF 9E DE CC ; Subtract with carry (long,X) $CCDE9E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $3018.w,X		; FD 18 30 ; Subtract with carry $3018.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $0200.w		; 20 00 02 ; Jump to subroutine at $0200.w [Writes: Stack Pointer] [Flow: call]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1C.b		; 02 1C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $DB18.w,X		; DD 18 DB ; Compare accumulator $DB18.w,X [Reads: X Index] [Flags: ZNC]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $BF.b,S		; 83 BF ; Store accumulator (stack relative) $BF.b,S [Reads: Accumulator, Stack Pointer]
	cmp ($DD.b,X)		; C1 DD ; Compare accumulator ($DD.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	cpx #$E6.b		; E0 E6 ; Compare #$E6.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $62, $FB, $11		; 62 FB 11 ; Push effective relative address $62, $FB, $11 [Writes: Stack Pointer]
	jsl $409924.l		; 22 24 99 40 ; Jump to subroutine long $409924.l [Writes: Stack Pointer] [Flow: call]
	jsl $020419.l		; 22 19 04 02 ; Jump to subroutine long $020419.l [Writes: Stack Pointer] [Flow: call]
	bit $78BD.w,X		; 3C BD 78 ; Test bits $78BD.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $F6		; F0 F6 ; Branch if equal to $F0, $F6 [Flow: branch]
	and ($ED.b,X)		; 21 ED ; Logical AND ($ED.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($29.b,X)		; 21 29 ; Logical AND ($29.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $C2.b,S		; 83 C2 ; Store accumulator (stack relative) $C2.b,S [Reads: Accumulator, Stack Pointer]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	.db $42, $84		; 42 84 ; Reserved instruction
	ora #$12.b		; 09 12 ; Logical OR #$12.b with accumulator [Writes: Accumulator] [Flags: ZN]
	dec $22.b,X		; D6 22 ; Decrement memory $22.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cmp #$14.b		; C9 14 ; Compare #$14.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	sbc $FE130F.l,X		; FF 0F 13 FE ; Subtract with carry (long,X) $FE130F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $FD.b		; 06 FD ; Arithmetic shift left $FD.b [Reads: Direct Page] [Flags: ZNC]
	bit $18FB.w		; 2C FB 18 ; Test bits $18FB.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sbc [$38.b],Y		; F7 38 ; Subtract with carry (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$6C.b]		; E7 6C ; Subtract with carry (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $BD.b		; C6 BD ; Decrement $BD.b [Reads: Direct Page] [Flags: ZN]
	sta $7E.b,S		; 83 7E ; Store accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $006300.l,X		; DF 00 63 00 ; Compare accumulator (long,X) $006300.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	cmp $0044.w,X		; DD 44 00 ; Compare accumulator $0044.w,X [Reads: X Index] [Flags: ZNC]
	ldx $BD04.w,Y		; BE 04 BD ; Load X register $BD04.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$42.b		; E0 42 ; Compare #$42.b with X register [Reads: X Index] [Flags: ZNC]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $F9.b,S		; 23 F9 ; AND accumulator with stack relative $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$F3.b]		; 07 F3 ; OR accumulator with memory (long) [$F3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $CF17E7.l		; 8F E7 17 CF ; Store accumulator (long) $CF17E7.l [Reads: Accumulator]
	and [$9F.b]		; 27 9F ; AND accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	sbc $FBFC.w,X		; FD FC FB ; Subtract with carry $FBFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $D3D7.w,Y		; F9 D7 D3 ; Subtract with carry $D3D7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$6F.b],Y		; 77 6F ; Add with carry (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$D8.b		; E0 D8 ; Compare #$D8.b with X register [Reads: X Index] [Flags: ZNC]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy $2EED.w,X		; BC ED 2E ; Load Y register $2EED.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $027D.w,X		; FE 7D 02 ; Increment memory $027D.w,X [Reads: X Index] [Flags: ZN]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	.db $90, $27		; 90 27 ; Branch if carry clear to $90, $27 [Flow: branch]
	eor $91.b,S		; 43 91 ; Exclusive OR accumulator with stack relative $91.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $C1.b		; 02 C1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($B963.w,X)		; 7C 63 B9 ; Jump indirect indexed to ($B963.w,X) [Reads: X Index] [Flow: jump]
	and [$D3.b],Y		; 37 D3 ; AND accumulator with memory (long indexed) [$D3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc [$C9.b]		; 67 C9 ; Add with carry (long) [$C9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and [$C4.b],Y		; 37 C4 ; AND accumulator with memory (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $FF01.w,X		; FE 01 FF ; Increment memory $FF01.w,X [Reads: X Index] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$F5.b],Y		; 17 F5 ; OR accumulator with memory (long indexed) [$F5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($CB.b,S),Y		; F3 CB ; Subtract with carry (stack relative indirect indexed) ($CB.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$14.b]		; C7 14 ; Compare accumulator (long) [$14.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tsb $1824.w		; 0C 24 18 ; Test and set bits $1824.w [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $67E6.w,X		; 3C E6 67 ; Test bits $67E6.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $F338.w		; 0C 38 F3 ; Test and set bits $F338.w [Reads: Accumulator] [Flags: Z]
	sbc [$C3.b]		; E7 C3 ; Subtract with carry (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $FE3E.w,Y		; 99 3E FE ; Store accumulator to $FE3E.w,Y [Reads: Accumulator, Y Index]
	eor $2700FF.l		; 4F FF 00 27 ; Exclusive OR accumulator with memory (long) $2700FF.l [Writes: Accumulator] [Flags: ZN]
	sbc $E00037.l,X		; FF 37 00 E0 ; Subtract with carry (long,X) $E00037.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and #$FD.b		; 29 FD ; Logical AND #$FD.b with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $33F3.w,X		; 7D F3 33 ; Add $33F3.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $6F7FDF.l,X		; FF DF 7F 6F ; Subtract with carry (long,X) $6F7FDF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $3E26.w,X		; 3E 26 3E ; Rotate left $3E26.w,X [Reads: X Index] [Flags: ZNC]
	jsl $F12D3F.l		; 22 3F 2D F1 ; Jump to subroutine long $F12D3F.l [Writes: Stack Pointer] [Flow: call]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	tsb $8000.w		; 0C 00 80 ; Test and set bits $8000.w [Reads: Accumulator] [Flags: Z]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: ZNC]
	adc $84AB60.l		; 6F 60 AB 84 ; Add with carry (long) $84AB60.l [Writes: Accumulator] [Flags: ZVNC]
	stz $03.b,X		; 74 03 ; Store zero to $03.b,X [Reads: X Index]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $1B10.w		; EC 10 1B ; Compare $1B10.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$FB.b		; E0 FB ; Compare #$FB.b with X register [Reads: X Index] [Flags: ZNC]
	tsb $88.b		; 04 88 ; Test and set bits $88.b [Reads: Accumulator] [Flags: Z]
	ora [$9F.b]		; 07 9F ; OR accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $E0FF25.l,X		; 7F 25 FF E0 ; Add long $E0FF25.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $A27F41.l,X		; 3F 41 7F A2 ; AND accumulator with memory (long,X) $A27F41.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldx $DCDC.w,Y		; BE DC DC ; Load X register $DCDC.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	ror $BDFF.w,X		; 7E FF BD ; Rotate right $BDFF.w,X [Reads: X Index] [Flags: ZNC]
	sbc $A47E5A.l,X		; FF 5A 7E A4 ; Subtract with carry (long,X) $A47E5A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy $4180.w,X		; BC 80 41 ; Load Y register $4180.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	and $1F.b,S		; 23 1F ; AND accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($43.b,X)		; 81 43 ; Store accumulator ($43.b,X) [Reads: Accumulator, X Index, Direct Page]
	and $F7F73F.l,X		; 3F 3F F7 F7 ; AND accumulator with memory (long,X) $F7F73F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $71FF.w,X		; FD FF 71 ; Subtract with carry $71FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $013F3F.l,X		; 7F 3F 3F 01 ; Add long $013F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($7C.b,X)		; 01 7C ; Logical OR ($7C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jmp ($FEFA.w,X)		; 7C FA FE ; Jump indirect indexed to ($FEFA.w,X) [Reads: X Index] [Flow: jump]
	cpy #$08.b		; C0 08 ; Compare #$08.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	sta $01.b,S		; 83 01 ; Store accumulator (stack relative) $01.b,S [Reads: Accumulator, Stack Pointer]
	adc $FF77FF.l,X		; 7F FF 77 FF ; Add long $FF77FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda [$7F.b],Y		; B7 7F ; Load accumulator (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $1F6E3F.l,X		; 5F 3F 6E 1F ; Exclusive OR accumulator with memory (long,X) $1F6E3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda ($8E.b),Y		; B1 8E ; Load accumulator ($8E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $0023C0.l,X		; DF C0 23 00 ; Compare accumulator (long,X) $0023C0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ora ($80.b,S),Y		; 13 80 ; OR accumulator (stack relative indirect indexed) ($80.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	jsr $FF7E.w		; 20 7E FF ; Jump to subroutine at $FF7E.w [Writes: Stack Pointer] [Flow: call]
	inc $BD7F.w,X		; FE 7F BD ; Increment memory $BD7F.w,X [Reads: X Index] [Flags: ZN]
	ror $3D52.w,X		; 7E 52 3D ; Rotate right $3D52.w,X [Reads: X Index] [Flags: ZNC]
	adc $B391.w		; 6D 91 B3 ; Add $B391.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	eor $2C.b,S		; 43 2C ; Exclusive OR accumulator with stack relative $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cmp $220FEC.l		; CF EC 0F 22 ; Compare accumulator (long) $220FEC.l [Reads: Accumulator] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	tsb $1010.w		; 0C 10 10 ; Test and set bits $1010.w [Reads: Accumulator] [Flags: Z]
	sta $230120.l		; 8F 20 01 23 ; Store accumulator (long) $230120.l [Reads: Accumulator]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	jsl $4B8400.l		; 22 00 84 4B ; Jump to subroutine long $4B8400.l [Writes: Stack Pointer] [Flow: call]
	ora ($14.b,X)		; 01 14 ; Logical OR ($14.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $C7.b		; 05 C7 ; Logical OR $C7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jmp ($7CED.w)		; 6C ED 7C ; Jump indirect to ($7CED.w) [Flow: jump]
	sbc $F574.w,X		; FD 74 F5 ; Subtract with carry $F574.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $3CFF.w		; 6E FF 3C ; Rotate right $3CFF.w [Flags: ZNC]
	sbc $38FF00.l,X		; FF 00 FF 38 ; Subtract with carry (long,X) $38FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010F00.l		; 22 00 0F 01 ; Jump to subroutine long $010F00.l [Writes: Stack Pointer] [Flow: call]
	jsr ($F942.w,X)		; FC 42 F9 ; Jump to subroutine indirect indexed ($F942.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and [$F3.b],Y		; 37 F3 ; AND accumulator with memory (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $C3DBE7.l		; 6F E7 DB C3 ; Add with carry (long) $C3DBE7.l [Writes: Accumulator] [Flags: ZVNC]
	lda $3E7D99.l,X		; BF 99 7D 3E ; Load long $3E7D99.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $836F.w		; EE 6F 83 ; Increment $836F.w [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	bit $42.b		; 24 42 ; Test bits $42.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta ($10.b,X)		; 81 10 ; Store accumulator ($10.b,X) [Reads: Accumulator, X Index, Direct Page]
	sbc $F7D7EF.l		; EF EF D7 F7 ; Subtract with carry (long) $F7D7EF.l [Writes: Accumulator] [Flags: ZVNC]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($F3.b,S),Y		; F3 F3 ; Subtract with carry (stack relative indirect indexed) ($F3.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$F7.b]		; E7 F7 ; Subtract with carry (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $77.b		; 66 77 ; Rotate right $77.b [Reads: Direct Page] [Flags: ZNC]
	ldx $B7.b		; A6 B7 ; Load $B7.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $8808.w		; 0C 08 88 ; Test and set bits $8808.w [Reads: Accumulator] [Flags: Z]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $D1FF.w,X		; BD FF D1 ; Load $D1FF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $1FFFE7.l,X		; FF E7 FF 1F ; Subtract with carry (long,X) $1FFFE7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $E6EFEF.l,X		; 1F EF EF E6 ; Logical OR long $E6EFEF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $E5ED.w		; EE ED E5 ; Increment $E5ED.w [Flags: ZN]
	sbc $22E7.w		; ED E7 22 ; Subtract $22E7.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$62.b		; E0 62 ; Compare #$62.b with X register [Reads: X Index] [Flags: ZNC]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	lda $002201.l		; AF 01 22 00 ; Load long $002201.l into accumulator [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $10, $0D		; 62 10 0D ; Push effective relative address $62, $10, $0D [Writes: Stack Pointer]
	.db $10, $A3		; 10 A3 ; Branch if plus to $10, $A3 [Flow: branch]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	.db $B0, $AC		; B0 AC ; Branch if carry set to $B0, $AC [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	adc [$7F.b],Y		; 77 7F ; Add with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($F1.b),Y		; F1 F1 ; Subtract with carry ($F1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FD.b,X		; F5 FD ; Subtract $FD.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda ($22.b),Y		; B1 22 ; Load accumulator ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $4432E0.l,X		; FF E0 32 44 ; Subtract with carry (long,X) $4432E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CD.b		; 00 CD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$0D.b]		; C7 0D ; Compare accumulator (long) [$0D.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	ora [$1D.b],Y		; 17 1D ; OR accumulator with memory (long indexed) [$1D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F31FFE.l		; EF FE 1F F3 ; Subtract with carry (long) $F31FFE.l [Writes: Accumulator] [Flags: ZVNC]
	sbc ($CD.b,S),Y		; F3 CD ; Subtract with carry (stack relative indirect indexed) ($CD.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $DE9E.w		; ED 9E DE ; Subtract $DE9E.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	stz $30DF.w,X		; 9E DF 30 ; Store zero to $30DF.w,X [Reads: X Index]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $FCFC.w		; 20 FC FC ; Jump to subroutine at $FCFC.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	trb $10.b		; 14 10 ; Test and reset bits $10.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sbc [$07.b]		; E7 07 ; Subtract with carry (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $11FF22.l		; EF 22 FF 11 ; Subtract with carry (long) $11FF22.l [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc [$44.b],Y		; F7 44 ; Subtract with carry (long indexed) [$44.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($83.b,S),Y		; 33 83 ; AND accumulator (stack relative indirect indexed) ($83.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($FF04.w,X)		; 7C 04 FF ; Jump indirect indexed to ($FF04.w,X) [Reads: X Index] [Flow: jump]
	stx $FDFF.w		; 8E FF FD ; Store X register to $FDFF.w [Reads: X Index]
	sbc $FFFFC3.l,X		; FF C3 FF FF ; Subtract with carry (long,X) $FFFFC3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $271FFF.l,X		; 7F FF 1F 27 ; Add long $271FFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C1C110.l,X		; FF 10 C1 C1 ; Subtract with carry (long,X) $C1C110.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$DF.b],Y		; D7 DF ; Compare accumulator (long indexed) [$DF.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	eor [$DF.b],Y		; 57 DF ; Exclusive OR accumulator with memory (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor ($DF.b),Y		; 51 DF ; Exclusive OR accumulator with memory ($DF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $41DF.w,X		; 5E DF 41 ; Logical shift right $41DF.w,X [Reads: X Index] [Flags: ZNC]
	cmp ($BC.b,X)		; C1 BC ; Compare accumulator ($BC.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	ldy $7F43.w,X		; BC 43 7F ; Load Y register $7F43.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	rol $2023.w,X		; 3E 23 20 ; Rotate left $2023.w,X [Reads: X Index] [Flags: ZNC]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $F5FD.w,Y		; F9 FD F5 ; Subtract with carry $F5FD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $EA43.w,X		; FD 43 EA ; Subtract with carry $EA43.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsl $D9D9E3.l		; 22 E3 D9 D9 ; Jump to subroutine long $D9D9E3.l [Writes: Stack Pointer] [Flow: call]
	bit $023C.w,X		; 3C 3C 02 ; Test bits $023C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	trb $C326.w		; 1C 26 C3 ; Test and reset bits $C326.w [Reads: Accumulator] [Flags: Z]
	nop		; EA ; No operation
	cpx $2D.b		; E4 2D ; Compare $2D.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc ($13.b),Y		; F1 13 ; Subtract with carry ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $43.b,S		; E3 43 ; Subtract stack-relative $43.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp [$E7.b],Y		; D7 E7 ; Compare accumulator (long indexed) [$E7.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: ZNC]
	lda #$CF.b		; A9 CF ; Load #$CF.b into accumulator [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sta $11BE3E.l,X		; 9F 3E BE 11 ; Store accumulator (long,X) $11BE3E.l,X [Reads: Accumulator, X Index]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	eor ($3F.b,X)		; 41 3F ; Exclusive OR accumulator with memory ($3F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $FDCFD3.l		; 0F D3 CF FD ; OR accumulator with memory (long) $FDCFD3.l [Writes: Accumulator] [Flags: ZN]
	cmp $A3.b,S		; C3 A3 ; Compare accumulator (stack relative) $A3.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	cmp ($AA.b,X)		; C1 AA ; Compare accumulator ($AA.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	cmp #$42.b		; C9 42 ; Compare #$42.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	sta $3C8D.w,Y		; 99 8D 3C ; Store accumulator to $3C8D.w,Y [Reads: Accumulator, Y Index]
	jsr ($C07D.w,X)		; FC 7D C0 ; Jump to subroutine indirect indexed ($C07D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $1C00.w		; 20 00 1C ; Jump to subroutine at $1C00.w [Writes: Stack Pointer] [Flow: call]
	trb $24.b		; 14 24 ; Test and reset bits $24.b [Reads: Accumulator] [Flags: Z]
	.db $42, $02		; 42 02 ; Reserved instruction
	sta $A0.b		; 85 A0 ; Store accumulator to $A0.b [Reads: Accumulator]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$E7.b],Y		; D7 E7 ; Compare accumulator (long indexed) [$E7.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	.db $F0, $25		; F0 25 ; Branch if equal to $F0, $25 [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $60E080.l,X		; 7F 80 E0 60 ; Add long $60E080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $489B40.l		; CF 40 9B 48 ; Compare accumulator (long) $489B40.l [Reads: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $0002.w		; 9C 02 00 ; Store zero to $0002.w
	ora $672430.l,X		; 1F 30 24 67 ; Logical OR long $672430.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $E5.b		; 26 E5 ; Rotate left $E5.b [Reads: Direct Page] [Flags: ZNC]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $3C02.w,X		; FD 02 3C ; Subtract with carry $3C02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $81.b,S		; 43 81 ; Exclusive OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $FF06.w,X		; 7E 06 FF ; Rotate right $FF06.w,X [Reads: X Index] [Flags: ZNC]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $42, $42		; 42 42 ; Reserved instruction
	ror $0022.w,X		; 7E 22 00 ; Rotate right $0022.w,X [Reads: X Index] [Flags: ZNC]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $608000.l,X		; 7F 00 80 60 ; Add long $608000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	lda $C00A3F.l,X		; BF 3F 0A C0 ; Load long $C00A3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FF7F80.l,X		; 7F 80 7F FF ; Add long $FF7F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $40407F.l,X		; 7F 7F 40 40 ; Add long $40407F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $B50300.l		; 22 00 03 B5 ; Jump to subroutine long $B50300.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $E7		; 42 E7 ; Reserved instruction
	bit $4A.b		; 24 4A ; Test bits $4A.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lda $66.b		; A5 66 ; Load $66.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: ZNC]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	stz $807F.w		; 9C 7F 80 ; Store zero to $807F.w
	adc $FF3FC0.l,X		; 7F C0 3F FF ; Add long $FF3FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda ($83.b,S),Y		; B3 83 ; Load accumulator (stack relative indirect indexed) ($83.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $03.b,S		; 63 03 ; Add with carry (stack relative) $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $002780.l,X		; 7F 80 27 00 ; Add long $002780.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $FC03.w,X		; FE 03 FC ; Increment memory $FC03.w,X [Reads: X Index] [Flags: ZN]
	sbc $FE9F00.l,X		; FF 00 9F FE ; Subtract with carry (long,X) $FE9F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $E4DFA0.l,X		; BF A0 DF E4 ; Load long $E4DFA0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0EA2.w		; 0C A2 0E ; Test and set bits $0EA2.w [Reads: Accumulator] [Flags: Z]
	eor $B2.b,S		; 43 B2 ; Exclusive OR accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $07.b,X		; 56 07 ; Logical shift right $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldy $46.b,X		; B4 46 ; Load Y register $46.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $B0, $5A		; B0 5A ; Branch if carry set to $B0, $5A [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($51.b,S),Y		; 13 51 ; OR accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $450049.l		; 22 49 00 45 ; Jump to subroutine long $450049.l [Writes: Stack Pointer] [Flow: call]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $30F03F.l,X		; 1F 3F F0 30 ; Logical OR long $30F03F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $E42C.w		; EC 2C E4 ; Compare $E42C.w with X register [Reads: X Index] [Flags: ZNC]
	bit $F0.b		; 24 F0 ; Test bits $F0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	adc $5E4F40.l,X		; 7F 40 4F 5E ; Add long $5E4F40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($5B.b,S),Y		; 53 5B ; XOR accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $050602.l		; 4F 02 06 05 ; Exclusive OR accumulator with memory (long) $050602.l [Writes: Accumulator] [Flags: ZN]
	tsb $1007.w		; 0C 07 10 ; Test and set bits $1007.w [Reads: Accumulator] [Flags: Z]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3C42.w,Y		; 19 42 3C ; OR accumulator with memory $3C42.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FB00.w,X		; FD 00 FB ; Subtract with carry $FB00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $2D.b		; 04 2D ; Test and set bits $2D.b [Reads: Accumulator] [Flags: Z]
	lda $12BF00.l,X		; BF 00 BF 12 ; Load long $12BF00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: ZNC]
	tsb $0CFF.w		; 0C FF 0C ; Test and set bits $0CFF.w [Reads: Accumulator] [Flags: Z]
	lda $52ED12.l,X		; BF 12 ED 52 ; Load long $52ED12.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $5E4C6D.l,X		; 7F 6D 4C 5E ; Add long $5E4C6D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FC.b)		; 12 FC ; OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $FDE0.w,X		; FD E0 FD ; Subtract with carry $FDE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp $51FD.w		; 4C FD 51 ; Jump to $51FD.w [Flow: jump]
	inc $FE61.w,X		; FE 61 FE ; Increment memory $FE61.w,X [Reads: X Index] [Flags: ZN]
	eor ($F2.b,X)		; 41 F2 ; Exclusive OR accumulator with memory ($F2.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $DC.b,S		; 23 DC ; AND accumulator with stack relative $DC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($AF.b)		; B2 AF ; Load accumulator (indirect) ($AF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $23FFBF.l,X		; 9F BF FF 23 ; Store accumulator (long,X) $23FFBF.l,X [Reads: Accumulator, X Index]
	sty $0210.w		; 8C 10 02 ; Store Y register to $0210.w [Reads: Y Index]
	jsl $2087FF.l		; 22 FF 87 20 ; Jump to subroutine long $2087FF.l [Writes: Stack Pointer] [Flow: call]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc #$62.b		; E9 62 ; Subtract #$62.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	sbc #$E0.b		; E9 E0 ; Subtract #$E0.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	eor $E4.b,S		; 43 E4 ; Exclusive OR accumulator with stack relative $E4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $E9.b		; E6 E9 ; Increment $E9.b [Reads: Direct Page] [Flags: ZN]
	sbc $D9D1.w		; ED D1 D9 ; Subtract $D9D1.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	lda $B5.b		; A5 B5 ; Load $B5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $65.b		; 45 65 ; Exclusive OR $65.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $D5.b,X		; 15 D5 ; OR accumulator with memory $D5.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $14.b,X		; 16 14 ; Arithmetic shift left $14.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $2612.w,Y		; 19 12 26 ; OR accumulator with memory $2612.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $A5.b		; 25 A5 ; Logical AND $A5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$C7.b]		; 47 C7 ; Exclusive OR accumulator with memory (long) [$C7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$67.b]		; 27 67 ; AND accumulator with memory (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $B5.b,X		; 95 B5 ; Store accumulator to $B5.b,X [Reads: Accumulator, X Index]
	bit #$B9.b		; 89 B9 ; Test bits #$B9.b with accumulator [Reads: Accumulator] [Flags: Z]
	cmp $DD.b		; C5 DD ; Compare $DD.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	nop		; EA ; No operation
	inc $DFD8.w		; EE D8 DF ; Increment $DFD8.w [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	lsr $22.b		; 46 22 ; Logical shift right $22.b [Reads: Direct Page] [Flags: ZNC]
	ora ($20.b),Y		; 11 20 ; OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F4D4EF.l		; EF EF D4 F4 ; Subtract with carry (long) $F4D4EF.l [Writes: Accumulator] [Flags: ZVNC]
	pei ($F7.b)		; D4 F7 ; Push effective indirect address ($F7.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $FCFCFF.l		; EF FF FC FC ; Subtract with carry (long) $FCFCFF.l [Writes: Accumulator] [Flags: ZVNC]
	sbc ($F3.b,S),Y		; F3 F3 ; Subtract with carry (stack relative indirect indexed) ($F3.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $BFAD7F.l		; 6F 7F AD BF ; Add with carry (long) $BFAD7F.l [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $0B		; 10 0B ; Branch if plus to $10, $0B [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $4080.w		; 0C 80 40 ; Test and set bits $4080.w [Reads: Accumulator] [Flags: Z]
	sty $C8.b		; 84 C8 ; Store Y register to $C8.b [Reads: Y Index]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $1F1F07.l,X		; FF 07 1F 1F ; Subtract with carry (long,X) $1F1F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $BDEE.w		; EE EE BD ; Increment $BDEE.w [Flags: ZN]
	sbc $FFF5.w,X		; FD F5 FF ; Subtract with carry $FFF5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $E0.b		; 14 E0 ; Test and reset bits $E0.b [Reads: Accumulator] [Flags: Z]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $9B.b		; 00 9B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $0F990F.l,X		; 9F 0F 99 0F ; Store accumulator (long,X) $0F990F.l,X [Reads: Accumulator, X Index]
	sta $40C010.l		; 8F 10 C0 40 ; Store accumulator (long) $40C010.l [Reads: Accumulator]
	sbc $70BF60.l,X		; FF 60 BF 70 ; Subtract with carry (long,X) $70BF60.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $676C.w		; 9C 6C 67 ; Store zero to $676C.w
	jsl $3F0360.l		; 22 60 03 3F ; Jump to subroutine long $3F0360.l [Writes: Stack Pointer] [Flow: call]
	ora $8C0300.l,X		; 1F 00 03 8C ; Logical OR long $8C0300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $677F.w		; 9C 7F 67 ; Store zero to $677F.w
	jsl $3F0460.l		; 22 60 04 3F ; Jump to subroutine long $3F0460.l [Writes: Stack Pointer] [Flow: call]
	ora $9F0000.l,X		; 1F 00 00 9F ; Logical OR long $9F0000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora ($33.b,X)		; 01 33 ; Logical OR ($33.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($43.b,S),Y		; 33 43 ; AND accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $01FF.w,X		; FE FF 01 ; Increment memory $01FF.w,X [Reads: X Index] [Flags: ZN]
	dec $23FF.w		; CE FF 23 ; Decrement $23FF.w [Flags: ZN]
	inc $CC00.w,X		; FE 00 CC ; Increment memory $CC00.w,X [Reads: X Index] [Flags: ZN]
	jsl $B10500.l		; 22 00 05 B1 ; Jump to subroutine long $B10500.l [Writes: Stack Pointer] [Flow: call]
	.db $50, $D9		; 50 D9 ; Branch if overflow clear to $50, $D9 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor $93.b,S		; 43 93 ; Exclusive OR accumulator with stack relative $93.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $70, $13		; 70 13 ; Branch if overflow set to $70, $13 [Flow: branch]
	sta $9E78.w,Y		; 99 78 9E ; Store accumulator to $9E78.w,Y [Reads: Accumulator, Y Index]
	ror $7881.w,X		; 7E 81 78 ; Rotate right $7881.w,X [Reads: X Index] [Flags: ZNC]
	ora $0F0707.l		; 0F 07 07 0F ; OR accumulator with memory (long) $0F0707.l [Writes: Accumulator] [Flags: ZN]
	ora $070107.l		; 0F 07 01 07 ; OR accumulator with memory (long) $070107.l [Writes: Accumulator] [Flags: ZN]
	sbc $FF0000.l,X		; FF 00 00 FF ; Subtract with carry (long,X) $FF0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $23FF.w,X		; FE FF 23 ; Increment memory $23FF.w,X [Reads: X Index] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc ($44.b,S),Y		; F3 44 ; Subtract with carry (stack relative indirect indexed) ($44.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $FE2400.l		; 22 00 24 FE ; Jump to subroutine long $FE2400.l [Writes: Stack Pointer] [Flow: call]
	cpx #$54.b		; E0 54 ; Compare #$54.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sta [$79.b]		; 87 79 ; Store accumulator (long) [$79.b] [Reads: Accumulator, Direct Page]
	asl $1EF3.w		; 0E F3 1E ; Arithmetic shift left $1EF3.w [Flags: ZNC]
	sbc $3F.b,S		; E3 3F ; Subtract stack-relative $3F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp #$77.b		; C9 77 ; Compare #$77.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	stz $E0F0.w		; 9C F0 E0 ; Store zero to $E0F0.w
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$57.b		; A0 57 ; Load #$57.b into Y register [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $5F.b		; A5 5F ; Load $5F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $6F.b,X		; B5 6F ; Load $6F.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc [$BF.b],Y		; 77 BF ; Add with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	sbc $454800.l,X		; FF 00 48 45 ; Subtract with carry (long,X) $454800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	adc $20E000.l,X		; 7F 00 E0 20 ; Add long $20E000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: ZN]
	inc $36.b,X		; F6 36 ; Increment memory $36.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $7FBF00.l,X		; FF 00 BF 7F ; Subtract with carry (long,X) $7FBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	nop		; EA ; No operation
	eor $95.b,X		; 55 95 ; Exclusive OR accumulator with memory $95.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $5F40E0.l,X		; 3F E0 40 5F ; AND accumulator with memory (long,X) $5F40E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7F49.w,Y		; 59 49 7F ; Exclusive OR accumulator with memory $7F49.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $8C18E3.l,X		; 3F E3 18 8C ; AND accumulator with memory (long,X) $8C18E3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($18.b,S),Y		; 73 18 ; Add with carry (stack relative indirect indexed) ($18.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$28.b]		; E7 28 ; Subtract with carry (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$47.b],Y		; D7 47 ; Compare accumulator (long indexed) [$47.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sta $7E7F.w,X		; 9D 7F 7E ; Store accumulator to $7E7F.w,X [Reads: Accumulator, X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $E11E04.l,X		; FF 04 1E E1 ; Subtract with carry (long,X) $E11E04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $BF44.w		; 2D 44 BF ; Logical AND $BF44.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $B73719.l,X		; 3F 19 37 B7 ; AND accumulator with memory (long,X) $B73719.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($B3.b,S),Y		; 33 B3 ; AND accumulator (stack relative indirect indexed) ($B3.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $7F1EBF.l,X		; 3F BF 1E 7F ; AND accumulator with memory (long,X) $7F1EBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor ($40.b)		; 52 40 ; Exclusive OR accumulator with memory (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jmp $2740.w		; 4C 40 27 ; Jump to $2740.w [Flow: jump]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp ($FE.b,X)		; C1 FE ; Compare accumulator ($FE.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc #$D6.b		; E9 D6 ; Subtract #$D6.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	lda $39BE.w,Y		; B9 BE 39 ; Load $39BE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $F943.w,X		; 3E 43 F9 ; Rotate left $F943.w,X [Reads: X Index] [Flags: ZNC]
	inc $2707.w,X		; FE 07 27 ; Increment memory $2707.w,X [Reads: X Index] [Flags: ZN]
	sbc $453F3F.l,X		; FF 3F 3F 45 ; Subtract with carry (long,X) $453F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $03.b		; C5 03 ; Compare $03.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	ora ($97.b,X)		; 01 97 ; Logical OR ($97.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $D5.b,X		; 15 D5 ; OR accumulator with memory $D5.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$67.b]		; 27 67 ; AND accumulator with memory (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$37.b],Y		; 17 37 ; OR accumulator with memory (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp $CD.b		; C5 CD ; Compare $CD.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
.ACCU 8
	sep #$E7		; E2 E7
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $62, $EB, $11		; 62 EB 11 ; Push effective relative address $62, $EB, $11 [Writes: Stack Pointer]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	and $32.b		; 25 32 ; Logical AND $32.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	.db $D0, $D8		; D0 D8 ; Branch if not equal to $D0, $D8 [Flow: branch]
	ldy #$B0.b		; A0 B0 ; Load #$B0.b into Y register [Writes: Y Index] [Flags: ZN]
	eor $65.b		; 45 65 ; Exclusive OR $65.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $C5.b		; 85 C5 ; Store accumulator to $C5.b [Reads: Accumulator]
	and $A5.b		; 25 A5 ; Logical AND $A5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $65.b,S		; 23 65 ; AND accumulator with stack relative $65.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$25.b		; 09 25 ; Logical OR #$25.b with accumulator [Writes: Accumulator] [Flags: ZN]
	lda $27.b		; A5 27 ; Load $27.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $5A3A9A.l		; 4F 9A 3A 5A ; Exclusive OR accumulator with memory (long) $5A3A9A.l [Writes: Accumulator] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	eor $D7.b,S		; 43 D7 ; Exclusive OR accumulator with stack relative $D7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FFB703.l,X		; FF 03 B7 FF ; Subtract with carry (long,X) $FFB703.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $021884.l,X		; FF 84 18 02 ; Subtract with carry (long,X) $021884.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $0023FF.l		; 22 FF 23 00 ; Jump to subroutine long $0023FF.l [Writes: Stack Pointer] [Flow: call]
	sta $24.b,S		; 83 24 ; Store accumulator (stack relative) $24.b,S [Reads: Accumulator, Stack Pointer]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF.b,X		; F5 FF ; Subtract $FF.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $ED.b,S		; 03 ED ; OR accumulator with stack relative $ED.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $87FF1E.l,X		; FF 1E FF 87 ; Subtract with carry (long,X) $87FF1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($21.b)		; 12 21 ; OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $0FFF.w		; 20 FF 0F ; Jump to subroutine at $0FFF.w [Writes: Stack Pointer] [Flow: call]
	ora ($FE.b,S),Y		; 13 FE ; OR accumulator (stack relative indirect indexed) ($FE.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $FD.b		; 06 FD ; Arithmetic shift left $FD.b [Reads: Direct Page] [Flags: ZNC]
	bit $18FB.w		; 2C FB 18 ; Test bits $18FB.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sbc [$38.b],Y		; F7 38 ; Subtract with carry (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$6C.b]		; E7 6C ; Subtract with carry (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $BD.b		; C6 BD ; Decrement $BD.b [Reads: Direct Page] [Flags: ZN]
	sta $7E.b,S		; 83 7E ; Store accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$00.b]		; C7 00 ; Compare accumulator (long) [$00.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	lda [$00.b],Y		; B7 00 ; Load accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$42.b		; E0 42 ; Compare #$42.b with X register [Reads: X Index] [Flags: ZNC]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $F9.b,S		; 23 F9 ; AND accumulator with stack relative $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$F3.b]		; 07 F3 ; OR accumulator with memory (long) [$F3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $CF17E7.l		; 8F E7 17 CF ; Store accumulator (long) $CF17E7.l [Reads: Accumulator]
	and [$9F.b]		; 27 9F ; AND accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	sbc $FBFC.w,X		; FD FC FB ; Subtract with carry $FBFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $D3D7.w,Y		; F9 D7 D3 ; Subtract with carry $D3D7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$6F.b],Y		; 77 6F ; Add with carry (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$D8.b		; E0 D8 ; Compare #$D8.b with X register [Reads: X Index] [Flags: ZNC]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy $2EED.w,X		; BC ED 2E ; Load Y register $2EED.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $027D.w,X		; FE 7D 02 ; Increment memory $027D.w,X [Reads: X Index] [Flags: ZN]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	.db $90, $27		; 90 27 ; Branch if carry clear to $90, $27 [Flow: branch]
	eor $91.b,S		; 43 91 ; Exclusive OR accumulator with stack relative $91.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $C1.b		; 02 C1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($B963.w,X)		; 7C 63 B9 ; Jump indirect indexed to ($B963.w,X) [Reads: X Index] [Flow: jump]
	and [$D3.b],Y		; 37 D3 ; AND accumulator with memory (long indexed) [$D3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc [$C9.b]		; 67 C9 ; Add with carry (long) [$C9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and [$C4.b],Y		; 37 C4 ; AND accumulator with memory (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $FF01.w,X		; FE 01 FF ; Increment memory $FF01.w,X [Reads: X Index] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$F5.b],Y		; 17 F5 ; OR accumulator with memory (long indexed) [$F5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($CB.b,S),Y		; F3 CB ; Subtract with carry (stack relative indirect indexed) ($CB.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$14.b]		; C7 14 ; Compare accumulator (long) [$14.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tsb $1824.w		; 0C 24 18 ; Test and set bits $1824.w [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $67E6.w,X		; 3C E6 67 ; Test bits $67E6.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $F338.w		; 0C 38 F3 ; Test and set bits $F338.w [Reads: Accumulator] [Flags: Z]
	sbc [$C3.b]		; E7 C3 ; Subtract with carry (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $FE3E.w,Y		; 99 3E FE ; Store accumulator to $FE3E.w,Y [Reads: Accumulator, Y Index]
	eor $2800FF.l		; 4F FF 00 28 ; Exclusive OR accumulator with memory (long) $2800FF.l [Writes: Accumulator] [Flags: ZN]
	sbc $003AE0.l,X		; FF E0 3A 00 ; Subtract with carry (long,X) $003AE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $708F30.l		; CF 30 8F 70 ; Compare accumulator (long) $708F30.l [Reads: Accumulator] [Flags: ZNC]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Accumulator, Direct Page]
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc ($0E.b),Y		; F1 0E ; Subtract with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $FF46.w,Y		; B9 46 FF ; Load $FF46.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$77.b],Y		; B7 77 ; Load accumulator (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $560E.w,X		; 9D 0E 56 ; Store accumulator to $560E.w,X [Reads: Accumulator, X Index]
	ora $1CEF.w,Y		; 19 EF 1C ; OR accumulator with memory $1CEF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	rol $AC.b,X		; 36 AC ; Rotate left $AC.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc ($CD.b)		; 72 CD ; Add with carry (indirect) ($CD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	sbc $4B.b		; E5 4B ; Subtract $4B.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ldy $EB.b,X		; B4 EB ; Load Y register $EB.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	trb $EF.b		; 14 EF ; Test and reset bits $EF.b [Reads: Accumulator] [Flags: Z]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	lda [$7B.b],Y		; B7 7B ; Load accumulator (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $B4E5.w		; CD E5 B4 ; Compare $B4E5.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	ora [$DB.b],Y		; 17 DB ; OR accumulator with memory (long indexed) [$DB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F60A.w,X		; FD 0A F6 ; Subtract with carry $F60A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and #$DF.b		; 29 DF ; Logical AND #$DF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jsr $01FE.w		; 20 FE 01 ; Jump to subroutine at $01FE.w [Writes: Stack Pointer] [Flow: call]
	sbc $F702.w,X		; FD 02 F7 ; Subtract with carry $F702.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$66.b		; E0 66 ; Compare #$66.b with X register [Reads: X Index] [Flags: ZNC]
	lda #$A6.b		; A9 A6 ; Load #$A6.b into accumulator [Writes: Accumulator] [Flags: ZN]
	sta $F3E9FE.l,X		; 9F FE E9 F3 ; Store accumulator (long,X) $F3E9FE.l,X [Reads: Accumulator, X Index]
	sbc $F6B9B9.l,X		; FF B9 B9 F6 ; Subtract with carry (long,X) $F6B9B9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$C4.b],Y		; F7 C4 ; Subtract with carry (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $E9.b		; C6 E9 ; Decrement $E9.b [Reads: Direct Page] [Flags: ZN]
	sbc $DBD3.w		; ED D3 DB ; Subtract $DBD3.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	lda [$B7.b]		; A7 B7 ; Load accumulator (long) [$B7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $DF9F6F.l		; 4F 6F 9F DF ; Exclusive OR accumulator with memory (long) $DF9F6F.l [Writes: Accumulator] [Flags: ZN]
	lsr $08.b		; 46 08 ; Logical shift right $08.b [Reads: Direct Page] [Flags: ZNC]
	and $2412.w,Y		; 39 12 24 ; AND accumulator with memory $2412.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $90, $20		; 90 20 ; Branch if carry clear to $90, $20 [Flow: branch]
	adc $DF5FFF.l,X		; 7F FF 5F DF ; Add long $DF5FFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta ($B3.b,S),Y		; 93 B3 ; Store accumulator (stack relative indirect indexed) ($B3.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	lda #$B9.b		; A9 B9 ; Load #$B9.b into accumulator [Writes: Accumulator] [Flags: ZN]
	cmp $DD.b,X		; D5 DD ; Compare accumulator $DD.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	nop		; EA ; No operation
	inc $DFD9.w		; EE D9 DF ; Increment $DFD9.w [Flags: ZN]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $4C.b,X		; 94 4C ; Store Y register $4C.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	lsr $22.b		; 46 22 ; Logical shift right $22.b [Reads: Direct Page] [Flags: ZNC]
	ora ($20.b),Y		; 11 20 ; OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $F030.w		; EE 30 F0 ; Increment $F030.w [Flags: ZN]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	lda $402380.l,X		; BF 80 23 40 ; Load long $402380.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor ($8E.b,X)		; 41 8E ; Exclusive OR accumulator with memory ($8E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $3E9E1E.l		; CF 1E 9E 3E ; Compare accumulator (long) $3E9E1E.l [Reads: Accumulator] [Flags: ZNC]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $2030.w		; 9C 30 20 ; Store zero to $2030.w
	eor ($40.b,X)		; 41 40 ; Exclusive OR accumulator with memory ($40.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $8340.w,X		; 1D 40 83 ; OR accumulator with memory $8340.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $3B.b		; C5 3B ; Compare $3B.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora [$8B.b]		; 07 8B ; OR accumulator with memory (long) [$8B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($80.b,S),Y		; 13 80 ; OR accumulator (stack relative indirect indexed) ($80.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $80.b		; 04 80 ; Test and set bits $80.b [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	ldy #$31.b		; A0 31 ; Load #$31.b into Y register [Writes: Y Index] [Flags: ZN]
	ldx #$3C.b		; A2 3C ; Load #$3C.b into X register [Writes: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $7B.b		; 64 7B ; Store zero to $7B.b
	mvn $F0,$4E		; 54 4E F0 ; Move block negative $F0,$4E [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $100120.l		; 2F 20 01 10 ; AND accumulator with memory (long) $100120.l [Writes: Accumulator] [Flags: ZN]
	ror $C381.w,X		; 7E 81 C3 ; Rotate right $C381.w,X [Reads: X Index] [Flags: ZNC]
	ror $7EA5.w,X		; 7E A5 7E ; Rotate right $7EA5.w,X [Reads: X Index] [Flags: ZNC]
	lda $7E.b,S		; A3 7E ; Load accumulator (stack relative) $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit #$7E.b		; 89 7E ; Test bits #$7E.b with accumulator [Reads: Accumulator] [Flags: Z]
	lda ($7E.b,X)		; A1 7E ; Load accumulator ($7E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: ZNC]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $42, $F9		; 42 F9 ; Reserved instruction
	and [$F3.b],Y		; 37 F3 ; AND accumulator with memory (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $C3DBE7.l		; 6F E7 DB C3 ; Add with carry (long) $C3DBE7.l [Writes: Accumulator] [Flags: ZVNC]
	lda $3E7D99.l,X		; BF 99 7D 3E ; Load long $3E7D99.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $836F.w		; EE 6F 83 ; Increment $836F.w [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $42.b		; 24 42 ; Test bits $42.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta ($10.b,X)		; 81 10 ; Store accumulator ($10.b,X) [Reads: Accumulator, X Index, Direct Page]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($00.b),Y		; 71 00 ; Add with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $80E080.l,X		; 9F 80 E0 80 ; Store accumulator (long,X) $80E080.l,X [Reads: Accumulator, X Index]
	dec $9E0E.w		; CE 0E 9E ; Decrement $9E0E.w [Flags: ZN]
	asl $3E22.w,X		; 1E 22 3E ; Arithmetic shift left $3E22.w,X [Reads: X Index] [Flags: ZNC]
	cpx #$21.b		; E0 21 ; Compare #$21.b with X register [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stx $1F60.w		; 8E 60 1F ; Store X register to $1F60.w [Reads: X Index]
	and ($61.b),Y		; 31 61 ; AND accumulator with memory ($61.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc [$FC.b],Y		; F7 FC ; Subtract with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($FD1C.w,X)		; FC 1C FD ; Jump to subroutine indirect indexed ($FD1C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $DF.b,S		; 03 DF ; OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpy #$EF.b		; C0 EF ; Compare #$EF.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc ($F0.b,X)		; E1 F0 ; Subtract with carry ($F0.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($FC.b),Y		; F1 FC ; Subtract with carry ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $0378.w,Y		; 79 78 03 ; Add $0378.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $EC.b		; 02 EC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0E10.w		; 20 10 0E ; Jump to subroutine at $0E10.w [Writes: Stack Pointer] [Flow: call]
	cop $86.b		; 02 86 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	jsl $21F03E.l		; 22 3E F0 21 ; Jump to subroutine long $21F03E.l [Writes: Stack Pointer] [Flow: call]
	ldx $E001.w,Y		; BE 01 E0 ; Load X register $E001.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	eor ($00.b,S),Y		; 53 00 ; XOR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $03.b,S		; E3 03 ; Subtract stack-relative $03.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc ($C3.b,S),Y		; F3 C3 ; Subtract with carry (stack relative indirect indexed) ($C3.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $1B.b,S		; 23 1B ; AND accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $8C		; 10 8C ; Branch if plus to $10, $8C [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cmp [$C8.b]		; C7 C8 ; Compare accumulator (long) [$C8.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$1C.b		; E0 1C ; Compare #$1C.b with X register [Reads: X Index] [Flags: ZNC]
	tsb $C404.w		; 0C 04 C4 ; Test and set bits $C404.w [Reads: Accumulator] [Flags: Z]
	adc $30.b,S		; 63 30 ; Add with carry (stack relative) $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($C6.b,X)		; 01 C6 ; Logical OR ($C6.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp $CC.b,S		; C3 CC ; Compare accumulator (stack relative) $CC.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and ($11.b),Y		; 31 11 ; AND accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $C4.b		; C5 C4 ; Compare $C4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	bit $EC.b		; 24 EC ; Test bits $EC.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $E3		; 30 E3 ; Branch if minus to $30, $E3 [Flow: branch]
	dec $0E.b		; C6 0E ; Decrement $0E.b [Reads: Direct Page] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cmp $76F93C.l,X		; DF 3C F9 76 ; Compare accumulator (long,X) $76F93C.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $CD32.w,X		; FD 32 CD ; Subtract with carry $CD32.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($A1.b)		; 32 A1 ; AND accumulator with memory (indirect) ($A1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $58A7.w,X		; 5E A7 58 ; Logical shift right $58A7.w,X [Reads: X Index] [Flags: ZNC]
	sta $50AF70.l		; 8F 70 AF 50 ; Store accumulator (long) $50AF70.l [Reads: Accumulator]
	lda $3276.w,X		; BD 76 32 ; Load $3276.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($5E.b)		; 32 5E ; AND accumulator with memory (indirect) ($5E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $5773.w,Y		; 59 73 57 ; Exclusive OR accumulator with memory $5773.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $42BD00.l,X		; FF 00 BD 42 ; Subtract with carry (long,X) $42BD00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpx $CF.b		; E4 CF ; Compare $CF.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $30, $E7		; 30 E7 ; Branch if minus to $30, $E7 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $E2.b		; 84 E2 ; Store Y register to $E2.b [Reads: Y Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	inc $3BFD.w,X		; FE FD 3B ; Increment memory $3BFD.w,X [Reads: X Index] [Flags: ZN]
	sta $E7EBCF.l,X		; 9F CF EB E7 ; Store accumulator (long,X) $E7EBCF.l,X [Reads: Accumulator, X Index]
	ora [$C7.b]		; 07 C7 ; OR accumulator with memory (long) [$C7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$67.b]		; 27 67 ; AND accumulator with memory (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta [$B7.b],Y		; 97 B7 ; Store accumulator (long indexed) [$B7.b],Y [Reads: Accumulator, Direct Page, Y Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp $CD.b		; C5 CD ; Compare $CD.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc ($F7.b)		; F2 F7 ; Subtract with carry (indirect) ($F7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	jsr ($38FD.w,X)		; FC FD 38 ; Jump to subroutine indirect indexed ($38FD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and [$32.b]		; 27 32 ; AND accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	mvp $90,$02		; 44 02 90 ; Move block positive $90,$02 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sta $B2A2.w,Y		; 99 A2 B2 ; Store accumulator to $B2A2.w,Y [Reads: Accumulator, Y Index]
	eor $CF8F6F.l		; 4F 6F 8F CF ; Exclusive OR accumulator with memory (long) $CF8F6F.l [Writes: Accumulator] [Flags: ZN]
	ora $79238F.l		; 0F 8F 23 79 ; OR accumulator with memory (long) $79238F.l [Writes: Accumulator] [Flags: ZN]
	cpx #$39.b		; E0 39 ; Compare #$39.b with X register [Reads: X Index] [Flags: ZNC]
	and $4D66BF.l,X		; 3F BF 66 4D ; AND accumulator with memory (long,X) $4D66BF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $90, $30		; 90 30 ; Branch if carry clear to $90, $30 [Flow: branch]
	.db $70, $86		; 70 86 ; Branch if overflow set to $70, $86 [Flow: branch]
	stx $40.b		; 86 40 ; Store X register to $40.b [Reads: X Index]
	ldx $883E.w,Y		; BE 3E 88 ; Load X register $883E.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cpy #$33.b		; C0 33 ; Compare #$33.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $8B131A.l		; 22 1A 13 8B ; Jump to subroutine long $8B131A.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $C8		; 80 C8 ; Branch always to $80, $C8 [Flow: branch]
	cpy #$EF.b		; C0 EF ; Compare #$EF.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc [$E0.b]		; E7 E0 ; Subtract with carry (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor ($37.b,X)		; 41 37 ; Exclusive OR accumulator with memory ($37.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $64C5.w		; 0C C5 64 ; Test and set bits $64C5.w [Reads: Accumulator] [Flags: Z]
	and [$10.b],Y		; 37 10 ; AND accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $D0, $9D		; D0 9D ; Branch if not equal to $D0, $9D [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $50, $16		; 50 16 ; Branch if overflow clear to $50, $16 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sty $4638.w		; 8C 38 46 ; Store Y register to $4638.w [Reads: Y Index]
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $C4.b,S		; 83 C4 ; Store accumulator (stack relative) $C4.b,S [Reads: Accumulator, Stack Pointer]
	and $22.b		; 25 22 ; Logical AND $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy $A9.b		; A4 A9 ; Load $A9.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	ora ($81.b,S),Y		; 13 81 ; OR accumulator (stack relative indirect indexed) ($81.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	trb $F01A.w		; 1C 1A F0 ; Test and reset bits $F01A.w [Reads: Accumulator] [Flags: Z]
	and $0602A0.l		; 2F A0 02 06 ; AND accumulator with memory (long) $0602A0.l [Writes: Accumulator] [Flags: ZN]
	adc $60E080.l,X		; 7F 80 E0 60 ; Add long $60E080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $489B40.l		; CF 40 9B 48 ; Compare accumulator (long) $489B40.l [Reads: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $0002.w		; 9C 02 00 ; Store zero to $0002.w
	ora $672430.l,X		; 1F 30 24 67 ; Logical OR long $672430.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $E5.b		; 26 E5 ; Rotate left $E5.b [Reads: Direct Page] [Flags: ZNC]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $3C02.w,X		; FD 02 3C ; Subtract with carry $3C02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $81.b,S		; 43 81 ; Exclusive OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $FF06.w,X		; 7E 06 FF ; Rotate right $FF06.w,X [Reads: X Index] [Flags: ZNC]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $42, $42		; 42 42 ; Reserved instruction
	ror $0022.w,X		; 7E 22 00 ; Rotate right $0022.w,X [Reads: X Index] [Flags: ZNC]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $608000.l,X		; 7F 00 80 60 ; Add long $608000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	lda $C00A3F.l,X		; BF 3F 0A C0 ; Load long $C00A3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FF7F80.l,X		; 7F 80 7F FF ; Add long $FF7F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $40407F.l,X		; 7F 7F 40 40 ; Add long $40407F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $B50300.l		; 22 00 03 B5 ; Jump to subroutine long $B50300.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $E7		; 42 E7 ; Reserved instruction
	bit $4A.b		; 24 4A ; Test bits $4A.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lda $66.b		; A5 66 ; Load $66.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: ZNC]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	stz $807F.w		; 9C 7F 80 ; Store zero to $807F.w
	adc $FF3FC0.l,X		; 7F C0 3F FF ; Add long $FF3FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda ($83.b,S),Y		; B3 83 ; Load accumulator (stack relative indirect indexed) ($83.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $03.b,S		; 63 03 ; Add with carry (stack relative) $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $002780.l,X		; 7F 80 27 00 ; Add long $002780.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $FC03.w,X		; FE 03 FC ; Increment memory $FC03.w,X [Reads: X Index] [Flags: ZN]
	sbc $FE9F00.l,X		; FF 00 9F FE ; Subtract with carry (long,X) $FE9F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $E4DFA0.l,X		; BF A0 DF E4 ; Load long $E4DFA0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0EA2.w		; 0C A2 0E ; Test and set bits $0EA2.w [Reads: Accumulator] [Flags: Z]
	eor $B2.b,S		; 43 B2 ; Exclusive OR accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $07.b,X		; 56 07 ; Logical shift right $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldy $46.b,X		; B4 46 ; Load Y register $46.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $B0, $5A		; B0 5A ; Branch if carry set to $B0, $5A [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($51.b,S),Y		; 13 51 ; OR accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $450049.l		; 22 49 00 45 ; Jump to subroutine long $450049.l [Writes: Stack Pointer] [Flow: call]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $30F03F.l,X		; 1F 3F F0 30 ; Logical OR long $30F03F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $E42C.w		; EC 2C E4 ; Compare $E42C.w with X register [Reads: X Index] [Flags: ZNC]
	bit $F0.b		; 24 F0 ; Test bits $F0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	adc $5E4F40.l,X		; 7F 40 4F 5E ; Add long $5E4F40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($5B.b,S),Y		; 53 5B ; XOR accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $050602.l		; 4F 02 06 05 ; Exclusive OR accumulator with memory (long) $050602.l [Writes: Accumulator] [Flags: ZN]
	tsb $1007.w		; 0C 07 10 ; Test and set bits $1007.w [Reads: Accumulator] [Flags: Z]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3C42.w,Y		; 19 42 3C ; OR accumulator with memory $3C42.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FB00.w,X		; FD 00 FB ; Subtract with carry $FB00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $3CAF.w		; 20 AF 3C ; Jump to subroutine at $3CAF.w [Writes: Stack Pointer] [Flow: call]
	lda $07FF1E.l,X		; BF 1E FF 07 ; Load long $07FF1E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $24BF22.l,X		; BF 22 BF 24 ; Load long $24BF22.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $078700.l,X		; BF 00 87 07 ; Load long $078700.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $786143.l,X		; 5F 43 61 78 ; Exclusive OR accumulator with memory (long,X) $786143.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7F5B.w,X		; 5D 5B 7F ; Exclusive OR accumulator with memory $7F5B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$C4.b]		; 07 C4 ; OR accumulator with memory (long) [$C4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $FD70.w,X		; DD 70 FD ; Compare accumulator $FD70.w,X [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $0CFF18.l,X		; FF 18 FF 0C ; Subtract with carry (long,X) $0CFF18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFC0.w,X		; FD C0 FF ; Subtract with carry $FFC0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	stx $E606.w		; 8E 06 E6 ; Store X register to $E606.w [Reads: X Index]
	sbc ($3E.b)		; F2 3E ; Subtract with carry (indirect) ($3E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $109707.l,X		; FF 07 97 10 ; Subtract with carry (long,X) $109707.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr ($78FE.w,X)		; FC FE 78 ; Jump to subroutine indirect indexed ($78FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($7931.w,X)		; FC 31 79 ; Jump to subroutine indirect indexed ($7931.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$37.b]		; 07 37 ; OR accumulator with memory (long) [$37.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $C7CF.w		; CD CF C7 ; Compare $C7CF.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	sbc $C0E7C1.l		; EF C1 E7 C0 ; Subtract with carry (long) $C0E7C1.l [Writes: Accumulator] [Flags: ZVNC]
	sbc ($01.b,X)		; E1 01 ; Subtract with carry ($01.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $86.b,S		; 03 86 ; OR accumulator with stack relative $86.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $F6F4.w,X		; 1E F4 F6 ; Arithmetic shift left $F6F4.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($987E.w,X)		; 7C 7E 98 ; Jump indirect indexed to ($987E.w,X) [Reads: X Index] [Flow: jump]
	ldy $D9C1.w,X		; BC C1 D9 ; Load Y register $D9C1.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sbc $E3.b,S		; E3 E3 ; Subtract stack-relative $E3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $B7.b,Y		; B6 B7 ; Load X register $B7.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	sbc [$F7.b]		; E7 F7 ; Subtract with carry (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora #$81.b		; 09 81 ; Logical OR #$81.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $26.b,S		; 43 26 ; Exclusive OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $4808.w		; 1C 08 48 ; Test and reset bits $4808.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($10.b),Y		; 71 10 ; Add with carry ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $C180.w,Y		; 99 80 C1 ; Store accumulator to $C180.w,Y [Reads: Accumulator, Y Index]
	.db $80, $9F		; 80 9F ; Branch always to $80, $9F [Flow: branch]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $B8.b,S		; 83 B8 ; Store accumulator (stack relative) $B8.b,S [Reads: Accumulator, Stack Pointer]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $30, $8E		; 30 8E ; Branch if minus to $30, $8E [Flow: branch]
	ror $3E.b		; 66 3E ; Rotate right $3E.b [Reads: Direct Page] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp $C161B1.l,X		; DF B1 61 C1 ; Compare accumulator (long,X) $C161B1.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	jmp $017D.w		; 4C 7D 01 ; Jump to $017D.w [Flow: jump]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc [$03.b]		; E7 03 ; Subtract with carry (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpy #$EF.b		; C0 EF ; Compare #$EF.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$F1.b		; E0 F1 ; Compare #$F1.b with X register [Reads: X Index] [Flags: ZNC]
	sbc ($82.b,S),Y		; F3 82 ; Subtract with carry (stack relative indirect indexed) ($82.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($EC18.w,X)		; FC 18 EC ; Jump to subroutine indirect indexed ($EC18.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and [$10.b]		; 27 10 ; AND accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $089B.w		; 0E 9B 08 ; Arithmetic shift left $089B.w [Flags: ZNC]
	sta $0F990F.l,X		; 9F 0F 99 0F ; Store accumulator (long,X) $0F990F.l,X [Reads: Accumulator, X Index]
	sta $40C010.l		; 8F 10 C0 40 ; Store accumulator (long) $40C010.l [Reads: Accumulator]
	sbc $70BF60.l,X		; FF 60 BF 70 ; Subtract with carry (long,X) $70BF60.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $676C.w		; 9C 6C 67 ; Store zero to $676C.w
	jsl $3F0360.l		; 22 60 03 3F ; Jump to subroutine long $3F0360.l [Writes: Stack Pointer] [Flow: call]
	ora $8C0300.l,X		; 1F 00 03 8C ; Logical OR long $8C0300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $677F.w		; 9C 7F 67 ; Store zero to $677F.w
	jsl $3F0460.l		; 22 60 04 3F ; Jump to subroutine long $3F0460.l [Writes: Stack Pointer] [Flow: call]
	ora $9F0000.l,X		; 1F 00 00 9F ; Logical OR long $9F0000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora ($33.b,X)		; 01 33 ; Logical OR ($33.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($43.b,S),Y		; 33 43 ; AND accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $01FF.w,X		; FE FF 01 ; Increment memory $01FF.w,X [Reads: X Index] [Flags: ZN]
	dec $23FF.w		; CE FF 23 ; Decrement $23FF.w [Flags: ZN]
	inc $CC00.w,X		; FE 00 CC ; Increment memory $CC00.w,X [Reads: X Index] [Flags: ZN]
	jsl $B10500.l		; 22 00 05 B1 ; Jump to subroutine long $B10500.l [Writes: Stack Pointer] [Flow: call]
	.db $50, $D9		; 50 D9 ; Branch if overflow clear to $50, $D9 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor $93.b,S		; 43 93 ; Exclusive OR accumulator with stack relative $93.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $70, $13		; 70 13 ; Branch if overflow set to $70, $13 [Flow: branch]
	sta $9E78.w,Y		; 99 78 9E ; Store accumulator to $9E78.w,Y [Reads: Accumulator, Y Index]
	ror $7881.w,X		; 7E 81 78 ; Rotate right $7881.w,X [Reads: X Index] [Flags: ZNC]
	ora $0F0707.l		; 0F 07 07 0F ; OR accumulator with memory (long) $0F0707.l [Writes: Accumulator] [Flags: ZN]
	ora $070107.l		; 0F 07 01 07 ; OR accumulator with memory (long) $070107.l [Writes: Accumulator] [Flags: ZN]
	sbc $FF0000.l,X		; FF 00 00 FF ; Subtract with carry (long,X) $FF0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $23FF.w,X		; FE FF 23 ; Increment memory $23FF.w,X [Reads: X Index] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc ($44.b,S),Y		; F3 44 ; Subtract with carry (stack relative indirect indexed) ($44.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $FE2400.l		; 22 00 24 FE ; Jump to subroutine long $FE2400.l [Writes: Stack Pointer] [Flow: call]
	cpx #$54.b		; E0 54 ; Compare #$54.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sta [$79.b]		; 87 79 ; Store accumulator (long) [$79.b] [Reads: Accumulator, Direct Page]
	asl $1EF3.w		; 0E F3 1E ; Arithmetic shift left $1EF3.w [Flags: ZNC]
	sbc $3F.b,S		; E3 3F ; Subtract stack-relative $3F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp #$77.b		; C9 77 ; Compare #$77.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	stz $E0F0.w		; 9C F0 E0 ; Store zero to $E0F0.w
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$57.b		; A0 57 ; Load #$57.b into Y register [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $5F.b		; A5 5F ; Load $5F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $6F.b,X		; B5 6F ; Load $6F.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc [$BF.b],Y		; 77 BF ; Add with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	sbc $454800.l,X		; FF 00 48 45 ; Subtract with carry (long,X) $454800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	adc $20E000.l,X		; 7F 00 E0 20 ; Add long $20E000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: ZN]
	inc $36.b,X		; F6 36 ; Increment memory $36.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $7FBF00.l,X		; FF 00 BF 7F ; Subtract with carry (long,X) $7FBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	nop		; EA ; No operation
	eor $95.b,X		; 55 95 ; Exclusive OR accumulator with memory $95.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $5F40E0.l,X		; 3F E0 40 5F ; AND accumulator with memory (long,X) $5F40E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7F49.w,Y		; 59 49 7F ; Exclusive OR accumulator with memory $7F49.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $8C18E3.l,X		; 3F E3 18 8C ; AND accumulator with memory (long,X) $8C18E3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($18.b,S),Y		; 73 18 ; Add with carry (stack relative indirect indexed) ($18.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$28.b]		; E7 28 ; Subtract with carry (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$47.b],Y		; D7 47 ; Compare accumulator (long indexed) [$47.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sta $7E7F.w,X		; 9D 7F 7E ; Store accumulator to $7E7F.w,X [Reads: Accumulator, X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $FC030B.l,X		; FF 0B 03 FC ; Subtract with carry (long,X) $FC030B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $A7.b		; 25 A7 ; Logical AND $A7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $3CBF.w,X		; 3E BF 3C ; Rotate left $3CBF.w,X [Reads: X Index] [Flags: ZNC]
	lda $43BF3D.l,X		; BF 3D BF 43 ; Load long $43BF3D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $031F9F.l,X		; 1F 9F 1F 03 ; Logical OR long $031F9F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $43415A.l,X		; 7F 5A 41 43 ; Add long $43415A.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $42, $60		; 42 60 ; Reserved instruction
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($C2.b,X)		; 01 C2 ; Logical OR ($C2.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $017E.w		; 0D 7E 01 ; Logical OR $017E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $FEFD.w,X		; FE FD FE ; Increment memory $FEFD.w,X [Reads: X Index] [Flags: ZN]
	sta $2CFC.w,X		; 9D FC 2C ; Store accumulator to $2CFC.w,X [Reads: Accumulator, X Index]
	sbc $FD44.w,X		; FD 44 FD ; Subtract with carry $FD44.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc ($FF.b,S),Y		; F3 FF ; Subtract with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $63.b,S		; 03 63 ; OR accumulator with stack relative $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cmp ($BA.b)		; D2 BA ; Compare accumulator (indirect) ($BA.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta [$28.b],Y		; 97 28 ; Store accumulator (long indexed) [$28.b],Y [Reads: Accumulator, Direct Page, Y Index]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3FDE9E.l		; 2F 9E DE 3F ; AND accumulator with memory (long) $3FDE9E.l [Writes: Accumulator] [Flags: ZN]
	lda $3F7D75.l,X		; BF 75 7D 3F ; Load long $3F7D75.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $003F07.l,X		; 7F 07 3F 00 ; Add long $003F07.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$78.b]		; 07 78 ; OR accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp ($217C.w,X)		; 7C 7C 21 ; Jump indirect indexed to ($217C.w,X) [Reads: X Index] [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $82, $80, $C0		; 82 80 C0 ; Branch always long to $82, $80, $C0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta [$83.b]		; 87 83 ; Store accumulator (long) [$83.b] [Reads: Accumulator, Direct Page]
	adc $F7.b,S		; 63 F7 ; Add with carry (stack relative) $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	ora ($63.b,X)		; 01 63 ; Logical OR ($63.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sty $9E8D.w		; 8C 8D 9E ; Store Y register to $9E8D.w [Reads: Y Index]
	dec $BF3B.w,X		; DE 3B BF ; Decrement memory $BF3B.w,X [Reads: X Index] [Flags: ZN]
	ror $EE7F.w,X		; 7E 7F EE ; Rotate right $EE7F.w,X [Reads: X Index] [Flags: ZNC]
	sbc $08FFFE.l		; EF FE FF 08 ; Subtract with carry (long) $08FFFE.l [Writes: Accumulator] [Flags: ZVNC]
	stz $2172.w		; 9C 72 21 ; Store zero to $2172.w
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $E001.w,X		; BC 01 E0 ; Load Y register $E001.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $9B.b,S		; 03 9B ; OR accumulator with stack relative $9B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $CB.b,S		; 83 CB ; Store accumulator (stack relative) $CB.b,S [Reads: Accumulator, Stack Pointer]
	cpy #$EC.b		; C0 EC ; Compare #$EC.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$E7.b		; E0 E7 ; Compare #$E7.b with X register [Reads: X Index] [Flags: ZNC]
	cmp ($F7.b,X)		; C1 F7 ; Compare accumulator ($F7.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	trb $64CC.w		; 1C CC 64 ; Test and reset bits $64CC.w [Reads: Accumulator] [Flags: Z]
	bit $13.b,X		; 34 13 ; Test bits $13.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $F0, $FD		; F0 FD ; Branch if equal to $F0, $FD [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $1310.w,Y		; 79 10 13 ; Add $1310.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C9.b		; C0 C9 ; Compare #$C9.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $E4.b		; 04 E4 ; Test and set bits $E4.b [Reads: Accumulator] [Flags: Z]
	cop $86.b		; 02 86 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $363B.w		; EC 3B 36 ; Compare $363B.w with X register [Reads: X Index] [Flags: ZNC]
	inc $1BDA.w		; EE DA 1B ; Increment $1BDA.w [Flags: ZN]
	sbc $FE130F.l,X		; FF 0F 13 FE ; Subtract with carry (long,X) $FE130F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $FD.b		; 06 FD ; Arithmetic shift left $FD.b [Reads: Direct Page] [Flags: ZNC]
	bit $18FB.w		; 2C FB 18 ; Test bits $18FB.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sbc [$38.b],Y		; F7 38 ; Subtract with carry (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$6C.b]		; E7 6C ; Subtract with carry (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $BD.b		; C6 BD ; Decrement $BD.b [Reads: Direct Page] [Flags: ZN]
	sta $7E.b,S		; 83 7E ; Store accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00.b,S		; E3 00 ; Subtract stack-relative $00.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc $DE00.w		; ED 00 DE ; Subtract $DE00.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$42.b		; E0 42 ; Compare #$42.b with X register [Reads: X Index] [Flags: ZNC]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $F9.b,S		; 23 F9 ; AND accumulator with stack relative $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$F3.b]		; 07 F3 ; OR accumulator with memory (long) [$F3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $CF17E7.l		; 8F E7 17 CF ; Store accumulator (long) $CF17E7.l [Reads: Accumulator]
	and [$9F.b]		; 27 9F ; AND accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	sbc $FBFC.w,X		; FD FC FB ; Subtract with carry $FBFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $D3D7.w,Y		; F9 D7 D3 ; Subtract with carry $D3D7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$6F.b],Y		; 77 6F ; Add with carry (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$D8.b		; E0 D8 ; Compare #$D8.b with X register [Reads: X Index] [Flags: ZNC]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy $2EED.w,X		; BC ED 2E ; Load Y register $2EED.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $027D.w,X		; FE 7D 02 ; Increment memory $027D.w,X [Reads: X Index] [Flags: ZN]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	.db $90, $27		; 90 27 ; Branch if carry clear to $90, $27 [Flow: branch]
	eor $91.b,S		; 43 91 ; Exclusive OR accumulator with stack relative $91.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $C1.b		; 02 C1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($B963.w,X)		; 7C 63 B9 ; Jump indirect indexed to ($B963.w,X) [Reads: X Index] [Flow: jump]
	and [$D3.b],Y		; 37 D3 ; AND accumulator with memory (long indexed) [$D3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc [$C9.b]		; 67 C9 ; Add with carry (long) [$C9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and [$C4.b],Y		; 37 C4 ; AND accumulator with memory (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $FF01.w,X		; FE 01 FF ; Increment memory $FF01.w,X [Reads: X Index] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$F5.b],Y		; 17 F5 ; OR accumulator with memory (long indexed) [$F5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($CB.b,S),Y		; F3 CB ; Subtract with carry (stack relative indirect indexed) ($CB.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$14.b]		; C7 14 ; Compare accumulator (long) [$14.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tsb $1824.w		; 0C 24 18 ; Test and set bits $1824.w [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $67E6.w,X		; 3C E6 67 ; Test bits $67E6.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $F338.w		; 0C 38 F3 ; Test and set bits $F338.w [Reads: Accumulator] [Flags: Z]
	sbc [$C3.b]		; E7 C3 ; Subtract with carry (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $FE3E.w,Y		; 99 3E FE ; Store accumulator to $FE3E.w,Y [Reads: Accumulator, Y Index]
	eor $2800FF.l		; 4F FF 00 28 ; Exclusive OR accumulator with memory (long) $2800FF.l [Writes: Accumulator] [Flags: ZN]
	sbc $C00004.l,X		; FF 04 00 C0 ; Subtract with carry (long,X) $C00004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $49609F.l,X		; 3F 9F 60 49 ; AND accumulator with memory (long,X) $49609F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $FF2840.l,X		; BF 40 28 FF ; Load long $FF2840.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $B8639C.l,X		; 3F 9C 63 B8 ; AND accumulator with memory (long,X) $B8639C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor [$B0.b]		; 47 B0 ; Exclusive OR accumulator with memory (long) [$B0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $435FA0.l		; 4F A0 5F 43 ; Exclusive OR accumulator with memory (long) $435FA0.l [Writes: Accumulator] [Flags: ZN]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $F0F8FC.l,X		; FF FC F8 F0 ; Subtract with carry (long,X) $F0F8FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$37.b		; C0 37 ; Compare #$37.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $FF0004.l,X		; FF 04 00 FF ; Subtract with carry (long,X) $FF0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $4A60FF.l,X		; 3F FF 60 4A ; AND accumulator with memory (long,X) $4A60FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $002840.l,X		; FF 40 28 00 ; Subtract with carry (long,X) $002840.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr ($06FF.w,X)		; FC FF 06 ; Jump to subroutine indirect indexed ($06FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $002702.l,X		; FF 02 27 00 ; Subtract with carry (long,X) $002702.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $98F08F.l		; 0F 8F F0 98 ; OR accumulator with memory (long) $98F08F.l [Writes: Accumulator] [Flags: ZN]
	sbc [$B7.b]		; E7 B7 ; Subtract with carry (long) [$B7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	dec $EED5.w		; CE D5 EE ; Decrement $EED5.w [Flags: ZN]
	sbc #$F6.b		; E9 F6 ; Subtract #$F6.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	asl $DE11.w		; 0E 11 DE ; Arithmetic shift left $DE11.w [Flags: ZNC]
	sbc ($23.b,X)		; E1 23 ; Subtract with carry ($23.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jmp.w [$0024]		; DC 24 00 ; Jump long indirect [$0024] [Flow: jump]
	tsb $00E0.w		; 0C E0 00 ; Test and set bits $00E0.w [Reads: Accumulator] [Flags: Z]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $37CB.w		; 0D CB 37 ; Logical OR $37CB.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sta $5B.b,X		; 95 5B ; Store accumulator to $5B.b,X [Reads: Accumulator, X Index]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $7546.w		; ED 46 75 ; Subtract $7546.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	eor $C2.b,S		; 43 C2 ; Exclusive OR accumulator with stack relative $C2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $6209.w,Y		; F9 09 62 ; Subtract with carry $6209.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($02.b,X)		; E1 02 ; Subtract with carry ($02.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $88		; 10 88 ; Branch if plus to $10, $88 [Flow: branch]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	trb $208F.w		; 1C 8F 20 ; Test and reset bits $208F.w [Reads: Accumulator] [Flags: Z]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $01.b,X		; 35 01 ; Logical AND $01.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $C2.b,S		; 43 C2 ; Exclusive OR accumulator with stack relative $C2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $4689.w,Y		; F9 89 46 ; Subtract with carry $4689.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $C381.w,X		; 7E 81 C3 ; Rotate right $C381.w,X [Reads: X Index] [Flags: ZNC]
	ror $7EA5.w,X		; 7E A5 7E ; Rotate right $7EA5.w,X [Reads: X Index] [Flags: ZNC]
	lda $7E.b,S		; A3 7E ; Load accumulator (stack relative) $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit #$7E.b		; 89 7E ; Test bits #$7E.b with accumulator [Reads: Accumulator] [Flags: Z]
	lda ($7E.b,X)		; A1 7E ; Load accumulator ($7E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ror $0081.w,X		; 7E 81 00 ; Rotate right $0081.w,X [Reads: X Index] [Flags: ZNC]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $42, $F9		; 42 F9 ; Reserved instruction
	and [$F3.b],Y		; 37 F3 ; AND accumulator with memory (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $C3DBE7.l		; 6F E7 DB C3 ; Add with carry (long) $C3DBE7.l [Writes: Accumulator] [Flags: ZVNC]
	lda $3E7D99.l,X		; BF 99 7D 3E ; Load long $3E7D99.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $836F.w		; EE 6F 83 ; Increment $836F.w [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $42.b		; 24 42 ; Test bits $42.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta ($10.b,X)		; 81 10 ; Store accumulator ($10.b,X) [Reads: Accumulator, X Index, Direct Page]
	jsr ($7DFF.w,X)		; FC FF 7D ; Jump to subroutine indirect indexed ($7DFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $045E5A.l,X		; 7F 5A 5E 04 ; Add long $045E5A.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $E120.w,X		; 3C 20 E1 ; Test bits $E120.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	eor $DF44.w,X		; 5D 44 DF ; Exclusive OR accumulator with memory $DF44.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor [$04.b],Y		; 57 04 ; Exclusive OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($C3.b,X)		; A1 C3 ; Load accumulator ($C3.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $2022.w,X		; 1E 22 20 ; Arithmetic shift left $2022.w,X [Reads: X Index] [Flags: ZNC]
	ora [$03.b],Y		; 17 03 ; OR accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $916763.l		; 0F 63 67 91 ; OR accumulator with memory (long) $916763.l [Writes: Accumulator] [Flags: ZN]
	sbc ($60.b,S),Y		; F3 60 ; Subtract with carry (stack relative indirect indexed) ($60.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($E0.b,S),Y		; F3 E0 ; Subtract with carry (stack relative indirect indexed) ($E0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $81.b,S		; E3 81 ; Subtract stack-relative $81.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	stx $21.b		; 86 21 ; Store X register to $21.b [Reads: X Index]
	rol $FC83.w,X		; 3E 83 FC ; Rotate left $FC83.w,X [Reads: X Index] [Flags: ZNC]
	.db $F0, $98		; F0 98 ; Branch if equal to $F0, $98 [Flow: branch]
	tsb $1C0C.w		; 0C 0C 1C ; Test and set bits $1C0C.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	mvp $57,$DF		; 44 DF 57 ; Move block positive $57,$DF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sty $C0.b		; 84 C0 ; Store Y register to $C0.b [Reads: Y Index]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr $C897.w		; 20 97 C8 ; Jump to subroutine at $C897.w [Writes: Stack Pointer] [Flow: call]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cmp $92E121.l		; CF 21 E1 92 ; Compare accumulator (long) $92E121.l [Reads: Accumulator] [Flags: ZNC]
	adc ($CC.b,S),Y		; 73 CC ; Add with carry (stack relative indirect indexed) ($CC.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $115F20.l,X		; BF 20 5F 11 ; Load long $115F20.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $908F.w		; 2E 8F 90 ; Rotate left $908F.w [Flags: ZNC]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	sbc $0C1E30.l		; EF 30 1E 0C ; Subtract with carry (long) $0C1E30.l [Writes: Accumulator] [Flags: ZVNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	sbc ($18.b),Y		; F1 18 ; Subtract with carry ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	and [$D7.b],Y		; 37 D7 ; AND accumulator with memory (long indexed) [$D7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	lda $DB5FD3.l		; AF D3 5F DB ; Load long $DB5FD3.l into accumulator [Writes: Accumulator] [Flags: ZN]
	eor $63CF4F.l,X		; 5F 4F CF 63 ; Exclusive OR accumulator with memory (long,X) $63CF4F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00.b,S		; E3 00 ; Subtract stack-relative $00.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	jsr $1C30.w		; 20 30 1C ; Jump to subroutine at $1C30.w [Writes: Stack Pointer] [Flow: call]
	sbc $7CFB00.l,X		; FF 00 FB 7C ; Subtract with carry (long,X) $7CFB00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$78.b],Y		; F7 78 ; Subtract with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $60DF70.l		; EF 70 DF 60 ; Subtract with carry (long) $60DF70.l [Writes: Accumulator] [Flags: ZVNC]
	lda $FF4340.l,X		; BF 40 43 FF ; Load long $FF4340.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $6773.w,Y		; 79 73 67 ; Add $6773.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $013F1F.l		; 4F 1F 3F 01 ; Exclusive OR accumulator with memory (long) $013F1F.l [Writes: Accumulator] [Flags: ZN]
	inc $FF3C.w,X		; FE 3C FF ; Increment memory $FF3C.w,X [Reads: X Index] [Flags: ZN]
	adc [$F8.b]		; 67 F8 ; Add with carry (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $E05FF0.l		; 4F F0 5F E0 ; Exclusive OR accumulator with memory (long) $E05FF0.l [Writes: Accumulator] [Flags: ZN]
	adc $C03FC0.l,X		; 7F C0 3F C0 ; Add long $C03FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $030140.l,X		; BF 40 01 03 ; Load long $030140.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $4A7F3F.l,X		; 1F 3F 7F 4A ; Logical OR long $4A7F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $600540.l,X		; FF 40 05 60 ; Subtract with carry (long,X) $600540.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF3F.l,X		; FF 3F FF 00 ; Subtract with carry (long,X) $00FF3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $490027.l,X		; FF 27 00 49 ; Subtract with carry (long,X) $490027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $00FFFC.l,X		; FF FC FF 00 ; Subtract with carry (long,X) $00FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E00027.l,X		; FF 27 00 E0 ; Subtract with carry (long,X) $E00027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $843AD9.l		; 2F D9 3A 84 ; AND accumulator with memory (long) $843AD9.l [Writes: Accumulator] [Flags: ZN]
	eor $5E92.w,X		; 5D 92 5E ; Exclusive OR accumulator with memory $5E92.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec $31AE.w		; CE AE 31 ; Decrement $31AE.w [Flags: ZN]
	eor ($26.b),Y		; 51 26 ; Exclusive OR accumulator with memory ($26.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $AC8C93.l,X		; 1F 93 8C AC ; Logical OR long $AC8C93.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $04.b,S		; E3 04 ; Subtract stack-relative $04.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	jsl $8E1121.l		; 22 21 11 8E ; Jump to subroutine long $8E1121.l [Writes: Stack Pointer] [Flow: call]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $AF		; 10 AF ; Branch if plus to $10, $AF [Flow: branch]
	.db $70, $F1		; 70 F1 ; Branch if overflow set to $70, $F1 [Flow: branch]
	asl $33D2.w		; 0E D2 33 ; Arithmetic shift left $33D2.w [Flags: ZNC]
	lda $926D.w		; AD 6D 92 ; Load $926D.w into accumulator [Writes: Accumulator] [Flags: ZN]
	lsr $5F9B.w,X		; 5E 9B 5F ; Logical shift right $5F9B.w,X [Reads: X Index] [Flags: ZNC]
	ora [$C7.b]		; 07 C7 ; OR accumulator with memory (long) [$C7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($F3.b,S),Y		; 13 F3 ; OR accumulator (stack relative indirect indexed) ($F3.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb BG3VOFS.w		; 0C 12 21 ; Test and set bits BG3VOFS.w [Reads: Accumulator] [Flags: Z]
	jsr $0C38.w		; 20 38 0C ; Jump to subroutine at $0C38.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $2F		; F0 2F ; Branch if equal to $F0, $2F [Flow: branch]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: ZN]
	ora $00FF.w,Y		; 19 FF 00 ; OR accumulator with memory $00FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $40.b,S		; C3 40 ; Compare accumulator (stack relative) $40.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($F7.b,X)		; 21 F7 ; Logical AND ($F7.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($F6.b)		; 32 F6 ; AND accumulator with memory (indirect) ($F6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($FF.b)		; 32 FF ; AND accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $5E7F7F.l,X		; 3F 7F 7F 5E ; AND accumulator with memory (long,X) $5E7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $4E4D.w		; 4D 4D 4E ; Exclusive OR $4E4D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $BD4418.l,X		; FF 18 44 BD ; Subtract with carry (long,X) $BD4418.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $0D.b		; 24 0D ; Test bits $0D.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	cmp $00.b,S		; C3 00 ; Compare accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $7E817E.l,X		; FF 7E 81 7E ; Subtract with carry (long,X) $7E817E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $5A6600.l,X		; FF 00 66 5A ; Subtract with carry (long,X) $5A6600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ror $7E.b		; 66 7E ; Rotate right $7E.b [Reads: Direct Page] [Flags: ZNC]
	jsl $FF0200.l		; 22 00 02 FF ; Jump to subroutine long $FF0200.l [Writes: Stack Pointer] [Flow: call]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FF,$88		; 44 88 FF ; Move block positive $FF,$88 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	eor $DD.b,X		; 55 DD ; Exclusive OR accumulator with memory $DD.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $230000.l,X		; FF 00 00 23 ; Subtract with carry (long,X) $230000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$0A.b],Y		; 77 0A ; Add with carry (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $BD0000.l		; 22 00 00 BD ; Jump to subroutine long $BD0000.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $BD		; 42 BD ; Reserved instruction
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $C3		; 42 C3 ; Reserved instruction
	ror $4886.w,X		; 7E 86 48 ; Rotate right $4886.w,X [Reads: X Index] [Flags: ZNC]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $003C.w,X		; 7E 3C 00 ; Rotate right $003C.w,X [Reads: X Index] [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stx $7E.b		; 86 7E ; Store X register to $7E.b [Reads: X Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor [$BD.b]		; 47 BD ; Exclusive OR accumulator with memory (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $F77D.w		; CE 7D F7 ; Decrement $F77D.w [Flags: ZN]
	ror $83BB.w,X		; 7E BB 83 ; Rotate right $83BB.w,X [Reads: X Index] [Flags: ZNC]
	cmp $0100.w		; CD 00 01 ; Compare $0100.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	asl $BEDD.w		; 0E DD BE ; Arithmetic shift left $BEDD.w [Flags: ZNC]
	sbc $DD.b,S		; E3 DD ; Subtract stack-relative $DD.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	adc $FFBEE3.l,X		; 7F E3 BE FF ; Add long $FFBEE3.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($FF.b,X)		; 41 FF ; Exclusive OR accumulator with memory ($FF.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $81FF.w,X		; 3E FF 81 ; Rotate left $81FF.w,X [Reads: X Index] [Flags: ZNC]
	ror $28FF.w,X		; 7E FF 28 ; Rotate right $28FF.w,X [Reads: X Index] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $E4DFA0.l,X		; BF A0 DF E4 ; Load long $E4DFA0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0EA2.w		; 0C A2 0E ; Test and set bits $0EA2.w [Reads: Accumulator] [Flags: Z]
	eor $B2.b,S		; 43 B2 ; Exclusive OR accumulator with stack relative $B2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $07.b,X		; 56 07 ; Logical shift right $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldy $46.b,X		; B4 46 ; Load Y register $46.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $B0, $5A		; B0 5A ; Branch if carry set to $B0, $5A [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($51.b,S),Y		; 13 51 ; OR accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $450049.l		; 22 49 00 45 ; Jump to subroutine long $450049.l [Writes: Stack Pointer] [Flow: call]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $30F03F.l,X		; 1F 3F F0 30 ; Logical OR long $30F03F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($21.b,X)		; E1 21 ; Subtract with carry ($21.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $E42C.w		; EC 2C E4 ; Compare $E42C.w with X register [Reads: X Index] [Flags: ZNC]
	bit $F0.b		; 24 F0 ; Test bits $F0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	adc $5E4F40.l,X		; 7F 40 4F 5E ; Add long $5E4F40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($5B.b,S),Y		; 53 5B ; XOR accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $050602.l		; 4F 02 06 05 ; Exclusive OR accumulator with memory (long) $050602.l [Writes: Accumulator] [Flags: ZN]
	tsb $1007.w		; 0C 07 10 ; Test and set bits $1007.w [Reads: Accumulator] [Flags: Z]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3C42.w,Y		; 19 42 3C ; OR accumulator with memory $3C42.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FB00.w,X		; FD 00 FB ; Subtract with carry $FB00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	sta $00FE01.l,X		; 9F 01 FE 00 ; Store accumulator (long,X) $00FE01.l,X [Reads: Accumulator, X Index]
	lda $BF442F.l,X		; BF 2F 44 BF ; Load long $BF442F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$0B.b]		; 27 0B ; AND accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $DF.b		; 46 DF ; Logical shift right $DF.b [Reads: Direct Page] [Flags: ZNC]
	ora $60E6.w,Y		; 19 E6 60 ; OR accumulator with memory $60E6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $58507F.l,X		; 7F 7F 50 58 ; Add long $58507F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and $4319.w,Y		; 39 19 43 ; AND accumulator with memory $4319.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	pea $13FD.w		; F4 FD 13 ; Push absolute address $13FD.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	stz $FD.b,X		; 74 FD ; Store zero to $FD.b,X [Reads: X Index]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	sta $FE.b,X		; 95 FE ; Store accumulator to $FE.b,X [Reads: Accumulator, X Index]
	cmp [$FE.b]		; C7 FE ; Compare accumulator (long) [$FE.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	and $FE.b,S		; 23 FE ; AND accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $0A0AD0.l		; 2F D0 0A 0A ; AND accumulator with memory (long) $0A0AD0.l [Writes: Accumulator] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec $396B.w		; CE 6B 39 ; Decrement $396B.w [Flags: ZN]
	cmp $972F.w,X		; DD 2F 97 ; Compare accumulator $972F.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: ZNC]
	.db $90, $9F		; 90 9F ; Branch if carry clear to $90, $9F [Flow: branch]
	sta ($9F.b),Y		; 91 9F ; Store accumulator ($9F.b),Y [Reads: Accumulator, Direct Page, Y Index]
.ACCU 8
.INDEX 8
	sep #$FE		; E2 FE
	cpy $FC.b		; C4 FC ; Compare $FC.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	bit #$F9.b		; 89 F9 ; Test bits #$F9.b with accumulator [Reads: Accumulator] [Flags: Z]
	and ($F3.b,S),Y		; 33 F3 ; AND accumulator (stack relative indirect indexed) ($F3.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$E7.b]		; 67 E7 ; Add with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $6060CF.l		; 4F CF 60 60 ; Exclusive OR accumulator with memory (long) $6060CF.l [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	sbc $13FFE7.l,X		; FF E7 FF 13 ; Subtract with carry (long,X) $13FFE7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $C40F09.l,X		; 1F 09 0F C4 ; Logical OR long $C40F09.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$E2.b]		; C7 E2 ; Compare accumulator (long) [$E2.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc $43.b,S		; E3 43 ; Subtract stack-relative $43.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc ($F3.b)		; F2 F3 ; Subtract with carry (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$4E.b		; E0 4E ; Compare #$4E.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $0C0C.w		; 1C 0C 0C ; Test and reset bits $0C0C.w [Reads: Accumulator] [Flags: Z]
	sta ($F3.b)		; 92 F3 ; Store accumulator (indirect) ($F3.b) [Reads: Accumulator, Direct Page]
	cpx $FD.b		; E4 FD ; Compare $FD.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	pea $E8FD.w		; F4 FD E8 ; Push absolute address $E8FD.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $E7.b		; E5 E7 ; Subtract $E7.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	asl $FDE1.w,X		; 1E E1 FD ; Arithmetic shift left $FDE1.w,X [Reads: X Index] [Flags: ZNC]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0202.w		; 0C 02 02 ; Test and set bits $0202.w [Reads: Accumulator] [Flags: Z]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	sbc ($02.b,X)		; E1 02 ; Subtract with carry ($02.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF7B.w,X		; FD 7B FF ; Subtract with carry $FF7B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $758F.w		; 8D 8F 75 ; Store accumulator to $758F.w [Reads: Accumulator]
	adc [$49.b],Y		; 77 49 ; Add with carry (long indexed) [$49.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $FB		; B0 FB ; Branch if carry set to $B0, $FB [Flow: branch]
	.db $70, $FB		; 70 FB ; Branch if overflow set to $70, $FB [Flow: branch]
	jsr ($02FF.w,X)		; FC FF 02 ; Jump to subroutine indirect indexed ($02FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sty $04.b		; 84 04 ; Store Y register to $04.b [Reads: Y Index]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sbc $20FC20.l		; EF 20 FC 20 ; Subtract with carry (long) $20FC20.l [Writes: Accumulator] [Flags: ZVNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora $F7.b,S		; 03 F7 ; OR accumulator with stack relative $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$E8.b]		; 07 E8 ; OR accumulator with memory (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	sbc $7F9F00.l,X		; FF 00 9F 7F ; Subtract with carry (long,X) $7F9F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $787C5F.l,X		; 5F 5F 7C 78 ; Exclusive OR accumulator with memory (long,X) $787C5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$4F.b],Y		; 77 4F ; Add with carry (long indexed) [$4F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $047F8C.l,X		; 7F 8C 7F 04 ; Add long $047F8C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $8578.w,Y		; B9 78 85 ; Load $8578.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $007F07.l,X		; 3F 07 7F 00 ; AND accumulator with memory (long,X) $007F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $80BE80.l,X		; FF 80 BE 80 ; Subtract with carry (long,X) $80BE80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $8022.w		; 9C 22 80 ; Store zero to $8022.w
	asl $C1.b		; 06 C1 ; Arithmetic shift left $C1.b [Reads: Direct Page] [Flags: ZNC]
	cmp ($62.b,X)		; C1 62 ; Compare accumulator ($62.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc $BE.b,S		; E3 BE ; Subtract stack-relative $BE.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	adc $7F23FF.l,X		; 7F FF 23 7F ; Add long $7F23FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	trb $F700.w		; 1C 00 F7 ; Test and reset bits $F700.w [Reads: Accumulator] [Flags: Z]
	.db $70, $EF		; 70 EF ; Branch if overflow set to $70, $EF [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor [$DF.b]		; 47 DF ; Exclusive OR accumulator with memory (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora $CF.b		; 05 CF ; Logical OR $CF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $3F241F.l		; 0F 1F 24 3F ; OR accumulator with memory (long) $3F241F.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BEC1C1.l,X		; FF C1 C1 BE ; Subtract with carry (long,X) $BEC1C1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $46		; 80 46 ; Branch always to $80, $46 [Flow: branch]
	adc $002200.l,X		; 7F 00 22 00 ; Add long $002200.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($3E.b,X)		; 01 3E ; Logical OR ($3E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $E0FF23.l,X		; 7F 23 FF E0 ; Add long $E0FF23.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	mvn $0F,$F0		; 54 F0 0F ; Move block negative $0F,$F0 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sta [$79.b]		; 87 79 ; Store accumulator (long) [$79.b] [Reads: Accumulator, Direct Page]
	ora $19F3.w		; 0D F3 19 ; Logical OR $19F3.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc [$31.b]		; E7 31 ; Subtract with carry (long) [$31.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $F09F7F.l		; CF 7F 9F F0 ; Compare accumulator (long) $F09F7F.l [Reads: Accumulator] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$A8.b],Y		; 57 A8 ; Exclusive OR accumulator with memory (long indexed) [$A8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $5F.b		; A5 5F ; Load $5F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $6F.b,X		; B5 6F ; Load $6F.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc [$BF.b],Y		; 77 BF ; Add with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	sbc $454800.l,X		; FF 00 48 45 ; Subtract with carry (long,X) $454800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	adc $20E000.l,X		; 7F 00 E0 20 ; Add long $20E000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: ZN]
	inc $36.b,X		; F6 36 ; Increment memory $36.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $7FBF00.l,X		; FF 00 BF 7F ; Subtract with carry (long,X) $7FBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	nop		; EA ; No operation
	eor $95.b,X		; 55 95 ; Exclusive OR accumulator with memory $95.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $5F40E0.l,X		; 3F E0 40 5F ; AND accumulator with memory (long,X) $5F40E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7F49.w,Y		; 59 49 7F ; Exclusive OR accumulator with memory $7F49.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $8C18E3.l,X		; 3F E3 18 8C ; AND accumulator with memory (long,X) $8C18E3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($18.b,S),Y		; 73 18 ; Add with carry (stack relative indirect indexed) ($18.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$28.b]		; E7 28 ; Subtract with carry (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$47.b],Y		; D7 47 ; Compare accumulator (long indexed) [$47.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sta $7E7F.w,X		; 9D 7F 7E ; Store accumulator to $7E7F.w,X [Reads: Accumulator, X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $192FE0.l,X		; FF E0 2F 19 ; Subtract with carry (long,X) $192FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $02.b		; E6 02 ; Increment $02.b [Reads: Direct Page] [Flags: ZN]
	lda $38BF31.l,X		; BF 31 BF 38 ; Load long $38BF31.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $3B9F18.l,X		; BF 18 9F 3B ; Load long $3B9F18.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $1FBF3F.l,X		; BF 3F BF 1F ; Load long $1FBF3F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $4E7D19.l,X		; 9F 19 7D 4E ; Store accumulator (long,X) $4E7D19.l,X [Reads: Accumulator, X Index]
	eor [$67.b]		; 47 67 ; Exclusive OR accumulator with memory (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $60,$40		; 44 40 60 ; Move block positive $60,$40 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and [$D8.b]		; 27 D8 ; AND accumulator with memory (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $3DFE.w,X		; DD FE 3D ; Compare accumulator $3DFE.w,X [Reads: X Index] [Flags: ZNC]
	inc $FEF9.w,X		; FE F9 FE ; Increment memory $FEF9.w,X [Reads: X Index] [Flags: ZN]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $DDFE.w		; 8D FE DD ; Store accumulator to $DDFE.w [Reads: Accumulator]
	jsr ($FDFC.w,X)		; FC FC FD ; Jump to subroutine indirect indexed ($FDFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and [$23.b]		; 27 23 ; AND accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $07.b,S		; C3 07 ; Compare accumulator (stack relative) $07.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $022373.l,X		; FF 73 23 02 ; Subtract with carry (long,X) $022373.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta [$28.b],Y		; 97 28 ; Store accumulator (long indexed) [$28.b],Y [Reads: Accumulator, Direct Page, Y Index]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($4F.b,X)		; 41 4F ; Exclusive OR accumulator with memory ($4F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $33E767.l		; CF 67 E7 33 ; Compare accumulator (long) $33E767.l [Reads: Accumulator] [Flags: ZNC]
	sbc ($1B.b,S),Y		; F3 1B ; Subtract with carry (stack relative indirect indexed) ($1B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta $FFC7FF.l		; 8F FF C7 FF ; Store accumulator (long) $FFC7FF.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $30BFA0.l,X		; 7F A0 BF 30 ; Add long $30BFA0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $0004.w		; 0C 04 00 ; Test and set bits $0004.w [Reads: Accumulator] [Flags: Z]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inc $F7.b,X		; F6 F7 ; Increment memory $F7.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cpx $D8EF.w		; EC EF D8 ; Compare $D8EF.w with X register [Reads: X Index] [Flags: ZNC]
	cmp $E7FFF3.l,X		; DF F3 FF E7 ; Compare accumulator (long,X) $E7FFF3.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $13F8C8.l,X		; FF C8 F8 13 ; Subtract with carry (long,X) $13F8C8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($37.b,S),Y		; F3 37 ; Subtract with carry (stack relative indirect indexed) ($37.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $DF4FCF.l		; 4F CF 4F DF ; Exclusive OR accumulator with memory (long) $DF4FCF.l [Writes: Accumulator] [Flags: ZN]
	eor ($DE.b)		; 52 DE ; Exclusive OR accumulator with memory (indirect) ($DE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldx $31EE.w		; AE EE 31 ; Load $31EE.w into X register [Writes: X Index] [Flags: ZN]
	adc ($1F.b),Y		; 71 1F ; Add with carry ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $A89F80.l,X		; 3F 80 9F A8 ; AND accumulator with memory (long,X) $A89F80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $852030.l		; EF 30 20 85 ; Subtract with carry (long) $852030.l [Writes: Accumulator] [Flags: ZVNC]
	lda ($02.b)		; B2 02 ; Load accumulator (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$B0.b],Y		; 17 B0 ; OR accumulator with memory (long indexed) [$B0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $A77840.l,X		; BF 40 78 A7 ; Load long $A77840.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$88.b]		; E7 88 ; Subtract with carry (long) [$88.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $1BDF53.l		; CF 53 DF 1B ; Compare accumulator (long) $1BDF53.l [Reads: Accumulator] [Flags: ZNC]
	sta $13C747.l,X		; 9F 47 C7 13 ; Store accumulator (long,X) $13C747.l,X [Reads: Accumulator, X Index]
	sbc ($40.b,S),Y		; F3 40 ; Subtract with carry (stack relative indirect indexed) ($40.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta [$18.b]		; 87 18 ; Store accumulator (long) [$18.b] [Reads: Accumulator, Direct Page]
	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	tsb $E0FF.w		; 0C FF E0 ; Test and set bits $E0FF.w [Reads: Accumulator] [Flags: Z]
	and ($93.b,X)		; 21 93 ; Logical AND ($93.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $428E.w		; 0C 8E 42 ; Test and set bits $428E.w [Reads: Accumulator] [Flags: Z]
	inc $4E.b		; E6 4E ; Increment $4E.b [Reads: Direct Page] [Flags: ZN]
	dec $66.b,X		; D6 66 ; Decrement memory $66.b,X [Reads: X Index, Direct Page] [Flags: ZN]
.ACCU 8
.INDEX 8
	sep #$3A		; E2 3A
	adc $99.b		; 65 99 ; Add $99.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rol $77C8.w,X		; 3E C8 77 ; Rotate left $77C8.w,X [Reads: X Index] [Flags: ZNC]
	ldy $3160.w		; AC 60 31 ; Load $3160.w into Y register [Writes: Y Index] [Flags: ZN]
	ora ($09.b),Y		; 11 09 ; OR accumulator with memory ($09.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $7BDF00.l,X		; FF 00 DF 7B ; Subtract with carry (long,X) $7BDF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy $FC77.w,X		; BC 77 FC ; Load Y register $FC77.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $62, $E0, $46		; 62 E0 46 ; Push effective relative address $62, $E0, $46 [Writes: Stack Pointer]
	eor $EE.b,S		; 43 EE ; Exclusive OR accumulator with stack relative $EE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor ($19.b),Y		; 51 19 ; Exclusive OR accumulator with memory ($19.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($0052.w,X)		; FC 52 00 ; Jump to subroutine indirect indexed ($0052.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($44.b,S),Y		; 13 44 ; OR accumulator (stack relative indirect indexed) ($44.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$7C.b]		; C7 7C ; Compare accumulator (long) [$7C.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc $7DFE83.l,X		; FF 83 FE 7D ; Subtract with carry (long,X) $7DFE83.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $7C83.w,X		; FE 83 7C ; Increment memory $7C83.w,X [Reads: X Index] [Flags: ZN]
	sbc $1BE439.l,X		; FF 39 E4 1B ; Subtract with carry (long,X) $1BE439.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($0E.b),Y		; F1 0E ; Subtract with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $0024FE.l		; 22 FE 24 00 ; Jump to subroutine long $0024FE.l [Writes: Stack Pointer] [Flow: call]
	ora $97F04F.l		; 0F 4F F0 97 ; OR accumulator with memory (long) $97F04F.l [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta [$FC.b],Y		; 97 FC ; Store accumulator (long indexed) [$FC.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sta $FE.b,X		; 95 FE ; Store accumulator to $FE.b,X [Reads: Accumulator, X Index]
	sty $FF.b,X		; 94 FF ; Store Y register $FF.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	stx $F9.b,Y		; 96 F9 ; Store X register $F9.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	jmp $7DF3.w		; 4C F3 7D ; Jump to $7DF3.w [Flow: jump]
	stx $26.b		; 86 26 ; Store X register to $26.b [Reads: X Index]
	cpy #$10.b		; C0 10 ; Compare #$10.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FE00FF.l,X		; FF FF 00 FE ; Subtract with carry (long,X) $FE00FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $6ADB.w		; 6D DB 6A ; Add $6ADB.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	lda $6D.b,X		; B5 6D ; Load $6D.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	ror $B6.b,X		; 76 B6 ; Rotate right $B6.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	dec $226A.w,X		; DE 6A 22 ; Decrement memory $226A.w,X [Reads: X Index] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	jsl $0F1C01.l		; 22 01 1C 0F ; Jump to subroutine long $0F1C01.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $F3		; F0 F3 ; Branch if equal to $F0, $F3 [Flow: branch]
	ora $4F30D0.l		; 0F D0 30 4F ; OR accumulator with memory (long) $4F30D0.l [Writes: Accumulator] [Flags: ZN]
	cmp $40BFB0.l		; CF B0 BF 40 ; Compare accumulator (long) $40BFB0.l [Reads: Accumulator] [Flags: ZNC]
	adc $07FF80.l,X		; 7F 80 FF 07 ; Add long $07FF80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $804030.l		; 0F 30 40 80 ; OR accumulator with memory (long) $804030.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7F8000.l,X		; FF 00 80 7F ; Subtract with carry (long,X) $7F8000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $4A		; 80 4A ; Branch always to $80, $4A [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sta $7F0002.l,X		; 9F 02 00 7F ; Store accumulator (long,X) $7F0002.l,X [Reads: Accumulator, X Index]
	adc $006024.l,X		; 7F 24 60 00 ; Add long $006024.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $008E83.l,X		; FF 83 8E 00 ; Subtract with carry (long,X) $008E83.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0024FF.l,X		; FF FF 24 00 ; Subtract with carry (long,X) $0024FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($C2.b)		; 12 C2 ; OR accumulator with memory (indirect) ($C2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $F87F82.l,X		; 3F 82 7F F8 ; AND accumulator with memory (long,X) $F87F82.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $05FB.w,Y		; 79 FB 05 ; Add $05FB.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$3D.b]		; C7 3D ; Compare accumulator (long) [$3D.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta $75877D.l		; 8F 7D 87 75 ; Store accumulator (long) $75877D.l [Reads: Accumulator]
	sta [$85.b]		; 87 85 ; Store accumulator (long) [$85.b] [Reads: Accumulator, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: ZNC]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	and $BF5FC0.l,X		; 3F C0 5F BF ; AND accumulator with memory (long,X) $BF5FC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $79FF73.l,X		; BF 73 FF 79 ; Load long $79FF73.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $439C0F.l		; 8F 0F 9C 43 ; Store accumulator (long) $439C0F.l [Reads: Accumulator]
	jmp ($00DF.w)		; 6C DF 00 ; Jump indirect to ($00DF.w) [Flow: jump]
	stz $23.b		; 64 23 ; Store zero to $23.b
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $03		; 70 03 ; Branch if overflow set to $70, $03 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $EC18E0.l,X		; 1F E0 18 EC ; Logical OR long $EC18E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $0FF8C7.l,X		; 3F C7 F8 0F ; AND accumulator with memory (long,X) $0FF8C7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($5F.b,S),Y		; F3 5F ; Subtract with carry (stack relative indirect indexed) ($5F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda [$7F.b]		; A7 7F ; Load accumulator (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $A7.b,S		; 43 A7 ; Exclusive OR accumulator with stack relative $A7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $0F0003.l,X		; 3F 03 00 0F ; AND accumulator with memory (long,X) $0F0003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $7F231F.l		; 0F 1F 23 7F ; OR accumulator with memory (long) $7F231F.l [Writes: Accumulator] [Flags: ZN]
	ora #$FF.b		; 09 FF ; Logical OR #$FF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FC78BF.l,X		; 7F BF 78 FC ; Add long $FC78BF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($FB.b,S),Y		; 73 FB ; Add with carry (stack relative indirect indexed) ($FB.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$45.b]		; 67 45 ; Add with carry (long) [$45.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$6F.b],Y		; F7 6F ; Subtract with carry (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $070000.l		; 22 00 00 07 ; Jump to subroutine long $070000.l [Writes: Stack Pointer] [Flow: call]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF4480.l,X		; FF 80 44 FF ; Subtract with carry (long,X) $FF4480.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $FFBB02.l,X		; BF 02 BB FF ; Load long $FFBB02.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda [$43.b],Y		; B7 43 ; Load accumulator (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FF2BBF.l,X		; FF BF 2B FF ; Subtract with carry (long,X) $FF2BBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$80.b		; 09 80 ; Logical OR #$80.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cpy #$BF.b		; C0 BF ; Compare #$BF.b with Y register [Reads: Y Index] [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sbc $BFEFBF.l,X		; FF BF EF BF ; Subtract with carry (long,X) $BFEFBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $BF43.w,X		; FD 43 BF ; Subtract with carry $BF43.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $808002.l,X		; FF 02 80 80 ; Subtract with carry (long,X) $808002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $23.b		; 84 23 ; Store Y register to $23.b [Reads: Y Index]
	.db $80, $84		; 80 84 ; Branch always to $80, $84 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $FB7CFC.l,X		; 7F FC 7C FB ; Add long $FB7CFC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc [$77.b],Y		; F7 77 ; Subtract with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $030022.l,X		; 7F 22 00 03 ; Add long $030022.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $041200.l,X		; FF 00 12 04 ; Subtract with carry (long,X) $041200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFF00.l,X		; FF 00 FF FF ; Subtract with carry (long,X) $FFFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $DFFFFF.l,X		; BF FF FF DF ; Load long $DFFFFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $9F4DD7.l,X		; FF D7 4D 9F ; Subtract with carry (long,X) $9F4DD7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($A2.b,X)		; 21 A2 ; Logical AND ($A2.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor ($D5.b,X)		; 41 D5 ; Exclusive OR accumulator with memory ($D5.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $43.b		; 14 43 ; Test and reset bits $43.b [Reads: Accumulator] [Flags: Z]
	ldx $36.b,Y		; B6 36 ; Load X register $36.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	cpx #$34.b		; E0 34 ; Compare #$34.b with X register [Reads: X Index] [Flags: ZNC]
	cmp $55.b,X		; D5 55 ; Compare accumulator $55.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $41.b,S		; E3 41 ; Subtract stack-relative $41.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	jsr $1C40.w		; 20 40 1C ; Jump to subroutine at $1C40.w [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	eor #$49.b		; 49 49 ; Exclusive OR #$49.b with accumulator [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	trb $B2EB.w		; 1C EB B2 ; Test and reset bits $B2EB.w [Reads: Accumulator] [Flags: Z]
	sbc $AC.b,X		; F5 AC ; Subtract $AC.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stx $97.b,Y		; 96 97 ; Store X register $97.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$9A.b],Y		; 17 9A ; OR accumulator with memory (long indexed) [$9A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc #$F6.b		; 69 F6 ; Add #$F6.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	wai		; CB ; Wait for interrupt
	and ($FD.b)		; 32 FD ; AND accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $04.b,X		; 56 04 ; Logical shift right $04.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($FF.b,X)		; 41 FF ; Exclusive OR accumulator with memory ($FF.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor #$FE.b		; 49 FE ; Exclusive OR #$FE.b with accumulator [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	sbc $DC5E.w,X		; FD 5E DC ; Subtract with carry $DC5E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $BF.b,S		; 63 BF ; Add with carry (stack relative) $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	and $FF40C0.l,X		; 3F C0 40 FF ; AND accumulator with memory (long,X) $FF40C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($40.b),Y		; 11 40 ; OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $58F700.l,X		; 3F 00 F7 58 ; AND accumulator with memory (long,X) $58F700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $1AEFE2.l,X		; 5F E2 EF 1A ; Exclusive OR accumulator with memory (long,X) $1AEFE2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$12.b],Y		; F7 12 ; Subtract with carry (long indexed) [$12.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FCFDC2.l,X		; 3F C2 FD FC ; AND accumulator with memory (long,X) $FCFDC2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $050023.l,X		; FF 23 00 05 ; Subtract with carry (long,X) $050023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($ED00.w,X)		; FC 00 ED ; Jump to subroutine indirect indexed ($ED00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor $43FD.w,Y		; 59 FD 43 ; Exclusive OR accumulator with memory $43FD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $015A.w,X		; FE 5A 01 ; Increment memory $015A.w,X [Reads: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	mvn $02,$24		; 54 24 02 ; Move block negative $02,$24 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	sbc [$33.b]		; E7 33 ; Subtract with carry (long) [$33.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpy $D827.w		; CC 27 D8 ; Compare $D827.w with Y register [Reads: Y Index] [Flags: ZNC]
	eor $2F.b		; 45 2F ; Exclusive OR $2F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $D0, $01		; D0 01 ; Branch if not equal to $D0, $01 [Flow: branch]
	lda $0027D0.l		; AF D0 27 00 ; Load long $0027D0.l into accumulator [Writes: Accumulator] [Flags: ZN]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sta $800440.l,X		; 9F 40 04 80 ; Store accumulator (long,X) $800440.l,X [Reads: Accumulator, X Index]
	eor $604080.l,X		; 5F 80 40 60 ; Exclusive OR accumulator with memory (long,X) $604080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $6F.b		; 24 6F ; Test bits $6F.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $00FF4B.l,X		; 7F 4B FF 00 ; Add long $00FF4B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $260022.l,X		; FF 22 00 26 ; Subtract with carry (long,X) $260022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F51F01.l,X		; FF 01 1F F5 ; Subtract with carry (long,X) $F51F01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $EE.b,S		; 43 EE ; Exclusive OR accumulator with stack relative $EE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx $01.b		; E4 01 ; Compare $01.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	dec $43C4.w		; CE C4 43 ; Decrement $43C4.w [Flags: ZN]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpy #$43.b		; C0 43 ; Compare #$43.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $0A03C0.l		; EF C0 03 0A ; Subtract with carry (long) $0A03C0.l [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $3F.b,S		; 23 3F ; AND accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	mvp $60,$DF		; 44 DF 60 ; Move block positive $60,$DF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ror $DF.b		; 66 DF ; Rotate right $DF.b [Reads: Direct Page] [Flags: ZNC]
	ror $DB.b		; 66 DB ; Rotate right $DB.b [Reads: Direct Page] [Flags: ZNC]
	lsr $AD.b		; 46 AD ; Logical shift right $AD.b [Reads: Direct Page] [Flags: ZNC]
	adc $C7.b,S		; 63 C7 ; Add with carry (stack relative) $C7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $1A8380.l,X		; 7F 80 83 1A ; Add long $1A8380.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $000317.l		; 2F 17 03 00 ; AND accumulator with memory (long) $000317.l [Writes: Accumulator] [Flags: ZN]
	lda [$5F.b]		; A7 5F ; Load accumulator (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc ($5F.b,S),Y		; F3 5F ; Subtract with carry (stack relative indirect indexed) ($5F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $F803FF.l		; 4F FF 03 F8 ; Exclusive OR accumulator with memory (long) $F803FF.l [Writes: Accumulator] [Flags: ZN]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	ora $E01FE8.l,X		; 1F E8 1F E0 ; Logical OR long $E01FE8.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $6F177F.l		; 22 7F 17 6F ; Jump to subroutine long $6F177F.l [Writes: Stack Pointer] [Flow: call]
	ora $00080C.l		; 0F 0C 08 00 ; OR accumulator with memory (long) $00080C.l [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $FC.b,S		; 63 FC ; Add with carry (stack relative) $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $78FF70.l,X		; FF 70 FF 78 ; Subtract with carry (long,X) $78FF70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $7FDF7F.l,X		; BF 7F DF 7F ; Load long $7FDF7F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$7F.b		; E0 7F ; Compare #$7F.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $0F0F00.l,X		; FF 00 0F 0F ; Subtract with carry (long,X) $0F0F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($5E.b),Y		; F1 5E ; Subtract with carry ($5E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C846.w,X		; FD 46 C8 ; Subtract with carry $C846.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$EE.b],Y		; 77 EE ; Add with carry (long indexed) [$EE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $F5.b,X		; 75 F5 ; Add $F5.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	lda $7FC07F.l,X		; BF 7F C0 7F ; Load long $7FC07F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $061E00.l,X		; FF 00 1E 06 ; Subtract with carry (long,X) $061E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $F7BD.w,X		; FD BD F7 ; Subtract with carry $F7BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $FDBFFF.l,X		; BF FF BF FD ; Load long $FDBFFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $2A83F7.l,X		; BF F7 83 2A ; Load long $2A83F7.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	sbc $802282.l,X		; FF 82 22 80 ; Subtract with carry (long,X) $802282.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	sbc $F77FFF.l,X		; FF FF 7F F7 ; Subtract with carry (long,X) $F77FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $FC7FFB.l,X		; 7F FB 7F FC ; Add long $FC7FFB.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $029086.l,X		; 7F 86 90 02 ; Add long $029086.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7FB100.l,X		; FF 00 B1 7F ; Subtract with carry (long,X) $7FB100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc [$F5.b]		; 67 F5 ; Add with carry (long) [$F5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lsr $5DAA.w		; 4E AA 5D ; Logical shift right $5DAA.w [Flags: ZNC]
	sta $7B.b,X		; 95 7B ; Store accumulator to $7B.b,X [Reads: Accumulator, X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	adc [$D5.b],Y		; 77 D5 ; Add with carry (long indexed) [$D5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $0027.w		; 6E 27 00 ; Rotate right $0027.w [Flags: ZNC]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $694390.l		; 6F 90 43 69 ; Add with carry (long) $694390.l [Writes: Accumulator] [Flags: ZVNC]
	stx $46.b,Y		; 96 46 ; Store X register $46.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ora $000296.l		; 0F 96 02 00 ; OR accumulator with memory (long) $000296.l [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ror $24.b		; 66 24 ; Rotate right $24.b [Reads: Direct Page] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $6E91.w		; 6E 91 6E ; Rotate right $6E91.w [Flags: ZNC]
	eor [$97.b]		; 47 97 ; Exclusive OR accumulator with memory (long) [$97.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $600002.l		; 0F 02 00 60 ; OR accumulator with memory (long) $600002.l [Writes: Accumulator] [Flags: ZN]
	adc ($24.b,X)		; 61 24 ; Add with carry ($24.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $7F.b		; 26 7F ; Rotate left $7F.b [Reads: Direct Page] [Flags: ZNC]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $F7.b		; 02 F7 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $47.b		; 06 47 ; Arithmetic shift left $47.b [Reads: Direct Page] [Flags: ZNC]
	sbc $00030E.l,X		; FF 0E 03 00 ; Subtract with carry (long,X) $00030E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $F8FC.w,X		; FE FC F8 ; Increment memory $F8FC.w,X [Reads: X Index] [Flags: ZN]
	and $F0.b,S		; 23 F0 ; AND accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$36.b		; E0 36 ; Compare #$36.b with X register [Reads: X Index] [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	pea $FB57.w		; F4 57 FB ; Push absolute address $FB57.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jmp $EE42FF.l		; 5C FF 42 EE ; Jump long to $EE42FF.l [Flow: jump]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	sbc $4AFB5D.l		; EF 5D FB 4A ; Subtract with carry (long) $4AFB5D.l [Writes: Accumulator] [Flags: ZVNC]
	pei ($6C.b)		; D4 6C ; Push effective indirect address ($6C.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	eor [$68.b],Y		; 57 68 ; Exclusive OR accumulator with memory (long indexed) [$68.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $CF4FB0.l,X		; BF B0 4F CF ; Load long $CF4FB0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $90, $70		; 90 70 ; Branch if carry clear to $90, $70 [Flow: branch]
	sbc [$1F.b]		; E7 1F ; Subtract with carry (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $70FF80.l,X		; FF 80 FF 70 ; Subtract with carry (long,X) $70FF80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $800B.w		; 0E 0B 80 ; Arithmetic shift left $800B.w [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	ora $F3.b,S		; 03 F3 ; OR accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	sbc $37C800.l,X		; FF 00 C8 37 ; Subtract with carry (long,X) $37C800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $C13043.l		; CF 43 30 C1 ; Compare accumulator (long) $C13043.l [Reads: Accumulator] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $3FC0.w,X		; 3E C0 3F ; Rotate left $3FC0.w,X [Reads: X Index] [Flags: ZNC]
	sbc $007F00.l,X		; FF 00 7F 00 ; Subtract with carry (long,X) $007F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	rol $3F3E.w,X		; 3E 3E 3F ; Rotate left $3F3E.w,X [Reads: X Index] [Flags: ZNC]
	sty $5F.b		; 84 5F ; Store Y register to $5F.b [Reads: Y Index]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$F6.b		; 09 F6 ; Logical OR #$F6.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc [$83.b],Y		; F7 83 ; Subtract with carry (long indexed) [$83.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $060200.l,X		; FF 00 02 06 ; Subtract with carry (long,X) $060200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: ZNC]
	mvp $FF,$00		; [PATTERN: Memory clearing operation] 44 00 FF ; Move block positive $FF,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $7BDC.w,Y		; 19 DC 7B ; OR accumulator with memory $7BDC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	stz $FB.b,X		; 74 FB ; Store zero to $FB.b,X [Reads: X Index]
	stz $FB.b		; 64 FB ; Store zero to $FB.b
	mvp $53,$FC		; 44 FC 53 ; Move block positive $53,$FC [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sbc $58FF50.l,X		; FF 50 FF 58 ; Subtract with carry (long,X) $58FF50.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: ZNC]
	asl $17.b,X		; 16 17 ; Arithmetic shift left $17.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $00FF.w		; 1C FF 00 ; Test and reset bits $00FF.w [Reads: Accumulator] [Flags: Z]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	eor $DF.b		; 45 DF ; Exclusive OR $DF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $40C007.l,X		; 5F 07 C0 40 ; Exclusive OR accumulator with memory (long,X) $40C007.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $40FF7F.l,X		; FF 7F FF 40 ; Subtract with carry (long,X) $40FF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3F0120.l		; 22 20 01 3F ; Jump to subroutine long $3F0120.l [Writes: Stack Pointer] [Flow: call]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $03.b,S		; 43 03 ; Exclusive OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $034301.l,X		; FF 01 43 03 ; Subtract with carry (long,X) $034301.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF0743.l,X		; FF 43 07 FF ; Subtract with carry (long,X) $FF0743.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00270F.l,X		; FF 0F 27 00 ; Subtract with carry (long,X) $00270F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$A0.b],Y		; 17 A0 ; OR accumulator with memory (long indexed) [$A0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $20B050.l		; 6F 50 B0 20 ; Add with carry (long) $20B050.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $880FF0.l,X		; DF F0 0F 88 ; Compare accumulator (long,X) $880FF0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	eor [$B5.b],Y		; 57 B5 ; Exclusive OR accumulator with memory (long indexed) [$B5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $B56B.w,X		; BD 6B B5 ; Load $B56B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $1F.b,S		; 63 1F ; Add with carry (stack relative) $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	ora $200000.l		; 0F 00 00 20 ; OR accumulator with memory (long) $200000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0027FF.l		; 2F FF 27 00 ; AND accumulator with memory (long) $0027FF.l [Writes: Accumulator] [Flags: ZN]
	jsl $3F04FF.l		; 22 FF 04 3F ; Jump to subroutine long $3F04FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $03FF0F.l,X		; FF 0F FF 03 ; Subtract with carry (long,X) $03FF0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: ZNC]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $045384.l,X		; FF 84 53 04 ; Subtract with carry (long,X) $045384.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($90.b),Y		; 11 90 ; OR accumulator with memory ($90.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $960990.l		; 0F 90 09 96 ; OR accumulator with memory (long) $960990.l [Writes: Accumulator] [Flags: ZN]
	adc $906996.l		; 6F 96 69 90 ; Add with carry (long) $906996.l [Writes: Accumulator] [Flags: ZVNC]
	adc $867689.l		; 6F 89 76 86 ; Add with carry (long) $867689.l [Writes: Accumulator] [Flags: ZVNC]
	eor #$B0.b		; 49 B0 ; Exclusive OR #$B0.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $226660.l		; 4F 60 66 22 ; Exclusive OR accumulator with memory (long) $226660.l [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $70.b		; 14 70 ; Test and reset bits $70.b [Reads: Accumulator] [Flags: Z]
	adc $904F.w,Y		; 79 4F 90 ; Add $904F.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $910E90.l		; 0F 90 0E 91 ; OR accumulator with memory (long) $910E90.l [Writes: Accumulator] [Flags: ZN]
	adc $906E91.l		; 6F 91 6E 90 ; Add with carry (long) $906E91.l [Writes: Accumulator] [Flags: ZVNC]
	adc $07F708.l		; 6F 08 F7 07 ; Add with carry (long) $07F708.l [Writes: Accumulator] [Flags: ZVNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $226160.l,X		; 9F 60 61 22 ; Store accumulator (long,X) $226160.l,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $008F45.l,X		; 9F 45 8F 00 ; Store accumulator (long,X) $008F45.l,X [Reads: Accumulator, X Index]
	ora $97.b		; 05 97 ; Logical OR $97.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$AF.b]		; 07 AF ; OR accumulator with memory (long) [$AF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $831FDF.l		; 0F DF 1F 83 ; OR accumulator with memory (long) $831FDF.l [Writes: Accumulator] [Flags: ZN]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	jsl $78047F.l		; 22 7F 04 78 ; Jump to subroutine long $78047F.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $F709.w		; 0E 09 F7 ; Arithmetic shift left $F709.w [Flags: ZNC]
	inc $FB.b,X		; F6 FB ; Increment memory $FB.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sbc $01FC.w,X		; FD FC 01 ; Subtract with carry $01FC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: ZN]
	jsl $0800F0.l		; 22 F0 00 08 ; Jump to subroutine long $0800F0.l [Writes: Stack Pointer] [Flow: call]
	sta $A8.b,S		; 83 A8 ; Store accumulator (stack relative) $A8.b,S [Reads: Accumulator, Stack Pointer]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	adc [$CC.b]		; 67 CC ; Add with carry (long) [$CC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($A6.b,S),Y		; 73 A6 ; Add with carry (stack relative indirect indexed) ($A6.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $7CA3.w,Y		; 79 A3 7C ; Add $7CA3.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ldx $37.b,Y		; B6 37 ; Load X register $37.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	sta ($0F.b,X)		; 81 0F ; Store accumulator ($0F.b,X) [Reads: Accumulator, X Index, Direct Page]
	sbc $0E0025.l,X		; FF 25 00 0E ; Subtract with carry (long,X) $0E0025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $F635.w		; ED 35 F6 ; Subtract $F635.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta [$7F.b]		; 87 7F ; Store accumulator (long) [$7F.b] [Reads: Accumulator, Direct Page]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	adc $FF2280.l,X		; 7F 80 22 FF ; Add long $FF2280.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($08.b),Y		; 11 08 ; OR accumulator with memory ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cmp $3B.b		; C5 3B ; Compare $3B.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	adc ($DD.b,X)		; 61 DD ; Add with carry ($DD.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sta ($1F.b),Y		; 91 1F ; Store accumulator ($1F.b),Y [Reads: Accumulator, Direct Page, Y Index]
	ldy #$31.b		; A0 31 ; Load #$31.b into Y register [Writes: Y Index] [Flags: ZN]
	dec $60.b		; C6 60 ; Decrement $60.b [Reads: Direct Page] [Flags: ZN]
	cmp ($30.b,S),Y		; D3 30 ; Compare accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	sbc #$18.b		; E9 18 ; Subtract #$18.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $4E60.w,X		; 3E 60 4E ; Rotate left $4E60.w,X [Reads: X Index] [Flags: ZNC]
	ora $05070F.l,X		; 1F 0F 07 05 ; Logical OR long $05070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $FB.b		; 06 FB ; Arithmetic shift left $FB.b [Reads: Direct Page] [Flags: ZNC]
	jsr ($F807.w,X)		; FC 07 F8 ; Jump to subroutine indirect indexed ($F807.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FF02.w,X		; FD 02 FF ; Subtract with carry $FF02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $F3.b		; 06 F3 ; Arithmetic shift left $F3.b [Reads: Direct Page] [Flags: ZNC]
	sbc ($F1.b)		; F2 F1 ; Subtract with carry (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cop $E5.b		; 02 E5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $FC0C.w		; 0C 0C FC ; Test and set bits $FC0C.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $FF56.w,X		; FE 56 FF ; Increment memory $FF56.w,X [Reads: X Index] [Flags: ZN]
	eor $DF.b,S		; 43 DF ; Exclusive OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $62, $EF, $70		; 62 EF 70 ; Push effective relative address $62, $EF, $70 [Writes: Stack Pointer]
	sbc [$78.b],Y		; F7 78 ; Subtract with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $AA.b		; 85 AA ; Store accumulator to $AA.b [Reads: Accumulator]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $070F1F.l,X		; 1F 1F 0F 07 ; Logical OR long $070F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc ($5E.b,X)		; E1 5E ; Subtract with carry ($5E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
.INDEX 8
	sep #$5C		; E2 5C
	sbc $59.b		; E5 59 ; Subtract $59.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	eor ($F7.b,S),Y		; 53 F7 ; XOR accumulator (stack relative indirect indexed) ($F7.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor [$FF.b]		; 47 FF ; Exclusive OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $E3.b,S		; 83 E3 ; Store accumulator (stack relative) $E3.b,S [Reads: Accumulator, Stack Pointer]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	jsl $1F4300.l		; 22 00 43 1F ; Jump to subroutine long $1F4300.l [Writes: Stack Pointer] [Flow: call]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7F4300.l,X		; 3F 00 43 7F ; AND accumulator with memory (long,X) $7F4300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $28FF00.l,X		; FF 00 FF 28 ; Subtract with carry (long,X) $28FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3F431F.l,X		; FF 1F 43 3F ; Subtract with carry (long,X) $3F431F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF7F02.l,X		; FF 02 7F FF ; Subtract with carry (long,X) $FF7F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $27FF23.l,X		; 7F 23 FF 27 ; Add long $27FF23.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $67.b,X		; B5 67 ; Load $67.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy $6C.b,X		; B4 6C ; Load Y register $6C.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	adc [$A7.b],Y		; 77 A7 ; Add with carry (long indexed) [$A7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sta $90835F.l,X		; 9F 5F 83 90 ; Store accumulator (long,X) $90835F.l,X [Reads: Accumulator, X Index]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $4F00.w		; 20 00 4F ; Jump to subroutine at $4F00.w [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $003F00.l,X		; FF 00 3F 00 ; Subtract with carry (long,X) $003F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $300300.l		; 0F 00 03 30 ; OR accumulator with memory (long) $300300.l [Writes: Accumulator] [Flags: ZN]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $D28400.l,X		; FF 00 84 D2 ; Subtract with carry (long,X) $D28400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $28.b		; 05 28 ; Logical OR $28.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $4D.b		; 00 4D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$67.b],Y		; F7 67 ; Subtract with carry (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $EF.b		; 26 EF ; Rotate left $EF.b [Reads: Direct Page] [Flags: ZNC]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F246F6.l,X		; FF F6 46 F2 ; Subtract with carry (long,X) $F246F6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $260700.l,X		; FF 00 07 26 ; Subtract with carry (long,X) $260700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $49		; F0 49 ; Branch if equal to $F0, $49 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $FF7004.l,X		; FF 04 70 FF ; Subtract with carry (long,X) $FF7004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $2300FF.l,X		; 7F FF 00 23 ; Add long $2300FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $22E000.l		; EF 00 E0 22 ; Subtract with carry (long) $22E000.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $4B0F00.l,X		; FF 00 0F 4B ; Subtract with carry (long,X) $4B0F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F72300.l,X		; FF 00 23 F7 ; Subtract with carry (long,X) $F72300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F74B60.l,X		; FF 60 4B F7 ; Subtract with carry (long,X) $F74B60.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$01.b]		; 67 01 ; Add with carry (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $EF25E0.l,X		; FF E0 25 EF ; Subtract with carry (long,X) $EF25E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $4C.b		; 06 4C ; Arithmetic shift left $4C.b [Reads: Direct Page] [Flags: ZNC]
	sbc $0700F6.l,X		; FF F6 00 07 ; Subtract with carry (long,X) $0700F6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $F7.b		; 26 F7 ; Rotate left $F7.b [Reads: Direct Page] [Flags: ZNC]
	ora ($67.b,X)		; 01 67 ; Logical OR ($67.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $F0, $47		; F0 47 ; Branch if equal to $F0, $47 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $FF7F43.l,X		; FF 43 7F FF ; Subtract with carry (long,X) $FF7F43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $EF.b,S		; 23 EF ; AND accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($F6.b,X)		; 01 F6 ; Logical OR ($F6.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $FF0647.l		; 0F 47 06 FF ; OR accumulator with memory (long) $FF0647.l [Writes: Accumulator] [Flags: ZN]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $230000.l,X		; FF 00 00 23 ; Subtract with carry (long,X) $230000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $FF0004.l,X		; FF 04 00 FF ; Subtract with carry (long,X) $FF0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $4960FF.l,X		; 7F FF 60 49 ; Add long $4960FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$67.b],Y		; F7 67 ; Subtract with carry (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $EF24E0.l,X		; FF E0 24 EF ; Subtract with carry (long,X) $EF24E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $06FF.w,X		; FE FF 06 ; Increment memory $06FF.w,X [Reads: X Index] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $FF01F6.l,X		; FF F6 01 FF ; Subtract with carry (long,X) $FF01F6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$25.b]		; 07 25 ; OR accumulator with memory (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc [$03.b],Y		; F7 03 ; Subtract with carry (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$F7.b]		; 67 F7 ; Add with carry (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc [$F0.b]		; 67 F0 ; Add with carry (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $60.b		; 45 60 ; Exclusive OR $60.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $FF7F43.l,X		; FF 43 7F FF ; Subtract with carry (long,X) $FF7F43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $EF.b,S		; 23 EF ; AND accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $F6.b,S		; 03 F6 ; OR accumulator with stack relative $F6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $450FF6.l,X		; FF F6 0F 45 ; Subtract with carry (long,X) $450FF6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: ZNC]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $230000.l,X		; FF 00 00 23 ; Subtract with carry (long,X) $230000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $440000.l,X		; FF 00 00 44 ; Subtract with carry (long,X) $440000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $60007F.l,X		; FF 7F 00 60 ; Subtract with carry (long,X) $60007F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor [$FF.b]		; 47 FF ; Exclusive OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $00FF28.l		; 6F 28 FF 00 ; Add with carry (long) $00FF28.l [Writes: Accumulator] [Flags: ZVNC]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0600FE.l,X		; FF FE 00 06 ; Subtract with carry (long,X) $0600FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor [$FF.b]		; 47 FF ; Exclusive OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $28.b,X		; F6 28 ; Increment memory $28.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $FF6F47.l,X		; FF 47 6F FF ; Subtract with carry (long,X) $FF6F47.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7F,$FF		; 44 FF 7F ; Move block positive $7F,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc $FFF647.l,X		; FF 47 F6 FF ; Subtract with carry (long,X) $FFF647.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FE,$FF		; 44 FF FE ; Move block positive $FE,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc $4D0000.l,X		; FF 00 00 4D ; Subtract with carry (long,X) $4D0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$67.b],Y		; F7 67 ; Subtract with carry (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $EF.b		; 26 EF ; Rotate left $EF.b [Reads: Direct Page] [Flags: ZNC]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F246F6.l,X		; FF F6 46 F2 ; Subtract with carry (long,X) $F246F6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $260700.l,X		; FF 00 07 26 ; Subtract with carry (long,X) $260700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $49		; F0 49 ; Branch if equal to $F0, $49 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $003B84.l,X		; FF 84 3B 00 ; Subtract with carry (long,X) $003B84.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $EF.b,S		; 23 EF ; AND accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0F00FF.l		; 22 FF 00 0F ; Jump to subroutine long $0F00FF.l [Writes: Stack Pointer] [Flow: call]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F72300.l,X		; FF 00 23 F7 ; Subtract with carry (long,X) $F72300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7F,$FF		; 44 FF 7F ; Move block positive $7F,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$FF.b]		; 47 FF ; Exclusive OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $00FF28.l		; 6F 28 FF 00 ; Add with carry (long) $00FF28.l [Writes: Accumulator] [Flags: ZVNC]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0600FE.l,X		; FF FE 00 06 ; Subtract with carry (long,X) $0600FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor [$FF.b]		; 47 FF ; Exclusive OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $28.b,X		; F6 28 ; Increment memory $28.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $FF6F47.l,X		; FF 47 6F FF ; Subtract with carry (long,X) $FF6F47.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7F,$FF		; 44 FF 7F ; Move block positive $7F,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc $FFF647.l,X		; FF 47 F6 FF ; Subtract with carry (long,X) $FFF647.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FE,$FF		; 44 FF FE ; Move block positive $FE,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc $FF0004.l,X		; FF 04 00 FF ; Subtract with carry (long,X) $FF0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $4320FF.l,X		; 1F FF 20 43 ; Logical OR long $4320FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FB0A40.l,X		; FF 40 0A FB ; Subtract with carry (long,X) $FB0A40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor [$F4.b]		; 47 F4 ; Exclusive OR accumulator with memory (long) [$F4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $C05FE8.l		; 4F E8 5F C0 ; Exclusive OR accumulator with memory (long) $C05FE8.l [Writes: Accumulator] [Flags: ZN]
	lda $60707F.l,X		; BF 7F 70 60 ; Load long $60707F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $E80F40.l		; 22 40 0F E8 ; Jump to subroutine long $E80F40.l [Writes: Stack Pointer] [Flow: call]
	eor $EA5BEC.l,X		; 5F EC 5B EA ; Exclusive OR accumulator with memory (long,X) $EA5BEC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $5FE8.w,X		; 5D E8 5F ; Exclusive OR accumulator with memory $5FE8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	pea $FF4F.w		; F4 4F FF ; Push absolute address $FF4F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jsr $1FFF.w		; 20 FF 1F ; Jump to subroutine at $1FFF.w [Writes: Stack Pointer] [Flow: call]
	sbc $402300.l,X		; FF 00 23 40 ; Subtract with carry (long,X) $402300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $BF		; 70 BF ; Branch if overflow set to $70, $BF [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $13C757.l,X		; FF 57 C7 13 ; Subtract with carry (long,X) $13C757.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	.db $30, $CC		; 30 CC ; Branch if minus to $30, $CC [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$18.b]		; C7 18 ; Compare accumulator (long) [$18.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	lda [$4C.b]		; A7 4C ; Load accumulator (long) [$4C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp ($6F.b,S),Y		; D3 6F ; Compare accumulator (stack relative indirect indexed) ($6F.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	mvp $00,$03		; 44 03 00 ; Move block positive $00,$03 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $0010.w		; 20 10 00 ; Jump to subroutine at $0010.w [Writes: Stack Pointer] [Flow: call]
	sbc $11CBD3.l,X		; FF D3 CB 11 ; Subtract with carry (long,X) $11CBD3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $EE10.w		; 2D 10 EE ; Logical AND $EE10.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cmp [$C4.b]		; C7 C4 ; Compare accumulator (long) [$C4.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C2.b		; 24 C2 ; Test bits $C2.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($54E0.w)		; 6C E0 54 ; Jump indirect to ($54E0.w) [Flow: jump]
	cld		; D8 ; Clear decimal flag [Flags: D]
	bit $B8.b		; 24 B8 ; Test bits $B8.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	eor $E418F0.l		; 4F F0 18 E4 ; Exclusive OR accumulator with memory (long) $E418F0.l [Writes: Accumulator] [Flags: ZN]
	adc ($CB.b,S),Y		; 73 CB ; Add with carry (stack relative indirect indexed) ($CB.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$F7.b]		; 67 F7 ; Add with carry (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora #$C3.b		; 09 C3 ; Logical OR #$C3.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $98.b,S		; 43 98 ; Exclusive OR accumulator with stack relative $98.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldy $C3.b		; A4 C3 ; Load $C3.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $80.b,X		; 15 80 ; OR accumulator with memory $80.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $24.b,S		; 43 24 ; Exclusive OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	.db $B0, $08		; B0 08 ; Branch if carry set to $B0, $08 [Flow: branch]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	.db $80, $50		; 80 50 ; Branch always to $80, $50 [Flow: branch]
	cpy #$20.b		; C0 20 ; Compare #$20.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($40.b,X)		; 01 40 ; Logical OR ($40.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr $0025.w		; 20 25 00 ; Jump to subroutine at $0025.w [Writes: Stack Pointer] [Flow: call]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $1343.w		; 0C 43 13 ; Test and set bits $1343.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $0403.w		; 0C 03 04 ; Test and set bits $0403.w [Reads: Accumulator] [Flags: Z]
	tsb $C0.b		; 04 C0 ; Test and set bits $C0.b [Reads: Accumulator] [Flags: Z]
	cpy #$90.b		; C0 90 ; Compare #$90.b with Y register [Reads: Y Index] [Flags: ZNC]
	sta $27BF20.l,X		; 9F 20 BF 27 ; Store accumulator (long,X) $27BF20.l,X [Reads: Accumulator, X Index]
	clv		; B8 ; Clear overflow flag [Flags: V]
	and $2F45B3.l		; 2F B3 45 2F ; AND accumulator with memory (long) $2F45B3.l [Writes: Accumulator] [Flags: ZN]
	ldy $01.b,X		; B4 01 ; Load Y register $01.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	and $402560.l,X		; 3F 60 25 40 ; AND accumulator with memory (long,X) $402560.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $AA.b,X		; 55 AA ; Exclusive OR accumulator with memory $AA.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $43.b,X		; 55 43 ; Exclusive OR accumulator with memory $43.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldx $011C.w,Y		; BE 1C 01 ; Load X register $011C.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ldx #$1C.b		; A2 1C ; Load #$1C.b into X register [Writes: X Index] [Flags: ZN]
	sta $1A.b,S		; 83 1A ; Store accumulator (stack relative) $1A.b,S [Reads: Accumulator, Stack Pointer]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $41.b,S		; 23 41 ; AND accumulator with stack relative $41.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $49.b		; 04 49 ; Test and set bits $49.b [Reads: Accumulator] [Flags: Z]
	eor ($FF.b,X)		; 41 FF ; Exclusive OR accumulator with memory ($FF.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $BF00.w		; 4C 00 BF ; Jump to $BF00.w [Flow: jump]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $114023.l,X		; 7F 23 40 11 ; Add long $114023.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $807F5F.l,X		; 5F 5F 7F 80 ; Exclusive OR accumulator with memory (long,X) $807F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	.db $B0, $7F		; B0 7F ; Branch if carry set to $B0, $7F [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc $8E7F9C.l,X		; 7F 9C 7F 8E ; Add long $8E7F9C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $827F87.l,X		; 7F 87 7F 82 ; Add long $827F87.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $0026.w,X		; 7E 26 00 ; Rotate right $0026.w,X [Reads: X Index] [Flags: ZNC]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004A00.l,X		; FF 00 4A 00 ; Subtract with carry (long,X) $004A00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $27FF22.l,X		; FF 22 FF 27 ; Subtract with carry (long,X) $27FF22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E0453F.l,X		; FF 3F 45 E0 ; Subtract with carry (long,X) $E0453F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $FF08.w		; 20 08 FF ; Jump to subroutine at $FF08.w [Writes: Stack Pointer] [Flow: call]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	adc $DF22C0.l,X		; 7F C0 22 DF ; Add long $DF22C0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $007FFF.l,X		; FF FF 7F 00 ; Subtract with carry (long,X) $007FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$9A.b]		; E7 9A ; Subtract with carry (long) [$9A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda $4000.w,X		; BD 00 40 ; Load $4000.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $AD40.w,X		; 9D 40 AD ; Store accumulator to $AD40.w,X [Reads: Accumulator, X Index]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $88		; 80 88 ; Branch always to $80, $88 [Flow: branch]
	sbc $1B.b,S		; E3 1B ; Subtract stack-relative $1B.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp $3B.b,S		; C3 3B ; Compare accumulator (stack relative) $3B.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $770012.l		; 22 12 00 77 ; Jump to subroutine long $770012.l [Writes: Stack Pointer] [Flow: call]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	lsr $007F.w		; 4E 7F 00 ; Logical shift right $007F.w [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F4300.l,X		; 1F 00 43 3F ; Logical OR long $3F4300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $68E400.l,X		; 7F 00 E4 68 ; Add long $68E400.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7FFE00.l,X		; FF 00 FE 7F ; Subtract with carry (long,X) $7FFE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FB7F.w,X		; FD 7F FB ; Subtract with carry $FB7F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $BF7F87.l,X		; 7F 87 7F BF ; Add long $BF7F87.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $EF7FDF.l,X		; 7F DF 7F EF ; Add long $EF7FDF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $170027.l,X		; 7F 27 00 17 ; Add long $170027.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7EFF00.l,X		; FF 00 FF 7E ; Subtract with carry (long,X) $7EFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7BFE7D.l,X		; FF 7D FE 7B ; Subtract with carry (long,X) $7BFE7D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F807.w,X)		; FC 07 F8 ; Jump to subroutine indirect indexed ($F807.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $F25CF0.l,X		; 3F F0 5C F2 ; AND accumulator with memory (long,X) $F25CF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($0000.w)		; 6C 00 00 ; Jump indirect to ($0000.w) [Flow: jump]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $FF4E0D.l,X		; 1F 0D 4E FF ; Logical OR long $FF4E0D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $B32F.w		; 2E 2F B3 ; Rotate left $B32F.w [Flags: ZNC]
	.db $10, $9F		; 10 9F ; Branch if plus to $10, $9F [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $4FFF06.l,X		; FF 06 FF 4F ; Subtract with carry (long,X) $4FFF06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $A639.w,Y		; D9 39 A6 ; Compare accumulator $A639.w,Y [Reads: Y Index] [Flags: ZNC]
	sbc $6040C0.l,X		; FF C0 40 60 ; Subtract with carry (long,X) $6040C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $200000.l,X		; 3F 00 00 20 ; AND accumulator with memory (long,X) $200000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $41BE.w,X		; 5D BE 41 ; Exclusive OR accumulator with memory $41BE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $7C		; 80 7C ; Branch always to $80, $7C [Flow: branch]
	sbc $A402.w,X		; FD 02 A4 ; Subtract with carry $A402.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	lda $7F8040.l,X		; BF 40 80 7F ; Load long $7F8040.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $414100.l,X		; FF 00 41 41 ; Subtract with carry (long,X) $414100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $404302.l,X		; 7F 02 43 40 ; Add long $404302.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $BF0044.l,X		; 7F 44 00 BF ; Add long $BF0044.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $A0		; 42 A0 ; Reserved instruction
	eor $04A285.l,X		; 5F 85 A2 04 ; Exclusive OR accumulator with memory (long,X) $04A285.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $5F.b,S		; 03 5F ; OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $83427F.l,X		; 5F 7F 42 83 ; Exclusive OR accumulator with memory (long,X) $83427F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldy $4F04.w		; AC 04 4F ; Load $4F04.w into Y register [Writes: Y Index] [Flags: ZN]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Accumulator, X Index, Direct Page]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FFFF01.l,X		; 3F 01 FF FF ; AND accumulator with memory (long,X) $FFFF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $C0.b		; 25 C0 ; Logical AND $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$39.b		; E0 39 ; Compare #$39.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	sbc $6F9300.l,X		; FF 00 93 6F ; Subtract with carry (long,X) $6F9300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $5C.b		; E4 5C ; Compare $5C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	ora $18A9.w,Y		; 19 A9 18 ; OR accumulator with memory $18A9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	pei ($4D.b)		; D4 4D ; Push effective indirect address ($4D.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	ror $3F.b		; 66 3F ; Rotate right $3F.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $46.b,S		; 03 46 ; OR accumulator with stack relative $46.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $22.b		; 46 22 ; Logical shift right $22.b [Reads: Direct Page] [Flags: ZNC]
	ora ($83.b),Y		; 11 83 ; OR accumulator with memory ($83.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	cpx #$18.b		; E0 18 ; Compare #$18.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $C0AF40.l,X		; BF 40 AF C0 ; Load long $C0AF40.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $1DA0.w,X		; 1D A0 1D ; OR accumulator with memory $1DA0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $C780.w,X		; FD 80 C7 ; Subtract with carry $C780.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	stz $07.b,X		; 74 07 ; Store zero to $07.b,X [Reads: X Index]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000242.l		; 22 42 02 00 ; Jump to subroutine long $000242.l [Writes: Stack Pointer] [Flow: call]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cop $F5.b		; 02 F5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $9665.w		; 0C 65 96 ; Test and set bits $9665.w [Reads: Accumulator] [Flags: Z]
	eor $F3.b,S		; 43 F3 ; Exclusive OR accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora #$63.b		; 09 63 ; Logical OR #$63.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sta ($F8.b)		; 92 F8 ; Store accumulator (indirect) ($F8.b) [Reads: Accumulator, Direct Page]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $68		; F0 68 ; Branch if equal to $F0, $68 [Flow: branch]
	stz $04.b		; 64 04 ; Store zero to $04.b
	tsb $D343.w		; 0C 43 D3 ; Test and set bits $D343.w [Reads: Accumulator] [Flags: Z]
	trb $D706.w		; 1C 06 D7 ; Test and reset bits $D706.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	cmp $1FC010.l,X		; DF 10 C0 1F ; Compare accumulator (long,X) $1FC010.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	cpy #$44.b		; C0 44 ; Compare #$44.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $20.b		; 24 20 ; Test bits $20.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004300.l,X		; FF 00 43 00 ; Subtract with carry (long,X) $004300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E00025.l,X		; FF 25 00 E0 ; Subtract with carry (long,X) $E00025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($FF.b),Y		; 31 FF ; AND accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $F764.w,X		; BC 64 F7 ; Load Y register $F764.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	eor $86.b,S		; 43 86 ; Exclusive OR accumulator with stack relative $86.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $62C3.w,X		; 1D C3 62 ; OR accumulator with memory $62C3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$20.b]		; C7 20 ; Compare accumulator (long) [$20.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	.db $70, $90		; 70 90 ; Branch if overflow set to $70, $90 [Flow: branch]
	and [$CF.b],Y		; 37 CF ; AND accumulator with memory (long indexed) [$CF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $381300.l,X		; FF 00 13 38 ; Subtract with carry (long,X) $381300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $0F1F.w		; 1C 1F 0F ; Test and reset bits $0F1F.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $F8E5.w		; 0C E5 F8 ; Test and set bits $F8E5.w [Reads: Accumulator] [Flags: Z]
	ora $F3E0.w,Y		; 19 E0 F3 ; OR accumulator with memory $F3E0.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($E5.b)		; 12 E5 ; OR accumulator with memory (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: ZNC]
	ora $FBE4.w		; 0D E4 FB ; Logical OR $FBE4.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $02F000.l,X		; FF 00 F0 02 ; Subtract with carry (long,X) $02F000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	eor $23FF00.l		; 4F 00 FF 23 ; Exclusive OR accumulator with memory (long) $23FF00.l [Writes: Accumulator] [Flags: ZN]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $01FE43.l,X		; FF 43 FE 01 ; Subtract with carry (long,X) $01FE43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $2701.w,X		; FE 01 27 ; Increment memory $2701.w,X [Reads: X Index] [Flags: ZN]
	ora $00FF4E.l,X		; 1F 4E FF 00 ; Logical OR long $00FF4E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $1F.b		; 24 1F ; Test bits $1F.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	eor $2200FF.l		; 4F FF 00 22 ; Exclusive OR accumulator with memory (long) $2200FF.l [Writes: Accumulator] [Flags: ZN]
	ora $FFFF24.l,X		; 1F 24 FF FF ; Logical OR long $FFFF24.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $030001.l		; 0F 01 00 03 ; OR accumulator with memory (long) $030001.l [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $03		; Opcode 03 overrunning bank boundry at 08FFFE. Skipping. ; OR accumulator with stack relative $03 [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $6B		; Opcode 6B overrunning bank boundry at 08FFFF. Skipping. ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]
.ENDS
