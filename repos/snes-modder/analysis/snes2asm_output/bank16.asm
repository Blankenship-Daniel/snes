.BANK 16 SLOT 0
.ORG $0000

.SECTION "Bank16" FORCE

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $3804.w		; 0C 04 38 ; Test and set bits $3804.w [Reads: Accumulator] [Flags: Z]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$9E.b],Y		; 17 9E ; OR accumulator with memory (long indexed) [$9E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $38BD.w,X		; 1D BD 38 ; OR accumulator with memory $38BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$68.b]		; 07 68 ; OR accumulator with memory (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$E3.b],Y		; 37 E3 ; AND accumulator with memory (long indexed) [$E3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($78C7.w,X)		; 7C C7 78 ; Jump indirect indexed to ($78C7.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	jmp $CA70.w		; 4C 70 CA ; Jump to $CA70.w [Flow: jump]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	cpx #$61.b		; E0 61 ; Compare #$61.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $86		; 80 86 ; Branch always to $80, $86 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$BC.b		; E0 BC ; Compare #$BC.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$3A.b		; C0 3A ; Compare #$3A.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy $F1.b		; C4 F1 ; Compare $F1.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	asl $1EE1.w		; 0E E1 1E ; Arithmetic shift left $1EE1.w [Flags: ZNC]
	stx $78.b		; 86 78 ; Store X register to $78.b [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $5B06.w		; 0E 06 5B ; Arithmetic shift left $5B06.w [Flags: ZNC]
	ora [$AC.b]		; 07 AC ; OR accumulator with memory (long) [$AC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $A3.b,S		; 03 A3 ; OR accumulator with stack relative $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jmp $10EF03.l		; 5C 03 EF 10 ; Jump long to $10EF03.l [Flow: jump]
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $5E		; 10 5E ; Branch if plus to $10, $5E [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	and $CDC8.w,X		; 3D C8 CD ; AND accumulator with memory $CDC8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E8.b		; C0 E8 ; Compare #$E8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $B6		; F0 B6 ; Branch if equal to $F0, $B6 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $F00D30.l		; CF 30 0D F0 ; Compare accumulator (long) $F00D30.l [Reads: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0C5C03.l		; 0F 03 5C 0C ; OR accumulator with memory (long) $0C5C03.l [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $6AF655.l		; EF 55 F6 6A ; Subtract with carry (long) $6AF655.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $5303.w		; 0C 03 53 ; Test and set bits $5303.w [Reads: Accumulator] [Flags: Z]
	ora $F40FF7.l		; 0F F7 0F F4 ; OR accumulator with memory (long) $F40FF7.l [Writes: Accumulator] [Flags: ZN]
	ora $9D05BA.l		; 0F BA 05 9D ; OR accumulator with memory (long) $9D05BA.l [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$1A.b		; C0 1A ; Compare #$1A.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	.db $F0, $FD		; F0 FD ; Branch if equal to $F0, $FD [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc [$EA.b],Y		; F7 EA ; Subtract with carry (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $000012.l,X		; 3F 12 00 00 ; AND accumulator with memory (long,X) $000012.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	nop		; EA ; No operation
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	.db $F0, $C7		; F0 C7 ; Branch if equal to $F0, $C7 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $CDE0.w,X		; 1D E0 CD ; OR accumulator with memory $CDE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $5B.b		; 06 5B ; Arithmetic shift left $5B.b [Reads: Direct Page] [Flags: ZNC]
	ora [$AC.b]		; 07 AC ; OR accumulator with memory (long) [$AC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $A3.b,S		; 03 A3 ; OR accumulator with stack relative $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jmp $10EF03.l		; 5C 03 EF 10 ; Jump long to $10EF03.l [Flow: jump]
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $5E		; 10 5E ; Branch if plus to $10, $5E [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	and $CDC8.w,X		; 3D C8 CD ; AND accumulator with memory $CDC8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E8.b		; C0 E8 ; Compare #$E8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $B6		; F0 B6 ; Branch if equal to $F0, $B6 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $F00D30.l		; CF 30 0D F0 ; Compare accumulator (long) $F00D30.l [Reads: Accumulator] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $061E07.l		; 0F 07 1E 06 ; OR accumulator with memory (long) $061E07.l [Writes: Accumulator] [Flags: ZN]
	trb $0C.b		; 14 0C ; Test and reset bits $0C.b [Reads: Accumulator] [Flags: Z]
	and ($0F.b,S),Y		; 33 0F ; AND accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($A303.w)		; 6C 03 A3 ; Jump indirect to ($A303.w) [Flow: jump]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$1B.b]		; 07 1B ; OR accumulator with memory (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $6F.b,S		; 03 6F ; OR accumulator with stack relative $6F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $E3		; 10 E3 ; Branch if plus to $10, $E3 [Flow: branch]
	trb $00C0.w		; 1C C0 00 ; Test and reset bits $00C0.w [Reads: Accumulator] [Flags: Z]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $30, $C8		; 30 C8 ; Branch if minus to $30, $C8 [Flow: branch]
	.db $F0, $3E		; F0 3E ; Branch if equal to $F0, $3E [Flow: branch]
	cpy #$C5.b		; C0 C5 ; Compare #$C5.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$90.b		; C0 90 ; Compare #$90.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$B0.b		; E0 B0 ; Compare #$B0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$D8.b		; C0 D8 ; Compare #$D8.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$38.b		; E0 38 ; Compare #$38.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1003.w		; 0C 03 10 ; Test and set bits $1003.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	lda $000004.l		; AF 04 00 00 ; Load long $000004.l into accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $071800.l		; 0F 00 18 07 ; OR accumulator with memory (long) $071800.l [Writes: Accumulator] [Flags: ZN]
	stz $0B.b,X		; 74 0B ; Store zero to $0B.b,X [Reads: X Index]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$08.b		; C0 08 ; Compare #$08.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$2E.b		; E0 2E ; Compare #$2E.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $D7		; D0 D7 ; Branch if not equal to $D0, $D7 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $070F03.l		; 0F 03 0F 07 ; OR accumulator with memory (long) $070F03.l [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$67.b]		; 07 67 ; OR accumulator with memory (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	jsr $1034.w		; 20 34 10 ; Jump to subroutine at $1034.w [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $F6E0.w,X		; 1E E0 F6 ; Arithmetic shift left $F6E0.w,X [Reads: X Index] [Flags: ZNC]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $B0, $EC		; B0 EC ; Branch if carry set to $B0, $EC [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	inc $FC.b		; E6 FC ; Increment $FC.b [Reads: Direct Page] [Flags: ZN]
	inc $F600.w,X		; FE 00 F6 ; Increment memory $F600.w,X [Reads: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor [$B8.b]		; 47 B8 ; Exclusive OR accumulator with memory (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $000010.l		; AF 10 00 00 ; Load long $000010.l into accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $081F03.l		; 0F 03 1F 08 ; OR accumulator with memory (long) $081F03.l [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$54.b]		; 07 54 ; OR accumulator with memory (long) [$54.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	cpx #$2A.b		; E0 2A ; Compare #$2A.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $D7		; D0 D7 ; Branch if not equal to $D0, $D7 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldy $7E30.w,X		; BC 30 7E ; Load Y register $7E30.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	jsl $0B032F.l		; 22 2F 03 0B ; Jump to subroutine long $0B032F.l [Writes: Stack Pointer] [Flow: call]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $5D		; 70 5D ; Branch if overflow set to $70, $5D [Flow: branch]
	jsr $002C.w		; 20 2C 00 ; Jump to subroutine at $002C.w [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $BA.b		; 04 BA ; Test and set bits $BA.b [Reads: Accumulator] [Flags: Z]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $FC.b,X		; 94 FC ; Store Y register $FC.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BA.b		; 00 BA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldx $AF40.w		; AE 40 AF ; Load $AF40.w into X register [Writes: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $183E29.l,X		; 7F 29 3E 18 ; Add long $183E29.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $0704.w		; 0C 04 07 ; Test and set bits $0704.w [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $50		; 10 50 ; Branch if plus to $10, $50 [Flow: branch]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $7C.b,X		; 94 7C ; Store Y register $7C.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	jsr $80E0.w		; 20 E0 80 ; Jump to subroutine at $80E0.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $08.b,X		; F5 08 ; Subtract $08.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $6F.b		; 65 6F ; Add $6F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($6F.b,X)		; 01 6F ; Logical OR ($6F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	trb $0E11.w		; 1C 11 0E ; Test and reset bits $0E11.w [Reads: Accumulator] [Flags: Z]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $9A.b,Y		; 96 9A ; Store X register $9A.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	.db $90, $D4		; 90 D4 ; Branch if carry clear to $90, $D4 [Flow: branch]
	cpy #$D8.b		; C0 D8 ; Compare #$D8.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$D0.b		; C0 D0 ; Compare #$D0.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc #$F0.b		; 69 F0 ; Add #$F0.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pea $E834.w		; F4 34 E8 ; Push absolute address $E834.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx #$B0.b		; E0 B0 ; Compare #$B0.b with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $297F40.l		; EF 40 7F 29 ; Subtract with carry (long) $297F40.l [Writes: Accumulator] [Flags: ZVNC]
	rol $1A18.w,X		; 3E 18 1A ; Rotate left $1A18.w,X [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0705.w		; 0D 05 07 ; Logical OR $0705.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $50		; 10 50 ; Branch if plus to $10, $50 [Flow: branch]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $7C.b,X		; 94 7C ; Store Y register $7C.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $10, $B0		; 10 B0 ; Branch if plus to $10, $B0 [Flow: branch]
	ldy #$E0.b		; A0 E0 ; Load #$E0.b into Y register [Writes: Y Index] [Flags: ZN]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cmp $397F48.l,X		; DF 48 7F 39 ; Compare accumulator (long,X) $397F48.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	rol $1A18.w,X		; 3E 18 1A ; Rotate left $1A18.w,X [Reads: X Index] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$B7.b],Y		; 17 B7 ; OR accumulator with memory (long indexed) [$B7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FE.b)		; 12 FE ; OR accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stz $187C.w		; 9C 7C 18 ; Store zero to $187C.w
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sbc $0200.w		; ED 00 02 ; Subtract $0200.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ror $20.b		; 66 20 ; Rotate right $20.b [Reads: Direct Page] [Flags: ZNC]
	adc [$31.b],Y		; 77 31 ; Add with carry (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $1F19.w,Y		; 39 19 1F ; AND accumulator with memory $1F19.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($66.b)		; 12 66 ; OR accumulator with memory (indirect) ($66.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $E6.b		; 04 E6 ; Test and set bits $E6.b [Reads: Accumulator] [Flags: Z]
	sty $8C.b		; 84 8C ; Store Y register to $8C.b [Reads: Y Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $90, $F0		; 90 F0 ; Branch if carry clear to $90, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $397F6F.l,X		; FF 6F 7F 39 ; Subtract with carry (long,X) $397F6F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FF0E.w,X		; FE 0E FF ; Increment memory $FF0E.w,X [Reads: X Index] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $90		; 10 90 ; Branch if plus to $10, $90 [Flow: branch]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 8
.INDEX 8
	sep #$BF		; E2 BF
	ldx $7E.b,Y		; B6 7E ; Load X register $7E.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	trb $000E.w		; 1C 0E 00 ; Test and reset bits $000E.w [Reads: Accumulator] [Flags: Z]
	sbc $001F00.l,X		; FF 00 1F 00 ; Subtract with carry (long,X) $001F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor #$00.b		; 49 00 ; Exclusive OR #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sep #$00		; E2 00 ; Set processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: ZN]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	asl $000E.w		; 0E 0E 00 ; Arithmetic shift left $000E.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $78FE29.l,X		; BF 29 FE 78 ; Load long $78FE29.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $14.b,X		; 76 14 ; Rotate right $14.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $070F0F.l,X		; 1F 0F 0F 07 ; Logical OR long $070F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $7F.b,X		; 94 7F ; Store Y register $7F.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	asl $084E.w,X		; 1E 4E 08 ; Arithmetic shift left $084E.w,X [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: ZNC]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: ZNC]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $EC.b		; 04 EC ; Test and set bits $EC.b [Reads: Accumulator] [Flags: Z]
	.db $10, $5C		; 10 5C ; Branch if plus to $10, $5C [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $84		; 10 84 ; Branch if plus to $10, $84 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy $00B0.w		; CC B0 00 ; Compare $00B0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	asl $1D.b		; 06 1D ; Arithmetic shift left $1D.b [Reads: Direct Page] [Flags: ZNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$7C.b		; C0 7C ; Compare #$7C.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $CE.b		; 04 CE ; Test and set bits $CE.b [Reads: Accumulator] [Flags: Z]
	trb $E4.b		; 14 E4 ; Test and reset bits $E4.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	pea $FCC8.w		; F4 C8 FC ; Push absolute address $FCC8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $3D.b		; 02 3D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $55.b		; 02 55 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	bit $7403.w,X		; 3C 03 74 ; Test bits $7403.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $BC.b		; 04 BC ; Test and set bits $BC.b [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	stz $9F60.w,X		; 9E 60 9F ; Store zero to $9F60.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $FE		; 50 FE ; Branch if overflow clear to $50, $FE [Flow: branch]
	jmp ($6CFF.w)		; 6C FF 6C ; Jump indirect to ($6CFF.w) [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $40BC.w		; 20 BC 40 ; Jump to subroutine at $40BC.w [Writes: Stack Pointer] [Flow: call]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	stz $FC.b		; 64 FC ; Store zero to $FC.b
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	jmp $F06FF0.l		; 5C F0 6F F0 ; Jump long to $F06FF0.l [Flow: jump]
	eor $000000.l		; 4F 00 00 00 ; Exclusive OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3D.b		; 04 3D ; Test and set bits $3D.b [Reads: Accumulator] [Flags: Z]
	cop $D9.b		; 02 D9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $1F.b		; 26 1F ; Rotate left $1F.b [Reads: Direct Page] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3A07.w		; 0C 07 3A ; Test and set bits $3A07.w [Reads: Accumulator] [Flags: Z]
	ora $F20FF6.l		; 0F F6 0F F2 ; OR accumulator with memory (long) $F20FF6.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $40BC.w		; 20 BC 40 ; Jump to subroutine at $40BC.w [Writes: Stack Pointer] [Flow: call]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	adc $DC.b		; 65 DC ; Add $DC.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	jmp $F06FF0.l		; 5C F0 6F F0 ; Jump long to $F06FF0.l [Flow: jump]
	and $000000.l		; 2F 00 00 00 ; AND accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3D.b		; 04 3D ; Test and set bits $3D.b [Reads: Accumulator] [Flags: Z]
	cop $39.b		; 02 39 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $7B.b		; C6 7B ; Decrement $7B.b [Reads: Direct Page] [Flags: ZN]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3A07.w		; 0C 07 3A ; Test and set bits $3A07.w [Reads: Accumulator] [Flags: Z]
	ora $F40FF6.l		; 0F F6 0F F4 ; OR accumulator with memory (long) $F40FF6.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $DC		; 70 DC ; Branch if overflow set to $70, $DC [Flow: branch]
	jsr $05FA.w		; 20 FA 05 ; Jump to subroutine at $05FA.w [Writes: Stack Pointer] [Flow: call]
	jmp ($2E03.w,X)		; 7C 03 2E ; Jump indirect indexed to ($2E03.w,X) [Reads: X Index] [Flow: jump]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	bit $4FF0.w		; 2C F0 4F ; Test bits $4FF0.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $000F20.l,X		; 1F 20 0F 00 ; Logical OR long $000F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $39.b		; 06 39 ; Arithmetic shift left $39.b [Reads: Direct Page] [Flags: ZNC]
	dec $7D.b		; C6 7D ; Decrement $7D.b [Reads: Direct Page] [Flags: ZN]
	.db $82, $7E, $80		; 82 7E 80 ; Branch always long to $82, $7E, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	ora $E61F36.l		; 0F 36 1F E6 ; OR accumulator with memory (long) $E61F36.l [Writes: Accumulator] [Flags: ZN]
	and $D83EDA.l,X		; 3F DA 3E D8 ; AND accumulator with memory (long,X) $D83EDA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $649B.w		; 20 9B 64 ; Jump to subroutine at $649B.w [Writes: Stack Pointer] [Flow: call]
	stz $FC63.w		; 9C 63 FC ; Store zero to $FC63.w
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $70, $2C		; 70 2C ; Branch if overflow set to $70, $2C [Flow: branch]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3900.w,X		; 1E 00 39 ; Arithmetic shift left $3900.w,X [Reads: X Index] [Flags: ZNC]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: ZNC]
	asl $1A.b		; 06 1A ; Arithmetic shift left $1A.b [Reads: Direct Page] [Flags: ZNC]
	cpx $1C.b		; E4 1C ; Compare $1C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $F60F36.l		; 0F 36 0F F6 ; OR accumulator with memory (long) $F60F36.l [Writes: Accumulator] [Flags: ZN]
	asl $04F4.w		; 0E F4 04 ; Arithmetic shift left $04F4.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $3402.w,X		; 1E 02 34 ; Arithmetic shift left $3402.w,X [Reads: X Index] [Flags: ZNC]
	trb $3F.b		; 14 3F ; Test and reset bits $3F.b [Reads: Accumulator] [Flags: Z]
	ora [$5C.b]		; 07 5C ; OR accumulator with memory (long) [$5C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00045B.l		; 0F 5B 04 00 ; OR accumulator with memory (long) $00045B.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2B.b,S		; 03 2B ; OR accumulator with stack relative $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $730738.l,X		; 1F 38 07 73 ; Logical OR long $730738.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $007F.w		; 0C 7F 00 ; Test and set bits $007F.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	stz $60.b,X		; 74 60 ; Store zero to $60.b,X [Reads: X Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $30, $16		; 30 16 ; Branch if minus to $30, $16 [Flow: branch]
	cpx #$62.b		; E0 62 ; Compare #$62.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $86		; 80 86 ; Branch always to $80, $86 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$FE.b		; E0 FE ; Compare #$FE.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$F6.b		; C0 F6 ; Compare #$F6.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
.INDEX 8
	sep #$1C		; E2 1C
	stx $78.b		; 86 78 ; Store X register to $78.b [Reads: X Index]
	asl $09.b,X		; 16 09 ; Arithmetic shift left $09.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora #$0B.b		; 09 0B ; Logical OR #$0B.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpx $F810.w		; EC 10 F8 ; Compare $F810.w with X register [Reads: X Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C020.w		; 20 20 C0 ; Jump to subroutine at $C020.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($A0.b)		; D4 A0 ; Push effective indirect address ($A0.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cpx $C8.b		; E4 C8 ; Compare $C8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $D0, $F0		; D0 F0 ; Branch if not equal to $D0, $F0 [Flow: branch]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $3E06.w,Y		; 39 06 3E ; AND accumulator with memory $3E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $30, $65		; 30 65 ; Branch if minus to $30, $65 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	stz $18.b		; 64 18 ; Store zero to $18.b
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$38.b		; 09 38 ; Logical OR #$38.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $7E.b		; 06 7E ; Arithmetic shift left $7E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($7D.b,X)		; 01 7D ; Logical OR ($7D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $72.b,X		; 74 72 ; Store zero to $72.b,X [Reads: X Index]
	sty $502C.w		; 8C 2C 50 ; Store Y register to $502C.w [Reads: Y Index]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $BE.b		; 66 BE ; Rotate right $BE.b [Reads: Direct Page] [Flags: ZNC]
	adc ($6F.b,X)		; 61 6F ; Add with carry ($6F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$F8.b		; 09 F8 ; Logical OR #$F8.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $6C.b		; 06 6C ; Arithmetic shift left $6C.b [Reads: Direct Page] [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $FE.b		; C4 FE ; Compare $FE.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $0F		; 80 0F ; Branch always to $80, $0F [Flow: branch]
	.db $30, $3E		; 30 3E ; Branch if minus to $30, $3E [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($F2.b,X)		; 01 F2 ; Logical OR ($F2.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $037C.w		; 0D 7C 03 ; Logical OR $037C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $0C1710.l,X		; 3F 10 17 0C ; AND accumulator with memory (long,X) $0C1710.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $7050E2.l		; 6F E2 50 70 ; Add with carry (long) $7050E2.l [Writes: Accumulator] [Flags: ZVNC]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000E00.l,X		; 1F 00 0E 00 ; Logical OR long $000E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $B04F80.l,X		; 7F 80 4F B0 ; Add long $B04F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $FCC0.w,X		; 3E C0 FC ; Rotate left $FCC0.w,X [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $47.b,X		; F6 47 ; Increment memory $47.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl $3C30.w		; 0E 30 3C ; Arithmetic shift left $3C30.w [Flags: ZNC]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($72.b,X)		; 01 72 ; Logical OR ($72.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $033C.w		; 0D 3C 03 ; Logical OR $033C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $0C3F10.l,X		; 3F 10 3F 0C ; AND accumulator with memory (long,X) $0C3F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $302072.l		; 4F 72 20 30 ; Exclusive OR accumulator with memory (long) $302072.l [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	and $001C00.l,X		; 3F 00 1C 00 ; AND accumulator with memory (long,X) $001C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $906E80.l,X		; 7F 80 6E 90 ; Add long $906E80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($F080.w,X)		; 7C 80 F0 ; Jump indirect indexed to ($F080.w,X) [Reads: X Index] [Flow: jump]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($6E.b)		; F2 6E ; Subtract with carry (indirect) ($6E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsb $4C.b		; 04 4C ; Test and set bits $4C.b [Reads: Accumulator] [Flags: Z]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7E.b,X)		; 01 7E ; Logical OR ($7E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($5F.b,X)		; 21 5F ; Logical AND ($5F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $30, $3F		; 30 3F ; Branch if minus to $30, $3F [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($72.b)		; 12 72 ; OR accumulator with memory (indirect) ($72.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0778.w		; 0C 78 07 ; Test and set bits $0778.w [Reads: Accumulator] [Flags: Z]
	and $001C00.l,X		; 3F 00 1C 00 ; AND accumulator with memory (long,X) $001C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $C03CA0.l		; 5C A0 3C C0 ; Jump long to $C03CA0.l [Flow: jump]
	jsr ($F808.w,X)		; FC 08 F8 ; Jump to subroutine indirect indexed ($F808.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $73		; 10 73 ; Branch if plus to $10, $73 [Flow: branch]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000300.l		; 0F 00 03 00 ; OR accumulator with memory (long) $000300.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$4F.b		; E0 4F ; Compare #$4F.b with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C8.b,X		; 34 C8 ; Test bits $C8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cpx $7C10.w		; EC 10 7C ; Compare $7C10.w with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jmp $7C30.w		; 4C 30 7C ; Jump to $7C30.w [Flow: jump]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3079.w		; 20 79 30 ; Jump to subroutine at $3079.w [Writes: Stack Pointer] [Flow: call]
	and $0C1C19.l,X		; 3F 19 1C 0C ; AND accumulator with memory (long,X) $0C1C19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $010707.l		; 0F 07 07 01 ; OR accumulator with memory (long) $010707.l [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $064903.l		; 5C 03 49 06 ; Jump long to $064903.l [Flow: jump]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	trb $EE.b		; 14 EE ; Test and reset bits $EE.b [Reads: Accumulator] [Flags: Z]
	bit $CC.b		; 24 CC ; Test bits $CC.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E2.b		; E0 E2 ; Compare #$E2.b with X register [Reads: X Index] [Flags: ZNC]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $9B		; 30 9B ; Branch if minus to $30, $9B [Flow: branch]
	stz $DC.b		; 64 DC ; Store zero to $DC.b
	and $7C.b,S		; 23 7C ; AND accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $F0.b,X		; 34 F0 ; Test bits $F0.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	adc $602FF0.l		; 6F F0 2F 60 ; Add with carry (long) $602FF0.l [Writes: Accumulator] [Flags: ZVNC]
	ora $000F20.l,X		; 1F 20 0F 00 ; Logical OR long $000F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: ZNC]
	asl $1A.b		; 06 1A ; Arithmetic shift left $1A.b [Reads: Direct Page] [Flags: ZNC]
	cpx $3C.b		; E4 3C ; Compare $3C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy #$34.b		; C0 34 ; Compare #$34.b with Y register [Reads: Y Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: ZNC]
	ora $F60F36.l		; 0F 36 0F F6 ; OR accumulator with memory (long) $F60F36.l [Writes: Accumulator] [Flags: ZN]
	asl $04F4.w		; 0E F4 04 ; Arithmetic shift left $04F4.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5800.w		; 20 00 58 ; Jump to subroutine at $5800.w [Writes: Stack Pointer] [Flow: call]
	jsr $6498.w		; 20 98 64 ; Jump to subroutine at $6498.w [Writes: Stack Pointer] [Flow: call]
	stz $EC63.w		; 9C 63 EC ; Store zero to $EC63.w
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $F0, $6C		; F0 6C ; Branch if equal to $F0, $6C [Flow: branch]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	cpx #$0F.b		; E0 0F ; Compare #$0F.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $3906.w,Y		; 19 06 39 ; OR accumulator with memory $3906.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $1A.b		; 06 1A ; Arithmetic shift left $1A.b [Reads: Direct Page] [Flags: ZNC]
	cpx $1C.b		; E4 1C ; Compare $1C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b,X		; 16 0F ; Arithmetic shift left $0F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $0E.b,X		; 36 0E ; Rotate left $0E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	pea $F804.w		; F4 04 F8 ; Push absolute address $F804.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0002.w		; 0D 02 00 ; Logical OR $0002.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp ($00B8.w,X)		; 7C B8 00 ; Jump indirect indexed to ($00B8.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $C4		; 10 C4 ; Branch if plus to $10, $C4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $3C04.w,X		; 1E 04 3C ; Arithmetic shift left $3C04.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $C700.w,X		; FE 00 C7 ; Increment memory $C700.w,X [Reads: X Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $7FC0.w,X		; 3E C0 7F ; Rotate left $7FC0.w,X [Reads: X Index] [Flags: ZNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0002.w		; 0D 02 00 ; Logical OR $0002.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$C8.b		; E0 C8 ; Compare #$C8.b with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $6090.w		; 20 90 60 ; Jump to subroutine at $6090.w [Writes: Stack Pointer] [Flow: call]
	jmp $043B20.l		; 5C 20 3B 04 ; Jump long to $043B20.l [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	.db $70, $2C		; 70 2C ; Branch if overflow set to $70, $2C [Flow: branch]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp ($8C00.w,X)		; 7C 00 8C ; Jump indirect indexed to ($8C00.w,X) [Reads: X Index] [Flow: jump]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $08.b,X		; 74 08 ; Store zero to $08.b,X [Reads: X Index]
	jsr ($0070.w,X)		; FC 70 00 ; Jump to subroutine indirect indexed ($0070.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	trb $38C4.w		; 1C C4 38 ; Test and reset bits $38C4.w [Reads: Accumulator] [Flags: Z]
	jmp ($0080.w,X)		; 7C 80 00 ; Jump indirect indexed to ($0080.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	trb $B87C.w		; 1C 7C B8 ; Test and reset bits $B87C.w [Reads: Accumulator] [Flags: Z]
	bit $33C0.w,X		; 3C C0 33 ; Test bits $33C0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	and $1C3F10.l,X		; 3F 10 3F 1C ; AND accumulator with memory (long,X) $1C3F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	and $001C00.l,X		; 3F 00 1C 00 ; AND accumulator with memory (long,X) $001C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $3C30.w		; CC 30 3C ; Compare $3C30.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $3830.w		; 0C 30 38 ; Test and set bits $3830.w [Reads: Accumulator] [Flags: Z]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	adc $1E06.w,Y		; 79 06 1E ; Add $1E06.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $000E.w		; 0C 0E 00 ; Test and set bits $000E.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$17.b		; A0 17 ; Load #$17.b into Y register [Writes: Y Index] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $0E10.w,Y		; 19 10 0E ; OR accumulator with memory $0E10.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $1F03.w		; 1C 03 1F ; Test and reset bits $1F03.w [Reads: Accumulator] [Flags: Z]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpy $3830.w		; CC 30 38 ; Compare $3830.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$39.b		; 09 39 ; Logical OR #$39.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $010300.l		; 0F 00 03 01 ; OR accumulator with memory (long) $010300.l [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $30.b,S		; 03 30 ; OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$38.b		; 09 38 ; Logical OR #$38.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: ZNC]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E4		; 80 E4 ; Branch always to $80, $E4 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $F8E0.w		; 1C E0 F8 ; Test and reset bits $F8E0.w [Reads: Accumulator] [Flags: Z]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$08.b		; C0 08 ; Compare #$08.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0738.w		; 0E 38 07 ; Arithmetic shift left $0738.w [Flags: ZNC]
	trb $0F03.w		; 1C 03 0F ; Test and reset bits $0F03.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $7C		; 30 7C ; Branch if minus to $30, $7C [Flow: branch]
	.db $80, $E4		; 80 E4 ; Branch always to $80, $E4 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $FCE0.w		; 1C E0 FC ; Test and reset bits $FCE0.w [Reads: Accumulator] [Flags: Z]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3C72.w		; 1C 72 3C ; Test and reset bits $3C72.w [Reads: Accumulator] [Flags: Z]
	bit $7800.w,X		; 3C 00 78 ; Test bits $7800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $B0, $34		; B0 34 ; Branch if carry set to $B0, $34 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	trb $FEE0.w		; 1C E0 FE ; Test and reset bits $FEE0.w [Reads: Accumulator] [Flags: Z]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($39.b,X)		; 01 39 ; Logical OR ($39.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $14.b,S		; 03 14 ; OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $30, $09		; 30 09 ; Branch if minus to $30, $09 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $E880.w,X		; 7E 80 E8 ; Rotate right $E880.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3C72.w		; 1C 72 3C ; Test and reset bits $3C72.w [Reads: Accumulator] [Flags: Z]
	bit $3F00.w,X		; 3C 00 3F ; Test bits $3F00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	asl $08E0.w,X		; 1E E0 08 ; Arithmetic shift left $08E0.w,X [Reads: X Index] [Flags: ZNC]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $FEE0.w		; 1C E0 FE ; Test and reset bits $FEE0.w [Reads: Accumulator] [Flags: Z]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $3F06.w,Y		; 39 06 3F ; AND accumulator with memory $3F06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $15.b		; 06 15 ; Arithmetic shift left $15.b [Reads: Direct Page] [Flags: ZNC]
	cop $31.b		; 02 31 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $1C06.w,Y		; 39 06 1C ; AND accumulator with memory $1C06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F4.b		; C0 F4 ; Compare #$F4.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx $FC10.w		; EC 10 FC ; Compare $FC10.w with X register [Reads: X Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3C72.w		; 1C 72 3C ; Test and reset bits $3C72.w [Reads: Accumulator] [Flags: Z]
	bit $E800.w,X		; 3C 00 E8 ; Test bits $E800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $D0, $E4		; D0 E4 ; Branch if not equal to $D0, $E4 [Flow: branch]
	.db $10, $EC		; 10 EC ; Branch if plus to $10, $EC [Flow: branch]
	cpy #$E4.b		; C0 E4 ; Compare #$E4.b with Y register [Reads: Y Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jmp.w [$FE20]		; DC 20 FE ; Jump long indirect [$FE20] [Flow: jump]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $33		; 10 33 ; Branch if plus to $10, $33 [Flow: branch]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	and $001F10.l,X		; 3F 10 1F 00 ; AND accumulator with memory (long,X) $001F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0D.b,S),Y		; 13 0D ; OR accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($12.b,X)		; 21 12 ; Logical AND ($12.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $30, $0C		; 30 0C ; Branch if minus to $30, $0C [Flow: branch]
	bit $1F03.w,X		; 3C 03 1F ; Test bits $1F03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F4		; 30 F4 ; Branch if minus to $30, $F4 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	trb $FCE0.w		; 1C E0 FC ; Test and reset bits $FCE0.w [Reads: Accumulator] [Flags: Z]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $38.b,X		; 74 38 ; Store zero to $38.b,X [Reads: X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $F4		; B0 F4 ; Branch if carry set to $B0, $F4 [Flow: branch]
	.db $80, $84		; 80 84 ; Branch always to $80, $84 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	trb $ECE0.w		; 1C E0 EC ; Test and reset bits $ECE0.w [Reads: Accumulator] [Flags: Z]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0E06.w,Y		; 19 06 0E ; OR accumulator with memory $0E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	trb $F8E0.w		; 1C E0 F8 ; Test and reset bits $F8E0.w [Reads: Accumulator] [Flags: Z]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cld		; D8 ; Clear decimal flag [Flags: D]
	jsr $00FC.w		; 20 FC 00 ; Jump to subroutine at $00FC.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	.db $F0, $A8		; F0 A8 ; Branch if equal to $F0, $A8 [Flow: branch]
	.db $F0, $8C		; F0 8C ; Branch if equal to $F0, $8C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $0018.w,X		; 3C 18 00 ; Test bits $0018.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $205F.w		; 20 5F 20 ; Jump to subroutine at $205F.w [Writes: Stack Pointer] [Flow: call]
	bit $3C03.w,X		; 3C 03 3C ; Test bits $3C03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $2F70.w		; 2C 70 2F ; Test bits $2F70.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	jsr $001F.w		; 20 1F 00 ; Jump to subroutine at $001F.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2ED1.w		; 0C D1 2E ; Test and set bits $2ED1.w [Reads: Accumulator] [Flags: Z]
	ora $1FE6.w,Y		; 19 E6 1F ; OR accumulator with memory $1FE6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $EE1F.w		; 2C 1F EE ; Test bits $EE1F.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $F807F6.l		; 0F F6 07 F8 ; OR accumulator with memory (long) $F807F6.l [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	jmp $5F30.w		; 4C 30 5F ; Jump to $5F30.w [Flow: jump]
	jsr $033C.w		; 20 3C 03 ; Jump to subroutine at $033C.w [Writes: Stack Pointer] [Flow: call]
	trb $3603.w		; 1C 03 36 ; Test and reset bits $3603.w [Reads: Accumulator] [Flags: Z]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $70.b,X		; 34 70 ; Test bits $70.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	and $100F30.l		; 2F 30 0F 10 ; AND accumulator with memory (long) $100F30.l [Writes: Accumulator] [Flags: ZN]
	ora $001720.l		; 0F 20 17 00 ; OR accumulator with memory (long) $001720.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $D9.b		; 04 D9 ; Test and set bits $D9.b [Reads: Accumulator] [Flags: Z]
	rol $0D.b		; 26 0D ; Rotate left $0D.b [Reads: Direct Page] [Flags: ZNC]
	sbc ($0E.b)		; F2 0E ; Subtract with carry (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E00.w		; 0C 00 0E ; Test and set bits $0E00.w [Reads: Accumulator] [Flags: Z]
	bit $0F.b,X		; 34 0F ; Test bits $0F.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	inc $07.b,X		; F6 07 ; Increment memory $07.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: ZNC]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $30C8.w		; 20 C8 30 ; Jump to subroutine at $30C8.w [Writes: Stack Pointer] [Flow: call]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $30F8.w		; 20 F8 30 ; Jump to subroutine at $30F8.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $4C		; F0 4C ; Branch if equal to $F0, $4C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $13.b		; 04 13 ; Test and set bits $13.b [Reads: Accumulator] [Flags: Z]
	tsb $003F.w		; 0C 3F 00 ; Test and set bits $003F.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $1F04.w		; 0E 04 1F ; Arithmetic shift left $1F04.w [Flags: ZNC]
	tsb $320F.w		; 0C 0F 32 ; Test and set bits $320F.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5800.w		; 20 00 58 ; Jump to subroutine at $5800.w [Writes: Stack Pointer] [Flow: call]
	jsr $609C.w		; 20 9C 60 ; Jump to subroutine at $609C.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$00.b]		; 67 00 ; Add with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $F0, $6C		; F0 6C ; Branch if equal to $F0, $6C [Flow: branch]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $3906.w,Y		; 19 06 39 ; OR accumulator with memory $3906.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $3A.b		; 06 3A ; Arithmetic shift left $3A.b [Reads: Direct Page] [Flags: ZNC]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b,X		; 16 0F ; Arithmetic shift left $0F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $0E.b,X		; 36 0E ; Rotate left $0E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	pea $0000.w		; F4 00 00 ; Push absolute address $0000.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $4C		; 10 4C ; Branch if plus to $10, $4C [Flow: branch]
	.db $30, $3B		; 30 3B ; Branch if minus to $30, $3B [Flow: branch]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $10, $78		; 10 78 ; Branch if plus to $10, $78 [Flow: branch]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $39.b		; 02 39 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $DD.b		; 06 DD ; Arithmetic shift left $DD.b [Reads: Direct Page] [Flags: ZNC]
	jsl $000000.l		; 22 00 00 00 ; Jump to subroutine long $000000.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $EA1F36.l		; 0F 36 1F EA ; OR accumulator with memory (long) $EA1F36.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$40.b		; A0 40 ; Load #$40.b into Y register [Writes: Y Index] [Flags: ZN]
	ldy #$40.b		; A0 40 ; Load #$40.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $20		; 70 20 ; Branch if overflow set to $70, $20 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1400.w		; 0C 00 14 ; Test and set bits $1400.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $18E61C.l		; 22 1C E6 18 ; Jump to subroutine long $18E61C.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C00.w		; 0C 00 1C ; Test and set bits $1C00.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $3E1C.w,X		; 3E 1C 3E ; Rotate left $3E1C.w,X [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $11.b		; 04 11 ; Test and set bits $11.b [Reads: Accumulator] [Flags: Z]
	asl $0C13.w		; 0E 13 0C ; Arithmetic shift left $0C13.w [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	asl $0D1F.w		; 0E 1F 0D ; Arithmetic shift left $0D1F.w [Flags: ZNC]
	ora $000005.l,X		; 1F 05 00 00 ; Logical OR long $000005.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $92.b		; 04 92 ; Test and set bits $92.b [Reads: Accumulator] [Flags: Z]
	tsb $0CF2.w		; 0C F2 0C ; Test and set bits $0CF2.w [Reads: Accumulator] [Flags: Z]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $9E.b		; 04 9E ; Test and set bits $9E.b [Reads: Accumulator] [Flags: Z]
	tsb $8CFE.w		; 0C FE 8C ; Test and set bits $8CFE.w [Reads: Accumulator] [Flags: Z]
	jsr ($9CB0.w,X)		; FC B0 9C ; Jump to subroutine indirect indexed ($9CB0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $72		; 10 72 ; Branch if plus to $10, $72 [Flow: branch]
	ora $237C.w		; 0D 7C 23 ; Logical OR $237C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $003B30.l,X		; 5F 30 3B 00 ; Exclusive OR accumulator with memory (long,X) $003B30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $0F		; 90 0F ; Branch if carry clear to $90, $0F [Flow: branch]
	jsr $620F.w		; 20 0F 62 ; Jump to subroutine at $620F.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	tsb $037C.w		; 0C 7C 03 ; Test and set bits $037C.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($7C80.w,X)		; 7C 80 7C ; Jump indirect indexed to ($7C80.w,X) [Reads: X Index] [Flow: jump]
	.db $80, $3C		; 80 3C ; Branch always to $80, $3C [Flow: branch]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	trb $1C32.w		; 1C 32 1C ; Test and reset bits $1C32.w [Reads: Accumulator] [Flags: Z]
	trb $3C00.w		; 1C 00 3C ; Test and reset bits $3C00.w [Reads: Accumulator] [Flags: Z]
	cld		; D8 ; Clear decimal flag [Flags: D]
	bit $7CC0.w,X		; 3C C0 7C ; Test bits $7CC0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $1A18.w,X		; 3C 18 1A ; Test bits $1A18.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx #$E6.b		; E0 E6 ; Compare #$E6.b with X register [Reads: X Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $200F.w		; 20 0F 20 ; Jump to subroutine at $200F.w [Writes: Stack Pointer] [Flow: call]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $C8.b,X		; 36 C8 ; Rotate left $C8.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy $3C30.w		; CC 30 3C ; Compare $3C30.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $1CFE.w		; 0C FE 1C ; Test and set bits $1CFE.w [Reads: Accumulator] [Flags: Z]
	rol $1C1C.w,X		; 3E 1C 1C ; Rotate left $1C1C.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $C804.w		; F4 04 C8 ; Push absolute address $C804.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tsb $3630.w		; 0C 30 36 ; Test and set bits $3630.w [Reads: Accumulator] [Flags: Z]
	cpy #$E6.b		; C0 E6 ; Compare #$E6.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $207E.w		; 1C 7E 20 ; Test and reset bits $207E.w [Reads: Accumulator] [Flags: Z]
	ror $3C00.w,X		; 7E 00 3C ; Rotate right $3C00.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $38.b		; 04 38 ; Test and set bits $38.b [Reads: Accumulator] [Flags: Z]
	asl $FEE0.w,X		; 1E E0 FE ; Arithmetic shift left $FEE0.w,X [Reads: X Index] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$3E.b]		; 07 3E ; OR accumulator with memory (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7F.b,X		; 34 7F ; Test bits $7F.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	adc $003800.l,X		; 7F 00 38 00 ; Add long $003800.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $2F		; 70 2F ; Branch if overflow set to $70, $2F [Flow: branch]
	jsr $3C1E.w		; 20 1E 3C ; Jump to subroutine at $3C1E.w [Writes: Stack Pointer] [Flow: call]
	ora $7B.b,S		; 03 7B ; OR accumulator with stack relative $7B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$5C.b		; C0 5C ; Compare #$5C.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$FC.b		; A0 FC ; Load #$FC.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $50FE.w		; 2C FE 50 ; Test bits $50FE.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	inc $1C00.w,X		; FE 00 1C ; Increment memory $1C00.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $7804.w		; F4 04 78 ; Push absolute address $7804.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	bit $DEC0.w,X		; 3C C0 DE ; Test bits $DEC0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$26.b],Y		; 17 26 ; OR accumulator with memory (long indexed) [$26.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0639.w,Y		; 19 39 06 ; OR accumulator with memory $0639.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $3F01.w,X		; 1E 01 3F ; Arithmetic shift left $3F01.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $001E1C.l,X		; 3F 1C 1E 00 ; AND accumulator with memory (long,X) $001E1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $200720.l		; 0F 20 07 20 ; OR accumulator with memory (long) $200720.l [Writes: Accumulator] [Flags: ZN]
	ora $0618.w,Y		; 19 18 06 ; OR accumulator with memory $0618.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $3F01.w,X		; 3E 01 3F ; Rotate left $3F01.w,X [Reads: X Index] [Flags: ZNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F4.b		; C0 F4 ; Compare #$F4.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy $3C30.w		; CC 30 3C ; Compare $3C30.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	tsb $C8.b		; 04 C8 ; Test and set bits $C8.b [Reads: Accumulator] [Flags: Z]
	tsb $3830.w		; 0C 30 38 ; Test and set bits $3830.w [Reads: Accumulator] [Flags: Z]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3E.b),Y		; 11 3E ; OR accumulator with memory ($3E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $1C3F.w		; 0D 3F 1C ; Logical OR $1C3F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $001E02.l,X		; 3F 02 1E 00 ; AND accumulator with memory (long,X) $001E02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	jsr $3C0F.w		; 20 0F 3C ; Jump to subroutine at $3C0F.w [Writes: Stack Pointer] [Flow: call]
	cop $32.b		; 02 32 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$7E.b		; C0 7E ; Compare #$7E.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $4C		; 80 4C ; Branch always to $80, $4C [Flow: branch]
	.db $B0, $3C		; B0 3C ; Branch if carry set to $B0, $3C [Flow: branch]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $E81E.w		; EC 1E E8 ; Compare $E81E.w with X register [Reads: X Index] [Flags: ZNC]
	jmp $0C00.w		; 4C 00 0C ; Jump to $0C00.w [Flow: jump]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F30.w		; 0C 30 0F ; Test and set bits $0F30.w [Reads: Accumulator] [Flags: Z]
	and #$16.b		; 29 16 ; Logical AND #$16.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $201F20.l,X		; 1F 20 1F 20 ; Logical OR long $201F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $301021.l		; 0F 21 10 30 ; OR accumulator with memory (long) $301021.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $1F03.w,X		; 3C 03 1F ; Test bits $1F03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $9E		; 80 9E ; Branch always to $80, $9E [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ror $8C.b,X		; 76 8C ; Rotate right $8C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inc $FE10.w,X		; FE 10 FE ; Increment memory $FE10.w,X [Reads: X Index] [Flags: ZN]
	.db $10, $9C		; 10 9C ; Branch if plus to $10, $9C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0F.b		; E6 0F ; Increment $0F.b [Reads: Direct Page] [Flags: ZN]
	inc $1E.b,X		; F6 1E ; Increment memory $1E.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	.db $80, $3E		; 80 3E ; Branch always to $80, $3E [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ror $7E80.w,X		; 7E 80 7E ; Rotate right $7E80.w,X [Reads: X Index] [Flags: ZNC]
	.db $80, $9C		; 80 9C ; Branch always to $80, $9C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000F0C.l,X		; 1F 0C 0F 00 ; Logical OR long $000F0C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $0B		; 10 0B ; Branch if plus to $10, $0B [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $3830.w		; 0C 30 38 ; Test and set bits $3830.w [Reads: Accumulator] [Flags: Z]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $47		; 30 47 ; Branch if minus to $30, $47 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $000000.l,X		; 3F 00 00 00 ; AND accumulator with memory (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $7F		; 30 7F ; Branch if minus to $30, $7F [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	and $023F1B.l,X		; 3F 1B 3F 02 ; AND accumulator with memory (long,X) $023F1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C400.w,X		; 3C 00 C4 ; Test bits $C400.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx $0010.w		; EC 10 00 ; Compare $0010.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($FC58.w,X)		; FC 58 FC ; Jump to subroutine indirect indexed ($FC58.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $47		; 30 47 ; Branch if minus to $30, $47 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	and $000010.l		; 2F 10 00 00 ; AND accumulator with memory (long) $000010.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $7F		; 30 7F ; Branch if minus to $30, $7F [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	and $000016.l,X		; 3F 16 00 00 ; AND accumulator with memory (long,X) $000016.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $CC		; 30 CC ; Branch if minus to $30, $CC [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($FC30.w,X)		; FC 30 FC ; Jump to subroutine indirect indexed ($FC30.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7B.b)		; 12 7B ; OR accumulator with memory (indirect) ($7B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	rol $1C04.w,X		; 3E 04 1C ; Rotate left $1C04.w,X [Reads: X Index] [Flags: ZNC]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3E45.w,X		; 1E 45 3E ; Arithmetic shift left $3E45.w,X [Reads: X Index] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rep #$C0		; C2 C0 ; Reset processor status bits #$C0 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
.ACCU 8
	sep #$60		; E2 60
	sbc $76.b,X		; F5 76 ; Subtract $76.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $007E.w,Y		; 99 7E 00 ; Store accumulator to $007E.w,Y [Reads: Accumulator, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $3E		; 70 3E ; Branch if overflow set to $70, $3E [Flow: branch]
	jsr ($7C9E.w,X)		; FC 9E 7C ; Jump to subroutine indirect indexed ($7C9E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	jmp ($18E7.w,X)		; 7C E7 18 ; Jump indirect indexed to ($18E7.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1606.w		; 0E 06 16 ; Arithmetic shift left $1606.w [Flags: ZNC]
	asl $0F33.w		; 0E 33 0F ; Arithmetic shift left $0F33.w [Flags: ZNC]
	jmp ($A303.w)		; 6C 03 A3 ; Jump indirect to ($A303.w) [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $6F.b,S		; 03 6F ; OR accumulator with stack relative $6F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $E3		; 10 E3 ; Branch if plus to $10, $E3 [Flow: branch]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $30, $C8		; 30 C8 ; Branch if minus to $30, $C8 [Flow: branch]
	.db $F0, $3E		; F0 3E ; Branch if equal to $F0, $3E [Flow: branch]
	cpy #$C5.b		; C0 C5 ; Compare #$C5.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$D8.b		; C0 D8 ; Compare #$D8.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$38.b		; E0 38 ; Compare #$38.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0C1C03.l		; 0F 03 1C 0C ; OR accumulator with memory (long) $0C1C03.l [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $06BE1D.l,X		; BF 1D BE 06 ; Load long $06BE1D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$49.b],Y		; D7 49 ; Compare accumulator (long indexed) [$49.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	stz $03.b		; 64 03 ; Store zero to $03.b
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $E20F74.l		; 0F 74 0F E2 ; OR accumulator with memory (long) $E20F74.l [Writes: Accumulator] [Flags: ZN]
	ora $07F9.w,X		; 1D F9 07 ; OR accumulator with memory $07F9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldx $9F01.w,Y		; BE 01 9F ; Load X register $9F01.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$38.b		; C0 38 ; Compare #$38.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	.db $30, $1D		; 30 1D ; Branch if minus to $30, $1D [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $1B08.w		; 2D 08 1B ; Logical AND $1B08.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($DF.b)		; 12 DF ; OR accumulator with memory (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $C0.b,X		; D6 C0 ; Decrement memory $C0.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C8.b		; C0 C8 ; Compare #$C8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $CE		; F0 CE ; Branch if equal to $F0, $CE [Flow: branch]
	.db $30, $E7		; 30 E7 ; Branch if minus to $30, $E7 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp [$D8.b],Y		; D7 D8 ; Compare accumulator (long indexed) [$D8.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sbc $29F0.w		; ED F0 29 ; Subtract $29F0.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $306D.w		; 0C 6D 30 ; Test and set bits $306D.w [Reads: Accumulator] [Flags: Z]
	eor ($21.b,S),Y		; 53 21 ; XOR accumulator (stack relative indirect indexed) ($21.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sep #$40		; E2 40 ; Set processor status bits #$40 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	lda $40.b		; A5 40 ; Load $40.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp $10BE00.l		; 5C 00 BE 10 ; Jump long to $10BE00.l [Flow: jump]
	ora $3700.w		; 0D 00 37 ; Logical OR $3700.w with accumulator [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $7222.w,X		; 5D 22 72 ; Exclusive OR accumulator with memory $7222.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $5CA3.w		; 0C A3 5C ; Test and set bits $5CA3.w [Reads: Accumulator] [Flags: Z]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	jsr $00E5.w		; 20 E5 00 ; Jump to subroutine at $00E5.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	jmp $DE00.w		; 4C 00 DE ; Jump to $DE00.w [Flow: jump]
	.db $80, $64		; 80 64 ; Branch always to $80, $64 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $18BC.w		; 0C BC 18 ; Test and set bits $18BC.w [Reads: Accumulator] [Flags: Z]
	jsr ($E818.w,X)		; FC 18 E8 ; Jump to subroutine indirect indexed ($E818.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $CC		; 10 CC ; Branch if plus to $10, $CC [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1D.b		; 06 1D ; Arithmetic shift left $1D.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $3310.w,Y		; 39 10 33 ; AND accumulator with memory $3310.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($7F.b),Y		; 11 7F ; OR accumulator with memory ($7F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $15.b		; 06 15 ; Arithmetic shift left $15.b [Reads: Direct Page] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and #$16.b		; 29 16 ; Logical AND #$16.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jsl $005C1C.l		; 22 1C 5C 00 ; Jump to subroutine long $005C1C.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $50, $00		; 50 00 ; Branch if overflow clear to $50, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $80, $48		; 80 48 ; Branch always to $80, $48 [Flow: branch]
	.db $70, $28		; 70 28 ; Branch if overflow set to $70, $28 [Flow: branch]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $B8		; 10 B8 ; Branch if plus to $10, $B8 [Flow: branch]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $10, $D0		; 10 D0 ; Branch if plus to $10, $D0 [Flow: branch]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $091B07.l		; 0F 07 1B 09 ; OR accumulator with memory (long) $091B07.l [Writes: Accumulator] [Flags: ZN]
	and $287F1B.l,X		; 3F 1B 7F 28 ; AND accumulator with memory (long,X) $287F1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $57.b		; 00 57 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $30		; 80 30 ; Branch always to $80, $30 [Flow: branch]
	jsr $1058.w		; 20 58 10 ; Jump to subroutine at $1058.w [Writes: Stack Pointer] [Flow: call]
	jsr ($FED0.w,X)		; FC D0 FE ; Jump to subroutine indirect indexed ($FED0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	trb $17.b		; 14 17 ; Test and reset bits $17.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	and ($0C.b,S),Y		; 33 0C ; AND accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $3F03.w,X		; 3C 03 3F ; Test bits $3F03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	trb $0C1E.w		; 1C 1E 0C ; Test and reset bits $0C1E.w [Reads: Accumulator] [Flags: Z]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($7838.w,X)		; FC 38 78 ; Jump to subroutine indirect indexed ($7838.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $3C30.w		; 0C 30 3C ; Test and set bits $3C30.w [Reads: Accumulator] [Flags: Z]
	cpy #$DC.b		; C0 DC ; Compare #$DC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $3F03.w,X		; 3C 03 3F ; Test bits $3F03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $102706.l,X		; 3F 06 27 10 ; AND accumulator with memory (long,X) $102706.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $0C		; 30 0C ; Branch if minus to $30, $0C [Flow: branch]
	bit $3F03.w,X		; 3C 03 3F ; Test bits $3F03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cpx $3C10.w		; EC 10 3C ; Compare $3C10.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($3838.w,X)		; FC 38 38 ; Jump to subroutine indirect indexed ($3838.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$E4.b		; A0 E4 ; Load #$E4.b into Y register [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $3C30.w		; 0C 30 3C ; Test and set bits $3C30.w [Reads: Accumulator] [Flags: Z]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: ZNC]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $1A		; 10 1A ; Branch if plus to $10, $1A [Flow: branch]
	ora ($1A.b,X)		; 01 1A ; Logical OR ($1A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $C300.w,Y		; 19 00 C3 ; OR accumulator with memory $C300.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$7C.b		; C0 7C ; Compare #$7C.b with Y register [Reads: Y Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy #$E0.b		; A0 E0 ; Load #$E0.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $19		; 80 19 ; Branch always to $80, $19 [Flow: branch]
	inc $C3.b		; E6 C3 ; Increment $C3.b [Reads: Direct Page] [Flags: ZN]
	bit $003E.w,X		; 3C 3E 00 ; Test bits $003E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sty $00.b,X		; 94 00 ; Store Y register $00.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cmp $397F48.l,X		; DF 48 7F 39 ; Compare accumulator (long,X) $397F48.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	rol $1818.w,X		; 3E 18 18 ; Rotate left $1818.w,X [Reads: X Index] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$B7.b],Y		; 17 B7 ; OR accumulator with memory (long indexed) [$B7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FE.b)		; 12 FE ; OR accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stz $187C.w		; 9C 7C 18 ; Store zero to $187C.w
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sbc $0200.w		; ED 00 02 ; Subtract $0200.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0021.w		; 20 21 00 ; Jump to subroutine at $0021.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	tsb $0300.w		; 0C 00 03 ; Test and set bits $0300.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $57.b		; 00 57 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $D4.b		; C4 D4 ; Compare $D4.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$B4.b		; E0 B4 ; Compare #$B4.b with X register [Reads: X Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $90, $30		; 90 30 ; Branch if carry clear to $90, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $000F0E.l,X		; 3F 0E 0F 00 ; AND accumulator with memory (long,X) $000F0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($0C.b,S),Y		; 33 0C ; AND accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1000.w,X		; 3D 00 10 ; AND accumulator with memory $1000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $3D1C3F.l		; 0F 3F 1C 3D ; OR accumulator with memory (long) $3D1C3F.l [Writes: Accumulator] [Flags: ZN]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sta $14EF72.l		; 8F 72 EF 14 ; Store accumulator (long) $14EF72.l [Reads: Accumulator]
	lda $807E44.l,X		; BF 44 7E 80 ; Load long $807E44.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7887.w,X		; 3C 87 78 ; Test bits $7887.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $B00FF0.l		; 0F F0 0F B0 ; OR accumulator with memory (long) $B00FF0.l [Writes: Accumulator] [Flags: ZN]
	asl $7860.w,X		; 1E 60 78 ; Arithmetic shift left $7860.w,X [Reads: X Index] [Flags: ZNC]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $061F.w		; 0D 1F 06 ; Logical OR $061F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $19.b		; 04 19 ; Test and set bits $19.b [Reads: Accumulator] [Flags: Z]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $000E.w		; 0E 0E 00 ; Arithmetic shift left $000E.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ldy #$9C.b		; A0 9C ; Load #$9C.b into Y register [Writes: Y Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	jsr ($FC08.w,X)		; FC 08 FC ; Jump to subroutine indirect indexed ($FC08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0060.w		; 20 60 00 ; Jump to subroutine at $0060.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $9C		; 30 9C ; Branch if minus to $30, $9C [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $3CE0.w		; 1C E0 3C ; Test and reset bits $3CE0.w [Reads: Accumulator] [Flags: Z]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$37.b]		; 07 37 ; OR accumulator with memory (long) [$37.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1E0E1E.l		; 0F 1E 0E 1E ; OR accumulator with memory (long) $1E0E1E.l [Writes: Accumulator] [Flags: ZN]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $073800.l,X		; 7F 00 38 07 ; Add long $073800.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0607.w,Y		; 19 07 06 ; OR accumulator with memory $0607.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$6C.b		; E0 6C ; Compare #$6C.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $38		; 70 38 ; Branch if overflow set to $70, $38 [Flow: branch]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $9C00.w,X		; FE 00 9C ; Increment memory $9C00.w,X [Reads: X Index] [Flags: ZN]
	cpx #$C8.b		; E0 C8 ; Compare #$C8.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	cpy #$90.b		; C0 90 ; Compare #$90.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $50.b		; 06 50 ; Arithmetic shift left $50.b [Reads: Direct Page] [Flags: ZNC]
	tsb $0768.w		; 0C 68 07 ; Test and set bits $0768.w [Reads: Accumulator] [Flags: Z]
	lsr $01.b		; 46 01 ; Logical shift right $01.b [Reads: Direct Page] [Flags: ZNC]
	adc ($00.b,X)		; 61 00 ; Add with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $106F03.l,X		; 7F 03 6F 10 ; Add long $106F03.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor [$38.b]		; 47 38 ; Exclusive OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc ($1E.b,X)		; 61 1E ; Add with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	bit $FC28.w		; 2C 28 FC ; Test bits $FC28.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cpx #$3A.b		; E0 3A ; Compare #$3A.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $DA		; F0 DA ; Branch if equal to $F0, $DA [Flow: branch]
	jsr $0436.w		; 20 36 04 ; Jump to subroutine at $0436.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpy #$D4.b		; C0 D4 ; Compare #$D4.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	trb $CEE0.w		; 1C E0 CE ; Test and reset bits $CEE0.w [Reads: Accumulator] [Flags: Z]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $0737.w		; 2E 37 07 ; Rotate left $0737.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $077F07.l,X		; 7F 07 7F 07 ; Add long $077F07.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $0B.b,X		; 56 0B ; Logical shift right $0B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	eor ($0E.b),Y		; 51 0E ; Exclusive OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $E00000.l		; 0F 00 00 E0 ; OR accumulator with memory (long) $E00000.l [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	.db $F0, $FA		; F0 FA ; Branch if equal to $F0, $FA [Flow: branch]
	cpx #$EE.b		; E0 EE ; Compare #$EE.b with X register [Reads: X Index] [Flags: ZNC]
	trb $D6.b		; 14 D6 ; Test and reset bits $D6.b [Reads: Accumulator] [Flags: Z]
	ldy $00.b		; A4 00 ; Load $00.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$C4.b		; E0 C4 ; Compare #$C4.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl $1EF0.w		; 0E F0 1E ; Arithmetic shift left $1EF0.w [Flags: ZNC]
	cpx #$FA.b		; E0 FA ; Compare #$FA.b with X register [Reads: X Index] [Flags: ZNC]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $56.b		; 06 56 ; Arithmetic shift left $56.b [Reads: Direct Page] [Flags: ZNC]
	asl $07B8.w		; 0E B8 07 ; Arithmetic shift left $07B8.w [Flags: ZNC]
	lda [$00.b]		; A7 00 ; Load accumulator (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $FF07.w,Y		; 59 07 FF ; Exclusive OR accumulator with memory $FF07.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $302A.w		; 20 2A 30 ; Jump to subroutine at $302A.w [Writes: Stack Pointer] [Flow: call]
	ora $E5E0.w,X		; 1D E0 E5 ; OR accumulator with memory $E5E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $D0		; 80 D0 ; Branch always to $80, $D0 [Flow: branch]
	cpx #$DA.b		; E0 DA ; Compare #$DA.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: ZNC]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $7100.w		; 0E 00 71 ; Arithmetic shift left $7100.w [Flags: ZNC]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($7D.b,X)		; 61 7D ; Add with carry ($7D.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $3910.w,Y		; 39 10 39 ; AND accumulator with memory $3910.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $7D9E.w		; 0E 9E 7D ; Arithmetic shift left $7D9E.w [Flags: ZNC]
	adc [$18.b]		; 67 18 ; Add with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $003F10.l		; 2F 10 3F 00 ; AND accumulator with memory (long) $003F10.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($80.b,X)		; 61 80 ; Add with carry ($80.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$7C.b		; C0 7C ; Compare #$7C.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $FA		; 80 FA ; Branch always to $80, $FA [Flow: branch]
	tsb $E1.b		; 04 E1 ; Test and set bits $E1.b [Reads: Accumulator] [Flags: Z]
	asl $0000.w,X		; 1E 00 00 ; Arithmetic shift left $0000.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0C1C03.l		; 0F 03 1C 0C ; OR accumulator with memory (long) $0C1C03.l [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $00001D.l,X		; BF 1D 00 00 ; Load long $00001D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1303.w		; 0C 03 13 ; Test and set bits $1303.w [Reads: Accumulator] [Flags: Z]
	ora $E20F74.l		; 0F 74 0F E2 ; OR accumulator with memory (long) $E20F74.l [Writes: Accumulator] [Flags: ZN]
	ora $0000.w,X		; 1D 00 00 ; OR accumulator with memory $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	.db $30, $1D		; 30 1D ; Branch if minus to $30, $1D [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $CE		; F0 CE ; Branch if equal to $F0, $CE [Flow: branch]
	.db $30, $E7		; 30 E7 ; Branch if minus to $30, $E7 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1D02.w		; ED 02 1D ; Subtract $1D02.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	sep #$09		; E2 09 ; Set processor status bits #$09 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc [$EA.b],Y		; F7 EA ; Subtract with carry (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0000F6.l,X		; FF F6 00 00 ; Subtract with carry (long,X) $0000F6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $9C6300.l,X		; FF 00 63 9C ; Subtract with carry (long,X) $9C6300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $DD3FE0.l,X		; 1F E0 3F DD ; Logical OR long $DD3FE0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $205C.w		; 20 5C 20 ; Jump to subroutine at $205C.w [Writes: Stack Pointer] [Flow: call]
	and $033C00.l,X		; 3F 00 3C 03 ; AND accumulator with memory (long,X) $033C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	jsr $2C70.w		; 20 70 2C ; Jump to subroutine at $2C70.w [Writes: Stack Pointer] [Flow: call]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	jsr $001F.w		; 20 1F 00 ; Jump to subroutine at $001F.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $39.b		; 04 39 ; Test and set bits $39.b [Reads: Accumulator] [Flags: Z]
	asl $DD.b		; 06 DD ; Arithmetic shift left $DD.b [Reads: Direct Page] [Flags: ZNC]
	jsl $00F00E.l		; 22 0E F0 00 ; Jump to subroutine long $00F00E.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	rol $07.b,X		; 36 07 ; Rotate left $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: ZNC]
	adc $247728.l,X		; 7F 28 77 24 ; Add long $247728.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda ($40.b,S),Y		; B3 40 ; Load accumulator (stack relative indirect indexed) ($40.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor $003F27.l,X		; 5F 27 3F 00 ; Exclusive OR accumulator with memory (long,X) $003F27.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $3803.w,X		; 3C 03 38 ; Test bits $3803.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora [$47.b]		; 07 47 ; OR accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inc $40.b		; E6 40 ; Increment $40.b [Reads: Direct Page] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr $183F.w		; 20 3F 18 ; Jump to subroutine at $183F.w [Writes: Stack Pointer] [Flow: call]
	and $073F1B.l,X		; 3F 1B 3F 07 ; AND accumulator with memory (long,X) $073F1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stz $FC0C.w,X		; 9E 0C FC ; Store zero to $FC0C.w,X [Reads: X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	cpx #$E8.b		; E0 E8 ; Compare #$E8.b with X register [Reads: X Index] [Flags: ZNC]
	.db $10, $14		; 10 14 ; Branch if plus to $10, $14 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	trb $78E0.w		; 1C E0 78 ; Test and reset bits $78E0.w [Reads: Accumulator] [Flags: Z]
	.db $80, $92		; 80 92 ; Branch always to $80, $92 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $00.b		; 64 00 ; Store zero to $00.b
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F4		; 10 F4 ; Branch if plus to $10, $F4 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	pea $E8E8.w		; F4 E8 E8 ; Push absolute address $E8E8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $90, $21		; 90 21 ; Branch if carry clear to $90, $21 [Flow: branch]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $17.b		; 06 17 ; Arithmetic shift left $17.b [Reads: Direct Page] [Flags: ZNC]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: ZNC]
	tsb $2F.b		; 04 2F ; Test and set bits $2F.b [Reads: Accumulator] [Flags: Z]
	.db $10, $2F		; 10 2F ; Branch if plus to $10, $2F [Flow: branch]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $391F3C.l,X		; 1F 3C 1F 39 ; Logical OR long $391F3C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0E19.w,X		; 1E 19 0E ; Arithmetic shift left $0E19.w,X [Reads: X Index] [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $103F.w		; 0D 3F 10 ; Logical OR $103F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$10.b],Y		; 17 10 ; OR accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $9C8CFE.l		; 0F FE 8C 9C ; OR accumulator with memory (long) $9C8CFE.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $E600.w,X		; FE 00 E6 ; Increment memory $E600.w,X [Reads: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($9E.b,X)		; 61 9E ; Add with carry ($9E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($80.b)		; 72 80 ; Add with carry (indirect) ($80.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sty $60.b,X		; 94 60 ; Store Y register $60.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $1C		; F0 1C ; Branch if equal to $F0, $1C [Flow: branch]
	cpx #$7E.b		; E0 7E ; Compare #$7E.b with X register [Reads: X Index] [Flags: ZNC]
	stz $649E.w		; 9C 9E 64 ; Store zero to $649E.w
	rol $3FD8.w,X		; 3E D8 3F ; Rotate left $3FD8.w,X [Reads: X Index] [Flags: ZNC]
	dec $40D0.w,X		; DE D0 40 ; Decrement memory $40D0.w,X [Reads: X Index] [Flags: ZN]
	jsr ($7F60.w,X)		; FC 60 7F ; Jump to subroutine indirect indexed ($7F60.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	trb $1137.w		; 1C 37 11 ; Test and reset bits $1137.w [Reads: Accumulator] [Flags: Z]
	lsr $6F20.w,X		; 5E 20 6F ; Logical shift right $6F20.w,X [Reads: X Index] [Flags: ZNC]
	ora ($FE.b),Y		; 11 FE ; OR accumulator with memory ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $B0.b		; 06 B0 ; Arithmetic shift left $B0.b [Reads: Direct Page] [Flags: ZNC]
	ora $63039C.l		; 0F 9C 03 63 ; OR accumulator with memory (long) $63039C.l [Writes: Accumulator] [Flags: ZN]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $107A.w		; 20 7A 10 ; Jump to subroutine at $107A.w [Writes: Stack Pointer] [Flow: call]
	sbc $6EF160.l,X		; FF 60 F1 6E ; Subtract with carry (long,X) $6EF160.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FE.b		; 06 FE ; Arithmetic shift left $FE.b [Reads: Direct Page] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx $7A88.w		; EC 88 7A ; Compare $7A88.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $F6.b		; 04 F6 ; Test and set bits $F6.b [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	adc $00FF00.l,X		; 7F 00 FF 00 ; Add long $00FF00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $39F0.w		; 0D F0 39 ; Logical OR $39F0.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cpy #$C6.b		; C0 C6 ; Compare #$C6.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $5E.b		; 04 5E ; Test and set bits $5E.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $768F06.l,X		; FF 06 8F 76 ; Subtract with carry (long,X) $768F06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $2E04.w,X		; 1D 04 2E ; OR accumulator with memory $2E04.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $4E.b		; 04 4E ; Test and set bits $4E.b [Reads: Accumulator] [Flags: Z]
	tsb $2B.b		; 04 2B ; Test and set bits $2B.b [Reads: Accumulator] [Flags: Z]
	cop $3D.b		; 02 3D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $4F.b,S		; 03 4F ; OR accumulator with stack relative $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $53		; 30 53 ; Branch if minus to $30, $53 [Flow: branch]
	bit $001B.w		; 2C 1B 00 ; Test bits $001B.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora ($4A.b),Y		; 11 4A ; OR accumulator with memory ($4A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($2D.b),Y		; 31 2D ; AND accumulator with memory ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $2C5F30.l		; 4F 30 5F 2C ; Exclusive OR accumulator with memory (long) $2C5F30.l [Writes: Accumulator] [Flags: ZN]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Accumulator, X Index, Direct Page]
	and $FE00.w,Y		; 39 00 FE ; AND accumulator with memory $FE00.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $72		; 80 72 ; Branch always to $80, $72 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sty $F888.w		; 8C 88 F8 ; Store Y register to $F888.w [Reads: Y Index]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $C639.w,X		; 7E 39 C6 ; Rotate right $C639.w,X [Reads: X Index] [Flags: ZNC]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	stz $7400.w,X		; 9E 00 74 ; Store zero to $7400.w,X [Reads: X Index]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$BE.b		; C0 BE ; Compare #$BE.b with Y register [Reads: Y Index] [Flags: ZNC]
	asl $F7.b		; 06 F7 ; Arithmetic shift left $F7.b [Reads: Direct Page] [Flags: ZNC]
	adc #$FB.b		; 69 FB ; Add #$FB.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	stz $77.b		; 64 77 ; Store zero to $77.b
	jsr $0061.w		; 20 61 00 ; Jump to subroutine at $0061.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	jmp.w [$9F20]		; DC 20 9F ; Jump long indirect [$9F20] [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $9E07.w,Y		; F9 07 9E ; Subtract with carry $9E07.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($9F.b,X)		; 01 9F ; Logical OR ($9F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $57.b		; 00 57 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc ($1E.b,X)		; 61 1E ; Add with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $4F		; F0 4F ; Branch if equal to $F0, $4F [Flow: branch]
	jsr ($F323.w,X)		; FC 23 F3 ; Jump to subroutine indirect indexed ($F323.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp ($082D.w)		; 6C 2D 08 ; Jump indirect to ($082D.w) [Flow: jump]
	ora $D6DF16.l,X		; 1F 16 DF D6 ; Logical OR long $D6DF16.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec $D6C4.w,X		; DE C4 D6 ; Decrement memory $D6C4.w,X [Reads: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $043B00.l		; 6F 00 3B 04 ; Add with carry (long) $043B00.l [Writes: Accumulator] [Flags: ZVNC]
	cmp #$36.b		; C9 36 ; Compare #$36.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	cmp [$D8.b],Y		; D7 D8 ; Compare accumulator (long indexed) [$D8.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sbc #$F0.b		; E9 F0 ; Subtract #$F0.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	and #$F0.b		; 29 F0 ; Logical AND #$F0.b with accumulator [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpx #$B6.b		; E0 B6 ; Compare #$B6.b with X register [Reads: X Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	adc $C43F92.l		; 6F 92 3F C4 ; Add with carry (long) $C43F92.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $040B36.l		; CF 36 0B 04 ; Compare accumulator (long) $040B36.l [Reads: Accumulator] [Flags: ZNC]
	tsb $0703.w		; 0C 03 07 ; Test and set bits $0703.w [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $E01F00.l,X		; FF 00 1F E0 ; Subtract with carry (long,X) $E01F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $F000.w,X		; FE 00 F0 ; Increment memory $F000.w,X [Reads: X Index] [Flags: ZN]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	adc $061F9A.l,X		; 7F 9A 1F 06 ; Add long $061F9A.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $F0F0.w		; 0E F0 F0 ; Arithmetic shift left $F0F0.w [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000F0C.l,X		; 1F 0C 0F 00 ; Logical OR long $000F0C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $14.b		; 04 14 ; Test and set bits $14.b [Reads: Accumulator] [Flags: Z]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$40BF]		; DC BF 40 ; Jump long indirect [$40BF] [Flow: jump]
	inc $08.b,X		; F6 08 ; Increment memory $08.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	tsb $FEF0.w		; 0C F0 FE ; Test and set bits $FEF0.w [Reads: Accumulator] [Flags: Z]
	tsb $FD.b		; 04 FD ; Test and set bits $FD.b [Reads: Accumulator] [Flags: Z]
	asl $1E39.w		; 0E 39 1E ; Arithmetic shift left $1E39.w [Flags: ZNC]
	asl $3F00.w,X		; 1E 00 3F ; Arithmetic shift left $3F00.w,X [Reads: X Index] [Flags: ZNC]
	cmp $E01F.w,X		; DD 1F E0 ; Compare accumulator $E01F.w,X [Reads: X Index] [Flags: ZNC]
	asl $F0.b		; 06 F0 ; Arithmetic shift left $F0.b [Reads: Direct Page] [Flags: ZNC]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $F0, $F7		; F0 F7 ; Branch if equal to $F0, $F7 [Flow: branch]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	and $001F10.l,X		; 3F 10 1F 00 ; AND accumulator with memory (long,X) $001F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $200F.w		; 20 0F 20 ; Jump to subroutine at $200F.w [Writes: Stack Pointer] [Flow: call]
	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E8.b		; 14 E8 ; Test and reset bits $E8.b [Reads: Accumulator] [Flags: Z]
	tsb $3EF0.w		; 0C F0 3E ; Test and set bits $3EF0.w [Reads: Accumulator] [Flags: Z]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $1CFE.w		; 0C FE 1C ; Test and set bits $1CFE.w [Reads: Accumulator] [Flags: Z]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	asl $3630.w		; 0E 30 36 ; Arithmetic shift left $3630.w [Flags: ZNC]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $1C06.w,Y		; 39 06 1C ; AND accumulator with memory $1C06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr $3117.w		; 20 17 31 ; Jump to subroutine at $3117.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cpy $3C30.w		; CC 30 3C ; Compare $3C30.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($E838.w,X)		; FC 38 E8 ; Jump to subroutine indirect indexed ($E838.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $04		; 70 04 ; Branch if overflow set to $70, $04 [Flow: branch]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $3C30.w		; 0C 30 3C ; Test and set bits $3C30.w [Reads: Accumulator] [Flags: Z]
	cpy #$DC.b		; C0 DC ; Compare #$DC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$34.b]		; 07 34 ; OR accumulator with memory (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and ($0C.b,S),Y		; 33 0C ; AND accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $0F03.w		; 1C 03 0F ; Test and reset bits $0F03.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $201720.l		; 0F 20 17 20 ; OR accumulator with memory (long) $201720.l [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($0E.b),Y		; F1 0E ; Subtract with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $CE00.w,X		; FE 00 CE ; Increment memory $CE00.w,X [Reads: X Index] [Flags: ZN]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F00E.w		; EE 0E F0 ; Increment $F00E.w [Flags: ZN]
	cop $CC.b		; 02 CC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $38.b		; 04 38 ; Test and set bits $38.b [Reads: Accumulator] [Flags: Z]
	bit $FCC0.w,X		; 3C C0 FC ; Test bits $FCC0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $043F3C.l,X		; 7F 3C 3F 04 ; Add long $043F3C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0000.w,X		; 1D 00 00 ; OR accumulator with memory $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F4.b		; C0 F4 ; Compare #$F4.b with Y register [Reads: Y Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $FC3C.w,X		; FE 3C FC ; Increment memory $FC3C.w,X [Reads: X Index] [Flags: ZN]
	jsr $00B8.w		; 20 B8 00 ; Jump to subroutine at $00B8.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FC20.w,X		; 1E 20 FC ; Arithmetic shift left $FC20.w,X [Reads: X Index] [Flags: ZNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $007F.w		; 0C 7F 00 ; Test and set bits $007F.w [Reads: Accumulator] [Flags: Z]
	adc $003F00.l,X		; 7F 00 3F 00 ; Add long $003F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $000700.l,X		; 1F 00 07 00 ; Logical OR long $000700.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $334F2D.l,X		; 5F 2D 4F 33 ; Exclusive OR accumulator with memory (long,X) $334F2D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor [$3B.b]		; 47 3B ; Exclusive OR accumulator with memory (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $BF.b		; 06 BF ; Arithmetic shift left $BF.b [Reads: Direct Page] [Flags: ZNC]
	.db $42, $B6		; 42 B6 ; Reserved instruction
	jmp $DC3E.w		; 4C 3E DC ; Jump to $DC3E.w [Flow: jump]
	jmp ($D898.w,X)		; 7C 98 D8 ; Jump indirect indexed to ($D898.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $00BE20.l,X		; 9F 20 BE 00 ; Store accumulator (long,X) $00BE20.l,X [Reads: Accumulator, X Index]
	rol $3C40.w,X		; 3E 40 3C ; Rotate left $3C40.w,X [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr $207F.w		; 20 7F 20 ; Jump to subroutine at $207F.w [Writes: Stack Pointer] [Flow: call]
	and $001B10.l,X		; 3F 10 1B 00 ; AND accumulator with memory (long,X) $001B10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $701F20.l,X		; 1F 20 1F 70 ; Logical OR long $701F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3C0F70.l		; 0F 70 0F 3C ; OR accumulator with memory (long) $3C0F70.l [Writes: Accumulator] [Flags: ZN]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	cpx $FE.b		; E4 FE ; Compare $FE.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	asl $0EF0.w		; 0E F0 0E ; Arithmetic shift left $0EF0.w [Flags: ZNC]
	.db $F0, $3C		; F0 3C ; Branch if equal to $F0, $3C [Flow: branch]
	cpy #$D8.b		; C0 D8 ; Compare #$D8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $37.b		; 02 37 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$3F.b],Y		; 17 3F ; OR accumulator with memory (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$5C.b]		; 07 5C ; OR accumulator with memory (long) [$5C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00045B.l		; 0F 5B 04 00 ; OR accumulator with memory (long) $00045B.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $28.b,S		; 03 28 ; OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $730738.l,X		; 1F 38 07 73 ; Logical OR long $730738.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $007F.w		; 0C 7F 00 ; Test and set bits $007F.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	stz $60.b,X		; 74 60 ; Store zero to $60.b,X [Reads: X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $F0, $16		; F0 16 ; Branch if equal to $F0, $16 [Flow: branch]
	cpx #$62.b		; E0 62 ; Compare #$62.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $86		; 80 86 ; Branch always to $80, $86 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$3E.b		; E0 3E ; Compare #$3E.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$F6.b		; C0 F6 ; Compare #$F6.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
.INDEX 8
	sep #$1C		; E2 1C
	stx $78.b		; 86 78 ; Store X register to $78.b [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1F06.w		; 0E 06 1F ; Arithmetic shift left $1F06.w [Flags: ZNC]
	ora $731F27.l		; 0F 27 1F 73 ; OR accumulator with memory (long) $731F27.l [Writes: Accumulator] [Flags: ZN]
	ora $0003AC.l		; 0F AC 03 00 ; OR accumulator with memory (long) $0003AC.l [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $7C0738.l		; 0F 38 07 7C ; OR accumulator with memory (long) $7C0738.l [Writes: Accumulator] [Flags: ZN]
	ora $EF.b,S		; 03 EF ; OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $E8		; 70 E8 ; Branch if overflow set to $70, $E8 [Flow: branch]
	.db $F0, $CE		; F0 CE ; Branch if equal to $F0, $CE [Flow: branch]
	.db $F0, $35		; F0 35 ; Branch if equal to $F0, $35 [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$88.b		; C0 88 ; Compare #$88.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	cpx #$3E.b		; E0 3E ; Compare #$3E.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$F7.b		; C0 F7 ; Compare #$F7.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $AC		; F0 AC ; Branch if equal to $F0, $AC [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $1905.w		; 0C 05 19 ; Test and set bits $1905.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $0814.w		; 0C 14 08 ; Test and set bits $0814.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $17.b		; 06 17 ; Arithmetic shift left $17.b [Reads: Direct Page] [Flags: ZNC]
	tsb $0916.w		; 0C 16 09 ; Test and set bits $0916.w [Reads: Accumulator] [Flags: Z]
	trb $0003.w		; 1C 03 00 ; Test and reset bits $0003.w [Reads: Accumulator] [Flags: Z]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $D4		; 10 D4 ; Branch if plus to $10, $D4 [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $77.b		; 04 77 ; Test and set bits $77.b [Reads: Accumulator] [Flags: Z]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $F00A.w		; 20 0A F0 ; Jump to subroutine at $F00A.w [Writes: Stack Pointer] [Flow: call]
	adc $814780.l,X		; 7F 80 47 81 ; Add long $814780.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $5B06.w		; 0E 06 5B ; Arithmetic shift left $5B06.w [Flags: ZNC]
	ora [$AC.b]		; 07 AC ; OR accumulator with memory (long) [$AC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $A3.b,S		; 03 A3 ; OR accumulator with stack relative $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$5C.b]		; 07 5C ; OR accumulator with memory (long) [$5C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $EF.b,S		; 03 EF ; OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $E3		; 10 E3 ; Branch if plus to $10, $E3 [Flow: branch]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $5E		; 10 5E ; Branch if plus to $10, $5E [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	and $CDC8.w,X		; 3D C8 CD ; AND accumulator with memory $CDC8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E8.b		; C0 E8 ; Compare #$E8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $B6		; F0 B6 ; Branch if equal to $F0, $B6 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $000030.l		; CF 30 00 00 ; Compare accumulator (long) $000030.l [Reads: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1800.w		; 0C 00 18 ; Test and set bits $1800.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc ($01.b),Y		; 71 01 ; Add with carry ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $3C2F.w,Y		; BE 2F 3C ; Load X register $3C2F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F1703.l		; 0F 03 17 0F ; OR accumulator with memory (long) $0F1703.l [Writes: Accumulator] [Flags: ZN]
	ror $D10F.w,X		; 7E 0F D1 ; Rotate right $D10F.w,X [Reads: X Index] [Flags: ZNC]
	ror $F8C7.w		; 6E C7 F8 ; Rotate right $F8C7.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$94.b		; E0 94 ; Compare #$94.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C2.b		; C0 C2 ; Compare #$C2.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$78.b		; C0 78 ; Compare #$78.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $74		; 80 74 ; Branch always to $80, $74 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
.INDEX 8
	sep #$1C		; E2 1C
.ACCU 16
.INDEX 16
	rep #$3C		; C2 3C
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0C5C03.l		; 0F 03 5C 0C ; OR accumulator with memory (long) $0C5C03.l [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $0AF615.l		; EF 15 F6 0A ; Subtract with carry (long) $0AF615.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $5303.w		; 0C 03 53 ; Test and set bits $5303.w [Reads: Accumulator] [Flags: Z]
	ora $F40FF7.l		; 0F F7 0F F4 ; OR accumulator with memory (long) $F40FF7.l [Writes: Accumulator] [Flags: ZN]
	ora $FD05FA.l		; 0F FA 05 FD ; OR accumulator with memory (long) $FD05FA.l [Writes: Accumulator] [Flags: ZN]
	adc $00.b,S		; 63 00 ; Add with carry (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$101A.w		; C0 1A 10 ; Compare #$101A.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $FDF0.w,X		; FD F0 FD ; Subtract with carry $FDF0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc [$EA.b],Y		; F7 EA ; Subtract with carry (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $000012.l,X		; 3F 12 00 00 ; AND accumulator with memory (long,X) $000012.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$3000.w		; C0 00 30 ; Compare #$3000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F0EA.w		; C0 EA F0 ; Compare #$F0EA.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora $38C7F0.l		; 0F F0 C7 38 ; OR accumulator with memory (long) $38C7F0.l [Writes: Accumulator] [Flags: ZN]
	ora $CDE0.w,X		; 1D E0 CD ; OR accumulator with memory $CDE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1079.w		; 20 79 10 ; Jump to subroutine at $1079.w [Writes: Stack Pointer] [Flow: call]
	rol $1C18.w,X		; 3E 18 1C ; Rotate left $1C18.w,X [Reads: X Index] [Flags: ZNC]
	tsb $060E.w		; 0C 0E 06 ; Test and set bits $060E.w [Reads: Accumulator] [Flags: Z]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $066903.l		; 5C 03 69 06 ; Jump long to $066903.l [Flow: jump]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$0600.w		; 09 00 06 ; Logical OR #$0600.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	dec $2484.w		; CE 84 24 ; Decrement $2484.w [Flags: ZN]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpx #$00E6.w		; E0 E6 00 ; Compare #$00E6.w with X register [Reads: X Index] [Flags: ZNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr $103F.w		; 20 3F 10 ; Jump to subroutine at $103F.w [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000303.l		; 0F 03 03 00 ; OR accumulator with memory (long) $000303.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $1C.b,S		; A3 1C ; Load accumulator (stack relative) $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora [$2F.b]		; 07 2F ; OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $9E.b		; 02 9E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	.db $80, $58		; 80 58 ; Branch always to $80, $58 [Flow: branch]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $38.b		; C5 38 ; Compare $38.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($E800.w,X)		; 7C 00 E8 ; Jump indirect indexed to ($E800.w,X) [Reads: X Index] [Flow: jump]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$B8.b]		; 07 B8 ; OR accumulator with memory (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$6C.b]		; 07 6C ; OR accumulator with memory (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($72.b,S),Y		; 13 72 ; OR accumulator (stack relative indirect indexed) ($72.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $335C.w		; 2D 5C 33 ; Logical AND $335C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $601FA0.l		; 8F A0 1F 60 ; Store accumulator (long) $601FA0.l [Reads: Accumulator]
	ora $7C0072.l		; 0F 72 00 7C ; OR accumulator with memory (long) $7C0072.l [Writes: Accumulator] [Flags: ZN]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $98.b		; 64 98 ; Store zero to $98.b
	jsr ($7C00.w,X)		; FC 00 7C ; Jump to subroutine indirect indexed ($7C00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $3E		; 80 3E ; Branch always to $80, $3E [Flow: branch]
	cpy #$04FE.w		; C0 FE 04 ; Compare #$04FE.w with Y register [Reads: Y Index] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	bit $3CD8.w,X		; 3C D8 3C ; Test bits $3CD8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	bit $7CC0.w,X		; 3C C0 7C ; Test bits $7CC0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $FE18.w,X		; 3E 18 FE ; Rotate left $FE18.w,X [Reads: X Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $53.b		; 00 53 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $000705.l		; 0F 05 07 00 ; OR accumulator with memory (long) $000705.l [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$3B.b]		; 07 3B ; OR accumulator with memory (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $72.b		; 04 72 ; Test and set bits $72.b [Reads: Accumulator] [Flags: Z]
	tsb $046A.w		; 0C 6A 04 ; Test and set bits $046A.w [Reads: Accumulator] [Flags: Z]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FA.b,X)		; 01 FA ; Logical OR ($FA.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor ($FB.b,X)		; 41 FB ; Exclusive OR accumulator with memory ($FB.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc $08FF14.l,X		; FF 14 FF 08 ; Subtract with carry (long,X) $08FF14.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FC19.w,X		; FE 19 FC ; Increment memory $FC19.w,X [Reads: X Index] [Flags: ZN]
	sbc $F8.b,S		; E3 F8 ; Subtract stack-relative $F8.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	ora [$7D.b]		; 07 7D ; OR accumulator with memory (long) [$7D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $82, $97, $01		; 82 97 01 ; Branch always long to $82, $97, $01 [Flow: branch]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $DC01.w		; CE 01 DC ; Decrement $DC01.w [Flags: ZN]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$E0.b]		; 07 E0 ; OR accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $20BFC0.l,X		; 1F C0 BF 20 ; Logical OR long $20BFC0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$8040.w		; C0 40 80 ; Compare #$8040.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$3C00.w		; E0 00 3C ; Compare #$3C00.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$8C76.w		; C0 76 8C ; Compare #$8C76.w with Y register [Reads: Y Index] [Flags: ZNC]
	ror $FE98.w,X		; 7E 98 FE ; Rotate right $FE98.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	cpy #$80C0.w		; C0 C0 80 ; Compare #$80C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $1C		; 80 1C ; Branch always to $80, $1C [Flow: branch]
	cpx #$E01E.w		; E0 1E E0 ; Compare #$E01E.w with X register [Reads: X Index] [Flags: ZNC]
	rol $3EC0.w,X		; 3E C0 3E ; Rotate left $3EC0.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$40D0.w		; C0 D0 40 ; Compare #$40D0.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $297F40.l		; EF 40 7F 29 ; Subtract with carry (long) $297F40.l [Writes: Accumulator] [Flags: ZVNC]
	rol $FA18.w,X		; 3E 18 FA ; Rotate left $FA18.w,X [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $DF64.w		; 9C 64 DF ; Store zero to $DF64.w
	and ($FB.b,X)		; 21 FB ; Logical AND ($FB.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $B0.b		; 04 B0 ; Test and set bits $B0.b [Reads: Accumulator] [Flags: Z]
	ora $5010AF.l		; 0F AF 10 50 ; OR accumulator with memory (long) $5010AF.l [Writes: Accumulator] [Flags: ZN]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $A8.b,X		; F6 A8 ; Increment memory $A8.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc ($8E.b),Y		; F1 8E ; Subtract with carry ($8E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	cop $F7.b		; 02 F7 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	.db $90, $7F		; 90 7F ; Branch if carry clear to $90, $7F [Flow: branch]
	.db $10, $59		; 10 59 ; Branch if plus to $10, $59 [Flow: branch]
	asl $39.b,X		; 16 39 ; Arithmetic shift left $39.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $F2.b		; 26 F2 ; Rotate left $F2.b [Reads: Direct Page] [Flags: ZNC]
	sty $2CD2.w		; 8C D2 2C ; Store Y register to $2CD2.w [Reads: Y Index]
	sta $7770.w		; 8D 70 77 ; Store accumulator to $7770.w [Reads: Accumulator]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $00CF06.l		; 0F 06 CF 00 ; OR accumulator with memory (long) $00CF06.l [Writes: Accumulator] [Flags: ZN]
	sbc $06DF06.l		; EF 06 DF 06 ; Subtract with carry (long) $06DF06.l [Writes: Accumulator] [Flags: ZVNC]
	ror $9E0C.w,X		; 7E 0C 9E ; Rotate right $9E0C.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($707B.w)		; 6C 7B 70 ; Jump indirect to ($707B.w) [Flow: jump]
	adc $FD60.w,Y		; 79 60 FD ; Add $FD60.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	mvp $06,$5F		; 44 5F 06 ; Move block positive $06,$5F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora [$03.b],Y		; 17 03 ; OR accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $000700.l		; 0F 00 07 00 ; OR accumulator with memory (long) $000700.l [Writes: Accumulator] [Flags: ZN]
	ora $8F02.w		; 0D 02 8F ; Logical OR $8F02.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $F0, $9F		; F0 9F ; Branch if equal to $F0, $9F [Flow: branch]
	cpx #$40BB.w		; E0 BB 40 ; Compare #$40BB.w with X register [Reads: X Index] [Flags: ZNC]
	eor $1400.w,Y		; 59 00 14 ; Exclusive OR accumulator with memory $1400.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $020500.l		; 0F 00 05 02 ; OR accumulator with memory (long) $020500.l [Writes: Accumulator] [Flags: ZN]
	ora #$6C06.w		; 09 06 6C ; Logical OR #$6C06.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pea $F200.w		; F4 00 F2 ; Push absolute address $F200.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$C038.w		; C0 38 C0 ; Compare #$C038.w with Y register [Reads: Y Index] [Flags: ZNC]
	jmp ($F490.w)		; 6C 90 F4 ; Jump indirect to ($F490.w) [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($FE60.w,X)		; FC 60 FE ; Jump to subroutine indirect indexed ($FE60.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $D0, $E8		; D0 E8 ; Branch if not equal to $D0, $E8 [Flow: branch]
	.db $D0, $FB		; D0 FB ; Branch if not equal to $D0, $FB [Flow: branch]
	ora $EF.b		; 05 EF ; Logical OR $EF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta ($60.b),Y		; 91 60 ; Store accumulator ($60.b),Y [Reads: Accumulator, Direct Page, Y Index]
	jmp $4B30.w		; 4C 30 4B ; Jump to $4B30.w [Flow: jump]
	bit $3C.b,X		; 34 3C ; Test bits $3C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc ($EF.b,X)		; 61 EF ; Add with carry ($EF.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $F3		; 10 F3 ; Branch if plus to $10, $F3 [Flow: branch]
	jmp ($6EF1.w)		; 6C F1 6E ; Jump indirect to ($6EF1.w) [Flow: jump]
	jmp ($7B33.w,X)		; 7C 33 7B ; Jump indirect indexed to ($7B33.w,X) [Reads: X Index] [Flow: jump]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ora $9F1F20.l		; 0F 20 1F 9F ; OR accumulator with memory (long) $9F1F20.l [Writes: Accumulator] [Flags: ZN]
	stx $9A.b,Y		; 96 9A ; Store X register $9A.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	.db $90, $D4		; 90 D4 ; Branch if carry clear to $90, $D4 [Flow: branch]
	cpy #$C0DC.w		; C0 DC C0 ; Compare #$C0DC.w with Y register [Reads: Y Index] [Flags: ZNC]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	mvp $06,$F9		; 44 F9 06 ; Move block positive $06,$F9 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $1EE2.w,X		; 1D E2 1E ; OR accumulator with memory $1EE2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$F069.w		; E0 69 F0 ; Compare #$F069.w with X register [Reads: X Index] [Flags: ZNC]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pea $E834.w		; F4 34 E8 ; Push absolute address $E834.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	bit $BEE0.w,X		; 3C E0 BE ; Test bits $BEE0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	stz $EF.b		; 64 EF ; Store zero to $EF.b
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: ZNC]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $DA.b		; 24 DA ; Test bits $DA.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	mvn $38,$BF		; 54 BF 38 ; Move block negative $38,$BF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $9E.b		; 14 9E ; Test and reset bits $9E.b [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $001A02.l,X		; 7F 02 1A 00 ; Add long $001A02.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	lsr $8E34.w		; 4E 34 8E ; Logical shift right $8E34.w [Flags: ZNC]
	stz $85.b		; 64 85 ; Store zero to $85.b
	.db $42, $69		; 42 69 ; Reserved instruction
	asl $F2.b		; 06 F2 ; Arithmetic shift left $F2.b [Reads: Direct Page] [Flags: ZNC]
	jmp ($1867.w)		; 6C 67 18 ; Jump indirect to ($1867.w) [Flow: jump]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $38.b		; 04 38 ; Test and set bits $38.b [Reads: Accumulator] [Flags: Z]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$9E.b],Y		; 17 9E ; OR accumulator with memory (long indexed) [$9E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $38BD.w,X		; 1D BD 38 ; OR accumulator with memory $38BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$68.b]		; 07 68 ; OR accumulator with memory (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$E3.b],Y		; 37 E3 ; AND accumulator with memory (long indexed) [$E3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($78C7.w,X)		; 7C C7 78 ; Jump indirect indexed to ($78C7.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$7000.w		; E0 00 70 ; Compare #$7000.w with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp $CA70.w		; 4C 70 CA ; Jump to $CA70.w [Flow: jump]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	cpx #$8061.w		; E0 61 80 ; Compare #$8061.w with X register [Reads: X Index] [Flags: ZNC]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Accumulator, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$9000.w		; E0 00 90 ; Compare #$9000.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$C0BC.w		; E0 BC C0 ; Compare #$C0BC.w with X register [Reads: X Index] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpy $F1.b		; C4 F1 ; Compare $F1.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	asl $1EE1.w		; 0E E1 1E ; Arithmetic shift left $1EE1.w [Flags: ZNC]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Accumulator, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $3804.w		; 0C 04 38 ; Test and set bits $3804.w [Reads: Accumulator] [Flags: Z]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$9E.b],Y		; 17 9E ; OR accumulator with memory (long indexed) [$9E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $38BD.w,X		; 1D BD 38 ; OR accumulator with memory $38BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$68.b]		; 07 68 ; OR accumulator with memory (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$E3.b],Y		; 37 E3 ; AND accumulator with memory (long indexed) [$E3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($78C7.w,X)		; 7C C7 78 ; Jump indirect indexed to ($78C7.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$7000.w		; E0 00 70 ; Compare #$7000.w with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp $CA70.w		; 4C 70 CA ; Jump to $CA70.w [Flow: jump]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	cpx #$8061.w		; E0 61 80 ; Compare #$8061.w with X register [Reads: X Index] [Flags: ZNC]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Accumulator, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$9000.w		; E0 00 90 ; Compare #$9000.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$C0BC.w		; E0 BC C0 ; Compare #$C0BC.w with X register [Reads: X Index] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpy $F1.b		; C4 F1 ; Compare $F1.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	asl $1EE1.w		; 0E E1 1E ; Arithmetic shift left $1EE1.w [Flags: ZNC]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Accumulator, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $1A03.w		; 0E 03 1A ; Arithmetic shift left $1A03.w [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and ($13.b)		; 32 13 ; AND accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($13.b)		; 32 13 ; AND accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $17.b,X		; 36 17 ; Rotate left $17.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jmp $00001F.l		; 5C 1F 00 00 ; Jump long to $00001F.l [Flow: jump]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1502.w		; 0D 02 15 ; Logical OR $1502.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $1E2D.w		; 0E 2D 1E ; Arithmetic shift left $1E2D.w [Flags: ZNC]
	and $291E.w		; 2D 1E 29 ; Logical AND $291E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $3C63.w,X		; 1E 63 3C ; Arithmetic shift left $3C63.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $44		; 80 44 ; Branch always to $80, $44 [Flow: branch]
	.db $80, $4C		; 80 4C ; Branch always to $80, $4C [Flow: branch]
	.db $80, $5E		; 80 5E ; Branch always to $80, $5E [Flow: branch]
	sty $9D.b		; 84 9D ; Store Y register to $9D.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $C4		; 30 C4 ; Branch if minus to $30, $C4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy $DA30.w		; CC 30 DA ; Compare $DA30.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $6097.w		; 20 97 60 ; Jump to subroutine at $6097.w [Writes: Stack Pointer] [Flow: call]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora $000F00.l		; 0F 00 0F 00 ; OR accumulator with memory (long) $000F00.l [Writes: Accumulator] [Flags: ZN]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $060F06.l		; 0F 06 0F 06 ; OR accumulator with memory (long) $060F06.l [Writes: Accumulator] [Flags: ZN]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $51C1.w,X		; 3E C1 51 ; Rotate left $51C1.w,X [Reads: X Index] [Flags: ZNC]
	stx $009F.w		; 8E 9F 00 ; Store X register to $009F.w [Reads: X Index]
	ora $030701.l		; 0F 01 07 03 ; OR accumulator with memory (long) $030701.l [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.INDEX 8
	sep #$DC		; E2 DC
	.db $D0, $81		; D0 81 ; Branch if not equal to $D0, $81 [Flow: branch]
	sta ($0E.b),Y		; 91 0E ; Store accumulator ($0E.b),Y [Reads: Accumulator, Direct Page, Y Index]
	asl $0700.w		; 0E 00 07 ; Arithmetic shift left $0700.w [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $F8		; 90 F8 ; Branch if carry clear to $90, $F8 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($72.b),Y		; 11 72 ; OR accumulator with memory ($72.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $237C.w		; 0D 7C 23 ; Logical OR $237C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $003B30.l,X		; 5F 30 3B 00 ; Exclusive OR accumulator with memory (long,X) $003B30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $0F		; 90 0F ; Branch if carry clear to $90, $0F [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora [$62.b]		; 07 62 ; OR accumulator with memory (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	tsb $037C.w		; 0C 7C 03 ; Test and set bits $037C.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$74.b		; C0 74 ; Compare #$74.b with Y register [Reads: Y Index] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jmp ($1C90.w)		; 6C 90 1C ; Jump indirect to ($1C90.w) [Flow: jump]
	cpx #$FE.b		; E0 FE ; Compare #$FE.b with X register [Reads: X Index] [Flags: ZNC]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	trb $1C3A.w		; 1C 3A 1C ; Test and reset bits $1C3A.w [Reads: Accumulator] [Flags: Z]
	trb $0C00.w		; 1C 00 0C ; Test and reset bits $0C00.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	cpx #$4C.b		; E0 4C ; Compare #$4C.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $1804.w		; 20 04 18 ; Jump to subroutine at $1804.w [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpx #$E6.b		; E0 E6 ; Compare #$E6.b with X register [Reads: X Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$16.b]		; 07 16 ; OR accumulator with memory (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0619.w		; 09 19 06 ; Logical OR #$0619.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $3F11.w,X		; 3E 11 3F ; Rotate left $3F11.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0638.w		; 09 38 06 ; Logical OR #$0638.w with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $1F03.w,X		; 3C 03 1F ; Test bits $1F03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E4		; 80 E4 ; Branch always to $80, $E4 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $FCE0.w		; 1C E0 FC ; Test and reset bits $FCE0.w [Reads: Accumulator] [Flags: Z]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3C72.w		; 1C 72 3C ; Test and reset bits $3C72.w [Reads: Accumulator] [Flags: Z]
	bit $C800.w,X		; 3C 00 C8 ; Test bits $C800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $30, $04		; 30 04 ; Branch if minus to $30, $04 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	trb $FEE0.w		; 1C E0 FE ; Test and reset bits $FEE0.w [Reads: Accumulator] [Flags: Z]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $33		; 10 33 ; Branch if plus to $10, $33 [Flow: branch]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	and $001F10.l,X		; 3F 10 1F 00 ; AND accumulator with memory (long,X) $001F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $200F.w		; 20 0F 20 ; Jump to subroutine at $200F.w [Writes: Stack Pointer] [Flow: call]
	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C8.b,X		; 34 C8 ; Test bits $C8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cpy $3C30.w		; CC 30 3C ; Compare $3C30.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $1CFE.w		; 0C FE 1C ; Test and set bits $1CFE.w [Reads: Accumulator] [Flags: Z]
	rol $1C1C.w,X		; 3E 1C 1C ; Rotate left $1C1C.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $3630.w		; 0C 30 36 ; Test and set bits $3630.w [Reads: Accumulator] [Flags: Z]
	cpy #$E6.b		; C0 E6 ; Compare #$E6.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $C6		; 10 C6 ; Branch if plus to $10, $C6 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $7E30.w,X		; BC 30 7E ; Load Y register $7E30.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	jsl $0B032F.l		; 22 2F 03 0B ; Jump to subroutine long $0B032F.l [Writes: Stack Pointer] [Flow: call]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $5D		; 70 5D ; Branch if overflow set to $70, $5D [Flow: branch]
	jsr $002C.w		; 20 2C 00 ; Jump to subroutine at $002C.w [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $BA.b		; 04 BA ; Test and set bits $BA.b [Reads: Accumulator] [Flags: Z]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $C0FE.w		; 9C FE C0 ; Store zero to $C0FE.w
	inc $60.b,X		; F6 60 ; Increment memory $60.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $3A04.w,X		; FD 04 3A ; Subtract with carry $3A04.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldx $AE40.w		; AE 40 AE ; Load $AE40.w into X register [Writes: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $3804.w		; 1C 04 38 ; Test and reset bits $3804.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $7E30.w,X		; BC 30 7E ; Load Y register $7E30.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	jsl $0B032F.l		; 22 2F 03 0B ; Jump to subroutine long $0B032F.l [Writes: Stack Pointer] [Flow: call]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $0000.w		; 2C 00 00 ; Test bits $0000.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cmp $205D70.l		; CF 70 5D 20 ; Compare accumulator (long) $205D70.l [Reads: Accumulator] [Flags: ZNC]
	bit $0A00.w		; 2C 00 0A ; Test bits $0A00.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2C.b,S		; 03 2C ; OR accumulator with stack relative $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $0000.w		; 2C 00 00 ; Test bits $0000.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ldx $BA04.w,Y		; BE 04 BA ; Load X register $BA04.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $BB.b		; 00 BB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FD		; 80 FD ; Branch always to $80, $FD [Flow: branch]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $001C.w		; 4C 1C 00 ; Jump to $001C.w [Flow: jump]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldx $AD40.w		; AE 40 AD ; Load $AD40.w into X register [Writes: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	stx $7C02.w		; 8E 02 7C ; Store X register to $7C02.w [Reads: X Index]
	jmp $0000.w		; 4C 00 00 ; Jump to $0000.w [Flow: jump]
	eor $206908.l		; 4F 08 69 20 ; Exclusive OR accumulator with memory (long) $206908.l [Writes: Accumulator] [Flags: ZN]
	rol $3F0A.w		; 2E 0A 3F ; Rotate left $3F0A.w [Flags: ZNC]
	ora $081D.w,Y		; 19 1D 08 ; OR accumulator with memory $081D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $77.b,S		; 03 77 ; OR accumulator with stack relative $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $183530.l,X		; 5F 30 35 18 ; Exclusive OR accumulator with memory (long,X) $183530.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: ZNC]
	ora $0A.b,X		; 15 0A ; OR accumulator with memory $0A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $3B.b,S		; 03 3B ; OR accumulator with stack relative $3B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($BE.b)		; 12 BE ; OR accumulator with memory (indirect) ($BE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $ADEF.w		; 1C EF AD ; Test and reset bits $ADEF.w [Reads: Accumulator] [Flags: Z]
	cmp $60FFCC.l		; CF CC FF 60 ; Compare accumulator (long) $60FFCC.l [Reads: Accumulator] [Flags: ZNC]
	sbc [$01.b],Y		; F7 01 ; Subtract with carry (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy $ED8C.w,X		; BC 8C ED ; Load Y register $ED8C.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$A6.b		; C0 A6 ; Compare #$A6.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor $003E01.l,X		; 5F 01 3E 00 ; Exclusive OR accumulator with memory (long,X) $003E01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sty $B100.w		; 8C 00 B1 ; Store Y register to $B100.w [Reads: Y Index]
	ora ($8C.b,X)		; 01 8C ; Logical OR ($8C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sty $0000.w		; 8C 00 00 ; Store Y register to $0000.w [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1824.w		; 20 24 18 ; Jump to subroutine at $1824.w [Writes: Stack Pointer] [Flow: call]
	asl $0C00.w,X		; 1E 00 0C ; Arithmetic shift left $0C00.w,X [Reads: X Index] [Flags: ZNC]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $183C.w		; 20 3C 18 ; Jump to subroutine at $183C.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	tsb $18E4.w		; 0C E4 18 ; Test and set bits $18E4.w [Reads: Accumulator] [Flags: Z]
	jmp ($0080.w,X)		; 7C 80 00 ; Jump indirect indexed to ($0080.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	tsb $D83C.w		; 0C 3C D8 ; Test and set bits $D83C.w [Reads: Accumulator] [Flags: Z]
	bit $00C0.w,X		; 3C C0 00 ; Test bits $00C0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3048.w		; 20 48 30 ; Jump to subroutine at $3048.w [Writes: Stack Pointer] [Flow: call]
	eor $003F20.l,X		; 5F 20 3F 00 ; Exclusive OR accumulator with memory (long,X) $003F20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	jsr $3078.w		; 20 78 30 ; Jump to subroutine at $3078.w [Writes: Stack Pointer] [Flow: call]
	jmp ($3C2B.w,X)		; 7C 2B 3C ; Jump indirect indexed to ($3C2B.w,X) [Reads: X Index] [Flow: jump]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $98		; 30 98 ; Branch if minus to $30, $98 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $B0, $F8		; B0 F8 ; Branch if carry set to $B0, $F8 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$08.b],Y		; 37 08 ; AND accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $0B3F1B.l,X		; 3F 1B 3F 0B ; AND accumulator with memory (long,X) $0B3F1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $6700.w,X		; 3E 00 67 ; Rotate left $6700.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	cmp [$38.b]		; C7 38 ; Compare accumulator (long) [$38.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5A3F.w		; 20 3F 5A ; Jump to subroutine at $5A3F.w [Writes: Stack Pointer] [Flow: call]
	sbc $40BE3A.l,X		; FF 3A BE 40 ; Subtract with carry (long,X) $40BE3A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $000014.l,X		; 1F 14 00 00 ; Logical OR long $000014.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0E0F00.l		; 0F 00 0F 0E ; OR accumulator with memory (long) $0E0F00.l [Writes: Accumulator] [Flags: ZN]
	ora $203F12.l,X		; 1F 12 3F 20 ; Logical OR long $203F12.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $010149.l,X		; 7F 49 01 01 ; Add long $010149.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $120E.w		; 0E 0E 12 ; Arithmetic shift left $120E.w [Flags: ZNC]
	ora ($20.b)		; 12 20 ; OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $4949.w		; 20 49 49 ; Jump to subroutine at $4949.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsr ($FC84.w,X)		; FC 84 FC ; Jump to subroutine indirect indexed ($FC84.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $5820.w		; 20 20 58 ; Jump to subroutine at $5820.w [Writes: Stack Pointer] [Flow: call]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	jsr ($FEA0.w,X)		; FC A0 FE ; Jump to subroutine indirect indexed ($FEA0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta ($7F.b),Y		; 91 7F ; Store accumulator ($7F.b),Y [Reads: Accumulator, Direct Page, Y Index]
	eor ($00.b)		; 52 00 ; Exclusive OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$BC.b		; A0 BC ; Load #$BC.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $90, $97		; 90 97 ; Branch if carry clear to $90, $97 [Flow: branch]
	eor ($57.b)		; 52 57 ; Exclusive OR accumulator with memory (indirect) ($57.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E04.w		; 0C 04 1E ; Test and set bits $1E04.w [Reads: Accumulator] [Flags: Z]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc #$C23E.w		; E9 3E C2 ; Subtract #$C23E.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$02F9.w		; 09 F9 02 ; Logical OR #$02F9.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sep #$00		; E2 00 ; Set processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($FCA0.w,X)		; FC A0 FC ; Jump to subroutine indirect indexed ($FCA0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Accumulator, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $A0		; 70 A0 ; Branch if overflow set to $70, $A0 [Flow: branch]
	ldy $0F00.w,X		; BC 00 0F ; Load Y register $0F00.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$87.b]		; 87 87 ; Store accumulator (long) [$87.b] [Reads: Accumulator, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F20.w,X		; 1D 20 1F ; OR accumulator with memory $1F20.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($1F.b,X)		; E1 1F ; Subtract with carry ($1F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($FF.b),Y		; F1 FF ; Subtract with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $00.b		; C5 00 ; Compare $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $01		; 30 01 ; Branch if minus to $30, $01 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($C5.b),Y		; F1 C5 ; Subtract with carry ($C5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00.b		; E5 00 ; Subtract $00.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $607C.w		; 1C 7C 60 ; Test and reset bits $607C.w [Reads: Accumulator] [Flags: Z]
	sbc $0082.w,X		; FD 82 00 ; Subtract with carry $0082.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $6060.w		; 1C 60 60 ; Test and reset bits $6060.w [Reads: Accumulator] [Flags: Z]
	sty $83.b		; 84 83 ; Store Y register to $83.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000100.l		; 0F 00 01 00 ; OR accumulator with memory (long) $000100.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $0718.w		; 0C 18 07 ; Test and set bits $0718.w [Reads: Accumulator] [Flags: Z]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F400.w,X)		; FC 00 F4 ; Jump to subroutine indirect indexed ($F400.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $F8F0.w		; 0C F0 F8 ; Test and set bits $F8F0.w [Reads: Accumulator] [Flags: Z]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	ora $0F001F.l		; 0F 1F 00 0F ; OR accumulator with memory (long) $0F001F.l [Writes: Accumulator] [Flags: ZN]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $101020.l		; 0F 20 10 10 ; OR accumulator with memory (long) $101020.l [Writes: Accumulator] [Flags: ZN]
	ora $0F000F.l		; 0F 0F 00 0F ; OR accumulator with memory (long) $0F000F.l [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $30.b,S		; 03 30 ; OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $DC10.w		; EC 10 DC ; Compare $DC10.w with X register [Reads: X Index] [Flags: ZNC]
	jsr $C038.w		; 20 38 C0 ; Jump to subroutine at $C038.w [Writes: Stack Pointer] [Flow: call]
	jsr ($EC08.w,X)		; FC 08 EC ; Jump to subroutine indirect indexed ($EC08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$14.b		; E0 14 ; Compare #$14.b with X register [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3C.b),Y		; 11 3C ; OR accumulator with memory ($3C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $38.b		; 24 38 ; Test bits $38.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr $0020.w		; 20 20 00 ; Jump to subroutine at $0020.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $1C24.w,X		; 3C 24 1C ; Test bits $1C24.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $0004.w		; 0C 04 00 ; Test and set bits $0004.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $8EFEAB.l,X		; FF AB FE 8E ; Subtract with carry (long,X) $8EFEAB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	ldy #$80.b		; A0 80 ; Load #$80.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	stx $488E.w		; 8E 8E 48 ; Store X register to $488E.w [Reads: X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $3EA2.w,X		; FE A2 3E ; Increment memory $3EA2.w,X [Reads: X Index] [Flags: ZN]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: ZNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$06.b		; A2 06 ; Load #$06.b into X register [Writes: X Index] [Flags: ZN]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $3F		; 50 3F ; Branch if overflow clear to $50, $3F [Flow: branch]
	and $1F.b		; 25 1F ; Logical AND $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $090F.w,X		; 1E 0F 09 ; Arithmetic shift left $090F.w,X [Reads: X Index] [Flags: ZNC]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	and $25.b		; 25 25 ; Logical AND $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $091E.w,X		; 1E 1E 09 ; Arithmetic shift left $091E.w,X [Reads: X Index] [Flags: ZNC]
	ora #$0606.w		; 09 06 06 ; Logical OR #$0606.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F8D4.w,X)		; FC D4 F8 ; Jump to subroutine indirect indexed ($F8D4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($D4.b)		; D4 D4 ; Push effective indirect address ($D4.b) [Reads: Direct Page] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $617F73.l,X		; 7F 73 7F 61 ; Add long $617F73.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $687F40.l,X		; 7F 40 7F 68 ; Add long $687F40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $0C0F38.l,X		; 3F 38 0F 0C ; AND accumulator with memory (long,X) $0C0F38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($61.b,X)		; 61 61 ; Add with carry ($61.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $020C.w		; 0C 0C 02 ; Test and set bits $020C.w [Reads: Accumulator] [Flags: Z]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	stx $FE.b		; 86 FE ; Store X register to $FE.b [Reads: X Index]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FC84FC.l		; 22 FC 84 FC ; Jump to subroutine long $FC84FC.l [Writes: Stack Pointer] [Flow: call]
	sty $E0.b,X		; 94 E0 ; Store Y register $E0.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $86.b		; 86 86 ; Store X register to $86.b [Reads: X Index]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $848422.l		; 22 22 84 84 ; Jump to subroutine long $848422.l [Writes: Stack Pointer] [Flow: call]
	sty $94.b,X		; 94 94 ; Store Y register $94.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($3F4B.w,X)		; 7C 4B 3F ; Jump indirect indexed to ($3F4B.w,X) [Reads: X Index] [Flow: jump]
	.db $30, $5F		; 30 5F ; Branch if minus to $30, $5F [Flow: branch]
	eor ($0F.b)		; 52 0F ; Exclusive OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $3B3B.w		; 0C 3B 3B ; Test and set bits $3B3B.w [Reads: Accumulator] [Flags: Z]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor $523030.l		; 4F 30 30 52 ; Exclusive OR accumulator with memory (long) $523030.l [Writes: Accumulator] [Flags: ZN]
	eor ($0C.b)		; 52 0C ; Exclusive OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $3B3B.w		; 0C 3B 3B ; Test and set bits $3B3B.w [Reads: Accumulator] [Flags: Z]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rep #$00		; C2 00 ; Reset processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	inc $FE08.w,X		; FE 08 FE ; Increment memory $FE08.w,X [Reads: X Index] [Flags: ZN]
	ora ($FC.b)		; 12 FC ; OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $F8.b		; 84 F8 ; Store Y register to $F8.b [Reads: Y Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($40.b),Y		; 71 40 ; Add with carry ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $20.b		; 26 20 ; Rotate left $20.b [Reads: Direct Page] [Flags: ZNC]
	stx $3E88.w		; 8E 88 3E ; Store X register to $3E88.w [Reads: X Index]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $8820.w		; 20 20 88 ; Jump to subroutine at $8820.w [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $84.b		; E6 84 ; Increment $84.b [Reads: Direct Page] [Flags: ZN]
	jmp ($1C78.w,X)		; 7C 78 1C ; Jump indirect indexed to ($1C78.w,X) [Reads: X Index] [Flow: jump]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $A0		; F0 A0 ; Branch if equal to $F0, $A0 [Flow: branch]
	jmp ($FA42.w,X)		; 7C 42 FA ; Jump indirect indexed to ($FA42.w,X) [Reads: X Index] [Flow: jump]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy #$B0.b		; A0 B0 ; Load #$B0.b into Y register [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lsr $1712.w		; 4E 12 17 ; Logical shift right $1712.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $7F.b		; 02 7F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $D000.w,Y		; 79 00 D0 ; Add $D000.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $5306.w		; 0E 06 53 ; Arithmetic shift left $5306.w [Flags: ZNC]
	ora $A303AC.l		; 0F AC 03 A3 ; OR accumulator with memory (long) $A303AC.l [Writes: Accumulator] [Flags: ZN]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora #$5C07.w		; 09 07 5C ; Logical OR #$5C07.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $EF.b,S		; 03 EF ; OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $E3		; 10 E3 ; Branch if plus to $10, $E3 [Flow: branch]
	trb $0FB0.w		; 1C B0 0F ; Test and reset bits $0FB0.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $5E		; 10 5E ; Branch if plus to $10, $5E [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	and $C5C0.w,X		; 3D C0 C5 ; AND accumulator with memory $C5C0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E8.b		; C0 E8 ; Compare #$E8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $B6		; F0 B6 ; Branch if equal to $F0, $B6 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sbc $38C700.l,X		; FF 00 C7 38 ; Subtract with carry (long,X) $38C700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00F0.w		; 0D F0 00 ; Logical OR $00F0.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $00.b		; 64 00 ; Store zero to $00.b
	lda $40D604.l		; AF 04 D6 40 ; Load long $40D604.l into accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $071800.l		; 0F 00 18 07 ; OR accumulator with memory (long) $071800.l [Writes: Accumulator] [Flags: ZN]
	stz $1B.b		; 64 1B ; Store zero to $1B.b
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	.db $10, $B9		; 10 B9 ; Branch if plus to $10, $B9 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$08.b		; C0 08 ; Compare #$08.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $26		; 10 26 ; Branch if plus to $10, $26 [Flow: branch]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $026B.w		; 20 6B 02 ; Jump to subroutine at $026B.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$26.b		; E0 26 ; Compare #$26.b with X register [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp [$08.b],Y		; D7 08 ; Compare accumulator (long indexed) [$08.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sta $0100.w,X		; 9D 00 01 ; Store accumulator to $0100.w,X [Reads: Accumulator, X Index]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $30.b		; 04 30 ; Test and set bits $30.b [Reads: Accumulator] [Flags: Z]
	tsb $0C12.w		; 0C 12 0C ; Test and set bits $0C12.w [Reads: Accumulator] [Flags: Z]
	ora $1002.w		; 0D 02 10 ; Logical OR $1002.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $0C1629.l		; 0F 29 16 0C ; OR accumulator with memory (long) $0C1629.l [Writes: Accumulator] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $3C14.w,X		; 3C 14 3C ; Test bits $3C14.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsb $0C1E.w		; 0C 1E 0C ; Test and set bits $0C1E.w [Reads: Accumulator] [Flags: Z]
	tsb $1003.w		; 0C 03 10 ; Test and set bits $1003.w [Reads: Accumulator] [Flags: Z]
	ora $000629.l		; 0F 29 06 00 ; OR accumulator with memory (long) $000629.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	inc $00F8.w,X		; FE F8 00 ; Increment memory $00F8.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3D.b,X)		; 01 3D ; Logical OR ($3D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $7A1A.w,X		; 3D 1A 7A ; AND accumulator with memory $7A1A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3C.b,X)		; 01 3C ; Logical OR ($3C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($78.b,X)		; 01 78 ; Logical OR ($78.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$C5.b]		; 07 C5 ; OR accumulator with memory (long) [$C5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($77.b,X)		; 01 77 ; Logical OR ($77.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $80, $3F		; 80 3F ; Branch always to $80, $3F [Flow: branch]
	cpy $0C.b		; C4 0C ; Compare $0C.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$C6.b]		; 07 C6 ; OR accumulator with memory (long) [$C6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $37.b,S		; 03 37 ; OR accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora #$00F0.w		; 09 F0 00 ; Logical OR #$00F0.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $FC		; D0 FC ; Branch if not equal to $D0, $FC [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $EA08.w		; 2C 08 EA ; Test bits $EA08.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ldy $BA.b		; A4 BA ; Load $BA.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	mvp $00,$00		; 44 00 00 ; Move block positive $00,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $F0, $C4		; F0 C4 ; Branch if equal to $F0, $C4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	pea $5E18.w		; F4 18 5E ; Push absolute address $5E18.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp ($3F.b,X)		; C1 3F ; Compare accumulator ($3F.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	bit $020F.w,X		; 3C 0F 02 ; Test bits $020F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $060708.l		; 0F 08 07 06 ; OR accumulator with memory (long) $060708.l [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	bit $023C.w,X		; 3C 3C 02 ; Test bits $023C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	sbc $19FF80.l,X		; FF 80 FF 19 ; Subtract with carry (long,X) $19FF80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $F806.w,X		; FE 06 F8 ; Increment memory $F806.w,X [Reads: X Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	ora $0619.w,Y		; 19 19 06 ; OR accumulator with memory $0619.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $78.b		; 06 78 ; Arithmetic shift left $78.b [Reads: Direct Page] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FF03.w,X		; FE 03 FF ; Increment memory $FF03.w,X [Reads: X Index] [Flags: ZN]
	sta ($7F.b),Y		; 91 7F ; Store accumulator ($7F.b),Y [Reads: Accumulator, Direct Page, Y Index]
	stz $3F.b		; 64 3F ; Store zero to $3F.b
	bit $0203.w,X		; 3C 03 02 ; Test bits $0203.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($91.b),Y		; 91 91 ; Store accumulator ($91.b),Y [Reads: Accumulator, Direct Page, Y Index]
	stz $64.b		; 64 64 ; Store zero to $64.b
	bit $023C.w,X		; 3C 3C 02 ; Test bits $023C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($BE.b,X)		; 01 BE ; Logical OR ($BE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ldx #$18.b		; A2 18 ; Load #$18.b into X register [Writes: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ldx #$A2.b		; A2 A2 ; Load #$A2.b into X register [Writes: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFA3.w,X		; FD A3 FF ; Subtract with carry $FFA3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $6F		; 70 6F ; Branch if overflow set to $70, $6F [Flow: branch]
	asl $0007.w		; 0E 07 00 ; Arithmetic shift left $0007.w [Flags: ZNC]
	and [$27.b]		; 27 27 ; AND accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($A3.b,X)		; A1 A3 ; Load accumulator ($A3.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	asl $000E.w		; 0E 0E 00 ; Arithmetic shift left $000E.w [Flags: ZNC]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $05FF85.l,X		; FF 85 FF 05 ; Subtract with carry (long,X) $05FF85.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FC32.w,X		; FE 32 FC ; Increment memory $FC32.w,X [Reads: X Index] [Flags: ZN]
	cpy $0000.w		; CC 00 00 ; Compare $0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $000C.w		; 0C 0C 00 ; Test and set bits $000C.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $05.b		; C5 05 ; Compare $05.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	ora $32.b		; 05 32 ; Logical OR $32.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($CC.b)		; 32 CC ; AND accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy $0000.w		; CC 00 00 ; Compare $0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $000C.w		; 0C 0C 00 ; Test and set bits $000C.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $187E29.l,X		; 7F 29 7E 18 ; Add long $187E29.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $3F00.w,X		; 7E 00 3F ; Rotate right $3F00.w,X [Reads: X Index] [Flags: ZNC]
	and $3F.b		; 25 3F ; Logical AND $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $0047.w		; 20 47 00 ; Jump to subroutine at $0047.w [Writes: Stack Pointer] [Flow: call]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $AF.b,S		; 03 AF ; OR accumulator with stack relative $AF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $50		; 10 50 ; Branch if plus to $10, $50 [Flow: branch]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $31.b		; 24 31 ; Test bits $31.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	jsr $0006.w		; 20 06 00 ; Jump to subroutine at $0006.w [Writes: Stack Pointer] [Flow: call]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc [$02.b],Y		; F7 02 ; Subtract with carry (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $7D94.w,X		; FE 94 7D ; Increment memory $7D94.w,X [Reads: X Index] [Flags: ZN]
	ora $064F.w,Y		; 19 4F 06 ; OR accumulator with memory $064F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ldx $FC80.w,Y		; BE 80 FC ; Load X register $FC80.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc ($30.b),Y		; F1 30 ; Subtract with carry ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $82, $80, $F5		; 82 80 F5 ; Branch always long to $82, $80, $F5 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $40.b		; 06 40 ; Arithmetic shift left $40.b [Reads: Direct Page] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	ror $20.b		; 66 20 ; Rotate right $20.b [Reads: Direct Page] [Flags: ZNC]
	adc ($31.b,S),Y		; 73 31 ; Add with carry (stack relative indirect indexed) ($31.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $4F7F5F.l,X		; FF 5F 7F 4F ; Subtract with carry (long,X) $4F7F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $105F23.l,X		; 3F 23 5F 10 ; AND accumulator with memory (long,X) $105F23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $010106.l,X		; 1F 06 01 01 ; Logical OR long $010106.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor [$40.b]		; 47 40 ; Exclusive OR accumulator with memory (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$20.b]		; 27 20 ; AND accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $04.b		; 66 04 ; Rotate right $04.b [Reads: Direct Page] [Flags: ZNC]
	lsr $04.b		; 46 04 ; Logical shift right $04.b [Reads: Direct Page] [Flags: ZNC]
	cmp $F0FFC2.l		; CF C2 FF F0 ; Compare accumulator (long) $F0FFC2.l [Reads: Accumulator] [Flags: ZNC]
	inc $DFC4.w,X		; FE C4 DF ; Increment memory $DFC4.w,X [Reads: X Index] [Flags: ZN]
	asl $EC.b		; 06 EC ; Arithmetic shift left $EC.b [Reads: Direct Page] [Flags: ZNC]
	tsb $C0.b		; 04 C0 ; Test and set bits $C0.b [Reads: Accumulator] [Flags: Z]
	cpy #$DA.b		; C0 DA ; Compare #$DA.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $E8.b		; 02 E8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $06,$0E		; 44 0E 06 ; Move block positive $06,$0E [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0C00.w		; 0C 00 0C ; Test and set bits $0C00.w [Reads: Accumulator] [Flags: Z]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $06F9.w		; 0C F9 06 ; Test and set bits $06F9.w [Reads: Accumulator] [Flags: Z]
	ror $3F31.w,X		; 7E 31 3F ; Rotate right $3F31.w,X [Reads: X Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$F0.b],Y		; 17 F0 ; OR accumulator with memory (long indexed) [$F0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$0678.w		; 09 78 06 ; Logical OR #$0678.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $0301.w,X		; 3E 01 03 ; Rotate left $0301.w,X [Reads: X Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $FE		; 70 FE ; Branch if overflow set to $70, $FE [Flow: branch]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $E0F0.w		; 20 F0 E0 ; Jump to subroutine at $E0F0.w [Writes: Stack Pointer] [Flow: call]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $8C7E76.l,X		; FF 76 7E 8C ; Subtract with carry (long,X) $8C7E76.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $3020.w		; 1C 20 30 ; Test and reset bits $3020.w [Reads: Accumulator] [Flags: Z]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FB.b,X		; 15 FB ; OR accumulator with memory $FB.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	stz $7D.b,X		; 74 7D ; Store zero to $7D.b,X [Reads: X Index]
	and ($7E.b)		; 32 7E ; AND accumulator with memory (indirect) ($7E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F8.b,S		; 03 F8 ; OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $78.b,S		; 03 78 ; OR accumulator with stack relative $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7C.b		; 05 7C ; Logical OR $7C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $7E.b		; 02 7E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $CB.b		; 04 CB ; Test and set bits $CB.b [Reads: Accumulator] [Flags: Z]
	and ($8D.b)		; 32 8D ; AND accumulator with memory (indirect) ($8D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $9C.b,X		; 75 9C ; Add $9C.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $00FF43.l,X		; BF 43 FF 00 ; Load long $00FF43.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cmp ($7D.b,X)		; C1 7D ; Compare accumulator ($7D.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	.db $B0, $FA		; B0 FA ; Branch if carry set to $B0, $FA [Flow: branch]
	.db $70, $F7		; 70 F7 ; Branch if overflow set to $70, $F7 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	jsr ($FF50.w,X)		; FC 50 FF ; Jump to subroutine indirect indexed ($FF50.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $00FF10.l,X		; FF 10 FF 00 ; Subtract with carry (long,X) $00FF10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $78.b		; 86 78 ; Store X register to $78.b [Reads: X Index]
	sbc $8100.w,X		; FD 00 81 ; Subtract with carry $8100.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E6		; 80 E6 ; Branch always to $80, $E6 [Flow: branch]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $81.b		; 02 81 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $3C42.w,X		; 7E 42 3C ; Rotate right $3C42.w,X [Reads: X Index] [Flags: ZNC]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: ZNC]
	jsr ($F000.w,X)		; FC 00 F0 ; Jump to subroutine indirect indexed ($F000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $003C.w		; 0C 3C 00 ; Test and set bits $003C.w [Reads: Accumulator] [Flags: Z]
	eor $609F30.l		; 4F 30 9F 60 ; Exclusive OR accumulator with memory (long) $609F30.l [Writes: Accumulator] [Flags: ZN]
	ldx $0341.w,Y		; BE 41 03 ; Load X register $0341.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$13.b]		; 07 13 ; OR accumulator with memory (long) [$13.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and [$F0.b],Y		; 37 F0 ; AND accumulator with memory (long indexed) [$F0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $805FE0.l		; 6F E0 5F 80 ; Add with carry (long) $805FE0.l [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $003C.w		; 20 3C 00 ; Jump to subroutine at $003C.w [Writes: Stack Pointer] [Flow: call]
	sbc ($0C.b)		; F2 0C ; Subtract with carry (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $0DE6.w,Y		; 19 E6 0D ; OR accumulator with memory $0DE6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($80.b)		; F2 80 ; Subtract with carry (indirect) ($80.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	cpx #$D8.b		; E0 D8 ; Compare #$D8.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $C03C.w		; 20 3C C0 ; Jump to subroutine at $C03C.w [Writes: Stack Pointer] [Flow: call]
	asl $0FEC.w,X		; 1E EC 0F ; Arithmetic shift left $0FEC.w,X [Reads: X Index] [Flags: ZNC]
	inc $07.b,X		; F6 07 ; Increment memory $07.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F00.w		; 0E 00 1F ; Arithmetic shift left $1F00.w [Flags: ZNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1C7B.w		; 20 7B 1C ; Jump to subroutine at $1C7B.w [Writes: Stack Pointer] [Flow: call]
	adc $007F00.l,X		; 7F 00 7F 00 ; Add long $007F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F00.w		; 0E 00 1F ; Arithmetic shift left $1F00.w [Flags: ZNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $205F.w		; 20 5F 20 ; Jump to subroutine at $205F.w [Writes: Stack Pointer] [Flow: call]
	eor $000030.l		; 4F 30 00 00 ; Exclusive OR accumulator with memory (long) $000030.l [Writes: Accumulator] [Flags: ZN]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $DE.b		; 04 DE ; Test and set bits $DE.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	inc $FE00.w,X		; FE 00 FE ; Increment memory $FE00.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FA.b		; 04 FA ; Test and set bits $FA.b [Reads: Accumulator] [Flags: Z]
	tsb $F2.b		; 04 F2 ; Test and set bits $F2.b [Reads: Accumulator] [Flags: Z]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: ZNC]
	jmp $B804.w		; 4C 04 B8 ; Jump to $B804.w [Flow: jump]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$CE.b],Y		; 17 CE ; OR accumulator with memory (long indexed) [$CE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $387D.w		; 4D 7D 38 ; Exclusive OR $387D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$E8.b]		; 47 E8 ; Exclusive OR accumulator with memory (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc [$B3.b],Y		; 77 B3 ; Add with carry (long indexed) [$B3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($3847.w,X)		; 7C 47 38 ; Jump indirect indexed to ($3847.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $62, $40, $7D		; 62 40 7D ; Push effective relative address $62, $40, $7D [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$11F0.w		; C9 F0 11 ; Compare #$11F0.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	cpx #$61.b		; E0 61 ; Compare #$61.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $86		; 80 86 ; Branch always to $80, $86 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$9D.b		; C0 9D ; Compare #$9D.b with Y register [Reads: Y Index] [Flags: ZNC]
.ACCU 8
.INDEX 8
	sep #$39		; E2 39
	dec $F1.b		; C6 F1 ; Decrement $F1.b [Reads: Direct Page] [Flags: ZN]
	asl $1EE1.w		; 0E E1 1E ; Arithmetic shift left $1EE1.w [Flags: ZNC]
	stx $78.b		; 86 78 ; Store X register to $78.b [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($00.b,S),Y		; 73 00 ; Add with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $4C52.w,X		; DE 52 4C ; Decrement memory $4C52.w,X [Reads: X Index] [Flags: ZN]
	tsb $67.b		; 04 67 ; Test and set bits $67.b [Reads: Accumulator] [Flags: Z]
	and [$36.b]		; 27 36 ; AND accumulator with memory (long) [$36.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3D.b,X		; 15 3D ; OR accumulator with memory $3D.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($00.b,S),Y		; 73 00 ; Add with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $7B73.w		; AD 73 7B ; Load $7B73.w into accumulator [Writes: Accumulator] [Flags: ZN]
	and [$58.b],Y		; 37 58 ; AND accumulator with memory (long indexed) [$58.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $271C2B.l,X		; 3F 2B 1C 27 ; AND accumulator with memory (long,X) $271C2B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	lsr $C970.w,X		; 5E 70 C9 ; Logical shift right $C970.w,X [Reads: X Index] [Flags: ZNC]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	.db $F0, $32		; F0 32 ; Branch if equal to $F0, $32 [Flow: branch]
	cpy #$C6.b		; C0 C6 ; Compare #$C6.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$AE.b		; E0 AE ; Compare #$AE.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $39		; D0 39 ; Branch if not equal to $D0, $39 [Flow: branch]
	dec $F9.b		; C6 F9 ; Decrement $F9.b [Reads: Direct Page] [Flags: ZN]
	asl $F2.b		; 06 F2 ; Arithmetic shift left $F2.b [Reads: Direct Page] [Flags: ZNC]
	tsb $38C6.w		; 0C C6 38 ; Test and set bits $38C6.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $2F06.w,X		; 1E 06 2F ; Arithmetic shift left $2F06.w,X [Reads: X Index] [Flags: ZNC]
	ora [$2F.b]		; 07 2F ; OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3B.b,S		; 03 3B ; OR accumulator with stack relative $3B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $35.b		; 14 35 ; Test and reset bits $35.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $19.b,S		; 03 19 ; OR accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$38.b]		; 07 38 ; OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $CF, $C0		; 82 CF C0 ; Branch always long to $82, $CF, $C0 [Flow: branch]
	inc $FA6C.w,X		; FE 6C FA ; Increment memory $FA6C.w,X [Reads: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $3FF8.w,X		; 7D F8 3F ; Add $3FF8.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $92		; F0 92 ; Branch if equal to $F0, $92 [Flow: branch]
	jmp ($FC06.w)		; 6C 06 FC ; Jump indirect to ($FC06.w) [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $53		; 30 53 ; Branch if minus to $30, $53 [Flow: branch]
	bit $3E41.w		; 2C 41 3E ; Test bits $3E41.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $7E		; 30 7E ; Branch if minus to $30, $7E [Flow: branch]
	and $3E7F.w		; 2D 7F 3E ; Logical AND $3E7F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $001D.w,X		; 3E 1D 00 ; Rotate left $001D.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FA.b		; 04 FA ; Test and set bits $FA.b [Reads: Accumulator] [Flags: Z]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	pea $F804.w		; F4 04 F8 ; Push absolute address $F804.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $1C02.w		; 0E 02 1C ; Arithmetic shift left $1C02.w [Flags: ZNC]
	tsb $1F78.w		; 0C 78 1F ; Test and set bits $1F78.w [Reads: Accumulator] [Flags: Z]
	lda [$18.b]		; A7 18 ; Load accumulator (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $FF1867.l		; 0F 67 18 FF ; OR accumulator with memory (long) $FF1867.l [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $68		; 80 68 ; Branch always to $80, $68 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx #$94.b		; E0 94 ; Compare #$94.b with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $D0, $98		; D0 98 ; Branch if not equal to $D0, $98 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($7C00.w,X)		; FC 00 7C ; Jump to subroutine indirect indexed ($7C00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $17		; 80 17 ; Branch always to $80, $17 [Flow: branch]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $030F0F.l,X		; 1F 0F 0F 03 ; Logical OR long $030F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $88		; 10 88 ; Branch if plus to $10, $88 [Flow: branch]
	.db $70, $18		; 70 18 ; Branch if overflow set to $70, $18 [Flow: branch]
	cpx #$E8.b		; E0 E8 ; Compare #$E8.b with X register [Reads: X Index] [Flags: ZNC]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2F.b,X)		; 01 2F ; Logical OR ($2F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $37		; 10 37 ; Branch if plus to $10, $37 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	trb $0C1E.w		; 1C 1E 0C ; Test and reset bits $0C1E.w [Reads: Accumulator] [Flags: Z]
	tsb $6000.w		; 0C 00 60 ; Test and set bits $6000.w [Reads: Accumulator] [Flags: Z]
	ora $300F20.l,X		; 1F 20 0F 30 ; Logical OR long $300F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$30.b]		; 07 30 ; OR accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $3F03.w,X		; 3C 03 3F ; Test bits $3F03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx $1C10.w		; EC 10 1C ; Compare $1C10.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($7838.w,X)		; FC 38 78 ; Jump to subroutine indirect indexed ($7838.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	tsb $0CE0.w		; 0C E0 0C ; Test and set bits $0CE0.w [Reads: Accumulator] [Flags: Z]
	.db $10, $3C		; 10 3C ; Branch if plus to $10, $3C [Flow: branch]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3A.b,S		; 03 3A ; OR accumulator with stack relative $3A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $4C.b		; 05 4C ; Logical OR $4C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($8F.b,S),Y		; 33 8F ; AND accumulator (stack relative indirect indexed) ($8F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $F3		; 70 F3 ; Branch if overflow set to $70, $F3 [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F30.w		; 0C 30 0F ; Test and set bits $0F30.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and [$FC.b],Y		; 37 FC ; AND accumulator with memory (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($F3.b,S),Y		; 73 F3 ; Add with carry (stack relative indirect indexed) ($F3.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$5E.b		; C0 5E ; Compare #$5E.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$32.b		; A0 32 ; Load #$32.b into Y register [Writes: Y Index] [Flags: ZN]
	cpy $0EF1.w		; CC F1 0E ; Compare $0EF1.w with Y register [Reads: Y Index] [Flags: ZNC]
	cmp $000F00.l		; CF 00 0F 00 ; Compare accumulator (long) $000F00.l [Reads: Accumulator] [Flags: ZNC]
	ora $000600.l		; 0F 00 06 00 ; OR accumulator with memory (long) $000600.l [Writes: Accumulator] [Flags: ZN]
	tsb $0E30.w		; 0C 30 0E ; Test and set bits $0E30.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	cpx $CE3F.w		; EC 3F CE ; Compare $CE3F.w with X register [Reads: X Index] [Flags: ZNC]
	cmp $060F00.l		; CF 00 0F 06 ; Compare accumulator (long) $060F00.l [Reads: Accumulator] [Flags: ZNC]
	ora $000606.l		; 0F 06 06 00 ; OR accumulator with memory (long) $000606.l [Writes: Accumulator] [Flags: ZN]
	bit $1E00.w,X		; 3C 00 1E ; Test bits $1E00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cop $27.b		; 02 27 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $BA.b		; 04 BA ; Test and set bits $BA.b [Reads: Accumulator] [Flags: Z]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $FC.b		; 14 FC ; Test and reset bits $FC.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9A.b		; 00 9A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx $2F40.w		; AE 40 2F ; Load $2F40.w into X register [Writes: X Index] [Flags: ZN]
	cpy #$EA.b		; C0 EA ; Compare #$EA.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3A.b		; 04 3A ; Test and set bits $3A.b [Reads: Accumulator] [Flags: Z]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $96.b		; 00 96 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $FC.b,X		; 94 FC ; Store Y register $FC.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9A.b		; 00 9A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rol $EFC0.w		; 2E C0 EF ; Rotate left $EFC0.w [Flags: ZNC]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	asl $0909.w,X		; 1E 09 09 ; Arithmetic shift left $0909.w,X [Reads: X Index] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E1.b		; 00 E1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F1.b		; E0 F1 ; Compare #$F1.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $F9		; 70 F9 ; Branch if overflow set to $70, $F9 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $7E8F.w,X		; FE 8F 7E ; Increment memory $7E8F.w,X [Reads: X Index] [Flags: ZN]
	cmp [$3E.b]		; C7 3E ; Compare accumulator (long) [$3E.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	lsr $BC.b		; 46 BC ; Logical shift right $BC.b [Reads: Direct Page] [Flags: ZNC]
	rol $CC.b,X		; 36 CC ; Rotate left $CC.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $1E06.w,Y		; 19 06 1E ; OR accumulator with memory $1E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000F0E.l,X		; 1F 0E 0F 00 ; Logical OR long $000F0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1003.w		; 1C 03 10 ; Test and reset bits $1003.w [Reads: Accumulator] [Flags: Z]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$18.b		; 09 18 ; Logical OR #$18.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $96		; 70 96 ; Branch if overflow set to $70, $96 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	inc $18.b		; E6 18 ; Increment $18.b [Reads: Direct Page] [Flags: ZN]
	trb $FCE0.w		; 1C E0 FC ; Test and reset bits $FCE0.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	cop $F4.b		; 02 F4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $E4.b		; 02 E4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C10.w		; 0C 10 1C ; Test and set bits $1C10.w [Reads: Accumulator] [Flags: Z]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $307C63.l,X		; FF 63 7C 30 ; Subtract with carry (long,X) $307C63.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $1E10.w,X		; 3C 10 1E ; Test bits $1E10.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $000F.w		; 0E 0F 00 ; Arithmetic shift left $000F.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $009010.l		; AF 10 90 00 ; Load long $009010.l into accumulator [Writes: Accumulator] [Flags: ZN]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$FC08]		; DC 08 FC ; Jump long indirect [$FC08] [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($E220.w,X)		; FC 20 E2 ; Jump to subroutine indirect indexed ($E220.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $FC		; 30 FC ; Branch if minus to $30, $FC [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0034.w		; 20 34 00 ; Jump to subroutine at $0034.w [Writes: Stack Pointer] [Flow: call]
	stz $BE00.w		; 9C 00 BE ; Store zero to $BE00.w
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $671131.l		; 0F 31 11 67 ; OR accumulator with memory (long) $671131.l [Writes: Accumulator] [Flags: ZN]
	and [$6C.b]		; 27 6C ; AND accumulator with memory (long) [$6C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $EC6CF3.l		; 2F F3 6C EC ; AND accumulator with memory (long) $EC6CF3.l [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F1000.l		; 0F 00 10 0F ; OR accumulator with memory (long) $0F1000.l [Writes: Accumulator] [Flags: ZN]
	rol $581F.w		; 2E 1F 58 ; Rotate left $581F.w [Flags: ZNC]
	and $9F3C53.l,X		; 3F 53 3C 9F ; AND accumulator with memory (long,X) $9F3C53.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy $0043.w,X		; BC 43 00 ; Load Y register $0043.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E9.b		; 00 E9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $2F.b		; E6 2F ; Increment $2F.b [Reads: Direct Page] [Flags: ZN]
	cpy #$49.b		; C0 49 ; Compare #$49.b with Y register [Reads: Y Index] [Flags: ZNC]
	stx $89.b		; 86 89 ; Store X register to $89.b [Reads: X Index]
	asl $3D.b		; 06 3D ; Arithmetic shift left $3D.b [Reads: Direct Page] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	sbc $807900.l		; EF 00 79 80 ; Subtract with carry (long) $807900.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $36CF10.l		; EF 10 CF 36 ; Subtract with carry (long) $36CF10.l [Writes: Accumulator] [Flags: ZVNC]
	sta $C23776.l		; 8F 76 37 C2 ; Store accumulator (long) $C23776.l [Reads: Accumulator]
	pea $FD50.w		; F4 50 FD ; Push absolute address $FD50.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sbc $067E6D.l,X		; FF 6D 7E 06 ; Subtract with carry (long,X) $067E6D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$09.b],Y		; 17 09 ; OR accumulator with memory (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1A.b		; 25 1A ; Logical AND $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $003F1D.l		; 22 1D 3F 00 ; Jump to subroutine long $003F1D.l [Writes: Stack Pointer] [Flow: call]
	ldy $A543.w		; AC 43 A5 ; Load $A543.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $42, $92		; 42 92 ; Reserved instruction
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $1E00.w,Y		; 79 00 1E ; Add $1E00.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $3E1A.w,X		; 3D 1A 3E ; AND accumulator with memory $3E1A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $013E.w,X		; 1D 3E 01 ; OR accumulator with memory $013E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DD2A.w,X		; FD 2A DD ; Subtract with carry $DD2A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cmp $DA0A.w		; CD 0A DA ; Compare $DA0A.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	trb $FA.b		; 14 FA ; Test and reset bits $FA.b [Reads: Accumulator] [Flags: Z]
	cpx $FC.b		; E4 FC ; Compare $FC.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $1A		; 10 1A ; Branch if plus to $10, $1A [Flow: branch]
	cpx $D7.b		; E4 D7 ; Compare $D7.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cop $67.b		; 02 67 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $77.b		; 02 77 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $2E.b		; 02 2E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	tsb $E4.b		; 04 E4 ; Test and set bits $E4.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp.w [$FC20]		; DC 20 FC ; Jump long indirect [$FC20] [Flow: jump]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $AC		; F0 AC ; Branch if equal to $F0, $AC [Flow: branch]
	.db $F0, $8F		; F0 8F ; Branch if equal to $F0, $8F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1C2300.l		; 0F 00 23 1C ; OR accumulator with memory (long) $1C2300.l [Writes: Accumulator] [Flags: ZN]
	and ($CC.b,S),Y		; 33 CC ; AND accumulator (stack relative indirect indexed) ($CC.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1D3F00.l		; 0F 00 3F 1D ; OR accumulator with memory (long) $1D3F00.l [Writes: Accumulator] [Flags: ZN]
	ora $0000ED.l,X		; 1F ED 00 00 ; Logical OR long $0000ED.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $1C		; 30 1C ; Branch if minus to $30, $1C [Flow: branch]
	cpx #$DF.b		; E0 DF ; Compare #$DF.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $033C.w		; 20 3C 03 ; Jump to subroutine at $033C.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	cpx $2FF0.w		; EC F0 2F ; Compare $2FF0.w with X register [Reads: X Index] [Flags: ZNC]
	jsr $001F.w		; 20 1F 00 ; Jump to subroutine at $001F.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $39.b		; 04 39 ; Test and set bits $39.b [Reads: Accumulator] [Flags: Z]
	asl $DD.b		; 06 DD ; Arithmetic shift left $DD.b [Reads: Direct Page] [Flags: ZNC]
	jsl $00F00E.l		; 22 0E F0 00 ; Jump to subroutine long $00F00E.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	rol $07.b,X		; 36 07 ; Rotate left $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $5B06.w		; 0E 06 5B ; Arithmetic shift left $5B06.w [Flags: ZNC]
	ora [$AC.b]		; 07 AC ; OR accumulator with memory (long) [$AC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $A3.b,S		; 03 A3 ; OR accumulator with stack relative $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$5C.b]		; 07 5C ; OR accumulator with memory (long) [$5C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $EF.b,S		; 03 EF ; OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $E3		; 10 E3 ; Branch if plus to $10, $E3 [Flow: branch]
	trb $0FF0.w		; 1C F0 0F ; Test and reset bits $0FF0.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $5E		; 10 5E ; Branch if plus to $10, $5E [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	and $CDC8.w,X		; 3D C8 CD ; AND accumulator with memory $CDC8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E8.b		; C0 E8 ; Compare #$E8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $B6		; F0 B6 ; Branch if equal to $F0, $B6 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $F00F30.l		; CF 30 0F F0 ; Compare accumulator (long) $F00F30.l [Reads: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $3804.w		; 0C 04 38 ; Test and set bits $3804.w [Reads: Accumulator] [Flags: Z]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$9E.b],Y		; 17 9E ; OR accumulator with memory (long indexed) [$9E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $38BD.w,X		; 1D BD 38 ; OR accumulator with memory $38BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$68.b]		; 07 68 ; OR accumulator with memory (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$E3.b],Y		; 37 E3 ; AND accumulator with memory (long indexed) [$E3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($78C7.w,X)		; 7C C7 78 ; Jump indirect indexed to ($78C7.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	jmp $CA70.w		; 4C 70 CA ; Jump to $CA70.w [Flow: jump]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	cpx #$61.b		; E0 61 ; Compare #$61.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $E7		; 80 E7 ; Branch always to $80, $E7 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$BC.b		; E0 BC ; Compare #$BC.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$3A.b		; C0 3A ; Compare #$3A.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy $F1.b		; C4 F1 ; Compare $F1.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	asl $1EE1.w		; 0E E1 1E ; Arithmetic shift left $1EE1.w [Flags: ZNC]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0C5C03.l		; 0F 03 5C 0C ; OR accumulator with memory (long) $0C5C03.l [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $0AF615.l		; EF 15 F6 0A ; Subtract with carry (long) $0AF615.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $5303.w		; 0C 03 53 ; Test and set bits $5303.w [Reads: Accumulator] [Flags: Z]
	ora $F40FF7.l		; 0F F7 0F F4 ; OR accumulator with memory (long) $F40FF7.l [Writes: Accumulator] [Flags: ZN]
	ora $FD05FA.l		; 0F FA 05 FD ; OR accumulator with memory (long) $FD05FA.l [Writes: Accumulator] [Flags: ZN]
	adc $00.b,S		; 63 00 ; Add with carry (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$1A.b		; C0 1A ; Compare #$1A.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	.db $F0, $FD		; F0 FD ; Branch if equal to $F0, $FD [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc [$E8.b],Y		; F7 E8 ; Subtract with carry (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $000010.l,X		; 3F 10 00 00 ; AND accumulator with memory (long,X) $000010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	nop		; EA ; No operation
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	.db $F0, $C7		; F0 C7 ; Branch if equal to $F0, $C7 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $D6CFE0.l,X		; 1F E0 CF D6 ; Logical OR long $D6CFE0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $A0		; F0 A0 ; Branch if equal to $F0, $A0 [Flow: branch]
	jmp ($FA42.w,X)		; 7C 42 FA ; Jump indirect indexed to ($FA42.w,X) [Reads: X Index] [Flow: jump]
	ora $FD.b,X		; 15 FD ; OR accumulator with memory $FD.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldx #$FF.b		; A2 FF ; Load #$FF.b into X register [Writes: X Index] [Flags: ZN]
	.db $70, $6F		; 70 6F ; Branch if overflow set to $70, $6F [Flow: branch]
	asl $3839.w		; 0E 39 38 ; Arithmetic shift left $3839.w [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy #$B0.b		; A0 B0 ; Load #$B0.b into Y register [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lsr $1510.w		; 4E 10 15 ; Logical shift right $1510.w [Flags: ZNC]
	ldy #$A2.b		; A0 A2 ; Load #$A2.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	asl $380E.w		; 0E 0E 38 ; Arithmetic shift left $380E.w [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $7E.b		; 02 7E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $FE.b		; 05 FE ; Logical OR $FE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $FC.b		; 06 FC ; Arithmetic shift left $FC.b [Reads: Direct Page] [Flags: ZNC]
	bit $D0.b,X		; 34 D0 ; Test bits $D0.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cpy #$08.b		; C0 08 ; Compare #$08.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($D1.b,X)		; 01 D1 ; Logical OR ($D1.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $45.b		; 05 45 ; Logical OR $45.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	pea $FD50.w		; F4 50 FD ; Push absolute address $FD50.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sbc $067E6D.l,X		; FF 6D 7E 06 ; Subtract with carry (long,X) $067E6D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$09.b],Y		; 17 09 ; OR accumulator with memory (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1A.b		; 25 1A ; Logical AND $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $003F1D.l		; 22 1D 3F 00 ; Jump to subroutine long $003F1D.l [Writes: Stack Pointer] [Flow: call]
	ldy $A543.w		; AC 43 A5 ; Load $A543.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $42, $92		; 42 92 ; Reserved instruction
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $1E00.w,Y		; 79 00 1E ; Add $1E00.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $3E1A.w,X		; 3D 1A 3E ; AND accumulator with memory $3E1A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $013E.w,X		; 1D 3E 01 ; OR accumulator with memory $013E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DD2A.w,X		; FD 2A DD ; Subtract with carry $DD2A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cmp $DA0A.w		; CD 0A DA ; Compare $DA0A.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	trb $FA.b		; 14 FA ; Test and reset bits $FA.b [Reads: Accumulator] [Flags: Z]
	cpx $FC.b		; E4 FC ; Compare $FC.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $1A		; 10 1A ; Branch if plus to $10, $1A [Flow: branch]
	cpx $D7.b		; E4 D7 ; Compare $D7.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cop $67.b		; 02 67 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $77.b		; 02 77 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $2E.b		; 02 2E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	tsb $E4.b		; 04 E4 ; Test and set bits $E4.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $F0, $33		; F0 33 ; Branch if equal to $F0, $33 [Flow: branch]
	.db $10, $3B		; 10 3B ; Branch if plus to $10, $3B [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $1F09.w,X		; 1E 09 1F ; Arithmetic shift left $1F09.w,X [Reads: X Index] [Flags: ZNC]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1B3B.w		; 0C 3B 1B ; Test and set bits $1B3B.w [Reads: Accumulator] [Flags: Z]
	and [$1E.b]		; 27 1E ; AND accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $2E00.w,X		; 1E 00 2E ; Arithmetic shift left $2E00.w,X [Reads: X Index] [Flags: ZNC]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $30CE.w		; 4C CE 30 ; Jump to $30CE.w [Flow: jump]
	and $0EFDC2.l,X		; 3F C2 FD 0E ; AND accumulator with memory (long,X) $0EFDC2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec $8000.w,X		; DE 00 80 ; Decrement memory $8000.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	cpy $300F.w		; CC 0F 30 ; Compare $300F.w with Y register [Reads: Y Index] [Flags: ZNC]
	and $00DEC0.l,X		; 3F C0 DE 00 ; AND accumulator with memory (long,X) $00DEC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $2F03.w		; 9C 03 2F ; Store zero to $2F03.w
	.db $10, $72		; 10 72 ; Branch if plus to $10, $72 [Flow: branch]
	ora $237C.w		; 0D 7C 23 ; Logical OR $237C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $003B30.l,X		; 5F 30 3B 00 ; Exclusive OR accumulator with memory (long,X) $003B30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $0F		; 90 0F ; Branch if carry clear to $90, $0F [Flow: branch]
	jsr $620F.w		; 20 0F 62 ; Jump to subroutine at $620F.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	tsb $037C.w		; 0C 7C 03 ; Test and set bits $037C.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$14.b		; E0 14 ; Compare #$14.b with X register [Reads: X Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	stz $98.b		; 64 98 ; Store zero to $98.b
	trb $FEE0.w		; 1C E0 FE ; Test and reset bits $FEE0.w [Reads: Accumulator] [Flags: Z]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	trb $1C3A.w		; 1C 3A 1C ; Test and reset bits $1C3A.w [Reads: Accumulator] [Flags: Z]
	trb $0F00.w		; 1C 00 0F ; Test and reset bits $0F00.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	.db $F0, $44		; F0 44 ; Branch if equal to $F0, $44 [Flow: branch]
	jsr $1804.w		; 20 04 18 ; Jump to subroutine at $1804.w [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpx #$E6.b		; E0 E6 ; Compare #$E6.b with X register [Reads: X Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $200F.w		; 20 0F 20 ; Jump to subroutine at $200F.w [Writes: Stack Pointer] [Flow: call]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E8.b		; 14 E8 ; Test and reset bits $E8.b [Reads: Accumulator] [Flags: Z]
	tsb $3EF0.w		; 0C F0 3E ; Test and set bits $3EF0.w [Reads: Accumulator] [Flags: Z]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $1CFE.w		; 0C FE 1C ; Test and set bits $1CFE.w [Reads: Accumulator] [Flags: Z]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	asl $3630.w		; 0E 30 36 ; Arithmetic shift left $3630.w [Flags: ZNC]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$FE.b		; 09 FE ; Logical OR #$FE.b with accumulator [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sty $4F74.w		; 8C 74 4F ; Store Y register to $4F74.w [Reads: Y Index]
	and ($31.b),Y		; 31 31 ; AND accumulator with memory ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $F0		; 50 F0 ; Branch if overflow clear to $50, $F0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $00.b,S		; E3 00 ; Subtract stack-relative $00.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc [$60.b],Y		; F7 60 ; Subtract with carry (long indexed) [$60.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $70, $7E		; 70 7E ; Branch if overflow set to $70, $7E [Flow: branch]
	.db $30, $31		; 30 31 ; Branch if minus to $30, $31 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $7F		; 90 7F ; Branch if carry clear to $90, $7F [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $3116.w,Y		; 59 16 31 ; Exclusive OR accumulator with memory $3116.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $8CF2.w		; 2E F2 8C ; Rotate left $8CF2.w [Flags: ZNC]
	sty $0000.w		; 8C 00 00 ; Store Y register to $0000.w [Reads: Y Index]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $00C706.l		; 0F 06 C7 00 ; OR accumulator with memory (long) $00C706.l [Writes: Accumulator] [Flags: ZN]
	sbc $0EDF06.l		; EF 06 DF 0E ; Subtract with carry (long) $0EDF06.l [Writes: Accumulator] [Flags: ZVNC]
	ror $8C0C.w,X		; 7E 0C 8C ; Rotate right $8C0C.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $7E		; 30 7E ; Branch if minus to $30, $7E [Flow: branch]
	jsl $0B032F.l		; 22 2F 03 0B ; Jump to subroutine long $0B032F.l [Writes: Stack Pointer] [Flow: call]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $5D		; 70 5D ; Branch if overflow set to $70, $5D [Flow: branch]
	jsr $002C.w		; 20 2C 00 ; Jump to subroutine at $002C.w [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FA.b		; 04 FA ; Test and set bits $FA.b [Reads: Accumulator] [Flags: Z]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($609C.w)		; 6C 9C 60 ; Jump indirect to ($609C.w) [Flow: jump]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $FF60.w,X		; FE 60 FF ; Increment memory $FF60.w,X [Reads: X Index] [Flags: ZN]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($F060.w,X)		; FC 60 F0 ; Jump to subroutine indirect indexed ($F060.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $EF.b		; 05 EF ; Logical OR $EF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta ($60.b),Y		; 91 60 ; Store accumulator ($60.b),Y [Reads: Accumulator, Direct Page, Y Index]
	jmp $4B30.w		; 4C 30 4B ; Jump to $4B30.w [Flow: jump]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($EF.b,X)		; 61 EF ; Add with carry ($EF.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $F3		; 10 F3 ; Branch if plus to $10, $F3 [Flow: branch]
	jmp ($6EF1.w)		; 6C F1 6E ; Jump indirect to ($6EF1.w) [Flow: jump]
	jmp ($7B33.w,X)		; 7C 33 7B ; Jump indirect indexed to ($7B33.w,X) [Reads: X Index] [Flow: jump]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $9F		; 90 9F ; Branch if carry clear to $90, $9F [Flow: branch]
	.db $90, $D9		; 90 D9 ; Branch if carry clear to $90, $D9 [Flow: branch]
	dec $D9.b		; C6 D9 ; Decrement $D9.b [Reads: Direct Page] [Flags: ZN]
	dec $D2.b		; C6 D2 ; Decrement $D2.b [Reads: Direct Page] [Flags: ZN]
	jmp $0CF2.w		; 4C F2 0C ; Jump to $0CF2.w [Flow: jump]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $6F.b,X		; F6 6F ; Increment memory $6F.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	inc $3F.b		; E6 3F ; Increment $3F.b [Reads: Direct Page] [Flags: ZN]
	inc $BE.b		; E6 BE ; Increment $BE.b [Reads: Direct Page] [Flags: ZN]
	jmp ($0CFE.w)		; 6C FE 0C ; Jump indirect to ($0CFE.w) [Flow: jump]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $00FC.w		; 20 FC 00 ; Jump to subroutine at $00FC.w [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $DC.b		; 04 DC ; Test and set bits $DC.b [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $CCF0.w		; 20 F0 CC ; Jump to subroutine at $CCF0.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $CF		; F0 CF ; Branch if equal to $F0, $CF [Flow: branch]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $3900.w		; 0E 00 39 ; Arithmetic shift left $3900.w [Flags: ZNC]
	asl $D1.b		; 06 D1 ; Arithmetic shift left $D1.b [Reads: Direct Page] [Flags: ZNC]
	rol $CE31.w		; 2E 31 CE ; Rotate left $CE31.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	ora $EE1F36.l		; 0F 36 1F EE ; OR accumulator with memory (long) $EE1F36.l [Writes: Accumulator] [Flags: ZN]
	ora $0000EE.l,X		; 1F EE 00 00 ; Logical OR long $0000EE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	jsr ($FB00.w,X)		; FC 00 FB ; Jump to subroutine indirect indexed ($FB00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $CCF0.w		; 20 F0 CC ; Jump to subroutine at $CCF0.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $CF		; F0 CF ; Branch if equal to $F0, $CF [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $3900.w		; 0E 00 39 ; Arithmetic shift left $3900.w [Flags: ZNC]
	asl $D1.b		; 06 D1 ; Arithmetic shift left $D1.b [Reads: Direct Page] [Flags: ZNC]
	rol $0000.w		; 2E 00 00 ; Rotate left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	ora $EE1F36.l		; 0F 36 1F EE ; OR accumulator with memory (long) $EE1F36.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $CCF0.w		; 20 F0 CC ; Jump to subroutine at $CCF0.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $3900.w		; 0E 00 39 ; Arithmetic shift left $3900.w [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000036.l		; 0F 36 00 00 ; OR accumulator with memory (long) $000036.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$5C.b]		; 67 5C ; Add with carry (long) [$5C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $3C.b,S		; 23 3C ; AND accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$F0.b]		; 67 F0 ; Add with carry (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $202F70.l		; 6F 70 2F 20 ; Add with carry (long) $202F70.l [Writes: Accumulator] [Flags: ZVNC]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E9.b		; 00 E9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $39.b		; 06 39 ; Arithmetic shift left $39.b [Reads: Direct Page] [Flags: ZNC]
	dec $1A.b		; C6 1A ; Decrement $1A.b [Reads: Direct Page] [Flags: ZN]
	cpx $3C.b		; E4 3C ; Compare $3C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0F.b		; E6 0F ; Increment $0F.b [Reads: Direct Page] [Flags: ZN]
	inc $0E.b,X		; F6 0E ; Increment memory $0E.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	pea $F804.w		; F4 04 F8 ; Push absolute address $F804.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$5C.b]		; 67 5C ; Add with carry (long) [$5C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$F0.b]		; 67 F0 ; Add with carry (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $002F70.l		; 6F 70 2F 00 ; Add with carry (long) $002F70.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E9.b		; 00 E9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $39.b		; 06 39 ; Arithmetic shift left $39.b [Reads: Direct Page] [Flags: ZNC]
	dec $1A.b		; C6 1A ; Decrement $1A.b [Reads: Direct Page] [Flags: ZN]
	cpx $00.b		; E4 00 ; Compare $00.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0F.b		; E6 0F ; Increment $0F.b [Reads: Direct Page] [Flags: ZN]
	inc $0E.b,X		; F6 0E ; Increment memory $0E.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	pea $0000.w		; F4 00 00 ; Push absolute address $0000.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$00.b]		; 67 00 ; Add with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$F0.b]		; 67 F0 ; Add with carry (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $000000.l		; 6F 00 00 00 ; Add with carry (long) $000000.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E9.b		; 00 E9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $39.b		; 06 39 ; Arithmetic shift left $39.b [Reads: Direct Page] [Flags: ZNC]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0F.b		; E6 0F ; Increment $0F.b [Reads: Direct Page] [Flags: ZN]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: ZNC]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	trb $CC.b		; 14 CC ; Test and reset bits $CC.b [Reads: Accumulator] [Flags: Z]
	.db $30, $E4		; 30 E4 ; Branch if minus to $30, $E4 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $1E00.w		; 0E 00 1E ; Arithmetic shift left $1E00.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	trb $2E.b		; 14 2E ; Test and reset bits $2E.b [Reads: Accumulator] [Flags: Z]
	ora ($32.b),Y		; 11 32 ; OR accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $031C.w		; 0D 1C 03 ; Logical OR $031C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $0C1F00.l,X		; 1F 00 1F 0C ; Logical OR long $0C1F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000C00.l,X		; 1F 00 0C 00 ; Logical OR long $000C00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $5E80.w,X		; 7E 80 5E ; Rotate right $5E80.w,X [Reads: X Index] [Flags: ZNC]
	ldy #$3E.b		; A0 3E ; Load #$3E.b into Y register [Writes: Y Index] [Flags: ZN]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$5E.b		; E0 5E ; Compare #$5E.b with X register [Reads: X Index] [Flags: ZNC]
	tsb $2C1E.w		; 0C 1E 2C ; Test and set bits $2C1E.w [Reads: Accumulator] [Flags: Z]
	bit $F8C0.w,X		; 3C C0 F8 ; Test bits $F8C0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $32.b,S		; 03 32 ; OR accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $033C.w		; 0D 3C 03 ; Logical OR $033C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $3F01.w,X		; 3E 01 3F ; Rotate left $3F01.w,X [Reads: X Index] [Flags: ZNC]
	trb $003F.w		; 1C 3F 00 ; Test and reset bits $003F.w [Reads: Accumulator] [Flags: Z]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $301320.l		; 0F 20 13 30 ; OR accumulator with memory (long) $301320.l [Writes: Accumulator] [Flags: ZN]
	tsb $023C.w		; 0C 3C 02 ; Test and set bits $023C.w [Reads: Accumulator] [Flags: Z]
	rol $3F01.w,X		; 3E 01 3F ; Rotate left $3F01.w,X [Reads: X Index] [Flags: ZNC]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $807E.w		; CE 7E 80 ; Decrement $807E.w [Flags: ZN]
	lsr $3EA0.w,X		; 5E A0 3E ; Logical shift right $3EA0.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $E01E.w		; EE 1E E0 ; Increment $E01E.w [Flags: ZN]
	lsr $1E0C.w,X		; 5E 0C 1E ; Logical shift right $1E0C.w,X [Reads: X Index] [Flags: ZNC]
	bit $C03C.w		; 2C 3C C0 ; Test bits $C03C.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $DC.b		; 04 DC ; Test and set bits $DC.b [Reads: Accumulator] [Flags: Z]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3C.b),Y		; 11 3C ; OR accumulator with memory ($3C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$2F.b		; 09 2F ; Logical OR #$2F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $063F.w		; 1C 3F 06 ; Test and reset bits $063F.w [Reads: Accumulator] [Flags: Z]
	asl $F000.w,X		; 1E 00 F0 ; Arithmetic shift left $F000.w,X [Reads: X Index] [Flags: ZNC]
	cmp $200FD0.l		; CF D0 0F 20 ; Compare accumulator (long) $200FD0.l [Reads: Accumulator] [Flags: ZNC]
	ora $3C1428.l		; 0F 28 14 3C ; OR accumulator with memory (long) $3C1428.l [Writes: Accumulator] [Flags: ZN]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $CE31.w		; 2E 31 CE ; Rotate left $CE31.w [Flags: ZNC]
	ror $5E80.w,X		; 7E 80 5E ; Rotate right $5E80.w,X [Reads: X Index] [Flags: ZNC]
	ldy #$3E.b		; A0 3E ; Load #$3E.b into Y register [Writes: Y Index] [Flags: ZN]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $EE1F.w		; EE 1F EE ; Increment $EE1F.w [Flags: ZN]
	asl $5EE0.w,X		; 1E E0 5E ; Arithmetic shift left $5EE0.w,X [Reads: X Index] [Flags: ZNC]
	tsb $2C1E.w		; 0C 1E 2C ; Test and set bits $2C1E.w [Reads: Accumulator] [Flags: Z]
	bit $C0C0.w,X		; 3C C0 C0 ; Test bits $C0C0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $0C1F00.l,X		; 1F 00 1F 0C ; Logical OR long $0C1F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $101320.l		; 0F 20 13 10 ; OR accumulator with memory (long) $101320.l [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000E00.l,X		; 1F 00 0E 00 ; Logical OR long $000E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	cpy $3830.w		; CC 30 38 ; Compare $3830.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000300.l,X		; 1F 00 03 00 ; Logical OR long $000300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $201F.w		; 20 1F 20 ; Jump to subroutine at $201F.w [Writes: Stack Pointer] [Flow: call]
	ora $301320.l		; 0F 20 13 30 ; OR accumulator with memory (long) $301320.l [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; [PATTERN: Memory clearing operation] 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C8.b,X		; 34 C8 ; Test bits $C8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	stz $98.b		; 64 98 ; Store zero to $98.b
	stz $7860.w		; 9C 60 78 ; Store zero to $7860.w
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($7838.w,X)		; FC 38 78 ; Jump to subroutine indirect indexed ($7838.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($FC80.w,X)		; 7C 80 FC ; Jump indirect indexed to ($FC80.w,X) [Reads: X Index] [Flow: jump]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3C.b,S		; 23 3C ; AND accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000300.l		; 0F 00 03 00 ; OR accumulator with memory (long) $000300.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $2F		; 70 2F ; Branch if overflow set to $70, $2F [Flow: branch]
	jsr $201F.w		; 20 1F 20 ; Jump to subroutine at $201F.w [Writes: Stack Pointer] [Flow: call]
	ora $101320.l		; 0F 20 13 10 ; OR accumulator with memory (long) $101320.l [Writes: Accumulator] [Flags: ZN]
	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; [PATTERN: Memory clearing operation] 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpx $34.b		; E4 34 ; Compare $34.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	stz $98.b		; 64 98 ; Store zero to $98.b
	stz $7C60.w		; 9C 60 7C ; Store zero to $7C60.w
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($FC38.w,X)		; FC 38 FC ; Jump to subroutine indirect indexed ($FC38.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $0038.w		; 20 38 00 ; Jump to subroutine at $0038.w [Writes: Stack Pointer] [Flow: call]
	asl $04F4.w		; 0E F4 04 ; Arithmetic shift left $04F4.w [Flags: ZNC]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cpx #$0C.b		; E0 0C ; Compare #$0C.b with X register [Reads: X Index] [Flags: ZNC]
	.db $90, $3C		; 90 3C ; Branch if carry clear to $90, $3C [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp ($FC80.w,X)		; 7C 80 FC ; Jump indirect indexed to ($FC80.w,X) [Reads: X Index] [Flow: jump]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0E06.w,Y		; 19 06 0E ; OR accumulator with memory $0E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($7C00.w,X)		; FC 00 7C ; Jump to subroutine indirect indexed ($7C00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C020.w		; 20 20 C0 ; Jump to subroutine at $C020.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $FCC0.w		; F4 C0 FC ; Push absolute address $FCC0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $30, $7C		; 30 7C ; Branch if minus to $30, $7C [Flow: branch]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	ora $17.b		; 05 17 ; Logical OR $17.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $3E06.w,Y		; 19 06 3E ; OR accumulator with memory $3E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $0E0E.w,Y		; 39 0E 0E ; AND accumulator with memory $0E0E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: ZNC]
	ora $15.b		; 05 15 ; Logical OR $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$38.b		; 09 38 ; Logical OR #$38.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $36		; D0 36 ; Branch if not equal to $D0, $36 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sbc $867F02.l,X		; FF 02 7F 86 ; Subtract with carry (long,X) $867F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $C000.w,X		; FE 00 C0 ; Increment memory $C000.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $E8		; 30 E8 ; Branch if minus to $30, $E8 [Flow: branch]
	.db $D0, $F6		; D0 F6 ; Branch if not equal to $D0, $F6 [Flow: branch]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $7F		; 30 7F ; Branch if minus to $30, $7F [Flow: branch]
	.db $30, $3E		; 30 3E ; Branch if minus to $30, $3E [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $183F.w		; 1C 3F 18 ; Test and reset bits $183F.w [Reads: Accumulator] [Flags: Z]
	and $033C00.l,X		; 3F 00 3C 03 ; AND accumulator with memory (long,X) $033C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $7F01.w,X		; 7E 01 7F ; Rotate right $7F01.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$38.b]		; 07 38 ; OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $7C.b		; 04 7C ; Test and set bits $7C.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	jmp ($001B.w,X)		; 7C 1B 00 ; Jump indirect indexed to ($001B.w,X) [Reads: X Index] [Flow: jump]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($3C18.w,X)		; FC 18 3C ; Jump to subroutine indirect indexed ($3C18.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$1C.b		; C0 1C ; Compare #$1C.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$3E.b		; E0 3E ; Compare #$3E.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$3E.b		; C0 3E ; Compare #$3E.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$1C.b		; E0 1C ; Compare #$1C.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $583E.w		; 20 3E 58 ; Jump to subroutine at $583E.w [Writes: Stack Pointer] [Flow: call]
	rol $00D8.w,X		; 3E D8 00 ; Rotate left $00D8.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp.w [$FC20]		; DC 20 FC ; Jump long indirect [$FC20] [Flow: jump]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $AC		; F0 AC ; Branch if equal to $F0, $AC [Flow: branch]
	.db $F0, $8F		; F0 8F ; Branch if equal to $F0, $8F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3A00.w		; 0C 00 3A ; Test and set bits $3A00.w [Reads: Accumulator] [Flags: Z]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1E.b		; 24 1E ; Test bits $1E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $E8		; 10 E8 ; Branch if plus to $10, $E8 [Flow: branch]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $D8		; 10 D8 ; Branch if plus to $10, $D8 [Flow: branch]
	bit $5C.b		; 24 5C ; Test bits $5C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and $3C.b,S		; 23 3C ; AND accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $F0		; 50 F0 ; Branch if overflow clear to $50, $F0 [Flow: branch]
	bit $2F70.w		; 2C 70 2F ; Test bits $2F70.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	jsr $000F.w		; 20 0F 00 ; Jump to subroutine at $000F.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $19.b		; 04 19 ; Test and set bits $19.b [Reads: Accumulator] [Flags: Z]
	rol $0D.b		; 26 0D ; Rotate left $0D.b [Reads: Direct Page] [Flags: ZNC]
	sbc ($0E.b)		; F2 0E ; Subtract with carry (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $1C		; F0 1C ; Branch if equal to $F0, $1C [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0F.b		; 14 0F ; Test and reset bits $0F.b [Reads: Accumulator] [Flags: Z]
	rol $07.b,X		; 36 07 ; Rotate left $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: ZNC]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	jmp.w [$FB20]		; DC 20 FB ; Jump long indirect [$FB20] [Flow: jump]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $AC		; F0 AC ; Branch if equal to $F0, $AC [Flow: branch]
	.db $F0, $8F		; F0 8F ; Branch if equal to $F0, $8F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3E00.w		; 0C 00 3E ; Test and set bits $3E00.w [Reads: Accumulator] [Flags: Z]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $EC1E.w		; 2C 1E EC ; Test bits $EC1E.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1B00.w		; 0C 00 1B ; Test and set bits $1B00.w [Reads: Accumulator] [Flags: Z]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	ora $001F20.l		; 0F 20 1F 00 ; OR accumulator with memory (long) $001F20.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C03C.w		; 20 3C C0 ; Jump to subroutine at $C03C.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $708C20.l,X		; 5F 20 8C 70 ; Exclusive OR accumulator with memory (long,X) $708C20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FC.b		; 24 FC ; Test bits $FC.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $31.b		; 04 31 ; Test and set bits $31.b [Reads: Accumulator] [Flags: Z]
	asl $0609.w		; 0E 09 06 ; Arithmetic shift left $0609.w [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $3F24.w,X		; DE 24 3F ; Decrement memory $3F24.w,X [Reads: X Index] [Flags: ZN]
	asl $060F.w		; 0E 0F 06 ; Arithmetic shift left $060F.w [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $2F01.w,X		; 9E 01 2F ; Store zero to $2F01.w,X [Reads: X Index]
	.db $10, $72		; 10 72 ; Branch if plus to $10, $72 [Flow: branch]
	ora $237C.w		; 0D 7C 23 ; Logical OR $237C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $003B30.l,X		; 5F 30 3B 00 ; Exclusive OR accumulator with memory (long,X) $003B30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $0F		; 90 0F ; Branch if carry clear to $90, $0F [Flow: branch]
	jsr $620F.w		; 20 0F 62 ; Jump to subroutine at $620F.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	tsb $037C.w		; 0C 7C 03 ; Test and set bits $037C.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$BE.b		; C0 BE ; Compare #$BE.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp ($1C90.w)		; 6C 90 1C ; Jump indirect to ($1C90.w) [Flow: jump]
	cpx #$FE.b		; E0 FE ; Compare #$FE.b with X register [Reads: X Index] [Flags: ZNC]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	trb $1C3A.w		; 1C 3A 1C ; Test and reset bits $1C3A.w [Reads: Accumulator] [Flags: Z]
	trb $1E00.w		; 1C 00 1E ; Test and reset bits $1E00.w [Reads: Accumulator] [Flags: Z]
	cpx $EC1E.w		; EC 1E EC ; Compare $EC1E.w with X register [Reads: X Index] [Flags: ZNC]
	jmp $0420.w		; 4C 20 04 ; Jump to $0420.w [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpx #$E6.b		; E0 E6 ; Compare #$E6.b with X register [Reads: X Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: ZNC]
	ora #$19.b		; 09 19 ; Logical OR #$19.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $3C.b		; 06 3C ; Arithmetic shift left $3C.b [Reads: Direct Page] [Flags: ZNC]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp ($FC80.w,X)		; 7C 80 FC ; Jump indirect indexed to ($FC80.w,X) [Reads: X Index] [Flow: jump]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3C72.w		; 1C 72 3C ; Test and reset bits $3C72.w [Reads: Accumulator] [Flags: Z]
	bit $E800.w,X		; 3C 00 E8 ; Test bits $E800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $90, $F4		; 90 F4 ; Branch if carry clear to $90, $F4 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	pea $6460.w		; F4 60 64 ; Push absolute address $6460.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $EEE0.w		; 1C E0 EE ; Test and reset bits $EEE0.w [Reads: Accumulator] [Flags: Z]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $3E06.w,Y		; 19 06 3E ; OR accumulator with memory $3E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $041301.l		; 0F 01 13 04 ; OR accumulator with memory (long) $041301.l [Writes: Accumulator] [Flags: ZN]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $3C.b		; 06 3C ; Arithmetic shift left $3C.b [Reads: Direct Page] [Flags: ZNC]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F4		; 80 F4 ; Branch always to $80, $F4 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx $1C10.w		; EC 10 1C ; Compare $1C10.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3C72.w		; 1C 72 3C ; Test and reset bits $3C72.w [Reads: Accumulator] [Flags: Z]
	bit $C800.w,X		; 3C 00 C8 ; Test bits $C800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $B0, $84		; B0 84 ; Branch if carry set to $B0, $84 [Flow: branch]
	.db $70, $0C		; 70 0C ; Branch if overflow set to $70, $0C [Flow: branch]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $EEE0.w		; 1C E0 EE ; Test and reset bits $EEE0.w [Reads: Accumulator] [Flags: Z]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1403.w		; 0C 03 14 ; Test and set bits $1403.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $3C.b		; 06 3C ; Arithmetic shift left $3C.b [Reads: Direct Page] [Flags: ZNC]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $5E		; 70 5E ; Branch if overflow set to $70, $5E [Flow: branch]
	ldy #$FE.b		; A0 FE ; Load #$FE.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3C72.w		; 1C 72 3C ; Test and reset bits $3C72.w [Reads: Accumulator] [Flags: Z]
	bit $FC00.w,X		; 3C 00 FC ; Test bits $FC00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $70, $7E		; 70 7E ; Branch if overflow set to $70, $7E [Flow: branch]
	ldy $CC3E.w		; AC 3E CC ; Load $CC3E.w into Y register [Writes: Y Index] [Flags: ZN]
	tsb $1C10.w		; 0C 10 1C ; Test and set bits $1C10.w [Reads: Accumulator] [Flags: Z]
	cpx #$EE.b		; E0 EE ; Compare #$EE.b with X register [Reads: X Index] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $7E26.w,Y		; 79 26 7E ; Add $7E26.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($3F.b),Y		; 31 3F ; AND accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$70.b],Y		; 17 70 ; OR accumulator with memory (long indexed) [$70.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$78.b		; 09 78 ; Logical OR #$78.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp.w [$3C20]		; DC 20 3C ; Jump long indirect [$3C20] [Flow: jump]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	trb $1CFE.w		; 1C FE 1C ; Test and reset bits $1CFE.w [Reads: Accumulator] [Flags: Z]
	rol $1C10.w,X		; 3E 10 1C ; Rotate left $1C10.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	trb $2620.w		; 1C 20 26 ; Test and reset bits $2620.w [Reads: Accumulator] [Flags: Z]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($72.b),Y		; 11 72 ; OR accumulator with memory ($72.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $237C.w		; 0D 7C 23 ; Logical OR $237C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $003B30.l,X		; 5F 30 3B 00 ; Exclusive OR accumulator with memory (long,X) $003B30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $0F		; 90 0F ; Branch if carry clear to $90, $0F [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora [$62.b]		; 07 62 ; OR accumulator with memory (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	tsb $037C.w		; 0C 7C 03 ; Test and set bits $037C.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$74.b		; C0 74 ; Compare #$74.b with Y register [Reads: Y Index] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jmp ($1C90.w)		; 6C 90 1C ; Jump indirect to ($1C90.w) [Flow: jump]
	cpx #$FE.b		; E0 FE ; Compare #$FE.b with X register [Reads: X Index] [Flags: ZNC]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	trb $1C3A.w		; 1C 3A 1C ; Test and reset bits $1C3A.w [Reads: Accumulator] [Flags: Z]
	trb $0C00.w		; 1C 00 0C ; Test and reset bits $0C00.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	cpx #$4C.b		; E0 4C ; Compare #$4C.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $1804.w		; 20 04 18 ; Jump to subroutine at $1804.w [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpx #$E6.b		; E0 E6 ; Compare #$E6.b with X register [Reads: X Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($32.b),Y		; 11 32 ; OR accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $033C.w		; 0D 3C 03 ; Logical OR $033C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $0C1710.l,X		; 3F 10 17 0C ; AND accumulator with memory (long,X) $0C1710.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $301022.l		; 0F 22 10 30 ; OR accumulator with memory (long) $301022.l [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000E00.l,X		; 1F 00 0E 00 ; Logical OR long $000E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	jmp $3CB0.w		; 4C B0 3C ; Jump to $3CB0.w [Flow: jump]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $44		; F0 44 ; Branch if equal to $F0, $44 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $3C30.w		; 0C 30 3C ; Test and set bits $3C30.w [Reads: Accumulator] [Flags: Z]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $DC		; 10 DC ; Branch if plus to $10, $DC [Flow: branch]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $04		; 10 04 ; Branch if plus to $10, $04 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $00F0.w		; 0C F0 00 ; Test and set bits $00F0.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $300F10.l		; 0F 10 0F 30 ; OR accumulator with memory (long) $300F10.l [Writes: Accumulator] [Flags: ZN]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$18.b		; C0 18 ; Compare #$18.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$3C.b		; E0 3C ; Compare #$3C.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$08.b		; E0 08 ; Compare #$08.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $000F10.l		; 0F 10 0F 00 ; OR accumulator with memory (long) $000F10.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$18.b		; C0 18 ; Compare #$18.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$08.b		; E0 08 ; Compare #$08.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$08.b		; E0 08 ; Compare #$08.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $3C		; F0 3C ; Branch if equal to $F0, $3C [Flow: branch]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $2F01.w,X		; 3E 01 2F ; Rotate left $2F01.w,X [Reads: X Index] [Flags: ZNC]
	trb $003F.w		; 1C 3F 00 ; Test and reset bits $003F.w [Reads: Accumulator] [Flags: Z]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $200F20.l		; 0F 20 0F 20 ; OR accumulator with memory (long) $200F20.l [Writes: Accumulator] [Flags: ZN]
	trb $3C.b		; 14 3C ; Test and reset bits $3C.b [Reads: Accumulator] [Flags: Z]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$74.b		; C0 74 ; Compare #$74.b with Y register [Reads: Y Index] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jmp $3CB0.w		; 4C B0 3C ; Jump to $3CB0.w [Flow: jump]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	mvp $0C,$08		; 44 08 0C ; Move block positive $0C,$08 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3C.b),Y		; 11 3C ; OR accumulator with memory ($3C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$3F.b		; 09 3F ; Logical OR #$3F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $063F.w		; 1C 3F 06 ; Test and reset bits $063F.w [Reads: Accumulator] [Flags: Z]
	asl $1000.w,X		; 1E 00 10 ; Arithmetic shift left $1000.w,X [Reads: X Index] [Flags: ZNC]
	ora $200F30.l		; 0F 30 0F 20 ; OR accumulator with memory (long) $200F30.l [Writes: Accumulator] [Flags: ZN]
	ora $3C1428.l		; 0F 28 14 3C ; OR accumulator with memory (long) $3C1428.l [Writes: Accumulator] [Flags: ZN]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C03C.w		; 20 3C C0 ; Jump to subroutine at $C03C.w [Writes: Stack Pointer] [Flow: call]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	jmp $3CB0.w		; 4C B0 3C ; Jump to $3CB0.w [Flow: jump]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	mvp $0C,$08		; 44 08 0C ; Move block positive $0C,$08 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$19.b		; 09 19 ; Logical OR #$19.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C020.w		; 20 20 C0 ; Jump to subroutine at $C020.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E0.b		; 14 E0 ; Test and reset bits $E0.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy #$08.b		; C0 08 ; Compare #$08.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	ora #$19.b		; 09 19 ; Logical OR #$19.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: ZNC]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $08F4.w		; 20 F4 08 ; Jump to subroutine at $08F4.w [Writes: Stack Pointer] [Flow: call]
	cpx $1C10.w		; EC 10 1C ; Compare $1C10.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	tsb $1C10.w		; 0C 10 1C ; Test and set bits $1C10.w [Reads: Accumulator] [Flags: Z]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: ZNC]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	ora #$19.b		; 09 19 ; Logical OR #$19.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $0E0E.w,Y		; 39 0E 0E ; AND accumulator with memory $0E0E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($38.b,X)		; 01 38 ; Logical OR ($38.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $DC		; 10 DC ; Branch if plus to $10, $DC [Flow: branch]
	jsr $08F6.w		; 20 F6 08 ; Jump to subroutine at $08F6.w [Writes: Stack Pointer] [Flow: call]
	sbc $E61F12.l		; EF 12 1F E6 ; Subtract with carry (long) $E61F12.l [Writes: Accumulator] [Flags: ZVNC]
	inc $E000.w,X		; FE 00 E0 ; Increment memory $E000.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	cpx $07.b		; E4 07 ; Compare $07.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	ora $E01E10.l		; 0F 10 1E E0 ; OR accumulator with memory (long) $E01E10.l [Writes: Accumulator] [Flags: ZN]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3311.w		; 2E 11 33 ; Rotate left $3311.w [Flags: ZNC]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $0C1F00.l,X		; 1F 00 1F 0C ; Logical OR long $0C1F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000E00.l,X		; 1F 00 0E 00 ; Logical OR long $000E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	cpy $3830.w		; CC 30 38 ; Compare $3830.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000300.l,X		; 1F 00 03 00 ; Logical OR long $000300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; [PATTERN: Memory clearing operation] 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C8.b,X		; 34 C8 ; Test bits $C8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	stz $98.b		; 64 98 ; Store zero to $98.b
	stz $7C60.w		; 9C 60 7C ; Store zero to $7C60.w
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($7838.w,X)		; FC 38 78 ; Jump to subroutine indirect indexed ($7838.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $7C60.w		; 1C 60 7C ; Test and reset bits $7C60.w [Reads: Accumulator] [Flags: Z]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000300.l		; 0F 00 03 00 ; OR accumulator with memory (long) $000300.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; [PATTERN: Memory clearing operation] 18 ; Clear carry flag [Flags: C]
	cpx #$34.b		; E0 34 ; Compare #$34.b with X register [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	stz $98.b		; 64 98 ; Store zero to $98.b
	stz $7C60.w		; 9C 60 7C ; Store zero to $7C60.w
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($FC38.w,X)		; FC 38 FC ; Jump to subroutine indirect indexed ($FC38.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $0038.w		; 20 38 00 ; Jump to subroutine at $0038.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$0C.b		; E0 0C ; Compare #$0C.b with X register [Reads: X Index] [Flags: ZNC]
	.db $90, $3C		; 90 3C ; Branch if carry clear to $90, $3C [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp ($FC80.w,X)		; 7C 80 FC ; Jump indirect indexed to ($FC80.w,X) [Reads: X Index] [Flow: jump]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9B.b		; 00 9B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $BD.b		; 04 BD ; Test and set bits $BD.b [Reads: Accumulator] [Flags: Z]
	cop $59.b		; 02 59 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp ($3B00.w)		; 6C 00 3B ; Jump indirect to ($3B00.w) [Flow: jump]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	jmp ($2600.w,X)		; 7C 00 26 ; Jump indirect indexed to ($2600.w,X) [Reads: X Index] [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $1B00.w,X		; 3E 00 1B ; Rotate left $1B00.w,X [Reads: X Index] [Flags: ZNC]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $7E10.w		; EC 10 7E ; Compare $7E10.w with X register [Reads: X Index] [Flags: ZNC]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	mvn $07,$78		; 54 78 07 ; Move block negative $07,$78 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	pea $3808.w		; F4 08 38 ; Push absolute address $3808.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $1C18.w,X		; 3C 18 1C ; Test bits $1C18.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $8C		; 30 8C ; Branch if minus to $30, $8C [Flow: branch]
	.db $70, $DC		; 70 DC ; Branch if overflow set to $70, $DC [Flow: branch]
	and $FE.b,S		; 23 FE ; AND accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F8.b,X		; 34 F8 ; Test bits $F8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	stz $F0.b,X		; 74 F0 ; Store zero to $F0.b,X [Reads: X Index]
	lda $00DFE0.l		; AF E0 DF 00 ; Load long $00DFE0.l into accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $19.b		; 04 19 ; Test and set bits $19.b [Reads: Accumulator] [Flags: Z]
	rol $19.b		; 26 19 ; Rotate left $19.b [Reads: Direct Page] [Flags: ZNC]
	inc $1E.b		; E6 1E ; Increment $1E.b [Reads: Direct Page] [Flags: ZN]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0F.b		; 14 0F ; Test and reset bits $0F.b [Reads: Accumulator] [Flags: Z]
	rol $0F.b,X		; 36 0F ; Rotate left $0F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inc $06.b,X		; F6 06 ; Increment memory $06.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $40BC.w		; 20 BC 40 ; Jump to subroutine at $40BC.w [Writes: Stack Pointer] [Flow: call]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	stz $DC.b		; 64 DC ; Store zero to $DC.b
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	jmp $F06FF0.l		; 5C F0 6F F0 ; Jump long to $F06FF0.l [Flow: jump]
	and $000000.l		; 2F 00 00 00 ; AND accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E31.w		; 0C 31 0E ; Test and set bits $0E31.w [Reads: Accumulator] [Flags: Z]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	bit $3F.b		; 24 3F ; Test bits $3F.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2E1F.w		; 0C 1F 2E ; Test and set bits $2E1F.w [Reads: Accumulator] [Flags: Z]
	ora $F907F5.l		; 0F F5 07 F9 ; OR accumulator with memory (long) $F907F5.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $4C		; 30 4C ; Branch if minus to $30, $4C [Flow: branch]
	.db $30, $3B		; 30 3B ; Branch if minus to $30, $3B [Flow: branch]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$F8.b		; A0 F8 ; Load #$F8.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ora $001F20.l		; 0F 20 1F 00 ; OR accumulator with memory (long) $001F20.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $D1.b		; 06 D1 ; Arithmetic shift left $D1.b [Reads: Direct Page] [Flags: ZNC]
	rol $C23D.w		; 2E 3D C2 ; Rotate left $C23D.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	ora $EE1F36.l		; 0F 36 1F EE ; OR accumulator with memory (long) $EE1F36.l [Writes: Accumulator] [Flags: ZN]
	ora $0000E2.l,X		; 1F E2 00 00 ; Logical OR long $0000E2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stz $5C.b		; 64 5C ; Store zero to $5C.b
	and $3C.b,S		; 23 3C ; AND accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $6C		; F0 6C ; Branch if equal to $F0, $6C [Flow: branch]
	.db $70, $2F		; 70 2F ; Branch if overflow set to $70, $2F [Flow: branch]
	jsr $001F.w		; 20 1F 00 ; Jump to subroutine at $001F.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $11.b		; 04 11 ; Test and set bits $11.b [Reads: Accumulator] [Flags: Z]
	asl $EC12.w		; 0E 12 EC ; Arithmetic shift left $EC12.w [Flags: ZNC]
	trb $00E0.w		; 1C E0 00 ; Test and reset bits $00E0.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	asl $EC1E.w		; 0E 1E EC ; Arithmetic shift left $EC1E.w [Flags: ZNC]
	tsb $00F0.w		; 0C F0 00 ; Test and set bits $00F0.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0902.w		; 0D 02 09 ; Logical OR $0902.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0802.w		; 0D 02 08 ; Logical OR $0802.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp [$38.b]		; C7 38 ; Compare accumulator (long) [$38.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	adc $0000BA.l,X		; 7F BA 00 00 ; Add long $0000BA.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta ($00.b)		; 92 00 ; Store accumulator (indirect) ($00.b) [Reads: Accumulator, Direct Page]
	rol $5E00.w		; 2E 00 5E ; Rotate left $5E00.w [Flags: ZNC]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $36.b		; 02 36 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0A1F.w		; 0C 1F 0A ; Test and set bits $0A1F.w [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $001F00.l,X		; 3F 00 1F 00 ; AND accumulator with memory (long,X) $001F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$3E.b]		; 07 3E ; OR accumulator with memory (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $03.b		; 14 03 ; Test and reset bits $03.b [Reads: Accumulator] [Flags: Z]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E8		; 80 E8 ; Branch always to $80, $E8 [Flow: branch]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3C72.w		; 0C 72 3C ; Test and set bits $3C72.w [Reads: Accumulator] [Flags: Z]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$08.b		; E0 08 ; Compare #$08.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $FEF0.w		; 0C F0 FE ; Test and set bits $FEF0.w [Reads: Accumulator] [Flags: Z]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $33		; 10 33 ; Branch if plus to $10, $33 [Flow: branch]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $0C1F00.l,X		; 1F 00 1F 0C ; Logical OR long $0C1F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $101320.l		; 0F 20 13 10 ; OR accumulator with memory (long) $101320.l [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000E00.l,X		; 1F 00 0E 00 ; Logical OR long $000E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $48.b,X		; B4 48 ; Load Y register $48.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	cpy $3830.w		; CC 30 38 ; Compare $3830.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F2		; 10 F2 ; Branch if plus to $10, $F2 [Flow: branch]
	ora $037C.w		; 0D 7C 03 ; Logical OR $037C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $0C1710.l,X		; 3F 10 17 0C ; AND accumulator with memory (long,X) $0C1710.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $7050E2.l		; 4F E2 50 70 ; Exclusive OR accumulator with memory (long) $7050E2.l [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000C00.l,X		; 1F 00 0C 00 ; Logical OR long $000C00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $C8.b,X		; 35 C8 ; Logical AND $C8.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp $3CB0.w		; 4C B0 3C ; Jump to $3CB0.w [Flow: jump]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $44		; F0 44 ; Branch if equal to $F0, $44 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $3C30.w		; 0C 30 3C ; Test and set bits $3C30.w [Reads: Accumulator] [Flags: Z]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($32.b),Y		; 11 32 ; OR accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $033C.w		; 0D 3C 03 ; Logical OR $033C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $0C1710.l,X		; 3F 10 17 0C ; AND accumulator with memory (long,X) $0C1710.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $301022.l		; 0F 22 10 30 ; OR accumulator with memory (long) $301022.l [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000C00.l,X		; 1F 00 0C 00 ; Logical OR long $000C00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $A05E80.l,X		; 7F 80 5E A0 ; Add long $A05E80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $FCC0.w,X		; 3C C0 FC ; Test bits $FCC0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $0C5E.w		; EC 5E 0C ; Compare $0C5E.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $3C30.w		; 0C 30 3C ; Test and set bits $3C30.w [Reads: Accumulator] [Flags: Z]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $33		; 10 33 ; Branch if plus to $10, $33 [Flow: branch]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $0C1F00.l,X		; 1F 00 1F 0C ; Logical OR long $0C1F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $101320.l		; 0F 20 13 10 ; OR accumulator with memory (long) $101320.l [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000E00.l,X		; 1F 00 0E 00 ; Logical OR long $000E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C8.b,X		; 34 C8 ; Test bits $C8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cpy $3830.w		; CC 30 38 ; Compare $3830.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$19.b		; 09 19 ; Logical OR #$19.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $F8E0.w		; 1C E0 F8 ; Test and reset bits $F8E0.w [Reads: Accumulator] [Flags: Z]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$04.b		; C0 04 ; Compare #$04.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $344B.w		; 20 4B 34 ; Jump to subroutine at $344B.w [Writes: Stack Pointer] [Flow: call]
	jmp $5E33.w		; 4C 33 5E ; Jump to $5E33.w [Flow: jump]
	and ($3F.b,X)		; 21 3F ; Logical AND ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3778.w		; 2C 78 37 ; Test bits $3778.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $7C.b,X		; 35 7C ; Logical AND $7C.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $3F183F.l		; 22 3F 18 3F ; Jump to subroutine long $3F183F.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $0E00.w,X		; 1E 00 0E ; Arithmetic shift left $0E00.w,X [Reads: X Index] [Flags: ZNC]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $D2.b		; 04 D2 ; Test and set bits $D2.b [Reads: Accumulator] [Flags: Z]
	bit $CC32.w		; 2C 32 CC ; Test bits $CC32.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sty $FE.b		; 84 FE ; Store Y register to $FE.b [Reads: Y Index]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1E.b,X		; 34 1E ; Test bits $1E.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cpx $AC1E.w		; EC 1E AC ; Compare $AC1E.w with X register [Reads: X Index] [Flags: ZNC]
	rol $FE44.w,X		; 3E 44 FE ; Rotate left $FE44.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($7818.w,X)		; FC 18 78 ; Jump to subroutine indirect indexed ($7818.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $46		; 10 46 ; Branch if plus to $10, $46 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1200.w		; 0C 00 12 ; Test and set bits $1200.w [Reads: Accumulator] [Flags: Z]
	tsb $0C32.w		; 0C 32 0C ; Test and set bits $0C32.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E00.w		; 0C 00 1E ; Test and set bits $1E00.w [Reads: Accumulator] [Flags: Z]
	tsb $0C3E.w		; 0C 3E 0C ; Test and set bits $0C3E.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $47		; 10 47 ; Branch if plus to $10, $47 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $7F		; 10 7F ; Branch if plus to $10, $7F [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3400.w		; 0C 00 34 ; Test and set bits $3400.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3C00.w		; 0C 00 3C ; Test and set bits $3C00.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($0038.w,X)		; FC 38 00 ; Jump to subroutine indirect indexed ($0038.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $44		; 30 44 ; Branch if minus to $30, $44 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $B0, $40		; B0 40 ; Branch if carry set to $B0, $40 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $7C		; 30 7C ; Branch if minus to $30, $7C [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0C1300.l		; 0F 00 13 0C ; OR accumulator with memory (long) $0C1300.l [Writes: Accumulator] [Flags: ZN]
	jsl $00001C.l		; 22 1C 00 00 ; Jump to subroutine long $00001C.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1F02.w		; 0D 02 1F ; Logical OR $1F02.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $1C3E.w		; 0C 3E 1C ; Test and set bits $1C3E.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $0D02.w		; 0D 02 0D ; Logical OR $0D02.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	stx $0070.w		; 8E 70 00 ; Store X register to $0070.w [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FE		; 80 FE ; Branch always to $80, $FE [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inc $0074.w,X		; FE 74 00 ; Increment memory $0074.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $6090.w		; 20 90 60 ; Jump to subroutine at $6090.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stz $78.b		; 64 78 ; Store zero to $78.b
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $60F0.w		; 20 F0 60 ; Jump to subroutine at $60F0.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $6C		; F0 6C ; Branch if equal to $F0, $6C [Flow: branch]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	jsr $001F.w		; 20 1F 00 ; Jump to subroutine at $001F.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: ZNC]
	rol $3E.b		; 26 3E ; Rotate left $3E.b [Reads: Direct Page] [Flags: ZNC]
	cpy #$3C.b		; C0 3C ; Compare #$3C.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	rol $0E.b,X		; 36 0E ; Rotate left $0E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $609C.w		; 20 9C 60 ; Jump to subroutine at $609C.w [Writes: Stack Pointer] [Flow: call]
	lda $00FF40.l,X		; BF 40 FF 00 ; Load long $00FF40.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $70EC.w		; 20 EC 70 ; Jump to subroutine at $70EC.w [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	mvp $3B,$FC		; 44 FC 3B ; Move block positive $3B,$FC [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and ($0C.b)		; 32 0C ; AND accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc ($0C.b)		; F2 0C ; Subtract with carry (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	trb $00E0.w		; 1C E0 00 ; Test and reset bits $00E0.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	tsb $2CDE.w		; 0C DE 2C ; Test and set bits $2CDE.w [Reads: Accumulator] [Flags: Z]
	tsb $00F0.w		; 0C F0 00 ; Test and set bits $00F0.w [Reads: Accumulator] [Flags: Z]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $205C.w		; 20 5C 20 ; Jump to subroutine at $205C.w [Writes: Stack Pointer] [Flow: call]
	bit $3C03.w,X		; 3C 03 3C ; Test bits $3C03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	.db $70, $2C		; 70 2C ; Branch if overflow set to $70, $2C [Flow: branch]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	jsr $001F.w		; 20 1F 00 ; Jump to subroutine at $001F.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $29.b		; 04 29 ; Test and set bits $29.b [Reads: Accumulator] [Flags: Z]
	asl $0D.b,X		; 16 0D ; Arithmetic shift left $0D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc ($1E.b)		; F2 1E ; Subtract with carry (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0F.b		; 14 0F ; Test and reset bits $0F.b [Reads: Accumulator] [Flags: Z]
	rol $07.b,X		; 36 07 ; Rotate left $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $0006.w,Y		; 19 06 00 ; OR accumulator with memory $0006.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy $0030.w		; CC 30 00 ; Compare $0030.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $6CFE.w		; 0C FE 6C ; Test and set bits $6CFE.w [Reads: Accumulator] [Flags: Z]
	jsr ($4F30.w,X)		; FC 30 4F ; Jump to subroutine indirect indexed ($4F30.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $2F		; 30 2F ; Branch if minus to $30, $2F [Flow: branch]
	.db $10, $16		; 10 16 ; Branch if plus to $10, $16 [Flow: branch]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $103F.w		; 0C 3F 10 ; Test and set bits $103F.w [Reads: Accumulator] [Flags: Z]
	rol $1C1C.w,X		; 3E 1C 1C ; Rotate left $1C1C.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3F.b,X		; 36 3F ; Rotate left $3F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora ($1A.b)		; 12 1A ; OR accumulator with memory (indirect) ($1A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $9C		; 80 9C ; Branch always to $80, $9C [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($1818.w,X)		; FC 18 18 ; Jump to subroutine indirect indexed ($1818.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $7A		; B0 7A ; Branch if carry set to $B0, $7A [Flow: branch]
	ldy $36.b,X		; B4 36 ; Load Y register $36.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	stz $E400.w		; 9C 00 E4 ; Store zero to $E400.w
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $2F		; 30 2F ; Branch if minus to $30, $2F [Flow: branch]
	.db $10, $17		; 10 17 ; Branch if plus to $10, $17 [Flow: branch]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	tsb $103F.w		; 0C 3F 10 ; Test and set bits $103F.w [Reads: Accumulator] [Flags: Z]
	rol $1C1C.w,X		; 3E 1C 1C ; Rotate left $1C1C.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3F.b,X		; 35 3F ; Logical AND $3F.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($1B.b),Y		; 11 1B ; OR accumulator with memory ($1B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $9C		; 10 9C ; Branch if plus to $10, $9C [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($1818.w,X)		; FC 18 18 ; Jump to subroutine indirect indexed ($1818.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $F2.b,X		; B4 F2 ; Load Y register $F2.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	sty $6886.w		; 8C 86 68 ; Store Y register to $6886.w [Reads: Y Index]
	stz $E400.w		; 9C 00 E4 ; Store zero to $E400.w
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $003F00.l,X		; 3F 00 3F 00 ; AND accumulator with memory (long,X) $003F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $1C2F10.l,X		; 3F 10 2F 1C ; AND accumulator with memory (long,X) $1C2F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w,X		; 1E 00 00 ; Arithmetic shift left $0000.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $063F.w,Y		; 19 3F 06 ; OR accumulator with memory $063F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and $013E06.l,X		; 3F 06 3E 01 ; AND accumulator with memory (long,X) $013E06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $001E00.l,X		; 3F 00 1E 00 ; AND accumulator with memory (long,X) $001E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	jsr ($FC00.w,X)		; FC 00 FC ; Jump to subroutine indirect indexed ($FC00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pea $7838.w		; F4 38 78 ; Push absolute address $7838.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($FC60.w,X)		; FC 60 FC ; Jump to subroutine indirect indexed ($FC60.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($FC80.w,X)		; 7C 80 FC ; Jump indirect indexed to ($FC80.w,X) [Reads: X Index] [Flow: jump]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0E06.w,Y		; 19 06 0E ; OR accumulator with memory $0E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $00FC.w		; 20 FC 00 ; Jump to subroutine at $00FC.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C020.w		; 20 20 C0 ; Jump to subroutine at $C020.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $3CAC.w,X		; 7E AC 3C ; Rotate right $3CAC.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$08.b		; C0 08 ; Compare #$08.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $33		; 10 33 ; Branch if plus to $10, $33 [Flow: branch]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $0C1F00.l,X		; 1F 00 1F 0C ; Logical OR long $0C1F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $101320.l		; 0F 20 13 10 ; OR accumulator with memory (long) $101320.l [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000E00.l,X		; 1F 00 0E 00 ; Logical OR long $000E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	cpy $3830.w		; CC 30 38 ; Compare $3830.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2F.b,X)		; 01 2F ; Logical OR ($2F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	trb $043F.w		; 1C 3F 04 ; Test and reset bits $043F.w [Reads: Accumulator] [Flags: Z]
	and $001F00.l,X		; 3F 00 1F 00 ; AND accumulator with memory (long,X) $001F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($3C3B.w,X)		; 7C 3B 3C ; Jump indirect indexed to ($3C3B.w,X) [Reads: X Index] [Flow: jump]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3E.b,X)		; 01 3E ; Logical OR ($3E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $94		; F0 94 ; Branch if equal to $F0, $94 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	jmp $BCB0.w		; 4C B0 BC ; Jump to $BCB0.w [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr ($F808.w,X)		; FC 08 F8 ; Jump to subroutine indirect indexed ($F808.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	mvp $0C,$08		; 44 08 0C ; Move block positive $0C,$08 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $B0, $BC		; B0 BC ; Branch if carry set to $B0, $BC [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	and $1C3F10.l,X		; 3F 10 3F 1C ; AND accumulator with memory (long,X) $1C3F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $1C1C.w,X		; 3E 1C 1C ; Rotate left $1C1C.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $101320.l		; 0F 20 13 10 ; OR accumulator with memory (long) $101320.l [Writes: Accumulator] [Flags: ZN]
	tsb $032C.w		; 0C 2C 03 ; Test and set bits $032C.w [Reads: Accumulator] [Flags: Z]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $1C00.w,X		; 3E 00 1C ; Rotate left $1C00.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpy $3C30.w		; CC 30 3C ; Compare $3C30.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $3C30.w		; 0C 30 3C ; Test and set bits $3C30.w [Reads: Accumulator] [Flags: Z]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $2C.b		; 04 2C ; Test and set bits $2C.b [Reads: Accumulator] [Flags: Z]
	ora ($1F.b,S),Y		; 13 1F ; OR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FFC63F.l		; 22 3F C6 FF ; Jump to subroutine long $FFC63F.l [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $0F		; 80 0F ; Branch always to $80, $0F [Flow: branch]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	.db $30, $3F		; 30 3F ; Branch if minus to $30, $3F [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $CC8C.w		; 8C 8C CC ; Store Y register to $CC8C.w [Reads: Y Index]
	cpy $7C7F.w		; CC 7F 7C ; Compare $7C7F.w with Y register [Reads: Y Index] [Flags: ZNC]
	adc $203F70.l,X		; 7F 70 3F 20 ; Add long $203F70.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $407F00.l,X		; 3F 00 7F 40 ; AND accumulator with memory (long,X) $407F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2121.w		; 20 21 21 ; Jump to subroutine at $2121.w [Writes: Stack Pointer] [Flow: call]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $36.b,X		; F6 36 ; Increment memory $36.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	inc $FC0E.w,X		; FE 0E FC ; Increment memory $FC0E.w,X [Reads: X Index] [Flags: ZN]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	ora $20.b,S		; 03 20 ; OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $071800.l		; 0F 00 18 07 ; OR accumulator with memory (long) $071800.l [Writes: Accumulator] [Flags: ZN]
	stz $0B.b,X		; 74 0B ; Store zero to $0B.b,X [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$2E.b		; E0 2E ; Compare #$2E.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $5C.b,S		; 03 5C ; OR accumulator with stack relative $5C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $08B8.w		; 0C B8 08 ; Test and set bits $08B8.w [Reads: Accumulator] [Flags: Z]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $000015.l		; EF 15 00 00 ; Subtract with carry (long) $000015.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $5303.w		; 0C 03 53 ; Test and set bits $5303.w [Reads: Accumulator] [Flags: Z]
	ora $F40FF7.l		; 0F F7 0F F4 ; OR accumulator with memory (long) $F40FF7.l [Writes: Accumulator] [Flags: ZN]
	ora $0005FA.l		; 0F FA 05 00 ; OR accumulator with memory (long) $0005FA.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$1A.b		; C0 1A ; Compare #$1A.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	.db $F0, $ED		; F0 ED ; Branch if equal to $F0, $ED [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc [$EA.b],Y		; F7 EA ; Subtract with carry (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	nop		; EA ; No operation
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	.db $F0, $D7		; F0 D7 ; Branch if equal to $F0, $D7 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $00E0.w,X		; 1D E0 00 ; OR accumulator with memory $00E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp.w [$FC20]		; DC 20 FC ; Jump long indirect [$FC20] [Flow: jump]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $AC		; F0 AC ; Branch if equal to $F0, $AC [Flow: branch]
	.db $F0, $8F		; F0 8F ; Branch if equal to $F0, $8F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3A00.w		; 0C 00 3A ; Test and set bits $3A00.w [Reads: Accumulator] [Flags: Z]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1E.b		; 24 1E ; Test bits $1E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $1C		; 30 1C ; Branch if minus to $30, $1C [Flow: branch]
	cpx #$DF.b		; E0 DF ; Compare #$DF.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $033C.w		; 20 3C 03 ; Jump to subroutine at $033C.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	cpx $2FF0.w		; EC F0 2F ; Compare $2FF0.w with X register [Reads: X Index] [Flags: ZNC]
	jsr $001F.w		; 20 1F 00 ; Jump to subroutine at $001F.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $39.b		; 04 39 ; Test and set bits $39.b [Reads: Accumulator] [Flags: Z]
	asl $DD.b		; 06 DD ; Arithmetic shift left $DD.b [Reads: Direct Page] [Flags: ZNC]
	jsl $00F00E.l		; 22 0E F0 00 ; Jump to subroutine long $00F00E.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	rol $07.b,X		; 36 07 ; Rotate left $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $000F00.l		; 0F 00 0F 00 ; OR accumulator with memory (long) $000F00.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $060F06.l		; 0F 06 0F 06 ; OR accumulator with memory (long) $060F06.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $C8		; 70 C8 ; Branch if overflow set to $70, $C8 [Flow: branch]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $C6		; B0 C6 ; Branch if carry set to $B0, $C6 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $0E04.w		; 0E 04 0E ; Arithmetic shift left $0E04.w [Flags: ZNC]
	trb $86.b		; 14 86 ; Test and reset bits $86.b [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy $B8.b		; C4 B8 ; Compare $B8.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	.db $82, $7C, $00		; 82 7C 00 ; Branch always long to $82, $7C, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$16.b]		; 07 16 ; OR accumulator with memory (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$1F.b		; 09 1F ; Logical OR #$1F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$1F.b		; 09 1F ; Logical OR #$1F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0060.w,X		; 9E 60 00 ; Store zero to $0060.w,X [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $02		; 70 02 ; Branch if overflow set to $70, $02 [Flow: branch]
	jsr ($EC12.w,X)		; FC 12 EC ; Jump to subroutine indirect indexed ($EC12.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $003FC0.l,X		; FF C0 3F 00 ; Subtract with carry (long,X) $003FC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $00FF00.l,X		; 7F 00 FF 00 ; Add long $00FF00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	trb $0CFF.w		; 1C FF 0C ; Test and reset bits $0CFF.w [Reads: Accumulator] [Flags: Z]
	sbc $00FE00.l,X		; FF 00 FE 00 ; Subtract with carry (long,X) $00FE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: ZN]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $3C00.w,X		; 3C 00 3C ; Test bits $3C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $DA.b		; 04 DA ; Test and set bits $DA.b [Reads: Accumulator] [Flags: Z]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ror $20.b		; 66 20 ; Rotate right $20.b [Reads: Direct Page] [Flags: ZNC]
	adc [$31.b],Y		; 77 31 ; Add with carry (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $3F19.w,Y		; 39 19 3F ; AND accumulator with memory $3F19.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $122F.w		; 0E 2F 12 ; Arithmetic shift left $122F.w [Flags: ZNC]
	eor [$38.b]		; 47 38 ; Exclusive OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	.db $10, $B7		; 10 B7 ; Branch if plus to $10, $B7 [Flow: branch]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $7F		; 10 7F ; Branch if plus to $10, $7F [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $20.b,X		; F5 20 ; Subtract $20.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	ora ($66.b)		; 12 66 ; OR accumulator with memory (indirect) ($66.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $E6.b		; 04 E6 ; Test and set bits $E6.b [Reads: Accumulator] [Flags: Z]
	sty $CC.b		; 84 CC ; Store Y register to $CC.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	tsb $E2.b		; 04 E2 ; Test and set bits $E2.b [Reads: Accumulator] [Flags: Z]
	trb $38C4.w		; 1C C4 38 ; Test and reset bits $38C4.w [Reads: Accumulator] [Flags: Z]
	cmp [$08.b],Y		; D7 08 ; Compare accumulator (long indexed) [$08.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sbc $DA00.w		; ED 00 DA ; Subtract $DA00.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $FE.b		; C4 FE ; Compare $FE.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	jmp.w [$38FC]		; DC FC 38 ; Jump long indirect [$38FC] [Flow: jump]
	inc $0A.b,X		; F6 0A ; Increment memory $0A.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $EF.b		; 05 EF ; Logical OR $EF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta ($60.b),Y		; 91 60 ; Store accumulator ($60.b),Y [Reads: Accumulator, Direct Page, Y Index]
	jmp $003F20.l		; 5C 20 3F 00 ; Jump long to $003F20.l [Flow: jump]
	trb $FD03.w		; 1C 03 FD ; Test and reset bits $FD03.w [Reads: Accumulator] [Flags: Z]
	adc $FE.b,S		; 63 FE ; Add with carry (stack relative) $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc ($EF.b,X)		; 61 EF ; Add with carry ($EF.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $F3		; 10 F3 ; Branch if plus to $10, $F3 [Flow: branch]
	jmp ($6EF1.w)		; 6C F1 6E ; Jump indirect to ($6EF1.w) [Flow: jump]
	jmp ($3323.w,X)		; 7C 23 33 ; Jump indirect indexed to ($3323.w,X) [Reads: X Index] [Flow: jump]
	tsb $0F10.w		; 0C 10 0F ; Test and set bits $0F10.w [Reads: Accumulator] [Flags: Z]
	and $969F12.l,X		; 3F 12 9F 96 ; AND accumulator with memory (long,X) $969F12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	.db $90, $D4		; 90 D4 ; Branch if carry clear to $90, $D4 [Flow: branch]
	cpy #$DE.b		; C0 DE ; Compare #$DE.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$D9.b		; C0 D9 ; Compare #$D9.b with Y register [Reads: Y Index] [Flags: ZNC]
	lsr $F9.b		; 46 F9 ; Logical shift right $F9.b [Reads: Direct Page] [Flags: ZNC]
	asl $FA.b		; 06 FA ; Arithmetic shift left $FA.b [Reads: Direct Page] [Flags: ZNC]
	tsb $CD.b		; 04 CD ; Test and set bits $CD.b [Reads: Accumulator] [Flags: Z]
	.db $D0, $69		; D0 69 ; Branch if not equal to $D0, $69 [Flow: branch]
	.db $F0, $6A		; F0 6A ; Branch if equal to $F0, $6A [Flow: branch]
	pea $E834.w		; F4 34 E8 ; Push absolute address $E834.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rol $BFE0.w,X		; 3E E0 BF ; Rotate left $BFE0.w,X [Reads: X Index] [Flags: ZNC]
	ror $EF.b		; 66 EF ; Rotate right $EF.b [Reads: Direct Page] [Flags: ZNC]
	asl $0E.b,X		; 16 0E ; Arithmetic shift left $0E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	pea $019E.w		; F4 9E 01 ; Push absolute address $019E.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and $0D3210.l		; 2F 10 32 0D ; AND accumulator with memory (long) $0D3210.l [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $387F.w		; 20 7F 38 ; Jump to subroutine at $387F.w [Writes: Stack Pointer] [Flow: call]
	jmp $003838.l		; 5C 38 38 00 ; Jump long to $003838.l [Flow: jump]
	.db $90, $0F		; 90 0F ; Branch if carry clear to $90, $0F [Flow: branch]
	jsr $220F.w		; 20 0F 22 ; Jump to subroutine at $220F.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$67.b]		; 07 67 ; OR accumulator with memory (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$BE.b		; C0 BE ; Compare #$BE.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp $3CB0.w		; 4C B0 3C ; Jump to $3CB0.w [Flow: jump]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $EC1E.w		; EC 1E EC ; Compare $EC1E.w with X register [Reads: X Index] [Flags: ZNC]
	jmp $0C00.w		; 4C 00 0C ; Jump to $0C00.w [Flow: jump]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	adc $387F30.l,X		; 7F 30 7F 38 ; Add long $387F30.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $301320.l		; 0F 20 13 30 ; OR accumulator with memory (long) $301320.l [Writes: Accumulator] [Flags: ZN]
	tsb $036C.w		; 0C 6C 03 ; Test and set bits $036C.w [Reads: Accumulator] [Flags: Z]
	adc $003800.l,X		; 7F 00 38 00 ; Add long $003800.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E8.b		; 14 E8 ; Test and reset bits $E8.b [Reads: Accumulator] [Flags: Z]
	tsb $3CF0.w		; 0C F0 3C ; Test and set bits $3CF0.w [Reads: Accumulator] [Flags: Z]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $3C30.w		; 0C 30 3C ; Test and set bits $3C30.w [Reads: Accumulator] [Flags: Z]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0E06.w,Y		; 19 06 0E ; OR accumulator with memory $0E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: ZNC]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: ZNC]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F4		; 80 F4 ; Branch always to $80, $F4 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx $1810.w		; EC 10 18 ; Compare $1810.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $94		; B0 94 ; Branch if carry set to $B0, $94 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $E8.b		; 04 E8 ; Test and set bits $E8.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $001C1C.l,X		; 3F 1C 1C 00 ; AND accumulator with memory (long,X) $001C1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	stz $FC60.w,X		; 9E 60 FC ; Store zero to $FC60.w,X [Reads: X Index]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $92.b,X		; 74 92 ; Store zero to $92.b,X [Reads: X Index]
	tsb $F00C.w		; 0C 0C F0 ; Test and set bits $F00C.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3801.w,X		; 3E 01 38 ; Rotate left $3801.w,X [Reads: X Index] [Flags: ZNC]
	asl $3C.b		; 06 3C ; Arithmetic shift left $3C.b [Reads: Direct Page] [Flags: ZNC]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$39.b		; A0 39 ; Load #$39.b into Y register [Writes: Y Index] [Flags: ZN]
	dec $1CF2.w		; CE F2 1C ; Decrement $1CF2.w [Flags: ZN]
	jmp.w [$0000]		; DC 00 00 ; Jump long indirect [$0000] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $1F		; D0 1F ; Branch if not equal to $D0, $1F [Flow: branch]
	jsr $C03E.w		; 20 3E C0 ; Jump to subroutine at $C03E.w [Writes: Stack Pointer] [Flow: call]
	jmp.w [$0000]		; DC 00 00 ; Jump long indirect [$0000] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $04.b		; C6 04 ; Decrement $04.b [Reads: Direct Page] [Flags: ZN]
	tsb $48.b		; 04 48 ; Test and set bits $48.b [Reads: Accumulator] [Flags: Z]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lsr $1342.w,X		; 5E 42 13 ; Logical shift right $1342.w,X [Reads: X Index] [Flags: ZNC]
	ora ($3A.b,S),Y		; 13 3A ; OR accumulator (stack relative indirect indexed) ($3A.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $D7.b		; 00 D7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A6.b		; 00 A6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $51.b		; 00 51 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $2F		; 30 2F ; Branch if minus to $30, $2F [Flow: branch]
	.db $10, $16		; 10 16 ; Branch if plus to $10, $16 [Flow: branch]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $103F.w		; 0C 3F 10 ; Test and set bits $103F.w [Reads: Accumulator] [Flags: Z]
	rol $1C1C.w,X		; 3E 1C 1C ; Rotate left $1C1C.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3F.b,X		; 36 3F ; Rotate left $3F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora ($1A.b)		; 12 1A ; OR accumulator with memory (indirect) ($1A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$6E.b		; C0 6E ; Compare #$6E.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $90, $9C		; 90 9C ; Branch if carry clear to $90, $9C [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($1818.w,X)		; FC 18 18 ; Jump to subroutine indirect indexed ($1818.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $02.b		; C4 02 ; Compare $02.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	jsr ($6806.w,X)		; FC 06 68 ; Jump to subroutine indirect indexed ($6806.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stz $E400.w		; 9C 00 E4 ; Store zero to $E400.w
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2C.b,S		; 03 2C ; OR accumulator with stack relative $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($32.b,S),Y		; 13 32 ; OR accumulator (stack relative indirect indexed) ($32.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $033C.w		; 0D 3C 03 ; Logical OR $033C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $1C3F10.l,X		; 3F 10 3F 1C ; AND accumulator with memory (long,X) $1C3F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w,X		; 1E 00 00 ; Arithmetic shift left $0000.w,X [Reads: X Index] [Flags: ZNC]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $200F20.l,X		; 1F 20 0F 20 ; Logical OR long $200F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	and $001E00.l,X		; 3F 00 1E 00 ; AND accumulator with memory (long,X) $001E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0CD0.w		; 2C D0 0C ; Test bits $0CD0.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	cpx $7E.b		; E4 7E ; Compare $7E.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sty $00FC.w		; 8C FC 00 ; Store Y register to $00FC.w [Reads: Y Index]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	tsb $E8.b		; 04 E8 ; Test and set bits $E8.b [Reads: Accumulator] [Flags: Z]
	asl $1E90.w		; 0E 90 1E ; Arithmetic shift left $1E90.w [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($8080.w,X)		; 7C 80 80 ; Jump indirect indexed to ($8080.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0619.w		; 0E 19 06 ; Arithmetic shift left $0619.w [Flags: ZNC]
	and $000000.l,X		; 3F 00 00 00 ; AND accumulator with memory (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F00.w		; 0E 00 1F ; Arithmetic shift left $1F00.w [Flags: ZNC]
	asl $061F.w		; 0E 1F 06 ; Arithmetic shift left $061F.w [Flags: ZNC]
	rol $0019.w,X		; 3E 19 00 ; Rotate left $0019.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $7E04.w		; 0E 04 7E ; Arithmetic shift left $7E04.w [Flags: ZNC]
	sty $0C.b		; 84 0C ; Store Y register to $0C.b [Reads: Y Index]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $4C		; 80 4C ; Branch always to $80, $4C [Flow: branch]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $EE.b		; 04 EE ; Test and set bits $EE.b [Reads: Accumulator] [Flags: Z]
	trb $CC.b		; 14 CC ; Test and reset bits $CC.b [Reads: Accumulator] [Flags: Z]
	.db $B0, $C4		; B0 C4 ; Branch if carry set to $B0, $C4 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $304C.w		; 20 4C 30 ; Jump to subroutine at $304C.w [Writes: Stack Pointer] [Flow: call]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	and $3C.b		; 25 3C ; Logical AND $3C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $053A.w,Y		; 19 3A 05 ; OR accumulator with memory $053A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	jsr $3478.w		; 20 78 34 ; Jump to subroutine at $3478.w [Writes: Stack Pointer] [Flow: call]
	.db $70, $2F		; 70 2F ; Branch if overflow set to $70, $2F [Flow: branch]
	jsr $201F.w		; 20 1F 20 ; Jump to subroutine at $201F.w [Writes: Stack Pointer] [Flow: call]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1200.w		; 0C 00 12 ; Test and set bits $1200.w [Reads: Accumulator] [Flags: Z]
	tsb $1C22.w		; 0C 22 1C ; Test and set bits $1C22.w [Reads: Accumulator] [Flags: Z]
	adc ($8C.b)		; 72 8C ; Add with carry (indirect) ($8C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C3E.w		; 0C 3E 1C ; Test and set bits $1C3E.w [Reads: Accumulator] [Flags: Z]
	rol $7ECC.w,X		; 3E CC 7E ; Rotate left $7ECC.w,X [Reads: X Index] [Flags: ZNC]
	ldy $7C.b,X		; B4 7C ; Load Y register $7C.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $B0, $74		; B0 74 ; Branch if carry set to $B0, $74 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $DF		; 70 DF ; Branch if overflow set to $70, $DF [Flow: branch]
	jsr $05FA.w		; 20 FA 05 ; Jump to subroutine at $05FA.w [Writes: Stack Pointer] [Flow: call]
	jmp ($0003.w,X)		; 7C 03 00 ; Jump indirect indexed to ($0003.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $F0.b,X		; 74 F0 ; Store zero to $F0.b,X [Reads: X Index]
	and $604FF0.l		; 2F F0 4F 60 ; AND accumulator with memory (long) $604FF0.l [Writes: Accumulator] [Flags: ZN]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $06F9.w		; 0C F9 06 ; Test and set bits $06F9.w [Reads: Accumulator] [Flags: Z]
	and $7DC6.w,Y		; 39 C6 7D ; AND accumulator with memory $7DC6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $82, $00, $00		; 82 00 00 ; Branch always long to $82, $00, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E10.w		; 0C 10 1E ; Test and set bits $1E10.w [Reads: Accumulator] [Flags: Z]
	bit $F60F.w		; 2C 0F F6 ; Test bits $F60F.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $DA3FE6.l,X		; 1F E6 3F DA ; Logical OR long $DA3FE6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	stz $5B60.w		; 9C 60 5B ; Store zero to $5B60.w
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($40.b,X)		; 01 40 ; Logical OR ($40.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $F0, $6C		; F0 6C ; Branch if equal to $F0, $6C [Flow: branch]
	.db $70, $2F		; 70 2F ; Branch if overflow set to $70, $2F [Flow: branch]
	jsr $201F.w		; 20 1F 20 ; Jump to subroutine at $201F.w [Writes: Stack Pointer] [Flow: call]
	ora $3C0F30.l,X		; 1F 30 0F 3C ; Logical OR long $3C0F30.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: ZNC]
	asl $1A.b		; 06 1A ; Arithmetic shift left $1A.b [Reads: Direct Page] [Flags: ZNC]
	cpx $3C.b		; E4 3C ; Compare $3C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy #$34.b		; C0 34 ; Compare #$34.b with Y register [Reads: Y Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpy $0030.w		; CC 30 00 ; Compare $0030.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $F60F36.l		; 0F 36 0F F6 ; OR accumulator with memory (long) $F60F36.l [Writes: Accumulator] [Flags: ZN]
	asl $04F4.w		; 0E F4 04 ; Arithmetic shift left $04F4.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	tsb $C8.b		; 04 C8 ; Test and set bits $C8.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp ($D004.w)		; 6C 04 D0 ; Jump indirect to ($D004.w) [Flow: jump]
	ora $60207F.l		; 0F 7F 20 60 ; OR accumulator with memory (long) $60207F.l [Writes: Accumulator] [Flags: ZN]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3E3E41.l,X		; 1F 41 3E 3E ; Logical OR long $3E3E41.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy $3AA8.w		; AC A8 3A ; Load $3AA8.w into Y register [Writes: Y Index] [Flags: ZN]
	cpx #$DA.b		; E0 DA ; Compare #$DA.b with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $AE		; 30 AE ; Branch if minus to $30, $AE [Flow: branch]
	sty $9E.b,X		; 94 9E ; Store Y register $9E.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	cpy #$54.b		; C0 54 ; Compare #$54.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	dec $EE20.w,X		; DE 20 EE ; Decrement memory $EE20.w,X [Reads: X Index] [Flags: ZN]
	.db $10, $B8		; 10 B8 ; Branch if plus to $10, $B8 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sta ($60.b)		; 92 60 ; Store accumulator (indirect) ($60.b) [Reads: Accumulator, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1003.w		; 0C 03 10 ; Test and set bits $1003.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $071800.l		; 0F 00 18 07 ; OR accumulator with memory (long) $071800.l [Writes: Accumulator] [Flags: ZN]
	stz $0B.b,X		; 74 0B ; Store zero to $0B.b,X [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$2E.b		; E0 2E ; Compare #$2E.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc ($01.b),Y		; 71 01 ; Add with carry ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $3C2F.w,Y		; BE 2F 3C ; Load X register $3C2F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $D10F7E.l		; 0F 7E 0F D1 ; OR accumulator with memory (long) $D10F7E.l [Writes: Accumulator] [Flags: ZN]
	ror $F8C7.w		; 6E C7 F8 ; Rotate right $F8C7.w [Flags: ZNC]
	sta $0000F0.l		; 8F F0 00 00 ; Store accumulator (long) $0000F0.l [Reads: Accumulator]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$94.b		; E0 94 ; Compare #$94.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C2.b		; C0 C2 ; Compare #$C2.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$78.b		; C0 78 ; Compare #$78.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $74		; 80 74 ; Branch always to $80, $74 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
.INDEX 8
	sep #$1C		; E2 1C
.ACCU 16
.INDEX 16
	rep #$3C		; C2 3C
	asl $3FF0.w		; 0E F0 3F ; Arithmetic shift left $3FF0.w [Flags: ZNC]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	ora ($38.b,X)		; 01 38 ; Logical OR ($38.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	rol $1DD0.w		; 2E D0 1D ; Rotate left $1DD0.w [Flags: ZNC]
	inc $FD.b		; E6 FD ; Increment $FD.b [Reads: Direct Page] [Flags: ZN]
	asl $1CFE.w		; 0E FE 1C ; Arithmetic shift left $1CFE.w [Flags: ZNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E806.w		; E0 06 E8 ; Compare #$E806.w with X register [Reads: X Index] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $10, $17		; 10 17 ; Branch if plus to $10, $17 [Flow: branch]
	cpx #$00FE.w		; E0 FE 00 ; Compare #$00FE.w with X register [Reads: X Index] [Flags: ZNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $13.b		; 04 13 ; Test and set bits $13.b [Reads: Accumulator] [Flags: Z]
	ora #$050B.w		; 09 0B 05 ; Logical OR #$050B.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($28.b)		; D4 28 ; Push effective indirect address ($28.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	jmp.w [$F820]		; DC 20 F8 ; Jump long indirect [$F820] [Flow: jump]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $C4		; 30 C4 ; Branch if minus to $30, $C4 [Flow: branch]
	ldy #$98C4.w		; A0 C4 98 ; Load #$98C4.w into Y register [Writes: Y Index] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($5F.b,X)		; 01 5F ; Logical OR ($5F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $001C04.l,X		; 7F 04 1C 00 ; Add long $001C04.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	tsb $7C.b		; 04 7C ; Test and set bits $7C.b [Reads: Accumulator] [Flags: Z]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00F8.w		; C0 F8 00 ; Compare #$00F8.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $09.b,X		; 36 09 ; Rotate left $09.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	bit $3E03.w,X		; 3C 03 3E ; Test bits $3E03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $1C2F.w		; 1C 2F 1C ; Test and reset bits $1C2F.w [Reads: Accumulator] [Flags: Z]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$30.b],Y		; 17 30 ; OR accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $022C.w		; 0C 2C 02 ; Test and set bits $022C.w [Reads: Accumulator] [Flags: Z]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $001C00.l,X		; 3F 00 1C 00 ; AND accumulator with memory (long,X) $001C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $5C80.w,X		; 7E 80 5C ; Rotate right $5C80.w,X [Reads: X Index] [Flags: ZNC]
	ldy #$C03C.w		; A0 3C C0 ; Load #$C03C.w into Y register [Writes: Y Index] [Flags: ZN]
	jsr ($F808.w,X)		; FC 08 F8 ; Jump to subroutine indirect indexed ($F808.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jmp $300C00.l		; 5C 00 0C 30 ; Jump long to $300C00.l [Flow: jump]
	bit $F8C0.w,X		; 3C C0 F8 ; Test bits $F8C0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $043F.w		; 1C 3F 04 ; Test and reset bits $043F.w [Reads: Accumulator] [Flags: Z]
	and $001C00.l,X		; 3F 00 1C 00 ; AND accumulator with memory (long,X) $001C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3F01.w,X		; 3E 01 3F ; Rotate left $3F01.w,X [Reads: X Index] [Flags: ZNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00F0.w		; C0 F0 00 ; Compare #$00F0.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $00FF2C.l,X		; 7F 2C FF 00 ; Add long $00FF2C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $00F800.l,X		; 7F 00 F8 00 ; Add long $00F800.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $609F4F.l,X		; BF 4F 9F 60 ; Load long $609F4F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and [$78.b]		; 27 78 ; AND accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$40.b]		; 07 40 ; OR accumulator with memory (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $7F		; 30 7F ; Branch if minus to $30, $7F [Flow: branch]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $2F7060.l,X		; FF 60 70 2F ; Subtract with carry (long,X) $2F7060.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $DE1F.w		; 20 1F DE ; Jump to subroutine at $DE1F.w [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	inc $3E54.w,X		; FE 54 3E ; Increment memory $3E54.w,X [Reads: X Index] [Flags: ZN]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	cpy #$00FF.w		; C0 FF 00 ; Compare #$00FF.w with Y register [Reads: Y Index] [Flags: ZNC]
	ror $98.b		; 66 98 ; Rotate right $98.b [Reads: Direct Page] [Flags: ZNC]
.INDEX 8
	sep #$1C		; E2 1C
	jmp ($5680.w,X)		; 7C 80 56 ; Jump indirect indexed to ($5680.w,X) [Reads: X Index] [Flow: jump]
	jsr $002E.w		; 20 2E 00 ; Jump to subroutine at $002E.w [Writes: Stack Pointer] [Flow: call]
	dec $3F00.w		; CE 00 3F ; Decrement $3F00.w [Flags: ZN]
	asl $DF.b		; 06 DF ; Arithmetic shift left $DF.b [Reads: Direct Page] [Flags: ZNC]
	rol $3E.b		; 26 3E ; Rotate left $3E.b [Reads: Direct Page] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	rol $1C5C.w,X		; 3E 5C 1C ; Rotate left $1C5C.w,X [Reads: X Index] [Flags: ZNC]
	ldy #$AF.b		; A0 AF ; Load #$AF.b into Y register [Writes: Y Index] [Flags: ZN]
	tsb $DA.b		; 04 DA ; Test and set bits $DA.b [Reads: Accumulator] [Flags: Z]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ror $20.b		; 66 20 ; Rotate right $20.b [Reads: Direct Page] [Flags: ZNC]
	adc [$31.b],Y		; 77 31 ; Add with carry (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $304F08.l,X		; 3F 08 4F 30 ; AND accumulator with memory (long,X) $304F08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor ($2C.b,S),Y		; 53 2C ; XOR accumulator (stack relative indirect indexed) ($2C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	.db $10, $B7		; 10 B7 ; Branch if plus to $10, $B7 [Flow: branch]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($7F.b,S),Y		; 33 7F ; AND accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $20F5.w		; 2C F5 20 ; Test bits $20F5.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	ora ($66.b)		; 12 66 ; OR accumulator with memory (indirect) ($66.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $E6.b		; 04 E6 ; Test and set bits $E6.b [Reads: Accumulator] [Flags: Z]
	sty $CC.b		; 84 CC ; Store Y register to $CC.b [Reads: Y Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($F210.w,X)		; FC 10 F2 ; Jump to subroutine indirect indexed ($F210.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $34CA.w		; 0C CA 34 ; Test and set bits $34CA.w [Reads: Accumulator] [Flags: Z]
	cmp [$08.b],Y		; D7 08 ; Compare accumulator (long indexed) [$08.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sbc $DA00.w		; ED 00 DA ; Subtract $DA00.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inc $FE4C.w,X		; FE 4C FE ; Increment memory $FE4C.w,X [Reads: X Index] [Flags: ZN]
	bit $79.b,X		; 34 79 ; Test bits $79.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $5F40.w,X		; FD 40 5F ; Subtract with carry $5F40.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$BF.b		; E0 BF ; Compare #$BF.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor $0C1E0C.l,X		; 5F 0C 1E 0C ; Exclusive OR accumulator with memory (long,X) $0C1E0C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $070F02.l,X		; 1F 02 0F 07 ; Logical OR long $070F02.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $040B03.l		; 0F 03 0B 04 ; OR accumulator with memory (long) $040B03.l [Writes: Accumulator] [Flags: ZN]
	jmp ($7408.w,X)		; 7C 08 74 ; Jump indirect indexed to ($7408.w,X) [Reads: X Index] [Flow: jump]
	brk $72.b		; 00 72 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	inc $FCE4.w,X		; FE E4 FC ; Increment memory $FCE4.w,X [Reads: X Index] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $80.b,X		; 74 80 ; Store zero to $80.b,X [Reads: X Index]
	jmp $805E80.l		; 5C 80 5E 80 ; Jump long to $805E80.l [Flow: jump]
	dec $00.b,X		; D6 00 ; Decrement memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $88		; 10 88 ; Branch if plus to $10, $88 [Flow: branch]
	.db $70, $9E		; 70 9E ; Branch if overflow set to $70, $9E [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $9B		; 30 9B ; Branch if minus to $30, $9B [Flow: branch]
	stz $DC.b		; 64 DC ; Store zero to $DC.b
	and $7C.b,S		; 23 7C ; AND accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $F0.b,X		; 34 F0 ; Test bits $F0.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	adc $602FF0.l		; 6F F0 2F 60 ; Add with carry (long) $602FF0.l [Writes: Accumulator] [Flags: ZVNC]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: ZNC]
	asl $3A.b		; 06 3A ; Arithmetic shift left $3A.b [Reads: Direct Page] [Flags: ZNC]
	cpy $3C.b		; C4 3C ; Compare $3C.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $F60F36.l		; 0F 36 0F F6 ; OR accumulator with memory (long) $F60F36.l [Writes: Accumulator] [Flags: ZN]
	asl $04F4.w		; 0E F4 04 ; Arithmetic shift left $04F4.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $9B		; 30 9B ; Branch if minus to $30, $9B [Flow: branch]
	stz $FC.b		; 64 FC ; Store zero to $FC.b
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $F0.b,X		; 34 F0 ; Test bits $F0.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	adc $F00FF0.l		; 6F F0 0F F0 ; Add with carry (long) $F00FF0.l [Writes: Accumulator] [Flags: ZVNC]
	adc $006FF0.l		; 6F F0 6F 00 ; Add with carry (long) $006FF0.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: ZNC]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: ZNC]
	cpx $3E.b		; E4 3E ; Compare $3E.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy #$2C.b		; C0 2C ; Compare #$2C.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $F60F36.l		; 0F 36 0F F6 ; OR accumulator with memory (long) $F60F36.l [Writes: Accumulator] [Flags: ZN]
	ora $F00EF4.l		; 0F F4 0E F0 ; OR accumulator with memory (long) $F00EF4.l [Writes: Accumulator] [Flags: ZN]
	tsb $20E0.w		; 0C E0 20 ; Test and set bits $20E0.w [Reads: Accumulator] [Flags: Z]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $708C.w		; 20 8C 70 ; Jump to subroutine at $708C.w [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $6F.b,S		; 03 6F ; OR accumulator with stack relative $6F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $33		; 10 33 ; Branch if plus to $10, $33 [Flow: branch]
	tsb $0020.w		; 0C 20 00 ; Test and set bits $0020.w [Reads: Accumulator] [Flags: Z]
	.db $70, $28		; 70 28 ; Branch if overflow set to $70, $28 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $F0.b,X		; 74 F0 ; Store zero to $F0.b,X [Reads: X Index]
	ora $F06FF0.l		; 0F F0 6F F0 ; OR accumulator with memory (long) $F06FF0.l [Writes: Accumulator] [Flags: ZN]
	adc $200F60.l		; 6F 60 0F 20 ; Add with carry (long) $200F60.l [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: ZNC]
	asl $1A.b		; 06 1A ; Arithmetic shift left $1A.b [Reads: Direct Page] [Flags: ZNC]
	cpx $3C.b		; E4 3C ; Compare $3C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy #$3C.b		; C0 3C ; Compare #$3C.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$BC.b		; C0 BC ; Compare #$BC.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: ZNC]
	ora $F60F36.l		; 0F 36 0F F6 ; OR accumulator with memory (long) $F60F36.l [Writes: Accumulator] [Flags: ZN]
	asl $04F4.w		; 0E F4 04 ; Arithmetic shift left $04F4.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	trb $00A0.w		; 1C A0 00 ; Test and reset bits $00A0.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $9B		; 30 9B ; Branch if minus to $30, $9B [Flow: branch]
	stz $FC.b		; 64 FC ; Store zero to $FC.b
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $F0.b,X		; 34 F0 ; Test bits $F0.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	adc $F00FF0.l		; 6F F0 0F F0 ; Add with carry (long) $F00FF0.l [Writes: Accumulator] [Flags: ZVNC]
	adc $000000.l		; 6F 00 00 00 ; Add with carry (long) $000000.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: ZNC]
	asl $3A.b		; 06 3A ; Arithmetic shift left $3A.b [Reads: Direct Page] [Flags: ZNC]
	cpy $3C.b		; C4 3C ; Compare $3C.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $F60F36.l		; 0F 36 0F F6 ; OR accumulator with memory (long) $F60F36.l [Writes: Accumulator] [Flags: ZN]
	asl $04F4.w		; 0E F4 04 ; Arithmetic shift left $04F4.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $649B.w		; 20 9B 64 ; Jump to subroutine at $649B.w [Writes: Stack Pointer] [Flow: call]
	stz $FC63.w		; 9C 63 FC ; Store zero to $FC63.w
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $70, $2C		; 70 2C ; Branch if overflow set to $70, $2C [Flow: branch]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3900.w,X		; 1E 00 39 ; Arithmetic shift left $3900.w,X [Reads: X Index] [Flags: ZNC]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: ZNC]
	asl $1A.b		; 06 1A ; Arithmetic shift left $1A.b [Reads: Direct Page] [Flags: ZNC]
	cpx $1C.b		; E4 1C ; Compare $1C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $F60F36.l		; 0F 36 0F F6 ; OR accumulator with memory (long) $F60F36.l [Writes: Accumulator] [Flags: ZN]
	asl $04F4.w		; 0E F4 04 ; Arithmetic shift left $04F4.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	ror BG3HOFS.w		; 6E 11 21 ; Rotate right BG3HOFS.w [Flags: ZNC]
	asl $0738.w,X		; 1E 38 07 ; Arithmetic shift left $0738.w,X [Reads: X Index] [Flags: ZNC]
	adc $187F20.l,X		; 7F 20 7F 18 ; Add long $187F20.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $200021.l		; 0F 21 00 20 ; OR accumulator with memory (long) $200021.l [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$5F.b]		; 07 5F ; OR accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $BE		; 80 BE ; Branch always to $80, $BE [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc ($8E.b,S),Y		; 73 8E ; Add with carry (stack relative indirect indexed) ($8E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $10FE18.l,X		; FF 18 FE 10 ; Subtract with carry (long,X) $10FE18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	ldy #$3F.b		; A0 3F ; Load #$3F.b into Y register [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $00FE80.l,X		; 7F 80 FE 00 ; Add long $00FE80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $013E.w		; 1C 3E 01 ; Test and reset bits $013E.w [Reads: Accumulator] [Flags: Z]
	asl $05.b,X		; 16 05 ; Arithmetic shift left $05.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $103F0C.l,X		; 1F 0C 3F 10 ; Logical OR long $103F0C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $1C1C.w,X		; 3E 1C 1C ; Rotate left $1C1C.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $033C.w,X		; 1D 3C 03 ; OR accumulator with memory $033C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	ror $6E80.w,X		; 7E 80 6E ; Rotate right $6E80.w,X [Reads: X Index] [Flags: ZNC]
	.db $90, $9C		; 90 9C ; Branch if carry clear to $90, $9C [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($1818.w,X)		; FC 18 18 ; Jump to subroutine indirect indexed ($1818.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpy $06.b		; C4 06 ; Compare $06.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	stz $E400.w		; 9C 00 E4 ; Store zero to $E400.w
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0E06.w,Y		; 19 06 0E ; OR accumulator with memory $0E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$0608.w		; 09 08 06 ; Logical OR #$0608.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $26DFD2.l		; 2F D2 DF 26 ; AND accumulator with memory (long) $26DFD2.l [Writes: Accumulator] [Flags: ZN]
	rol $F0C0.w,X		; 3E C0 F0 ; Rotate left $F0C0.w,X [Reads: X Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	ora $201ED0.l		; 0F D0 1E 20 ; OR accumulator with memory (long) $201ED0.l [Writes: Accumulator] [Flags: ZN]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($0D.b)		; 32 0D ; AND accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $3C06.w,Y		; 39 06 3C ; AND accumulator with memory $3C06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $001E04.l,X		; 3F 04 1E 00 ; AND accumulator with memory (long,X) $001E04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $301F.w		; 20 1F 30 ; Jump to subroutine at $301F.w [Writes: Stack Pointer] [Flow: call]
	ora $3C0438.l		; 0F 38 04 3C ; OR accumulator with memory (long) $3C0438.l [Writes: Accumulator] [Flags: ZN]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $7870.w		; 8C 70 78 ; Store Y register to $7870.w [Reads: Y Index]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$3C20]		; DC 20 3C ; Jump long indirect [$3C20] [Flow: jump]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($3800.w,X)		; FC 00 38 ; Jump to subroutine indirect indexed ($3800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	trb $3C20.w		; 1C 20 3C ; Test and reset bits $3C20.w [Reads: Accumulator] [Flags: Z]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($FC98.w,X)		; 7C 98 FC ; Jump indirect indexed to ($FC98.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($7820.w,X)		; FC 20 78 ; Jump to subroutine indirect indexed ($7820.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp ($FC80.w,X)		; 7C 80 FC ; Jump indirect indexed to ($FC80.w,X) [Reads: X Index] [Flow: jump]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000300.l		; 0F 00 03 00 ; OR accumulator with memory (long) $000300.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $BCB0.w		; 4C B0 BC ; Jump to $BCB0.w [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp ($FC80.w,X)		; 7C 80 FC ; Jump indirect indexed to ($FC80.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($7820.w,X)		; FC 20 78 ; Jump to subroutine indirect indexed ($7820.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $3CF0.w		; 0C F0 3C ; Test and set bits $3CF0.w [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp ($FC80.w,X)		; 7C 80 FC ; Jump indirect indexed to ($FC80.w,X) [Reads: X Index] [Flow: jump]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $77		; 10 77 ; Branch if plus to $10, $77 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $3F01.w,X		; 3E 01 3F ; Rotate left $3F01.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $321364.l		; 4F 64 13 32 ; Exclusive OR accumulator with memory (long) $321364.l [Writes: Accumulator] [Flags: ZN]
	tsb $013E.w		; 0C 3E 01 ; Test and set bits $013E.w [Reads: Accumulator] [Flags: Z]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C8.b,X		; 34 C8 ; Test bits $C8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cpy $3830.w		; CC 30 38 ; Compare $3830.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $5C.b		; 06 5C ; Arithmetic shift left $5C.b [Reads: Direct Page] [Flags: ZNC]
	ora $B3.b,S		; 03 B3 ; OR accumulator with stack relative $B3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $5F.b,S		; 03 5F ; OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1FE0.w		; 0C E0 1F ; Test and set bits $1FE0.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $3E		; 30 3E ; Branch if minus to $30, $3E [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cmp $0500.w		; CD 00 05 ; Compare $0500.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E8.b		; C0 E8 ; Compare #$E8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $D0, $F6		; D0 F6 ; Branch if not equal to $D0, $F6 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $F80730.l		; CF 30 07 F8 ; Compare accumulator (long) $F80730.l [Reads: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $3804.w		; 0C 04 38 ; Test and set bits $3804.w [Reads: Accumulator] [Flags: Z]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$9E.b],Y		; 17 9E ; OR accumulator with memory (long indexed) [$9E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $38BD.w,X		; 1D BD 38 ; OR accumulator with memory $38BD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$68.b]		; 07 68 ; OR accumulator with memory (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$E3.b],Y		; 37 E3 ; AND accumulator with memory (long indexed) [$E3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($78C7.w,X)		; 7C C7 78 ; Jump indirect indexed to ($78C7.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	jmp $CA70.w		; 4C 70 CA ; Jump to $CA70.w [Flow: jump]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	cpx #$61.b		; E0 61 ; Compare #$61.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $87		; 80 87 ; Branch always to $80, $87 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$BC.b		; E0 BC ; Compare #$BC.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$3A.b		; C0 3A ; Compare #$3A.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy $F1.b		; C4 F1 ; Compare $F1.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	asl $1EE1.w		; 0E E1 1E ; Arithmetic shift left $1EE1.w [Flags: ZNC]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Accumulator, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0C1C03.l		; 0F 03 1C 0C ; OR accumulator with memory (long) $0C1C03.l [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $06BE1D.l,X		; BF 1D BE 06 ; Load long $06BE1D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$69.b],Y		; F7 69 ; Subtract with carry (long indexed) [$69.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1303.w		; 0C 03 13 ; Test and set bits $1303.w [Reads: Accumulator] [Flags: Z]
	ora $E20F74.l		; 0F 74 0F E2 ; OR accumulator with memory (long) $E20F74.l [Writes: Accumulator] [Flags: ZN]
	ora $07F9.w,X		; 1D F9 07 ; OR accumulator with memory $07F9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stz $0001.w,X		; 9E 01 00 ; Store zero to $0001.w,X [Reads: X Index]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$38.b		; C0 38 ; Compare #$38.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	.db $30, $1D		; 30 1D ; Branch if minus to $30, $1D [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $1F08.w		; 2D 08 1F ; Logical AND $1F08.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C8.b		; C0 C8 ; Compare #$C8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $CE		; F0 CE ; Branch if equal to $F0, $CE [Flow: branch]
	.db $30, $E7		; 30 E7 ; Branch if minus to $30, $E7 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp [$D8.b],Y		; D7 D8 ; Compare accumulator (long indexed) [$D8.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sbc #$00F0.w		; E9 F0 00 ; Subtract #$00F0.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $304C.w		; 20 4C 30 ; Jump to subroutine at $304C.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	jsr $3478.w		; 20 78 34 ; Jump to subroutine at $3478.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $1E04.w		; 0E 04 1E ; Arithmetic shift left $1E04.w [Flags: ZNC]
	bit $0000.w		; 2C 00 00 ; Test bits $0000.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C00.w		; 0C 00 1C ; Test and set bits $1C00.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0002.w		; 0D 02 00 ; Logical OR $0002.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $11.b		; 04 11 ; Test and set bits $11.b [Reads: Accumulator] [Flags: Z]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5700.w		; 20 00 57 ; Jump to subroutine at $5700.w [Writes: Stack Pointer] [Flow: call]
	jsr $609F.w		; 20 9F 60 ; Jump to subroutine at $609F.w [Writes: Stack Pointer] [Flow: call]
	stz $0063.w		; 9C 63 00 ; Store zero to $0063.w
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $67F8.w		; 20 F8 67 ; Jump to subroutine at $67F8.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $6F		; F0 6F ; Branch if equal to $F0, $6F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	nop		; EA ; No operation
	tsb $39.b		; 04 39 ; Test and set bits $39.b [Reads: Accumulator] [Flags: Z]
	dec $09.b		; C6 09 ; Decrement $09.b [Reads: Direct Page] [Flags: ZN]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	inc $0F.b		; E6 0F ; Increment $0F.b [Reads: Direct Page] [Flags: ZN]
	inc $EF.b,X		; F6 EF ; Increment memory $EF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	.db $42, $FF		; 42 FF ; Reserved instruction
	adc #$197E.w		; 69 7E 19 ; Add #$197E.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AD.b		; 00 AD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($92.b)		; 12 92 ; OR accumulator with memory (indirect) ($92.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $FF		; 42 FF ; Reserved instruction
	stx $7E.b,Y		; 96 7E ; Store X register $7E.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $D0		; F0 D0 ; Branch if equal to $F0, $D0 [Flow: branch]
	jsr $C0E0.w		; 20 E0 C0 ; Jump to subroutine at $C0E0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $48.b,X		; B5 48 ; Load $48.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor #$8600.w		; 49 00 86 ; Exclusive OR #$8600.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $7E		; 30 7E ; Branch if minus to $30, $7E [Flow: branch]
	jsl $0B032F.l		; 22 2F 03 0B ; Jump to subroutine long $0B032F.l [Writes: Stack Pointer] [Flow: call]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $5D		; 70 5D ; Branch if overflow set to $70, $5D [Flow: branch]
	jsr $002C.w		; 20 2C 00 ; Jump to subroutine at $002C.w [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $BA.b		; 04 BA ; Test and set bits $BA.b [Reads: Accumulator] [Flags: Z]
	brk $A9.b		; 00 A9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $C2.b		; 14 C2 ; Test and reset bits $C2.b [Reads: Accumulator] [Flags: Z]
	ldy $F0CC.w		; AC CC F0 ; Load $F0CC.w into Y register [Writes: Y Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9A.b		; 00 9A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx $BF40.w,Y		; BE 40 BF ; Load X register $BF40.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ror $3C00.w,X		; 7E 00 3C ; Rotate right $3C00.w,X [Reads: X Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $77.b		; 64 77 ; Store zero to $77.b
	jsr $0021.w		; 20 21 00 ; Jump to subroutine at $0021.w [Writes: Stack Pointer] [Flow: call]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $57.b		; 00 57 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $DE.b,X		; D6 DE ; Decrement memory $DE.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cpy $D4.b		; C4 D4 ; Compare $D4.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $3A		; F0 3A ; Branch if equal to $F0, $3A [Flow: branch]
	cpx #$B4.b		; E0 B4 ; Compare #$B4.b with X register [Reads: X Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $7F017E.l		; 22 7E 01 7F ; Jump to subroutine long $7F017E.l [Writes: Stack Pointer] [Flow: call]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and [$7C.b]		; 27 7C ; AND accumulator with memory (long) [$7C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jmp ($381B.w,X)		; 7C 1B 38 ; Jump indirect indexed to ($381B.w,X) [Reads: X Index] [Flow: jump]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	cpy #$7E.b		; C0 7E ; Compare #$7E.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $3E		; 80 3E ; Branch always to $80, $3E [Flow: branch]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $3E.b		; E4 3E ; Compare $3E.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	rol $1AD8.w,X		; 3E D8 1A ; Rotate left $1AD8.w,X [Reads: X Index] [Flags: ZNC]
	bit $C4.b		; 24 C4 ; Test bits $C4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $47		; 30 47 ; Branch if minus to $30, $47 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	ror $7F11.w		; 6E 11 7F ; Rotate right $7F11.w [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7C.b,X		; 34 7C ; Test bits $7C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp ($5E13.w,X)		; 7C 13 5E ; Jump indirect indexed to ($5E13.w,X) [Reads: X Index] [Flow: jump]
	and $0C3E.w		; 2D 3E 0C ; Logical AND $0C3E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $001C00.l,X		; 3F 00 1C 00 ; AND accumulator with memory (long,X) $001C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($0C.b)		; 32 0C ; AND accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
.INDEX 8
	sep #$1C		; E2 1C
	ror $88.b,X		; 76 88 ; Rotate right $88.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inc $7C00.w,X		; FE 00 7C ; Increment memory $7C00.w,X [Reads: X Index] [Flags: ZN]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $DC3E.w		; 2C 3E DC ; Test bits $DC3E.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	rol $7AC8.w,X		; 3E C8 7A ; Rotate left $7AC8.w,X [Reads: X Index] [Flags: ZNC]
	ldy $7C.b,X		; B4 7C ; Load Y register $7C.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: ZNC]
	asl $37.b		; 06 37 ; Arithmetic shift left $37.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $3E06.w,Y		; 39 06 3E ; AND accumulator with memory $3E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $200718.l		; 0F 18 07 20 ; OR accumulator with memory (long) $200718.l [Writes: Accumulator] [Flags: ZN]
	ora [$30.b],Y		; 17 30 ; OR accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$0638.w		; 09 38 06 ; Logical OR #$0638.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0701.w,X		; 1E 01 07 ; Arithmetic shift left $0701.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $84		; 70 84 ; Branch if overflow set to $70, $84 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	dec $3F30.w		; CE 30 3F ; Decrement $3F30.w [Flags: ZN]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ror $3FB0.w,X		; 7E B0 3F ; Rotate right $3FB0.w,X [Reads: X Index] [Flags: ZNC]
	asl $E61F.w		; 0E 1F E6 ; Arithmetic shift left $E61F.w [Flags: ZNC]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3906.w,Y		; 19 06 39 ; OR accumulator with memory $3906.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $37.b		; 06 37 ; Arithmetic shift left $37.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $3E06.w,Y		; 39 06 3E ; AND accumulator with memory $3E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $200F30.l		; 0F 30 0F 20 ; OR accumulator with memory (long) $200F30.l [Writes: Accumulator] [Flags: ZN]
	ora [$30.b],Y		; 17 30 ; OR accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$0638.w		; 09 38 06 ; Logical OR #$0638.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0701.w,X		; 1E 01 07 ; Arithmetic shift left $0701.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $86		; 70 86 ; Branch if overflow set to $70, $86 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp $00FF30.l		; CF 30 FF 00 ; Compare accumulator (long) $00FF30.l [Reads: Accumulator] [Flags: ZNC]
	rol $F8C8.w,X		; 3E C8 F8 ; Rotate left $F8C8.w,X [Reads: X Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $FE		; 70 FE ; Branch if overflow set to $70, $FE [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $C63FB6.l,X		; 7F B6 3F C6 ; Add long $C63FB6.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $3820.w,X		; 1E 20 38 ; Arithmetic shift left $3820.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($2F.b,X)		; 01 2F ; Logical OR ($2F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $33		; 10 33 ; Branch if plus to $10, $33 [Flow: branch]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000300.l		; 0F 00 03 00 ; OR accumulator with memory (long) $000300.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $200F30.l,X		; 1F 30 0F 20 ; Logical OR long $200F30.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $101320.l		; 0F 20 13 10 ; OR accumulator with memory (long) $101320.l [Writes: Accumulator] [Flags: ZN]
	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1CE0.w,X		; 1E E0 1C ; Arithmetic shift left $1CE0.w,X [Reads: X Index] [Flags: ZNC]
	cpx #$B4.b		; E0 B4 ; Compare #$B4.b with X register [Reads: X Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cpy $3830.w		; CC 30 38 ; Compare $3830.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $04F0.w		; 0C F0 04 ; Test and set bits $04F0.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $68		; F0 68 ; Branch if equal to $F0, $68 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora #$0906.w		; 09 06 09 ; Logical OR #$0906.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	trb $CC.b		; 14 CC ; Test and reset bits $CC.b [Reads: Accumulator] [Flags: Z]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $4E.b		; 04 4E ; Test and set bits $4E.b [Reads: Accumulator] [Flags: Z]
	sty $00.b,X		; 94 00 ; Store Y register $00.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp.w [$FB20]		; DC 20 FB ; Jump long indirect [$FB20] [Flow: jump]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $2C		; F0 2C ; Branch if equal to $F0, $2C [Flow: branch]
	.db $F0, $4F		; F0 4F ; Branch if equal to $F0, $4F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $3900.w		; 0E 00 39 ; Arithmetic shift left $3900.w [Flags: ZNC]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $E61F36.l		; 0F 36 1F E6 ; OR accumulator with memory (long) $E61F36.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	jmp $000020.l		; 5C 20 00 00 ; Jump long to $000020.l [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	jsr $2C70.w		; 20 70 2C ; Jump to subroutine at $2C70.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	asl $3200.w		; 0E 00 32 ; Arithmetic shift left $3200.w [Flags: ZNC]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3E00.w		; 0E 00 3E ; Arithmetic shift left $3E00.w [Flags: ZNC]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5800.w		; 20 00 58 ; Jump to subroutine at $5800.w [Writes: Stack Pointer] [Flow: call]
	jsr $205C.w		; 20 5C 20 ; Jump to subroutine at $205C.w [Writes: Stack Pointer] [Flow: call]
	ldy $0043.w,X		; BC 43 00 ; Load Y register $0043.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $70, $2C		; 70 2C ; Branch if overflow set to $70, $2C [Flow: branch]
	.db $F0, $4F		; F0 4F ; Branch if equal to $F0, $4F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $3906.w,Y		; 19 06 39 ; OR accumulator with memory $3906.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $1A.b		; 06 1A ; Arithmetic shift left $1A.b [Reads: Direct Page] [Flags: ZNC]
	cpx $00.b		; E4 00 ; Compare $00.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b,X		; 16 0F ; Arithmetic shift left $0F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $0E.b,X		; 36 0E ; Rotate left $0E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	pea $0000.w		; F4 00 00 ; Push absolute address $0000.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5800.w		; 20 00 58 ; Jump to subroutine at $5800.w [Writes: Stack Pointer] [Flow: call]
	jsr $44B8.w		; 20 B8 44 ; Jump to subroutine at $44B8.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $F0, $4C		; F0 4C ; Branch if equal to $F0, $4C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $3906.w,Y		; 19 06 39 ; OR accumulator with memory $3906.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b,X		; 16 0F ; Arithmetic shift left $0F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($1E.b,X)		; 61 1E ; Add with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($0E.b),Y		; 71 0E ; Add with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $2E5F1E.l,X		; 7F 1E 5F 2E ; Add long $2E5F1E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $46		; 10 46 ; Branch if plus to $10, $46 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $00FF10.l		; EF 10 FF 00 ; Subtract with carry (long) $00FF10.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $C6FF16.l,X		; FF 16 FF C6 ; Subtract with carry (long,X) $C6FF16.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $3C02.w,X		; 3D 02 3C ; AND accumulator with memory $3C02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($17.b),Y		; 11 17 ; OR accumulator with memory ($17.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000300.l		; 0F 00 03 00 ; OR accumulator with memory (long) $000300.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	jsr $201F.w		; 20 1F 20 ; Jump to subroutine at $201F.w [Writes: Stack Pointer] [Flow: call]
	ora $100F20.l,X		; 1F 20 0F 10 ; Logical OR long $100F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$1C.b		; E0 1C ; Compare #$1C.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$34.b		; E0 34 ; Compare #$34.b with X register [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx #$30.b		; E0 30 ; Compare #$30.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $17.b		; 05 17 ; Logical OR $17.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0E06.w,Y		; 19 06 0E ; OR accumulator with memory $0E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $15.b		; 05 15 ; Logical OR $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0608.w		; 09 08 06 ; Logical OR #$0608.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0F01.w		; 0E 01 0F ; Arithmetic shift left $0F01.w [Flags: ZNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $3C		; D0 3C ; Branch if not equal to $D0, $3C [Flow: branch]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	pea $FCC8.w		; F4 C8 FC ; Push absolute address $FCC8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $30, $7C		; 30 7C ; Branch if minus to $30, $7C [Flow: branch]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: ZNC]
	tsb $17.b		; 04 17 ; Test and set bits $17.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $3E06.w,Y		; 19 06 3E ; OR accumulator with memory $3E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $0E0E.w,Y		; 39 0E 0E ; AND accumulator with memory $0E0E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($38.b,X)		; 01 38 ; Logical OR ($38.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	stz $DE60.w,X		; 9E 60 DE ; Store zero to $DE60.w,X [Reads: X Index]
	jsr $02FF.w		; 20 FF 02 ; Jump to subroutine at $02FF.w [Writes: Stack Pointer] [Flow: call]
	and $00FEC6.l,X		; 3F C6 FE 00 ; AND accumulator with memory (long,X) $00FEC6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FE40.w,X)		; FC 40 FE ; Jump to subroutine indirect indexed ($FE40.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp ($AC7E.w)		; 6C 7E AC ; Jump indirect to ($AC7E.w) [Flow: jump]
	and $300FC0.l,X		; 3F C0 0F 30 ; AND accumulator with memory (long,X) $300FC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $C0C0.w,X		; 3E C0 C0 ; Rotate left $C0C0.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($34.b),Y		; 11 34 ; OR accumulator with memory ($34.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $2F01.w,X		; 3E 01 2F ; Rotate left $2F01.w,X [Reads: X Index] [Flags: ZNC]
	trb $003F.w		; 1C 3F 00 ; Test and reset bits $003F.w [Reads: Accumulator] [Flags: Z]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $200F20.l,X		; 1F 20 0F 20 ; Logical OR long $200F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $3C.b		; 14 3C ; Test and reset bits $3C.b [Reads: Accumulator] [Flags: Z]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 16
.INDEX 16
	rep #$7E		; C2 7E
	.db $80, $5C		; 80 5C ; Branch always to $80, $5C [Flow: branch]
	ldy #$C03C.w		; A0 3C C0 ; Load #$C03C.w into Y register [Writes: Y Index] [Flags: ZN]
	jsr ($F808.w,X)		; FC 08 F8 ; Jump to subroutine indirect indexed ($F808.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	rol $5CD8.w,X		; 3E D8 5C ; Rotate left $5CD8.w,X [Reads: X Index] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	cpy #$00F8.w		; C0 F8 00 ; Compare #$00F8.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3C.b),Y		; 11 3C ; OR accumulator with memory ($3C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$1C3F.w		; 09 3F 1C ; Logical OR #$1C3F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $001E06.l,X		; 3F 06 1E 00 ; AND accumulator with memory (long,X) $001E06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	jsr $280F.w		; 20 0F 28 ; Jump to subroutine at $280F.w [Writes: Stack Pointer] [Flow: call]
	trb $3C.b		; 14 3C ; Test and reset bits $3C.b [Reads: Accumulator] [Flags: Z]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $7A.b		; 04 7A ; Test and set bits $7A.b [Reads: Accumulator] [Flags: Z]
	sty $7C.b		; 84 7C ; Store Y register to $7C.b [Reads: Y Index]
	.db $80, $4C		; 80 4C ; Branch always to $80, $4C [Flow: branch]
	.db $B0, $3C		; B0 3C ; Branch if carry set to $B0, $3C [Flow: branch]
	cpy #$00F8.w		; C0 F8 00 ; Compare #$00F8.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $7E.b,X		; B4 7E ; Load Y register $7E.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	ldy $34.b,X		; B4 34 ; Load Y register $34.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	mvp $0C,$08		; 44 08 0C ; Move block positive $0C,$08 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($7F03.w,X)		; FC 03 7F ; Jump to subroutine indirect indexed ($7F03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000300.l,X		; 1F 00 03 00 ; Logical OR long $000300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $2F		; F0 2F ; Branch if equal to $F0, $2F [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and [$30.b],Y		; 37 30 ; AND accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $30.b,S		; 03 30 ; OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; [PATTERN: Memory clearing operation] 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E8.b		; 14 E8 ; Test and reset bits $E8.b [Reads: Accumulator] [Flags: Z]
	stz $98.b		; 64 98 ; Store zero to $98.b
	stz $7860.w		; 9C 60 78 ; Store zero to $7860.w
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($7838.w,X)		; FC 38 78 ; Jump to subroutine indirect indexed ($7838.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cpx #$9804.w		; E0 04 98 ; Compare #$9804.w with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($FC80.w,X)		; 7C 80 FC ; Jump indirect indexed to ($FC80.w,X) [Reads: X Index] [Flow: jump]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7C.b,S		; 03 7C ; OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000300.l		; 0F 00 03 00 ; OR accumulator with memory (long) $000300.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	and [$78.b],Y		; 37 78 ; AND accumulator with memory (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$30.b],Y		; 37 30 ; AND accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $101320.l		; 0F 20 13 10 ; OR accumulator with memory (long) $101320.l [Writes: Accumulator] [Flags: ZN]
	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; [PATTERN: Memory clearing operation] 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpx $14.b		; E4 14 ; Compare $14.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	stz $98.b		; 64 98 ; Store zero to $98.b
	stz $7C60.w		; 9C 60 7C ; Store zero to $7C60.w
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($FC38.w,X)		; FC 38 FC ; Jump to subroutine indirect indexed ($FC38.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $0038.w		; 20 38 00 ; Jump to subroutine at $0038.w [Writes: Stack Pointer] [Flow: call]
	asl $04F4.w		; 0E F4 04 ; Arithmetic shift left $04F4.w [Flags: ZNC]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cpx #$900C.w		; E0 0C 90 ; Compare #$900C.w with X register [Reads: X Index] [Flags: ZNC]
	bit $7C40.w,X		; 3C 40 7C ; Test bits $7C40.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $E7.b		; 26 E7 ; Rotate left $E7.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $2E		; 30 2E ; Branch if minus to $30, $2E [Flow: branch]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $608756.l		; 8F 56 87 60 ; Store accumulator (long) $608756.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C030.w		; 20 30 C0 ; Jump to subroutine at $C030.w [Writes: Stack Pointer] [Flow: call]
	cpx #$8000.w		; E0 00 80 ; Compare #$8000.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8060.w		; 20 60 80 ; Jump to subroutine at $8060.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($1E.b,X)		; 61 1E ; Add with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00001E.l,X		; 7F 1E 00 00 ; Add long $00001E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $46		; 10 46 ; Branch if plus to $10, $46 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $000010.l		; EF 10 00 00 ; Subtract with carry (long) $000010.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $000016.l,X		; FF 16 00 00 ; Subtract with carry (long,X) $000016.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $46		; 10 46 ; Branch if plus to $10, $46 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($1E.b,X)		; 61 1E ; Add with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00001E.l,X		; 7F 1E 00 00 ; Add long $00001E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $46		; 10 46 ; Branch if plus to $10, $46 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $000010.l		; EF 10 00 00 ; Subtract with carry (long) $000010.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $000016.l,X		; FF 16 00 00 ; Subtract with carry (long,X) $000016.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $46		; 10 46 ; Branch if plus to $10, $46 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $071800.l		; 0F 00 18 07 ; OR accumulator with memory (long) $071800.l [Writes: Accumulator] [Flags: ZN]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1003.w		; 0C 03 10 ; Test and set bits $1003.w [Reads: Accumulator] [Flags: Z]
	ora $001F20.l		; 0F 20 1F 00 ; OR accumulator with memory (long) $001F20.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $9C.b,S		; 63 9C ; Add with carry (stack relative) $9C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	.db $62, $9C, $74		; 62 9C 74 ; Push effective relative address $62, $9C, $74 [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	cmp $CA3F06.l		; CF 06 3F CA ; Compare accumulator (long) $CA3F06.l [Reads: Accumulator] [Flags: ZNC]
	and $DC3EDC.l,X		; 3F DC 3E DC ; AND accumulator with memory (long,X) $DC3EDC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $00E8.w		; 1C E8 00 ; Test and reset bits $00E8.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $9C, $62		; 62 9C 62 ; Push effective relative address $62, $9C, $62 [Writes: Stack Pointer]
	stz $0000.w		; 9C 00 00 ; Store zero to $0000.w
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	cmp $CA3F06.l		; CF 06 3F CA ; Compare accumulator (long) $CA3F06.l [Reads: Accumulator] [Flags: ZNC]
	rol $3EDC.w,X		; 3E DC 3E ; Rotate left $3EDC.w,X [Reads: X Index] [Flags: ZNC]
	jmp.w [$0000]		; DC 00 00 ; Jump long indirect [$0000] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $9C, $00		; 62 9C 00 ; Push effective relative address $62, $9C, $00 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: ZNC]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	rol $00DC.w,X		; 3E DC 00 ; Rotate left $00DC.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
.INDEX 8
	sep #$1C		; E2 1C
	.db $62, $9C, $00		; 62 9C 00 ; Push effective relative address $62, $9C, $00 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: ZNC]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	rol $3EDC.w,X		; 3E DC 3E ; Rotate left $3EDC.w,X [Reads: X Index] [Flags: ZNC]
	jmp.w [$0E71]		; DC 71 0E ; Jump long indirect [$0E71] [Flow: jump]
	cmp $EF26.w,Y		; D9 26 EF ; Compare accumulator $EF26.w,Y [Reads: Y Index] [Flags: ZNC]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	ora $1F003F.l		; 0F 3F 00 1F ; OR accumulator with memory (long) $1F003F.l [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $5F000F.l		; 0F 0F 00 5F ; OR accumulator with memory (long) $5F000F.l [Writes: Accumulator] [Flags: ZN]
	rol $568F.w		; 2E 8F 56 ; Rotate left $568F.w [Flags: ZNC]
	sta [$68.b]		; 87 68 ; Store accumulator (long) [$68.b] [Reads: Accumulator, Direct Page]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	ora $1F001F.l		; 0F 1F 00 1F ; OR accumulator with memory (long) $1F001F.l [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C030.w		; 20 30 C0 ; Jump to subroutine at $C030.w [Writes: Stack Pointer] [Flow: call]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $D0EEC6.l,X		; FF C6 EE D0 ; Subtract with carry (long,X) $D0EEC6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0E71.w,X		; 1E 71 0E ; Arithmetic shift left $0E71.w,X [Reads: X Index] [Flags: ZNC]
	lda $CF46.w,Y		; B9 46 CF ; Load $CF46.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $7E		; 30 7E ; Branch if minus to $30, $7E [Flow: branch]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2E5F.w,X		; 1E 5F 2E ; Arithmetic shift left $2E5F.w,X [Reads: X Index] [Flags: ZNC]
	sta $488736.l		; 8F 36 87 48 ; Store accumulator (long) $488736.l [Reads: Accumulator]
	eor $102F30.l		; 4F 30 2F 10 ; Exclusive OR accumulator with memory (long) $102F30.l [Writes: Accumulator] [Flags: ZN]
	ora $000700.l,X		; 1F 00 07 00 ; Logical OR long $000700.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00FF10.l		; EF 10 FF 00 ; Subtract with carry (long) $00FF10.l [Writes: Accumulator] [Flags: ZVNC]
	inc $D000.w,X		; FE 00 D0 ; Increment memory $D000.w,X [Reads: X Index] [Flags: ZN]
	jsr $8070.w		; 20 70 80 ; Jump to subroutine at $8070.w [Writes: Stack Pointer] [Flow: call]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $C6FF16.l,X		; FF 16 FF C6 ; Subtract with carry (long,X) $C6FF16.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $D0D0.w		; EE D0 D0 ; Increment $D0D0.w [Flags: ZN]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $00E0.w		; 20 E0 00 ; Jump to subroutine at $00E0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	adc ($0E.b),Y		; 71 0E ; Add with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $E726.w,Y		; D9 26 E7 ; Compare accumulator $E726.w,Y [Reads: Y Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $003F.w		; 20 3F 00 ; Jump to subroutine at $003F.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $568F2E.l,X		; 5F 2E 8F 56 ; Exclusive OR accumulator with memory (long,X) $568F2E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta [$60.b]		; 87 60 ; Store accumulator (long) [$60.b] [Reads: Accumulator, Direct Page]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C038.w		; 20 38 C0 ; Jump to subroutine at $C038.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $D0EEC6.l,X		; FF C6 EE D0 ; Subtract with carry (long,X) $D0EEC6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0E71.w,X		; 1E 71 0E ; Arithmetic shift left $0E71.w,X [Reads: X Index] [Flags: ZNC]
	cmp $E726.w,Y		; D9 26 E7 ; Compare accumulator $E726.w,Y [Reads: Y Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2E5F.w,X		; 1E 5F 2E ; Arithmetic shift left $2E5F.w,X [Reads: X Index] [Flags: ZNC]
	sta $608756.l		; 8F 56 87 60 ; Store accumulator (long) $608756.l [Reads: Accumulator]
	cpx #$18.b		; E0 18 ; Compare #$18.b with X register [Reads: X Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $B8.b,X		; 74 B8 ; Store zero to $B8.b,X [Reads: X Index]
	jsr ($B820.w,X)		; FC 20 B8 ; Jump to subroutine indirect indexed ($B820.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FF.b,X		; 16 FF ; Arithmetic shift left $FF.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	dec $FE.b		; C6 FE ; Decrement $FE.b [Reads: Direct Page] [Flags: ZN]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B8		; 80 B8 ; Branch always to $80, $B8 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$31.b],Y		; 17 31 ; OR accumulator with memory (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $011E.w		; 0E 1E 01 ; Arithmetic shift left $011E.w [Flags: ZNC]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $200F.w		; 20 0F 20 ; Jump to subroutine at $200F.w [Writes: Stack Pointer] [Flow: call]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $031C.w		; 0E 1C 03 ; Arithmetic shift left $031C.w [Flags: ZNC]
	ora $000000.l		; 0F 00 00 00 ; OR accumulator with memory (long) $000000.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($EC00.w,X)		; FC 00 EC ; Jump to subroutine indirect indexed ($EC00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	trb $FCE0.w		; 1C E0 FC ; Test and reset bits $FCE0.w [Reads: Accumulator] [Flags: Z]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $390738.l		; 0F 38 07 39 ; OR accumulator with memory (long) $390738.l [Writes: Accumulator] [Flags: ZN]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	tsb $001C.w		; 0C 1C 00 ; Test and set bits $001C.w [Reads: Accumulator] [Flags: Z]
	jsr $201F.w		; 20 1F 20 ; Jump to subroutine at $201F.w [Writes: Stack Pointer] [Flow: call]
	ora $301920.l,X		; 1F 20 19 30 ; Logical OR long $301920.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $033C.w		; 0E 3C 03 ; Arithmetic shift left $033C.w [Flags: ZNC]
	and $003E00.l,X		; 3F 00 3E 00 ; AND accumulator with memory (long,X) $003E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $7400.w		; 1C 00 74 ; Test and reset bits $7400.w [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($EC00.w,X)		; FC 00 EC ; Jump to subroutine indirect indexed ($EC00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	tsb $04F0.w		; 0C F0 04 ; Test and set bits $04F0.w [Reads: Accumulator] [Flags: Z]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	trb $F8E0.w		; 1C E0 F8 ; Test and reset bits $F8E0.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $390738.l		; 0F 38 07 39 ; OR accumulator with memory (long) $390738.l [Writes: Accumulator] [Flags: ZN]
	asl $7E.b		; 06 7E ; Arithmetic shift left $7E.b [Reads: Direct Page] [Flags: ZNC]
	and ($7F.b,X)		; 21 7F ; Logical AND ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $003C04.l,X		; 7F 04 3C 00 ; Add long $003C04.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	jsr $201F.w		; 20 1F 20 ; Jump to subroutine at $201F.w [Writes: Stack Pointer] [Flow: call]
	ora $0678.w,Y		; 19 78 06 ; OR accumulator with memory $0678.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($7F03.w,X)		; 7C 03 7F ; Jump indirect indexed to ($7F03.w,X) [Reads: X Index] [Flow: jump]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $8874.w		; 9C 74 88 ; Store zero to $8874.w
	jsr ($CC00.w,X)		; FC 00 CC ; Jump to subroutine indirect indexed ($CC00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$E81C]		; DC 1C E8 ; Jump long indirect [$E81C] [Flow: jump]
	tsb $04F0.w		; 0C F0 04 ; Test and set bits $04F0.w [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $311728.l		; 0F 28 17 31 ; OR accumulator with memory (long) $311728.l [Writes: Accumulator] [Flags: ZN]
	asl $011E.w		; 0E 1E 01 ; Arithmetic shift left $011E.w [Flags: ZNC]
	ora $000300.l		; 0F 00 03 00 ; OR accumulator with memory (long) $000300.l [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $201F.w		; 20 1F 20 ; Jump to subroutine at $201F.w [Writes: Stack Pointer] [Flow: call]
	ora $101120.l		; 0F 20 11 10 ; OR accumulator with memory (long) $101120.l [Writes: Accumulator] [Flags: ZN]
	asl $030C.w		; 0E 0C 03 ; Arithmetic shift left $030C.w [Flags: ZNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	jsr ($EC00.w,X)		; FC 00 EC ; Jump to subroutine indirect indexed ($EC00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	tsb $04F0.w		; 0C F0 04 ; Test and set bits $04F0.w [Reads: Accumulator] [Flags: Z]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	tsb $F8F0.w		; 0C F0 F8 ; Test and set bits $F8F0.w [Reads: Accumulator] [Flags: Z]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
.INDEX 8
	sep #$1C		; E2 1C
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	cmp $CA3F06.l		; CF 06 3F CA ; Compare accumulator (long) $CA3F06.l [Reads: Accumulator] [Flags: ZNC]
	rol $00DC.w,X		; 3E DC 00 ; Rotate left $00DC.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	adc $00002F.l,X		; 7F 2F 00 00 ; Add long $00002F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $077F07.l,X		; 7F 07 7F 07 ; Add long $077F07.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor [$0A.b],Y		; 57 0A ; Exclusive OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $50, $0F		; 50 0F ; Branch if overflow clear to $50, $0F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	.db $F0, $EA		; F0 EA ; Branch if equal to $F0, $EA [Flow: branch]
	.db $70, $CA		; 70 CA ; Branch if overflow set to $70, $CA [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$C4.b		; E0 C4 ; Compare #$C4.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl $9EF0.w		; 0E F0 9E ; Arithmetic shift left $9EF0.w [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $19.b		; 04 19 ; Test and set bits $19.b [Reads: Accumulator] [Flags: Z]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$11.b]		; 07 11 ; OR accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0F10.w		; 0E 10 0F ; Arithmetic shift left $0F10.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	inc $0F00.w,X		; FE 00 0F ; Increment memory $0F00.w,X [Reads: X Index] [Flags: ZN]
	.db $F0, $8F		; F0 8F ; Branch if equal to $F0, $8F [Flow: branch]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	ror $00.b,X		; 76 00 ; Rotate right $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$11.b]		; 07 11 ; OR accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	inc $0F00.w,X		; FE 00 0F ; Increment memory $0F00.w,X [Reads: X Index] [Flags: ZN]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $6000.w		; 20 00 60 ; Jump to subroutine at $6000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $390F30.l		; 0F 30 0F 39 ; OR accumulator with memory (long) $390F30.l [Writes: Accumulator] [Flags: ZN]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $200F10.l		; 0F 10 0F 20 ; OR accumulator with memory (long) $200F10.l [Writes: Accumulator] [Flags: ZN]
	ora [$20.b],Y		; 17 20 ; OR accumulator with memory (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $041B.w,Y		; 19 1B 04 ; OR accumulator with memory $041B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $62, $9C, $74		; 62 9C 74 ; Push effective relative address $62, $9C, $74 [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpx $FC10.w		; EC 10 FC ; Compare $FC10.w with X register [Reads: X Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	rol $1CDC.w,X		; 3E DC 1C ; Rotate left $1CDC.w,X [Reads: X Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	tsb $04E0.w		; 0C E0 04 ; Test and set bits $04E0.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $37.b		; 06 37 ; Arithmetic shift left $37.b [Reads: Direct Page] [Flags: ZNC]
	asl $36.b		; 06 36 ; Arithmetic shift left $36.b [Reads: Direct Page] [Flags: ZNC]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3C1F3E.l		; 0F 3E 1F 3C ; OR accumulator with memory (long) $3C1F3E.l [Writes: Accumulator] [Flags: ZN]
	ora $391E39.l,X		; 1F 39 1E 39 ; Logical OR long $391E39.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0C3A.w		; 0E 3A 0C ; Arithmetic shift left $0C3A.w [Flags: ZNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $F6.b		; A4 F6 ; Load $F6.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	sty $DC.b		; 84 DC ; Store Y register to $DC.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $F818.w,X		; 3C 18 F8 ; Test bits $F818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7A		; 80 7A ; Branch always to $80, $7A [Flow: branch]
	.db $80, $D4		; 80 D4 ; Branch always to $80, $D4 [Flow: branch]
	jsr $C024.w		; 20 24 C0 ; Jump to subroutine at $C024.w [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($33.b)		; 12 33 ; OR accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $081F00.l,X		; 1F 00 1F 08 ; Logical OR long $081F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0707.w		; 0E 07 07 ; Arithmetic shift left $0707.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $C800.w,X		; FE 00 C8 ; Increment memory $C800.w,X [Reads: X Index] [Flags: ZN]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	cpy #$08.b		; C0 08 ; Compare #$08.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2D.b		; 06 2D ; Arithmetic shift left $2D.b [Reads: Direct Page] [Flags: ZNC]
	ora ($33.b)		; 12 33 ; OR accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $0C1F00.l,X		; 1F 00 1F 0C ; Logical OR long $0C1F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $10000F.l		; 0F 0F 00 10 ; OR accumulator with memory (long) $10000F.l [Writes: Accumulator] [Flags: ZN]
	ora $200728.l		; 0F 28 07 20 ; OR accumulator with memory (long) $200728.l [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031C.w		; 0C 1C 03 ; Test and set bits $031C.w [Reads: Accumulator] [Flags: Z]
	ora $001F00.l,X		; 1F 00 1F 00 ; Logical OR long $001F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $708F00.l		; 0F 00 8F 70 ; OR accumulator with memory (long) $708F00.l [Writes: Accumulator] [Flags: ZN]
	inc $C800.w,X		; FE 00 C8 ; Increment memory $C800.w,X [Reads: X Index] [Flags: ZN]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7E.b,X		; 76 7E ; Rotate right $7E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	cpy #$08.b		; C0 08 ; Compare #$08.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $19.b		; 04 19 ; Test and set bits $19.b [Reads: Accumulator] [Flags: Z]
	asl $2D.b		; 06 2D ; Arithmetic shift left $2D.b [Reads: Direct Page] [Flags: ZNC]
	ora ($33.b)		; 12 33 ; OR accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $237C.w		; 0C 7C 23 ; Test and set bits $237C.w [Reads: Accumulator] [Flags: Z]
	adc $1C7330.l,X		; 7F 30 73 1C ; Add long $1C7330.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $1100.w		; 1C 00 11 ; Test and reset bits $1100.w [Reads: Accumulator] [Flags: Z]
	asl $0F10.w		; 0E 10 0F ; Arithmetic shift left $0F10.w [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora [$30.b]		; 07 30 ; OR accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $70.b,S		; 03 70 ; OR accumulator with stack relative $70.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $037C.w		; 0C 7C 03 ; Test and set bits $037C.w [Reads: Accumulator] [Flags: Z]
	adc $001C00.l,X		; 7F 00 1C 00 ; Add long $001C00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $708FF0.l		; 0F F0 8F 70 ; OR accumulator with memory (long) $708FF0.l [Writes: Accumulator] [Flags: ZN]
	inc $DE00.w,X		; FE 00 DE ; Increment memory $DE00.w,X [Reads: X Index] [Flags: ZN]
	bit $3E.b		; 24 3E ; Test bits $3E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpy $00FC.w		; CC FC 00 ; Compare $00FC.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $76FFF6.l,X		; FF F6 FF 76 ; Subtract with carry (long,X) $76FFF6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $0E80.w,X		; 7E 80 0E ; Rotate right $0E80.w,X [Reads: X Index] [Flags: ZNC]
	.db $D0, $1E		; D0 1E ; Branch if not equal to $D0, $1E [Flow: branch]
	jsr $C03C.w		; 20 3C C0 ; Jump to subroutine at $C03C.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $334C20.l		; 5C 20 4C 33 ; Jump long to $334C20.l [Flow: jump]
	lsr $4431.w		; 4E 31 44 ; Logical shift right $4431.w [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $003C00.l,X		; 3F 00 3C 00 ; AND accumulator with memory (long,X) $003C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $1800.w,X		; 3C 00 18 ; Test bits $1800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $78.b		; 24 78 ; Test bits $78.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and [$78.b],Y		; 37 78 ; AND accumulator with memory (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$7C.b],Y		; 37 7C ; AND accumulator with memory (long indexed) [$7C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	and $183C00.l,X		; 3F 00 3C 18 ; AND accumulator with memory (long,X) $183C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	cpy $8C72.w		; CC 72 8C ; Compare $8C72.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $00FCDC.l		; 22 DC FC 00 ; Jump to subroutine long $00FCDC.l [Writes: Stack Pointer] [Flow: call]
	bit $3C00.w,X		; 3C 00 3C ; Test bits $3C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1E.b		; 24 1E ; Test bits $1E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx $EC1E.w		; EC 1E EC ; Compare $EC1E.w with X register [Reads: X Index] [Flags: ZNC]
	rol $FC1C.w,X		; 3E 1C FC ; Rotate left $FC1C.w,X [Reads: X Index] [Flags: ZNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $334C.w		; 20 4C 33 ; Jump to subroutine at $334C.w [Writes: Stack Pointer] [Flow: call]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $5C.b,X		; 35 5C ; Logical AND $5C.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $3F.b,S		; 23 3F ; AND accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $78		; 10 78 ; Branch if plus to $10, $78 [Flow: branch]
	bit $78.b		; 24 78 ; Test bits $78.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and [$78.b],Y		; 37 78 ; AND accumulator with memory (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($7C.b,S),Y		; 33 7C ; AND accumulator (stack relative indirect indexed) ($7C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $183F.w		; 20 3F 18 ; Jump to subroutine at $183F.w [Writes: Stack Pointer] [Flow: call]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	cpy $AC52.w		; CC 52 AC ; Compare $AC52.w with Y register [Reads: Y Index] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpy $FC.b		; C4 FC ; Compare $FC.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $1E24.w,X		; 1E 24 1E ; Arithmetic shift left $1E24.w,X [Reads: X Index] [Flags: ZNC]
	cpx $CC1E.w		; EC 1E CC ; Compare $CC1E.w with X register [Reads: X Index] [Flags: ZNC]
	rol $FC04.w,X		; 3E 04 FC ; Rotate left $FC04.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy $8E40.w,X		; BC 40 8E ; Load Y register $8E40.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc ($5E.b),Y		; 71 5E ; Add with carry ($5E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($3F.b,X)		; 21 3F ; Logical AND ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $4C		; F0 4C ; Branch if equal to $F0, $4C [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$7E.b],Y		; 77 7E ; Add with carry (long indexed) [$7E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $183F.w		; 20 3F 18 ; Jump to subroutine at $183F.w [Writes: Stack Pointer] [Flow: call]
	rol $1C18.w,X		; 3E 18 1C ; Rotate left $1C18.w,X [Reads: X Index] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3D.b		; 06 3D ; Arithmetic shift left $3D.b [Reads: Direct Page] [Flags: ZNC]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $C43A.w		; EE 3A C4 ; Increment $C43A.w [Flags: ZN]
	jsr ($3C00.w,X)		; FC 00 3C ; Jump to subroutine indirect indexed ($3C00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	and ($1F.b)		; 32 1F ; AND accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $043E.w		; CE 3E 04 ; Decrement $043E.w [Flags: ZN]
	jsr ($3C18.w,X)		; FC 18 3C ; Jump to subroutine indirect indexed ($3C18.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $16.b		; 02 16 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0C13.w		; 09 13 0C ; Logical OR #$0C13.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $000D.w,X		; 1E 0D 00 ; Arithmetic shift left $000D.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1A.b		; 04 1A ; Test and set bits $1A.b [Reads: Accumulator] [Flags: Z]
	tsb $E6.b		; 04 E6 ; Test and set bits $E6.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	stx $0070.w		; 8E 70 00 ; Store X register to $0070.w [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	trb $06.b		; 14 06 ; Test and reset bits $06.b [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3C.b		; 06 3C ; Arithmetic shift left $3C.b [Reads: Direct Page] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $1A.b		; 04 1A ; Test and set bits $1A.b [Reads: Accumulator] [Flags: Z]
	tsb $E7.b		; 04 E7 ; Test and set bits $E7.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $0E04.w		; 0E 04 0E ; Arithmetic shift left $0E04.w [Flags: ZNC]
	trb $07.b		; 14 07 ; Test and reset bits $07.b [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0A.b,X		; 16 0A ; Arithmetic shift left $0A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C00.w		; 0C 00 1C ; Test and set bits $1C00.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $000F30.l		; 0F 30 0F 00 ; OR accumulator with memory (long) $000F30.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; [PATTERN: Memory clearing operation] 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$D4.b		; C0 D4 ; Compare #$D4.b with Y register [Reads: Y Index] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	stz $98.b		; 64 98 ; Store zero to $98.b
	stz $98.b		; 64 98 ; Store zero to $98.b
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $3CD8.w,X		; 3C D8 3C ; Test bits $3CD8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($20.b,X)		; 41 20 ; Exclusive OR accumulator with memory ($20.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($0003.w,X)		; FC 03 00 ; Jump to subroutine indirect indexed ($0003.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $42F1.w		; 20 F1 42 ; Jump to subroutine at $42F1.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $4F		; F0 4F ; Branch if equal to $F0, $4F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$F4.b		; C0 F4 ; Compare #$F4.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $9C, $00		; 62 9C 00 ; Push effective relative address $62, $9C, $00 [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rol $00DC.w,X		; 3E DC 00 ; Rotate left $00DC.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $4B.b,S		; 03 4B ; OR accumulator with stack relative $4B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $7B		; 30 7B ; Branch if minus to $30, $7B [Flow: branch]
	.db $30, $7C		; 30 7C ; Branch if minus to $30, $7C [Flow: branch]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$D2.b		; C0 D2 ; Compare #$D2.b with Y register [Reads: Y Index] [Flags: ZNC]
	bit $0000.w		; 2C 00 00 ; Test bits $0000.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E00.w		; 0C 00 1E ; Test and set bits $1E00.w [Reads: Accumulator] [Flags: Z]
	tsb $0CDE.w		; 0C DE 0C ; Test and set bits $0CDE.w [Reads: Accumulator] [Flags: Z]
	rol $FE00.w,X		; 3E 00 FE ; Rotate left $FE00.w,X [Reads: X Index] [Flags: ZNC]
	tsb $0001.w		; 0C 01 00 ; Test and set bits $0001.w [Reads: Accumulator] [Flags: Z]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1C06.w		; 0E 06 1C ; Arithmetic shift left $1C06.w [Flags: ZNC]
	ora $AC0C53.l		; 0F 53 0C AC ; OR accumulator with memory (long) $AC0C53.l [Writes: Accumulator] [Flags: ZN]
	.db $10, $B0		; 10 B0 ; Branch if plus to $10, $B0 [Flow: branch]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora #$1307.w		; 09 07 13 ; Logical OR #$1307.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $005F.w		; 0C 5F 00 ; Test and set bits $005F.w [Reads: Accumulator] [Flags: Z]
	jsr ($F003.w,X)		; FC 03 F0 ; Jump to subroutine indirect indexed ($F003.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $E017A8.l		; 0F A8 17 E0 ; OR accumulator with memory (long) $E017A8.l [Writes: Accumulator] [Flags: ZN]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	bit $20.b,X		; 34 20 ; Test bits $20.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $CEF0.w,X		; 3C F0 CE ; Test bits $CEF0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $30, $35		; 30 35 ; Branch if minus to $30, $35 [Flow: branch]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D7.b		; 00 D7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$DC.b		; C0 DC ; Compare #$DC.b with Y register [Reads: Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpy $FE30.w		; CC 30 FE ; Compare $FE30.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $28.b,X		; D5 28 ; Compare accumulator $28.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $011E00.l,X		; 1F 00 1E 01 ; Logical OR long $011E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000707.l		; 0F 07 07 00 ; OR accumulator with memory (long) $000707.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1E0D.w,X		; 1E 0D 1E ; Arithmetic shift left $1E0D.w,X [Reads: X Index] [Flags: ZNC]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $0D1E.w		; 0C 1E 0D ; Test and set bits $0D1E.w [Reads: Accumulator] [Flags: Z]
	ora $000F00.l		; 0F 00 0F 00 ; OR accumulator with memory (long) $000F00.l [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $C8.b,X		; 36 C8 ; Rotate left $C8.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy $1C30.w		; CC 30 1C ; Compare $1C30.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $1C10.w		; 0C 10 1C ; Test and set bits $1C10.w [Reads: Accumulator] [Flags: Z]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0877.w,X		; 1D 77 08 ; OR accumulator with memory $0877.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2B7C.w,X		; 1D 7C 2B ; OR accumulator with memory $2B7C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $000F.w		; 0C 0F 00 ; Test and set bits $000F.w [Reads: Accumulator] [Flags: Z]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $C836F0.l		; 0F F0 36 C8 ; OR accumulator with memory (long) $C836F0.l [Writes: Accumulator] [Flags: ZN]
	cpy $F830.w		; CC 30 F8 ; Compare $F830.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $F0.b		; 06 F0 ; Arithmetic shift left $F0.b [Reads: Direct Page] [Flags: ZNC]
	tsb $C8.b		; 04 C8 ; Test and set bits $C8.b [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$39.b]		; 07 39 ; OR accumulator with memory (long) [$39.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $2D.b		; 06 2D ; Arithmetic shift left $2D.b [Reads: Direct Page] [Flags: ZNC]
	ora ($73.b)		; 12 73 ; OR accumulator with memory (indirect) ($73.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $237C.w		; 0C 7C 23 ; Test and set bits $237C.w [Reads: Accumulator] [Flags: Z]
	adc $003F30.l,X		; 7F 30 3F 00 ; Add long $003F30.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $063F07.l,X		; 1F 07 3F 06 ; Logical OR long $063F07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$0A.b]		; 27 0A ; AND accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $10.b,S		; 63 10 ; Add with carry (stack relative) $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $0C		; 70 0C ; Branch if overflow set to $70, $0C [Flow: branch]
	jmp ($3F03.w,X)		; 7C 03 3F ; Jump indirect indexed to ($3F03.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $F410.w		; EC 10 F4 ; Compare $F410.w with X register [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy $3E30.w		; CC 30 3E ; Compare $3E30.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy $FE.b		; C4 FE ; Compare $FE.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	tsb $00FC.w		; 0C FC 00 ; Test and set bits $00FC.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	cpx $D8.b		; E4 D8 ; Compare $D8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx $D0.b		; E4 D0 ; Compare $D0.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy $08.b		; C4 08 ; Compare $08.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	asl $3E30.w		; 0E 30 3E ; Arithmetic shift left $3E30.w [Flags: ZNC]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$31.b]		; 07 31 ; OR accumulator with memory (long) [$31.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $031C.w		; 0E 1C 03 ; Arithmetic shift left $031C.w [Flags: ZNC]
	ora $000F08.l,X		; 1F 08 0F 00 ; Logical OR long $000F08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora [$30.b],Y		; 17 30 ; OR accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$3C.b		; C0 3C ; Compare #$3C.b with Y register [Reads: Y Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	trb $3828.w		; 1C 28 38 ; Test and reset bits $3828.w [Reads: Accumulator] [Flags: Z]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$38.b]		; 07 38 ; OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$31.b]		; 07 31 ; OR accumulator with memory (long) [$31.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $031C.w		; 0E 1C 03 ; Arithmetic shift left $031C.w [Flags: ZNC]
	ora $030700.l		; 0F 00 07 03 ; OR accumulator with memory (long) $030700.l [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora [$20.b],Y		; 17 20 ; OR accumulator with memory (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $000F.w		; 0C 0F 00 ; Test and set bits $000F.w [Reads: Accumulator] [Flags: Z]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $88.b,X		; 76 88 ; Rotate right $88.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $10EE00.l,X		; FF 00 EE 10 ; Subtract with carry (long,X) $10EE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $F0E0.w		; 1C E0 F0 ; Test and reset bits $F0E0.w [Reads: Accumulator] [Flags: Z]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $A0		; 80 A0 ; Branch always to $80, $A0 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	ora $E40EE6.l,X		; 1F E6 0E E4 ; Logical OR long $E40EE6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $9010.w		; 0C 10 90 ; Test and set bits $9010.w [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	trb $3803.w		; 1C 03 38 ; Test and reset bits $3803.w [Reads: Accumulator] [Flags: Z]
	ora [$29.b]		; 07 29 ; OR accumulator with memory (long) [$29.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $31.b,X		; 16 31 ; Arithmetic shift left $31.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	asl $027D.w		; 0E 7D 02 ; Arithmetic shift left $027D.w [Flags: ZNC]
	adc $087F10.l,X		; 7F 10 7F 08 ; Add long $087F10.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $280F30.l		; 0F 30 0F 28 ; OR accumulator with memory (long) $280F30.l [Writes: Accumulator] [Flags: ZN]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($71.b)		; 12 71 ; OR accumulator with memory (indirect) ($71.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $037C.w		; 0C 7C 03 ; Test and set bits $037C.w [Reads: Accumulator] [Flags: Z]
	adc $003800.l,X		; 7F 00 38 00 ; Add long $003800.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $90, $88		; 90 88 ; Branch if carry clear to $90, $88 [Flow: branch]
	.db $70, $D8		; 70 D8 ; Branch if overflow set to $70, $D8 [Flow: branch]
	jsr $00FC.w		; 20 FC 00 ; Jump to subroutine at $00FC.w [Writes: Stack Pointer] [Flow: call]
	pea $FC08.w		; F4 08 FC ; Push absolute address $FC08.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $F8		; 90 F8 ; Branch if carry clear to $90, $F8 [Flow: branch]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	jsr $D0EC.w		; 20 EC D0 ; Jump to subroutine at $D0EC.w [Writes: Stack Pointer] [Flow: call]
	jsr ($FCC0.w,X)		; FC C0 FC ; Jump to subroutine indirect indexed ($FCC0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $96.b		; 00 96 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc #$59BE.w		; 69 BE 59 ; Add #$59BE.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	sbc $40E828.l,X		; FF 28 E8 40 ; Subtract with carry (long,X) $40E828.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda [$00.b]		; A7 00 ; Load accumulator (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora [$F7.b]		; 07 F7 ; OR accumulator with memory (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $F96EFE.l		; 0F FE 6E F9 ; OR accumulator with memory (long) $F96EFE.l [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $40.b,S		; E3 40 ; Subtract stack-relative $40.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp [$00.b],Y		; D7 00 ; Compare accumulator (long indexed) [$00.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	ora [$E7.b],Y		; 17 E7 ; OR accumulator with memory (long indexed) [$E7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $07F800.l,X		; FF 00 F8 07 ; Subtract with carry (long,X) $07F800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp ($0F.b),Y		; D1 0F ; Compare accumulator ($0F.b),Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	adc #$7D96.w		; 69 96 7D ; Add #$7D96.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	sta ($FF.b)		; 92 FF ; Store accumulator (indirect) ($FF.b) [Reads: Accumulator, Direct Page]
	trb $17.b		; 14 17 ; Test and reset bits $17.b [Reads: Accumulator] [Flags: Z]
	cop $E5.b		; 02 E5 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$6F.b		; E0 6F ; Compare #$6F.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $3F		; 70 3F ; Branch if overflow set to $70, $3F [Flow: branch]
	rol $9F.b,X		; 36 9F ; Rotate left $9F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	asl $CF.b		; 06 CF ; Arithmetic shift left $CF.b [Reads: Direct Page] [Flags: ZNC]
	cop $EB.b		; 02 EB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E09F00.l,X		; FF 00 9F E0 ; Subtract with carry (long,X) $E09F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	wai		; CB ; Wait for interrupt
	.db $F0, $EF		; F0 EF ; Branch if equal to $F0, $EF [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $183E29.l,X		; 7F 29 3E 18 ; Add long $183E29.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0F08.w,X		; 1E 08 0F ; Arithmetic shift left $0F08.w,X [Reads: X Index] [Flags: ZNC]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $50		; 10 50 ; Branch if plus to $10, $50 [Flow: branch]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 16
.INDEX 16
	rep #$FE		; C2 FE
	sty $7E.b,X		; 94 7E ; Store Y register $7E.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	.db $10, $79		; 10 79 ; Branch if plus to $10, $79 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $F60C.w,X		; 1D 0C F6 ; OR accumulator with memory $F60C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$00D4.w		; C0 D4 00 ; Compare #$00D4.w with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D7.b		; 00 D7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $09FB.w		; 0C FB 09 ; Test and set bits $09FB.w [Reads: Accumulator] [Flags: Z]
	sbc $14AE07.l,X		; FF 07 AE 14 ; Subtract with carry (long,X) $14AE07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$48.b],Y		; D7 48 ; Compare accumulator (long indexed) [$48.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp ($F303.w,X)		; 7C 03 F3 ; Jump indirect indexed to ($F303.w,X) [Reads: X Index] [Flow: jump]
	adc $F86DF6.l		; 6F F6 6D F8 ; Add with carry (long) $F86DF6.l [Writes: Accumulator] [Flags: ZVNC]
	ora [$FB.b]		; 07 FB ; OR accumulator with memory (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $BF.b		; 05 BF ; Logical OR $BF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$30FF.w		; C0 FF 30 ; Compare #$30FF.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $181FF0.l,X		; FF F0 1F 18 ; Subtract with carry (long,X) $181FF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $1B08.w		; 2D 08 1B ; Logical AND $1B08.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$36CF.w		; C0 CF 36 ; Compare #$36CF.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora $F8E7F6.l		; 0F F6 E7 F8 ; OR accumulator with memory (long) $F8E7F6.l [Writes: Accumulator] [Flags: ZN]
	cmp [$D8.b],Y		; D7 D8 ; Compare accumulator (long indexed) [$D8.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sbc $00F0.w		; ED F0 00 ; Subtract $00F0.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7C.b,S		; 03 7C ; OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $08B8.w		; 0C B8 08 ; Test and set bits $08B8.w [Reads: Accumulator] [Flags: Z]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $6AF655.l		; EF 55 F6 6A ; Subtract with carry (long) $6AF655.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $7303.w		; 0C 03 73 ; Test and set bits $7303.w [Reads: Accumulator] [Flags: Z]
	ora $F40FF7.l		; 0F F7 0F F4 ; OR accumulator with memory (long) $F40FF7.l [Writes: Accumulator] [Flags: ZN]
	ora $9D05BA.l		; 0F BA 05 9D ; OR accumulator with memory (long) $9D05BA.l [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$101E.w		; C0 1E 10 ; Compare #$101E.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $FDF0.w,X		; FD F0 FD ; Subtract with carry $FDF0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc [$EA.b],Y		; F7 EA ; Subtract with carry (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $000012.l,X		; 3F 12 00 00 ; AND accumulator with memory (long,X) $000012.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$3000.w		; C0 00 30 ; Compare #$3000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F0EE.w		; C0 EE F0 ; Compare #$F0EE.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora $38C7F0.l		; 0F F0 C7 38 ; OR accumulator with memory (long) $38C7F0.l [Writes: Accumulator] [Flags: ZN]
	ora $CDE0.w,X		; 1D E0 CD ; OR accumulator with memory $CDE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $D0, $60		; D0 60 ; Branch if not equal to $D0, $60 [Flow: branch]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta [$60.b],Y		; 97 60 ; Store accumulator (long indexed) [$60.b],Y [Reads: Accumulator, Direct Page, Y Index]
	eor $006021.l,X		; 5F 21 60 00 ; Exclusive OR accumulator with memory (long,X) $006021.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($60.b),Y		; F1 60 ; Subtract with carry ($60.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $61.b,X		; F6 61 ; Increment memory $61.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc [$F7.b],Y		; 77 F7 ; Add with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$F7.b]		; 67 F7 ; Add with carry (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	jsr $0006.w		; 20 06 00 ; Jump to subroutine at $0006.w [Writes: Stack Pointer] [Flow: call]
	sta $80EF00.l		; 8F 00 EF 80 ; Store accumulator (long) $80EF00.l [Reads: Accumulator]
	and $10FF20.l,X		; 3F 20 FF 10 ; AND accumulator with memory (long,X) $10FF20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $E906.w,Y		; 19 06 E9 ; OR accumulator with memory $E906.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $FA.b		; 06 FA ; Arithmetic shift left $FA.b [Reads: Direct Page] [Flags: ZNC]
	sty $06.b		; 84 06 ; Store Y register to $06.b [Reads: Y Index]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $6F.b		; 06 6F ; Arithmetic shift left $6F.b [Reads: Direct Page] [Flags: ZNC]
	stx $DF.b		; 86 DF ; Store X register to $DF.b [Reads: X Index]
	inc $10EF.w		; EE EF 10 ; Increment $10EF.w [Flags: ZN]
	ora $16EFE6.l,X		; 1F E6 EF 16 ; Logical OR long $16EFE6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lsr $0004.w,X		; 5E 04 00 ; Logical shift right $0004.w,X [Reads: X Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor ($1C.b)		; 52 1C ; Exclusive OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp ($5C.b)		; D2 5C ; Compare accumulator (indirect) ($5C.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jmp $0000.w		; 4C 00 00 ; Jump to $0000.w [Flow: jump]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$2C.b]		; 07 2C ; OR accumulator with memory (long) [$2C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($6E.b,S),Y		; 13 6E ; OR accumulator (stack relative indirect indexed) ($6E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($AE.b),Y		; 31 AE ; AND accumulator with memory ($AE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($B6.b),Y		; 71 B6 ; Add with carry ($B6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $0000.w,Y		; 79 00 00 ; Add $0000.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	stx $CE74.w		; 8E 74 CE ; Store X register to $CE74.w [Reads: X Index]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	ora ($3D.b,X)		; 01 3D ; Logical OR ($3D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: ZNC]
	ora $130E11.l		; 0F 11 0E 13 ; OR accumulator with memory (long) $130E11.l [Writes: Accumulator] [Flags: ZN]
	ora $1E21.w		; 0D 21 1E ; Logical OR $1E21.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	jsr ($1E00.w,X)		; FC 00 1E ; Jump to subroutine indirect indexed ($1E00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$E01E.w		; E0 1E E0 ; Compare #$E01E.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FE00.w,X)		; FC 00 FE ; Jump to subroutine indirect indexed ($FE00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $ECFE.w		; EC FE EC ; Compare $ECFE.w with X register [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $DE		; 10 DE ; Branch if plus to $10, $DE [Flow: branch]
	jsr $007F.w		; 20 7F 00 ; Jump to subroutine at $007F.w [Writes: Stack Pointer] [Flow: call]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $30F4.w		; 20 F4 30 ; Jump to subroutine at $30F4.w [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	adc #$0D7F.w		; 69 7F 0D ; Add #$0D7F.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	asl $0C.b,X		; 16 0C ; Arithmetic shift left $0C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $1E.b		; 26 1E ; Rotate left $1E.b [Reads: Direct Page] [Flags: ZNC]
	trb $3E00.w		; 1C 00 3E ; Test and reset bits $3E00.w [Reads: Accumulator] [Flags: Z]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($10.b,S),Y		; 33 10 ; AND accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $7F2C.w		; ED 2C 7F ; Subtract $7F2C.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	ldx $FE.b,Y		; B6 FE ; Load X register $FE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	.db $B0, $78		; B0 78 ; Branch if carry set to $B0, $78 [Flow: branch]
	.db $30, $1C		; 30 1C ; Branch if minus to $30, $1C [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $7726.w,X		; FE 26 77 ; Increment memory $7726.w,X [Reads: X Index] [Flags: ZN]
	ora #$043B.w		; 09 3B 04 ; Logical OR #$043B.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $000700.l,X		; 1F 00 07 00 ; Logical OR long $000700.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $6607.w,Y		; D9 07 66 ; Compare accumulator $6607.w,Y [Reads: Y Index] [Flags: ZNC]
	ora $0E31.w,Y		; 19 31 0E ; OR accumulator with memory $0E31.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $7E.b		; 04 7E ; Test and set bits $7E.b [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx $9810.w		; EC 10 98 ; Compare $9810.w with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$0000.w		; E0 00 00 ; Compare #$0000.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E896.w		; C0 96 E8 ; Compare #$E896.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $50, $76		; 50 76 ; Branch if overflow clear to $50, $76 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E00.w		; 0C 00 1E ; Test and set bits $1E00.w [Reads: Accumulator] [Flags: Z]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($9D.b)		; 12 9D ; OR accumulator with memory (indirect) ($9D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $68F7.w		; 6E F7 68 ; Rotate right $68F7.w [Flags: ZNC]
	sbc $B736.w,Y		; F9 36 B7 ; Subtract with carry $B736.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $DF.b,X		; D6 DF ; Decrement memory $DF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	jmp $42DD.w		; 4C DD 42 ; Jump to $42DD.w [Flow: jump]
	adc ($0C.b)		; 72 0C ; Add with carry (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $B3		; F0 B3 ; Branch if equal to $F0, $B3 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0C7E62.l,X		; BF 62 7E 0C ; Load long $0C7E62.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $EF.b		; 65 EF ; Add $EF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $A3.b		; 00 A3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sta ($60.b),Y		; 91 60 ; Store accumulator ($60.b),Y [Reads: Accumulator, Direct Page, Y Index]
	jmp $3330.w		; 4C 30 33 ; Jump to $3330.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($EF.b,X)		; 01 EF ; Logical OR ($EF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $E3		; 10 E3 ; Branch if plus to $10, $E3 [Flow: branch]
	jmp $7C6EF1.l		; 5C F1 6E 7C ; Jump long to $7C6EF1.l [Flow: jump]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $9B.b,Y		; 96 9B ; Store X register $9B.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	.db $90, $D5		; 90 D5 ; Branch if carry clear to $90, $D5 [Flow: branch]
.INDEX 16
	rep #$D9		; C2 D9
	dec $D2.b		; C6 D2 ; Decrement $D2.b [Reads: Direct Page] [Flags: ZN]
	jmp $00EC.w		; 4C EC 00 ; Jump to $00EC.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc #$6BF0.w		; 69 F0 6B ; Add #$6BF0.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	pea $EA37.w		; F4 37 EA ; Push absolute address $EA37.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and $6CBEE6.l,X		; 3F E6 BE 6C ; AND accumulator with memory (long,X) $6CBEE6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx $0000.w		; EC 00 00 ; Compare $0000.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$395F.w		; 29 5F 39 ; Logical AND #$395F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	and #$2F11.w		; 29 11 2F ; Logical AND #$2F11.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b,S),Y		; 13 1F ; OR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	ora [$72.b]		; 07 72 ; OR accumulator with memory (long) [$72.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $2060.w		; 20 60 20 ; Jump to subroutine at $2060.w [Writes: Stack Pointer] [Flow: call]
	adc [$20.b],Y		; 77 20 ; Add with carry (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $103C10.l,X		; 3F 10 3C 10 ; AND accumulator with memory (long,X) $103C10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sty $FA.b,X		; 94 FA ; Store Y register $FA.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	stz $141A.w		; 9C 1A 14 ; Store zero to $141A.w
	sty $88.b,X		; 94 88 ; Store Y register $88.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	pea $F8C8.w		; F4 C8 F8 ; Push absolute address $F8C8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $E018.w		; 20 18 E0 ; Jump to subroutine at $E018.w [Writes: Stack Pointer] [Flow: call]
	lsr $0604.w		; 4E 04 06 ; Logical shift right $0604.w [Flags: ZNC]
	tsb $EE.b		; 04 EE ; Test and set bits $EE.b [Reads: Accumulator] [Flags: Z]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $C808.w,X		; 3C 08 C8 ; Test bits $C808.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $30, $08		; 30 08 ; Branch if minus to $30, $08 [Flow: branch]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	.db $F0, $E9		; F0 E9 ; Branch if equal to $F0, $E9 [Flow: branch]
	ror $3774.w		; 6E 74 37 ; Rotate right $3774.w [Flags: ZNC]
	adc $003A1E.l,X		; 7F 1E 3A 00 ; Add long $003A1E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $000E0E.l,X		; 1F 0E 0E 00 ; Logical OR long $000E0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta [$78.b],Y		; 97 78 ; Store accumulator (long indexed) [$78.b],Y [Reads: Accumulator, Direct Page, Y Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	bit $1E61.w,X		; 3C 61 1E ; Test bits $1E61.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $1E3D04.l,X		; 3F 04 3D 1E ; AND accumulator with memory (long,X) $1E3D04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $111E.w,X		; 3D 1E 11 ; AND accumulator with memory $111E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $000E.w		; 0E 0E 00 ; Arithmetic shift left $000E.w [Flags: ZNC]
	rol $FE1C.w		; 2E 1C FE ; Rotate left $FE1C.w [Flags: ZNC]
	trb $181C.w		; 1C 1C 18 ; Test and reset bits $181C.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00E2.w		; C0 E2 00 ; Compare #$00E2.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx $00.b		; E4 00 ; Compare $00.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $200738.l,X		; 1F 38 07 20 ; Logical OR long $200738.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$10.b],Y		; 17 10 ; OR accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C038.w		; 20 38 C0 ; Jump to subroutine at $C038.w [Writes: Stack Pointer] [Flow: call]
	pea $E418.w		; F4 18 E4 ; Push absolute address $E418.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$0000.w		; E0 00 00 ; Compare #$0000.w with X register [Reads: X Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $18		; D0 18 ; Branch if not equal to $D0, $18 [Flow: branch]
	jsr $807C.w		; 20 7C 80 ; Jump to subroutine at $807C.w [Writes: Stack Pointer] [Flow: call]
	jsr ($F800.w,X)		; FC 00 F8 ; Jump to subroutine indirect indexed ($F800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $221921.l,X		; 1F 21 19 22 ; Logical OR long $221921.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($0F.b)		; 12 0F ; OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy $7040.w,X		; BC 40 70 ; Load Y register $7040.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	stz $D498.w		; 9C 98 D4 ; Store zero to $D498.w
	cld		; D8 ; Clear decimal flag [Flags: D]
	jsr ($70F0.w,X)		; FC F0 70 ; Jump to subroutine indirect indexed ($70F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$0060.w		; E0 60 00 ; Compare #$0060.w with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0E00.w,X)		; FC 00 0E ; Jump to subroutine indirect indexed ($0E00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $F4FE.w		; F4 FE F4 ; Push absolute address $F4FE.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $28,$54		; 44 54 28 ; Move block positive $28,$54 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $54		; 10 54 ; Branch if plus to $10, $54 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	mvp $00,$44		; 44 44 00 ; Move block positive $00,$44 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $EE,$00		; 44 00 EE ; Move block positive $EE,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	mvp $28,$7C		; 44 7C 28 ; Move block positive $28,$7C [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	inc $4444.w		; EE 44 44 ; Increment $4444.w [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2C.b		; 06 2C ; Arithmetic shift left $2C.b [Reads: Direct Page] [Flags: ZNC]
	ora ($3A.b,S),Y		; 13 3A ; OR accumulator (stack relative indirect indexed) ($3A.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $7C.b		; 05 7C ; Logical OR $7C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $6E.b,S		; 03 6E ; OR accumulator with stack relative $6E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($33.b,X)		; 01 33 ; Logical OR ($33.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3A0F20.l		; 0F 20 0F 3A ; OR accumulator with memory (long) $3A0F20.l [Writes: Accumulator] [Flags: ZN]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr $331D.w		; 4E 1D 33 ; Logical shift right $331D.w [Flags: ZNC]
	tsb $001C.w		; 0C 1C 00 ; Test and set bits $001C.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $7E60.w,Y		; 99 60 7E ; Store accumulator to $7E60.w,Y [Reads: Accumulator, Y Index]
	.db $80, $4C		; 80 4C ; Branch always to $80, $4C [Flow: branch]
	.db $B0, $1C		; B0 1C ; Branch if carry set to $B0, $1C [Flow: branch]
	cpx #$00F0.w		; E0 F0 00 ; Compare #$00F0.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F00E.w		; EE 0E F0 ; Increment $F00E.w [Flags: ZN]
	mvp $0C,$08		; 44 08 0C ; Move block positive $0C,$08 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $C6		; 10 C6 ; Branch if plus to $10, $C6 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cmp ($6E.b),Y		; D1 6E ; Compare accumulator ($6E.b),Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	.db $D0, $6F		; D0 6F ; Branch if not equal to $D0, $6F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E00.w		; 0C 00 1E ; Test and set bits $1E00.w [Reads: Accumulator] [Flags: Z]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9B.b		; 00 9B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1A00.w		; 0C 00 1A ; Test and set bits $1A00.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $1C.b		; 65 1C ; Add $1C.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ror $0B.b,X		; 76 0B ; Rotate right $0B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inc $38.b,X		; F6 38 ; Increment memory $38.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $DE		; 10 DE ; Branch if plus to $10, $DE [Flow: branch]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3074.w		; 20 74 30 ; Jump to subroutine at $3074.w [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc #$1F7B.w		; 69 7B 1F ; Add #$1F7B.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	ora $1E260F.l,X		; 1F 0F 26 1E ; Logical OR long $1E260F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $3E00.w		; 1C 00 3E ; Test and reset bits $3E00.w [Reads: Accumulator] [Flags: Z]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $32		; 10 32 ; Branch if plus to $10, $32 [Flow: branch]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	bit $B67B.w,X		; 3C 7B B6 ; Test bits $B67B.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inc $38F8.w,X		; FE F8 38 ; Increment memory $38F8.w,X [Reads: X Index] [Flags: ZN]
	.db $30, $04		; 30 04 ; Branch if minus to $30, $04 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7800.w		; 20 00 78 ; Jump to subroutine at $7800.w [Writes: Stack Pointer] [Flow: call]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BB.b		; 00 BB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $4897.w		; 20 97 48 ; Jump to subroutine at $4897.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $6F		; B0 6F ; Branch if carry set to $B0, $6F [Flow: branch]
	cpx #$005F.w		; E0 5F 00 ; Compare #$005F.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $E01F.w		; 20 1F E0 ; Jump to subroutine at $E01F.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $09.b		; 14 09 ; Test and reset bits $09.b [Reads: Accumulator] [Flags: Z]
	pea $FA07.w		; F4 07 FA ; Push absolute address $FA07.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7800.w		; 20 00 78 ; Jump to subroutine at $7800.w [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $48D7.w		; 20 D7 48 ; Jump to subroutine at $48D7.w [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $EB04.w,X		; 1D 04 EB ; OR accumulator with memory $EB04.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $05.b,X		; 16 05 ; Arithmetic shift left $05.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $001F00.l		; 0F 00 1F 00 ; OR accumulator with memory (long) $001F00.l [Writes: Accumulator] [Flags: ZN]
	and $3302.w,X		; 3D 02 33 ; AND accumulator with memory $3302.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $1D37.w		; 0E 37 1D ; Arithmetic shift left $1D37.w [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$E000.w		; C0 00 E0 ; Compare #$E000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BA.b		; 00 BA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $10, $44		; 10 44 ; Branch if plus to $10, $44 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	jmp $000000.l		; 5C 00 00 00 ; Jump long to $000000.l [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $88		; 10 88 ; Branch if plus to $10, $88 [Flow: branch]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0000.w		; 0D 00 00 ; Logical OR $0000.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $1FE000.l,X		; FF 00 E0 1F ; Subtract with carry (long,X) $1FE000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sta $DF3F60.l,X		; 9F 60 3F DF ; Store accumulator (long,X) $DF3F60.l,X [Reads: Accumulator, X Index]
	inc $7211.w		; EE 11 72 ; Increment $7211.w [Flags: ZN]
	ora $033C.w		; 0D 3C 03 ; Logical OR $033C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $003300.l,X		; 3F 00 33 00 ; AND accumulator with memory (long,X) $003300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $301062.l		; 4F 62 10 30 ; Exclusive OR accumulator with memory (long) $301062.l [Writes: Accumulator] [Flags: ZN]
	tsb $133C.w		; 0C 3C 13 ; Test and set bits $133C.w [Reads: Accumulator] [Flags: Z]
	and $0C.b,S		; 23 0C ; AND accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	lsr $3CB0.w		; 4E B0 3C ; Logical shift right $3CB0.w [Flags: ZNC]
	cpy #$807C.w		; C0 7C 80 ; Compare #$807C.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsr ($3800.w,X)		; FC 00 38 ; Jump to subroutine indirect indexed ($3800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($46.b)		; F2 46 ; Subtract with carry (indirect) ($46.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $3430.w		; 0C 30 34 ; Test and set bits $3430.w [Reads: Accumulator] [Flags: Z]
	cpy #$30F4.w		; C0 F4 30 ; Compare #$30F4.w with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3F57.w,X		; 3E 57 3F ; Rotate left $3F57.w,X [Reads: X Index] [Flags: ZNC]
	and $1F.b,S		; 23 1F ; AND accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora $070718.l,X		; 1F 18 07 07 ; Logical OR long $070718.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($E400.w,X)		; FC 00 E4 ; Jump to subroutine indirect indexed ($E400.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C1A.w		; 0C 1A 1C ; Test and set bits $1C1A.w [Reads: Accumulator] [Flags: Z]
	jsr ($F4F8.w,X)		; FC F8 F4 ; Jump to subroutine indirect indexed ($F4F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $7313.w		; EC 13 73 ; Compare $7313.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $003F.w		; 0C 3F 00 ; Test and set bits $003F.w [Reads: Accumulator] [Flags: Z]
	rol $1F00.w,X		; 3E 00 1F ; Rotate left $1F00.w,X [Reads: X Index] [Flags: ZNC]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $331261.l		; 4F 61 12 33 ; Exclusive OR accumulator with memory (long) $331261.l [Writes: Accumulator] [Flags: ZN]
	ora $113E.w		; 0D 3E 11 ; Logical OR $113E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$04.b],Y		; 17 04 ; OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	dec $FC30.w		; CE 30 FC ; Decrement $FC30.w [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($86.b)		; F2 86 ; Subtract with carry (indirect) ($86.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jmp $FC30.w		; 4C 30 FC ; Jump to $FC30.w [Flow: jump]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jsr $0070.w		; 20 70 00 ; Jump to subroutine at $0070.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $7603.w		; 9C 03 76 ; Store zero to $7603.w
	ora #$043B.w		; 09 3B 04 ; Logical OR #$043B.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $001D00.l,X		; 3F 00 1D 00 ; AND accumulator with memory (long,X) $001D00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$70.b],Y		; 77 70 ; Add with carry (long indexed) [$70.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $0A.b,X		; 36 0A ; Rotate left $0A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $0303.w,X		; 1D 03 03 ; OR accumulator with memory $0303.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jmp $3CB0.w		; 4C B0 3C ; Jump to $3CB0.w [Flow: jump]
	cpy #$00FC.w		; C0 FC 00 ; Compare #$00FC.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsr ($9C00.w,X)		; FC 00 9C ; Jump to subroutine indirect indexed ($9C00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	trb $BC20.w		; 1C 20 BC ; Test and reset bits $BC20.w [Reads: Accumulator] [Flags: Z]
	.db $50, $DC		; 50 DC ; Branch if overflow clear to $50, $DC [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $7860.w		; 9C 60 78 ; Store zero to $7860.w
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $7B.b		; 04 7B ; Test and set bits $7B.b [Reads: Accumulator] [Flags: Z]
	tsb $7A.b		; 04 7A ; Test and set bits $7A.b [Reads: Accumulator] [Flags: Z]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $9092.w		; EC 92 90 ; Compare $9092.w with X register [Reads: X Index] [Flags: ZNC]
	sta $96.b,X		; 95 96 ; Store accumulator to $96.b,X [Reads: Accumulator, X Index]
	eor [$D6.b],Y		; 57 D6 ; Exclusive OR accumulator with memory (long indexed) [$D6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	jsr ($F01C.w,X)		; FC 1C F0 ; Jump to subroutine indirect indexed ($F01C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3A00.w,X		; 1E 00 3A ; Arithmetic shift left $3A00.w,X [Reads: X Index] [Flags: ZNC]
	tsb $37.b		; 04 37 ; Test and set bits $37.b [Reads: Accumulator] [Flags: Z]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $012A.w		; 0D 2A 01 ; Logical OR $012A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and [$19.b],Y		; 37 19 ; AND accumulator with memory (long indexed) [$19.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$09.b],Y		; 17 09 ; OR accumulator with memory (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0202.w		; 0D 02 02 ; Logical OR $0202.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	pei ($28.b)		; D4 28 ; Push effective indirect address ($28.b) [Reads: Direct Page] [Writes: Stack Pointer]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpy $B0.b		; C4 B0 ; Compare $B0.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $B0		; 30 B0 ; Branch if minus to $30, $B0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $D0, $C0		; D0 C0 ; Branch if not equal to $D0, $C0 [Flow: branch]
	cpx #$0000.w		; E0 00 00 ; Compare #$0000.w with X register [Reads: X Index] [Flags: ZNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $35.b		; 04 35 ; Test and set bits $35.b [Reads: Accumulator] [Flags: Z]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $11.b		; 06 11 ; Arithmetic shift left $11.b [Reads: Direct Page] [Flags: ZNC]
	asl $0328.w		; 0E 28 03 ; Arithmetic shift left $0328.w [Flags: ZNC]
	bit $19.b,X		; 34 19 ; Test bits $19.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	ora $0C15.w		; 0D 15 0C ; Logical OR $0C15.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $102800.l		; 0F 00 28 10 ; OR accumulator with memory (long) $102800.l [Writes: Accumulator] [Flags: ZN]
	stz $08.b,X		; 74 08 ; Store zero to $08.b,X [Reads: X Index]
	ldy $08.b,X		; B4 08 ; Load Y register $08.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	nop		; EA ; No operation
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $54		; D0 54 ; Branch if not equal to $D0, $54 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	ldy $60.b,X		; B4 60 ; Load Y register $60.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sty $1E.b		; 84 1E ; Store Y register to $1E.b [Reads: Y Index]
	jmp ($807C.w)		; 6C 7C 80 ; Jump indirect to ($807C.w) [Flow: jump]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C03.w		; 0C 03 1C ; Test and set bits $1C03.w [Reads: Accumulator] [Flags: Z]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$083F.w		; 09 3F 08 ; Logical OR #$083F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $000F0C.l,X		; 1F 0C 0F 00 ; Logical OR long $000F0C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3C.b		; 05 3C ; Logical OR $3C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $3C.b		; 02 3C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $EE807F.l		; 0F 7F 80 EE ; OR accumulator with memory (long) $EE807F.l [Writes: Accumulator] [Flags: ZN]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	cpx #$04FF.w		; E0 FF 04 ; Compare #$04FF.w with X register [Reads: X Index] [Flags: ZNC]
	inc $1C1F.w,X		; FE 1F 1C ; Increment memory $1C1F.w,X [Reads: X Index] [Flags: ZN]
	ora $1F000F.l		; 0F 0F 00 1F ; OR accumulator with memory (long) $1F000F.l [Writes: Accumulator] [Flags: ZN]
	sbc $0AF00F.l		; EF 0F F0 0A ; Subtract with carry (long) $0AF00F.l [Writes: Accumulator] [Flags: ZVNC]
	cpx $06.b		; E4 06 ; Compare $06.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpx #$00E7.w		; E0 E7 00 ; Compare #$00E7.w with X register [Reads: X Index] [Flags: ZNC]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F008.w		; E0 08 F0 ; Compare #$F008.w with X register [Reads: X Index] [Flags: ZNC]
	jmp ($0000.w)		; 6C 00 00 ; Jump indirect to ($0000.w) [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $4C18.w,X		; 3C 18 4C ; Test bits $4C18.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $30, $4F		; 30 4F ; Branch if minus to $30, $4F [Flow: branch]
	.db $30, $2C		; 30 2C ; Branch if minus to $30, $2C [Flow: branch]
	ora ($34.b,S),Y		; 13 34 ; OR accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $09.b,X		; 36 09 ; Rotate left $09.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1D.b		; 04 1D ; Test and set bits $1D.b [Reads: Accumulator] [Flags: Z]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($78.b,X)		; 01 78 ; Logical OR ($78.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $78.b,X		; 34 78 ; Test bits $78.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	and [$38.b],Y		; 37 38 ; AND accumulator with memory (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$30.b],Y		; 17 30 ; OR accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$20.b],Y		; 17 20 ; OR accumulator with memory (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $3A.b		; 06 3A ; Arithmetic shift left $3A.b [Reads: Direct Page] [Flags: ZNC]
	tsb $F9.b		; 04 F9 ; Test and set bits $F9.b [Reads: Accumulator] [Flags: Z]
	asl $1D.b		; 06 1D ; Arithmetic shift left $1D.b [Reads: Direct Page] [Flags: ZNC]
.INDEX 8
	sep #$1E		; E2 1E
	cpx #$34.b		; E0 34 ; Compare #$34.b with X register [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpx $DC10.w		; EC 10 DC ; Compare $DC10.w with X register [Reads: X Index] [Flags: ZNC]
	jsr $C83C.w		; 20 3C C8 ; Jump to subroutine at $C83C.w [Writes: Stack Pointer] [Flow: call]
	asl $0F34.w		; 0E 34 0F ; Arithmetic shift left $0F34.w [Flags: ZNC]
	inc $0F.b,X		; F6 0F ; Increment memory $0F.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc ($06.b)		; F2 06 ; Subtract with carry (indirect) ($06.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	tsb $E8.b		; 04 E8 ; Test and set bits $E8.b [Reads: Accumulator] [Flags: Z]
	tsb $14D0.w		; 0C D0 14 ; Test and set bits $14D0.w [Reads: Accumulator] [Flags: Z]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	jsr ($FB00.w,X)		; FC 00 FB ; Jump to subroutine indirect indexed ($FB00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $CCF0.w		; 20 F0 CC ; Jump to subroutine at $CCF0.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $CF		; F0 CF ; Branch if equal to $F0, $CF [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $3900.w		; 0E 00 39 ; Arithmetic shift left $3900.w [Flags: ZNC]
	asl $D1.b		; 06 D1 ; Arithmetic shift left $D1.b [Reads: Direct Page] [Flags: ZNC]
	rol $0000.w		; 2E 00 00 ; Rotate left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	ora $EE1F36.l		; 0F 36 1F EE ; OR accumulator with memory (long) $EE1F36.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $CCF0.w		; 20 F0 CC ; Jump to subroutine at $CCF0.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $3900.w		; 0E 00 39 ; Arithmetic shift left $3900.w [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000036.l		; 0F 36 00 00 ; OR accumulator with memory (long) $000036.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1B00.w		; 0C 00 1B ; Test and set bits $1B00.w [Reads: Accumulator] [Flags: Z]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	ora $000F10.l		; 0F 10 0F 00 ; OR accumulator with memory (long) $000F10.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C038.w		; 20 38 C0 ; Jump to subroutine at $C038.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $F7.b,S		; 23 F7 ; AND accumulator with stack relative $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$F4.b]		; A7 F4 ; Load accumulator (long) [$F4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $F0.b,S		; 83 F0 ; Store accumulator (stack relative) $F0.b,S [Reads: Accumulator, Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $64.b		; [PATTERN: Memory clearing operation] 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stz $98.b		; 64 98 ; Store zero to $98.b
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	stz $98.b		; 64 98 ; Store zero to $98.b
	cpx $58.b		; E4 58 ; Compare $58.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	jsr ($FC40.w,X)		; FC 40 FC ; Jump to subroutine indirect indexed ($FC40.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp ($3C00.w,X)		; 7C 00 3C ; Jump indirect indexed to ($3C00.w,X) [Reads: X Index] [Flow: jump]
	cld		; D8 ; Clear decimal flag [Flags: D]
	bit $7CD8.w,X		; 3C D8 7C ; Test bits $7CD8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($BC18.w,X)		; 7C 18 BC ; Jump indirect indexed to ($BC18.w,X) [Reads: X Index] [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldy $FC00.w,X		; BC 00 FC ; Load Y register $FC00.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp ($0718.w,X)		; 7C 18 07 ; Jump indirect indexed to ($0718.w,X) [Reads: X Index] [Flow: jump]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	bit $7E.b		; 24 7E ; Test bits $7E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	trb $207E.w		; 1C 7E 20 ; Test and reset bits $207E.w [Reads: Accumulator] [Flags: Z]
	ror $7E20.w,X		; 7E 20 7E ; Rotate right $7E20.w,X [Reads: X Index] [Flags: ZNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$DE.b		; C0 DE ; Compare #$DE.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($32.b),Y		; 11 32 ; OR accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $033C.w		; 0D 3C 03 ; Logical OR $033C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $001F10.l,X		; 3F 10 1F 00 ; AND accumulator with memory (long,X) $001F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	jsr $220F.w		; 20 0F 22 ; Jump to subroutine at $220F.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	tsb $033C.w		; 0C 3C 03 ; Test and set bits $033C.w [Reads: Accumulator] [Flags: Z]
	ora $000000.l,X		; 1F 00 00 00 ; Logical OR long $000000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($CE.b),Y		; 31 CE ; AND accumulator with memory ($CE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $3E80.w,X		; 7E 80 3E ; Rotate right $3E80.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$7E.b		; C0 7E ; Compare #$7E.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	.db $30, $FC		; 30 FC ; Branch if minus to $30, $FC [Flow: branch]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $E01E.w		; EE 1E E0 ; Increment $E01E.w [Flags: ZN]
	asl $3E2C.w,X		; 1E 2C 3E ; Arithmetic shift left $3E2C.w,X [Reads: X Index] [Flags: ZNC]
	jmp $807C.w		; 4C 7C 80 ; Jump to $807C.w [Flow: jump]
	jsr ($3800.w,X)		; FC 00 38 ; Jump to subroutine indirect indexed ($3800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $DC.b		; 04 DC ; Test and set bits $DC.b [Reads: Accumulator] [Flags: Z]
	ora $36.b,S		; 03 36 ; OR accumulator with stack relative $36.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$053A.w		; 09 3A 05 ; Logical OR #$053A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $1F03.w,X		; 3C 03 1F ; Test bits $1F03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $200FD0.l		; CF D0 0F 20 ; Compare accumulator (long) $200FD0.l [Reads: Accumulator] [Flags: ZNC]
	ora [$32.b],Y		; 17 32 ; OR accumulator with memory (long indexed) [$32.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $0C		; 30 0C ; Branch if minus to $30, $0C [Flow: branch]
	trb $0303.w		; 1C 03 03 ; Test and reset bits $0303.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $CE31.w		; 2E 31 CE ; Rotate left $CE31.w [Flags: ZNC]
	ror $3E80.w,X		; 7E 80 3E ; Rotate right $3E80.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$7E.b		; C0 7E ; Compare #$7E.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($7860.w,X)		; FC 60 78 ; Jump to subroutine indirect indexed ($7860.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $EE1F.w		; EE 1F EE ; Increment $EE1F.w [Flags: ZN]
	asl $1EE0.w,X		; 1E E0 1E ; Arithmetic shift left $1EE0.w,X [Reads: X Index] [Flags: ZNC]
	bit $4C3E.w		; 2C 3E 4C ; Test bits $4C3E.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	jmp ($FC80.w,X)		; 7C 80 FC ; Jump indirect indexed to ($FC80.w,X) [Reads: X Index] [Flow: jump]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($72.b),Y		; 11 72 ; OR accumulator with memory ($72.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $037C.w		; 0D 7C 03 ; Logical OR $037C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	lda $709B60.l,X		; BF 60 9B 70 ; Load long $709B60.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$42.b]		; 07 42 ; OR accumulator with memory (long) [$42.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	tsb $03FC.w		; 0C FC 03 ; Test and set bits $03FC.w [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	lsr $3EB0.w		; 4E B0 3E ; Logical shift right $3EB0.w [Flags: ZNC]
	cpy #$FD.b		; C0 FD ; Compare #$FD.b with Y register [Reads: Y Index] [Flags: ZNC]
	asl $D9.b		; 06 D9 ; Arithmetic shift left $D9.b [Reads: Direct Page] [Flags: ZNC]
	asl $001F.w		; 0E 1F 00 ; Arithmetic shift left $001F.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E0.b		; 14 E0 ; Test and reset bits $E0.b [Reads: Accumulator] [Flags: Z]
	.db $42, $0C		; 42 0C ; Reserved instruction
	asl $3F30.w		; 0E 30 3F ; Arithmetic shift left $3F30.w [Flags: ZNC]
	cpy #$DF.b		; C0 DF ; Compare #$DF.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $30F4.w		; 20 F4 30 ; Jump to subroutine at $30F4.w [Writes: Stack Pointer] [Flow: call]
	jsr ($FC18.w,X)		; FC 18 FC ; Jump to subroutine indirect indexed ($FC18.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $A4,$CC		; 54 CC A4 ; Move block negative $A4,$CC [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	trb $18B4.w		; 1C B4 18 ; Test and reset bits $18B4.w [Reads: Accumulator] [Flags: Z]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7E.b		; 24 7E ; Test bits $7E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $5A.b,X		; 34 5A ; Test bits $5A.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $2424.w,X		; 7E 24 24 ; Rotate right $2424.w,X [Reads: X Index] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $6624.w		; 6E 24 66 ; Rotate right $6624.w [Flags: ZNC]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $2400.w,X		; 7E 00 24 ; Rotate right $2400.w,X [Reads: X Index] [Flags: ZNC]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $52.b		; A5 52 ; Load $52.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $5A.b		; A5 5A ; Load $5A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $0060.w,X		; 3C 60 00 ; Test bits $0060.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc ($00.b)		; F2 00 ; Subtract with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	jsr ($F818.w,X)		; FC 18 F8 ; Jump to subroutine indirect indexed ($F818.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx $9E.b		; E4 9E ; Compare $9E.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cpx $98.b		; E4 98 ; Compare $98.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7E.b		; 24 7E ; Test bits $7E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $425A.w,X		; 3C 5A 42 ; Test bits $425A.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	mvp $AA,$44		; 44 44 AA ; Move block positive $AA,$44 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	inc $7C54.w		; EE 54 7C ; Increment $7C54.w [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sec		; 38 ; Set carry flag [Flags: C]
	mvn $AA,$7C		; 54 7C AA ; Move block negative $AA,$7C [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	inc $4444.w		; EE 44 44 ; Increment $4444.w [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7C,$EE		; 44 EE 7C ; Move block positive $7C,$EE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($44EE.w,X)		; 7C EE 44 ; Jump indirect indexed to ($44EE.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $54		; 10 54 ; Branch if plus to $10, $54 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $08.b,X		; 94 08 ; Store Y register $08.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	trb $28.b		; 14 28 ; Test and reset bits $28.b [Reads: Accumulator] [Flags: Z]
	tsb $1200.w		; 0C 00 12 ; Test and set bits $1200.w [Reads: Accumulator] [Flags: Z]
	tsb $102E.w		; 0C 2E 10 ; Test and set bits $102E.w [Reads: Accumulator] [Flags: Z]
	eor ($20.b)		; 52 20 ; Exclusive OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($20.b)		; 52 20 ; Exclusive OR accumulator with memory (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldx #$40.b		; A2 40 ; Load #$40.b into X register [Writes: X Index] [Flags: ZN]
	ldx #$40.b		; A2 40 ; Load #$40.b into X register [Writes: X Index] [Flags: ZN]
	ldx #$40.b		; A2 40 ; Load #$40.b into X register [Writes: X Index] [Flags: ZN]
	tsb $2C12.w		; 0C 12 2C ; Test and set bits $2C12.w [Reads: Accumulator] [Flags: Z]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	ldy #$A0.b		; A0 A0 ; Load #$A0.b into Y register [Writes: Y Index] [Flags: ZN]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$68.b		; C0 68 ; Compare #$68.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $90, $38		; 90 38 ; Branch if carry clear to $90, $38 [Flow: branch]
	cpy #$14.b		; C0 14 ; Compare #$14.b with Y register [Reads: Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	trb $E8.b		; 14 E8 ; Test and reset bits $E8.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$30.b		; C0 30 ; Compare #$30.b with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	bit $4200.w,X		; 3C 00 42 ; Test bits $4200.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $7E81.w,X		; 3C 81 7E ; Test bits $7E81.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lda ($4E.b),Y		; B1 4E ; Load accumulator ($4E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda ($5E.b,X)		; A1 5E ; Load accumulator ($5E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	.db $42, $3C		; 42 3C ; Reserved instruction
	bit $815A.w,X		; 3C 5A 81 ; Test bits $815A.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Accumulator, X Index, Direct Page]
	.db $42, $3C		; 42 3C ; Reserved instruction
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3C42.w,X		; 3C 42 3C ; Test bits $3C42.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	eor ($2C.b)		; 52 2C ; Exclusive OR accumulator with memory (indirect) ($2C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $42, $3C		; 42 3C ; Reserved instruction
	.db $42, $3C		; 42 3C ; Reserved instruction
	.db $42, $3C		; 42 3C ; Reserved instruction
	bit $3C00.w,X		; 3C 00 3C ; Test bits $3C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $42, $42		; 42 42 ; Reserved instruction
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $42, $42		; 42 42 ; Reserved instruction
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $4200.w,X		; 3C 00 42 ; Test bits $4200.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $7E81.w,X		; 3C 81 7E ; Test bits $7E81.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	lda $0042.w,X		; BD 42 00 ; Load $0042.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $423C.w,X		; 3C 3C 42 ; Test bits $423C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta ($C3.b,X)		; 81 C3 ; Store accumulator ($C3.b,X) [Reads: Accumulator, X Index, Direct Page]
	lda $0007.w,X		; BD 07 00 ; Load $0007.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $001F00.l		; 0F 00 1F 00 ; OR accumulator with memory (long) $001F00.l [Writes: Accumulator] [Flags: ZN]
	asl $0C00.w,X		; 1E 00 0C ; Arithmetic shift left $0C00.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7E.b		; 24 7E ; Test bits $7E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $5A.b,X		; 34 5A ; Test bits $5A.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $007E.w,X		; 7E 7E 00 ; Rotate right $007E.w,X [Reads: X Index] [Flags: ZNC]
	sbc $18FF00.l,X		; FF 00 FF 18 ; Subtract with carry (long,X) $18FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$24.b]		; E7 24 ; Subtract with carry (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C24.w,X		; 7E 24 3C ; Rotate right $3C24.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $42, $3C		; 42 3C ; Reserved instruction
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $007F00.l,X		; 3F 00 7F 00 ; AND accumulator with memory (long,X) $007F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $003F00.l,X		; 7F 00 3F 00 ; Add long $003F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3F4040.l,X		; 3F 40 40 3F ; AND accumulator with memory (long,X) $3F4040.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C00.w,X		; 7E 00 3C ; Rotate right $3C00.w,X [Reads: X Index] [Flags: ZNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $66.b		; A5 66 ; Load $66.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $EE,$AA		; 44 AA EE ; Move block positive $EE,$AA [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	mvn $28,$7C		; 54 7C 28 ; Move block negative $28,$7C [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sec		; 38 ; Set carry flag [Flags: C]
	mvn $AA,$7C		; 54 7C AA ; Move block negative $AA,$7C [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	inc $4444.w		; EE 44 44 ; Increment $4444.w [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7C,$EE		; 44 EE 7C ; Move block positive $7C,$EE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($44EE.w,X)		; 7C EE 44 ; Jump indirect indexed to ($44EE.w,X) [Reads: X Index] [Flow: jump]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($31.b),Y		; 31 31 ; AND accumulator with memory ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $000E.w		; 0E 0E 00 ; Arithmetic shift left $000E.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($4E.b,X)		; 21 4E ; Logical AND ($4E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $50		; 10 50 ; Branch if plus to $10, $50 [Flow: branch]
	jsr $6090.w		; 20 90 60 ; Jump to subroutine at $6090.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $90		; 50 90 ; Branch if overflow clear to $50, $90 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $40A000.l,X		; 7F 00 A0 40 ; Add long $40A000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy #$40.b		; A0 40 ; Load #$40.b into Y register [Writes: Y Index] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsr $1827.w		; 20 27 18 ; Jump to subroutine at $1827.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy #$A0.b		; A0 A0 ; Load #$A0.b into Y register [Writes: Y Index] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$11.b]		; 07 11 ; OR accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0C12.w		; 0E 12 0C ; Arithmetic shift left $0C12.w [Flags: ZNC]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C1E1F.l		; 0F 1F 1E 0C ; OR accumulator with memory (long) $0C1E1F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $90		; F0 90 ; Branch if equal to $F0, $90 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3C3C.w,X		; 3C 3C 3C ; Test bits $3C3C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $0018.w,X		; 3C 18 00 ; Test bits $0018.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $BB66.w,Y		; 99 66 BB ; Store accumulator to $BB66.w,Y [Reads: Accumulator, Y Index]
	mvp $5E,$A1		; 44 A1 5E ; Move block positive $5E,$A1 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	ror $1800.w,X		; 7E 00 18 ; Rotate right $1800.w,X [Reads: X Index] [Flags: ZNC]
	ror $8199.w,X		; 7E 99 81 ; Rotate right $8199.w,X [Reads: X Index] [Flags: ZNC]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta $9966.w,Y		; 99 66 99 ; Store accumulator to $9966.w,Y [Reads: Accumulator, Y Index]
	ror $81.b		; 66 81 ; Rotate right $81.b [Reads: Direct Page] [Flags: ZNC]
	ror $3C42.w,X		; 7E 42 3C ; Rotate right $3C42.w,X [Reads: X Index] [Flags: ZNC]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $9981.w,Y		; 99 81 99 ; Store accumulator to $9981.w,Y [Reads: Accumulator, Y Index]
	.db $42, $3C		; [PATTERN: Memory clearing operation] 42 3C ; Reserved instruction
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($9A00.w,X)		; 7C 00 9A ; Jump indirect indexed to ($9A00.w,X) [Reads: X Index] [Flow: jump]
	stz $8A.b		; 64 8A ; Store zero to $8A.b
	stz $8D.b,X		; 74 8D ; Store zero to $8D.b,X [Reads: X Index]
	adc ($85.b)		; 72 85 ; Add with carry (indirect) ($85.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stz $82.b,X		; 74 82 ; Store zero to $82.b,X [Reads: X Index]
	jmp ($007C.w,X)		; 7C 7C 00 ; Jump indirect indexed to ($007C.w,X) [Reads: X Index] [Flow: jump]
	jmp ($8282.w,X)		; 7C 82 82 ; Jump indirect indexed to ($8282.w,X) [Reads: X Index] [Flow: jump]
	sta [$87.b]		; 87 87 ; Store accumulator (long) [$87.b] [Reads: Accumulator, Direct Page]
	.db $82, $82, $7C		; 82 82 7C ; Branch always long to $82, $82, $7C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $4200.w,X		; 3C 00 42 ; Test bits $4200.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $7E81.w,X		; 3C 81 7E ; Test bits $7E81.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	lda $000040.l,X		; BF 40 00 00 ; Load long $000040.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $81		; 42 81 ; Reserved instruction
	sta ($83.b,X)		; 81 83 ; Store accumulator ($83.b,X) [Reads: Accumulator, X Index, Direct Page]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $192E.w		; 0C 2E 19 ; Test and set bits $192E.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3B3F1F.l		; 0F 1F 3F 3B ; OR accumulator with memory (long) $3B3F1F.l [Writes: Accumulator] [Flags: ZN]
	ora ($80.b),Y		; 11 80 ; OR accumulator with memory ($80.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $D0		; 80 D0 ; Branch always to $80, $D0 [Flow: branch]
	cpx #$E8.b		; E0 E8 ; Compare #$E8.b with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $F4		; 30 F4 ; Branch if minus to $30, $F4 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp L000888.l		; 5C 88 88 00 ; Jump long to L000888.l [Flow: jump]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	ldy #$F0.b		; A0 F0 ; Load #$F0.b into Y register [Writes: Y Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp ($88DC.w,X)		; 7C DC 88 ; Jump indirect indexed to ($88DC.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $BB08.w,X		; 7E 08 BB ; Rotate right $BB08.w,X [Reads: X Index] [Flags: ZNC]
	jmp $0000.w		; 4C 00 00 ; Jump to $0000.w [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	bit $DD7A.w,X		; 3C 7A DD ; Test bits $DD7A.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp $7A6E.w,X		; DD 6E 7A ; Compare accumulator $7A6E.w,X [Reads: X Index] [Flags: ZNC]
	tsb $1834.w		; 0C 34 18 ; Test and set bits $1834.w [Reads: Accumulator] [Flags: Z]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $30, $D0		; 30 D0 ; Branch if minus to $30, $D0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $783C.w,X		; 7E 3C 78 ; Rotate right $783C.w,X [Reads: X Index] [Flags: ZNC]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($FCF8.w,X)		; FC F8 FC ; Jump to subroutine indirect indexed ($FCF8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $0C04.w		; F4 04 0C ; Push absolute address $0C04.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $000F00.l		; 0F 00 0F 00 ; OR accumulator with memory (long) $000F00.l [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $000003.l		; 0F 03 00 00 ; OR accumulator with memory (long) $000003.l [Writes: Accumulator] [Flags: ZN]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: ZNC]
	cmp $8BABDF.l,X		; DF DF AB 8B ; Compare accumulator (long,X) $8BABDF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	cmp ($C1.b,X)		; C1 C1 ; Compare accumulator ($C1.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	.db $62, $62, $34		; 62 62 34 ; Push effective relative address $62, $62, $34 [Writes: Stack Pointer]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $1C,$3E		; 54 3E 1C ; Move block negative $1C,$3E [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	jmp ($6C38.w,X)		; 7C 38 6C ; Jump indirect indexed to ($6C38.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	mvn $54,$54		; 54 54 54 ; Move block negative $54,$54 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $44		; 10 44 ; Branch if plus to $10, $44 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($1028.w,X)		; 7C 28 10 ; Jump indirect indexed to ($1028.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $1C360E.l,X		; 1F 0E 36 1C ; Logical OR long $1C360E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	trb $181C.w		; 1C 1C 18 ; Test and reset bits $181C.w [Reads: Accumulator] [Flags: Z]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $1F380C.l,X		; 1F 0C 38 1F ; Logical OR long $1F380C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000404.l,X		; 1F 04 04 00 ; Logical OR long $000404.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $1B.b		; 24 1B ; Test bits $1B.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and [$1B.b]		; 27 1B ; AND accumulator with memory (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F0F10.l		; 0F 10 0F 0F ; OR accumulator with memory (long) $0F0F10.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $000F1F.l,X		; 1F 1F 0F 00 ; Logical OR long $000F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7E81.w,X		; 7E 81 7E ; Rotate right $7E81.w,X [Reads: X Index] [Flags: ZNC]
	lda $A542.w,X		; BD 42 A5 ; Load $A542.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($BD.b,X)		; 81 BD ; Store accumulator ($BD.b,X) [Reads: Accumulator, X Index, Direct Page]
	lda $3C7E.w,X		; BD 7E 3C ; Load $3C7E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $1018.w,X		; 3C 18 10 ; Test bits $1018.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	.db $10, $7D		; 10 7D ; Branch if plus to $10, $7D [Flow: branch]
	asl $78BE.w,X		; 1E BE 78 ; Arithmetic shift left $78BE.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($1408.w,X)		; 7C 08 14 ; Jump indirect indexed to ($1408.w,X) [Reads: X Index] [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	rol $FE7F.w,X		; 3E 7F FE ; Rotate left $FE7F.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($081C.w,X)		; 7C 1C 08 ; Jump indirect indexed to ($081C.w,X) [Reads: X Index] [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $2C2C.w,X		; 3C 2C 2C ; Test bits $2C2C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $2C2C.w		; 2C 2C 2C ; Test bits $2C2C.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	.db $10, $7D		; 10 7D ; Branch if plus to $10, $7D [Flow: branch]
	asl $78BE.w,X		; 1E BE 78 ; Arithmetic shift left $78BE.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($1408.w,X)		; 7C 08 14 ; Jump indirect indexed to ($1408.w,X) [Reads: X Index] [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	rol $FE7F.w,X		; 3E 7F FE ; Rotate left $FE7F.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($081C.w,X)		; 7C 1C 08 ; Jump indirect indexed to ($081C.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $8100.w,X		; 7E 00 81 ; Rotate right $8100.w,X [Reads: X Index] [Flags: ZNC]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($007E.w,X)		; 7C 7E 00 ; Jump indirect indexed to ($007E.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $83FF.w,X		; 7E FF 83 ; Rotate right $83FF.w,X [Reads: X Index] [Flags: ZNC]
	ror $0000.w,X		; 7E 00 00 ; Rotate right $0000.w,X [Reads: X Index] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0C0C.w		; 0C 0C 0C ; Test and set bits $0C0C.w [Reads: Accumulator] [Flags: Z]
	ora $0007.w		; 0D 07 00 ; Logical OR $0007.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $187E.w,X		; 7E 7E 18 ; Rotate right $187E.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $160C.w		; 0C 0C 16 ; Test and set bits $160C.w [Reads: Accumulator] [Flags: Z]
	asl $2B.b,X		; 16 2B ; Arithmetic shift left $2B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	adc $71.b,X		; 75 71 ; Add $71.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ror $1C7E.w,X		; 7E 7E 1C ; Rotate right $1C7E.w,X [Reads: X Index] [Flags: ZNC]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0A.b		; 14 0A ; Test and reset bits $0A.b [Reads: Accumulator] [Flags: Z]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $1F		; 30 1F ; Branch if minus to $30, $1F [Flow: branch]
	adc $003838.l,X		; 7F 38 38 00 ; Add long $003838.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$3F.b]		; 47 3F ; Exclusive OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$38.b]		; 47 38 ; Exclusive OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	jsr ($04FA.w,X)		; FC FA 04 ; Jump to subroutine indirect indexed ($04FA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FEFD.w,X		; FE FD FE ; Increment memory $FEFD.w,X [Reads: X Index] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $106C.w		; 20 6C 10 ; Jump to subroutine at $106C.w [Writes: Stack Pointer] [Flow: call]
	rol $08.b,X		; 36 08 ; Rotate left $08.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	dec $3330.w		; CE 30 33 ; Decrement $3330.w [Flags: ZN]
	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $030F.w		; 0C 0F 03 ; Test and set bits $030F.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00030F.l,X		; 1F 0F 03 00 ; Logical OR long $00030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $00FF00.l,X		; 7F 00 FF 00 ; Add long $00FF00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $010000.l,X		; 7F 00 00 01 ; Add long $010000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $7F7E.w,X		; 7D 7E 7F ; Add $7F7E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $BE		; 80 BE ; Branch always to $80, $BE [Flow: branch]
	ror $02FE.w,X		; 7E FE 02 ; Rotate right $02FE.w,X [Reads: X Index] [Flags: ZNC]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F1400.l		; 0F 00 14 0F ; OR accumulator with memory (long) $0F1400.l [Writes: Accumulator] [Flags: ZN]
	bit $1F.b		; 24 1F ; Test bits $1F.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $937FB6.l,X		; 3F B6 7F 93 ; AND accumulator with memory (long,X) $937FB6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $007F92.l,X		; 7F 92 7F 00 ; Add long $007F92.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $001F1F.l,X		; 3F 1F 1F 00 ; AND accumulator with memory (long,X) $001F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp ($FC.b)		; D2 FC ; Compare accumulator (indirect) ($FC.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	adc $C9FE.w		; 6D FE C9 ; Add $C9FE.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	inc $FE49.w,X		; FE 49 FE ; Increment memory $FE49.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $F0E0.w		; 20 E0 F0 ; Jump to subroutine at $F0E0.w [Writes: Stack Pointer] [Flow: call]
	jsr ($F8F8.w,X)		; FC F8 F8 ; Jump to subroutine indirect indexed ($F8F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl $1300.w		; 0E 00 13 ; Arithmetic shift left $1300.w [Flags: ZNC]
	cop $37.b		; 02 37 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $7F.b		; 06 7F ; Arithmetic shift left $7F.b [Reads: Direct Page] [Flags: ZNC]
	asl $9F.b		; 06 9F ; Arithmetic shift left $9F.b [Reads: Direct Page] [Flags: ZNC]
	ora $3CBE.w,Y		; 19 BE 3C ; OR accumulator with memory $3CBE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $7F3C.w,X		; FE 3C 7F ; Increment memory $7F3C.w,X [Reads: X Index] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $0008.w		; 0C 08 00 ; Test and set bits $0008.w [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor ($01.b,X)		; 41 01 ; Exclusive OR accumulator with memory ($01.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $F960.w,X		; FE 60 F9 ; Increment memory $F960.w,X [Reads: X Index] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $7F3C.w,X		; 7D 3C 7F ; Add $7F3C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $80FE.w,X		; 3C FE 80 ; Test bits $80FE.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	asl $82.b		; 06 82 ; Arithmetic shift left $82.b [Reads: Direct Page] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $5E.b,X		; 34 5E ; Test bits $5E.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $28.b,X		; 34 28 ; Test bits $28.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr $1034.w		; 20 34 10 ; Jump to subroutine at $1034.w [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0002.w		; 0E 02 00 ; Arithmetic shift left $0002.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $411F20.l		; 0F 20 1F 41 ; OR accumulator with memory (long) $411F20.l [Writes: Accumulator] [Flags: ZN]
	and $003F43.l,X		; 3F 43 3F 00 ; AND accumulator with memory (long,X) $003F43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $60FF40.l,X		; FF 40 FF 60 ; Subtract with carry (long,X) $60FF40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFF73.l,X		; FF 73 FF FF ; Subtract with carry (long,X) $FFFF73.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $8CFFC0.l,X		; FF C0 FF 8C ; Subtract with carry (long,X) $8CFFC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $404000.l,X		; FF 00 40 40 ; Subtract with carry (long,X) $404000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($FF.b,S),Y		; 73 FF ; Add with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $D820.w		; 20 20 D8 ; Jump to subroutine at $D820.w [Writes: Stack Pointer] [Flow: call]
	jsr $0A26.w		; 20 26 0A ; Jump to subroutine at $0A26.w [Writes: Stack Pointer] [Flow: call]
	ora $0002.w		; 0D 02 00 ; Logical OR $0002.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $4040.w		; 20 40 40 ; Jump to subroutine at $4040.w [Writes: Stack Pointer] [Flow: call]
	jsr $4008.w		; 20 08 40 ; Jump to subroutine at $4008.w [Writes: Stack Pointer] [Flow: call]
	jsr $2ADC.w		; 20 DC 2A ; Jump to subroutine at $2ADC.w [Writes: Stack Pointer] [Flow: call]
	rol $0D.b		; 26 0D ; Rotate left $0D.b [Reads: Direct Page] [Flags: ZNC]
	cop $82.b		; 02 82 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and ($24.b)		; 32 24 ; AND accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $28.b,X		; 34 28 ; Test bits $28.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $4000.w		; 0C 00 40 ; Test and set bits $4000.w [Reads: Accumulator] [Flags: Z]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0740.w		; 0C 40 07 ; Test and set bits $0740.w [Reads: Accumulator] [Flags: Z]
	jsl $100900.l		; 22 00 09 10 ; Jump to subroutine long $100900.l [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	trb $6404.w		; 1C 04 64 ; Test and reset bits $6404.w [Reads: Accumulator] [Flags: Z]
	cpy #$E2.b		; C0 E2 ; Compare #$E2.b with Y register [Reads: Y Index] [Flags: ZNC]
.ACCU 8
.INDEX 8
	sep #$F2		; E2 F2
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E264.w		; 1C 64 E2 ; Test and reset bits $E264.w [Reads: Accumulator] [Flags: Z]
	sbc ($1C.b)		; F2 1C ; Subtract with carry (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3F20.w		; 2D 20 3F ; Logical AND $3F20.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $FE00.w,X		; FE 00 FE ; Increment memory $FE00.w,X [Reads: X Index] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $04.b,X		; B4 04 ; Load Y register $04.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	jsr ($8000.w,X)		; FC 00 80 ; Jump to subroutine indirect indexed ($8000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	stx $7F.b,Y		; 96 7F ; Store X register $7F.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	adc $477FA4.l,X		; 7F A4 7F 47 ; Add long $477FA4.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $141F26.l,X		; 3F 26 1F 14 ; AND accumulator with memory (long,X) $141F26.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $070708.l		; 0F 08 07 07 ; OR accumulator with memory (long) $070708.l [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $060727.l,X		; 3F 27 07 06 ; AND accumulator with memory (long,X) $060727.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FEDD.w,X		; FE DD FE ; Increment memory $FEDD.w,X [Reads: X Index] [Flags: ZN]
	and $FE.b		; 25 FE ; Logical AND $FE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
.ACCU 8
.INDEX 8
	sep #$FC		; E2 FC
	stz $F8.b		; 64 F8 ; Store zero to $F8.b
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($E0E4.w,X)		; FC E4 E0 ; Jump to subroutine indirect indexed ($E0E4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	sbc $39BF3C.l,X		; FF 3C BF 39 ; Subtract with carry (long,X) $39BF3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $03FF13.l,X		; 9F 13 FF 03 ; Store accumulator (long,X) $03FF13.l,X [Reads: Accumulator, X Index]
	adc $6E19.w,X		; 7D 19 6E ; Add $6E19.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $000100.l,X		; 3F 00 01 00 ; AND accumulator with memory (long,X) $000100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $9CFD.w,X		; 3C FD 9C ; Test bits $9CFD.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $FFC8.w,Y		; F9 C8 FF ; Subtract with carry $FFC8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$BE.b		; C0 BE ; Compare #$BE.b with Y register [Reads: Y Index] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stz $10.b,X		; 74 10 ; Store zero to $10.b,X [Reads: X Index]
	jsr ($8000.w,X)		; FC 00 80 ; Jump to subroutine indirect indexed ($8000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $82, $7C, $E2		; 82 7C E2 ; Branch always long to $82, $7C, $E2 [Flow: branch]
	trb $62FF.w		; 1C FF 62 ; Test and reset bits $62FF.w [Reads: Accumulator] [Flags: Z]
	ror $3C2C.w,X		; 7E 2C 3C ; Rotate right $3C2C.w,X [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($621C.w,X)		; 7C 1C 62 ; Jump indirect indexed to ($621C.w,X) [Reads: X Index] [Flow: jump]
	bit $0008.w		; 2C 08 00 ; Test bits $0008.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $001102.l		; 0F 02 11 00 ; OR accumulator with memory (long) $001102.l [Writes: Accumulator] [Flags: ZN]
	rol $520C.w		; 2E 0C 52 ; Rotate left $520C.w [Flags: ZNC]
	.db $10, $64		; 10 64 ; Branch if plus to $10, $64 [Flow: branch]
	jsr $60F8.w		; 20 F8 60 ; Jump to subroutine at $60F8.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $2C		; 10 2C ; Branch if plus to $10, $2C [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7FBE7F.l,X		; FF 7F BE 7F ; Subtract with carry (long,X) $7FBE7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $7F.b		; 86 7F ; Store X register to $7F.b [Reads: X Index]
	.db $82, $7F, $82		; 82 7F 82 ; Branch always long to $82, $7F, $82 [Flow: branch]
	adc $467F82.l,X		; 7F 82 7F 46 ; Add long $467F82.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $7F3F46.l,X		; 3F 46 3F 7F ; AND accumulator with memory (long,X) $7F3F46.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $030307.l,X		; 3F 07 03 03 ; AND accumulator with memory (long,X) $030307.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $67FF3F.l,X		; FF 3F FF 67 ; Subtract with carry (long,X) $67FF3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $3FFF67.l,X		; FF 67 FF 3F ; Subtract with carry (long,X) $3FFF67.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $79FF39.l,X		; FF 39 FF 79 ; Subtract with carry (long,X) $79FF39.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFF7F.l,X		; FF 7F FF FF ; Subtract with carry (long,X) $FFFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFE7E7.l,X		; FF E7 E7 FF ; Subtract with carry (long,X) $FFE7E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $81FFFF.l,X		; FF FF FF 81 ; Subtract with carry (long,X) $81FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5020.w		; 20 20 50 ; Jump to subroutine at $5020.w [Writes: Stack Pointer] [Flow: call]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5020.w		; 20 20 50 ; Jump to subroutine at $5020.w [Writes: Stack Pointer] [Flow: call]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $2050.w		; 20 50 20 ; Jump to subroutine at $2050.w [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3071.w		; 20 71 30 ; Jump to subroutine at $3071.w [Writes: Stack Pointer] [Flow: call]
	adc ($20.b,S),Y		; 73 20 ; Add with carry (stack relative indirect indexed) ($20.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $1C3F18.l,X		; 3F 18 3F 1C ; AND accumulator with memory (long,X) $1C3F18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000707.l,X		; 1F 07 07 00 ; Logical OR long $000707.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lsr $5E4F.w,X		; 5E 4F 5E ; Logical shift right $5E4F.w,X [Reads: X Index] [Flags: ZNC]
	bit $23.b		; 24 23 ; Test bits $23.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp ($0C.b,S),Y		; D3 0C ; Compare accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	inc $E060.w,X		; FE 60 E0 ; Increment memory $E060.w,X [Reads: X Index] [Flags: ZN]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E4.b		; 14 E4 ; Test and reset bits $E4.b [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	adc $609E.w,X		; 7D 9E 60 ; Add $609E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $3C		; 80 3C ; Branch always to $80, $3C [Flow: branch]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3C.b,X		; 34 3C ; Test bits $3C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $72		; 10 72 ; Branch if plus to $10, $72 [Flow: branch]
	bit $62E3.w,X		; 3C E3 62 ; Test bits $62E3.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ror $34.b,X		; 76 34 ; Rotate right $34.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	bit $3C00.w,X		; 3C 00 3C ; Test bits $3C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $7E2C.w,X		; 3C 2C 7E ; Test bits $7E2C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta $3C4A.w,X		; 9D 4A 3C ; Store accumulator to $3C4A.w,X [Reads: Accumulator, X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $083900.l		; 0F 00 39 08 ; OR accumulator with memory (long) $083900.l [Writes: Accumulator] [Flags: ZN]
	adc $7114.w,X		; 7D 14 71 ; Add $7114.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $60F9.w		; 20 F9 60 ; Jump to subroutine at $60F9.w [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inc $0040.w,X		; FE 40 00 ; Increment memory $0040.w,X [Reads: X Index] [Flags: ZN]
	ora $5F6B37.l		; 0F 37 6B 5F ; OR accumulator with memory (long) $5F6B37.l [Writes: Accumulator] [Flags: ZN]
	sta $00A6AE.l,X		; 9F AE A6 00 ; Store accumulator (long,X) $00A6AE.l,X [Reads: Accumulator, X Index]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $F7, $76		; 62 F7 76 ; Push effective relative address $62, $F7, $76 [Writes: Stack Pointer]
	ror $3C00.w,X		; 7E 00 3C ; Rotate right $3C00.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $7E89.w,X		; 9D 89 7E ; Store accumulator to $7E89.w,X [Reads: Accumulator, X Index]
	bit $2C.b		; 24 2C ; Test bits $2C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $0010.w		; 2C 10 00 ; Test bits $0010.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $28		; 30 28 ; Branch if minus to $30, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	stz $38.b,X		; 74 38 ; Store zero to $38.b,X [Reads: X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F1D02.l		; 0F 02 1D 0F ; OR accumulator with memory (long) $0F1D02.l [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00001F.l		; 0F 1F 00 00 ; OR accumulator with memory (long) $00001F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1A.b]		; 07 1A ; OR accumulator with memory (long) [$1A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $081E.w		; 0E 1E 08 ; Arithmetic shift left $081E.w [Flags: ZNC]
	ora $070200.l,X		; 1F 00 02 07 ; Logical OR long $070200.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0F07.w		; 0E 07 0F ; Arithmetic shift left $0F07.w [Flags: ZNC]
	asl $1018.w,X		; 1E 18 10 ; Arithmetic shift left $1018.w,X [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp ($6000.w,X)		; 7C 00 60 ; Jump indirect indexed to ($6000.w,X) [Reads: X Index] [Flow: jump]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $0004.w		; 0C 04 00 ; Test and set bits $0004.w [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	ora ($0A.b)		; 12 0A ; OR accumulator with memory (indirect) ($0A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F00.w,X		; 1E 00 3F ; Arithmetic shift left $3F00.w,X [Reads: X Index] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2E21.w,X		; 1E 21 2E ; Arithmetic shift left $2E21.w,X [Reads: X Index] [Flags: ZNC]
	and ($1D.b,X)		; 21 1D ; Logical AND ($1D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $7F00.w		; 2E 00 7F ; Rotate left $7F00.w [Flags: ZNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $5551.w		; 2E 51 55 ; Rotate left $5551.w [Flags: ZNC]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($2E.b),Y		; 51 2E ; Exclusive OR accumulator with memory ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: ZNC]
	sta $E166.w,Y		; 99 66 E1 ; Store accumulator to $E166.w,Y [Reads: Accumulator, Y Index]
	ror $66F9.w,X		; 7E F9 66 ; Rotate right $66F9.w,X [Reads: X Index] [Flags: ZNC]
	sbc $E166.w,Y		; F9 66 E1 ; Subtract with carry $E166.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C72.w,X		; 7E 72 3C ; Rotate right $3C72.w,X [Reads: X Index] [Flags: ZNC]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00007E.l,X		; FF 7E 00 00 ; Subtract with carry (long,X) $00007E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $003F00.l,X		; 1F 00 3F 00 ; Logical OR long $003F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $001F00.l,X		; 3F 00 1F 00 ; AND accumulator with memory (long,X) $001F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F3F3F.l,X		; 1F 3F 3F 1F ; Logical OR long $1F3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0D1F02.l		; 0F 02 1F 0D ; OR accumulator with memory (long) $0D1F02.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $0019.w,Y		; 39 19 00 ; AND accumulator with memory $0019.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($15.b)		; 12 15 ; OR accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $48		; B0 48 ; Branch if carry set to $B0, $48 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sty $18.b		; 84 18 ; Store Y register to $18.b [Reads: Y Index]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $7C.b		; 04 7C ; Test and set bits $7C.b [Reads: Accumulator] [Flags: Z]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $000C00.l		; 0F 00 0C 00 ; OR accumulator with memory (long) $000C00.l [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $0F.b		; 14 0F ; Test and reset bits $0F.b [Reads: Accumulator] [Flags: Z]
	tsb $FC10.w		; 0C 10 FC ; Test and set bits $FC10.w [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ror $7F24.w,X		; 7E 24 7F ; Rotate right $7F24.w,X [Reads: X Index] [Flags: ZNC]
	.db $30, $3E		; 30 3E ; Branch if minus to $30, $3E [Flow: branch]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	eor $1232.w		; 4D 32 12 ; Exclusive OR $1232.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $42FF.w,X		; 3C FF 42 ; Test bits $42FF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $42C37E.l,X		; FF 7E C3 42 ; Subtract with carry (long,X) $42C37E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$66.b]		; E7 66 ; Subtract with carry (long) [$66.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C3C.w,X		; 7E 3C 3C ; Rotate right $3C3C.w,X [Reads: X Index] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $81BD.w,X		; 7E BD 81 ; Rotate right $81BD.w,X [Reads: X Index] [Flags: ZNC]
	lda $4299.w,X		; BD 99 42 ; Load $4299.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $1028.w,X		; 3C 28 10 ; Test bits $1028.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jmp ($AA10.w)		; 6C 10 AA ; Jump indirect to ($AA10.w) [Flow: jump]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	mvn $54,$EE		; 54 EE 54 ; Move block negative $54,$EE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	inc $9210.w		; EE 10 92 ; Increment $9210.w [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($BAFE.w,X)		; 7C FE BA ; Jump indirect indexed to ($BAFE.w,X) [Reads: X Index] [Flow: jump]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	inc $0092.w,X		; FE 92 00 ; Increment memory $0092.w,X [Reads: X Index] [Flags: ZN]
	and ($1E.b)		; 32 1E ; AND accumulator with memory (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $38.b		; 66 38 ; Rotate right $38.b [Reads: Direct Page] [Flags: ZNC]
	sbc [$78.b]		; E7 78 ; Subtract with carry (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$70.b]		; E7 70 ; Subtract with carry (long) [$70.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
.ACCU 8
.INDEX 8
	sep #$72		; E2 72
	adc ($39.b),Y		; 71 39 ; Add with carry ($39.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $000F0F.l,X		; 3F 0F 0F 00 ; AND accumulator with memory (long,X) $000F0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $FA78.w,X		; 3E 78 FA ; Rotate left $FA78.w,X [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $3F7F.w,X		; FE 7F 3F ; Increment memory $3F7F.w,X [Reads: X Index] [Flags: ZN]
	ora $3A3834.l		; 0F 34 38 3A ; OR accumulator with memory (long) $3A3834.l [Writes: Accumulator] [Flags: ZN]
	tsb $06F5.w		; 0C F5 06 ; Test and set bits $06F5.w [Reads: Accumulator] [Flags: Z]
	adc $06.b,X		; 75 06 ; Add $06.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora #$0E.b		; 09 0E ; Logical OR #$0E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($1C.b)		; 12 1C ; OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr ($F0F0.w,X)		; FC F0 F0 ; Jump to subroutine indirect indexed ($F0F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0727.w		; 0E 27 07 ; Arithmetic shift left $0727.w [Flags: ZNC]
	ora $F0FC1E.l		; 0F 1E FC F0 ; OR accumulator with memory (long) $F0FC1E.l [Writes: Accumulator] [Flags: ZN]
	and $183F10.l,X		; 3F 10 3F 18 ; AND accumulator with memory (long,X) $183F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stz $3C.b,X		; 74 3C ; Store zero to $3C.b,X [Reads: X Index]
	adc ($3A.b)		; 72 3A ; Add with carry (indirect) ($3A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $1C1D.w,Y		; 39 1D 1C ; AND accumulator with memory $1C1D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($3F7E.w,X)		; 7C 7E 3F ; Jump indirect indexed to ($3F7E.w,X) [Reads: X Index] [Flow: jump]
	ora $FC030F.l,X		; 1F 0F 03 FC ; Logical OR long $FC030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $1C12.w		; 0C 12 1C ; Test and set bits $1C12.w [Reads: Accumulator] [Flags: Z]
	cpx $38F8.w		; EC F8 38 ; Compare $38F8.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E0E.w		; 0C 0E 1E ; Test and set bits $1E0E.w [Reads: Accumulator] [Flags: Z]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $2A.b		; 14 2A ; Test and reset bits $2A.b [Reads: Accumulator] [Flags: Z]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and ($1A.b,X)		; 21 1A ; Logical AND ($1A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2D21.w,X		; 1E 21 2D ; Arithmetic shift left $2D21.w,X [Reads: X Index] [Flags: ZNC]
	and ($2D.b,X)		; 21 2D ; Logical AND ($2D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $130C.w		; 0C 0C 13 ; Test and set bits $130C.w [Reads: Accumulator] [Flags: Z]
	.db $10, $AF		; 10 AF ; Branch if plus to $10, $AF [Flow: branch]
	jsr $405F.w		; 20 5F 40 ; Jump to subroutine at $405F.w [Writes: Stack Pointer] [Flow: call]
	eor $80BF40.l,X		; 5F 40 BF 80 ; Exclusive OR accumulator with memory (long,X) $80BF40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $030080.l,X		; BF 80 00 03 ; Load long $030080.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $2010.w		; 0C 10 20 ; Test and set bits $2010.w [Reads: Accumulator] [Flags: Z]
	jsr $4040.w		; 20 40 40 ; Jump to subroutine at $4040.w [Writes: Stack Pointer] [Flow: call]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $3210.w,X		; 3C 10 32 ; Test bits $3210.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	trb $103C.w		; 1C 3C 10 ; Test and reset bits $103C.w [Reads: Accumulator] [Flags: Z]
	and ($1C.b)		; 32 1C ; AND accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $1010.w,X		; 3C 10 10 ; Test bits $1010.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3E3C.w,X		; 3C 3C 3E ; Test bits $3E3C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $3C3E.w,X		; 3C 3E 3C ; Test bits $3C3E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1B3B.w		; 1C 3B 1B ; Test and reset bits $1B3B.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $1F0C.w		; 1C 0C 1F ; Test and reset bits $1F0C.w [Reads: Accumulator] [Flags: Z]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $27.b		; 24 27 ; Test bits $27.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	bit $DC08.w		; 2C 08 DC ; Test bits $DC08.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	trb $3818.w		; 1C 18 38 ; Test and reset bits $3818.w [Reads: Accumulator] [Flags: Z]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E4.b		; 24 E4 ; Test bits $E4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$15.b		; 09 15 ; Logical OR #$15.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($2A.b)		; 12 2A ; OR accumulator with memory (indirect) ($2A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $55.b		; 24 55 ; Test bits $55.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	eor #$52.b		; 49 52 ; Exclusive OR #$52.b with accumulator [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $1221.w		; 2D 21 12 ; Logical AND $1221.w with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	ora ($07.b,S),Y		; 13 07 ; OR accumulator (stack relative indirect indexed) ($07.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $3C3E1F.l		; 0F 1F 3E 3C ; OR accumulator with memory (long) $3C3E1F.l [Writes: Accumulator] [Flags: ZN]
	asl $0F0F.w,X		; 1E 0F 0F ; Arithmetic shift left $0F0F.w,X [Reads: X Index] [Flags: ZNC]
	eor $9D9A.w,Y		; 59 9A 9D ; Exclusive OR accumulator with memory $9D9A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	adc ($35.b,S),Y		; 73 35 ; Add with carry (stack relative indirect indexed) ($35.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $96.b,X		; B5 96 ; Load $96.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sty $94F4.w		; 8C F4 94 ; Store Y register to $94F4.w [Reads: Y Index]
	cpx $28.b		; E4 28 ; Compare $28.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	dec $7C4E.w		; CE 4E 7C ; Decrement $7C4E.w [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $54		; F0 54 ; Branch if equal to $F0, $54 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$26.b		; 29 26 ; Logical AND #$26.b with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $13.b		; 14 13 ; Test and reset bits $13.b [Reads: Accumulator] [Flags: Z]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and #$5C.b		; 29 5C ; Logical AND #$5C.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $A0.b,S		; 43 A0 ; Exclusive OR accumulator with stack relative $A0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $A19FA0.l,X		; 9F A0 9F A1 ; Store accumulator (long,X) $A19FA0.l,X [Reads: Accumulator, X Index]
	stz $1F3F.w,X		; 9E 3F 1F ; Store zero to $1F3F.w,X [Reads: X Index]
	ora $7F3F17.l		; 0F 17 3F 7F ; OR accumulator with memory (long) $7F3F17.l [Writes: Accumulator] [Flags: ZN]
	adc $334B7F.l,X		; 7F 7F 4B 33 ; Add long $334B7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($0A.b)		; 72 0A ; Add with carry (indirect) ($0A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($04.b)		; F2 04 ; Subtract with carry (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	pea $C434.w		; F4 34 C4 ; Push absolute address $C434.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr ($FCFC.w,X)		; FC FC FC ; Jump to subroutine indirect indexed ($FCFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $1B		; F0 1B ; Branch if equal to $F0, $1B [Flow: branch]
	ora $1B.b,X		; 15 1B ; OR accumulator with memory $1B.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1B.b,X		; 15 1B ; OR accumulator with memory $1B.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1B.b,X		; 15 1B ; OR accumulator with memory $1B.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $37.b,X		; 15 37 ; OR accumulator with memory $37.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and #$36.b		; 29 36 ; Logical AND #$36.b with accumulator [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	rol $2A.b,X		; 36 2A ; Rotate left $2A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and ($2D.b,S),Y		; 33 2D ; AND accumulator (stack relative indirect indexed) ($2D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: ZNC]
	asl $1C1E.w		; 0E 1E 1C ; Arithmetic shift left $1C1E.w [Flags: ZNC]
	trb $361E.w		; 1C 1E 36 ; Test and reset bits $361E.w [Reads: Accumulator] [Flags: Z]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ror $4A.b,X		; 76 4A ; Rotate right $4A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy $98B4.w		; CC B4 98 ; Compare $98B4.w with Y register [Reads: Y Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $B0, $50		; B0 50 ; Branch if carry set to $B0, $50 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	.db $B0, $D0		; B0 D0 ; Branch if carry set to $B0, $D0 [Flow: branch]
	trb $783C.w		; 1C 3C 78 ; Test and reset bits $783C.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: ZNC]
	ora $0D0A.w		; 0D 0A 0D ; Logical OR $0D0A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $090A.w		; 0D 0A 09 ; Logical OR $090A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: ZNC]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: ZNC]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: ZNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx $EC14.w		; EC 14 EC ; Compare $EC14.w with X register [Reads: X Index] [Flags: ZNC]
	pei ($B6.b)		; D4 B6 ; Push effective indirect address ($B6.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	ldx $AA.b,Y		; B6 AA ; Load X register $AA.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	inc $6A.b,X		; F6 6A ; Increment memory $6A.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	eor $DB.b,X		; 55 DB ; Exclusive OR accumulator with memory $DB.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $F0.b,X		; 55 F0 ; Exclusive OR accumulator with memory $F0.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $9C1C.w		; 1C 1C 9C ; Test and reset bits $9C1C.w [Reads: Accumulator] [Flags: Z]
	stx $008E.w		; 8E 8E 00 ; Store X register to $008E.w [Reads: X Index]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	bit $04.b		; 24 04 ; Test bits $04.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($16.b,S),Y		; 13 16 ; OR accumulator (stack relative indirect indexed) ($16.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and #$26.b		; 29 26 ; Logical AND #$26.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $1A16.w,Y		; 19 16 1A ; OR accumulator with memory $1A16.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	jsr $3C78.w		; 20 78 3C ; Jump to subroutine at $3C78.w [Writes: Stack Pointer] [Flow: call]
	and $2F0F1F.l,X		; 3F 1F 0F 2F ; AND accumulator with memory (long,X) $2F0F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	lda #$8A.b		; A9 8A ; Load #$8A.b into accumulator [Writes: Accumulator] [Flags: ZN]
	lda ($A4.b),Y		; B1 A4 ; Load accumulator ($A4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta ($A0.b,S),Y		; 93 A0 ; Store accumulator (stack relative indirect indexed) ($A0.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	sta $803F40.l,X		; 9F 40 3F 80 ; Store accumulator (long,X) $803F40.l,X [Reads: Accumulator, X Index]
	adc $603FC0.l,X		; 7F C0 3F 60 ; Add long $603FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $7F7F77.l,X		; 1F 77 7F 7F ; Logical OR long $7F7F77.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FFFFFF.l,X		; [PATTERN: Memory clearing operation] 7F FF FF FF ; Add long $FFFFFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $125D23.l,X		; FF 23 5D 12 ; Subtract with carry (long,X) $125D23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $99.b		; 64 99 ; Store zero to $99.b
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	stz $12AD.w		; 9C AD 12 ; Store zero to $12AD.w
	jsl $2C5149.l		; 22 49 51 2C ; Jump to subroutine long $2C5149.l [Writes: Stack Pointer] [Flow: call]
	bit $26.b		; 24 26 ; Test bits $26.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc $77FF.w,X		; FE FF 77 ; Increment memory $77FF.w,X [Reads: X Index] [Flags: ZN]
	adc ($7D.b,S),Y		; 73 7D ; Add with carry (stack relative indirect indexed) ($7D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $1C18.w,X		; 3C 18 1C ; Test bits $1C18.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $40A0.w		; 20 A0 40 ; Jump to subroutine at $40A0.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $D0		; 10 D0 ; Branch if plus to $10, $D0 [Flow: branch]
	bit $63DC.w,X		; 3C DC 63 ; Test bits $63DC.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta $1C.b,S		; 83 1C ; Store accumulator (stack relative) $1C.b,S [Reads: Accumulator, Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $9C.b,S		; 83 9C ; Store accumulator (stack relative) $9C.b,S [Reads: Accumulator, Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $F0.b,S		; 63 F0 ; Add with carry (stack relative) $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $011F7F.l,X		; FF 7F 1F 01 ; Subtract with carry (long,X) $011F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $2D.b		; 24 2D ; Test bits $2D.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($33.b,X)		; 01 33 ; Logical OR ($33.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $4A2455.l,X		; 3F 55 24 4A ; AND accumulator with memory (long,X) $4A2455.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and #$9A.b		; 29 9A ; Logical AND #$9A.b with accumulator [Writes: Accumulator] [Flags: ZN]
	adc #$56.b		; 69 56 ; Add #$56.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	jsr $3807.w		; 20 07 38 ; Jump to subroutine at $3807.w [Writes: Stack Pointer] [Flow: call]
	jmp $8830.w		; 4C 30 88 ; Jump to $8830.w [Flow: jump]
	.db $70, $C4		; 70 C4 ; Branch if overflow set to $70, $C4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F8FCFF.l,X		; FF FF FC F8 ; Subtract with carry (long,X) $F8FCFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($6412.w,X)		; FC 12 64 ; Jump to subroutine indirect indexed ($6412.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	stz $10AC.w		; 9C AC 10 ; Store zero to $10AC.w
	jsr $5048.w		; 20 48 50 ; Jump to subroutine at $5048.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr $0804.w		; 20 04 08 ; Jump to subroutine at $0804.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	adc [$72.b],Y		; 77 72 ; Add with carry (long indexed) [$72.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $1C3C.w,X		; 7E 3C 1C ; Rotate right $1C3C.w,X [Reads: X Index] [Flags: ZNC]
	bit $001E.w,X		; 3C 1E 00 ; Test bits $001E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($5E.b,X)		; 01 5E ; Logical OR ($5E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $1C2728.l,X		; 1F 28 27 1C ; Logical OR long $1C2728.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $FF.b,S		; 63 FF ; Add with carry (stack relative) $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	sbc $071F7F.l,X		; FF 7F 1F 07 ; Subtract with carry (long,X) $071F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $13.b		; 14 13 ; Test and reset bits $13.b [Reads: Accumulator] [Flags: Z]
	trb $13.b		; 14 13 ; Test and reset bits $13.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	and [$56.b]		; 27 56 ; AND accumulator with memory (long) [$56.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor #$AB.b		; 49 AB ; Exclusive OR #$AB.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sta ($A7.b)		; 92 A7 ; Store accumulator (indirect) ($A7.b) [Reads: Accumulator, Direct Page]
	stx $A5.b,Y		; 96 A5 ; Store X register $A5.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sta $6B.b,X		; 95 6B ; Store accumulator to $6B.b,X [Reads: Accumulator, X Index]
	eor ($0F.b,S),Y		; 53 0F ; XOR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $7D3F1F.l		; 0F 1F 3F 7D ; OR accumulator with memory (long) $7D3F1F.l [Writes: Accumulator] [Flags: ZN]
	adc $3C78.w,Y		; 79 78 3C ; Add $3C78.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $D4.b		; 24 D4 ; Test bits $D4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sta ($A7.b)		; 92 A7 ; Store accumulator (indirect) ($A7.b) [Reads: Accumulator, Direct Page]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	eor $91.b,X		; 55 91 ; Exclusive OR accumulator with memory $91.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($D5.b),Y		; 31 D5 ; AND accumulator with memory ($D5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and #$CD.b		; 29 CD ; Logical AND #$CD.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor #$3D.b		; 49 3D ; Exclusive OR #$3D.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $39.b		; 45 39 ; Exclusive OR $39.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($EEDC.w,X)		; FC DC EE ; Jump to subroutine indirect indexed ($EEDC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $F6.b		; E6 F6 ; Increment $F6.b [Reads: Direct Page] [Flags: ZN]
	inc $FE.b,X		; F6 FE ; Increment memory $FE.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	eor ($4E.b),Y		; 51 4E ; Exclusive OR accumulator with memory ($4E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ldx #$9C.b		; A2 9C ; Load #$9C.b into X register [Writes: X Index] [Flags: ZN]
	lda $99.b		; A5 99 ; Load $99.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $99.b		; A5 99 ; Load $99.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($4C.b)		; 52 4C ; Exclusive OR accumulator with memory (indirect) ($4C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $15.b		; 24 15 ; Test bits $15.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($0A.b)		; 12 0A ; OR accumulator with memory (indirect) ($0A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$3F.b		; 09 3F ; Logical OR #$3F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $3F7E7E.l,X		; 7F 7E 7E 3F ; Add long $3F7E7E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $54070F.l,X		; 1F 0F 07 54 ; Logical OR long $54070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $A4.b		; 24 A4 ; Test bits $A4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sty $5A.b,X		; 94 5A ; Store Y register $5A.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	.db $42, $22		; 42 22 ; Reserved instruction
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sta $9195.w,Y		; 99 95 91 ; Store accumulator to $9195.w,Y [Reads: Accumulator, Y Index]
	sta $4A.b,X		; 95 4A ; Store accumulator to $4A.b,X [Reads: Accumulator, X Index]
	jmp $AC2A.w		; 4C 2A AC ; Jump to $AC2A.w [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $0E1C.w,X		; 3C 1C 0E ; Test bits $0E1C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $C787.w		; 0E 87 C7 ; Arithmetic shift left $C787.w [Flags: ZNC]
	ora $0E16.w,Y		; 19 16 0E ; OR accumulator with memory $0E16.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($30.b,X)		; 01 30 ; Logical OR ($30.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $50, $30		; 50 30 ; Branch if overflow clear to $50, $30 [Flow: branch]
	.db $D0, $B0		; D0 B0 ; Branch if not equal to $D0, $B0 [Flow: branch]
	.db $50, $B0		; 50 B0 ; Branch if overflow clear to $50, $B0 [Flow: branch]
	.db $50, $B0		; 50 B0 ; Branch if overflow clear to $50, $B0 [Flow: branch]
	.db $50, $60		; 50 60 ; Branch if overflow clear to $50, $60 [Flow: branch]
	ldy #$60.b		; A0 60 ; Load #$60.b into Y register [Writes: Y Index] [Flags: ZN]
	ldy #$70.b		; A0 70 ; Load #$70.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $90, $E0		; 90 E0 ; Branch if carry clear to $90, $E0 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$06.b		; E0 06 ; Compare #$06.b with X register [Reads: X Index] [Flags: ZNC]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $1B0A.w		; 0D 0A 1B ; Logical OR $1B0A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $1B.b,X		; 15 1B ; OR accumulator with memory $1B.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $36.b,X		; 15 36 ; OR accumulator with memory $36.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	rol $2A.b,X		; 36 2A ; Rotate left $2A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $2A.b,X		; 36 2A ; Rotate left $2A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1C1C.w		; 0E 1C 1C ; Arithmetic shift left $1C1C.w [Flags: ZNC]
	trb $6AF6.w		; 1C F6 6A ; Test and reset bits $6AF6.w [Reads: Accumulator] [Flags: Z]
	ldx $AA.b,Y		; B6 AA ; Load X register $AA.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	cpx $6CD4.w		; EC D4 6C ; Compare $6CD4.w with X register [Reads: X Index] [Flags: ZNC]
	mvn $2A,$36		; 54 36 2A ; Move block negative $2A,$36 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	rol $2A.b,X		; 36 2A ; Rotate left $2A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $1B.b,X		; 15 1B ; OR accumulator with memory $1B.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $3838.w		; 1C 38 38 ; Test and reset bits $3838.w [Reads: Accumulator] [Flags: Z]
	trb $0E1C.w		; 1C 1C 0E ; Test and reset bits $0E1C.w [Reads: Accumulator] [Flags: Z]
	asl $2935.w		; 0E 35 29 ; Arithmetic shift left $2935.w [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora ($2C.b)		; 12 2C ; OR accumulator with memory (indirect) ($2C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	jsl $95A497.l		; 22 97 A4 95 ; Jump to subroutine long $95A497.l [Writes: Stack Pointer] [Flow: call]
	ldx #$2B.b		; A2 2B ; Load #$2B.b into X register [Writes: X Index] [Flags: ZN]
	eor $03.b,X		; 55 03 ; Exclusive OR accumulator with memory $03.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $3C1E.w,X		; 7D 1E 3C ; Add $3C1E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $7B79.w,Y		; 79 79 7B ; Add $7B79.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $90FEFE.l,X		; 7F FE FE 90 ; Add long $90FEFE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $926364.l		; 8F 64 63 92 ; Store accumulator (long) $926364.l [Reads: Accumulator]
	sta ($8C.b),Y		; 91 8C ; Store accumulator ($8C.b),Y [Reads: Accumulator, Direct Page, Y Index]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $80		; B0 80 ; Branch if carry set to $B0, $80 [Flow: branch]
	adc $C36F1F.l,X		; 7F 1F 6F C3 ; Add long $C36F1F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	.db $10, $14		; 10 14 ; Branch if plus to $10, $14 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0707.w		; 0E 07 07 ; Arithmetic shift left $0707.w [Flags: ZNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0303.w		; 1C 03 03 ; Test and reset bits $0303.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $000EE0.l		; CF E0 0E 00 ; Compare accumulator (long) $000EE0.l [Reads: Accumulator] [Flags: ZNC]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2935.w		; 0C 35 29 ; Test and set bits $2935.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora ($2C.b)		; 12 2C ; OR accumulator with memory (indirect) ($2C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $10.b		; 14 10 ; Test and reset bits $10.b [Reads: Accumulator] [Flags: Z]
	jsr $A091.w		; 20 91 A0 ; Jump to subroutine at $A091.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $A2		; 90 A2 ; Branch if carry clear to $90, $A2 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	mvn $1E,$1F		; 54 1F 1E ; Move block negative $1E,$1F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	bit $7978.w,X		; 3C 78 79 ; Test bits $7978.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $1C63FF.l,X		; 7F FF 63 1C ; Add long $1C63FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$BF.b		; C0 BF ; Compare #$BF.b with Y register [Reads: Y Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and [$94.b],Y		; 37 94 ; AND accumulator with memory (long indexed) [$94.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $06.b,S		; 63 06 ; Add with carry (stack relative) $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	eor $40.b		; 45 40 ; Exclusive OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FBFF7F.l,X		; 7F 7F FF FB ; Add long $FBFF7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $01.b,S		; C3 01 ; Compare accumulator (stack relative) $01.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($31.b,X)		; 01 31 ; Logical OR ($31.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $50		; 30 50 ; Branch if minus to $30, $50 [Flow: branch]
	jsr $0020.w		; 20 20 00 ; Jump to subroutine at $0020.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $79.b,S		; 03 79 ; OR accumulator with stack relative $79.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $00307C.l,X		; 7F 7C 30 00 ; Add long $00307C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $C5,$24		; 54 24 C5 ; Move block negative $C5,$24 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cmp #$FA.b		; C9 FA ; Compare #$FA.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	pea $3631.w		; F4 31 36 ; Push absolute address $3631.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	rol $C0DF.w,X		; 3E DF C0 ; Rotate left $C0DF.w,X [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	rol $CF0F.w,X		; 3E 0F CF ; Rotate left $CF0F.w,X [Reads: X Index] [Flags: ZNC]
	sbc $1111E1.l,X		; FF E1 11 11 ; Subtract with carry (long,X) $1111E1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $B120.w		; 20 20 B1 ; Jump to subroutine at $B120.w [Writes: Stack Pointer] [Flow: call]
	stx $2746.w		; 8E 46 27 ; Store X register to $2746.w [Reads: X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	cmp $21A6.w,Y		; D9 A6 21 ; Compare accumulator $21A6.w,Y [Reads: Y Index] [Flags: ZNC]
	trb $ED80.w		; 1C 80 ED ; Test and reset bits $ED80.w [Reads: Accumulator] [Flags: Z]
	sta $0E.b,X		; 95 0E ; Store accumulator to $0E.b,X [Reads: Accumulator, X Index]
	eor $E7F17F.l,X		; 5F 7F F1 E7 ; Exclusive OR accumulator with memory (long,X) $E7F17F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $007AFF.l,X		; DF FF 7A 00 ; Compare accumulator (long,X) $007AFF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0808.w		; 20 08 08 ; Jump to subroutine at $0808.w [Writes: Stack Pointer] [Flow: call]
	sbc $05.b		; E5 05 ; Subtract $05.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	and $001C23.l,X		; 3F 23 1C 00 ; AND accumulator with memory (long,X) $001C23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $220D.w		; 0C 0D 22 ; Test and set bits $220D.w [Reads: Accumulator] [Flags: Z]
	and ($8A.b,X)		; 21 8A ; Logical AND ($8A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sty $29.b		; 84 29 ; Store Y register to $29.b [Reads: Y Index]
	ora ($A4.b),Y		; 11 A4 ; OR accumulator with memory ($A4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	mvp $91,$51		; 44 51 91 ; Move block positive $91,$51 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ldx #$22.b		; A2 22 ; Load #$22.b into X register [Writes: X Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $F8FE7F.l,X		; 1F 7F FE F8 ; Logical OR long $F8FE7F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$C1.b		; E0 C1 ; Compare #$C1.b with X register [Reads: X Index] [Flags: ZNC]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Accumulator, Direct Page]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $11.b,X		; 16 11 ; Arithmetic shift left $11.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A1F1F.l		; 0F 1F 1F 0A ; OR accumulator with memory (long) $0A1F1F.l [Writes: Accumulator] [Flags: ZN]
	ora #$14.b		; 09 14 ; Logical OR #$14.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($99.b,S),Y		; 13 99 ; OR accumulator (stack relative indirect indexed) ($99.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	stx $63.b		; 86 63 ; Store X register to $63.b [Reads: X Index]
	ora $6C90.w,X		; 1D 90 6C ; OR accumulator with memory $6C90.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sty $BC.b		; 84 BC ; Store Y register to $BC.b [Reads: Y Index]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	nop		; EA ; No operation
	ora [$2F.b]		; 07 2F ; OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $FEFFFE.l,X		; 7F FE FF FE ; Add long $FEFFFE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$07.b]		; C7 07 ; Compare accumulator (long) [$07.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $2B.b,X		; 16 2B ; Arithmetic shift left $2B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and $2C.b		; 25 2C ; Logical AND $2C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $241017.l		; 22 17 10 24 ; Jump to subroutine long $241017.l [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1F1E0F.l		; 0F 0F 1E 1F ; OR accumulator with memory (long) $1F1E0F.l [Writes: Accumulator] [Flags: ZN]
	ora $08D41F.l		; 0F 1F D4 08 ; OR accumulator with memory (long) $08D41F.l [Writes: Accumulator] [Flags: ZN]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr $501F.w		; 20 1F 50 ; Jump to subroutine at $501F.w [Writes: Stack Pointer] [Flow: call]
	jmp $5C60.w		; 4C 60 5C ; Jump to $5C60.w [Flow: jump]
	ldy $9B.b		; A4 9B ; Load $9B.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	wai		; CB ; Wait for interrupt
	.db $30, $08		; 30 08 ; Branch if minus to $30, $08 [Flow: branch]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	sbc $3F3FFF.l,X		; FF FF 3F 3F ; Subtract with carry (long,X) $3F3FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $03FFFF.l,X		; 7F FF FF 03 ; Add long $03FFFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1013.w		; 0C 13 10 ; Test and set bits $1013.w [Reads: Accumulator] [Flags: Z]
	bit $5823.w		; 2C 23 58 ; Test bits $5823.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	eor [$50.b]		; 47 50 ; Exclusive OR accumulator with memory (long) [$50.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $A09FA0.l		; 4F A0 9F A0 ; Exclusive OR accumulator with memory (long) $A09FA0.l [Writes: Accumulator] [Flags: ZN]
	sta $0F0300.l,X		; 9F 00 03 0F ; Store accumulator (long,X) $0F0300.l,X [Reads: Accumulator, X Index]
	ora $7F3F3F.l,X		; 1F 3F 3F 7F ; Logical OR long $7F3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $30C0C0.l,X		; 7F C0 C0 30 ; Add long $30C0C0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $C8		; 30 C8 ; Branch if minus to $30, $C8 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $C4.b,X		; 34 C4 ; Test bits $C4.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sep #$0A		; E2 0A ; Set processor status bits #$0A [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc ($05.b)		; F2 05 ; Subtract with carry (indirect) ($05.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F905.w,Y		; F9 05 F9 ; Subtract with carry $F905.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($FEFC.w,X)		; FC FC FE ; Jump to subroutine indirect indexed ($FEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $11.b,X		; 16 11 ; Arithmetic shift left $11.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $14		; Opcode 14 overrunning bank boundry at 087FFE. Skipping. ; Test and reset bits $14 [Reads: Accumulator] [Flags: Z]
	.db $13		; Opcode 13 overrunning bank boundry at 087FFF. Skipping. ; OR accumulator (stack relative indirect indexed) $13 [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
.ENDS
