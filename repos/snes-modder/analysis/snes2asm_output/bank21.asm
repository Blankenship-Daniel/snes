.BANK 21 SLOT 0
.ORG $0000

.SECTION "Bank21" FORCE

	ora $0C1D07.l		; 0F 07 1D 0C ; OR accumulator with memory (long) $0C1D07.l [Writes: Accumulator] [Flags: ZN]
	ora $1C08.w,Y		; 19 08 1C ; OR accumulator with memory $1C08.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0F1F.w		; 0C 1F 0F ; Test and set bits $0F1F.w [Reads: Accumulator] [Flags: Z]
	adc $43EF0F.l,X		; 7F 0F EF 43 ; Add long $43EF0F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($16.b)		; 12 16 ; OR accumulator with memory (indirect) ($16.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $BC		; 70 BC ; Branch if overflow set to $70, $BC [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $30, $98		; 30 98 ; Branch if minus to $30, $98 [Flow: branch]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $F0, $FE		; F0 FE ; Branch if equal to $F0, $FE [Flow: branch]
	.db $F0, $F7		; F0 F7 ; Branch if equal to $F0, $F7 [Flow: branch]
.ACCU 16
	rep #$E0		; C2 E0
	.db $10, $48		; 10 48 ; Branch if plus to $10, $48 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $833D.w		; 0E 3D 83 ; Arithmetic shift left $833D.w [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $1C0E.w,X		; 1E 0E 1C ; Arithmetic shift left $1C0E.w,X [Reads: X Index] [Flags: ZNC]
	tsb $0E1E.w		; 0C 1E 0E ; Test and set bits $0E1E.w [Reads: Accumulator] [Flags: Z]
	eor $84BF0F.l,X		; 5F 0F BF 84 ; Exclusive OR accumulator with memory (long,X) $84BF0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0400.w		; 0D 00 04 ; Logical OR $0400.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($50.b),Y		; 11 50 ; OR accumulator with memory ($50.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $84		; F0 84 ; Branch if equal to $F0, $84 [Flow: branch]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($D8.b,S),Y		; 13 D8 ; OR accumulator (stack relative indirect indexed) ($D8.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $C8		; 10 C8 ; Branch if plus to $10, $C8 [Flow: branch]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	.db $F0, $F6		; F0 F6 ; Branch if equal to $F0, $F6 [Flow: branch]
	cpx #$F5.b		; E0 F5 ; Compare #$F5.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $233F.w,X		; 1E 3F 23 ; Arithmetic shift left $233F.w,X [Reads: X Index] [Flags: ZNC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $00230F.l		; 22 0F 23 00 ; Jump to subroutine long $00230F.l [Writes: Stack Pointer] [Flow: call]
	ora $E000C0.l		; 0F C0 00 E0 ; OR accumulator with memory (long) $E000C0.l [Writes: Accumulator] [Flags: ZN]
	cpy #$70.b		; C0 70 ; Compare #$70.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	and $F0.b,S		; 23 F0 ; AND accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $68		; 30 68 ; Branch if minus to $30, $68 [Flow: branch]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$7E.b		; E0 7E ; Compare #$7E.b with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $09.b,X		; 34 09 ; Test bits $09.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $F788.w,X		; DD 88 F7 ; Compare accumulator $F788.w,X [Reads: X Index] [Flags: ZNC]
	cmp $77EA.w,X		; DD EA 77 ; Compare accumulator $77EA.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	stz $FFDD.w		; 9C DD FF ; Store zero to $FFDD.w
	sbc [$10.b],Y		; F7 10 ; Subtract with carry (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($27.b,S),Y		; 13 27 ; OR accumulator (stack relative indirect indexed) ($27.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	ora $267E.w,Y		; 19 7E 26 ; OR accumulator with memory $267E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor $DE35FF.l		; 4F FF 35 DE ; Exclusive OR accumulator with memory (long) $DE35FF.l [Writes: Accumulator] [Flags: ZN]
	and #$495E.w		; 29 5E 49 ; Logical AND #$495E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ldx $10.b,Y		; B6 10 ; Load X register $10.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	and $5A.b,S		; 23 5A ; AND accumulator with stack relative $5A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda ($7F.b,S),Y		; B3 7F ; Load accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $4E.b,X		; 56 4E ; Logical shift right $4E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	lda [$40.b]		; A7 40 ; Load accumulator (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy #$30.b		; A0 30 ; Load #$30.b into Y register [Writes: Y Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	and $CE34.w,X		; 3D 34 CE ; AND accumulator with memory $CE34.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $FE		; 80 FE ; Branch always to $80, $FE [Flow: branch]
	pea $163A.w		; F4 3A 16 ; Push absolute address $163A.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $7F8C.w		; ED 8C 7F ; Subtract $7F8C.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	ldy #$30.b		; A0 30 ; Load #$30.b into Y register [Writes: Y Index] [Flags: ZN]
	ora $8CCC.w,Y		; 19 CC 8C ; OR accumulator with memory $8CCC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($E4.b)		; 32 E4 ; AND accumulator with memory (indirect) ($E4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $0021.w,X		; FE 21 00 ; Increment memory $0021.w,X [Reads: X Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $98		; 80 98 ; Branch always to $80, $98 [Flow: branch]
	sbc ($4E.b,X)		; E1 4E ; Subtract with carry ($4E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($62.b,S),Y		; 73 62 ; Add with carry (stack relative indirect indexed) ($62.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $3D1B.w,X		; 7D 1B 3D ; Add $3D1B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $040E.w		; 0D 0E 04 ; Logical OR $040E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $E18000.l		; 0F 00 80 E1 ; OR accumulator with memory (long) $E18000.l [Writes: Accumulator] [Flags: ZN]
	adc ($7D.b,S),Y		; 73 7D ; Add with carry (stack relative indirect indexed) ($7D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $0F0E.w,X		; 3D 0E 0F ; AND accumulator with memory $0F0E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $70, $4C		; 70 4C ; Branch if overflow set to $70, $4C [Flow: branch]
	cmp $B0.b,S		; C3 B0 ; Compare accumulator (stack relative) $B0.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	.db $42, $A1		; 42 A1 ; Reserved instruction
	tsb $E3.b		; 04 E3 ; Test and set bits $E3.b [Reads: Accumulator] [Flags: Z]
	tsb $C2.b		; 04 C2 ; Test and set bits $C2.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp $A1B0.w		; 4C B0 A1 ; Jump to $A1B0.w [Flow: jump]
	sbc $C2.b,S		; E3 C2 ; Subtract stack-relative $C2.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$0023.w		; 09 23 00 ; Logical OR #$0023.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $FF00.w,X		; 3C 00 FF ; Test bits $FF00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $BDBD.w,X		; 3C BD BD ; Test bits $BDBD.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3C1800.l		; 22 00 18 3C ; Jump to subroutine long $3C1800.l [Writes: Stack Pointer] [Flow: call]
	cmp $42.b,S		; C3 42 ; Compare accumulator (stack relative) $42.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	bit $C3E7.w,X		; 3C E7 C3 ; Test bits $C3E7.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1F03.w		; 0C 03 1F ; Test and set bits $1F03.w [Reads: Accumulator] [Flags: Z]
	tsb $070F.w		; 0C 0F 07 ; Test and set bits $070F.w [Reads: Accumulator] [Flags: Z]
	ora $040F01.l		; 0F 01 0F 04 ; OR accumulator with memory (long) $040F01.l [Writes: Accumulator] [Flags: ZN]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $0F22.w		; 1C 22 0F ; Test and reset bits $0F22.w [Reads: Accumulator] [Flags: Z]
	cpx #$7C.b		; E0 7C ; Compare #$7C.b with X register [Reads: X Index] [Flags: ZNC]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy $FEE0.w,X		; BC E0 FE ; Load Y register $FEE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cmp ($AC.b,S),Y		; D3 AC ; Compare accumulator (stack relative indirect indexed) ($AC.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cmp $80.b,X		; D5 80 ; Compare accumulator $80.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($F3F2.w,X)		; FC F2 F3 ; Jump to subroutine indirect indexed ($F3F2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	eor ($00.b,S),Y		; 53 00 ; XOR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ldy $EF20.w,X		; BC 20 EF ; Load Y register $EF20.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor $115F1B.l,X		; 5F 1B 5F 11 ; Exclusive OR accumulator with memory (long,X) $115F1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $011B09.l		; 2F 09 1B 01 ; AND accumulator with memory (long) $011B09.l [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $64B7DF.l,X		; 7F DF B7 64 ; Add long $64B7DF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $1A36.w		; 6E 36 1A ; Rotate right $1A36.w [Flags: ZNC]
	ora ($CE.b,X)		; 01 CE ; Logical OR ($CE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $3D.b		; 04 3D ; Test and set bits $3D.b [Reads: Accumulator] [Flags: Z]
	tsb $F7.b		; 04 F7 ; Test and set bits $F7.b [Reads: Accumulator] [Flags: Z]
	ora ($BA.b)		; 12 BA ; OR accumulator with memory (indirect) ($BA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $10.b,X		; 74 10 ; Store zero to $10.b,X [Reads: X Index]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $F666.w		; ED 66 F6 ; Subtract $F666.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	cpx $80D8.w		; EC D8 80 ; Compare $80D8.w with X register [Reads: X Index] [Flags: ZNC]
	sbc ($60.b,S),Y		; F3 60 ; Subtract with carry (stack relative indirect indexed) ($60.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($6F00.w,X)		; FC 00 6F ; Jump to subroutine indirect indexed ($6F00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldx $DF08.w		; AE 08 DF ; Load $DF08.w into X register [Writes: X Index] [Flags: ZN]
	.db $50, $79		; 50 79 ; Branch if overflow clear to $50, $79 [Flow: branch]
	jsr $0032.w		; 20 32 00 ; Jump to subroutine at $0032.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $F777FF.l,X		; 9F FF 77 F7 ; Store accumulator (long,X) $F777FF.l,X [Reads: Accumulator, X Index]
	lda $013359.l		; AF 59 33 01 ; Load long $013359.l into accumulator [Writes: Accumulator] [Flags: ZN]
	cmp $083A04.l		; CF 04 3A 08 ; Compare accumulator (long) $083A04.l [Reads: Accumulator] [Flags: ZNC]
	sbc $F320.w		; ED 20 F3 ; Subtract $F320.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	cmp ($7E.b)		; D2 7E ; Compare accumulator (indirect) ($7E.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	jmp $406C.w		; 4C 6C 40 ; Jump to $406C.w [Flow: jump]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $DF.b,X		; F6 DF ; Increment memory $DF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	and $ACB2.w		; 2D B2 AC ; Logical AND $ACB2.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $07		; 80 07 ; Branch always to $80, $07 [Flow: branch]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $030000.l		; 22 00 00 03 ; Jump to subroutine long $030000.l [Writes: Stack Pointer] [Flow: call]
	mvp $0F,$00		; 44 00 0F ; Move block positive $0F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $070000.l		; 22 00 00 07 ; Jump to subroutine long $070000.l [Writes: Stack Pointer] [Flow: call]
	sta $5E.b,S		; 83 5E ; Store accumulator (stack relative) $5E.b,S [Reads: Accumulator, Stack Pointer]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $E00003.l		; 0F 03 00 E0 ; OR accumulator with memory (long) $E00003.l [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $C00000.l		; 22 00 00 C0 ; Jump to subroutine long $C00000.l [Writes: Stack Pointer] [Flow: call]
	mvp $F0,$00		; 44 00 F0 ; Move block positive $F0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E00600.l		; 22 00 06 E0 ; Jump to subroutine long $E00600.l [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	jsl $631900.l		; 22 00 19 63 ; Jump to subroutine long $631900.l [Writes: Stack Pointer] [Flow: call]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $63.b,S		; 43 63 ; Exclusive OR accumulator with stack relative $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $D7.b,S		; 63 D7 ; Add with carry (stack relative) $D7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc $01.b,S		; 63 01 ; Add with carry (stack relative) $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$DD.b]		; 07 DD ; OR accumulator with memory (long) [$DD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $62, $BF, $C0		; 62 BF C0 ; Push effective relative address $62, $BF, $C0 [Writes: Stack Pointer]
	eor $7F.b,S		; 43 7F ; Exclusive OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $83		; 80 83 ; Branch always to $80, $83 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $80E000.l,X		; FF 00 E0 80 ; Subtract with carry (long,X) $80E000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sep #$C0		; E2 C0 ; Set processor status bits #$C0 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$AFF6.w		; 09 F6 AF ; Logical OR #$AFF6.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cmp $DFA5.w,Y		; D9 A5 DF ; Compare accumulator $DFA5.w,Y [Reads: Y Index] [Flags: ZNC]
	sta ($6F.b)		; 92 6F ; Store accumulator (indirect) ($6F.b) [Reads: Accumulator, Direct Page]
	ora $7F4677.l		; 0F 77 46 7F ; OR accumulator with memory (long) $7F4677.l [Writes: Accumulator] [Flags: ZN]
	ora ($1E.b),Y		; 11 1E ; OR accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$E7.b]		; 07 E7 ; OR accumulator with memory (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp #$2FDF.w		; C9 DF 2F ; Compare #$2FDF.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	and [$47.b]		; 27 47 ; AND accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	cmp #$A93E.w		; C9 3E A9 ; Compare #$A93E.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	cmp $6ACEB7.l,X		; DF B7 CE 6A ; Compare accumulator (long,X) $6ACEB7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sty $92.b,X		; 94 92 ; Store Y register $92.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	inc $1AE4.w		; EE E4 1A ; Increment $1AE4.w [Flags: ZN]
	.db $B0, $7C		; B0 7C ; Branch if carry set to $B0, $7C [Flow: branch]
	jsr $BCE0.w		; 20 E0 BC ; Jump to subroutine at $BCE0.w [Writes: Stack Pointer] [Flow: call]
	cmp $80CE.w,X		; DD CE 80 ; Compare accumulator $80CE.w,X [Reads: X Index] [Flags: ZNC]
	stx $18.b		; 86 18 ; Store X register to $18.b [Reads: X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr $0618.w		; 20 18 06 ; Jump to subroutine at $0618.w [Writes: Stack Pointer] [Flow: call]
	asl $18.b,X		; 16 18 ; Arithmetic shift left $18.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $0406.w		; 0C 06 04 ; Test and set bits $0406.w [Reads: Accumulator] [Flags: Z]
	jsr $0002.w		; 20 02 00 ; Jump to subroutine at $0002.w [Writes: Stack Pointer] [Flow: call]
	jsr $7804.w		; 20 04 78 ; Jump to subroutine at $7804.w [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: ZNC]
	tsb $0204.w		; 0C 04 02 ; Test and set bits $0204.w [Reads: Accumulator] [Flags: Z]
	jsr $0078.w		; 20 78 00 ; Jump to subroutine at $0078.w [Writes: Stack Pointer] [Flow: call]
	ora ($C1.b,S),Y		; 13 C1 ; OR accumulator (stack relative indirect indexed) ($C1.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($80.b)		; 12 80 ; OR accumulator with memory (indirect) ($80.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $80		; 10 80 ; Branch if plus to $10, $80 [Flow: branch]
	jsr $2210.w		; 20 10 22 ; Jump to subroutine at $2210.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $40		; 10 40 ; Branch if plus to $10, $40 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $60.b		; 14 60 ; Test and reset bits $60.b [Reads: Accumulator] [Flags: Z]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	cmp ($80.b,X)		; C1 80 ; Compare accumulator ($80.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $3A0D.w,X		; 1D 0D 3A ; OR accumulator with memory $3A0D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and $3E1D.w,X		; 3D 1D 3E ; AND accumulator with memory $3E1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $173F.w,X		; 1E 3F 17 ; Arithmetic shift left $173F.w,X [Reads: X Index] [Flags: ZNC]
	and $051F0B.l,X		; 3F 0B 1F 05 ; AND accumulator with memory (long,X) $051F0B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $12.b,X		; 15 12 ; OR accumulator with memory $12.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $22.b		; 25 22 ; Logical AND $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($28.b,X)		; 21 28 ; Logical AND ($28.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $1A.b,X		; 34 1A ; Test bits $1A.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $C30700.l		; 22 00 07 C3 ; Jump to subroutine long $C30700.l [Writes: Stack Pointer] [Flow: call]
	cmp $5A.b,S		; C3 5A ; Compare accumulator (stack relative) $5A.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jsl $4208FF.l		; 22 FF 08 42 ; Jump to subroutine long $4208FF.l [Writes: Stack Pointer] [Flow: call]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	bit $5AA5.w,X		; 3C A5 5A ; Test bits $5AA5.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lda $0029.w,X		; BD 29 00 ; Load $0029.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0F00.w		; 29 00 0F ; Logical AND #$0F00.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F.b,X		; 15 3F ; OR accumulator with memory $3F.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	adc $DB18.w,Y		; 79 18 DB ; Add $DB18.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	lda $7670.w,Y		; B9 70 76 ; Load $7670.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$E1.b		; E0 E1 ; Compare #$E1.b with X register [Reads: X Index] [Flags: ZNC]
	jsl $FA0F00.l		; 22 00 0F FA ; Jump to subroutine long $FA0F00.l [Writes: Stack Pointer] [Flow: call]
	and $67.b,X		; 35 67 ; Logical AND $67.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy $FE.b,X		; B4 FE ; Load Y register $FE.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	sbc [$E1.b],Y		; F7 E1 ; Subtract with carry (long indexed) [$E1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $012F07.l,X		; 1F 07 2F 01 ; Logical OR long $012F07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $1013.w		; 0C 13 10 ; Test and set bits $1013.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $1883.w,X		; 3E 83 18 ; Rotate left $1883.w,X [Reads: X Index] [Flags: ZNC]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $3C		; 70 3C ; Branch if overflow set to $70, $3C [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($FC78.w,X)		; 7C 78 FC ; Jump indirect indexed to ($FC78.w,X) [Reads: X Index] [Flow: jump]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $88		; 10 88 ; Branch if plus to $10, $88 [Flow: branch]
	cpy $84.b		; C4 84 ; Compare $84.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	tsb $3C08.w		; 0C 08 3C ; Test and set bits $3C08.w [Reads: Accumulator] [Flags: Z]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $0D06.w		; 0E 06 0D ; Arithmetic shift left $0D06.w [Flags: ZNC]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	asl $0A87.w		; 0E 87 0A ; Arithmetic shift left $0A87.w [Flags: ZNC]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$110A.w		; 09 0A 11 ; Logical OR #$110A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	stx $15.b		; 86 15 ; Store X register to $15.b [Reads: X Index]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $9C		; 30 9C ; Branch if minus to $30, $9C [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $8738.w,X		; 3C 38 87 ; Test bits $8738.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jsl $4FE003.l		; 22 03 E0 4F ; Jump to subroutine long $4FE003.l [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	stz $C4.b		; 64 C4 ; Store zero to $C4.b
	tsb $3C08.w		; 0C 08 3C ; Test and set bits $3C08.w [Reads: Accumulator] [Flags: Z]
	adc ($00.b,X)		; 61 00 ; Add with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta ($61.b,S),Y		; 93 61 ; Store accumulator (stack relative indirect indexed) ($61.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	ror $5613.w		; 6E 13 56 ; Rotate right $5613.w [Flags: ZNC]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	adc $9E35.w		; 6D 35 9E ; Add $9E35.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	adc $619F09.l,X		; 7F 09 9F 61 ; Add long $619F09.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($F3.b,X)		; 61 F3 ; Add with carry ($F3.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($6A5C.w,X)		; 7C 5C 6A ; Jump indirect indexed to ($6A5C.w,X) [Reads: X Index] [Flow: jump]
	sbc [$72.b],Y		; F7 72 ; Subtract with carry (long indexed) [$72.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	cmp #$F686.w		; C9 86 F6 ; Compare #$F686.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pei ($B6.b)		; D4 B6 ; Push effective indirect address ($B6.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ldy $1679.w		; AC 79 16 ; Load $1679.w into Y register [Writes: Y Index] [Flags: ZN]
	ror $F910.w,X		; 7E 10 F9 ; Rotate right $F910.w,X [Reads: X Index] [Flags: ZNC]
	stx $86.b		; 86 86 ; Store X register to $86.b [Reads: X Index]
	cmp $563ABE.l		; CF BE 3A 56 ; Compare accumulator (long) $563ABE.l [Reads: Accumulator] [Flags: ZNC]
	sbc $0019CE.l		; EF CE 19 00 ; Subtract with carry (long) $0019CE.l [Writes: Accumulator] [Flags: ZVNC]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($6F.b,X)		; 61 6F ; Add with carry ($6F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora ($7F.b,S),Y		; 13 7F ; OR accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($5F.b,X)		; 21 5F ; Logical AND ($5F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sta $4CBB67.l,X		; 9F 67 BB 4C ; Store accumulator (long,X) $4CBB67.l,X [Reads: Accumulator, X Index]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($6C.b)		; F2 6C ; Subtract with carry (indirect) ($6C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	eor [$FF.b],Y		; 57 FF ; Exclusive OR accumulator with memory (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $78.b		; 85 78 ; Store accumulator to $78.b [Reads: Accumulator]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $7E.b,X		; 34 7E ; Test bits $7E.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	tsb $FA.b		; 04 FA ; Test and set bits $FA.b [Reads: Accumulator] [Flags: Z]
	trb $F9.b		; 14 F9 ; Test and reset bits $F9.b [Reads: Accumulator] [Flags: Z]
	inc $FD.b		; E6 FD ; Increment $FD.b [Reads: Direct Page] [Flags: ZN]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stx $CF.b		; 86 CF ; Store X register to $CF.b [Reads: X Index]
	rol $DE.b,X		; 36 DE ; Rotate left $DE.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	nop		; EA ; No operation
	sbc $20067D.l,X		; FF 7D 06 20 ; Subtract with carry (long,X) $20067D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $6857.w,X		; 3C 57 68 ; Test bits $6857.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	rol $BB66.w,X		; 3E 66 BB ; Rotate left $BB66.w,X [Reads: X Index] [Flags: ZNC]
	and $DD.b,S		; 23 DD ; AND accumulator with stack relative $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7576.w,Y		; 19 76 75 ; OR accumulator with memory $7576.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $1E6C.w		; 6E 6C 1E ; Rotate right $1E6C.w [Flags: ZNC]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	lda ($5D.b)		; B2 5D ; Load accumulator (indirect) ($5D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($66.b)		; 12 66 ; OR accumulator with memory (indirect) ($66.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $9A.b		; 00 9A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda [$58.b]		; A7 58 ; Load accumulator (long) [$58.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Accumulator, Direct Page]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $60.b		; 05 60 ; Logical OR $60.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	stx $84.b		; 86 84 ; Store X register to $84.b [Reads: X Index]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $E70300.l		; 22 00 03 E7 ; Jump to subroutine long $E70300.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $43.b		; 24 43 ; Test bits $43.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lda $0242.w,X		; BD 42 02 ; Load $0242.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $42, $3C		; 42 3C ; Reserved instruction
	bit $0022.w,X		; 3C 22 00 ; Test bits $0022.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx #$2C.b		; E0 2C ; Compare #$2C.b with X register [Reads: X Index] [Flags: ZNC]
	bit $5A24.w,X		; 3C 24 5A ; Test bits $5A24.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lda $42BD.w,X		; BD BD 42 ; Load $42BD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $6000.w,X		; 3C 00 60 ; Test bits $6000.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $205E.w		; 20 5E 20 ; Jump to subroutine at $205E.w [Writes: Stack Pointer] [Flow: call]
	eor $304E20.l,X		; 5F 20 4E 30 ; Exclusive OR accumulator with memory (long,X) $304E20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp $5030.w		; 4C 30 50 ; Jump to $5030.w [Flow: jump]
	jsr $0060.w		; 20 60 00 ; Jump to subroutine at $0060.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor ($4D.b)		; 52 4D ; Exclusive OR accumulator with memory (indirect) ($4D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor #$4C4A.w		; 49 4A 4C ; Exclusive OR #$4C4A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $50, $60		; 50 60 ; Branch if overflow clear to $50, $60 [Flow: branch]
	ora $040F02.l,X		; 1F 02 0F 04 ; Logical OR long $040F02.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0604.w		; 0E 04 06 ; Arithmetic shift left $0604.w [Flags: ZNC]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1D1400.l		; 22 00 14 1D ; Jump to subroutine long $1D1400.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	cmp $BD.b,S		; C3 BD ; Compare accumulator (stack relative) $BD.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ror $5A.b		; 66 5A ; Rotate right $5A.b [Reads: Direct Page] [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jsl $FF0600.l		; 22 00 06 FF ; Jump to subroutine long $FF0600.l [Writes: Stack Pointer] [Flow: call]
	sbc $42A599.l,X		; FF 99 A5 42 ; Subtract with carry (long,X) $42A599.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $DB.b		; A5 DB ; Load $DB.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $63.b		; 84 63 ; Store Y register to $63.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $5A.b		; 84 5A ; Store Y register to $5A.b [Reads: Y Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $070F07.l		; 22 07 0F 07 ; Jump to subroutine long $070F07.l [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$40.b		; A0 40 ; Load #$40.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $50, $A0		; 50 A0 ; Branch if overflow clear to $50, $A0 [Flow: branch]
	.db $90, $E0		; 90 E0 ; Branch if carry clear to $90, $E0 [Flow: branch]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	jsr ($FE20.w,X)		; FC 20 FE ; Jump to subroutine indirect indexed ($FE20.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $60C0.w		; AC C0 60 ; Load $60C0.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	sbc ($F3.b)		; F2 F3 ; Subtract with carry (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $5B.b		; 04 5B ; Test and set bits $5B.b [Reads: Accumulator] [Flags: Z]
	ora ($3B.b)		; 12 3B ; OR accumulator with memory (indirect) ($3B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b,X		; 16 04 ; Arithmetic shift left $04.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $2CE000.l		; 22 00 E0 2C ; Jump to subroutine long $2CE000.l [Writes: Stack Pointer] [Flow: call]
	ora $3D6D3B.l,X		; 1F 3B 6D 3D ; Logical OR long $3D6D3B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $CC00.w		; 0D 00 CC ; Logical OR $CC00.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $76.b		; 24 76 ; Test bits $76.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $50, $F4		; 50 F4 ; Branch if overflow clear to $50, $F4 [Flow: branch]
	.db $90, $DA		; 90 DA ; Branch if carry clear to $90, $DA [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jmp ($C040.w)		; 6C 40 C0 ; Jump indirect to ($C040.w) [Flow: jump]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $AEDA.w,X		; FE DA AE ; Increment memory $AEDA.w,X [Reads: X Index] [Flags: ZN]
	jmp ($AC56.w)		; 6C 56 AC ; Jump indirect to ($AC56.w) [Flow: jump]
	cpy #$71.b		; C0 71 ; Compare #$71.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $36,$FF		; 44 FF 36 ; Move block positive $36,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	adc [$05.b],Y		; 77 05 ; Add with carry (long indexed) [$05.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$04.b],Y		; 17 04 ; OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $7F1400.l		; 22 00 14 7F ; Jump to subroutine long $7F1400.l [Writes: Stack Pointer] [Flow: call]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	cmp #$1B7A.w		; C9 7A 1B ; Compare #$1B7A.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	ora $0006.w,X		; 1D 06 00 ; OR accumulator with memory $0006.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec $3D00.w		; CE 00 3D ; Decrement $3D00.w [Flags: ZN]
	tsb $F7.b		; 04 F7 ; Test and set bits $F7.b [Reads: Accumulator] [Flags: Z]
	jsl $9C84EE.l		; 22 EE 84 9C ; Jump to subroutine long $9C84EE.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $F0		; 90 F0 ; Branch if carry clear to $90, $F0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $39E000.l		; 22 00 E0 39 ; Jump to subroutine long $39E000.l [Writes: Stack Pointer] [Flow: call]
	inc $DDFB.w,X		; FE FB DD ; Increment memory $DDFB.w,X [Reads: X Index] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	jmp ($6090.w)		; 6C 90 60 ; Jump indirect to ($6090.w) [Flow: jump]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $1B2C1B.l		; 2F 1B 2C 1B ; AND accumulator with memory (long) $1B2C1B.l [Writes: Accumulator] [Flags: ZN]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $3F03.w,X		; 3C 03 3F ; Test bits $3F03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsb $0B2F.w		; 0C 2F 0B ; Test and set bits $0B2F.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $13282B.l,X		; 7F 2B 28 13 ; Add long $13282B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $0023.w		; 1C 23 00 ; Test and reset bits $0023.w [Reads: Accumulator] [Flags: Z]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($34D8.w,X)		; FC D8 34 ; Jump to subroutine indirect indexed ($34D8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cld		; D8 ; Clear decimal flag [Flags: D]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	cpy #$DC.b		; C0 DC ; Compare #$DC.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $32		; 10 32 ; Branch if plus to $10, $32 [Flow: branch]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$C814]		; DC 14 C8 ; Jump long indirect [$C814] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx $C0.b		; E4 C0 ; Compare $C0.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $0B.b,X		; 34 0B ; Test bits $0B.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $4F03.w,X		; 3C 03 4F ; Test bits $4F03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc [$2F.b]		; 67 2F ; Add with carry (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $2C1023.l		; 2F 23 10 2C ; AND accumulator with memory (long) $2C1023.l [Writes: Accumulator] [Flags: ZN]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $4318.w,X		; FE 18 43 ; Increment memory $4318.w,X [Reads: X Index] [Flags: ZN]
	jsr ($E008.w,X)		; FC 08 E0 ; Jump to subroutine indirect indexed ($E008.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and #$18E4.w		; 29 E4 18 ; Logical AND #$18E4.w with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $3CD0.w		; 2C D0 3C ; Test bits $3CD0.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cpy #$F1.b		; C0 F1 ; Compare #$F1.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $C2		; 10 C2 ; Branch if plus to $10, $C2 [Flow: branch]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($C4FC.w,X)		; FC FC C4 ; Jump to subroutine indirect indexed ($C4FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $C0.b,X		; 34 C0 ; Test bits $C0.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $44C6.w		; 20 C6 44 ; Jump to subroutine at $44C6.w [Writes: Stack Pointer] [Flow: call]
	inc $7D6C.w		; EE 6C 7D ; Increment $7D6C.w [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $3F34.w,X		; 7D 34 3F ; Add $3F34.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $000E.w		; 0E 0E 00 ; Arithmetic shift left $000E.w [Flags: ZNC]
	.db $30, $5C		; 30 5C ; Branch if minus to $30, $5C [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	sta ($47.b)		; 92 47 ; Store accumulator (indirect) ($47.b) [Reads: Accumulator, Direct Page]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sta $8366.w,Y		; 99 66 83 ; Store accumulator to $8366.w,Y [Reads: Accumulator, Y Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda $4266.w,X		; BD 66 42 ; Load $4266.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $4299.w,Y		; 99 99 42 ; Store accumulator to $4299.w,Y [Reads: Accumulator, Y Index]
	bit $8400.w,X		; 3C 00 84 ; Test bits $8400.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	lda $8442.w,X		; BD 42 84 ; Load $8442.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda $42.b		; A5 42 ; Load $42.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $03.b		; 84 03 ; Store Y register to $03.b [Reads: Y Index]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx $8E50.w		; AE 50 8E ; Load $8E50.w into X register [Writes: X Index] [Flags: ZN]
	.db $70, $96		; 70 96 ; Branch if overflow set to $70, $96 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($60.b,S),Y		; 13 60 ; OR accumulator (stack relative indirect indexed) ($60.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sty $8C.b,X		; 94 8C ; Store Y register $8C.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	stx $60.b,Y		; 96 60 ; Store X register $60.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	jsl $20E000.l		; 22 00 E0 20 ; Jump to subroutine long $20E000.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $04		; 30 04 ; Branch if minus to $30, $04 [Flow: branch]
	asl $0044.w		; 0E 44 00 ; Arithmetic shift left $0044.w [Flags: ZNC]
	bit $6200.w,X		; 3C 00 62 ; Test bits $6200.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jsr $76F7.w		; 20 F7 76 ; Jump to subroutine at $76F7.w [Writes: Stack Pointer] [Flow: call]
	sbc $186618.l,X		; FF 18 66 18 ; Subtract with carry (long,X) $186618.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
.ACCU 16
.INDEX 16
	rep #$7C		; C2 7C
	sbc $1C7E66.l,X		; FF 66 7E 1C ; Subtract with carry (long,X) $1C7E66.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $895E.w,X		; 3C 5E 89 ; Test bits $895E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta ($3C.b,X)		; 81 3C ; Store accumulator ($3C.b,X) [Reads: Accumulator, X Index, Direct Page]
	ldx $7ABD.w,Y		; BE BD 7A ; Load X register $7ABD.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $030200.l		; 22 00 02 03 ; Jump to subroutine long $030200.l [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $64.b,S		; 83 64 ; Store accumulator (stack relative) $64.b,S [Reads: Accumulator, Stack Pointer]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	brk $CB.b		; 00 CB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FB.b,X		; 75 FB ; Add $FB.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b,X		; 35 FF ; Logical AND $FF.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $FBD8.w,Y		; 39 D8 FB ; AND accumulator with memory $FBD8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sbc $0600.w,Y		; F9 00 06 ; Subtract with carry $0600.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	adc $E7.b,X		; 75 E7 ; Add $E7.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $FE.b		; E4 FE ; Compare $FE.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $002FE0.l,X		; FF E0 2F 00 ; Subtract with carry (long,X) $002FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $7E05.w,X		; FE 05 7E ; Increment memory $7E05.w,X [Reads: X Index] [Flags: ZN]
	ora $7F133F.l		; 0F 3F 13 7F ; OR accumulator with memory (long) $7F133F.l [Writes: Accumulator] [Flags: ZN]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F0F.w,X		; 1D 0F 1F ; OR accumulator with memory $1F0F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000077.l,X		; 1F 77 00 00 ; Logical OR long $000077.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $00F300.l		; 22 00 F3 00 ; Jump to subroutine long $00F300.l [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $10, $7F		; 10 7F ; Branch if plus to $10, $7F [Flow: branch]
	ldy #$709E.w		; A0 9E 70 ; Load #$709E.w into Y register [Writes: Y Index] [Flags: ZN]
	bit $7EC8.w,X		; 3C C8 7E ; Test bits $7EC8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $0023.w		; EE 23 00 ; Increment $0023.w [Flags: ZN]
	cpx #$012B.w		; E0 2B 01 ; Compare #$012B.w with X register [Reads: X Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00003F.l		; 0F 3F 00 00 ; OR accumulator with memory (long) $00003F.l [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($7880.w,X)		; 7C 80 78 ; Jump indirect indexed to ($7880.w,X) [Reads: X Index] [Flow: jump]
	cpy $F0.b		; C4 F0 ; Compare $F0.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	sty $58E4.w		; 8C E4 58 ; Store Y register to $58E4.w [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	.db $F0, $E4		; F0 E4 ; Branch if equal to $F0, $E4 [Flow: branch]
	cpy $83FC.w		; CC FC 83 ; Compare $83FC.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $C3.b,S		; 03 C3 ; OR accumulator with stack relative $C3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $CF.b		; 04 CF ; Test and set bits $CF.b [Reads: Accumulator] [Flags: Z]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $0B07.w,X		; FE 07 0B ; Increment memory $0B07.w,X [Reads: X Index] [Flags: ZN]
	adc $0F7F0B.l,X		; 7F 0B 7F 0F ; Add long $0F7F0B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $7F1B0F.l,X		; 1F 0F 1B 7F ; Logical OR long $7F1B0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $18.b,S		; 83 18 ; Store accumulator (stack relative) $18.b,S [Reads: Accumulator, Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3320C3.l		; 2F C3 20 33 ; AND accumulator with memory (long) $3320C3.l [Writes: Accumulator] [Flags: ZN]
	cpy #$A05F.w		; C0 5F A0 ; Compare #$A05F.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $B05E00.l,X		; FF 00 5E B0 ; Subtract with carry (long,X) $B05E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $00F0.w,Y		; BE F0 00 ; Load X register $00F0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $B8		; F0 B8 ; Branch if equal to $F0, $B8 [Flow: branch]
	.db $10, $B8		; 10 B8 ; Branch if plus to $10, $B8 [Flow: branch]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1D3F05.l,X		; 1F 05 3F 1D ; Logical OR long $1D3F05.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$16.b],Y		; 37 16 ; AND accumulator with memory (long indexed) [$16.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $0C4F2A.l		; 6F 2A 4F 0C ; Add with carry (long) $0C4F2A.l [Writes: Accumulator] [Flags: ZVNC]
	adc $070029.l		; 6F 29 00 07 ; Add with carry (long) $070029.l [Writes: Accumulator] [Flags: ZVNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	jsl $735529.l		; 22 29 55 73 ; Jump to subroutine long $735529.l [Writes: Stack Pointer] [Flow: call]
	eor [$7E.b],Y		; 57 7E ; Exclusive OR accumulator with memory (long indexed) [$7E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $44		; 42 44 ; Reserved instruction
	sbc $C30381.l,X		; FF 81 03 C3 ; Subtract with carry (long,X) $C30381.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $45FF7E.l,X		; FF 7E FF 45 ; Subtract with carry (long,X) $45FF7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $047E.w,X		; BD 7E 04 ; Load $047E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $813C.w,X		; 7E 3C 81 ; Rotate right $813C.w,X [Reads: X Index] [Flags: ZNC]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta [$92.b]		; 87 92 ; Store accumulator (long) [$92.b] [Reads: Accumulator, Direct Page]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0C4F0A.l		; 2F 0A 4F 0C ; AND accumulator with memory (long) $0C4F0A.l [Writes: Accumulator] [Flags: ZN]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$0300.w		; A0 00 03 ; Load #$0300.w into Y register [Writes: Y Index] [Flags: ZN]
	and $73.b,X		; 35 73 ; Logical AND $73.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $A8.b,S		; 83 A8 ; Store accumulator (stack relative) $A8.b,S [Reads: Accumulator, Stack Pointer]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $B18481.l,X		; FF 81 84 B1 ; Subtract with carry (long,X) $B18481.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F800.w		; E0 00 F8 ; Compare #$F800.w with X register [Reads: X Index] [Flags: ZNC]
	ldy #$B8FC.w		; A0 FC B8 ; Load #$B8FC.w into Y register [Writes: Y Index] [Flags: ZN]
	cpx $F468.w		; EC 68 F4 ; Compare $F468.w with X register [Reads: X Index] [Flags: ZNC]
	.db $50, $F2		; 50 F2 ; Branch if overflow clear to $50, $F2 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	mvp $AC,$94		; 44 94 AC ; Move block positive $AC,$94 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	dec $0023.w		; CE 23 00 ; Decrement $0023.w [Flags: ZN]
	sta $34.b,S		; 83 34 ; Store accumulator (stack relative) $34.b,S [Reads: Accumulator, Stack Pointer]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C1F01.l		; 0F 01 1F 0C ; OR accumulator with memory (long) $0C1F01.l [Writes: Accumulator] [Flags: ZN]
	and ($12.b,S),Y		; 33 12 ; AND accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$16.b],Y		; 37 16 ; AND accumulator with memory (long indexed) [$16.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2D13.w		; 0E 13 2D ; Arithmetic shift left $2D13.w [Flags: ZNC]
	and #$D885.w		; 29 85 D8 ; Logical AND #$D885.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E38C81.l,X		; FF 81 8C E3 ; Subtract with carry (long,X) $E38C81.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $24.b,X		; 16 24 ; Arithmetic shift left $24.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and [$2F.b],Y		; 37 2F ; AND accumulator with memory (long indexed) [$2F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and #$0500.w		; 29 00 05 ; Logical AND #$0500.w with accumulator [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($24C8.w,X)		; FC C8 24 ; Jump to subroutine indirect indexed ($24C8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b,X		; 36 18 ; Rotate left $18.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jsr ($7F3C.w,X)		; FC 3C 7F ; Jump to subroutine indirect indexed ($7F3C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr $113F.w		; 20 3F 11 ; Jump to subroutine at $113F.w [Writes: Stack Pointer] [Flow: call]
	asl $1C0E.w,X		; 1E 0E 1C ; Arithmetic shift left $1C0E.w,X [Reads: X Index] [Flags: ZNC]
	tsb $0C1E.w		; 0C 1E 0C ; Test and set bits $0C1E.w [Reads: Accumulator] [Flags: Z]
	ora $000707.l		; 0F 07 07 00 ; OR accumulator with memory (long) $000707.l [Writes: Accumulator] [Flags: ZN]
	adc $51.b,S		; 63 51 ; Add with carry (stack relative) $51.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	rol $1311.w		; 2E 11 13 ; Rotate left $1311.w [Flags: ZNC]
	ora ($08.b,S),Y		; 13 08 ; OR accumulator (stack relative indirect indexed) ($08.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$7E.b]		; 07 7E ; OR accumulator with memory (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $80, $F6		; 80 F6 ; Branch always to $80, $F6 [Flow: branch]
	tsb $EC.b		; 04 EC ; Test and set bits $EC.b [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $58		; 10 58 ; Branch if plus to $10, $58 [Flow: branch]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: ZNC]
	dec $749A.w		; CE 9A 74 ; Decrement $749A.w [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	eor $088F12.l,X		; 5F 12 8F 08 ; Exclusive OR accumulator with memory (long,X) $088F12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $E7.b,S		; 43 E7 ; Exclusive OR accumulator with stack relative $E7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	mvp $33,$E0		; 44 E0 33 ; Move block positive $33,$E0 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sbc ($61.b,X)		; E1 61 ; Subtract with carry ($61.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $003F0F.l,X		; 3F 0F 3F 00 ; AND accumulator with memory (long,X) $003F0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($B8F0.w)		; 6C F0 B8 ; Jump indirect to ($B8F0.w) [Flow: jump]
	tyx		; [PATTERN: Memory clearing operation] BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	stz $3044.w,X		; 9E 44 30 ; Store zero to $3044.w,X [Reads: X Index]
	ora $FE20FC.l		; 0F FC 20 FE ; OR accumulator with memory (long) $FE20FC.l [Writes: Accumulator] [Flags: ZN]
	tsb $0CCE.w		; 0C CE 0C ; Test and set bits $0CCE.w [Reads: Accumulator] [Flags: Z]
	stz $9C1C.w,X		; 9E 1C 9C ; Store zero to $9C1C.w,X [Reads: X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($F838.w,X)		; FC 38 F8 ; Jump to subroutine indirect indexed ($F838.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($F2.b)		; 72 F2 ; Add with carry (indirect) ($F2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
.ACCU 8
	sep #$64		; E2 64
	cpy $78.b		; C4 78 ; Compare $78.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	cpy #$133F.w		; C0 3F 13 ; Compare #$133F.w with Y register [Reads: Y Index] [Flags: ZNC]
	adc $3B7B3C.l,X		; 7F 3C 7B 3B ; Add long $3B7B3C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($7E3C.w,X)		; 7C 3C 7E ; Jump indirect indexed to ($7E3C.w,X) [Reads: X Index] [Flow: jump]
	rol $0F3F.w		; 2E 3F 0F ; Rotate left $0F3F.w [Flags: ZNC]
	sta $8C.b,S		; 83 8C ; Store accumulator (stack relative) $8C.b,S [Reads: Accumulator, Stack Pointer]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $434443.l		; 2F 43 44 43 ; AND accumulator with memory (long) $434443.l [Writes: Accumulator] [Flags: ZN]
	eor ($30.b),Y		; 51 30 ; Exclusive OR accumulator with memory ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$FC.b]		; 07 FC ; OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	inc $CE2C.w		; EE 2C CE ; Increment $CE2C.w [Flags: ZN]
	cpy $0C0E.w		; CC 0E 0C ; Compare $0C0E.w with Y register [Reads: Y Index] [Flags: ZNC]
	rol $9C34.w,X		; 3E 34 9C ; Rotate left $9C34.w,X [Reads: X Index] [Flags: ZNC]
	.db $90, $83		; 90 83 ; Branch if carry clear to $90, $83 [Flow: branch]
	ldy $01.b		; A4 01 ; Load $01.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	cpx #$F42F.w		; E0 2F F4 ; Compare #$F42F.w with X register [Reads: X Index] [Flags: ZNC]
	cmp ($32.b)		; D2 32 ; Compare accumulator (indirect) ($32.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc ($CA.b)		; F2 CA ; Subtract with carry (indirect) ($CA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($E010.w)		; 6C 10 E0 ; Jump indirect to ($E010.w) [Flow: jump]
	adc $0A3531.l,X		; 7F 31 35 0A ; Add long $0A3531.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $0306.w,X		; 1E 06 03 ; Arithmetic shift left $0306.w,X [Reads: X Index] [Flags: ZNC]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($BD.b,X)		; 01 BD ; Logical OR ($BD.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $7E3CE7.l,X		; FF E7 3C 7E ; Subtract with carry (long,X) $7E3CE7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $42, $FF		; 42 FF ; Reserved instruction
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $E7.b,S		; C3 E7 ; Compare accumulator (stack relative) $E7.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $18BD1E.l,X		; FF 1E BD 18 ; Subtract with carry (long,X) $18BD1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$24.b]		; E7 24 ; Subtract with carry (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$4F.b]		; E7 4F ; Subtract with carry (long) [$4F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora #$6F.b		; 09 6F ; Logical OR #$6F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $10, $1D		; 10 1D ; Branch if plus to $10, $1D [Flow: branch]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0701.w		; 0D 01 07 ; Logical OR $0701.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$2B.b],Y		; 57 2B ; Exclusive OR accumulator with memory (long indexed) [$2B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b,S),Y		; 13 1F ; OR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0307.w		; 0E 07 03 ; Arithmetic shift left $0307.w [Flags: ZNC]
	ror $85BD.w,X		; 7E BD 85 ; Rotate right $85BD.w,X [Reads: X Index] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A3FF43.l,X		; FF 43 FF A3 ; Subtract with carry (long,X) $A3FF43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $40.b,S		; E3 40 ; Subtract stack-relative $40.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cpx #$C300.w		; E0 00 C3 ; Compare #$C300.w with X register [Reads: X Index] [Flags: ZNC]
	jsl $BC10FF.l		; 22 FF 10 BC ; Jump to subroutine long $BC10FF.l [Writes: Stack Pointer] [Flow: call]
	jmp $F2E0A3.l		; 5C A3 E0 F2 ; Jump long to $F2E0A3.l [Flow: jump]
	.db $B0, $F6		; B0 F6 ; Branch if carry set to $B0, $F6 [Flow: branch]
	sty $FC.b,X		; 94 FC ; Store Y register $FC.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clv		; B8 ; Clear overflow flag [Flags: V]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $CE1F00.l		; 22 00 1F CE ; Jump to subroutine long $CE1F00.l [Writes: Stack Pointer] [Flow: call]
	nop		; EA ; No operation
	pei ($C8.b)		; D4 C8 ; Push effective indirect address ($C8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	adc $0C2F2D.l		; 6F 2D 2F 0C ; Add with carry (long) $0C2F2D.l [Writes: Accumulator] [Flags: ZVNC]
	and [$04.b]		; 27 04 ; AND accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $043B01.l,X		; 1F 01 3B 04 ; Logical OR long $043B01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $55.b		; 00 55 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($33.b,S),Y		; 53 33 ; XOR accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $2627.w,X		; 1E 27 26 ; Arithmetic shift left $2627.w,X [Reads: X Index] [Flags: ZNC]
	ora $025888.l,X		; 1F 88 58 02 ; Logical OR long $025888.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$81.b]		; 07 81 ; OR accumulator with memory (long) [$81.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $80E060.l,X		; FF 60 E0 80 ; Subtract with carry (long,X) $80E060.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$C300.w		; C0 00 C3 ; Compare #$C300.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $7E03FF.l		; 22 FF 03 7E ; Jump to subroutine long $7E03FF.l [Writes: Stack Pointer] [Flow: call]
	sta $37C060.l,X		; 9F 60 C0 37 ; Store accumulator (long,X) $37C060.l,X [Reads: Accumulator, X Index]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$0D.b],Y		; 37 0D ; AND accumulator with memory (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $001C0D.l,X		; 3F 0D 1C 00 ; AND accumulator with memory (long,X) $001C0D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $1F00.w,X		; 1E 00 1F ; Arithmetic shift left $1F00.w,X [Reads: X Index] [Flags: ZNC]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $131F.w,X		; 3E 1F 13 ; Rotate left $131F.w,X [Reads: X Index] [Flags: ZNC]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $4307.w		; 0E 07 43 ; Arithmetic shift left $4307.w [Flags: ZNC]
	jmp ($1368.w,X)		; 7C 68 13 ; Jump indirect indexed to ($1368.w,X) [Reads: X Index] [Flow: jump]
	inc $DC.b,X		; F6 DC ; Increment memory $DC.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	inc $BC.b		; E6 BC ; Increment $BC.b [Reads: Direct Page] [Flags: ZN]
	jsr ($F858.w,X)		; FC 58 F8 ; Jump to subroutine indirect indexed ($F858.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	cpy #$00E0.w		; C0 E0 00 ; Compare #$00E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	stz $3E9C.w		; 9C 9C 3E ; Store zero to $3E9C.w
	ror $F8BC.w,X		; 7E BC F8 ; Rotate right $F8BC.w,X [Reads: X Index] [Flags: ZNC]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sta $5A.b		; 85 5A ; Store accumulator to $5A.b [Reads: Accumulator]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and [$2F.b],Y		; 37 2F ; AND accumulator with memory (long indexed) [$2F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sta $72.b		; 85 72 ; Store accumulator to $72.b [Reads: Accumulator]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($293C.w,X)		; FC 3C 29 ; Jump to subroutine indirect indexed ($293C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	and $013910.l		; 2F 10 39 01 ; AND accumulator with memory (long) $013910.l [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00293E.l,X		; 3F 3E 29 00 ; AND accumulator with memory (long,X) $00293E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $70.b		; 05 70 ; Logical OR $70.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $B0, $24		; B0 24 ; Branch if carry set to $B0, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1637.w		; 0C 37 16 ; Test and set bits $1637.w [Reads: Accumulator] [Flags: Z]
	adc $0A4F29.l		; 6F 29 4F 0A ; Add with carry (long) $0A4F29.l [Writes: Accumulator] [Flags: ZVNC]
	adc $00002C.l		; 6F 2C 00 00 ; Add with carry (long) $00002C.l [Writes: Accumulator] [Flags: ZVNC]
	tsb $2912.w		; 0C 12 29 ; Test and set bits $2912.w [Reads: Accumulator] [Flags: Z]
	eor [$75.b],Y		; 57 75 ; Exclusive OR accumulator with memory (long indexed) [$75.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor ($27.b,S),Y		; 53 27 ; XOR accumulator (stack relative indirect indexed) ($27.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $8300.w,X		; 7E 00 83 ; Rotate right $8300.w,X [Reads: X Index] [Flags: ZNC]
	lda ($00.b)		; B2 00 ; Load accumulator (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($BD.b,X)		; 01 BD ; Logical OR ($BD.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp $23.b,S		; C3 23 ; Compare accumulator (stack relative) $23.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $C381.w,X		; 7E 81 C3 ; Rotate right $C381.w,X [Reads: X Index] [Flags: ZNC]
	sbc $070027.l,X		; FF 27 00 07 ; Subtract with carry (long,X) $070027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $3700.w,X		; 1E 00 37 ; Arithmetic shift left $3700.w,X [Reads: X Index] [Flags: ZNC]
	asl $6F.b,X		; 16 6F ; Arithmetic shift left $6F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and $084F.w		; 2D 4F 08 ; Logical AND $084F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and #$53.b		; 29 53 ; Logical AND #$53.b with accumulator [Writes: Accumulator] [Flags: ZN]
	adc [$29.b],Y		; 77 29 ; Add with carry (long indexed) [$29.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $7E.b		; 02 7E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($C3.b,X)		; 81 C3 ; Store accumulator ($C3.b,X) [Reads: Accumulator, X Index, Direct Page]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$78.b]		; 07 78 ; OR accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	inc $B4.b,X		; F6 B4 ; Increment memory $B4.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc ($10.b)		; F2 10 ; Subtract with carry (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sty $CA.b,X		; 94 CA ; Store Y register $CA.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	inc $0038.w		; EE 38 00 ; Increment $0038.w [Flags: ZN]
	bit $7C00.w,X		; 3C 00 7C ; Test bits $7C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	lsr $5F18.w,X		; 5E 18 5F ; Logical shift right $5F18.w,X [Reads: X Index] [Flags: ZNC]
	asl $0E2F.w,X		; 1E 2F 0E ; Arithmetic shift left $0E2F.w,X [Reads: X Index] [Flags: ZNC]
	and $011F0D.l		; 2F 0D 1F 01 ; AND accumulator with memory (long) $011F0D.l [Writes: Accumulator] [Flags: ZN]
	jsr $443C.w		; 20 3C 44 ; Jump to subroutine at $443C.w [Writes: Stack Pointer] [Flow: call]
	ror $61.b		; 66 61 ; Rotate right $61.b [Reads: Direct Page] [Flags: ZNC]
	and ($33.b),Y		; 31 33 ; AND accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $070027.l,X		; 1F 27 00 07 ; Logical OR long $070027.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $DF00.w,X		; FE 00 DF ; Increment memory $DF00.w,X [Reads: X Index] [Flags: ZN]
	ror $FF8D.w,X		; 7E 8D FF ; Rotate right $FF8D.w,X [Reads: X Index] [Flags: ZNC]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Accumulator, X Index, Direct Page]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3883FF.l		; 22 FF 83 38 ; Jump to subroutine long $3883FF.l [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp ($004A.w,X)		; 7C 4A 00 ; Jump indirect indexed to ($004A.w,X) [Reads: X Index] [Flow: jump]
	inc $0002.w,X		; FE 02 00 ; Increment memory $0002.w,X [Reads: X Index] [Flags: ZN]
	.db $10, $6C		; 10 6C ; Branch if plus to $10, $6C [Flow: branch]
	bit $AA.b		; 24 AA ; Test bits $AA.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $3F,$00		; 44 00 3F ; Move block positive $3F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $3F,$00		; 44 00 3F ; Move block positive $3F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora #$1F.b		; 09 1F ; Logical OR #$1F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $403F20.l,X		; 1F 20 3F 40 ; Logical OR long $403F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $371F20.l,X		; 3F 20 1F 37 ; AND accumulator with memory (long,X) $371F20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; [PATTERN: Memory clearing operation] 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $E2.b		; 64 E2 ; Store zero to $E2.b
	stz $38.b,X		; 74 38 ; Store zero to $38.b,X [Reads: X Index]
	mvn $6C,$BA		; 54 BA 6C ; Move block negative $6C,$BA [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sta $18.b,S		; 83 18 ; Store accumulator (stack relative) $18.b,S [Reads: Accumulator, Stack Pointer]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00E100.l,X		; FF 00 E1 00 ; Subtract with carry (long,X) $00E100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $005700.l		; 8F 00 57 00 ; Store accumulator (long) $005700.l [Reads: Accumulator]
	jsl $220000.l		; 22 00 00 22 ; Jump to subroutine long $220000.l [Writes: Stack Pointer] [Flow: call]
	eor $8B.b,X		; 55 8B ; Exclusive OR accumulator with memory $8B.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	stz $75FB.w,X		; 9E FB 75 ; Store zero to $75FB.w,X [Reads: X Index]
	jsl $02D08A.l		; 22 8A D0 02 ; Jump to subroutine long $02D08A.l [Writes: Stack Pointer] [Flow: call]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta $E0.b		; 85 E0 ; Store accumulator to $E0.b [Reads: Accumulator]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0000.w,X		; 3E 00 00 ; Rotate left $0000.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($7E68.w,X)		; 7C 68 7E ; Jump indirect indexed to ($7E68.w,X) [Reads: X Index] [Flow: jump]
	jmp ($C4FE.w)		; 6C FE C4 ; Jump indirect to ($C4FE.w) [Flow: jump]
	inc $CE98.w,X		; FE 98 CE ; Increment memory $CE98.w,X [Reads: X Index] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $189E.w		; 0C 9E 18 ; Test and set bits $189E.w [Reads: Accumulator] [Flags: Z]
	jmp ($9C00.w,X)		; 7C 00 9C ; Jump indirect indexed to ($9C00.w,X) [Reads: X Index] [Flow: jump]
	stz $663E.w,X		; 9E 3E 66 ; Store zero to $663E.w,X [Reads: X Index]
	inc $E6F2.w,X		; FE F2 E6 ; Increment memory $E6F2.w,X [Reads: X Index] [Flags: ZN]
	jmp ($0363.w,X)		; 7C 63 03 ; Jump indirect indexed to ($0363.w,X) [Reads: X Index] [Flow: jump]
	sbc $18FF0F.l		; EF 0F FF 18 ; Subtract with carry (long) $18FF0F.l [Writes: Accumulator] [Flags: ZVNC]
	adc $113D04.l,X		; 7F 04 3D 11 ; Add long $113D04.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $0E4F0D.l,X		; 7F 0D 4F 0E ; Add long $0E4F0D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $7C00.w,X		; 3E 00 7C ; Rotate left $7C00.w,X [Reads: X Index] [Flags: ZNC]
	.db $B0, $A7		; B0 A7 ; Branch if carry set to $B0, $A7 [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $7172.w,X		; 3E 72 71 ; Rotate left $7172.w,X [Reads: X Index] [Flags: ZNC]
	rol $B0F8.w,X		; 3E F8 B0 ; Rotate left $B0F8.w,X [Reads: X Index] [Flags: ZNC]
	cpy $DC78.w		; CC 78 DC ; Compare $DC78.w with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldx $FEE4.w,Y		; BE E4 FE ; Load X register $FEE4.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	jmp $8080FC.l		; 5C FC 80 80 ; Jump long to $8080FC.l [Flow: jump]
	jsl $781C00.l		; 22 00 1C 78 ; Jump to subroutine long $781C00.l [Writes: Stack Pointer] [Flow: call]
	jsr ($FAFC.w,X)		; FC FC FA ; Jump to subroutine indirect indexed ($FAFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
.ACCU 8
.INDEX 8
	sep #$7C		; E2 7C
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	and $011F19.l,X		; 3F 19 1F 01 ; AND accumulator with memory (long,X) $011F19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and [$1F.b]		; 27 1F ; AND accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sty $B2.b		; 84 B2 ; Store Y register to $B2.b [Reads: Y Index]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $B0		; 42 B0 ; Reserved instruction
	ldy #$E0.b		; A0 E0 ; Load #$E0.b into Y register [Writes: Y Index] [Flags: ZN]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BC7E0D.l,X		; FF 0D 7E BC ; Subtract with carry (long,X) $BC7E0D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	cpx #$47.b		; E0 47 ; Compare #$47.b with X register [Reads: X Index] [Flags: ZNC]
	ora $6F.b		; 05 6F ; Logical OR $6F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $1A3F.w		; 2D 3F 1A ; Logical AND $1A3F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $260301.l,X		; 1F 01 03 26 ; Logical OR long $260301.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($25.b,S),Y		; 53 25 ; XOR accumulator (stack relative indirect indexed) ($25.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $2203.w,X		; 1E 03 22 ; Arithmetic shift left $2203.w,X [Reads: X Index] [Flags: ZNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $81C3.w,X		; BD C3 81 ; Load $81C3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FFFEC3.l,X		; FF C3 FE FF ; Subtract with carry (long,X) $FFFEC3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $3BFF.w,X		; 7D FF 3B ; Add $3BFF.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $0700.w,X		; 7E 00 07 ; Rotate right $0700.w,X [Reads: X Index] [Flags: ZNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FE25E0.l,X		; FF E0 25 FE ; Subtract with carry (long,X) $FE25E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($047F.w,X)		; FC 7F 04 ; Jump to subroutine indirect indexed ($047F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$E2.b]		; 07 E2 ; OR accumulator with memory (long) [$E2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy #$F6.b		; A0 F6 ; Load #$F6.b into Y register [Writes: Y Index] [Flags: ZN]
	ldy $FC.b,X		; B4 FC ; Load Y register $FC.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $C000.w		; 20 00 C0 ; Jump to subroutine at $C000.w [Writes: Stack Pointer] [Flow: call]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx $78.b		; E4 78 ; Compare $78.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	ldy #$20.b		; A0 20 ; Load #$20.b into Y register [Writes: Y Index] [Flags: ZN]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: ZNC]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($FE.b,X)		; C1 FE ; Compare accumulator ($FE.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc $FF.b,S		; E3 FF ; Subtract stack-relative $FF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc $BEFF7F.l,X		; FF 7F FF BE ; Subtract with carry (long,X) $BEFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $1D18.w,X		; FE 18 1D ; Increment memory $1D18.w,X [Reads: X Index] [Flags: ZN]
	ora $83.b		; 05 83 ; Logical OR $83.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $05.b,X		; 34 05 ; Test bits $05.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	jsl $7F08FF.l		; 22 FF 08 7F ; Jump to subroutine long $7F08FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $07041A.l,X		; FF 1A 04 07 ; Subtract with carry (long,X) $07041A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	mvp $28,$54		; 44 54 28 ; Move block positive $28,$54 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $28.b,S		; 43 28 ; Exclusive OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	jmp ($5410.w)		; 6C 10 54 ; Jump indirect to ($5410.w) [Flow: jump]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	mvp $38,$38		; 44 38 38 ; Move block positive $38,$38 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($3838.w)		; 6C 38 38 ; Jump indirect to ($3838.w) [Flow: jump]
	jmp ($4454.w,X)		; 7C 54 44 ; Jump indirect indexed to ($4454.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	lsr $B980.w		; 4E 80 B9 ; Logical shift right $B980.w [Flags: ZNC]
	lsr $C5.b		; 46 C5 ; Logical shift right $C5.b [Reads: Direct Page] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	lda $4E46.w,Y		; B9 46 4E ; Load $4E46.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $D3.b,S		; 83 D3 ; Store accumulator (stack relative) $D3.b,S [Reads: Accumulator, Stack Pointer]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	.db $80, $CE		; 80 CE ; Branch always to $80, $CE [Flow: branch]
	adc $793D.w,Y		; 79 3D 79 ; Add $793D.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $3780.w		; CE 80 37 ; Decrement $3780.w [Flags: ZN]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0750E0.l,X		; FF E0 50 07 ; Subtract with carry (long,X) $0750E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $5F3F4F.l,X		; 1F 4F 3F 5F ; Logical OR long $5F3F4F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda $6BBF74.l,X		; BF 74 BF 6B ; Load long $6BBF74.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldx $0768.w,Y		; BE 68 07 ; Load X register $0768.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ora $7F7F3F.l,X		; 1F 3F 7F 7F ; Logical OR long $7F7F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	pea $C0F3.w		; F4 F3 C0 ; Push absolute address $C0F3.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C8.b		; C0 C8 ; Compare #$C8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FC98.w,X)		; FC 98 FC ; Jump to subroutine indirect indexed ($FC98.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy $7A90.w,X		; BC 90 7A ; Load Y register $7A90.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $10, $C0		; 10 C0 ; Branch if plus to $10, $C0 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($9CFC.w,X)		; FC FC 9C ; Jump to subroutine indirect indexed ($9CFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp ($07CE.w)		; 6C CE 07 ; Jump indirect to ($07CE.w) [Flow: jump]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3F173F.l		; 0F 3F 17 3F ; OR accumulator with memory (long) $3F173F.l [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $133F03.l,X		; 1F 03 3F 13 ; Logical OR long $133F03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3F373F.l,X		; 1F 3F 37 3F ; Logical OR long $3F373F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $00E0.w		; 20 E0 00 ; Jump to subroutine at $00E0.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($43.b)		; B2 43 ; Load accumulator (indirect) ($43.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr ($05FA.w,X)		; FC FA 05 ; Jump to subroutine indirect indexed ($05FA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp $E008D4.l		; 5C D4 08 E0 ; Jump long to $E008D4.l [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FE23.w,X)		; FC 23 FE ; Jump to subroutine indirect indexed ($FE23.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $211F.w		; 20 1F 21 ; Jump to subroutine at $211F.w [Writes: Stack Pointer] [Flow: call]
	ora $4E3F4F.l,X		; 1F 4F 3F 4E ; Logical OR long $4E3F4F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $633F40.l,X		; 3F 40 3F 63 ; AND accumulator with memory (long,X) $633F40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $3F1F07.l,X		; 3F 07 1F 3F ; AND accumulator with memory (long,X) $3F1F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $837F23.l,X		; 3F 23 7F 83 ; AND accumulator with memory (long,X) $837F23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	.db $F0, $43		; F0 43 ; Branch if equal to $F0, $43 [Flow: branch]
	jsr ($43F8.w,X)		; FC F8 43 ; Jump to subroutine indirect indexed ($43F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FEFC.w,X)		; FC FC FE ; Jump to subroutine indirect indexed ($FEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $001F.w,X		; FE 1F 00 ; Increment memory $001F.w,X [Reads: X Index] [Flags: ZN]
	and [$83.b]		; 27 83 ; AND accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $7699.w,Y		; 39 99 76 ; AND accumulator with memory $7699.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc [$FC.b],Y		; 77 FC ; Add with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($FE.b,S),Y		; 73 FE ; Add with carry (stack relative indirect indexed) ($FE.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $FF.b,X		; 15 FF ; OR accumulator with memory $FF.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $FCF9FB.l,X		; FF FB F9 FC ; Subtract with carry (long,X) $FCF9FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FEF1.w,X)		; FC F1 FE ; Jump to subroutine indirect indexed ($FEF1.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $9F8E.w,Y		; F9 8E 9F ; Subtract with carry $9F8E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $0EE4.w,X		; 1D E4 0E ; OR accumulator with memory $0EE4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $6C		; F0 6C ; Branch if equal to $F0, $6C [Flow: branch]
	.db $90, $FC		; 90 FC ; Branch if carry clear to $90, $FC [Flow: branch]
	inc $FF22.w,X		; FE 22 FF ; Increment memory $FF22.w,X [Reads: X Index] [Flags: ZN]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $239C.w,X		; FE 9C 23 ; Increment memory $239C.w,X [Reads: X Index] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $4507.w		; 0C 07 45 ; Test and set bits $4507.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $000004.l		; 0F 04 00 00 ; OR accumulator with memory (long) $000004.l [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F1F23.l		; 0F 23 1F 0F ; OR accumulator with memory (long) $0F1F23.l [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02FFE1.l,X		; 1F E1 FF 02 ; Logical OR long $02FFE1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $C0FF01.l,X		; FF 01 FF C0 ; Subtract with carry (long,X) $C0FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $1FFF80.l,X		; 7F 80 FF 1F ; Add long $1FFF80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $7F.b		; 02 7F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0025E0.l,X		; FF E0 25 00 ; Subtract with carry (long,X) $0025E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($17.b,S),Y		; 13 17 ; OR accumulator (stack relative indirect indexed) ($17.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$25.b],Y		; 17 25 ; OR accumulator with memory (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $D0, $43		; D0 43 ; Branch if not equal to $D0, $43 [Flow: branch]
	jmp ($01D8.w,X)		; 7C D8 01 ; Jump indirect indexed to ($01D8.w,X) [Reads: X Index] [Flow: jump]
	ror $22DC.w,X		; 7E DC 22 ; Rotate right $22DC.w,X [Reads: X Index] [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $35.b		; E4 35 ; Compare $35.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $011E00.l		; 0F 00 1E 01 ; OR accumulator with memory (long) $011E00.l [Writes: Accumulator] [Flags: ZN]
	trb $2503.w		; 1C 03 25 ; Test and reset bits $2503.w [Reads: Accumulator] [Flags: Z]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b,S),Y		; 13 1F ; OR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $090025.l,X		; 3F 25 00 09 ; AND accumulator with memory (long,X) $090025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	.db $F0, $7C		; F0 7C ; Branch if equal to $F0, $7C [Flow: branch]
	.db $F0, $BC		; F0 BC ; Branch if equal to $F0, $BC [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jsl $898400.l		; 22 00 84 89 ; Jump to subroutine long $898400.l [Writes: Stack Pointer] [Flow: call]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $2C5C28.l,X		; 5F 28 5C 2C ; Exclusive OR accumulator with memory (long,X) $2C5C28.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $BE68.w,Y		; B9 68 BE ; Load $BE68.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stz $5F.b,X		; 74 5F ; Store zero to $5F.b,X [Reads: X Index]
	and $23.b,S		; 23 23 ; AND accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($71.b)		; 12 71 ; OR accumulator with memory (indirect) ($71.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc ($F7.b,S),Y		; 73 F7 ; Add with carry (stack relative indirect indexed) ($F7.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jmp ($0023.w,X)		; 7C 23 00 ; Jump indirect indexed to ($0023.w,X) [Reads: X Index] [Flow: jump]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3C		; 10 3C ; Branch if plus to $10, $3C [Flow: branch]
	.db $30, $98		; 30 98 ; Branch if minus to $30, $98 [Flow: branch]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	jsr $C0E0.w		; 20 E0 C0 ; Jump to subroutine at $C0E0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$24.b		; C0 24 ; Compare #$24.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $E8CC.w		; 8E CC E8 ; Store X register to $E8CC.w [Reads: X Index]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0040.w		; 1C 40 00 ; Test and reset bits $0040.w [Reads: Accumulator] [Flags: Z]
	and $3501.w,Y		; 39 01 35 ; AND accumulator with memory $3501.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $240E.w		; 0E 0E 24 ; Arithmetic shift left $240E.w [Flags: ZNC]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $7F.b,S		; 63 7F ; Add with carry (stack relative) $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	rol $112E.w,X		; 3E 2E 11 ; Rotate left $112E.w,X [Reads: X Index] [Flags: ZNC]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: ZNC]
	sty $08.b,X		; 94 08 ; Store Y register $08.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cpx $9EF1.w		; EC F1 9E ; Compare $9EF1.w with X register [Reads: X Index] [Flags: ZNC]
	sbc $FD1E.w,Y		; F9 1E FD ; Subtract with carry $FD1E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0C1E.w,X		; 1E 1E 0C ; Arithmetic shift left $0C1E.w,X [Reads: X Index] [Flags: ZNC]
	tsb $0022.w		; 0C 22 00 ; Test and set bits $0022.w [Reads: Accumulator] [Flags: Z]
	trb $FC.b		; 14 FC ; Test and reset bits $FC.b [Reads: Accumulator] [Flags: Z]
	asl $FF7F.w,X		; 1E 7F FF ; Arithmetic shift left $FF7F.w,X [Reads: X Index] [Flags: ZNC]
	sbc $000C1E.l,X		; FF 1E 0C 00 ; Subtract with carry (long,X) $000C1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $033F1D.l,X		; 3F 1D 3F 03 ; AND accumulator with memory (long,X) $033F1D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $633F.w		; 6D 3F 63 ; Add $633F.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	and $3F3F77.l,X		; 3F 77 3F 3F ; AND accumulator with memory (long,X) $3F3F77.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $223C.w		; 1C 3C 22 ; Test and reset bits $223C.w [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7F223F.l,X		; 3F 3F 22 7F ; AND accumulator with memory (long,X) $7F223F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3C3F.w		; 0D 3F 3C ; Logical OR $3C3F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $C8FC.w		; EC FC C8 ; Compare $C8FC.w with X register [Reads: X Index] [Flags: ZNC]
	jsr ($F888.w,X)		; FC 88 F8 ; Jump to subroutine indirect indexed ($F888.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $10, $F2		; 10 F2 ; Branch if plus to $10, $F2 [Flow: branch]
	pea $F8F4.w		; F4 F4 F8 ; Push absolute address $F8F4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $74FB40.l		; CF 40 FB 74 ; Compare accumulator (long) $74FB40.l [Reads: Accumulator] [Flags: ZNC]
	jmp ($2703.w,X)		; 7C 03 27 ; Jump indirect indexed to ($2703.w,X) [Reads: X Index] [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $0026.w		; 1C 26 00 ; Test and reset bits $0026.w [Reads: Accumulator] [Flags: Z]
	tsb $BC.b		; 04 BC ; Test and set bits $BC.b [Reads: Accumulator] [Flags: Z]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	jmp ($1C27.w,X)		; 7C 27 1C ; Jump indirect indexed to ($1C27.w,X) [Reads: X Index] [Flow: jump]
	jsl $F40C00.l		; 22 00 0C F4 ; Jump to subroutine long $F40C00.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy $3C30.w		; CC 30 3C ; Compare $3C30.w with Y register [Reads: Y Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	inc $7A38.w,X		; FE 38 7A ; Increment memory $7A38.w,X [Reads: X Index] [Flags: ZN]
	bit $62.b		; 24 62 ; Test bits $62.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	trb $223C.w		; 1C 3C 22 ; Test and reset bits $223C.w [Reads: Accumulator] [Flags: Z]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $CC.b,X		; 34 CC ; Test bits $CC.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $7AFE.w,X		; 3C FE 7A ; Test bits $7AFE.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $62, $3C, $00		; 62 3C 00 ; Push effective relative address $62, $3C, $00 [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $430E19.l		; 0F 19 0E 43 ; OR accumulator with memory (long) $430E19.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $1E03.w		; 0C 03 1E ; Test and set bits $1E03.w [Reads: Accumulator] [Flags: Z]
	ora #$1D.b		; 09 1D ; Logical OR #$1D.b with accumulator [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor $1B.b,S		; 43 1B ; Exclusive OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1E1F0E.l		; 0F 0E 1F 1E ; OR accumulator with memory (long) $1E1F0E.l [Writes: Accumulator] [Flags: ZN]
	trb $191C.w		; 1C 1C 19 ; Test and reset bits $191C.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $807F1F.l,X		; 1F 1F 7F 80 ; Logical OR long $807F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	sta $257F7F.l,X		; 9F 7F 7F 25 ; Store accumulator (long,X) $257F7F.l,X [Reads: Accumulator, X Index]
	sbc $FFF005.l,X		; FF 05 F0 FF ; Subtract with carry (long,X) $FFF005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora $FF247F.l,X		; 1F 7F 24 FF ; Logical OR long $FF247F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	tsb $102E.w		; 0C 2E 10 ; Test and set bits $102E.w [Reads: Accumulator] [Flags: Z]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $010700.l		; 0F 00 07 01 ; OR accumulator with memory (long) $010700.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0F112F.l,X		; 3F 2F 11 0F ; AND accumulator with memory (long,X) $0F112F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $7E1CFE.l		; 0F FE 1C 7E ; OR accumulator with memory (long) $7E1CFE.l [Writes: Accumulator] [Flags: ZN]
	.db $50, $72		; 50 72 ; Branch if overflow clear to $50, $72 [Flow: branch]
	jmp $38C4.w		; 4C C4 38 ; Jump to $38C4.w [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$20.b		; C0 20 ; Compare #$20.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $C4B2.w,Y		; BE B2 C4 ; Load X register $C4B2.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$E4.b		; E0 E4 ; Compare #$E4.b with X register [Reads: X Index] [Flags: ZNC]
	and $2F0A00.l		; 2F 00 0A 2F ; AND accumulator with memory (long) $2F0A00.l [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $043B1B.l,X		; 3F 1B 3B 04 ; AND accumulator with memory (long,X) $043B1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp $4733.w		; 4C 33 47 ; Jump to $4733.w [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $0024.w,X		; 3C 24 00 ; Test bits $0024.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	trb $37.b		; 14 37 ; Test and reset bits $37.b [Reads: Accumulator] [Flags: Z]
	and [$3B.b]		; 27 3B ; AND accumulator with memory (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp $3C47.w		; 4C 47 3C ; Jump to $3C47.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F290.w,X		; FE 90 F2 ; Increment memory $F290.w,X [Reads: X Index] [Flags: ZN]
	jmp ($18E7.w)		; 6C E7 18 ; Jump indirect to ($18E7.w) [Flow: jump]
	ora $F9F2.w		; 0D F2 F9 ; Logical OR $F9F2.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: ZNC]
	trb $223C.w		; 1C 3C 22 ; Test and reset bits $223C.w [Reads: Accumulator] [Flags: Z]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $E7F2.w,X		; FE F2 E7 ; Increment memory $E7F2.w,X [Reads: X Index] [Flags: ZN]
	ora $22F9.w		; 0D F9 22 ; Logical OR $22F9.w with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $0F00.w,X		; 3C 00 0F ; Test bits $0F00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7F2F7F.l		; 0F 7F 2F 7F ; OR accumulator with memory (long) $7F2F7F.l [Writes: Accumulator] [Flags: ZN]
	and ($D1.b,X)		; 21 D1 ; Logical AND ($D1.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $6FD0.w		; 6E D0 6F ; Rotate right $6FD0.w [Flags: ZNC]
	pei ($6B.b)		; D4 6B ; Push effective indirect address ($6B.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $850F70.l,X		; FF 70 0F 85 ; Subtract with carry (long,X) $850F70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda ($00.b,X)		; A1 00 ; Load accumulator ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $F0F8.w,X		; 1D F8 F0 ; OR accumulator with memory $F0F8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $FE		; F0 FE ; Branch if equal to $F0, $FE [Flow: branch]
	pea $84FE.w		; F4 FE 84 ; Push absolute address $84FE.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ror $0B.b,X		; 76 0B ; Rotate right $0B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inc $2B.b,X		; F6 2B ; Increment memory $2B.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	dec $FF.b,X		; D6 FF ; Decrement memory $FF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	asl $FCF0.w		; 0E F0 FC ; Arithmetic shift left $FCF0.w [Flags: ZNC]
	inc $FFFE.w,X		; FE FE FF ; Increment memory $FFFE.w,X [Reads: X Index] [Flags: ZN]
	sbc $0F1FDF.l,X		; FF DF 1F 0F ; Subtract with carry (long,X) $0F1FDF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05832F.l		; 0F 2F 83 05 ; OR accumulator with memory (long) $05832F.l [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$9B.b],Y		; 37 9B ; AND accumulator with memory (long indexed) [$9B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$FC.b],Y		; 77 FC ; Add with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$9E.b],Y		; 17 9E ; OR accumulator with memory (long indexed) [$9E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $40.b,S		; 83 40 ; Store accumulator (stack relative) $40.b,S [Reads: Accumulator, Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FF227F.l,X		; 7F 7F 22 FF ; Add long $FF227F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $F0.b		; 05 F0 ; Logical OR $F0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $FA		; F0 FA ; Branch if equal to $F0, $FA [Flow: branch]
	pea $FD43.w		; F4 43 FD ; Push absolute address $FD43.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	inc $08.b,X		; F6 08 ; Increment memory $08.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cmp $F23BF0.l,X		; DF F0 3B F2 ; Compare accumulator (long,X) $F23BF0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $FCF0F0.l,X		; 7F F0 F0 FC ; Add long $FCF0F0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FF22.w,X		; FE 22 FF ; Increment memory $FF22.w,X [Reads: X Index] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $0FFF.w,X		; FD FF 0F ; Subtract with carry $0FFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7F3F7F.l		; 0F 7F 3F 7F ; OR accumulator with memory (long) $7F3F7F.l [Writes: Accumulator] [Flags: ZN]
	and [$B9.b],Y		; 37 B9 ; AND accumulator with memory (long indexed) [$B9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $77.b,S		; 43 77 ; Exclusive OR accumulator with stack relative $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldy $6F02.w,X		; BC 02 6F ; Load Y register $6F02.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $8327.w,X		; FE 27 83 ; Increment memory $8327.w,X [Reads: X Index] [Flags: ZN]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $48.b,S		; 83 48 ; Store accumulator (stack relative) $48.b,S [Reads: Accumulator, Stack Pointer]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $FEFC.w,X		; FE FC FE ; Increment memory $FEFC.w,X [Reads: X Index] [Flags: ZN]
	cpx $439D.w		; EC 9D 43 ; Compare $439D.w with X register [Reads: X Index] [Flags: ZNC]
	inc $023D.w		; EE 3D 02 ; Increment $023D.w [Flags: ZN]
	inc $7F.b,X		; F6 7F ; Increment memory $7F.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cpx $83.b		; E4 83 ; Compare $83.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $000312.l,X		; FF 12 03 00 ; Subtract with carry (long,X) $000312.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0A.b,X		; 35 0A ; Logical AND $0A.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $5F02.w,X		; 5D 02 5F ; Exclusive OR accumulator with memory $5F02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	sty $40.b		; 84 40 ; Store Y register to $40.b [Reads: Y Index]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx $00.b		; E4 00 ; Compare $00.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	dec $EC00.w,X		; DE 00 EC ; Decrement memory $EC00.w,X [Reads: X Index] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	trb $BC.b		; 14 BC ; Test and reset bits $BC.b [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($E6FC.w,X)		; FC FC E6 ; Jump to subroutine indirect indexed ($E6FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $070B03.l		; 0F 03 0B 07 ; OR accumulator with memory (long) $070B03.l [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $1F.b		; 25 1F ; Logical AND $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $CE.b,S		; 83 CE ; Store accumulator (stack relative) $CE.b,S [Reads: Accumulator, Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	inc $5D.b,X		; F6 5D ; Increment memory $5D.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $FE77FD.l		; 6F FD 77 FE ; Add with carry (long) $FE77FD.l [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $00C101.l,X		; FF 01 C1 00 ; Subtract with carry (long,X) $00C101.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $FF.b		; 26 FF ; Rotate left $FF.b [Reads: Direct Page] [Flags: ZNC]
	cpx #$44.b		; E0 44 ; Compare #$44.b with X register [Reads: X Index] [Flags: ZNC]
	cmp ($FE.b,X)		; C1 FE ; Compare accumulator ($FE.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	adc $FBBFFD.l,X		; 7F FD BF FB ; Add long $FBBFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $007FBF.l,X		; DF BF 7F 00 ; Compare accumulator (long,X) $007FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $467A.w,X		; 3C 7A 46 ; Test bits $467A.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc ($8F.b),Y		; F1 8F ; Subtract with carry ($8F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($9F.b,X)		; E1 9F ; Subtract with carry ($9F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda ($DF.b,X)		; A1 DF ; Load accumulator ($DF.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($7F.b,X)		; 41 7F ; Exclusive OR accumulator with memory ($7F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc ($BF.b),Y		; F1 BF ; Subtract with carry ($BF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $8F.b		; 46 8F ; Logical shift right $8F.b [Reads: Direct Page] [Flags: ZNC]
	sta $BF7FDF.l,X		; 9F DF 7F BF ; Store accumulator (long,X) $BF7FDF.l,X [Reads: Accumulator, X Index]
	ora $071B00.l		; 0F 00 1B 07 ; OR accumulator with memory (long) $071B00.l [Writes: Accumulator] [Flags: ZN]
	and $133F17.l,X		; 3F 17 3F 13 ; AND accumulator with memory (long,X) $133F17.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$38.b]		; 67 38 ; Add with carry (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $38.b		; 66 38 ; Rotate right $38.b [Reads: Direct Page] [Flags: ZNC]
	adc #$36.b		; 69 36 ; Add #$36.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	adc ($3F.b,S),Y		; 73 3F ; Add with carry (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $3F3F1F.l		; 0F 1F 3F 3F ; OR accumulator with memory (long) $3F3F1F.l [Writes: Accumulator] [Flags: ZN]
	and $7F.b,S		; 23 7F ; AND accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$43.b		; E0 43 ; Compare #$43.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($07E8.w,X)		; FC E8 07 ; Jump to subroutine indirect indexed ($07E8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $6C.b,X		; F6 6C ; Increment memory $6C.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	ror $0C.b,X		; 76 0C ; Rotate right $0C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	dec $BC.b		; C6 BC ; Decrement $BC.b [Reads: Direct Page] [Flags: ZN]
	stx $847C.w		; 8E 7C 84 ; Store X register to $847C.w [Reads: X Index]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $FE7E.w,X		; FE 7E FE ; Increment memory $FE7E.w,X [Reads: X Index] [Flags: ZN]
	sta $03F0.w,Y		; 99 F0 03 ; Store accumulator to $03F0.w,Y [Reads: Accumulator, Y Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0CB300.l,X		; FF 00 B3 0C ; Subtract with carry (long,X) $0CB300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy $7F13.w,X		; BC 13 7F ; Load Y register $7F13.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	trb $245E.w		; 1C 5E 24 ; Test and reset bits $245E.w [Reads: Accumulator] [Flags: Z]
	lsr $38.b		; 46 38 ; Logical shift right $38.b [Reads: Direct Page] [Flags: ZNC]
	bit $0022.w,X		; 3C 22 00 ; Test bits $0022.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsb $F3FC.w		; 0C FC F3 ; Test and set bits $F3FC.w [Reads: Accumulator] [Flags: Z]
	jsr ($5E7F.w,X)		; FC 7F 5E ; Jump to subroutine indirect indexed ($5E7F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lsr $3C.b		; 46 3C ; Logical shift right $3C.b [Reads: Direct Page] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CD.b		; 00 CD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $3D		; 30 3D ; Branch if minus to $30, $3D [Flow: branch]
	sta [$2D.b]		; 87 2D ; Store accumulator (long) [$2D.b] [Reads: Accumulator, Direct Page]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $843FCF.l,X		; 3F CF 3F 84 ; AND accumulator with memory (long,X) $843FCF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $128643.l		; CF 43 86 12 ; Compare accumulator (long) $128643.l [Reads: Accumulator] [Flags: ZNC]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $022183.l,X		; BF 83 21 02 ; Load long $022183.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $F40C00.l		; 22 00 0C F4 ; Jump to subroutine long $F40C00.l [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($FA38.w,X)		; FC 38 FA ; Jump to subroutine indirect indexed ($FA38.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $46.b		; 04 46 ; Test and set bits $46.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $0022.w,X		; 3C 22 00 ; Test bits $0022.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsb $F4.b		; 04 F4 ; Test and set bits $F4.b [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	bit $FAFC.w,X		; 3C FC FA ; Test bits $FAFC.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta $95.b,S		; 83 95 ; Store accumulator (stack relative) $95.b,S [Reads: Accumulator, Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	eor $B3.b,S		; 43 B3 ; Exclusive OR accumulator with stack relative $B3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $837C.w		; 0C 7C 83 ; Test and set bits $837C.w [Reads: Accumulator] [Flags: Z]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	ora $20.b,S		; 03 20 ; OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $221C1C.l		; 22 1C 1C 22 ; Jump to subroutine long $221C1C.l [Writes: Stack Pointer] [Flow: call]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $7F7CF3.l,X		; BF F3 7C 7F ; Load long $7F7CF3.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lsr $1C22.w,X		; 5E 22 1C ; Logical shift right $1C22.w,X [Reads: X Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rep #$CD		; C2 CD ; Reset processor status bits #$CD [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $30, $3E		; 30 3E ; Branch if minus to $30, $3E [Flow: branch]
	sta $2D.b,S		; 83 2D ; Store accumulator (stack relative) $2D.b,S [Reads: Accumulator, Stack Pointer]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $37E000.l		; 22 00 E0 37 ; Jump to subroutine long $37E000.l [Writes: Stack Pointer] [Flow: call]
	sbc $3ECF.w,X		; FD CF 3E ; Subtract with carry $3ECF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $447A.w,X		; FE 7A 44 ; Increment memory $447A.w,X [Reads: X Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $205F.w		; 2C 5F 20 ; Test bits $205F.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sty $7270.w		; 8C 70 72 ; Store Y register to $7270.w [Reads: Y Index]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $8F5E.w,X		; 5E 5E 8F ; Logical shift right $8F5E.w,X [Reads: X Index] [Flags: ZNC]
	adc ($8B.b,S),Y		; 73 8B ; Add with carry (stack relative indirect indexed) ($8B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	bit #$70.b		; 89 70 ; Test bits #$70.b with accumulator [Reads: Accumulator] [Flags: Z]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $60E4.w		; 20 E4 60 ; Jump to subroutine at $60E4.w [Writes: Stack Pointer] [Flow: call]
	sbc ($30.b)		; F2 30 ; Subtract with carry (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $0E0C.w,X		; 3D 0C 0E ; AND accumulator with memory $0E0C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $9CDEF6.l,X		; 3F F6 DE 9C ; AND accumulator with memory (long,X) $9CDEF6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec $0E33.w		; CE 33 0E ; Decrement $0E33.w [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($6C44.w,X)		; 7C 44 6C ; Jump indirect indexed to ($6C44.w,X) [Reads: X Index] [Flow: jump]
	mvn $7C,$54		; 54 54 7C ; Move block negative $7C,$54 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	jmp ($547C.w)		; 6C 7C 54 ; Jump indirect to ($547C.w) [Flow: jump]
	jmp ($0000.w,X)		; 7C 00 00 ; Jump indirect indexed to ($0000.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	mvp $22,$54		; 44 54 22 ; Move block positive $22,$54 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	jmp ($4843.w,X)		; 7C 43 48 ; Jump indirect indexed to ($4843.w,X) [Reads: X Index] [Flow: jump]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor $28.b,S		; 43 28 ; Exclusive OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $14.b,S		; 03 14 ; OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $0808.w		; 1C 08 08 ; Test and reset bits $0808.w [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $0008.w		; 1C 08 00 ; Test and reset bits $0008.w [Reads: Accumulator] [Flags: Z]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $DCA4.w		; 8E A4 DC ; Store X register to $DCA4.w [Reads: X Index]
	eor $48.b,S		; 43 48 ; Exclusive OR accumulator with stack relative $48.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cop $2C.b		; 02 2C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $8412.w,X		; 3C 12 84 ; Test bits $8412.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp ($01.b)		; D2 01 ; Compare accumulator (indirect) ($01.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	asl $8E.b		; 06 8E ; Arithmetic shift left $8E.b [Reads: Direct Page] [Flags: ZNC]
	jmp.w [$7878]		; DC 78 78 ; Jump long indirect [$7878] [Flow: jump]
	bit $0C1E.w,X		; 3C 1E 0C ; Test bits $0C1E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jsl $010900.l		; 22 00 09 01 ; Jump to subroutine long $010900.l [Writes: Stack Pointer] [Flow: call]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $0706.w,X		; 7E 06 07 ; Rotate right $0706.w,X [Reads: X Index] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $0701.w		; 0C 01 07 ; Test and set bits $0701.w [Reads: Accumulator] [Flags: Z]
	ror $0107.w,X		; 7E 07 01 ; Rotate right $0107.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $207F1C.l,X		; 3F 1C 7F 20 ; AND accumulator with memory (long,X) $207F1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($8633.w,X)		; 7C 33 86 ; Jump indirect indexed to ($8633.w,X) [Reads: X Index] [Flow: jump]
	stx $04.b		; 86 04 ; Store X register to $04.b [Reads: X Index]
	jsl $3F0200.l		; 22 00 02 3F ; Jump to subroutine long $3F0200.l [Writes: Stack Pointer] [Flow: call]
	adc $93847C.l,X		; 7F 7C 84 93 ; Add long $93847C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	jsr ($FEF8.w,X)		; FC F8 FE ; Jump to subroutine indirect indexed ($FEF8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	cpy $2E86.w		; CC 86 2E ; Compare $2E86.w with Y register [Reads: Y Index] [Flags: ZNC]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($3EFE.w,X)		; FC FE 3E ; Jump to subroutine indirect indexed ($3EFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sty $3B.b		; 84 3B ; Store Y register to $3B.b [Reads: Y Index]
	cop $97.b		; 02 97 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $21.b		; E4 21 ; Compare $21.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $071800.l		; 0F 00 18 07 ; OR accumulator with memory (long) $071800.l [Writes: Accumulator] [Flags: ZN]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $01		; 30 01 ; Branch if minus to $30, $01 [Flow: branch]
	stx $21.b		; 86 21 ; Store X register to $21.b [Reads: X Index]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($1F.b,X)		; 61 1F ; Add with carry ($1F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3F.b,S		; C3 3F ; Compare accumulator (stack relative) $3F.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F01FF.l		; 0F FF 01 0F ; OR accumulator with memory (long) $0F01FF.l [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $61		; 30 61 ; Branch if minus to $30, $61 [Flow: branch]
	cmp $07.b,S		; C3 07 ; Compare accumulator (stack relative) $07.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ora $4300FF.l		; 0F FF 00 43 ; OR accumulator with memory (long) $4300FF.l [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F00EFF.l		; 22 FF 0E F0 ; Jump to subroutine long $F00EFF.l [Writes: Stack Pointer] [Flow: call]
	sbc $80FFC0.l,X		; FF C0 FF 80 ; Subtract with carry (long,X) $80FFC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $C0F0FF.l,X		; 7F FF F0 C0 ; Add long $C0F0FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $41		; 80 41 ; Branch always to $80, $41 [Flow: branch]
	mvp $40,$3F		; 44 3F 40 ; Move block positive $40,$3F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $20,$1F		; 44 1F 20 ; Move block positive $20,$1F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($30.b)		; 12 30 ; OR accumulator with memory (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $410F10.l		; 0F 10 0F 41 ; OR accumulator with memory (long) $410F10.l [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $3020.w		; 20 20 30 ; Jump to subroutine at $3020.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $FC		; 10 FC ; Branch if plus to $10, $FC [Flow: branch]
	sbc $7FFFFE.l,X		; FF FE FF 7F ; Subtract with carry (long,X) $7FFFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF443F.l,X		; FF 3F 44 FF ; Subtract with carry (long,X) $FF443F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FF0F43.l,X		; 1F 43 0F FF ; Logical OR long $FF0F43.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$FC.b]		; 07 FC ; OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $3F7F.w,X		; FE 7F 3F ; Increment memory $3F7F.w,X [Reads: X Index] [Flags: ZN]
	ora $0F0F1F.l,X		; 1F 1F 0F 0F ; Logical OR long $0F0F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $FF8008.l,X		; FF 08 80 FF ; Subtract with carry (long,X) $FF8008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $FEFFFC.l,X		; FF FC FF FE ; Subtract with carry (long,X) $FEFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $0006FF.l		; 22 FF 06 00 ; Jump to subroutine long $0006FF.l [Writes: Stack Pointer] [Flow: call]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($84FE.w,X)		; FC FE 84 ; Jump to subroutine indirect indexed ($84FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Accumulator, X Index, Direct Page]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $1F0200.l,X		; FF 00 02 1F ; Subtract with carry (long,X) $1F0200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $002A07.l		; 0F 07 2A 00 ; OR accumulator with memory (long) $002A07.l [Writes: Accumulator] [Flags: ZN]
	ora #$09.b		; 09 09 ; Logical OR #$09.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $96.b		; 00 96 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$F3.b		; 09 F3 ; Logical OR #$F3.b with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $6FB8.w		; 0C B8 6F ; Test and set bits $6FB8.w [Reads: Accumulator] [Flags: Z]
	jmp.w [$2277]		; DC 77 22 ; Jump long indirect [$2277] [Flow: jump]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$97.b		; 09 97 ; Logical OR #$97.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc [$BB.b],Y		; F7 BB ; Subtract with carry (long indexed) [$BB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp.w [$0010]		; DC 10 00 ; Jump long indirect [$0010] [Flow: jump]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $68		; 10 68 ; Branch if plus to $10, $68 [Flow: branch]
	.db $30, $98		; 30 98 ; Branch if minus to $30, $98 [Flow: branch]
	.db $70, $3B		; 70 3B ; Branch if overflow set to $70, $3B [Flow: branch]
	.db $F0, $F7		; F0 F7 ; Branch if equal to $F0, $F7 [Flow: branch]
	.db $62, $FD, $A6		; 62 FD A6 ; Push effective relative address $62, $FD, $A6 [Writes: Stack Pointer]
	sbc $10CE.w,X		; FD CE 10 ; Subtract with carry $10CE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sbc [$FD.b],Y		; F7 FD ; Subtract with carry (long indexed) [$FD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0025.w,X		; FD 25 00 ; Subtract with carry $0025.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $5F.b,S		; 03 5F ; OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $256B7C.l,X		; 3F 7C 6B 25 ; AND accumulator with memory (long,X) $256B7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	bit $DA00.w,X		; 3C 00 DA ; Test bits $DA00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpy #$FD.b		; C0 FD ; Compare #$FD.b with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $0022.w		; 0C 22 00 ; Test and set bits $0022.w [Reads: Accumulator] [Flags: Z]
	tsb $C0.b		; 04 C0 ; Test and set bits $C0.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	rol $27F3.w,X		; 3E F3 27 ; Rotate left $27F3.w,X [Reads: X Index] [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $273B.w		; 1C 3B 27 ; Test and reset bits $273B.w [Reads: Accumulator] [Flags: Z]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0301.w		; 0E 01 03 ; Arithmetic shift left $0301.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$3C.b		; C0 3C ; Compare #$3C.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $23		; 30 23 ; Branch if minus to $30, $23 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($C0.b,S),Y		; 33 C0 ; AND accumulator (stack relative indirect indexed) ($C0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	cpy $0003.w		; CC 03 00 ; Compare $0003.w with Y register [Reads: Y Index] [Flags: ZNC]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	tsb $2F07.w		; 0C 07 2F ; Test and set bits $2F07.w [Reads: Accumulator] [Flags: Z]
	tsb $5F.b		; 04 5F ; Test and set bits $5F.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $019F00.l,X		; 5F 00 9F 01 ; Exclusive OR accumulator with memory (long,X) $019F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $070349.l,X		; DF 49 03 07 ; Compare accumulator (long,X) $070349.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ora $777B2C.l		; 0F 2C 7B 77 ; OR accumulator with memory (long) $777B2C.l [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	lda ($C0.b)		; B2 C0 ; Load accumulator (indirect) ($C0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$30.b		; C0 30 ; Compare #$30.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$F4.b		; E0 F4 ; Compare #$F4.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $10FA.w		; 20 FA 10 ; Jump to subroutine at $10FA.w [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FB		; 80 FB ; Branch always to $80, $FB [Flow: branch]
	sta ($C0.b)		; 92 C0 ; Store accumulator (indirect) ($C0.b) [Reads: Accumulator, Direct Page]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	bit $DE.b,X		; 34 DE ; Test bits $DE.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	inc $4D1F.w		; EE 1F 4D ; Increment $4D1F.w [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $473F43.l,X		; 1F 43 3F 47 ; Logical OR long $473F43.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $8F3FCF.l,X		; 3F CF 3F 8F ; AND accumulator with memory (long,X) $8F3FCF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FF0F43.l,X		; 7F 43 0F FF ; Add long $FF0F43.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$46.b		; E0 46 ; Compare #$46.b with X register [Reads: X Index] [Flags: ZNC]
	asl $60FF.w		; 0E FF 60 ; Arithmetic shift left $60FF.w [Flags: ZNC]
	eor $47.b,S		; 43 47 ; Exclusive OR accumulator with stack relative $47.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cmp $0F0F8F.l		; CF 8F 0F 0F ; Compare accumulator (long) $0F0F8F.l [Reads: Accumulator] [Flags: ZNC]
	asl $FF3F.w		; 0E 3F FF ; Arithmetic shift left $FF3F.w [Flags: ZNC]
	inc $FCFF.w,X		; FE FF FC ; Increment memory $FCFF.w,X [Reads: X Index] [Flags: ZN]
	sbc $F0FFF8.l,X		; FF F8 FF F0 ; Subtract with carry (long,X) $F0FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $80FFE0.l,X		; FF E0 FF 80 ; Subtract with carry (long,X) $80FFE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $3FFF01.l,X		; FF 01 FF 3F ; Subtract with carry (long,X) $3FFF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $F8FC.w,X		; FE FC F8 ; Increment memory $F8FC.w,X [Reads: X Index] [Flags: ZN]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $FF1FFF.l		; 0F FF 1F FF ; OR accumulator with memory (long) $FF1FFF.l [Writes: Accumulator] [Flags: ZN]
	and $FF7FFF.l,X		; 3F FF 7F FF ; AND accumulator with memory (long,X) $FF7FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $00FFE0.l,X		; FF E0 FF 00 ; Subtract with carry (long,X) $00FFE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $F87F3F.l,X		; 1F 3F 7F F8 ; Logical OR long $F87F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: ZNC]
	ora $080718.l		; 0F 18 07 08 ; OR accumulator with memory (long) $080718.l [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $100800.l		; 22 00 08 10 ; Jump to subroutine long $100800.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $0306.w		; 0C 06 03 ; Test and set bits $0306.w [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $07FF46.l		; 0F 46 FF 07 ; OR accumulator with memory (long) $07FF46.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora $030722.l		; 0F 22 07 03 ; OR accumulator with memory (long) $030722.l [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	and $00FF.w		; 2D FF 00 ; Logical AND $00FF.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $00FF27.l,X		; 3F 27 FF 00 ; AND accumulator with memory (long,X) $00FF27.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $009283.l,X		; 3F 83 92 00 ; AND accumulator with memory (long,X) $009283.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF28F0.l,X		; FF F0 28 FF ; Subtract with carry (long,X) $FF28F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	sbc $6F6CE0.l,X		; FF E0 6C 6F ; Subtract with carry (long,X) $6F6CE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $023D.w,Y		; 39 3D 02 ; AND accumulator with memory $023D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$0E.b],Y		; 17 0E ; OR accumulator with memory (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $385C3C.l		; 4F 3C 5C 38 ; Exclusive OR accumulator with memory (long) $385C3C.l [Writes: Accumulator] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $331F.w,X		; 3D 1F 33 ; AND accumulator with memory $331F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $60985C.l		; 6F 5C 98 60 ; Add with carry (long) $60985C.l [Writes: Accumulator] [Flags: ZVNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	pea $08F4.w		; F4 F4 08 ; Push absolute address $08F4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$90.b		; E0 90 ; Compare #$90.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$C8.b		; E0 C8 ; Compare #$C8.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	.db $70, $64		; 70 64 ; Branch if overflow set to $70, $64 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $B0F8.w		; F4 F8 B0 ; Push absolute address $B0F8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cld		; D8 ; Clear decimal flag [Flags: D]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	stz $18.b		; 64 18 ; Store zero to $18.b
	ldy $FE30.w,X		; BC 30 FE ; Load Y register $FE30.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	asl $0B9B.w		; 0E 9B 0B ; Arithmetic shift left $0B9B.w [Flags: ZNC]
	lda $FF15.w,X		; BD 15 FF ; Load $FF15.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$67.b]		; 27 67 ; AND accumulator with memory (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($F4.b),Y		; F1 F4 ; Subtract with carry ($F4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	nop		; EA ; No operation
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stz $02.b		; 64 02 ; Store zero to $02.b
	ora ($3D.b,X)		; 01 3D ; Logical OR ($3D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	adc $D0DA72.l,X		; 7F 72 DA D0 ; Add long $D0DA72.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $FDA8.w,Y		; BE A8 FD ; Load X register $FDA8.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	cpy $FD.b		; C4 FD ; Compare $FD.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	.db $80, $E7		; 80 E7 ; Branch always to $80, $E7 [Flow: branch]
	cpy #$C2.b		; C0 C2 ; Compare #$C2.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $D7.b		; 00 D7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $562E.w		; 8D 2E 56 ; Store accumulator to $562E.w [Reads: Accumulator]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $7EC225.l,X		; 7F 25 C2 7E ; Add long $7EC225.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $1B7B.w		; 0E 7B 1B ; Arithmetic shift left $1B7B.w [Flags: ZNC]
	lda $BF15.w,X		; BD 15 BF ; Load $BF15.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$EF.b]		; 27 EF ; AND accumulator with memory (long) [$EF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $47.b,S		; 03 47 ; OR accumulator with stack relative $47.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $711900.l		; 22 00 19 71 ; Jump to subroutine long $711900.l [Writes: Stack Pointer] [Flow: call]
	stz $EA.b		; 64 EA ; Store zero to $EA.b
	cld		; D8 ; Clear decimal flag [Flags: D]
	ldy $0146.w		; AC 46 01 ; Load $0146.w into Y register [Writes: Y Index] [Flags: ZN]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $D6		; 70 D6 ; Branch if overflow set to $70, $D6 [Flow: branch]
	cpy #$AE.b		; C0 AE ; Compare #$AE.b with Y register [Reads: Y Index] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	.db $D0, $FA		; D0 FA ; Branch if not equal to $D0, $FA [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	nop		; EA ; No operation
	cpy #$CE.b		; C0 CE ; Compare #$CE.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $7643.w,X		; 3E 43 76 ; Rotate left $7643.w,X [Reads: X Index] [Flags: ZNC]
	rol $31E0.w		; 2E E0 31 ; Rotate left $31E0.w [Flags: ZNC]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stz $24.b		; 64 24 ; Store zero to $24.b
	and $002F07.l		; 2F 07 2F 00 ; AND accumulator with memory (long) $002F07.l [Writes: Accumulator] [Flags: ZN]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000303.l		; 0F 03 03 00 ; OR accumulator with memory (long) $000303.l [Writes: Accumulator] [Flags: ZN]
	sta $5B.b,S		; 83 5B ; Store accumulator (stack relative) $5B.b,S [Reads: Accumulator, Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $171F.w,X		; 3C 1F 17 ; Test bits $171F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsb $7F03.w		; 0C 03 7F ; Test and set bits $7F03.w [Reads: Accumulator] [Flags: Z]
	asl $2426.w,X		; 1E 26 24 ; Arithmetic shift left $2426.w,X [Reads: X Index] [Flags: ZNC]
	pea $F4E0.w		; F4 E0 F4 ; Push absolute address $F4E0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	trb $F83C.w		; 1C 3C F8 ; Test and reset bits $F83C.w [Reads: Accumulator] [Flags: Z]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	sta $24.b,S		; 83 24 ; Store accumulator (stack relative) $24.b,S [Reads: Accumulator, Stack Pointer]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $601F.w		; 20 1F 60 ; Jump to subroutine at $601F.w [Writes: Stack Pointer] [Flow: call]
	ora $3F4440.l,X		; 1F 40 44 3F ; Logical OR long $3F4440.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor ($0E.b,X)		; 41 0E ; Exclusive OR accumulator with memory ($0E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor ($41.b,X)		; 41 41 ; Exclusive OR accumulator with memory ($41.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $1C.b,S		; 43 1C ; Exclusive OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $78FF38.l,X		; FF 38 FF 78 ; Subtract with carry (long,X) $78FF38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	mvp $F0,$FF		; 44 FF F0 ; Move block positive $F0,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $E0.b		; 45 E0 ; Exclusive OR $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $381C04.l,X		; FF 04 1C 38 ; Subtract with carry (long,X) $381C04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	jsl $0700E0.l		; 22 E0 00 07 ; Jump to subroutine long $0700E0.l [Writes: Stack Pointer] [Flow: call]
	mvp $0F,$FF		; 44 FF 0F ; Move block positive $0F,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor #$1F.b		; 49 1F ; Exclusive OR #$1F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $0F0702.l,X		; FF 02 07 0F ; Subtract with carry (long,X) $0F0702.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $431F24.l		; 0F 24 1F 43 ; OR accumulator with memory (long) $431F24.l [Writes: Accumulator] [Flags: ZN]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: ZNC]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Accumulator, Direct Page]
	sta $43.b,S		; 83 43 ; Store accumulator (stack relative) $43.b,S [Reads: Accumulator, Stack Pointer]
	sbc $C001C0.l,X		; FF C0 01 C0 ; Subtract with carry (long,X) $C001C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $22.b,S		; 83 22 ; Store accumulator (stack relative) $22.b,S [Reads: Accumulator, Stack Pointer]
	sta [$01.b]		; 87 01 ; Store accumulator (long) [$01.b] [Reads: Accumulator, Direct Page]
	sta $C0.b,S		; 83 C0 ; Store accumulator (stack relative) $C0.b,S [Reads: Accumulator, Stack Pointer]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $20,$1F		; 44 1F 20 ; Move block positive $20,$1F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	asl $30.b		; 06 30 ; Arithmetic shift left $30.b [Reads: Direct Page] [Flags: ZNC]
	ora $0E0718.l		; 0F 18 07 0E ; OR accumulator with memory (long) $0E0718.l [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $738300.l		; 22 00 83 73 ; Jump to subroutine long $738300.l [Writes: Stack Pointer] [Flow: call]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $0003.w		; 0E 03 00 ; Arithmetic shift left $0003.w [Flags: ZNC]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $0000.w,X		; 7E 00 00 ; Rotate right $0000.w,X [Reads: X Index] [Flags: ZNC]
	ora [$48.b]		; 07 48 ; OR accumulator with memory (long) [$48.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $C00400.l,X		; FF 00 04 C0 ; Subtract with carry (long,X) $C00400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $071F3F.l,X		; 3F 3F 1F 07 ; AND accumulator with memory (long,X) $071F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	tsb $0E19.w		; 0C 19 0E ; Test and set bits $0E19.w [Reads: Accumulator] [Flags: Z]
	ora $002203.l		; 0F 03 22 00 ; OR accumulator with memory (long) $002203.l [Writes: Accumulator] [Flags: ZN]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	bit $1B16.w		; 2C 16 1B ; Test bits $1B16.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $0A0023.l		; 0F 23 00 0A ; OR accumulator with memory (long) $0A0023.l [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $26.b		; 04 26 ; Test and set bits $26.b [Reads: Accumulator] [Flags: Z]
	trb $385C.w		; 1C 5C 38 ; Test and reset bits $385C.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $040500.l		; 22 00 05 04 ; Jump to subroutine long $040500.l [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	rol $7C.b,X		; 36 7C ; Rotate left $7C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $84		; 80 84 ; Branch always to $80, $84 [Flow: branch]
	stx $01.b		; 86 01 ; Store X register to $01.b [Reads: X Index]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	jsr $3058.w		; 20 58 30 ; Jump to subroutine at $3058.w [Writes: Stack Pointer] [Flow: call]
	.db $30, $83		; 30 83 ; Branch if minus to $30, $83 [Flow: branch]
	sta ($01.b)		; 92 01 ; Store accumulator (indirect) ($01.b) [Reads: Accumulator, Direct Page]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	jsr $5870.w		; 20 70 58 ; Jump to subroutine at $5870.w [Writes: Stack Pointer] [Flow: call]
	.db $30, $23		; 30 23 ; Branch if minus to $30, $23 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	jsl $801D00.l		; 22 00 1D 80 ; Jump to subroutine long $801D00.l [Writes: Stack Pointer] [Flow: call]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1038.w		; 1C 38 10 ; Test and reset bits $1038.w [Reads: Accumulator] [Flags: Z]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: ZN]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $977FBF.l,X		; DF BF 7F 97 ; Compare accumulator (long,X) $977FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	jsr $F004.w		; 20 04 F0 ; Jump to subroutine at $F004.w [Writes: Stack Pointer] [Flow: call]
	and $4D0420.l		; 2F 20 04 4D ; AND accumulator with memory (long) $4D0420.l [Writes: Accumulator] [Flags: ZN]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($41.b,X)		; 01 41 ; Logical OR ($41.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $004326.l,X		; 3F 26 43 00 ; AND accumulator with memory (long,X) $004326.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor ($47.b,X)		; 41 47 ; Exclusive OR accumulator with memory ($47.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F8,$FF		; 44 FF F8 ; Move block positive $F8,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $03E023.l,X		; FF 23 E0 03 ; Subtract with carry (long,X) $03E023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0F43.w,X)		; FC 43 0F ; Jump to subroutine indirect indexed ($0F43.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FF0702.l,X		; FF 02 07 FF ; Subtract with carry (long,X) $FF0702.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $48.b,S		; 03 48 ; OR accumulator with stack relative $48.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $0F0300.l,X		; FF 00 03 0F ; Subtract with carry (long,X) $0F0300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $230307.l		; 0F 07 03 23 ; OR accumulator with memory (long) $230307.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$84.b		; C0 84 ; Compare #$84.b with Y register [Reads: Y Index] [Flags: ZNC]
	sta $0004.w,X		; 9D 04 00 ; Store accumulator to $0004.w,X [Reads: Accumulator, X Index]
	jsr ($FF22.w,X)		; FC 22 FF ; Jump to subroutine indirect indexed ($FF22.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $7C.b		; 85 7C ; Store accumulator to $7C.b [Reads: Accumulator]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	sbc $1F3F7F.l,X		; FF 7F 3F 1F ; Subtract with carry (long,X) $1F3F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $47.b		; E4 47 ; Compare $47.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $00002E.l,X		; 7F 2E 00 00 ; Add long $00002E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $080026.l,X		; 7F 26 00 08 ; Add long $080026.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $070C04.l		; 0F 04 0C 07 ; OR accumulator with memory (long) $070C04.l [Writes: Accumulator] [Flags: ZN]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: ZNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03060D.l		; 0F 0D 06 03 ; OR accumulator with memory (long) $03060D.l [Writes: Accumulator] [Flags: ZN]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $04		; 10 04 ; Branch if plus to $10, $04 [Flow: branch]
	asl $88.b		; 06 88 ; Arithmetic shift left $88.b [Reads: Direct Page] [Flags: ZNC]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $C088.w		; 1C 88 C0 ; Test and reset bits $C088.w [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$24.b		; C0 24 ; Compare #$24.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $04		; 10 04 ; Branch if plus to $10, $04 [Flow: branch]
	cop $34.b		; 02 34 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $1834.w		; 1C 34 18 ; Test and reset bits $1834.w [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $20.b		; 06 20 ; Arithmetic shift left $20.b [Reads: Direct Page] [Flags: ZNC]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $387C.w		; 20 7C 38 ; Jump to subroutine at $387C.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $20.b,S		; 03 20 ; OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp ($2238.w,X)		; 7C 38 22 ; Jump indirect indexed to ($2238.w,X) [Reads: X Index] [Flow: jump]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $0420.w,X		; 5E 20 04 ; Logical shift right $0420.w,X [Reads: X Index] [Flags: ZNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000003.l,X		; FF 03 00 00 ; Subtract with carry (long,X) $000003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $4300.w		; 20 00 43 ; Jump to subroutine at $4300.w [Writes: Stack Pointer] [Flow: call]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	ora ($93.b)		; 12 93 ; OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $6BD753.l		; EF 53 D7 6B ; Subtract with carry (long) $6BD753.l [Writes: Accumulator] [Flags: ZVNC]
	ror $3B.b		; 66 3B ; Rotate right $3B.b [Reads: Direct Page] [Flags: ZNC]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	sbc ($DF.b,S),Y		; F3 DF ; Subtract with carry (stack relative indirect indexed) ($DF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00007F.l		; EF 7F 00 00 ; Subtract with carry (long) $00007F.l [Writes: Accumulator] [Flags: ZVNC]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$41.b		; E0 41 ; Compare #$41.b with X register [Reads: X Index] [Flags: ZNC]
	cmp $F302.w		; CD 02 F3 ; Compare $F302.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	dec $DEF3.w		; CE F3 DE ; Decrement $DEF3.w [Flags: ZN]
	ror $00DC.w,X		; 7E DC 00 ; Rotate right $00DC.w,X [Reads: X Index] [Flags: ZNC]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	wai		; CB ; Wait for interrupt
	sbc $03FEFF.l,X		; FF FF FE 03 ; Subtract with carry (long,X) $03FEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1034.w		; 0C 34 10 ; Test and set bits $1034.w [Reads: Accumulator] [Flags: Z]
	jmp ($5E20.w)		; 6C 20 5E ; Jump indirect to ($5E20.w) [Flow: jump]
	cop $9E.b		; 02 9E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0C03.w,X		; 7D 03 0C ; Add $0C03.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($2F.b,S),Y		; 13 2F ; OR accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	adc $82F1.w,Y		; 79 F1 82 ; Add $82F1.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy $7A80.w		; CC 80 7A ; Compare $7A80.w with Y register [Reads: Y Index] [Flags: ZNC]
	mvp $20,$3E		; 44 3E 20 ; Move block positive $20,$3E [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	adc $E0FE60.l,X		; 7F 60 FE E0 ; Add long $E0FE60.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cpy $EE.b		; C4 EE ; Compare $EE.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	.db $90, $80		; 90 80 ; Branch if carry clear to $90, $80 [Flow: branch]
	jmp $D6B2.w		; 4C B2 D6 ; Jump to $D6B2.w [Flow: jump]
	sta $2212.w,Y		; 99 12 22 ; Store accumulator to $2212.w,Y [Reads: Accumulator, Y Index]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $40.b		; 86 40 ; Store X register to $40.b [Reads: X Index]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	jsr $4078.w		; 20 78 40 ; Jump to subroutine at $4078.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$F4.b		; C0 F4 ; Compare #$F4.b with Y register [Reads: Y Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $A8		; 70 A8 ; Branch if overflow set to $70, $A8 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $83.b		; 24 83 ; Test bits $83.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1D07.w		; 0E 07 1D ; Arithmetic shift left $1D07.w [Flags: ZNC]
	asl $0F7A.w		; 0E 7A 0F ; Arithmetic shift left $0F7A.w [Flags: ZNC]
	sta $7F7F.w,Y		; 99 7F 7F ; Store accumulator to $7F7F.w,Y [Reads: Accumulator, Y Index]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $FF7F1E.l		; 0F 1E 7F FF ; OR accumulator with memory (long) $FF7F1E.l [Writes: Accumulator] [Flags: ZN]
	adc $007883.l,X		; 7F 83 78 00 ; Add long $007883.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $E0.b		; 14 E0 ; Test and reset bits $E0.b [Reads: Accumulator] [Flags: Z]
	.db $80, $70		; 80 70 ; Branch always to $80, $70 [Flow: branch]
	cpx #$B8.b		; E0 B8 ; Compare #$B8.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $5E		; 70 5E ; Branch if overflow set to $70, $5E [Flow: branch]
	.db $F0, $B9		; F0 B9 ; Branch if equal to $F0, $B9 [Flow: branch]
	dec $ECFE.w,X		; DE FE EC ; Decrement memory $ECFE.w,X [Reads: X Index] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $FEDF.w,X		; FE DF FE ; Increment memory $FEDF.w,X [Reads: X Index] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $010006.l		; 0F 06 00 01 ; OR accumulator with memory (long) $010006.l [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $67FED1.l,X		; DF D1 FE 67 ; Compare accumulator (long,X) $67FED1.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $FA1E.w,X		; FD 1E FA ; Subtract with carry $FA1E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $C0FEE5.l,X		; 7F E5 FE C0 ; Add long $C0FEE5.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $2FD3.w		; 20 D3 2F ; Jump to subroutine at $2FD3.w [Writes: Stack Pointer] [Flow: call]
	sta $FEFFFE.l,X		; 9F FE FF FE ; Store accumulator (long,X) $FEFFFE.l,X [Reads: Accumulator, X Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $C4.b,S		; 83 C4 ; Store accumulator (stack relative) $C4.b,S [Reads: Accumulator, Stack Pointer]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: ZNC]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $07DE01.l		; 0F 01 DE 07 ; OR accumulator with memory (long) $07DE01.l [Writes: Accumulator] [Flags: ZN]
	sbc $839E.w,X		; FD 9E 83 ; Subtract with carry $839E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $00.b		; E4 00 ; Compare $00.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$5F.b],Y		; F7 5F ; Subtract with carry (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0F0364.l,X		; FF 64 03 0F ; Subtract with carry (long,X) $0F0364.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FEFF7E.l,X		; DF 7E FF FE ; Compare accumulator (long,X) $FEFF7E.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $0025FF.l,X		; FF FF 25 00 ; Subtract with carry (long,X) $0025FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F2.b,S		; 03 F2 ; OR accumulator with stack relative $F2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $6AEF1D.l		; 0F 1D EF 6A ; OR accumulator with memory (long) $6AEF1D.l [Writes: Accumulator] [Flags: ZN]
	sbc $BAFFF5.l,X		; FF F5 FF BA ; Subtract with carry (long,X) $BAFFF5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $03FF1D.l,X		; FF 1D FF 03 ; Subtract with carry (long,X) $03FF1D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $1FF3.w		; 1C F3 1F ; Test and reset bits $1FF3.w [Reads: Accumulator] [Flags: Z]
	adc $13FF22.l		; 6F 22 FF 13 ; Add with carry (long) $13FF22.l [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	tsb $94F0.w		; 0C F0 94 ; Test and set bits $94F0.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsr ($FE85.w,X)		; FC 85 FE ; Jump to subroutine indirect indexed ($FE85.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$FF.b]		; 87 FF ; Store accumulator (long) [$FF.b] [Reads: Accumulator, Direct Page]
	lsr $FF.b,X		; 56 FF ; Logical shift right $FF.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	pea $62FA.w		; F4 FA 62 ; Push absolute address $62FA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $FE00.w,X		; FD 00 FE ; Subtract with carry $FE00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$C0.b]		; 07 C0 ; OR accumulator with memory (long) [$C0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	cpy #$50.b		; C0 50 ; Compare #$50.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: ZNC]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $B0, $50		; B0 50 ; Branch if carry set to $B0, $50 [Flow: branch]
	jmp ($3E37.w,X)		; 7C 37 3E ; Jump indirect indexed to ($3E37.w,X) [Reads: X Index] [Flow: jump]
	ora $7F133F.l		; 0F 3F 13 7F ; OR accumulator with memory (long) $7F133F.l [Writes: Accumulator] [Flags: ZN]
	ora $1DF7.w,Y		; 19 F7 1D ; OR accumulator with memory $1DF7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	adc $FF63FE.l		; 6F FE 63 FF ; Add with carry (long) $FF63FE.l [Writes: Accumulator] [Flags: ZVNC]
	ora $3F7F.w,X		; 1D 7F 3F ; OR accumulator with memory $3F7F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $22BD7B.l,X		; 3F 7B BD 22 ; AND accumulator with memory (long,X) $22BD7B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $E83E14.l,X		; FF 14 3E E8 ; Subtract with carry (long,X) $E83E14.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $FEF0.w,X		; 7E F0 FE ; Rotate right $FEF0.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $90, $EF		; 90 EF ; Branch if carry clear to $90, $EF [Flow: branch]
	.db $B0, $57		; B0 57 ; Branch if carry set to $B0, $57 [Flow: branch]
	cpx #$77.b		; E0 77 ; Compare #$77.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$F7.b		; E0 F7 ; Compare #$F7.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $FE		; 80 FE ; Branch always to $80, $FE [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	jsl $3CE0F9.l		; 22 F9 E0 3C ; Jump to subroutine long $3CE0F9.l [Writes: Stack Pointer] [Flow: call]
	adc $001E1F.l,X		; 7F 1F 1E 00 ; Add long $001E1F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($0C.b)		; 12 0C ; OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: ZNC]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F0E1F.l,X		; 1F 1F 0E 0F ; Logical OR long $0F0E1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$72.b]		; 07 72 ; OR accumulator with memory (long) [$72.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp $5864.w		; 4C 64 58 ; Jump to $5864.w [Flow: jump]
	jmp ($EC40.w,X)		; 7C 40 EC ; Jump indirect indexed to ($EC40.w,X) [Reads: X Index] [Flow: jump]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpx $F808.w		; EC 08 F8 ; Compare $F808.w with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $F0		; D0 F0 ; Branch if not equal to $D0, $F0 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $BC.b		; A4 BC ; Load $BC.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	bit $F4.b,X		; 34 F4 ; Test bits $F4.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	sbc $107C7D.l,X		; FF 7D 7C 10 ; Subtract with carry (long,X) $107C7D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $1F09.w,Y		; 19 09 1F ; OR accumulator with memory $1F09.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $113F.w		; 0E 3F 11 ; Arithmetic shift left $113F.w [Flags: ZNC]
	and $0703.w,X		; 3D 03 07 ; AND accumulator with memory $0703.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $31E000.l		; 22 00 E0 31 ; Jump to subroutine long $31E000.l [Writes: Stack Pointer] [Flow: call]
	.db $82, $6F, $16		; 82 6F 16 ; Branch always long to $82, $6F, $16 [Flow: branch]
	ora ($2E.b),Y		; 11 2E ; OR accumulator with memory ($2E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $0007.w,X		; 3E 07 00 ; Rotate left $0007.w,X [Reads: X Index] [Flags: ZNC]
	pea $C488.w		; F4 88 C4 ; Push absolute address $C488.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpx $EC50.w		; EC 50 EC ; Compare $EC50.w with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $DE		; D0 DE ; Branch if not equal to $D0, $DE [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	dec $9C1C.w,X		; DE 1C 9C ; Decrement memory $9C1C.w,X [Reads: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $2C,$AC		; 44 AC 2C ; Move block positive $2C,$AC [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ror $E2.b,X		; 76 E2 ; Rotate right $E2.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx $78.b		; E4 78 ; Compare $78.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	ror $3C29.w,X		; 7E 29 3C ; Rotate right $3C29.w,X [Reads: X Index] [Flags: ZNC]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $7F.b,S		; 23 7F ; AND accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	and $031F17.l,X		; 3F 17 1F 03 ; AND accumulator with memory (long,X) $031F17.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $7F223F.l,X		; 7F 3F 22 7F ; Add long $7F223F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $3F.b		; 14 3F ; Test and reset bits $3F.b [Reads: Accumulator] [Flags: Z]
	ora $947E07.l,X		; 1F 07 7E 94 ; Logical OR long $947E07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $F6C8.w,X		; 3C C8 F6 ; Test bits $F6C8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
.ACCU 8
.INDEX 8
	sep #$3C		; E2 3C
	ror $BC.b,X		; 76 BC ; Rotate right $BC.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jsr ($F8B8.w,X)		; FC B8 F8 ; Jump to subroutine indirect indexed ($F8B8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldy #$E0.b		; A0 E0 ; Load #$E0.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FE22.w,X)		; FC 22 FE ; Jump to subroutine indirect indexed ($FE22.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$0B.b		; E0 0B ; Compare #$0B.b with X register [Reads: X Index] [Flags: ZNC]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($05.b),Y		; 11 05 ; OR accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $37.b,S		; 03 37 ; OR accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $070E.w		; 0E 0E 07 ; Arithmetic shift left $070E.w [Flags: ZNC]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: ZNC]
	and #$1E.b		; 29 1E ; Logical AND #$1E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sta $14.b,S		; 83 14 ; Store accumulator (stack relative) $14.b,S [Reads: Accumulator, Stack Pointer]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $A2FFB0.l,X		; FF B0 FF A2 ; Subtract with carry (long,X) $A2FFB0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FF05.w,X		; FE 05 FF ; Increment memory $FF05.w,X [Reads: X Index] [Flags: ZN]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E7737C.l,X		; FF 7C 73 E7 ; Subtract with carry (long,X) $E7737C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$3B.b],Y		; F7 3B ; Subtract with carry (long indexed) [$3B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $85.b,S		; 03 85 ; OR accumulator with stack relative $85.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	ora $0C0D.w		; 0D 0D 0C ; Logical OR $0C0D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $1E29.w		; 1C 29 1E ; Test and reset bits $1E29.w [Reads: Accumulator] [Flags: Z]
	sbc $227F30.l,X		; FF 30 7F 22 ; Subtract with carry (long,X) $227F30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $3F05.w,X		; 7E 05 3F ; Rotate right $3F05.w,X [Reads: X Index] [Flags: ZNC]
	tsb $9F.b		; 04 9F ; Test and set bits $9F.b [Reads: Accumulator] [Flags: Z]
	cop $87.b		; 02 87 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$4C.b		; E0 4C ; Compare #$4C.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($6773.w,X)		; FC 73 67 ; Jump to subroutine indirect indexed ($6773.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and [$9B.b],Y		; 37 9B ; AND accumulator with memory (long indexed) [$9B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Accumulator, Direct Page]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2E0F14.l		; 0F 14 0F 2E ; OR accumulator with memory (long) $2E0F14.l [Writes: Accumulator] [Flags: ZN]
	ora $1E2B.w,X		; 1D 2B 1E ; OR accumulator with memory $1E2B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor ($3F.b,X)		; 41 3F ; Exclusive OR accumulator with memory ($3F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($3F.b),Y		; 51 3F ; Exclusive OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	adc $117F95.l,X		; 7F 95 7F 11 ; Add long $117F95.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $2E.b		; 14 2E ; Test and reset bits $2E.b [Reads: Accumulator] [Flags: Z]
	and $BF5F5F.l		; 2F 5F 5F BF ; AND accumulator with memory (long) $BF5F5F.l [Writes: Accumulator] [Flags: ZN]
	lda $5DFFAA.l,X		; BF AA FF 5D ; Load long $5DFFAA.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $1FFFBE.l,X		; FF BE FF 1F ; Subtract with carry (long,X) $1FFFBE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $8F7F9F.l,X		; FF 9F 7F 8F ; Subtract with carry (long,X) $8F7F9F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $F03FC3.l,X		; 7F C3 3F F0 ; Add long $F03FC3.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $BFFFFF.l		; 0F FF FF BF ; OR accumulator with memory (long) $BFFFFF.l [Writes: Accumulator] [Flags: ZN]
	ora $C38F9F.l,X		; 1F 9F 8F C3 ; Logical OR long $C38F9F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $AC		; F0 AC ; Branch if equal to $F0, $AC [Flow: branch]
	sbc $B3FC7B.l,X		; FF 7B FC B3 ; Subtract with carry (long,X) $B3FC7B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F8C7.w,X		; FD C7 F8 ; Subtract with carry $F8C7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $FDFFE1.l,X		; 9F E1 FF FD ; Store accumulator (long,X) $FDFFE1.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sbc $FCFFD5.l,X		; FF D5 FF FC ; Subtract with carry (long,X) $FCFFD5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc ($C7.b,S),Y		; F3 C7 ; Subtract with carry (stack relative indirect indexed) ($C7.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $07FF22.l,X		; 9F 22 FF 07 ; Store accumulator (long,X) $07FF22.l,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $70, $F4		; 70 F4 ; Branch if overflow set to $70, $F4 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $F8.b		; 84 F8 ; Store Y register to $F8.b [Reads: Y Index]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr ($8A07.w,X)		; FC 07 8A ; Jump to subroutine indirect indexed ($8A07.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($FC52.w,X)		; FC 52 FC ; Jump to subroutine indirect indexed ($FC52.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	pea $FCF4.w		; F4 F4 FC ; Push absolute address $FCF4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and $FA.b,S		; 23 FA ; AND accumulator with stack relative $FA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7F.b		; 05 7F ; Logical OR $7F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $DD5DE3.l		; 22 E3 5D DD ; Jump to subroutine long $DD5DE3.l [Writes: Stack Pointer] [Flow: call]
	adc $77FF44.l,X		; 7F 44 FF 77 ; Add long $77FF44.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc [$02.b],Y		; 77 02 ; Add with carry (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $DD.b,S		; 63 DD ; Add with carry (stack relative) $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	sbc $24.b,S		; E3 24 ; Subtract stack-relative $24.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp ($E0.b,X)		; C1 E0 ; Compare accumulator ($E0.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	eor $B320F3.l,X		; 5F F3 20 B3 ; Exclusive OR accumulator with memory (long,X) $B320F3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $70, $FB		; 70 FB ; Branch if overflow set to $70, $FB [Flow: branch]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $FF48.w,Y		; F9 48 FF ; Subtract with carry $FF48.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $6EFD.w		; 20 FD 6E ; Jump to subroutine at $6EFD.w [Writes: Stack Pointer] [Flow: call]
	sbc $FFFD.w,X		; FD FD FF ; Subtract with carry $FFFD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFB7F5.l,X		; FF F5 B7 FF ; Subtract with carry (long,X) $FFB7F5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $BF007D.l,X		; FF 7D 00 BF ; Subtract with carry (long,X) $BF007D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($5E.b,X)		; 41 5E ; Exclusive OR accumulator with memory ($5E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $3C.b		; 26 3C ; Rotate left $3C.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $7E08.w,X		; 3E 08 7E ; Rotate left $7E08.w,X [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	adc [$31.b],Y		; 77 31 ; Add with carry (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	adc $4986.w,X		; 7D 86 49 ; Add $4986.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$33.b],Y		; 37 33 ; AND accumulator with memory (long indexed) [$33.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor ($4E.b,X)		; 41 4E ; Exclusive OR accumulator with memory ($4E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$80.b],Y		; 57 80 ; Exclusive OR accumulator with memory (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7D		; 80 7D ; Branch always to $80, $7D [Flow: branch]
	.db $62, $3A, $14		; 62 3A 14 ; Push effective relative address $62, $3A, $14 [Writes: Stack Pointer]
	jmp ($7E10.w,X)		; 7C 10 7E ; Jump indirect indexed to ($7E10.w,X) [Reads: X Index] [Flow: jump]
	trb $8CEF.w		; 1C EF 8C ; Test and reset bits $8CEF.w [Reads: Accumulator] [Flags: Z]
	eor $8014.w,X		; 5D 14 80 ; Exclusive OR accumulator with memory $8014.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $EA91.w,X		; 7E 91 EA ; Rotate right $EA91.w,X [Reads: X Index] [Flags: ZNC]
	cpy $7382.w		; CC 82 73 ; Compare $7382.w with Y register [Reads: Y Index] [Flags: ZNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $3C06.w		; 0E 06 3C ; Arithmetic shift left $3C06.w [Flags: ZNC]
	tsb $047C.w		; 0C 7C 04 ; Test and set bits $047C.w [Reads: Accumulator] [Flags: Z]
	lsr $2F22.w,X		; 5E 22 2F ; Logical shift right $2F22.w,X [Reads: X Index] [Flags: ZNC]
	ora ($2D.b),Y		; 11 2D ; OR accumulator with memory ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: ZNC]
	and ($5B.b,S),Y		; 33 5B ; AND accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $22.b		; 45 22 ; Exclusive OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $AA84.w		; 20 84 AA ; Jump to subroutine at $AA84.w [Writes: Stack Pointer] [Flow: call]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $3E		; 30 3E ; Branch if minus to $30, $3E [Flow: branch]
	.db $30, $7F		; 30 7F ; Branch if minus to $30, $7F [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inc $FD80.w,X		; FE 80 FD ; Increment memory $FD80.w,X [Reads: X Index] [Flags: ZN]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $C8		; 90 C8 ; Branch if carry clear to $90, $C8 [Flow: branch]
	dec $42B9.w		; CE B9 42 ; Decrement $42B9.w [Flags: ZN]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b],Y		; 17 01 ; OR accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $105C04.l		; 2F 04 5C 10 ; AND accumulator with memory (long) $105C04.l [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $3B.b,X		; 16 3B ; Arithmetic shift left $3B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc $070027.l		; 6F 27 00 07 ; Add with carry (long) $070027.l [Writes: Accumulator] [Flags: ZVNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $FA		; 90 FA ; Branch if carry clear to $90, $FA [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rol $2304.w,X		; 3E 04 23 ; Rotate left $2304.w,X [Reads: X Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($FAD6.w)		; 6C D6 FA ; Jump indirect to ($FAD6.w) [Flow: jump]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $0203.w		; 9C 03 02 ; Store zero to $0203.w
	ror $002E.w,X		; 7E 2E 00 ; Rotate right $002E.w,X [Reads: X Index] [Flags: ZNC]
	.db $62, $00, $03		; 62 00 03 ; Push effective relative address $62, $00, $03 [Writes: Stack Pointer]
	ora $3B.b,X		; 15 3B ; OR accumulator with memory $3B.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $002351.l		; 6F 51 23 00 ; Add with carry (long) $002351.l [Writes: Accumulator] [Flags: ZVNC]
	ora ($80.b,S),Y		; 13 80 ; OR accumulator (stack relative indirect indexed) ($80.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $68		; 80 68 ; Branch always to $80, $68 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	pea $3A20.w		; F4 20 3A ; Push absolute address $3A20.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ror $0074.w,X		; 7E 74 00 ; Rotate right $0074.w,X [Reads: X Index] [Flags: ZNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	jmp.w [$8AF6]		; DC F6 8A ; Jump long indirect [$8AF6] [Flow: jump]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	pea $0000.w		; F4 00 00 ; Push absolute address $0000.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: ZN]
	asl $84.b		; 06 84 ; Arithmetic shift left $84.b [Reads: Direct Page] [Flags: ZNC]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $010D.w		; 8C 0D 01 ; Store Y register to $010D.w [Reads: Y Index]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $1B.b		; 84 1B ; Store Y register to $1B.b [Reads: Y Index]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $B57FAA.l,X		; 3F AA 7F B5 ; AND accumulator with memory (long,X) $B57FAA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $573F5B.l,X		; 7F 5B 3F 57 ; Add long $573F5B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $211E2F.l,X		; 3F 2F 1E 21 ; AND accumulator with memory (long,X) $211E2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $1827.w,X		; 1E 27 18 ; Arithmetic shift left $1827.w,X [Reads: X Index] [Flags: ZNC]
	trb $BF03.w		; 1C 03 BF ; Test and reset bits $BF03.w [Reads: Accumulator] [Flags: Z]
	lda $2F5F5F.l,X		; BF 5F 5F 2F ; Load long $2F5F5F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($27.b,X)		; 21 27 ; Logical AND ($27.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	trb $83FC.w		; 1C FC 83 ; Test and reset bits $83FC.w [Reads: Accumulator] [Flags: Z]
	sbc $A3DC80.l,X		; FF 80 DC A3 ; Subtract with carry (long,X) $A3DC80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $7B.b		; 84 7B ; Store Y register to $7B.b [Reads: Y Index]
	cpx $CE7B.w		; EC 7B CE ; Compare $CE7B.w with X register [Reads: X Index] [Flags: ZNC]
	sbc $F98E.w,Y		; F9 8E F9 ; Subtract with carry $F98E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor [$FC.b],Y		; 57 FC ; Exclusive OR accumulator with memory (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($DCFF.w,X)		; FC FF DC ; Jump to subroutine indirect indexed ($DCFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sty $FC.b		; 84 FC ; Store Y register to $FC.b [Reads: Y Index]
	inc $FFFE.w,X		; FE FE FF ; Increment memory $FFFE.w,X [Reads: X Index] [Flags: ZN]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $7E7FB5.l,X		; FF B5 7F 7E ; Subtract with carry (long,X) $7E7FB5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $5FFFBF.l,X		; FF BF FF 5F ; Subtract with carry (long,X) $5FFFBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1AFF2F.l,X		; FF 2F FF 1A ; Subtract with carry (long,X) $1AFF2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $43FF05.l,X		; FF 05 FF 43 ; Subtract with carry (long,X) $43FF05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $2EE0BF.l,X		; 7F BF E0 2E ; Add long $2EE0BF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $051A2F.l,X		; 5F 2F 1A 05 ; Exclusive OR accumulator with memory (long,X) $051A2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	jsr ($FC52.w,X)		; FC 52 FC ; Jump to subroutine indirect indexed ($FC52.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	nop		; EA ; No operation
	jsr ($F8D4.w,X)		; FC D4 F8 ; Jump to subroutine indirect indexed ($F8D4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy $B8.b		; C4 B8 ; Compare $B8.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $B0, $D0		; B0 D0 ; Branch if carry set to $B0, $D0 [Flow: branch]
	ldy #$60.b		; A0 60 ; Load #$60.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $80, $FA		; 80 FA ; Branch always to $80, $FA [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	nop		; EA ; No operation
	pei ($C4.b)		; D4 C4 ; Push effective indirect address ($C4.b) [Reads: Direct Page] [Writes: Stack Pointer]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $D0, $60		; D0 60 ; Branch if not equal to $D0, $60 [Flow: branch]
	sbc $5CFF3E.l,X		; FF 3E FF 5C ; Subtract with carry (long,X) $5CFF3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $387F40.l,X		; FF 40 7F 38 ; Subtract with carry (long,X) $387F40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$3F.b],Y		; 77 3F ; Add with carry (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $07071F.l,X		; 1F 1F 07 07 ; Logical OR long $07071F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $2384FF.l,X		; FF FF 84 23 ; Subtract with carry (long,X) $2384FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $34DF70.l,X		; FF 70 DF 34 ; Subtract with carry (long,X) $34DF70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1CFE02.l,X		; FF 02 FE 1C ; Subtract with carry (long,X) $1CFE02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $6CFC.w		; CE FC 6C ; Decrement $6CFC.w [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $9CFEFE.l,X		; FF FE FE 9C ; Subtract with carry (long,X) $9CFEFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: ZNC]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $052600.l,X		; 1F 00 26 05 ; Logical OR long $052600.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $06470F.l		; 2F 0F 47 06 ; AND accumulator with memory (long) $06470F.l [Writes: Accumulator] [Flags: ZN]
	adc $003E0E.l,X		; 7F 0E 3E 00 ; Add long $003E0E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $79		; 30 79 ; Branch if minus to $30, $79 [Flow: branch]
	adc ($3E.b),Y		; 71 3E ; Add with carry ($3E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FAE8.w,Y		; F9 E8 FA ; Subtract with carry $FAE8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($3C20.w,X)		; FC 20 3C ; Jump to subroutine indirect indexed ($3C20.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$2A.b		; E0 2A ; Compare #$2A.b with X register [Reads: X Index] [Flags: ZNC]
	ora [$36.b],Y		; 17 36 ; OR accumulator with memory (long indexed) [$36.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp.w [$88C4]		; DC C4 88 ; Jump long indirect [$88C4] [Flow: jump]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1E0D13.l,X		; 1F 13 0D 1E ; Logical OR long $1E0D13.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $270F2F.l,X		; 1F 2F 0F 27 ; Logical OR long $270F2F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: ZNC]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: ZNC]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1D.b)		; 12 1D ; OR accumulator with memory (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $3930.w		; 20 30 39 ; Jump to subroutine at $3930.w [Writes: Stack Pointer] [Flow: call]
	and $BD1E.w,Y		; 39 1E BD ; AND accumulator with memory $BD1E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpy $8D.b		; C4 8D ; Compare $8D.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	pea $364F.w		; F4 4F 36 ; Push absolute address $364F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ror $FC40.w,X		; 7E 40 FC ; Rotate right $FC40.w,X [Reads: X Index] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	trb $0B.b		; 14 0B ; Test and reset bits $0B.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cmp #$BE.b		; C9 BE ; Compare #$BE.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	tsb $00F8.w		; 0C F8 00 ; Test and set bits $00F8.w [Reads: Accumulator] [Flags: Z]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $1BFB.w		; 4E FB 1B ; Logical shift right $1BFB.w [Flags: ZNC]
	lda $BF15.w,X		; BD 15 BF ; Load $BF15.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($EE.b,X)		; 21 EE ; Logical AND ($EE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $2CE000.l		; 22 00 E0 2C ; Jump to subroutine long $2CE000.l [Writes: Stack Pointer] [Flow: call]
	lda ($E4.b),Y		; B1 E4 ; Load accumulator ($E4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	nop		; EA ; No operation
	cld		; D8 ; Clear decimal flag [Flags: D]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	lsr $01.b		; 46 01 ; Logical shift right $01.b [Reads: Direct Page] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $D4.b,X		; 74 D4 ; Store zero to $D4.b,X [Reads: X Index]
	cpy #$AE.b		; C0 AE ; Compare #$AE.b with Y register [Reads: Y Index] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	.db $90, $7A		; 90 7A ; Branch if carry clear to $90, $7A [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	nop		; EA ; No operation
	.db $80, $8E		; 80 8E ; Branch always to $80, $8E [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $2E76.w,X		; 3C 76 2E ; Test bits $2E76.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inc $6E.b,X		; F6 6E ; Increment memory $6E.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $7B.b		; 04 7B ; Test and set bits $7B.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor $7F15.w,X		; 5D 15 7F ; Exclusive OR accumulator with memory $7F15.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($BE.b),Y		; 11 BE ; OR accumulator with memory ($BE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $01A7.w		; 20 A7 01 ; Jump to subroutine at $01A7.w [Writes: Stack Pointer] [Flow: call]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsl $741400.l		; 22 00 14 74 ; Jump to subroutine long $741400.l [Writes: Stack Pointer] [Flow: call]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	inc $A1.b		; E6 A1 ; Increment $A1.b [Reads: Direct Page] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $BA		; D0 BA ; Branch if not equal to $D0, $BA [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	inc $7D88.w,X		; FE 88 7D ; Increment memory $7D88.w,X [Reads: X Index] [Flags: ZN]
	tsb $E5.b		; 04 E5 ; Test and set bits $E5.b [Reads: Accumulator] [Flags: Z]
	.db $80, $87		; 80 87 ; Branch always to $80, $87 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $2E0600.l		; 22 00 06 2E ; Jump to subroutine long $2E0600.l [Writes: Stack Pointer] [Flow: call]
	lsr $16.b,X		; 56 16 ; Logical shift right $16.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	adc [$85.b]		; 67 85 ; Add with carry (long) [$85.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0700.w,Y		; 19 00 07 ; OR accumulator with memory $0700.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F0B.w		; 0D 0B 0F ; Logical OR $0F0B.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $5C.b		; 84 5C ; Store Y register to $5C.b [Reads: Y Index]
	cop $14.b		; 02 14 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $FF.b		; 85 FF ; Store accumulator to $FF.b [Reads: Accumulator]
	sty $FF.b		; 84 FF ; Store Y register to $FF.b [Reads: Y Index]
.ACCU 16
	rep #$67		; C2 67
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($67.b,S),Y		; 73 67 ; Add with carry (stack relative indirect indexed) ($67.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$3B.b],Y		; 77 3B ; Add with carry (long indexed) [$3B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda [$A0.b]		; A7 A0 ; Load accumulator (long) [$A0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	asl $4301.w,X		; 1E 01 43 ; Arithmetic shift left $4301.w,X [Reads: X Index] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0707.w,X		; 1E 07 07 ; Arithmetic shift left $0707.w,X [Reads: X Index] [Flags: ZNC]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $FF57FC.l		; AF FC 57 FF ; Load long $FF57FC.l into accumulator [Writes: Accumulator] [Flags: ZN]
	eor $CF.b,S		; 43 CF ; Exclusive OR accumulator with stack relative $CF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $1FE704.l,X		; 3F 04 E7 1F ; AND accumulator with memory (long,X) $1FE704.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $FF1400.l		; 22 00 14 FF ; Jump to subroutine long $FF1400.l [Writes: Stack Pointer] [Flow: call]
	adc $E7CFDF.l,X		; 7F DF CF E7 ; Add long $E7CFDF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
.INDEX 8
	sep #$1F		; E2 1F
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	and $FF80C0.l,X		; 3F C0 80 FF ; AND accumulator with memory (long,X) $FF80C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $E20500.l		; 22 00 05 E2 ; Jump to subroutine long $E20500.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	.db $80, $07		; 80 07 ; Branch always to $80, $07 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $1C65E0.l,X		; FF E0 65 1C ; Subtract with carry (long,X) $1C65E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0E13.w		; 1C 13 0E ; Test and reset bits $0E13.w [Reads: Accumulator] [Flags: Z]
	ora #$0603.w		; 09 03 06 ; Logical OR #$0603.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $6E.b,S		; 03 6E ; OR accumulator with stack relative $6E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $D7.b,S		; 03 D7 ; OR accumulator with stack relative $D7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $3E1C.w		; 2D 1C 3E ; Logical AND $3E1C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($0D.b,S),Y		; 13 0D ; OR accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$6F.b]		; 07 6F ; OR accumulator with memory (long) [$6F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sta $0038.w,X		; 9D 38 00 ; Store accumulator to $0038.w,X [Reads: Accumulator, X Index]
	jmp ($C838.w,X)		; 7C 38 C8 ; Jump indirect indexed to ($C838.w,X) [Reads: X Index] [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $C0		; 90 C0 ; Branch if carry clear to $90, $C0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$36.b		; C0 36 ; Compare #$36.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$6D.b		; C0 6D ; Compare #$6D.b with Y register [Reads: Y Index] [Flags: ZNC]
	pei ($CF.b)		; D4 CF ; Push effective indirect address ($CF.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ldy $38.b,X		; B4 38 ; Load Y register $38.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	jmp ($B0D8.w,X)		; 7C D8 B0 ; Jump indirect indexed to ($B0D8.w,X) [Reads: X Index] [Flow: jump]
	cpx #$F6.b		; E0 F6 ; Compare #$F6.b with X register [Reads: X Index] [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda $0038.w,Y		; B9 38 00 ; Load $0038.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stz $38.b		; 64 38 ; Store zero to $38.b
	adc [$3C.b],Y		; 77 3C ; Add with carry (long indexed) [$3C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$18.b],Y		; 37 18 ; AND accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $0D3A18.l,X		; 3F 18 3A 0D ; AND accumulator with memory (long,X) $0D3A18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $6F1E.w,Y		; 79 1E 6F ; Add $6F1E.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($3C7F.w,X)		; 7C 7F 3C ; Jump indirect indexed to ($3C7F.w,X) [Reads: X Index] [Flow: jump]
	bit $5F1D.w,X		; 3C 1D 5F ; Test bits $5F1D.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lsr $0000.w,X		; 5E 00 00 ; Logical shift right $0000.w,X [Reads: X Index] [Flags: ZNC]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $58B4.w		; 20 B4 58 ; Jump to subroutine at $58B4.w [Writes: Stack Pointer] [Flow: call]
	trb $9CE0.w		; 1C E0 9C ; Test and reset bits $9CE0.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $0018.w,X		; FE 18 00 ; Increment memory $0018.w,X [Reads: X Index] [Flags: ZN]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	jmp ($FC7C.w,X)		; 7C 7C FC ; Jump indirect indexed to ($FC7C.w,X) [Reads: X Index] [Flow: jump]
	jsr ($6D7C.w,X)		; FC 7C 6D ; Jump to subroutine indirect indexed ($6D7C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FB.b		; 04 FB ; Test and set bits $FB.b [Reads: Accumulator] [Flags: Z]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	sbc $7F4300.l,X		; FF 00 43 7F ; Subtract with carry (long,X) $7F4300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $506000.l,X		; 3F 00 60 50 ; AND accumulator with memory (long,X) $506000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc #$F6F7.w		; E9 F7 F6 ; Subtract #$F6F7.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	ror $7B.b,X		; 76 7B ; Rotate right $7B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and $008043.l,X		; 3F 43 80 00 ; AND accumulator with memory (long,X) $008043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F8,$00		; 44 00 F8 ; Move block positive $F8,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	trb $18E4.w		; 1C E4 18 ; Test and reset bits $18E4.w [Reads: Accumulator] [Flags: Z]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	bit $86.b,X		; 34 86 ; Test bits $86.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp ($FA76.w,X)		; 7C 76 FA ; Jump indirect indexed to ($FA76.w,X) [Reads: X Index] [Flow: jump]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	bit $07.b		; 24 07 ; Test bits $07.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $04.b,S		; 23 04 ; AND accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $230F00.l		; 0F 00 0F 23 ; OR accumulator with memory (long) $230F00.l [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $000025.l		; 0F 25 00 00 ; OR accumulator with memory (long) $000025.l [Writes: Accumulator] [Flags: ZN]
	.db $F0, $44		; F0 44 ; Branch if equal to $F0, $44 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $82.b,S		; 83 82 ; Store accumulator (stack relative) $82.b,S [Reads: Accumulator, Stack Pointer]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1902.w		; 0D 02 19 ; Logical OR $1902.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ror $83.b		; 66 83 ; Rotate right $83.b [Reads: Direct Page] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $84FF00.l,X		; DF 00 FF 84 ; Compare accumulator (long,X) $84FF00.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	lda ($00.b,X)		; A1 00 ; Load accumulator ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	eor [$DF.b]		; 47 DF ; Exclusive OR accumulator with memory (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $E00000.l,X		; FF 00 00 E0 ; Subtract with carry (long,X) $E00000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $7B.b		; 84 7B ; Store Y register to $7B.b [Reads: Y Index]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $00, $0B		; 82 00 0B ; Branch always long to $82, $00, $0B [Flow: branch]
	sta $7A.b		; 85 7A ; Store accumulator to $7A.b [Reads: Accumulator]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jmp ($FB76.w,X)		; 7C 76 FB ; Jump indirect indexed to ($FB76.w,X) [Reads: X Index] [Flow: jump]
	sbc $5C43.w,X		; FD 43 5C ; Subtract with carry $5C43.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0D1E43.l		; 0F 43 1E 0D ; OR accumulator with memory (long) $0D1E43.l [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lsr $1E0D.w,X		; 5E 0D 1E ; Logical shift right $1E0D.w,X [Reads: X Index] [Flags: ZNC]
	ora $0F1F.w		; 0D 1F 0F ; Logical OR $0F1F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $1F1F07.l		; 2F 07 1F 1F ; AND accumulator with memory (long) $1F1F07.l [Writes: Accumulator] [Flags: ZN]
	ora $221D.w,X		; 1D 1D 22 ; OR accumulator with memory $221D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3A0F04.l,X		; 1F 04 0F 3A ; Logical OR long $3A0F04.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $1A		; F0 1A ; Branch if equal to $F0, $1A [Flow: branch]
	.db $F0, $43		; F0 43 ; Branch if equal to $F0, $43 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $B0, $0B		; B0 0B ; Branch if carry set to $B0, $0B [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $B0, $58		; B0 58 ; Branch if carry set to $B0, $58 [Flow: branch]
	.db $B0, $78		; B0 78 ; Branch if carry set to $B0, $78 [Flow: branch]
	.db $F0, $B4		; F0 B4 ; Branch if equal to $F0, $B4 [Flow: branch]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jsl $F015F8.l		; 22 F8 15 F0 ; Jump to subroutine long $F015F8.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $3F		; 70 3F ; Branch if overflow set to $70, $3F [Flow: branch]
	adc ($3D.b)		; 72 3D ; Add with carry (indirect) ($3D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	and $B9.b,X		; 35 B9 ; Logical AND $B9.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $7D.b,X		; 16 7D ; Arithmetic shift left $7D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	jmp $0F1E0B.l		; 5C 0B 1E 0F ; Jump long to $0F1E0B.l [Flow: jump]
	ora $7D7F0F.l,X		; 1F 0F 7F 7D ; Logical OR long $7D7F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $37.b,X		; 75 37 ; Add $37.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $031F22.l,X		; 3F 22 1F 03 ; AND accumulator with memory (long,X) $031F22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $D0, $80		; D0 80 ; Branch if not equal to $D0, $80 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cpy #$06.b		; C0 06 ; Compare #$06.b with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$64.b		; C0 64 ; Compare #$64.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$E4.b		; C0 E4 ; Compare #$E4.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$68.b		; C0 68 ; Compare #$68.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $E025C0.l		; 22 C0 25 E0 ; Jump to subroutine long $E025C0.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0F1F00.l		; 0F 00 1F 0F ; OR accumulator with memory (long) $0F1F00.l [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $381D32.l,X		; 1F 32 1D 38 ; Logical OR long $381D32.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $430E1D.l,X		; 1F 1D 0E 43 ; Logical OR long $430E1D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $1C07.w		; 0E 07 1C ; Arithmetic shift left $1C07.w [Flags: ZNC]
	ora $3D3F1F.l		; 0F 1F 3F 3D ; OR accumulator with memory (long) $3D3F1F.l [Writes: Accumulator] [Flags: ZN]
	and $0F0F1E.l,X		; 3F 1E 0F 0F ; AND accumulator with memory (long,X) $0F0F1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	.db $70, $A0		; 70 A0 ; Branch if overflow set to $70, $A0 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $D0, $B8		; D0 B8 ; Branch if not equal to $D0, $B8 [Flow: branch]
	.db $50, $98		; 50 98 ; Branch if overflow clear to $50, $98 [Flow: branch]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $B0		; F0 B0 ; Branch if equal to $F0, $B0 [Flow: branch]
	jsl $3CE0F8.l		; 22 F8 E0 3C ; Jump to subroutine long $3CE0F8.l [Writes: Stack Pointer] [Flow: call]
	adc $187F17.l,X		; 7F 17 7F 18 ; Add long $187F17.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $3E0E.w,X		; 1D 0E 3E ; OR accumulator with memory $3E0E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $182F.w,X		; 1D 2F 18 ; OR accumulator with memory $182F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $182C0C.l,X		; 1F 0C 2C 18 ; Logical OR long $182C0C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3D1F.w,X		; 3E 1F 3D ; Rotate left $3D1F.w,X [Reads: X Index] [Flags: ZNC]
	rol $3C1F.w,X		; 3E 1F 3C ; Rotate left $3C1F.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $FEE8.w,X		; 9E E8 FE ; Store zero to $FEE8.w,X [Reads: X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	.db $70, $74		; 70 74 ; Branch if overflow set to $70, $74 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	pea $F818.w		; F4 18 F8 ; Push absolute address $F818.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($BCF8.w,X)		; 7C F8 BC ; Jump indirect indexed to ($BCF8.w,X) [Reads: X Index] [Flow: jump]
	jmp ($3CF8.w,X)		; 7C F8 3C ; Jump indirect indexed to ($3CF8.w,X) [Reads: X Index] [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$76.b]		; 27 76 ; AND accumulator with memory (long) [$76.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $2F7F.w		; 0D 7F 2F ; Logical OR $2F7F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	lda $26C743.l,X		; BF 43 C7 26 ; Load long $26C743.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$1E.b]		; 27 1E ; AND accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0022.w,X		; 1E 22 00 ; Arithmetic shift left $0022.w,X [Reads: X Index] [Flags: ZNC]
	asl $7F5F.w,X		; 1E 5F 7F ; Arithmetic shift left $7F5F.w,X [Reads: X Index] [Flags: ZNC]
	adc $3F79FD.l,X		; 7F FD 79 3F ; Add long $3F79FD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $DF00.w,X		; 1E 00 DF ; Arithmetic shift left $DF00.w,X [Reads: X Index] [Flags: ZNC]
	cpx $6D.b		; E4 6D ; Compare $6D.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	ldy $FE.b,X		; B4 FE ; Load Y register $FE.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $F0, $FD		; F0 FD ; Branch if equal to $F0, $FD [Flow: branch]
.ACCU 16
	rep #$E2		; C2 E2
	stz $E4.b		; 64 E4 ; Store zero to $E4.b
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	inc $9EBF.w,X		; FE BF 9E ; Increment memory $9EBF.w,X [Reads: X Index] [Flags: ZN]
	jsr ($4470.w,X)		; FC 70 44 ; Jump to subroutine indirect indexed ($4470.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3F1200.l		; 22 00 12 3F ; Jump to subroutine long $3F1200.l [Writes: Stack Pointer] [Flow: call]
	bit $1F1C.w,X		; 3C 1C 1F ; Test bits $1F1C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $000C1E.l,X		; 1F 1E 0C 00 ; Logical OR long $000C1E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $4A.b,X		; B5 4A ; Load $4A.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp #$6536.w		; C9 36 65 ; Compare #$6536.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $A202.w,X		; FD 02 A2 ; Subtract with carry $A202.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E206FF.l		; 22 FF 06 E2 ; Jump to subroutine long $E206FF.l [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FF,$00		; 44 00 FF ; Move block positive $FF,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $E7.b		; 86 E7 ; Store X register to $E7.b [Reads: X Index]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $E2FD7F.l,X		; 1F 7F FD E2 ; Logical OR long $E2FD7F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $0C1E1F.l,X		; 7F 1F 1E 0C ; Add long $0C1E1F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $78.b		; 86 78 ; Store X register to $78.b [Reads: X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsl $25E0FF.l		; 22 FF E0 25 ; Jump to subroutine long $25E0FF.l [Writes: Stack Pointer] [Flow: call]
	sep #$C0		; E2 C0 ; Set processor status bits #$C0 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	inc $7E.b		; E6 7E ; Increment $7E.b [Reads: Direct Page] [Flags: ZN]
	and $0E1F1F.l,X		; 3F 1F 1F 0E ; AND accumulator with memory (long,X) $0E1F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $CA62.w,X		; 9D 62 CA ; Store accumulator to $CA62.w,X [Reads: Accumulator, X Index]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $FAFF.w,Y		; 19 FF FA ; OR accumulator with memory $FAFF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $074F07.l		; 2F 07 4F 07 ; AND accumulator with memory (long) $074F07.l [Writes: Accumulator] [Flags: ZN]
	and [$03.b]		; 27 03 ; AND accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $071D03.l		; 0F 03 1D 07 ; OR accumulator with memory (long) $071D03.l [Writes: Accumulator] [Flags: ZN]
	and $3B1F.w,X		; 3D 1F 3B ; AND accumulator with memory $3B1F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	ora $5F830F.l		; 0F 0F 83 5F ; OR accumulator with memory (long) $5F830F.l [Writes: Accumulator] [Flags: ZN]
	ora ($1A.b,X)		; 01 1A ; Logical OR ($1A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $E0341C.l,X		; 3F 1C 34 E0 ; AND accumulator with memory (long,X) $E0341C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda ($E0.b)		; B2 E0 ; Load accumulator (indirect) ($E0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx $C0.b		; E4 C0 ; Compare $C0.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$E4.b		; E0 E4 ; Compare #$E4.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	pea $3838.w		; F4 38 38 ; Push absolute address $3838.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($38FC.w,X)		; FC FC 38 ; Jump to subroutine indirect indexed ($38FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl $0744.w		; 0E 44 07 ; Arithmetic shift left $0744.w [Flags: ZNC]
	and $030F09.l		; 2F 09 0F 03 ; AND accumulator with memory (long) $030F09.l [Writes: Accumulator] [Flags: ZN]
	ora $3507.w,Y		; 19 07 35 ; OR accumulator with memory $3507.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $1E1E3F.l,X		; 1F 3F 1E 1E ; Logical OR long $1E1E3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F1F16.l		; 0F 16 1F 3F ; OR accumulator with memory (long) $3F1F16.l [Writes: Accumulator] [Flags: ZN]
	and $C0601E.l,X		; 3F 1E 60 C0 ; AND accumulator with memory (long,X) $C0601E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$EC.b		; C0 EC ; Compare #$EC.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $D0, $8A		; D0 8A ; Branch if not equal to $D0, $8A [Flow: branch]
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr $0030.w		; 20 30 00 ; Jump to subroutine at $0030.w [Writes: Stack Pointer] [Flow: call]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $192701.l,X		; 1F 01 27 19 ; Logical OR long $192701.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($0F.b,S),Y		; 73 0F ; Add with carry (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $003F0F.l,X		; 7F 0F 3F 00 ; Add long $003F0F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $3F7F7F.l,X		; 3F 7F 7F 3F ; AND accumulator with memory (long,X) $3F7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $F0, $D8		; F0 D8 ; Branch if equal to $F0, $D8 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$30.b		; E0 30 ; Compare #$30.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C8.b		; C0 C8 ; Compare #$C8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $83		; F0 83 ; Branch if equal to $F0, $83 [Flow: branch]
	cmp ($01.b)		; D2 01 ; Compare accumulator (indirect) ($01.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	jsl $F011F8.l		; 22 F8 11 F0 ; Jump to subroutine long $F011F8.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($0078.w,X)		; FC 78 00 ; Jump to subroutine indirect indexed ($0078.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $42BD.w,X		; 3C BD 42 ; Test bits $42BD.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc [$7E.b]		; E7 7E ; Subtract with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C3C.w,X		; 7E 3C 3C ; Rotate right $3C3C.w,X [Reads: X Index] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $3C.b		; 06 3C ; Arithmetic shift left $3C.b [Reads: Direct Page] [Flags: ZNC]
	ror $FFFF.w,X		; 7E FF FF ; Rotate right $FFFF.w,X [Reads: X Index] [Flags: ZNC]
	ror $003C.w,X		; 7E 3C 00 ; Rotate right $003C.w,X [Reads: X Index] [Flags: ZNC]
	eor $1C.b,S		; 43 1C ; Exclusive OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0D1E47.l		; 0F 47 1E 0D ; OR accumulator with memory (long) $0D1E47.l [Writes: Accumulator] [Flags: ZN]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF840F.l		; 0F 0F 84 FF ; OR accumulator with memory (long) $FF840F.l [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $380F04.l,X		; 1F 04 0F 38 ; Logical OR long $380F04.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $98		; F0 98 ; Branch if equal to $F0, $98 [Flow: branch]
	.db $70, $47		; 70 47 ; Branch if overflow set to $70, $47 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $B0, $07		; B0 07 ; Branch if carry set to $B0, $07 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $B0		; F0 B0 ; Branch if equal to $F0, $B0 [Flow: branch]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jsl $F000F8.l		; 22 F8 00 F0 ; Jump to subroutine long $F000F8.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $078E07.l		; 2F 07 8E 07 ; AND accumulator with memory (long) $078E07.l [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $01.b		; 66 01 ; Rotate right $01.b [Reads: Direct Page] [Flags: ZNC]
	ora $0002.w		; 0D 02 00 ; Logical OR $0002.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb INIDSP.w		; 0C 00 21 ; Test and set bits INIDSP.w [Reads: Accumulator] [Flags: Z]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1FBF.w		; 1C BF 1F ; Test and reset bits $1FBF.w [Reads: Accumulator] [Flags: Z]
	adc $233F.w,Y		; 79 3F 23 ; Add $233F.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3F3F.w		; 1C 3F 3F ; Test and reset bits $3F3F.w [Reads: Accumulator] [Flags: Z]
	adc $020025.l,X		; 7F 25 00 02 ; Add long $020025.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $800200.l		; 22 00 02 80 ; Jump to subroutine long $800200.l [Writes: Stack Pointer] [Flow: call]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $80, $27		; 80 27 ; Branch always to $80, $27 [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b],Y		; 17 01 ; OR accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $105C04.l		; 2F 04 5C 10 ; AND accumulator with memory (long) $105C04.l [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $3B.b,X		; 16 3B ; Arithmetic shift left $3B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc $070027.l		; 6F 27 00 07 ; Add with carry (long) $070027.l [Writes: Accumulator] [Flags: ZVNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $FA		; 90 FA ; Branch if carry clear to $90, $FA [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rol $2304.w,X		; 3E 04 23 ; Rotate left $2304.w,X [Reads: X Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($FAD6.w)		; 6C D6 FA ; Jump indirect to ($FAD6.w) [Flow: jump]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $0203.w		; 9C 03 02 ; Store zero to $0203.w
	ror $002E.w,X		; 7E 2E 00 ; Rotate right $002E.w,X [Reads: X Index] [Flags: ZNC]
	.db $62, $00, $03		; 62 00 03 ; Push effective relative address $62, $00, $03 [Writes: Stack Pointer]
	ora $3B.b,X		; 15 3B ; OR accumulator with memory $3B.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $002351.l		; 6F 51 23 00 ; Add with carry (long) $002351.l [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	pea $3A20.w		; F4 20 3A ; Push absolute address $3A20.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ror $0074.w,X		; 7E 74 00 ; Rotate right $0074.w,X [Reads: X Index] [Flags: ZNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	jmp.w [$8AF6]		; DC F6 8A ; Jump long indirect [$8AF6] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F00.w		; 0E 00 1F ; Arithmetic shift left $1F00.w [Flags: ZNC]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	and $007F10.l,X		; 3F 10 7F 00 ; AND accumulator with memory (long,X) $007F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $0E0000.l,X		; BF 00 00 0E ; Load long $0E0000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	bit $3F3F.w,X		; 3C 3F 3F ; Test bits $3F3F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	adc $0000FF.l,X		; 7F FF 00 00 ; Add long $0000FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	jsr ($FE0B.w,X)		; FC 0B FE ; Jump to subroutine indirect indexed ($FE0B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $00A0.w,X		; BD A0 00 ; Load $00A0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $D8		; 70 D8 ; Branch if overflow set to $70, $D8 [Flow: branch]
	ldy $FCFC.w,X		; BC FC FC ; Load Y register $FCFC.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	ldx $235F.w,Y		; BE 5F 23 ; Load X register $235F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $003F00.l		; 0F 00 3F 00 ; OR accumulator with memory (long) $003F00.l [Writes: Accumulator] [Flags: ZN]
	adc $30CF10.l		; 6F 10 CF 30 ; Add with carry (long) $30CF10.l [Writes: Accumulator] [Flags: ZVNC]
	sta [$6C.b],Y		; 97 6C ; Store accumulator (long indexed) [$6C.b],Y [Reads: Accumulator, Direct Page, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $9F8F4F.l,X		; 3F 4F 8F 9F ; AND accumulator with memory (long,X) $9F8F4F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $DA.b,S		; 83 DA ; Store accumulator (stack relative) $DA.b,S [Reads: Accumulator, Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FC.b		; 24 FC ; Test bits $FC.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc #$0036.w		; E9 36 00 ; Subtract #$0036.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	sbc ($F1.b)		; F2 F1 ; Subtract with carry (indirect) ($F1.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0003.w,Y		; F9 03 00 ; Subtract with carry $0003.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $3E07.w		; 0E 07 3E ; Arithmetic shift left $3E07.w [Flags: ZNC]
	ora [$7C.b]		; 07 7C ; OR accumulator with memory (long) [$7C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$FC.b],Y		; 37 FC ; AND accumulator with memory (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $BA7FC4.l		; 6F C4 7F BA ; Add with carry (long) $BA7FC4.l [Writes: Accumulator] [Flags: ZVNC]
	eor [$03.b]		; 47 03 ; Exclusive OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $FF227F.l,X		; 3F 7F 22 FF ; AND accumulator with memory (long,X) $FF227F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $6A.b,S		; 83 6A ; Store accumulator (stack relative) $6A.b,S [Reads: Accumulator, Stack Pointer]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	bit $1EF0.w,X		; 3C F0 1E ; Test bits $1EF0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	pea $FE1F.w		; F4 1F FE ; Push absolute address $FE1F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and $E0C0FE.l,X		; 3F FE C0 E0 ; AND accumulator with memory (long,X) $E0C0FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	jsr ($FFFE.w,X)		; FC FE FF ; Jump to subroutine indirect indexed ($FFFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $830027.l,X		; FF 27 00 83 ; Subtract with carry (long,X) $830027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $50, $03		; 50 03 ; Branch if overflow clear to $50, $03 [Flow: branch]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $07030F.l		; 22 0F 03 07 ; Jump to subroutine long $07030F.l [Writes: Stack Pointer] [Flow: call]
	ora $920707.l		; 0F 07 07 92 ; OR accumulator with memory (long) $920707.l [Writes: Accumulator] [Flags: ZN]
	adc $02.b,X		; 75 02 ; Add $02.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsb $30.b		; 04 30 ; Test and set bits $30.b [Reads: Accumulator] [Flags: Z]
	cpx #$B0.b		; E0 B0 ; Compare #$B0.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	sta ($8D.b)		; 92 8D ; Store accumulator (indirect) ($8D.b) [Reads: Accumulator, Direct Page]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0200.w		; 1C 00 02 ; Test and reset bits $0200.w [Reads: Accumulator] [Flags: Z]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7F,$00		; 44 00 7F ; Move block positive $7F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1C0800.l		; 22 00 08 1C ; Jump to subroutine long $1C0800.l [Writes: Stack Pointer] [Flow: call]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($47.b,X)		; 41 47 ; Exclusive OR accumulator with memory ($47.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $18001C.l		; 22 1C 00 18 ; Jump to subroutine long $18001C.l [Writes: Stack Pointer] [Flow: call]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $12.b		; 24 12 ; Test bits $12.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	lda $9900.w,X		; BD 00 99 ; Load $9900.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $42, $BD		; 42 BD ; Reserved instruction
	.db $42, $7E		; 42 7E ; Reserved instruction
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $6624.w,X		; 3C 24 66 ; Test bits $6624.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc [$BD.b]		; E7 BD ; Subtract with carry (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda $437E.w,X		; BD 7E 43 ; Load $437E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	eor $2C.b,S		; 43 2C ; Exclusive OR accumulator with stack relative $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	eor $2C.b,S		; 43 2C ; Exclusive OR accumulator with stack relative $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $16		; 10 16 ; Branch if plus to $10, $16 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3434.w,X		; 3C 34 34 ; Test bits $3434.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $3434.w,X		; 3C 34 34 ; Test bits $3434.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $FB4E.w,X		; FE 4E FB ; Increment memory $FB4E.w,X [Reads: X Index] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda $BF15.w,X		; BD 15 BF ; Load $BF15.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($EE.b,X)		; 21 EE ; Logical AND ($EE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $2CE000.l		; 22 00 E0 2C ; Jump to subroutine long $2CE000.l [Writes: Stack Pointer] [Flow: call]
	lda ($E4.b),Y		; B1 E4 ; Load accumulator ($E4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	nop		; EA ; No operation
	cld		; D8 ; Clear decimal flag [Flags: D]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	lsr $01.b		; 46 01 ; Logical shift right $01.b [Reads: Direct Page] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $D4.b,X		; 74 D4 ; Store zero to $D4.b,X [Reads: X Index]
	cpy #$AE.b		; C0 AE ; Compare #$AE.b with Y register [Reads: Y Index] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	.db $90, $7A		; 90 7A ; Branch if carry clear to $90, $7A [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	nop		; EA ; No operation
	.db $80, $8E		; 80 8E ; Branch always to $80, $8E [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $2E76.w,X		; 3C 76 2E ; Test bits $2E76.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inc $6E.b,X		; F6 6E ; Increment memory $6E.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $7B.b		; 04 7B ; Test and set bits $7B.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor $7F15.w,X		; 5D 15 7F ; Exclusive OR accumulator with memory $7F15.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($BE.b),Y		; 11 BE ; OR accumulator with memory ($BE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $01A7.w		; 20 A7 01 ; Jump to subroutine at $01A7.w [Writes: Stack Pointer] [Flow: call]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsl $741400.l		; 22 00 14 74 ; Jump to subroutine long $741400.l [Writes: Stack Pointer] [Flow: call]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	inc $A1.b		; E6 A1 ; Increment $A1.b [Reads: Direct Page] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $BA		; D0 BA ; Branch if not equal to $D0, $BA [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	inc $7D88.w,X		; FE 88 7D ; Increment memory $7D88.w,X [Reads: X Index] [Flags: ZN]
	tsb $E5.b		; 04 E5 ; Test and set bits $E5.b [Reads: Accumulator] [Flags: Z]
	.db $80, $87		; 80 87 ; Branch always to $80, $87 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $44E000.l		; 22 00 E0 44 ; Jump to subroutine long $44E000.l [Writes: Stack Pointer] [Flow: call]
	rol $1656.w		; 2E 56 16 ; Rotate left $1656.w [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	adc [$85.b]		; 67 85 ; Add with carry (long) [$85.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $57FF10.l,X		; BF 10 FF 57 ; Load long $57FF10.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor $086A.w,Y		; 59 6A 08 ; Exclusive OR accumulator with memory $086A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and $003F10.l,X		; 3F 10 3F 00 ; AND accumulator with memory (long,X) $003F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000701.l,X		; 1F 01 07 00 ; Logical OR long $000701.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $77A6A8.l		; EF A8 A6 77 ; Subtract with carry (long) $77A6A8.l [Writes: Accumulator] [Flags: ZVNC]
	and $071E3F.l		; 2F 3F 1E 07 ; AND accumulator with memory (long) $071E3F.l [Writes: Accumulator] [Flags: ZN]
	lda $3F90.w,X		; BD 90 3F ; Load $3F90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cmp $10569A.l,X		; DF 9A 56 10 ; Compare accumulator (long,X) $10569A.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	jsr ($FC08.w,X)		; FC 08 FC ; Jump to subroutine indirect indexed ($FC08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $65.b,X		; D5 65 ; Compare accumulator $65.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inc $FCF4.w		; EE F4 FC ; Increment $FCF4.w [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx #$DA.b		; E0 DA ; Compare #$DA.b with X register [Reads: X Index] [Flags: ZNC]
	and $587F.w		; 2D 7F 58 ; Logical AND $587F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cmp $CBA1.w,Y		; D9 A1 CB ; Compare accumulator $CBA1.w,Y [Reads: Y Index] [Flags: ZNC]
	adc ($FF.b)		; 72 FF ; Add with carry (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $7F.b,X		; 76 7F ; Rotate right $7F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	asl $0022.w,X		; 1E 22 00 ; Arithmetic shift left $0022.w,X [Reads: X Index] [Flags: ZNC]
	trb $DE.b		; 14 DE ; Test and reset bits $DE.b [Reads: Accumulator] [Flags: Z]
	lda $F9FD7E.l,X		; BF 7E FD F9 ; Load long $F9FD7E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $001E.w,X		; 7D 1E 00 ; Add $001E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	ldy $7E.b,X		; B4 7E ; Load Y register $7E.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ora $73.b		; 05 73 ; Logical OR $73.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $DEFF.w,X		; 5E FF DE ; Logical shift right $DEFF.w,X [Reads: X Index] [Flags: ZNC]
	inc $7858.w,X		; FE 58 78 ; Increment memory $7858.w,X [Reads: X Index] [Flags: ZN]
	jsl $37E000.l		; 22 00 E0 37 ; Jump to subroutine long $37E000.l [Writes: Stack Pointer] [Flow: call]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $BFFE.w,X		; 7D FE BF ; Add $BFFE.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $0078BE.l,X		; 3F BE 78 00 ; AND accumulator with memory (long,X) $0078BE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $3E2B.w,X		; 7D 2B 3E ; Add $3E2B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $021F.w,Y		; 19 1F 02 ; OR accumulator with memory $021F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1C3C1F.l,X		; 3F 1F 3C 1C ; AND accumulator with memory (long,X) $1C3C1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0F0E.w,X		; 1E 0E 0F ; Arithmetic shift left $0F0E.w,X [Reads: X Index] [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $23201D.l,X		; 3F 1D 20 23 ; AND accumulator with memory (long,X) $23201D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $FB.b,S		; 03 FB ; OR accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr ($F806.w,X)		; FC 06 F8 ; Jump to subroutine indirect indexed ($F806.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $50, $38		; 50 38 ; Branch if overflow clear to $50, $38 [Flow: branch]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $70F8.w,X		; FE F8 70 ; Increment memory $70F8.w,X [Reads: X Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	sbc $002FE0.l,X		; FF E0 2F 00 ; Subtract with carry (long,X) $002FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $27.b		; 06 27 ; Arithmetic shift left $27.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $40BF20.l,X		; 5F 20 BF 40 ; Exclusive OR accumulator with memory (long,X) $40BF20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $003F00.l,X		; FF 00 3F 00 ; Subtract with carry (long,X) $003F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $5F27.w,Y		; 19 27 5F ; OR accumulator with memory $5F27.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $003FFF.l,X		; BF FF 3F 00 ; Load long $003FFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F7.b,S		; 03 F7 ; OR accumulator with stack relative $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$0300.w		; 09 00 03 ; Logical OR #$0300.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cmp $FB.b		; C5 FB ; Compare $FB.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc [$F5.b],Y		; F7 F5 ; Subtract with carry (long indexed) [$F5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $F4.b,X		; F6 F4 ; Increment memory $F4.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $0001.w		; 0C 01 00 ; Test and set bits $0001.w [Reads: Accumulator] [Flags: Z]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	adc $00.b,S		; 63 00 ; Add with carry (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $00.b,S		; 63 00 ; Add with carry (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	sbc $02.b,X		; F5 02 ; Subtract $02.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1E8500.l,X		; FF 00 85 1E ; Subtract with carry (long,X) $1E8500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0B.b,X		; F5 0B ; Subtract $0B.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FB.b,X		; F5 FB ; Subtract $FB.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F6.b,X		; F5 F6 ; Subtract $F6.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and #$4400.w		; 29 00 44 ; Logical AND #$4400.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $001701.l		; 22 01 17 00 ; Jump to subroutine long $001701.l [Writes: Stack Pointer] [Flow: call]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inc $7C00.w,X		; FE 00 7C ; Increment memory $7C00.w,X [Reads: X Index] [Flags: ZN]
	.db $80, $76		; 80 76 ; Branch always to $80, $76 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $B7FB.w,X		; 7D FB B7 ; Add $B7FB.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$77.b],Y		; F7 77 ; Subtract with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $37.b,X		; 75 37 ; Add $37.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3F00.w		; 1C 00 3F ; Test and reset bits $3F00.w [Reads: Accumulator] [Flags: Z]
	sty $007B.w		; 8C 7B 00 ; Store Y register to $007B.w [Reads: Y Index]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $008A85.l,X		; 3F 85 8A 00 ; AND accumulator with memory (long,X) $008A85.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx $33.b		; E4 33 ; Compare $33.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F1807.l		; 0F 07 18 0F ; OR accumulator with memory (long) $0F1807.l [Writes: Accumulator] [Flags: ZN]
	ora $430F.w,Y		; 19 0F 43 ; OR accumulator with memory $430F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $0003.w		; 0E 03 00 ; Arithmetic shift left $0003.w [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $231F23.l		; 0F 23 1F 23 ; OR accumulator with memory (long) $231F23.l [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx #$3E.b		; E0 3E ; Compare #$3E.b with X register [Reads: X Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	lda $76DDEE.l,X		; BF EE DD 76 ; Load long $76DDEE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $07.b		; 46 07 ; Logical shift right $07.b [Reads: Direct Page] [Flags: ZNC]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $020023.l		; 0F 23 00 02 ; OR accumulator with memory (long) $020023.l [Writes: Accumulator] [Flags: ZN]
	sbc $49FF00.l,X		; FF 00 FF 49 ; Subtract with carry (long,X) $49FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $F3.b,S		; 83 F3 ; Store accumulator (stack relative) $F3.b,S [Reads: Accumulator, Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1C00.w		; 2D 00 1C ; Logical AND $1C00.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$70.b]		; 07 70 ; OR accumulator with memory (long) [$70.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $C71F61.l		; 0F 61 1F C7 ; OR accumulator with memory (long) $C71F61.l [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $70381C.l		; 0F 1C 38 70 ; OR accumulator with memory (long) $70381C.l [Writes: Accumulator] [Flags: ZN]
	adc ($C7.b,X)		; 61 C7 ; Add with carry ($C7.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1FE000.l,X		; FF 00 E0 1F ; Subtract with carry (long,X) $1FE000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $E03FEF.l,X		; 1F EF 3F E0 ; Logical OR long $E03FEF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $CF		; 70 CF ; Branch if overflow set to $70, $CF [Flow: branch]
	cmp $BF.b,S		; C3 BF ; Compare accumulator (stack relative) $BF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	cmp [$3F.b]		; C7 3F ; Compare accumulator (long) [$3F.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc $E0FF5F.l		; EF 5F FF E0 ; Subtract with carry (long) $E0FF5F.l [Writes: Accumulator] [Flags: ZVNC]
	ora $C3703F.l,X		; 1F 3F 70 C3 ; Logical OR long $C3703F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$EF.b]		; C7 EF ; Compare accumulator (long) [$EF.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	ora $2C0100.l		; 0F 00 01 2C ; OR accumulator with memory (long) $2C0100.l [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $002501.l		; 0F 01 25 00 ; OR accumulator with memory (long) $002501.l [Writes: Accumulator] [Flags: ZN]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $2A.b,S		; 43 2A ; Exclusive OR accumulator with stack relative $2A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0FFF.w,X		; FE FF 0F ; Increment memory $0FFF.w,X [Reads: X Index] [Flags: ZN]
	ora $143E3E.l,X		; 1F 3E 3E 14 ; Logical OR long $143E3E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	ora $0E0200.l		; 0F 00 02 0E ; OR accumulator with memory (long) $0E0200.l [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora $040E0F.l		; 0F 0F 0E 04 ; OR accumulator with memory (long) $040E0F.l [Writes: Accumulator] [Flags: ZN]
	jsl $FF0A00.l		; 22 00 0A FF ; Jump to subroutine long $FF0A00.l [Writes: Stack Pointer] [Flow: call]
	ora ($BF.b,X)		; 01 BF ; Logical OR ($BF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora #$153F.w		; 09 3F 15 ; Logical OR #$153F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl $FC.b		; 06 FC ; Arithmetic shift left $FC.b [Reads: Direct Page] [Flags: ZNC]
	ldx $3F1F.w,Y		; BE 1F 3F ; Load X register $3F1F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	and $470012.l,X		; 3F 12 00 47 ; AND accumulator with memory (long,X) $470012.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF03.w,X		; FD 03 FF ; Subtract with carry $FF03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$15FF.w		; 09 FF 15 ; Logical OR #$15FF.w with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $F715.w,X		; FE 15 F7 ; Increment memory $F715.w,X [Reads: X Index] [Flags: ZN]
	ora ($E1.b,X)		; 01 E1 ; Logical OR ($E1.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FFFE.w,X)		; FC FE FF ; Jump to subroutine indirect indexed ($FFFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc [$E1.b],Y		; F7 E1 ; Subtract with carry (long indexed) [$E1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $0037.w		; 20 37 00 ; Jump to subroutine at $0037.w [Writes: Stack Pointer] [Flow: call]
	ora ($FD.b,X)		; 01 FD ; Logical OR ($FD.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $3E1101.l,X		; 7F 01 11 3E ; Add long $3E1101.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc $7E7C.w,X		; FE 7C 7E ; Increment memory $7E7C.w,X [Reads: X Index] [Flags: ZN]
	and $0E1F3F.l,X		; 3F 3F 1F 0E ; AND accumulator with memory (long,X) $0E1F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $002FE4.l,X		; 1F E4 2F 00 ; Logical OR long $002FE4.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $051F.w		; 0C 1F 05 ; Test and set bits $051F.w [Reads: Accumulator] [Flags: Z]
	ora [$09.b],Y		; 17 09 ; OR accumulator with memory (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,X		; 15 0F ; OR accumulator with memory $0F.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: ZNC]
	jsl $1F1700.l		; 22 00 17 1F ; Jump to subroutine long $1F1700.l [Writes: Stack Pointer] [Flow: call]
	ora [$11.b],Y		; 17 11 ; OR accumulator with memory (long indexed) [$11.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0B.b,X		; 15 0B ; OR accumulator with memory $0B.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0007.w		; 09 07 00 ; Logical OR #$0007.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sta $8AF6.w,X		; 9D F6 8A ; Store accumulator to $8AF6.w,X [Reads: Accumulator, X Index]
	sbc $79E7.w,X		; FD E7 79 ; Subtract with carry $79E7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $E69F9E.l,X		; 7F 9E 9F E6 ; Add long $E69F9E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7BF5F0.l		; EF F0 F5 7B ; Subtract with carry (long) $7BF5F0.l [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $9F7F04.l,X		; FF 04 7F 9F ; Subtract with carry (long,X) $9F7F04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $437BF5.l		; EF F5 7B 43 ; Subtract with carry (long) $437BF5.l [Writes: Accumulator] [Flags: ZVNC]
	tsb $0507.w		; 0C 07 05 ; Test and set bits $0507.w [Reads: Accumulator] [Flags: Z]
	asl $0B03.w		; 0E 03 0B ; Arithmetic shift left $0B03.w [Flags: ZNC]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $45.b		; 04 45 ; Test and set bits $45.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0B0B01.l		; 0F 01 0B 0B ; OR accumulator with memory (long) $0B0B01.l [Writes: Accumulator] [Flags: ZN]
	jsl $00430A.l		; 22 0A 43 00 ; Jump to subroutine long $00430A.l [Writes: Stack Pointer] [Flow: call]
	sbc $FF0F0B.l,X		; FF 0B 0F FF ; Subtract with carry (long,X) $FF0F0B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $06F9F0.l,X		; FF F0 F9 06 ; Subtract with carry (long,X) $06F9F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
.ACCU 8
.INDEX 8
	sep #$FD		; E2 FD
	cmp $23E3.w,X		; DD E3 23 ; Compare accumulator $23E3.w,X [Reads: X Index] [Flags: ZNC]
	sbc $01F91C.l,X		; FF 1C F9 01 ; Subtract with carry (long,X) $01F91C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $DF.b,S		; E3 DF ; Subtract stack-relative $DF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cpy $9633.w		; CC 33 96 ; Compare $9633.w with Y register [Reads: Y Index] [Flags: ZNC]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda ($4C.b,S),Y		; B3 4C ; Load accumulator (stack relative indirect indexed) ($4C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $B727.w,Y		; F9 27 B7 ; Subtract with carry $B727.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	lda ($6F.b,S),Y		; B3 6F ; Load accumulator (stack relative indirect indexed) ($6F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda [$68.b],Y		; B7 68 ; Load accumulator (long indexed) [$68.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	adc [$CF.b]		; 67 CF ; Add with carry (long) [$CF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta [$B3.b],Y		; 97 B3 ; Store accumulator (long indexed) [$B3.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sbc $B3B7.w,Y		; F9 B7 B3 ; Subtract with carry $B3B7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda [$BB.b],Y		; B7 BB ; Load accumulator (long indexed) [$BB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $5F43.w		; EE 43 5F ; Increment $5F43.w [Flags: ZN]
	cpx $DF0A.w		; EC 0A DF ; Compare $DF0A.w with X register [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	lda $F47FB3.l,X		; BF B3 7F F4 ; Load long $F47FB3.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DB7EB9.l,X		; FF B9 7E DB ; Subtract with carry (long,X) $DB7EB9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $EF22.w,X		; BD 22 EF ; Load $EF22.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $DF.b		; 04 DF ; Test and set bits $DF.b [Reads: Accumulator] [Flags: Z]
	lda $DEBFFF.l,X		; BF FF BF DE ; Load long $DEBFFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	mvp $00,$01		; 44 01 00 ; Move block positive $00,$01 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $002701.l		; 22 01 27 00 ; Jump to subroutine long $002701.l [Writes: Stack Pointer] [Flow: call]
	ora [$80.b]		; 07 80 ; OR accumulator with memory (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	sta ($EF.b,X)		; 81 EF ; Store accumulator ($EF.b,X) [Reads: Accumulator, X Index, Direct Page]
	cmp $23.b,S		; C3 23 ; Compare accumulator (stack relative) $23.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($80.b,S),Y		; 33 80 ; AND accumulator (stack relative indirect indexed) ($80.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp ($C3.b,X)		; C1 C3 ; Compare accumulator ($C3.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc $040003.l		; EF 03 00 04 ; Subtract with carry (long) $040003.l [Writes: Accumulator] [Flags: ZVNC]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$16.b]		; 07 16 ; OR accumulator with memory (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $EE0BF5.l		; 0F F5 0B EE ; OR accumulator with memory (long) $EE0BF5.l [Writes: Accumulator] [Flags: ZN]
	cmp $D86F.w,Y		; D9 6F D8 ; Compare accumulator $D86F.w,Y [Reads: Y Index] [Flags: ZNC]
	and $0403FD.l		; 2F FD 03 04 ; AND accumulator with memory (long) $0403FD.l [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$F5.b],Y		; 17 F5 ; OR accumulator with memory (long indexed) [$F5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	nop		; EA ; No operation
	sbc #$ED.b		; E9 ED ; Subtract #$ED.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $5EC0.w		; 20 C0 5E ; Jump to subroutine at $5EC0.w [Writes: Stack Pointer] [Flow: call]
	cpx #$6B.b		; E0 6B ; Compare #$6B.b with X register [Reads: X Index] [Flags: ZNC]
	inc $AD.b,X		; F6 AD ; Increment memory $AD.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cmp ($76.b,S),Y		; D3 76 ; Compare accumulator (stack relative indirect indexed) ($76.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sbc [$1B.b],Y		; F7 1B ; Subtract with carry (long indexed) [$1B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $BF.b,X		; F5 BF ; Subtract $BF.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$20.b		; C0 20 ; Compare #$20.b with Y register [Reads: Y Index] [Flags: ZNC]
	dec $ADEB.w,X		; DE EB AD ; Decrement memory $ADEB.w,X [Reads: X Index] [Flags: ZN]
	eor [$97.b],Y		; 57 97 ; Exclusive OR accumulator with memory (long indexed) [$97.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $23.b,X		; B5 23 ; Load $23.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	cmp $82.b		; C5 82 ; Compare $82.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc $C67DC6.l		; EF C6 7D C6 ; Subtract with carry (long) $C67DC6.l [Writes: Accumulator] [Flags: ZVNC]
	bit $00CB.w,X		; 3C CB 00 ; Test bits $00CB.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$C7.b]		; 87 C7 ; Store accumulator (long) [$C7.b] [Reads: Accumulator, Direct Page]
	sbc $2BBCFD.l		; EF FD BC 2B ; Subtract with carry (long) $2BBCFD.l [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $90, $E0		; 90 E0 ; Branch if carry clear to $90, $E0 [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$31.b		; E0 31 ; Compare #$31.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	.db $82, $82, $01		; 82 82 01 ; Branch always long to $82, $82, $01 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($88.b,X)		; 81 88 ; Store accumulator ($88.b,X) [Reads: Accumulator, X Index, Direct Page]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C64.w,Y		; 19 64 0C ; OR accumulator with memory $0C64.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $82.b		; 06 82 ; Arithmetic shift left $82.b [Reads: Direct Page] [Flags: ZNC]
	eor ($03.b,X)		; 41 03 ; Exclusive OR accumulator with memory ($03.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta ($08.b,X)		; 81 08 ; Store accumulator ($08.b,X) [Reads: Accumulator, X Index, Direct Page]
	and $4440.w,Y		; 39 40 44 ; AND accumulator with memory $4440.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C4E.w,X		; 1D 4E 0C ; OR accumulator with memory $0C4E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$9E.b]		; E7 9E ; Subtract with carry (long) [$9E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp ($B4.b,X)		; C1 B4 ; Compare accumulator ($B4.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sta $FACF75.l,X		; 9F 75 CF FA ; Store accumulator (long,X) $FACF75.l,X [Reads: Accumulator, X Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	tsb $B59F.w		; 0C 9F B5 ; Test and set bits $B59F.w [Reads: Accumulator] [Flags: Z]
	sbc $31E4EB.l,X		; FF EB E4 31 ; Subtract with carry (long,X) $31E4EB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $2D5F34.l		; 4F 34 5F 2D ; Exclusive OR accumulator with memory (long) $2D5F34.l [Writes: Accumulator] [Flags: ZN]
	adc [$1E.b]		; 67 1E ; Add with carry (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor [$3E.b]		; 47 3E ; Exclusive OR accumulator with memory (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $0006.w,Y		; 39 06 00 ; AND accumulator with memory $0006.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $7F7F.w,X		; 3C 7F 7F ; Test bits $7F7F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	adc [$47.b]		; 67 47 ; Add with carry (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $F283.w,Y		; 39 83 F2 ; AND accumulator with memory $F283.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $3C.b		; 66 3C ; Rotate right $3C.b [Reads: Direct Page] [Flags: ZNC]
	inc $0E0C.w,X		; FE 0C 0E ; Increment memory $0E0C.w,X [Reads: X Index] [Flags: ZN]
	pea $F886.w		; F4 86 F8 ; Push absolute address $F886.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sta $F3CCF4.l		; 8F F4 CC F3 ; Store accumulator (long) $F3CCF4.l [Reads: Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $227E.w,X		; 3C 7E 22 ; Test bits $227E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inc $FF01.w,X		; FE 01 FF ; Increment memory $FF01.w,X [Reads: X Index] [Flags: ZN]
	cmp $050A4F.l		; CF 4F 0A 05 ; Compare accumulator (long) $050A4F.l [Reads: Accumulator] [Flags: ZNC]
	and [$0A.b]		; 27 0A ; AND accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $FB.b		; E5 FB ; Subtract $FB.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $FDFD.w,X		; FE FD FD ; Increment memory $FDFD.w,X [Reads: X Index] [Flags: ZN]
	inc $AEFD.w,X		; FE FD AE ; Increment memory $AEFD.w,X [Reads: X Index] [Flags: ZN]
	ldx $FF23.w		; AE 23 FF ; Load $FF23.w into X register [Writes: X Index] [Flags: ZN]
	ora $D5.b,S		; 03 D5 ; OR accumulator with stack relative $D5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cmp $FF.b,X		; D5 FF ; Compare accumulator $FF.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $83.b		; E5 83 ; Subtract $83.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	sbc $6CB30F.l,X		; FF 0F B3 6C ; Subtract with carry (long,X) $6CB30F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda [$6B.b],Y		; B7 6B ; Load accumulator (long indexed) [$6B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ldx $6A.b,Y		; B6 6A ; Load X register $6A.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	sta [$6B.b],Y		; 97 6B ; Store accumulator (long indexed) [$6B.b],Y [Reads: Accumulator, Direct Page, Y Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $AB.b,X		; 35 AB ; Logical AND $AB.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	stz $A4.b,X		; 74 A4 ; Store zero to $A4.b,X [Reads: X Index]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta ($7C.b,S),Y		; 93 7C ; Store accumulator (stack relative indirect indexed) ($7C.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	.db $62, $B3, $E0		; 62 B3 E0 ; Push effective relative address $62, $B3, $E0 [Writes: Stack Pointer]
	bit #$94.b		; 89 94 ; Test bits #$94.b with accumulator [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ldy $6A9F.w,X		; BC 9F 6A ; Load Y register $6A9F.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	jmp.w [$6EB5]		; DC B5 6E ; Jump long indirect [$6EB5] [Flow: jump]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda [$78.b],Y		; B7 78 ; Load accumulator (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor [$FB.b],Y		; 57 FB ; Exclusive OR accumulator with memory (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$EC.b],Y		; D7 EC ; Compare accumulator (long indexed) [$EC.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	and ($D7.b,S),Y		; 33 D7 ; AND accumulator (stack relative indirect indexed) ($D7.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $6F1FE0.l		; EF E0 1F 6F ; Subtract with carry (long) $6F1FE0.l [Writes: Accumulator] [Flags: ZVNC]
	lda [$5B.b],Y		; B7 5B ; Load accumulator (long indexed) [$5B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx $EFD7.w		; EC D7 EF ; Compare $EFD7.w with X register [Reads: X Index] [Flags: ZNC]
	ora $0F1200.l		; 0F 00 12 0F ; OR accumulator with memory (long) $0F1200.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: ZNC]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0608.w,X		; 1E 08 06 ; Arithmetic shift left $0608.w,X [Reads: X Index] [Flags: ZNC]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	ora $CF7206.l		; 0F 06 72 CF ; OR accumulator with memory (long) $CF7206.l [Writes: Accumulator] [Flags: ZN]
	adc $F5A7.w,Y		; 79 A7 F5 ; Add $F5A7.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $E7DA7B.l		; EF 7B DA E7 ; Subtract with carry (long) $E7DA7B.l [Writes: Accumulator] [Flags: ZVNC]
	rol $DF.b		; 26 DF ; Rotate left $DF.b [Reads: Direct Page] [Flags: ZNC]
	sbc ($0E.b),Y		; F1 0E ; Subtract with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $7301.w		; 0E 01 73 ; Arithmetic shift left $7301.w [Flags: ZNC]
	adc $EFFD.w,Y		; 79 FD EF ; Add $EFFD.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	rol $F1.b		; 26 F1 ; Rotate left $F1.b [Reads: Direct Page] [Flags: ZNC]
	asl $FFF2.w		; 0E F2 FF ; Arithmetic shift left $FFF2.w [Flags: ZNC]
	lda $12FE.w		; AD FE 12 ; Load $12FE.w into accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $E9BF48.l,X		; FF 48 BF E9 ; Subtract with carry (long,X) $E9BF48.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $6A3FCE.l,X		; 1F CE 3F 6A ; Logical OR long $6A3FCE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta [$BE.b],Y		; 97 BE ; Store accumulator (long indexed) [$BE.b],Y [Reads: Accumulator, Direct Page, Y Index]
	adc #$F2.b		; 69 F2 ; Add #$F2.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	lda $4F1E.w,X		; BD 1E 4F ; Load $4F1E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $BE6ACE.l		; EF CE 6A BE ; Subtract with carry (long) $BE6ACE.l [Writes: Accumulator] [Flags: ZVNC]
	eor $B0FF.w		; 4D FF B0 ; Exclusive OR $B0FF.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $16FD4A.l,X		; 7F 4A FD 16 ; Add long $16FD4A.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FC93.w,Y		; F9 93 FC ; Subtract with carry $FC93.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($FC.b,S),Y		; 73 FC ; Add with carry (stack relative indirect indexed) ($FC.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $EB.b,X		; 55 EB ; Exclusive OR accumulator with memory $EB.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $B84D84.l,X		; 7F 84 4D B8 ; Add long $B84D84.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	inc $F3.b,X		; F6 F3 ; Increment memory $F3.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	adc ($55.b,S),Y		; 73 55 ; Add with carry (stack relative indirect indexed) ($55.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $EEBDDE.l,X		; 7F DE BD EE ; Add long $EEBDDE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $8FF6.w,X		; BD F6 8F ; Load $8FF6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $6FF6.w,Y		; 39 F6 6F ; AND accumulator with memory $6FF6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $88		; F0 88 ; Branch if equal to $F0, $88 [Flow: branch]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	jsl $FE1200.l		; 22 00 12 FE ; Jump to subroutine long $FE1200.l [Writes: Stack Pointer] [Flow: call]
	inc $79F6.w		; EE F6 79 ; Increment $79F6.w [Flags: ZN]
	adc $00F088.l		; 6F 88 F0 00 ; Add with carry (long) $00F088.l [Writes: Accumulator] [Flags: ZVNC]
	jsr $C0C0.w		; 20 C0 C0 ; Jump to subroutine at $C0C0.w [Writes: Stack Pointer] [Flow: call]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$24.b		; C0 24 ; Compare #$24.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $20.b,S		; 43 20 ; Exclusive OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $1E24.w,X		; 3E 24 1E ; Rotate left $1E24.w,X [Reads: X Index] [Flags: ZNC]
	eor [$EA.b]		; 47 EA ; Exclusive OR accumulator with memory (long) [$EA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $7C.b,S		; 03 7C ; OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $6724.w		; 4C 24 67 ; Jump to $6724.w [Flow: jump]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $7D82.w,Y		; 79 82 7D ; Add $7D82.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$FE.b],Y		; 17 FE ; OR accumulator with memory (long indexed) [$FE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx $DB.b		; E4 DB ; Compare $DB.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $7EA1EA.l,X		; 5F EA A1 7E ; Exclusive OR accumulator with memory (long,X) $7EA1EA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $3037.w,Y		; 59 37 30 ; Exclusive OR accumulator with memory $3037.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $B1.b,S		; 03 B1 ; OR accumulator with stack relative $B1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($17.b)		; 92 17 ; Store accumulator (indirect) ($17.b) [Reads: Accumulator, Direct Page]
	inc $B17F.w		; EE 7F B1 ; Increment $B17F.w [Flags: ZN]
	eor $0030.w,Y		; 59 30 00 ; Exclusive OR accumulator with memory $0030.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	sbc $18FF00.l,X		; FF 00 FF 18 ; Subtract with carry (long,X) $18FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	bit $187E.w,X		; 3C 7E 18 ; Test bits $187E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jmp $0C0039.l		; 5C 39 00 0C ; Jump long to $0C0039.l [Flow: jump]
	ora $1F2000.l,X		; 1F 00 20 1F ; Logical OR long $1F2000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $2F		; 70 2F ; Branch if overflow set to $70, $2F [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and [$7F.b],Y		; 37 7F ; AND accumulator with memory (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $31		; 30 31 ; Branch if minus to $30, $31 [Flow: branch]
	asl $221E.w		; 0E 1E 22 ; Arithmetic shift left $221E.w [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7F223F.l,X		; 1F 3F 22 7F ; Logical OR long $7F223F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and ($1E.b),Y		; 31 1E ; AND accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $5F6F98.l		; EF 98 6F 5F ; Subtract with carry (long) $5F6F98.l [Writes: Accumulator] [Flags: ZVNC]
	ldy $BC.b		; A4 BC ; Load $BC.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	jsr ($FE1B.w,X)		; FC 1B FE ; Jump to subroutine indirect indexed ($FE1B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $3D.b,X		; 35 3D ; Logical AND $3D.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $FCBCDF.l,X		; 9F DF BC FC ; Store accumulator (long,X) $FCBCDF.l,X [Reads: Accumulator, X Index]
	inc $073D.w,X		; FE 3D 07 ; Increment memory $073D.w,X [Reads: X Index] [Flags: ZN]
	eor $0A.b,S		; 43 0A ; Exclusive OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $8301.w,X		; 1E 01 83 ; Arithmetic shift left $8301.w,X [Reads: X Index] [Flags: ZNC]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl $0F1E.w,X		; 1E 1E 0F ; Arithmetic shift left $0F1E.w,X [Reads: X Index] [Flags: ZNC]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $EAEA01.l,X		; FF 01 EA EA ; Subtract with carry (long,X) $EAEA01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $00FF43.l,X		; FF 43 FF 00 ; Subtract with carry (long,X) $00FF43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $FFFF00.l		; 0F 00 FF FF ; OR accumulator with memory (long) $FFFF00.l [Writes: Accumulator] [Flags: ZN]
	cmp #$3F.b		; C9 3F ; Compare #$3F.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	stz $1F.b		; 64 1F ; Store zero to $1F.b
	and ($0F.b,S),Y		; 33 0F ; AND accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $CF1F00.l		; 22 00 1F CF ; Jump to subroutine long $CF1F00.l [Writes: Stack Pointer] [Flow: call]
	adc [$33.b]		; 67 33 ; Add with carry (long) [$33.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $000103.l		; 0F 03 01 00 ; OR accumulator with memory (long) $000103.l [Writes: Accumulator] [Flags: ZN]
	ldy #$FF.b		; A0 FF ; Load #$FF.b into Y register [Writes: Y Index] [Flags: ZN]
	mvp $57,$FF		; 44 FF 57 ; Move block positive $57,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $F877F0.l,X		; 7F F0 77 F8 ; Add long $F877F0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc $FF3FCF.l,X		; 7F CF 3F FF ; Add long $FF3FCF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($7F77.w,X)		; 7C 77 7F ; Jump indirect indexed to ($7F77.w,X) [Reads: X Index] [Flow: jump]
	adc [$B8.b],Y		; 77 B8 ; Add with carry (long indexed) [$B8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $E0FFFF.l		; CF FF FF E0 ; Compare accumulator (long) $E0FFFF.l [Reads: Accumulator] [Flags: ZNC]
	ldy $0021.w,X		; BC 21 00 ; Load Y register $0021.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	ror $01.b,X		; 76 01 ; Rotate right $01.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $205F26.l,X		; 5F 26 5F 20 ; Exclusive OR accumulator with memory (long,X) $205F26.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $3F15.w		; 2E 15 3F ; Rotate left $3F15.w [Flags: ZNC]
	asl $3C7F.w		; 0E 7F 3C ; Arithmetic shift left $3C7F.w [Flags: ZNC]
	ror $212D.w,X		; 7E 2D 21 ; Rotate right $212D.w,X [Reads: X Index] [Flags: ZNC]
	eor [$6F.b],Y		; 57 6F ; Exclusive OR accumulator with memory (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $3F.b		; 66 3F ; Rotate right $3F.b [Reads: Direct Page] [Flags: ZNC]
	and $847F7E.l,X		; 3F 7E 7F 84 ; AND accumulator with memory (long,X) $847F7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $DE		; 80 DE ; Branch always to $80, $DE [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	nop		; EA ; No operation
	trb $F4.b		; 14 F4 ; Test and reset bits $F4.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	stz $CE70.w		; 9C 70 CE ; Store zero to $CE70.w
	bit $B45E.w,X		; 3C 5E B4 ; Test bits $B45E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sty $EA.b		; 84 EA ; Store Y register to $EA.b [Reads: Y Index]
	sbc ($76.b)		; F2 76 ; Subtract with carry (indirect) ($76.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($7EFC.w,X)		; 7C FC 7E ; Jump indirect indexed to ($7EFC.w,X) [Reads: X Index] [Flow: jump]
	inc $0001.w,X		; FE 01 00 ; Increment memory $0001.w,X [Reads: X Index] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1F02.w		; 0D 02 1F ; Logical OR $1F02.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($3E.b,X)		; 01 3E ; Logical OR ($3E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$68.b]		; 07 68 ; OR accumulator with memory (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$79.b],Y		; 17 79 ; OR accumulator with memory (long indexed) [$79.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $163D.w		; 2E 3D 16 ; Rotate left $163D.w [Flags: ZNC]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $7F7F2F.l,X		; 1F 2F 7F 7F ; Logical OR long $7F7F2F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $A000C0.l		; 2F C0 00 A0 ; AND accumulator with memory (long) $A000C0.l [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy #$F4.b		; C0 F4 ; Compare #$F4.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($FC80.w,X)		; FC 80 FC ; Jump to subroutine indirect indexed ($FC80.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stx $6C.b,Y		; 96 6C ; Store X register $6C.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	rol $DC.b		; 26 DC ; Rotate left $DC.b [Reads: Direct Page] [Flags: ZNC]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp.w [$9CDC]		; DC DC 9C ; Jump long indirect [$9CDC] [Flow: jump]
	ror $20FE.w,X		; 7E FE 20 ; Rotate right $20FE.w,X [Reads: X Index] [Flags: ZNC]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($5E.b),Y		; 11 5E ; OR accumulator with memory ($5E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1C77.w		; 2D 77 1C ; Logical AND $1C77.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $3D6E3C.l		; 6F 3C 6E 3D ; Add with carry (long) $3D6E3C.l [Writes: Accumulator] [Flags: ZVNC]
	adc [$1C.b],Y		; 77 1C ; Add with carry (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $5F51.w		; 20 51 5F ; Jump to subroutine at $5F51.w [Writes: Stack Pointer] [Flow: call]
	adc $7F7E7F.l,X		; 7F 7F 7E 7F ; Add long $7F7E7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $8E0004.l,X		; 7F 04 00 8E ; Add long $8E0004.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	ldy $CE.b,X		; B4 CE ; Load Y register $CE.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	dec $3C.b		; C6 3C ; Decrement $3C.b [Reads: Direct Page] [Flags: ZN]
	lsr $BC.b		; 46 BC ; Logical shift right $BC.b [Reads: Direct Page] [Flags: ZNC]
	dec $0438.w		; CE 38 04 ; Decrement $0438.w [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	inc $7EFE.w,X		; FE FE 7E ; Increment memory $7EFE.w,X [Reads: X Index] [Flags: ZN]
	inc $40FE.w,X		; FE FE 40 ; Increment memory $40FE.w,X [Reads: X Index] [Flags: ZN]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $E7		; 30 E7 ; Branch if minus to $30, $E7 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sbc $018F00.l,X		; FF 00 8F 01 ; Subtract with carry (long,X) $018F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy #$90.b		; A0 90 ; Load #$90.b into Y register [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($F7.b,S),Y		; F3 F7 ; Subtract with carry (stack relative indirect indexed) ($F7.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b)		; 12 0C ; OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $316E.w,X		; FD 6E 31 ; Subtract with carry $316E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $C0FF.w		; EE FF C0 ; Increment $C0FF.w [Flags: ZN]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E712.w		; 0D 12 E7 ; Logical OR $E712.w with accumulator [Writes: Accumulator] [Flags: ZN]
	jsl $908BFF.l		; 22 FF 8B 90 ; Jump to subroutine long $908BFF.l [Writes: Stack Pointer] [Flow: call]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $FB01.w		; 8E 01 FB ; Store X register to $FB01.w [Reads: X Index]
	ora #$91.b		; 09 91 ; Logical OR #$91.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: ZN]
	ora $BD.b		; 05 BD ; Logical OR $BD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $EE91.w		; 6E 91 EE ; Rotate right $EE91.w [Flags: ZNC]
	sbc $B88440.l,X		; FF 40 84 B8 ; Subtract with carry (long,X) $B88440.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $002043.l,X		; FF 43 20 00 ; Subtract with carry (long,X) $002043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $2F		; 10 2F ; Branch if plus to $10, $2F [Flow: branch]
	eor $14.b,S		; 43 14 ; Exclusive OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol $110A.w		; 2E 0A 11 ; Rotate left $110A.w [Flags: ZNC]
	and $202012.l		; 2F 12 20 20 ; AND accumulator with memory (long) $202012.l [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	rol $2B2B.w		; 2E 2B 2B ; Rotate left $2B2B.w [Flags: ZNC]
	rol $232F.w		; 2E 2F 23 ; Rotate left $232F.w [Flags: ZNC]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	cpy $0200.w		; CC 00 02 ; Compare $0200.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $73		; 30 73 ; Branch if minus to $30, $73 [Flow: branch]
	sty $26F9.w		; 8C F9 26 ; Store Y register to $26F9.w [Reads: Y Index]
	sta $0072.w,X		; 9D 72 00 ; Store accumulator to $0072.w,X [Reads: Accumulator, X Index]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($73CE.w,X)		; FC CE 73 ; Jump to subroutine indirect indexed ($73CE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $43FD.w,Y		; F9 FD 43 ; Subtract with carry $43FD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $8400.w		; 20 00 84 ; Jump to subroutine at $8400.w [Writes: Stack Pointer] [Flow: call]
	pea $4300.w		; F4 00 43 ; Push absolute address $4300.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	trb $2E.b		; 14 2E ; Test and reset bits $2E.b [Reads: Accumulator] [Flags: Z]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $2300.w,X		; FD 00 23 ; Subtract with carry $2300.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0001.w		; 0C 01 00 ; Test and set bits $0001.w [Reads: Accumulator] [Flags: Z]
	adc ($89.b)		; 72 89 ; Add with carry (indirect) ($89.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $F972.w		; 1C 72 F9 ; Test and reset bits $F972.w [Reads: Accumulator] [Flags: Z]
	sbc $00E0.w,X		; FD E0 00 ; Subtract with carry $00E0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	.db $90, $40		; 90 40 ; Branch if carry clear to $90, $40 [Flow: branch]
	sty $E760.w		; 8C 60 E7 ; Store Y register to $E760.w [Reads: Y Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc [$6B.b],Y		; F7 6B ; Subtract with carry (long indexed) [$6B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $67FC77.l,X		; BF 77 FC 67 ; Load long $67FC77.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	stz $F7E7.w		; 9C E7 F7 ; Store zero to $F7E7.w
	sbc $0006FF.l,X		; FF FF 06 00 ; Subtract with carry (long,X) $0006FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $09.b,S		; 43 09 ; Exclusive OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	adc #$31.b		; 69 31 ; Add #$31.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$10.b]		; E7 10 ; Subtract with carry (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $EEFDD6.l		; EF D6 FD EE ; Subtract with carry (long) $EEFDD6.l [Writes: Accumulator] [Flags: ZVNC]
	and $06E6.w,Y		; 39 E6 06 ; AND accumulator with memory $06E6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and [$EF.b],Y		; 37 EF ; AND accumulator with memory (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $7EFFFF.l		; EF FF FF 7E ; Subtract with carry (long) $7EFFFF.l [Writes: Accumulator] [Flags: ZVNC]
	ora $7F.b,X		; 15 7F ; OR accumulator with memory $7F.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	adc $306F29.l,X		; 7F 29 6F 30 ; Add long $306F29.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $19.b,X		; 36 19 ; Rotate left $19.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $030F0B.l,X		; 1F 0B 0F 03 ; Logical OR long $030F0B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $797277.l		; 6F 77 72 79 ; Add with carry (long) $797277.l [Writes: Accumulator] [Flags: ZVNC]
	and $070F1F.l,X		; 3F 1F 0F 07 ; AND accumulator with memory (long,X) $070F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $FEA8.w,X		; 7E A8 FE ; Rotate right $FEA8.w,X [Reads: X Index] [Flags: ZNC]
	trb $6A.b		; 14 6A ; Test and reset bits $6A.b [Reads: Accumulator] [Flags: Z]
	tsb $F6.b		; 04 F6 ; Test and set bits $F6.b [Reads: Accumulator] [Flags: Z]
	tsb $9864.w		; 0C 64 98 ; Test and set bits $9864.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $D0, $30		; D0 30 ; Branch if not equal to $D0, $30 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $9EDE.w		; EE DE 9E ; Increment $9EDE.w [Flags: ZN]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: ZNC]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $5B.b		; 04 5B ; Test and set bits $5B.b [Reads: Accumulator] [Flags: Z]
	and $4D.b,S		; 23 4D ; AND accumulator with stack relative $4D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($6B.b),Y		; 31 6B ; AND accumulator with memory ($6B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $2C.b,X		; 34 2C ; Test bits $2C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ora [$1D.b],Y		; 17 1D ; OR accumulator with memory (long indexed) [$1D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7C.b,S		; 23 7C ; AND accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $3F7F.w,X		; 7E 7F 3F ; Rotate right $3F7F.w,X [Reads: X Index] [Flags: ZNC]
	ora $0CF607.l,X		; 1F 07 F6 0C ; Logical OR long $0CF607.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $CE84.w,X		; FE 84 CE ; Increment memory $CE84.w,X [Reads: X Index] [Flags: ZN]
	.db $30, $B4		; 30 B4 ; Branch if minus to $30, $B4 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jmp ($78B8.w,X)		; 7C B8 78 ; Jump indirect indexed to ($78B8.w,X) [Reads: X Index] [Flow: jump]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FC14.w,X		; FE 14 FC ; Increment memory $FC14.w,X [Reads: X Index] [Flags: ZN]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: ZNC]
	asl $2F7F.w,X		; 1E 7F 2F ; Arithmetic shift left $2F7F.w,X [Reads: X Index] [Flags: ZNC]
	adc $143B33.l		; 6F 33 3B 14 ; Add with carry (long) $143B33.l [Writes: Accumulator] [Flags: ZVNC]
	rol $3F07.w,X		; 3E 07 3F ; Rotate left $3F07.w,X [Reads: X Index] [Flags: ZNC]
	ora [$1F.b],Y		; 17 1F ; OR accumulator with memory (long indexed) [$1F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $113F22.l,X		; 7F 22 3F 11 ; Add long $113F22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $78DE03.l,X		; 1F 03 DE 78 ; Logical OR long $78DE03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	pea $CCF2.w		; F4 F2 CC ; Push absolute address $CCF2.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	dec $1C2C.w,X		; DE 2C 1C ; Decrement memory $1C2C.w,X [Reads: X Index] [Flags: ZN]
	cpx #$1C.b		; E0 1C ; Compare #$1C.b with X register [Reads: X Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $33E0.w,X		; FE E0 33 ; Increment memory $33E0.w,X [Reads: X Index] [Flags: ZN]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$9B.b		; C0 9B ; Compare #$9B.b with Y register [Reads: Y Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	adc $7D9F.w,Y		; 79 9F 7D ; Add $7D9F.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	adc $3847.w,X		; 7D 47 38 ; Add $3847.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $1E3F00.l,X		; 3F 00 3F 1E ; AND accumulator with memory (long,X) $1E3F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $8700.w,X		; 1E 00 87 ; Arithmetic shift left $8700.w,X [Reads: X Index] [Flags: ZNC]
	sta [$83.b]		; 87 83 ; Store accumulator (long) [$83.b] [Reads: Accumulator, Direct Page]
	sta $47.b,S		; 83 47 ; Store accumulator (stack relative) $47.b,S [Reads: Accumulator, Stack Pointer]
	and $E11E21.l,X		; 3F 21 1E E1 ; AND accumulator with memory (long,X) $E11E21.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $D22D.w,X		; 1E 2D D2 ; Arithmetic shift left $D22D.w,X [Reads: X Index] [Flags: ZNC]
	lda $B0FCC0.l,X		; BF C0 FC B0 ; Load long $B0FCC0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy $3C30.w		; CC 30 3C ; Compare $3C30.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E1.b		; 00 E1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F0F3.w		; ED F3 F0 ; Subtract $F0F3.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$10.b		; 89 10 ; Test bits #$10.b with accumulator [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0024.w,X		; 3C 24 00 ; Test bits $0024.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sty $20.b		; 84 20 ; Store Y register to $20.b [Reads: Y Index]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta [$28.b]		; 87 28 ; Store accumulator (long) [$28.b] [Reads: Accumulator, Direct Page]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $FC70.w		; EC 70 FC ; Compare $FC70.w with X register [Reads: X Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $7C		; 70 7C ; Branch if overflow set to $70, $7C [Flow: branch]
	sta $37.b,S		; 83 37 ; Store accumulator (stack relative) $37.b,S [Reads: Accumulator, Stack Pointer]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	.db $80, $78		; 80 78 ; Branch always to $80, $78 [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $3D.b		; 04 3D ; Test and set bits $3D.b [Reads: Accumulator] [Flags: Z]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7E.b,X)		; 01 7E ; Logical OR ($7E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3F1F00.l		; 22 00 1F 3F ; Jump to subroutine long $3F1F00.l [Writes: Stack Pointer] [Flow: call]
	and $0202.w,X		; 3D 02 02 ; AND accumulator with memory $0202.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	lda $34FB70.l,X		; BF 70 FB 34 ; Load long $34FB70.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $BF06.w,X		; FD 06 BF ; Subtract with carry $BF06.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	inc $FC30.w,X		; FE 30 FC ; Increment memory $FC30.w,X [Reads: X Index] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FEFFBF.l,X		; FF BF FF FE ; Subtract with carry (long,X) $FEFFBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F804.w,X)		; FC 04 F8 ; Jump to subroutine indirect indexed ($F804.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta [$70.b]		; 87 70 ; Store accumulator (long) [$70.b] [Reads: Accumulator, Direct Page]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0702.w		; 0D 02 07 ; Logical OR $0702.w with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta $80.b,S		; 83 80 ; Store accumulator (stack relative) $80.b,S [Reads: Accumulator, Stack Pointer]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0007.w		; 0D 07 00 ; Logical OR $0007.w with accumulator [Writes: Accumulator] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sta [$02.b]		; 87 02 ; Store accumulator (long) [$02.b] [Reads: Accumulator, Direct Page]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: ZNC]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	trb $841C.w		; 1C 1C 84 ; Test and reset bits $841C.w [Reads: Accumulator] [Flags: Z]
	sta [$02.b],Y		; 97 02 ; Store accumulator (long indexed) [$02.b],Y [Reads: Accumulator, Direct Page, Y Index]
	ora $22F9FF.l		; 0F FF F9 22 ; OR accumulator with memory (long) $22F9FF.l [Writes: Accumulator] [Flags: ZN]
	trb $177E.w		; 1C 7E 17 ; Test and reset bits $177E.w [Reads: Accumulator] [Flags: Z]
	adc $267939.l		; 6F 39 79 26 ; Add with carry (long) $267939.l [Writes: Accumulator] [Flags: ZVNC]
	rol $1B.b,X		; 36 1B ; Rotate left $1B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and [$1D.b],Y		; 37 1D ; AND accumulator with memory (long indexed) [$1D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $C48300.l,X		; 3F 00 83 C4 ; AND accumulator with memory (long,X) $C48300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0C3F22.l,X		; 7F 22 3F 0C ; Add long $0C3F22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $E87E1C.l		; 22 1C 7E E8 ; Jump to subroutine long $E87E1C.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	stz $649A.w		; 9C 9A 64 ; Store zero to $649A.w
	jmp ($FCD8.w,X)		; 7C D8 FC ; Jump indirect indexed to ($FCD8.w,X) [Reads: X Index] [Flow: jump]
	ldy #$F8.b		; A0 F8 ; Load #$F8.b into Y register [Writes: Y Index] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	jsl $FC04FE.l		; 22 FE 04 FC ; Jump to subroutine long $FC04FE.l [Writes: Stack Pointer] [Flow: call]
	jmp.w [$00F8]		; DC F8 00 ; Jump long indirect [$00F8] [Flow: jump]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $01		; 50 01 ; Branch if overflow clear to $50, $01 [Flow: branch]
	eor $09.b,S		; 43 09 ; Exclusive OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $91.b		; 04 91 ; Test and set bits $91.b [Reads: Accumulator] [Flags: Z]
	ror $1001.w		; 6E 01 10 ; Rotate right $1001.w [Flags: ZNC]
	adc $7F8000.l,X		; 7F 00 80 7F ; Add long $7F8000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $007F7F.l,X		; FF 7F 7F 00 ; Subtract with carry (long,X) $007F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $227F06.l		; 0F 06 7F 22 ; OR accumulator with memory (long) $227F06.l [Writes: Accumulator] [Flags: ZN]
	sbc $037F1B.l,X		; FF 1B 7F 03 ; Subtract with carry (long,X) $037F1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $0100.w,X		; FE 00 01 ; Increment memory $0100.w,X [Reads: X Index] [Flags: ZN]
	inc $0AF7.w,X		; FE F7 0A ; Increment memory $0AF7.w,X [Reads: X Index] [Flags: ZN]
	sbc $00FEFE.l,X		; FF FE FE 00 ; Subtract with carry (long,X) $00FEFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	inc $0BFF.w,X		; FE FF 0B ; Increment memory $0BFF.w,X [Reads: X Index] [Flags: ZN]
	sbc $E0C0FE.l,X		; FF FE C0 E0 ; Subtract with carry (long,X) $E0C0FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $27		; F0 27 ; Branch if equal to $F0, $27 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F0,$70		; 44 70 F0 ; Move block positive $F0,$70 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $78.b,S		; 03 78 ; OR accumulator with stack relative $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $0D,$0E		; 44 0E 0D ; Move block positive $0D,$0E [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1E.b,X		; 15 1E ; OR accumulator with memory $1E.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $6F0F0F.l,X		; 1F 0F 0F 6F ; Logical OR long $6F0F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $3F		; 30 3F ; Branch if minus to $30, $3F [Flow: branch]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $030E.w		; 0C 0E 03 ; Test and set bits $030E.w [Reads: Accumulator] [Flags: Z]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	adc $94833C.l,X		; 7F 3C 83 94 ; Add long $94833C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($06.b),Y		; 31 06 ; AND accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$EE.b]		; 07 EE ; OR accumulator with memory (long) [$EE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $02DD.w,Y		; 19 DD 02 ; OR accumulator with memory $02DD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	stz $7E11.w,X		; 9E 11 7E ; Store zero to $7E11.w,X [Reads: X Index]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sta $0DF3.w,X		; 9D F3 0D ; Store accumulator to $0DF3.w,X [Reads: Accumulator, X Index]
	lda $4652.w,X		; BD 52 46 ; Load $4652.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $FBFD.w,X		; BD FD FB ; Load $FBFD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $BFFFDF.l		; EF DF FF BF ; Subtract with carry (long) $BFFFDF.l [Writes: Accumulator] [Flags: ZVNC]
	adc $0000FF.l,X		; 7F FF 00 00 ; Add long $0000FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $EF		; 30 EF ; Branch if minus to $30, $EF [Flow: branch]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc $09.b,X		; F6 09 ; Increment memory $09.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $25BDBF.l,X		; FF BF BD 25 ; Subtract with carry (long,X) $25BDBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $4060.w		; 20 60 40 ; Jump to subroutine at $4060.w [Writes: Stack Pointer] [Flow: call]
	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: ZNC]
	jsl $34E000.l		; 22 00 E0 34 ; Jump to subroutine long $34E000.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $F0		; 90 F0 ; Branch if carry clear to $90, $F0 [Flow: branch]
	ldy #$A0.b		; A0 A0 ; Load #$A0.b into Y register [Writes: Y Index] [Flags: ZN]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc $45BB06.l,X		; 7F 06 BB 45 ; Add long $45BB06.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $186770.l		; 8F 70 67 18 ; Store accumulator (long) $186770.l [Reads: Accumulator]
	sbc $41FF60.l,X		; FF 60 FF 41 ; Subtract with carry (long,X) $41FF60.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $4F3623.l,X		; 7F 23 36 4F ; Add long $4F3623.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FF7DF7.l		; CF F7 7D FF ; Compare accumulator (long) $FF7DF7.l [Reads: Accumulator] [Flags: ZNC]
	inc $7C.b,X		; F6 7C ; Increment memory $7C.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $DE00.w		; 8C 00 DE ; Store Y register to $DE00.w [Reads: Y Index]
	.db $80, $62		; 80 62 ; Branch always to $80, $62 [Flow: branch]
	sty $5C.b		; 84 5C ; Store Y register to $5C.b [Reads: Y Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sty $FED2.w		; 8C D2 FE ; Store Y register to $FED2.w [Reads: Y Index]
	pea $BED8.w		; F4 D8 BE ; Push absolute address $BED8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($1B.b,S),Y		; 13 1B ; OR accumulator (stack relative indirect indexed) ($1B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $113F10.l,X		; 3F 10 3F 11 ; AND accumulator with memory (long,X) $113F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and [$3B.b]		; 27 3B ; AND accumulator with memory (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $253E3F.l,X		; 1F 3F 3E 25 ; Logical OR long $253E3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $80, $78		; 80 78 ; Branch always to $80, $78 [Flow: branch]
	.db $90, $F8		; 90 F8 ; Branch if carry clear to $90, $F8 [Flow: branch]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $21E000.l		; 22 00 E0 21 ; Jump to subroutine long $21E000.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $E8		; 90 E8 ; Branch if carry clear to $90, $E8 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	pea $0000.w		; F4 00 00 ; Push absolute address $0000.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $3F03.w,X		; 1E 03 3F ; Arithmetic shift left $3F03.w,X [Reads: X Index] [Flags: ZNC]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $2778.w		; 1C 78 27 ; Test and reset bits $2778.w [Reads: Accumulator] [Flags: Z]
	eor $003A.w		; 4D 3A 00 ; Exclusive OR $003A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $7F3D33.l		; 22 33 3D 7F ; Jump to subroutine long $7F3D33.l [Writes: Stack Pointer] [Flow: call]
	adc $E0C060.l,X		; 7F 60 C0 E0 ; Add long $E0C060.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$24.b		; C0 24 ; Compare #$24.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $241F05.l,X		; 3F 05 1F 24 ; AND accumulator with memory (long,X) $241F05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $3B3F04.l,X		; 7F 04 3F 3B ; Add long $3B3F04.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $850000.l,X		; 1F 00 00 85 ; Logical OR long $850000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $D8.b,X		; 74 D8 ; Store zero to $D8.b,X [Reads: X Index]
	pea $FCB8.w		; F4 B8 FC ; Push absolute address $FCB8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FC22.w,X		; FE 22 FC ; Increment memory $FC22.w,X [Reads: X Index] [Flags: ZN]
	ora $44.b		; 05 44 ; Logical OR $44.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $070F03.l		; 0F 03 0F 07 ; OR accumulator with memory (long) $070F03.l [Writes: Accumulator] [Flags: ZN]
	sta $B0.b,S		; 83 B0 ; Store accumulator (stack relative) $B0.b,S [Reads: Accumulator, Stack Pointer]
	tsb $87.b		; 04 87 ; Test and set bits $87.b [Reads: Accumulator] [Flags: Z]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	and [$0F.b]		; 27 0F ; AND accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpx #$43.b		; E0 43 ; Compare #$43.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $A0		; D0 A0 ; Branch if not equal to $D0, $A0 [Flow: branch]
	eor #$90.b		; 49 90 ; Exclusive OR #$90.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $B0		; F0 B0 ; Branch if equal to $F0, $B0 [Flow: branch]
	.db $B0, $24		; B0 24 ; Branch if carry set to $B0, $24 [Flow: branch]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	.db $70, $FF		; 70 FF ; Branch if overflow set to $70, $FF [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $44FF7C.l,X		; FF 7C FF 44 ; Subtract with carry (long,X) $44FF7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $FF0380.l,X		; 7F 80 03 FF ; Add long $FF0380.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FF25.w,X)		; FC 25 FF ; Jump to subroutine indirect indexed ($FF25.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($1D.b),Y		; 11 1D ; OR accumulator with memory ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0E3D.w		; 0E 3D 0E ; Arithmetic shift left $0E3D.w [Flags: ZNC]
	sbc $FD1E.w,X		; FD 1E FD ; Subtract with carry $FD1E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $FEFD.w,X		; 3E FD FE ; Rotate left $FEFD.w,X [Reads: X Index] [Flags: ZNC]
	ora $01F2.w		; 0D F2 01 ; Logical OR $01F2.w with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: ZN]
	ora $FF223F.l,X		; 1F 3F 22 FF ; Logical OR long $FF223F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora #$F3.b		; 09 F3 ; Logical OR #$F3.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $0009FF.l,X		; FF FF 09 00 ; Subtract with carry (long,X) $0009FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $041B03.l,X		; 1F 03 1B 04 ; Logical OR long $041B03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0028.w		; 0C 28 00 ; Test and set bits $0028.w [Reads: Accumulator] [Flags: Z]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $17.b		; 14 17 ; Test and reset bits $17.b [Reads: Accumulator] [Flags: Z]
	tsb $0023.w		; 0C 23 00 ; Test and set bits $0023.w [Reads: Accumulator] [Flags: Z]
	tsb $3BEC.w		; 0C EC 3B ; Test and set bits $3BEC.w [Reads: Accumulator] [Flags: Z]
	lda $324F05.l,X		; BF 05 4F 32 ; Load long $324F05.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta [$7A.b]		; 87 7A ; Store accumulator (long) [$7A.b] [Reads: Accumulator, Direct Page]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	mvp $00,$7E		; 44 7E 00 ; Move block positive $00,$7E [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	trb $0022.w		; 1C 22 00 ; Test and reset bits $0022.w [Reads: Accumulator] [Flags: Z]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $BA874F.l,X		; BF 4F 87 BA ; Load long $BA874F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $001C.w,X		; 7E 1C 00 ; Rotate right $001C.w,X [Reads: X Index] [Flags: ZNC]
	sta [$A8.b],Y		; 97 A8 ; Store accumulator (long indexed) [$A8.b],Y [Reads: Accumulator, Direct Page, Y Index]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor ($D8.b)		; 52 D8 ; Exclusive OR accumulator with memory (indirect) ($D8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpy $4EB0.w		; CC B0 4E ; Compare $4EB0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $B0, $EE		; B0 EE ; Branch if carry set to $B0, $EE [Flow: branch]
	.db $90, $F6		; 90 F6 ; Branch if carry clear to $90, $F6 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jmp ($70B0.w,X)		; 7C B0 70 ; Jump indirect indexed to ($70B0.w,X) [Reads: X Index] [Flow: jump]
	cpy #$D8.b		; C0 D8 ; Compare #$D8.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy $CC.b		; A4 CC ; Load $CC.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	dec $F6EE.w		; CE EE F6 ; Decrement $F6EE.w [Flags: ZN]
	jsr ($67F0.w,X)		; FC F0 67 ; Jump to subroutine indirect indexed ($67F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	and $091600.l,X		; 3F 00 16 09 ; AND accumulator with memory (long,X) $091600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	ora $6F.b		; 05 6F ; Logical OR $6F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ror $3311.w		; 6E 11 33 ; Rotate right $3311.w [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3F1B.w,X		; 3D 1B 3F ; AND accumulator with memory $3F1B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor [$5E.b],Y		; 57 5E ; Exclusive OR accumulator with memory (long indexed) [$5E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($01.b,S),Y		; 33 01 ; AND accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	mvn $E6,$F9		; 54 F9 E6 ; Move block negative $E6,$F9 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	dec $F468.w,X		; DE 68 F4 ; Decrement memory $F468.w,X [Reads: X Index] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx $38.b		; E4 38 ; Compare $38.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $FCFE.w,Y		; F9 FE FC ; Subtract with carry $FCFE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($A038.w,X)		; FC 38 A0 ; Jump to subroutine indirect indexed ($A038.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$1B.b		; C0 1B ; Compare #$1B.b with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $000F.w		; 0C 0F 00 ; Test and set bits $000F.w [Reads: Accumulator] [Flags: Z]
	asl $1F01.w		; 0E 01 1F ; Arithmetic shift left $1F01.w [Flags: ZNC]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora #$0F.b		; 09 0F ; Logical OR #$0F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $F8C0BC.l		; 5C BC C0 F8 ; Jump long to $F8C0BC.l [Flow: jump]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	.db $B0, $70		; B0 70 ; Branch if carry set to $B0, $70 [Flow: branch]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $F21F00.l		; 22 00 1F F2 ; Jump to subroutine long $F21F00.l [Writes: Stack Pointer] [Flow: call]
	jsr ($F8F8.w,X)		; FC F8 F8 ; Jump to subroutine indirect indexed ($F8F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	inc $FE30.w,X		; FE 30 FE ; Increment memory $FE30.w,X [Reads: X Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	inc $7944.w,X		; FE 44 79 ; Increment memory $7944.w,X [Reads: X Index] [Flags: ZN]
	rol $1CF6.w		; 2E F6 1C ; Rotate left $1CF6.w [Flags: ZNC]
	stz $08.b,X		; 74 08 ; Store zero to $08.b,X [Reads: X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	inc $7DFE.w,X		; FE FE 7D ; Increment memory $7DFE.w,X [Reads: X Index] [Flags: ZN]
	ldx $0874.w,Y		; BE 74 08 ; Load X register $0874.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00001F.l,X		; FF 1F 00 00 ; Subtract with carry (long,X) $00001F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$33.b]		; 07 33 ; OR accumulator with memory (long) [$33.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $410F73.l		; 0F 73 0F 41 ; OR accumulator with memory (long) $410F73.l [Writes: Accumulator] [Flags: ZN]
	and $007F80.l,X		; 3F 80 7F 00 ; AND accumulator with memory (long,X) $007F80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $41.b,S		; 43 41 ; Exclusive OR accumulator with stack relative $41.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$98.b		; E0 98 ; Compare #$98.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $43		; F0 43 ; Branch if equal to $F0, $43 [Flow: branch]
	jmp ($1398.w)		; 6C 98 13 ; Jump indirect to ($1398.w) [Flow: jump]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	jsr ($FCF2.w,X)		; FC F2 FC ; Jump to subroutine indirect indexed ($FCF2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	stz $FA9C.w		; 9C 9C FA ; Store zero to $FA9C.w
	sbc ($00.b)		; F2 00 ; Subtract with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $431729.l		; 0F 29 17 43 ; OR accumulator with memory (long) $431729.l [Writes: Accumulator] [Flags: ZN]
	adc ($0F.b,S),Y		; 73 0F ; Add with carry (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($81.b,S),Y		; 13 81 ; OR accumulator (stack relative indirect indexed) ($81.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $007F80.l,X		; 7F 80 7F 00 ; Add long $007F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $432110.l		; 0F 10 21 43 ; OR accumulator with memory (long) $432110.l [Writes: Accumulator] [Flags: ZN]
	eor $81.b,S		; 43 81 ; Exclusive OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$90.b		; C0 90 ; Compare #$90.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$43.b		; E0 43 ; Compare #$43.b with X register [Reads: X Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $90, $0B		; 90 0B ; Branch if carry clear to $90, $0B [Flow: branch]
	sty $F8.b,X		; 94 F8 ; Store Y register $F8.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	pea $00F8.w		; F4 F8 00 ; Push absolute address $00F8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $98		; F0 98 ; Branch if equal to $F0, $98 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	pea $29F4.w		; F4 F4 29 ; Push absolute address $29F4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	and $307F00.l,X		; 3F 00 7F 30 ; AND accumulator with memory (long,X) $307F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00277F.l,X		; 3F 7F 27 00 ; AND accumulator with memory (long,X) $00277F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $DEFD.w		; 1C FD DE ; Test and reset bits $DEFD.w [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$4E.b		; E0 4E ; Compare #$4E.b with X register [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $3FFE.w,X		; 3C FE 3F ; Test bits $3FFE.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1300.w		; 0C 00 13 ; Test and set bits $1300.w [Reads: Accumulator] [Flags: Z]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $55.b		; 00 55 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $63331E.l		; 0F 1E 33 63 ; OR accumulator with memory (long) $63331E.l [Writes: Accumulator] [Flags: ZN]
	adc ($B0.b,X)		; 61 B0 ; Add with carry ($B0.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BA.b		; 00 BA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	cpy $86C6.w		; CC C6 86 ; Compare $86C6.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora $0056.w		; 0D 56 00 ; Logical OR $0056.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0300.w		; 1C 00 03 ; Test and reset bits $0300.w [Reads: Accumulator] [Flags: Z]
	tsb $2A10.w		; 0C 10 2A ; Test and set bits $2A10.w [Reads: Accumulator] [Flags: Z]
	rol $5F.b		; 26 5F ; Rotate left $5F.b [Reads: Direct Page] [Flags: ZNC]
	and $800000.l,X		; 3F 00 00 80 ; AND accumulator with memory (long,X) $800000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $19.b,S		; 83 19 ; Store accumulator (stack relative) $19.b,S [Reads: Accumulator, Stack Pointer]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($DE.b,X)		; 01 DE ; Logical OR ($DE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$00.b],Y		; D7 00 ; Compare accumulator (long indexed) [$00.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	cpx #$35.b		; E0 35 ; Compare #$35.b with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $C1.b		; 26 C1 ; Rotate left $C1.b [Reads: Direct Page] [Flags: ZNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1B.b		; 05 1B ; Logical OR $1B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $7142.w,X		; 3D 42 71 ; AND accumulator with memory $7142.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp.w [$00E0]		; DC E0 00 ; Jump long indirect [$00E0] [Flow: jump]
	.db $90, $E0		; 90 E0 ; Branch if carry clear to $90, $E0 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $FC		; 10 FC ; Branch if plus to $10, $FC [Flow: branch]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D7.b		; 00 D7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $E8		; 90 E8 ; Branch if carry clear to $90, $E8 [Flow: branch]
	stz $8F42.w		; 9C 42 8F ; Store zero to $8F42.w
	ora $3B.b,S		; 03 3B ; OR accumulator with stack relative $3B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $003F00.l,X		; 1F 00 3F 00 ; Logical OR long $003F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $6D		; 10 6D ; Branch if plus to $10, $6D [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $5C54.w		; 20 54 5C ; Jump to subroutine at $5C54.w [Writes: Stack Pointer] [Flow: call]
	ldx $877F.w,Y		; BE 7F 87 ; Load X register $877F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FE00.w,X)		; FC 00 FE ; Jump to subroutine indirect indexed ($FE00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $E7.b		; 84 E7 ; Store Y register to $E7.b [Reads: Y Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0C.b,S		; 63 0C ; Add with carry (stack relative) $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	mvp $07,$98		; 44 98 07 ; Move block positive $07,$98 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$33.b]		; 07 33 ; OR accumulator with memory (long) [$33.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $007F.w		; 0C 7F 00 ; Test and set bits $007F.w [Reads: Accumulator] [Flags: Z]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$33.b		; 09 33 ; Logical OR #$33.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jmp $C1F364.l		; 5C 64 F3 C1 ; Jump long to $C1F364.l [Flow: jump]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$DC.b		; C0 DC ; Compare #$DC.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $00FE.w		; 20 FE 00 ; Jump to subroutine at $00FE.w [Writes: Stack Pointer] [Flow: call]
	dec $B700.w,X		; DE 00 B7 ; Decrement memory $B700.w,X [Reads: X Index] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$DC.b		; A0 DC ; Load #$DC.b into Y register [Writes: Y Index] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	rol $CF.b		; 26 CF ; Rotate left $CF.b [Reads: Direct Page] [Flags: ZNC]
	sta $03.b,S		; 83 03 ; Store accumulator (stack relative) $03.b,S [Reads: Accumulator, Stack Pointer]
	sta ($6E.b),Y		; 91 6E ; Store accumulator ($6E.b),Y [Reads: Accumulator, Direct Page, Y Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	eor $80.b,X		; 55 80 ; Exclusive OR accumulator with memory $80.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $303F40.l,X		; 7F 40 3F 30 ; Add long $303F40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0E000F.l		; 0F 0F 00 0E ; OR accumulator with memory (long) $0E000F.l [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $91.b		; 00 91 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $62, $FC, $82		; 62 FC 82 ; Push effective relative address $62, $FC, $82 [Writes: Stack Pointer]
	jmp ($FC02.w,X)		; 7C 02 FC ; Jump indirect indexed to ($FC02.w,X) [Reads: X Index] [Flow: jump]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $02, $04		; 82 02 04 ; Branch always long to $82, $02, $04 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	.db $80, $89		; 80 89 ; Branch always to $80, $89 [Flow: branch]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $8F.b		; 85 8F ; Store accumulator to $8F.b [Reads: Accumulator]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $641F27.l,X		; 1F 27 1F 64 ; Logical OR long $641F27.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $78.b		; 84 78 ; Store Y register to $78.b [Reads: Y Index]
	sta $9E.b,S		; 83 9E ; Store accumulator (stack relative) $9E.b,S [Reads: Accumulator, Stack Pointer]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	pea $E010.w		; F4 10 E0 ; Push absolute address $E010.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	stz $84.b		; 64 84 ; Store zero to $84.b
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	.db $90, $E0		; 90 E0 ; Branch if carry clear to $90, $E0 [Flow: branch]
	ror $3D30.w,X		; 7E 30 3D ; Rotate right $3D30.w,X [Reads: X Index] [Flags: ZNC]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $33.b		; 02 33 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $49.b,S		; 03 49 ; OR accumulator with stack relative $49.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($2F.b),Y		; 31 2F ; AND accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($0C.b)		; 12 0C ; OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $1C183E.l,X		; 7F 3E 18 1C ; Add long $1C183E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $2F5E.w,X		; 3C 5E 2F ; Test bits $2F5E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora ($FD.b)		; 12 FD ; OR accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $FD.b		; E6 FD ; Increment $FD.b [Reads: Direct Page] [Flags: ZN]
	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	inc $10FE.w		; EE FE 10 ; Increment $10FE.w [Flags: ZN]
	jsr ($FEF8.w,X)		; FC F8 FE ; Jump to subroutine indirect indexed ($FEF8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pea $0CFA.w		; F4 FA 0C ; Push absolute address $0CFA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $0E1F0F.l,X		; 1F 0F 1F 0E ; Logical OR long $0E1F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	bit $65.b,X		; 34 65 ; Test bits $65.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4D.b		; 00 4D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $98.b,S		; E3 98 ; Subtract stack-relative $98.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	mvn $7B,$E1		; 54 E1 7B ; Move block negative $7B,$E1 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	adc $971CEE.l,X		; 7F EE 1C 97 ; Add long $971CEE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	dec $7900.w,X		; DE 00 79 ; Decrement memory $7900.w,X [Reads: X Index] [Flags: ZN]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cmp $19CA.w		; CD CA 19 ; Compare $19CA.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	ora [$5E.b],Y		; 17 5E ; OR accumulator with memory (long indexed) [$5E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sta [$DE.b]		; 87 DE ; Store accumulator (long) [$DE.b] [Reads: Accumulator, Direct Page]
	jsr ($3576.w,X)		; FC 76 35 ; Jump to subroutine indirect indexed ($3576.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc #$3F.b		; E9 3F ; Subtract #$3F.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	ora ($5F.b)		; 12 5F ; OR accumulator with memory (indirect) ($5F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $7F3E7D.l		; 22 7D 3E 7F ; Jump to subroutine long $7F3E7D.l [Writes: Stack Pointer] [Flow: call]
	asl $7F.b		; 06 7F ; Arithmetic shift left $7F.b [Reads: Direct Page] [Flags: ZNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F000F.l		; 0F 0F 00 3F ; OR accumulator with memory (long) $3F000F.l [Writes: Accumulator] [Flags: ZN]
	adc ($7F.b,S),Y		; 73 7F ; Add with carry (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $F60F10.l,X		; 3F 10 0F F6 ; AND accumulator with memory (long,X) $F60F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9A.b		; 00 9A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $82C4.w,X		; 1E C4 82 ; Arithmetic shift left $82C4.w,X [Reads: X Index] [Flags: ZNC]
	cmp ($EE.b,X)		; C1 EE ; Compare accumulator ($EE.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	jsr ($9C30.w,X)		; FC 30 9C ; Jump to subroutine indirect indexed ($9C30.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $0DF708.l,X		; DF 08 F7 0D ; Compare accumulator (long,X) $0DF708.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ldx $0B.b,Y		; B6 0B ; Load X register $0B.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	eor $043F08.l,X		; 5F 08 3F 04 ; Exclusive OR accumulator with memory (long,X) $043F08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $DBBDBB.l,X		; FF BB BD DB ; Subtract with carry (long,X) $DBBDBB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $390307.l,X		; 3F 07 03 39 ; AND accumulator with memory (long,X) $390307.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $FB		; 10 FB ; Branch if plus to $10, $FB [Flow: branch]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	.db $B0, $6D		; B0 6D ; Branch if carry set to $B0, $6D [Flow: branch]
	.db $D0, $FA		; D0 FA ; Branch if not equal to $D0, $FA [Flow: branch]
	.db $10, $FC		; 10 FC ; Branch if plus to $10, $FC [Flow: branch]
	jsr $C0E0.w		; 20 E0 C0 ; Jump to subroutine at $C0E0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $DBBDDD.l,X		; FF DD BD DB ; Subtract with carry (long,X) $DBBDDD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $E0FC.w,X		; DE FC E0 ; Decrement memory $E0FC.w,X [Reads: X Index] [Flags: ZN]
	cpy #$2E.b		; C0 2E ; Compare #$2E.b with Y register [Reads: Y Index] [Flags: ZNC]
	trb $7E.b		; 14 7E ; Test and reset bits $7E.b [Reads: Accumulator] [Flags: Z]
	bit $9E.b		; 24 9E ; Test bits $9E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	jmp ($7EFF.w)		; 6C FF 7E ; Jump indirect to ($7EFF.w) [Flow: jump]
	sbc $2F7E02.l,X		; FF 02 7E 2F ; Subtract with carry (long,X) $2F7E02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $1606.w,Y		; 39 06 16 ; AND accumulator with memory $1606.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$EF.b],Y		; 77 EF ; Add with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $296EFF.l,X		; FF FF 6E 29 ; Subtract with carry (long,X) $296EFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $C4.b,X		; 16 C4 ; Arithmetic shift left $C4.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $67E000.l		; 22 00 E0 67 ; Jump to subroutine long $67E000.l [Writes: Stack Pointer] [Flow: call]
	bit $C51E.w,X		; 3C 1E C5 ; Test bits $C51E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta $9E.b,S		; 83 9E ; Store accumulator (stack relative) $9E.b,S [Reads: Accumulator, Stack Pointer]
	jsr ($00F0.w,X)		; FC F0 00 ; Jump to subroutine indirect indexed ($00F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lda $00DF00.l		; AF 00 DF 00 ; Load long $00DF00.l into accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $09FF0A.l,X		; FF 0A FF 09 ; Subtract with carry (long,X) $09FF0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $0B5E0C.l,X		; BF 0C 5E 0B ; Load long $0B5E0C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $000F03.l		; 2F 03 0F 00 ; AND accumulator with memory (long) $000F03.l [Writes: Accumulator] [Flags: ZN]
	pei ($FE.b)		; D4 FE ; Push effective indirect address ($FE.b) [Reads: Direct Page] [Writes: Stack Pointer]
	lda $7FDDDB.l,X		; BF DB DD 7F ; Load long $7FDDDB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $00.b,X		; F5 00 ; Subtract $00.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $FF		; 50 FF ; Branch if overflow clear to $50, $FF [Flow: branch]
	.db $90, $FD		; 90 FD ; Branch if carry clear to $90, $FD [Flow: branch]
	.db $30, $7A		; 30 7A ; Branch if minus to $30, $7A [Flow: branch]
	.db $D0, $F4		; D0 F4 ; Branch if not equal to $D0, $F4 [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $BBDBFD.l,X		; 7F FD DB BB ; Add long $BBDBFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $D0D4.w,X		; FE D4 D0 ; Increment memory $D0D4.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $01.b,X		; 76 01 ; Rotate right $01.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $2F07.w,Y		; 59 07 2F ; Exclusive OR accumulator with memory $2F07.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $5F.b,S		; 03 5F ; OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and [$EE.b]		; 27 EE ; AND accumulator with memory (long) [$EE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $003EDD.l,X		; 7F DD 3E 00 ; Add long $003EDD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($57.b,X)		; 21 57 ; Logical AND ($57.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $FE7F37.l		; 6F 37 7F FE ; Add with carry (long) $FE7F37.l [Writes: Accumulator] [Flags: ZVNC]
	stz $0000.w		; 9C 00 00 ; Store zero to $0000.w
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	trb $FAF0.w		; 1C F0 FA ; Test and reset bits $FAF0.w [Reads: Accumulator] [Flags: Z]
	pea $ECF3.w		; F4 F3 EC ; Push absolute address $ECF3.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	adc ($EC.b,S),Y		; 73 EC ; Add with carry (stack relative indirect indexed) ($EC.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	jsr ($7CA3.w,X)		; FC A3 7C ; Jump to subroutine indirect indexed ($7CA3.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FFFE.w,X)		; FC FE FF ; Jump to subroutine indirect indexed ($FFFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $29373F.l,X		; 7F 3F 37 29 ; Add long $29373F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $EC98.w		; EC 98 EC ; Compare $EC98.w with X register [Reads: X Index] [Flags: ZNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsl $081C00.l		; 22 00 1C 08 ; Jump to subroutine long $081C00.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($FC7C.w,X)		; FC 7C FC ; Jump to subroutine indirect indexed ($FC7C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0E1706.l		; 0F 06 17 0E ; OR accumulator with memory (long) $0E1706.l [Writes: Accumulator] [Flags: ZN]
	and $1E.b		; 25 1E ; Logical AND $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	ora $182D.w,X		; 1D 2D 18 ; OR accumulator with memory $182D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $3A3D1F.l		; 0F 1F 3D 3A ; OR accumulator with memory (long) $3A3D1F.l [Writes: Accumulator] [Flags: ZN]
	and $831F1D.l		; 2F 1D 1F 83 ; AND accumulator with memory (long) $831F1D.l [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0BEC10.l,X		; 1F 10 EC 0B ; Logical OR long $0BEC10.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $A3F56B.l,X		; DF 6B F5 A3 ; Compare accumulator (long,X) $A3F56B.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	eor $2E.b,S		; 43 2E ; Exclusive OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $1F.b,X		; F5 1F ; Subtract $1F.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $FDD7F4.l		; EF F4 D7 FD ; Subtract with carry (long) $FDD7F4.l [Writes: Accumulator] [Flags: ZVNC]
	nop		; EA ; No operation
	nop		; EA ; No operation
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $D2.b		; 04 D2 ; Test and set bits $D2.b [Reads: Accumulator] [Flags: Z]
	tsb $CC36.w		; 0C 36 CC ; Test and set bits $CC36.w [Reads: Accumulator] [Flags: Z]
	dec $EC.b,X		; D6 EC ; Decrement memory $EC.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	pea $F896.w		; F4 96 F8 ; Push absolute address $F896.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $DE1E.w		; 1C 1E DE ; Test and reset bits $DE1E.w [Reads: Accumulator] [Flags: Z]
	rol $EAD6.w,X		; 3E D6 EA ; Rotate left $EAD6.w,X [Reads: X Index] [Flags: ZNC]
	inc $83.b,X		; F6 83 ; Increment memory $83.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $62.b		; 86 62 ; Store X register to $62.b [Reads: X Index]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $1B2D.w		; 1C 2D 1B ; Test and reset bits $1B2D.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $70.b,S		; 83 70 ; Store accumulator (stack relative) $70.b,S [Reads: Accumulator, Stack Pointer]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $18857F.l		; 2F 7F 85 18 ; AND accumulator with memory (long) $18857F.l [Writes: Accumulator] [Flags: ZN]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($0603.w,X)		; 7C 03 06 ; Jump indirect indexed to ($0603.w,X) [Reads: X Index] [Flow: jump]
	lda $63D5DB.l,X		; BF DB D5 63 ; Load long $63D5DB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec $E5.b,X		; D6 E5 ; Decrement memory $E5.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda [$DD.b]		; A7 DD ; Load accumulator (long) [$DD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$37.b		; E0 37 ; Compare #$37.b with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tsb $CC36.w		; 0C 36 CC ; Test and set bits $CC36.w [Reads: Accumulator] [Flags: Z]
	dec $AAE4.w,X		; DE E4 AA ; Decrement memory $AAE4.w,X [Reads: X Index] [Flags: ZN]
	pea $0000.w		; F4 00 00 ; Push absolute address $0000.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $36DE.w,X		; 3C DE 36 ; Test bits $36DE.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	dec $00EA.w,X		; DE EA 00 ; Decrement memory $00EA.w,X [Reads: X Index] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1D33.w,X		; 1D 33 1D ; OR accumulator with memory $1D33.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $7D3E.w,Y		; 79 3E 7D ; Add $7D3E.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0100.w,X		; 1E 00 01 ; Arithmetic shift left $0100.w,X [Reads: X Index] [Flags: ZNC]
	asl $3A14.w		; 0E 14 3A ; Arithmetic shift left $3A14.w [Flags: ZNC]
	and ($79.b)		; 32 79 ; AND accumulator with memory (indirect) ($79.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $003C.w,X		; 7D 3C 00 ; Add $003C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $66FF3C.l,X		; FF 3C FF 66 ; Subtract with carry (long,X) $66FF3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $66DB42.l,X		; FF 42 DB 66 ; Subtract with carry (long,X) $66DB42.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$7E.b]		; E7 7E ; Subtract with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda $3C00.w,X		; BD 00 3C ; Load $3C00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $DB03FF.l		; 22 FF 03 DB ; Jump to subroutine long $DB03FF.l [Writes: Stack Pointer] [Flow: call]
	sbc [$7E.b]		; E7 7E ; Subtract with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $1883.w,X		; 7E 83 18 ; Rotate right $1883.w,X [Reads: X Index] [Flags: ZNC]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $B0, $F4		; B0 F4 ; Branch if carry set to $B0, $F4 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jmp.w [$CEB8]		; DC B8 CE ; Jump long indirect [$CEB8] [Flow: jump]
	clv		; B8 ; Clear overflow flag [Flags: V]
	dec $F6B0.w,X		; DE B0 F6 ; Decrement memory $F6B0.w,X [Reads: X Index] [Flags: ZN]
	stz $F000.w		; 9C 00 F0 ; Store zero to $F000.w
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	bit $5C.b,X		; 34 5C ; Test bits $5C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	lsr $7E5E.w		; 4E 5E 7E ; Logical shift right $7E5E.w [Flags: ZNC]
	and #$1E.b		; 29 1E ; Logical AND #$1E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $3E.b,X		; 55 3E ; Exclusive OR accumulator with memory $3E.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc [$3D.b]		; 67 3D ; Add with carry (long) [$3D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $7B3E.w		; 6D 3E 7B ; Add $7B3E.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	bit $1936.w,X		; 3C 36 19 ; Test bits $1936.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $0A03.w,X		; 1D 03 0A ; OR accumulator with memory $0A03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$29.b]		; 07 29 ; OR accumulator with memory (long) [$29.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $7D7E.w,X		; 5D 7E 7D ; Exclusive OR accumulator with memory $7D7E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $1D.b,X		; 36 1D ; Rotate left $1D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Accumulator, X Index, Direct Page]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Accumulator, X Index, Direct Page]
	sbc $FE0100.l,X		; FF 00 01 FE ; Subtract with carry (long,X) $FE0100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $31FF.w		; CE FF 31 ; Decrement $31FF.w [Flags: ZN]
	sbc $7EEF54.l,X		; FF 54 EF 7E ; Subtract with carry (long,X) $7EEF54.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $FF00.w,X		; 3C 00 FF ; Test bits $FF00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $7098D7.l,X		; FF D7 98 70 ; Subtract with carry (long,X) $7098D7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $CC78.w		; 9C 78 CC ; Store zero to $CC78.w
	clv		; B8 ; Clear overflow flag [Flags: V]
	dec $BC.b		; C6 BC ; Decrement $BC.b [Reads: Direct Page] [Flags: ZN]
	dec $3C.b,X		; D6 3C ; Decrement memory $3C.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	dec $643C.w		; CE 3C 64 ; Decrement $643C.w [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldy #$98.b		; A0 98 ; Load #$98.b into Y register [Writes: Y Index] [Flags: ZN]
	stz $5E5C.w		; 9C 5C 5E ; Store zero to $5E5C.w
	dec $64CE.w,X		; DE CE 64 ; Decrement memory $64CE.w,X [Reads: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	trb $58A7.w		; 1C A7 58 ; Test and reset bits $58A7.w [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	adc $3E3E5F.l,X		; 7F 5F 3E 3E ; Add long $3E3E5F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00220F.l		; 0F 0F 22 00 ; OR accumulator with memory (long) $00220F.l [Writes: Accumulator] [Flags: ZN]
	trb $AA.b		; 14 AA ; Test and reset bits $AA.b [Reads: Accumulator] [Flags: Z]
	.db $80, $98		; 80 98 ; Branch always to $80, $98 [Flow: branch]
	lsr $102A.w,X		; 5E 2A 10 ; Logical shift right $102A.w,X [Reads: X Index] [Flags: ZNC]
	ora $788700.l		; 0F 00 87 78 ; OR accumulator with memory (long) $788700.l [Writes: Accumulator] [Flags: ZN]
	asl $44F0.w		; 0E F0 44 ; Arithmetic shift left $44F0.w [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $18		; 70 18 ; Branch if overflow set to $70, $18 [Flow: branch]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $0F0800.l		; 22 00 08 0F ; Jump to subroutine long $0F0800.l [Writes: Stack Pointer] [Flow: call]
	asl $8804.w		; 0E 04 88 ; Arithmetic shift left $8804.w [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $E3.b		; 84 E3 ; Store Y register to $E3.b [Reads: Y Index]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($03.b,S),Y		; 13 03 ; OR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $1C18.w		; 0E 18 1C ; Arithmetic shift left $1C18.w [Flags: ZNC]
	trb $070E.w		; 1C 0E 07 ; Test and reset bits $070E.w [Reads: Accumulator] [Flags: Z]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpy $7843.w		; CC 43 78 ; Compare $7843.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsr ($49E0.w,X)		; FC E0 49 ; Jump to subroutine indirect indexed ($49E0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($047C.w,X)		; FC 7C 04 ; Jump to subroutine indirect indexed ($047C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$12.b		; E0 12 ; Compare #$12.b with X register [Reads: X Index] [Flags: ZNC]
	ora $1F33.w		; 0D 33 1F ; Logical OR $1F33.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $131F.w,X		; 3E 1F 13 ; Rotate left $131F.w,X [Reads: X Index] [Flags: ZNC]
	tsb $031E.w		; 0C 1E 03 ; Test and set bits $031E.w [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $1F073C.l		; 0F 3C 07 1F ; OR accumulator with memory (long) $1F073C.l [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1E133E.l,X		; 3F 3E 13 1E ; AND accumulator with memory (long,X) $1E133E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $1F24.w,X		; 1E 24 1F ; Arithmetic shift left $1F24.w,X [Reads: X Index] [Flags: ZNC]
	cmp $13F3.w		; CD F3 13 ; Compare $13F3.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	sbc $9F9D67.l		; EF 67 9D 9F ; Subtract with carry (long) $9F9D67.l [Writes: Accumulator] [Flags: ZVNC]
	adc $3CC3.w,X		; 7D C3 3C ; Add $3CC3.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $008300.l,X		; BF 00 83 00 ; Load long $008300.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp $6713.w		; CD 13 67 ; Compare $6713.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	sta $82BFC3.l,X		; 9F C3 BF 82 ; Store accumulator (long,X) $82BFC3.l,X [Reads: Accumulator, X Index]
	ora ($14.b,X)		; 01 14 ; Logical OR ($14.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldy $F8.b,X		; B4 F8 ; Load Y register $F8.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	mvn $68,$E8		; 54 E8 68 ; Move block negative $68,$E8 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $F0.b,S		; 43 F0 ; Exclusive OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx #$3E.b		; E0 3E ; Compare #$3E.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $C8		; 70 C8 ; Branch if overflow set to $70, $C8 [Flow: branch]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $E8D4.w		; F4 D4 E8 ; Push absolute address $E8D4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $F0, $C8		; F0 C8 ; Branch if equal to $F0, $C8 [Flow: branch]
	and [$87.b],Y		; 37 87 ; AND accumulator with memory (long indexed) [$87.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $677FD8.l,X		; 7F D8 7F 67 ; Add long $677FD8.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	and $030D07.l,X		; 3F 07 0D 03 ; AND accumulator with memory (long,X) $030D07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000701.l		; 0F 01 07 00 ; OR accumulator with memory (long) $000701.l [Writes: Accumulator] [Flags: ZN]
	sbc $67F8FF.l,X		; FF FF F8 67 ; Subtract with carry (long,X) $67F8FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $07090F.l,X		; 3F 0F 09 07 ; AND accumulator with memory (long,X) $07090F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldx $6DDD.w,Y		; BE DD 6D ; Load X register $6DDD.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	lda $D3.b,S		; A3 D3 ; Load accumulator (stack relative) $D3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $9BE7.w		; 4D E7 9B ; Exclusive OR $9BE7.w with accumulator [Writes: Accumulator] [Flags: ZN]
	lsr $ADBB.w,X		; 5E BB AD ; Logical shift right $ADBB.w,X [Reads: X Index] [Flags: ZNC]
	cmp [$1E.b],Y		; D7 1E ; Compare accumulator (long indexed) [$1E.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sbc $EF.b,S		; E3 EF ; Subtract stack-relative $EF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $E7B3.w,X		; 5D B3 E7 ; Exclusive OR accumulator with memory $E7B3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $EF12AF.l,X		; 5F AF 12 EF ; Exclusive OR accumulator with memory (long,X) $EF12AF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stx $F8.b,Y		; 96 F8 ; Store X register $F8.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sta $10.b,S		; 83 10 ; Store accumulator (stack relative) $10.b,S [Reads: Accumulator, Stack Pointer]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pei ($E8.b)		; D4 E8 ; Push effective indirect address ($E8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sty $E8.b,X		; 94 E8 ; Store Y register $E8.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $D0, $83		; D0 83 ; Branch if not equal to $D0, $83 [Flow: branch]
	ldx #$04.b		; A2 04 ; Load #$04.b into X register [Writes: X Index] [Flags: ZN]
	trb $F6.b		; 14 F6 ; Test and reset bits $F6.b [Reads: Accumulator] [Flags: Z]
	pea $D4F4.w		; F4 F4 D4 ; Push absolute address $D4F4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sty $28.b,X		; 94 28 ; Store Y register $28.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	adc $433A.w		; 6D 3A 43 ; Add $433A.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	bit $3D6B.w,X		; 3C 6B 3D ; Test bits $3D6B.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and [$18.b],Y		; 37 18 ; AND accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0D07.w,X		; 1D 07 0D ; OR accumulator with memory $0D07.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $28E000.l		; 22 00 E0 28 ; Jump to subroutine long $28E000.l [Writes: Stack Pointer] [Flow: call]
	adc $7B7B.w,X		; 7D 7B 7B ; Add $7B7B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$1F.b],Y		; 37 1F ; AND accumulator with memory (long indexed) [$1F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cmp $E7.b,S		; C3 E7 ; Compare accumulator (stack relative) $E7.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cmp $DB.b,S		; C3 DB ; Compare accumulator (stack relative) $DB.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	bit $83FD.w,X		; 3C FD 83 ; Test bits $83FD.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $DB3C.w,X		; 3C 3C DB ; Test bits $DB3C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $84FDDB.l,X		; FF DB FD 84 ; Subtract with carry (long,X) $84FDDB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $C2.b,S		; 03 C2 ; OR accumulator with stack relative $C2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldy $3CD6.w,X		; BC D6 3C ; Load Y register $3CD6.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	cpx $78D8.w		; EC D8 78 ; Compare $78D8.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $15		; 30 15 ; Branch if minus to $30, $15 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $78EC.w,X		; DE EC 78 ; Decrement memory $78EC.w,X [Reads: X Index] [Flags: ZN]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $000F0E.l		; 0F 0E 0F 00 ; OR accumulator with memory (long) $000F0E.l [Writes: Accumulator] [Flags: ZN]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$E5.b],Y		; D7 E5 ; Compare accumulator (long indexed) [$E5.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda [$6D.b],Y		; B7 6D ; Load accumulator (long indexed) [$6D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	eor $8B.b,X		; 55 8B ; Exclusive OR accumulator with memory $8B.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy $0703.w		; CC 03 07 ; Compare $0703.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AB.b		; 00 AB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FB.b		; E5 FB ; Subtract $FB.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $CC5D.w,X		; 7D 5D CC ; Add $CC5D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $44		; B0 44 ; Branch if carry set to $B0, $44 [Flow: branch]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($60.b),Y		; 11 60 ; OR accumulator with memory ($60.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	cpy #$D0.b		; C0 D0 ; Compare #$D0.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$F0.b		; A0 F0 ; Load #$F0.b into Y register [Writes: Y Index] [Flags: ZN]
	jsr $00E0.w		; 20 E0 00 ; Jump to subroutine at $00E0.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $A0		; B0 A0 ; Branch if carry set to $B0, $A0 [Flow: branch]
	ldy #$60.b		; A0 60 ; Load #$60.b into Y register [Writes: Y Index] [Flags: ZN]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	sbc $002FE0.l,X		; FF E0 2F 00 ; Subtract with carry (long,X) $002FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc ($1C.b,S),Y		; F3 1C ; Subtract with carry (stack relative indirect indexed) ($1C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $174E6D.l,X		; DF 6D 4E 17 ; Compare accumulator (long,X) $174E6D.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	jmp $2F7E17.l		; 5C 17 7E 2F ; Jump long to $2F7E17.l [Flow: jump]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($9FFF.w,X)		; FC FF 9F ; Jump to subroutine indirect indexed ($9FFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $005F6F.l		; 6F 6F 5F 00 ; Add with carry (long) $005F6F.l [Writes: Accumulator] [Flags: ZVNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $38CF.w,X		; 1E CF 38 ; Arithmetic shift left $38CF.w,X [Reads: X Index] [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ldx $72.b,Y		; B6 72 ; Load X register $72.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	ror $00F4.w,X		; 7E F4 00 ; Rotate right $00F4.w,X [Reads: X Index] [Flags: ZNC]
	asl $FF3F.w,X		; 1E 3F FF ; Arithmetic shift left $FF3F.w,X [Reads: X Index] [Flags: ZNC]
	sbc $F6F6.w,Y		; F9 F6 F6 ; Subtract with carry $F6F6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$37.b]		; 07 37 ; OR accumulator with memory (long) [$37.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$22.b		; 09 22 ; Logical OR #$22.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $383F0F.l		; 0F 0F 3F 38 ; OR accumulator with memory (long) $383F0F.l [Writes: Accumulator] [Flags: ZN]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($E640.w,X)		; FC 40 E6 ; Jump to subroutine indirect indexed ($E640.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $70DE.w,X		; 3C DE 70 ; Test bits $70DE.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lda ($6C.b)		; B2 6C ; Load accumulator (indirect) ($6C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx $F4D8.w		; EC D8 F4 ; Compare $F4D8.w with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $38		; D0 38 ; Branch if not equal to $D0, $38 [Flow: branch]
	jmp ($FEFC.w,X)		; 7C FC FE ; Jump indirect indexed to ($FEFC.w,X) [Reads: X Index] [Flow: jump]
	inc $E4F2.w,X		; FE F2 E4 ; Increment memory $E4F2.w,X [Reads: X Index] [Flags: ZN]
	cpx $0083.w		; EC 83 00 ; Compare $0083.w with X register [Reads: X Index] [Flags: ZNC]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $7DE778.l		; CF 78 E7 7D ; Compare accumulator (long) $7DE778.l [Reads: Accumulator] [Flags: ZNC]
	sbc $1B7F3D.l,X		; FF 3D 7F 1B ; Subtract with carry (long,X) $1B7F3D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $3E27.w,X		; 7D 27 3E ; Add $3E27.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $227800.l		; 0F 00 78 22 ; OR accumulator with memory (long) $227800.l [Writes: Accumulator] [Flags: ZN]
	sbc $5F7F02.l,X		; FF 02 7F 5F ; Subtract with carry (long,X) $5F7F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $001883.l,X		; 3F 83 18 00 ; AND accumulator with memory (long,X) $001883.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $1EF3.w		; 0D F3 1E ; Logical OR $1EF3.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc [$BE.b]		; E7 BE ; Subtract with carry (long) [$BE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $D8FEBC.l,X		; FF BC FE D8 ; Subtract with carry (long,X) $D8FEBC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $7CE4.w,Y		; BE E4 7C ; Load X register $7CE4.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	asl $FF22.w,X		; 1E 22 FF ; Arithmetic shift left $FF22.w,X [Reads: X Index] [Flags: ZNC]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	jsr ($0027.w,X)		; FC 27 00 ; Jump to subroutine indirect indexed ($0027.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$30.b]		; 07 30 ; OR accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $BE		; 10 BE ; Branch if plus to $10, $BE [Flow: branch]
	bit $08FB.w,X		; 3C FB 08 ; Test bits $08FB.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $30.b,S		; 03 30 ; OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp ($F7C2.w)		; 6C C2 F7 ; Jump indirect to ($F7C2.w) [Flow: jump]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $10DC.w		; 2C DC 10 ; Test bits $10DC.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	jsl $040500.l		; 22 00 05 04 ; Jump to subroutine long $040500.l [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	rol $EC52.w,X		; 3E 52 EC ; Rotate left $EC52.w,X [Reads: X Index] [Flags: ZNC]
	asl $0045.w		; 0E 45 00 ; Arithmetic shift left $0045.w [Flags: ZNC]
	ora $2F0111.l,X		; 1F 11 01 2F ; Logical OR long $2F0111.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($2F.b,S),Y		; 13 2F ; OR accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $103F.w		; 1C 3F 10 ; Test and reset bits $103F.w [Reads: Accumulator] [Flags: Z]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $1511.w		; 0E 11 15 ; Arithmetic shift left $1511.w [Flags: ZNC]
	ora ($2C.b)		; 12 2C ; OR accumulator with memory (indirect) ($2C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $2C.b,S		; 23 2C ; AND accumulator with stack relative $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $80		; 10 80 ; Branch if plus to $10, $80 [Flow: branch]
	pea $F4C8.w		; F4 C8 F4 ; Push absolute address $F4C8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($E808.w,X)		; FC 08 E8 ; Jump to subroutine indirect indexed ($E808.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	bit $C4.b,X		; 34 C4 ; Test bits $C4.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $08.b,X		; 34 08 ; Test bits $08.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: ZNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora #$1E.b		; 09 1E ; Logical OR #$1E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $1B.b,X		; 16 1B ; Arithmetic shift left $1B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$30.b]		; 07 30 ; OR accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $D0, $FC		; D0 FC ; Branch if not equal to $D0, $FC [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $30.b,S		; 03 30 ; OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $23.b		; 24 23 ; Test bits $23.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $3409.w		; 0C 09 34 ; Test and set bits $3409.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	asl $1E1E.w		; 0E 1E 1E ; Arithmetic shift left $1E1E.w [Flags: ZNC]
	bit $1885.w,X		; 3C 85 18 ; Test bits $1885.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0607.w,Y		; 19 07 06 ; OR accumulator with memory $0607.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	and [$1F.b]		; 27 1F ; AND accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $2408.w		; 1C 08 24 ; Test and reset bits $2408.w [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora [$29.b],Y		; 17 29 ; OR accumulator with memory (long indexed) [$29.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $F000.w		; 20 00 F0 ; Jump to subroutine at $F000.w [Writes: Stack Pointer] [Flow: call]
	jsr $B0F8.w		; 20 F8 B0 ; Jump to subroutine at $B0F8.w [Writes: Stack Pointer] [Flow: call]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $48D020.l		; 0F 20 D0 48 ; OR accumulator with memory (long) $48D020.l [Writes: Accumulator] [Flags: ZN]
	and $193F1B.l,X		; 3F 1B 3F 19 ; AND accumulator with memory (long,X) $193F1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $071C1D.l,X		; 3F 1D 1C 07 ; AND accumulator with memory (long,X) $071C1D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1F3D3B.l,X		; 3F 3B 3D 1F ; AND accumulator with memory (long,X) $1F3D3B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr ($FCD8.w,X)		; FC D8 FC ; Jump to subroutine indirect indexed ($FCD8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($38B8.w,X)		; FC B8 38 ; Jump to subroutine indirect indexed ($38B8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$60.b		; E0 60 ; Compare #$60.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $FC1200.l		; 22 00 12 FC ; Jump to subroutine long $FC1200.l [Writes: Stack Pointer] [Flow: call]
	jmp.w [$F8BC]		; DC BC F8 ; Jump long indirect [$F8BC] [Flow: jump]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	eor $377E33.l,X		; 5F 33 7E 37 ; Exclusive OR accumulator with memory (long,X) $377E33.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $1E1F.w,X		; 3C 1F 1E ; Test bits $1E1F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($7B.b)		; 12 7B ; OR accumulator with memory (indirect) ($7B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc [$3F.b],Y		; 77 3F ; Add with carry (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00030F.l,X		; 1F 0F 03 00 ; Logical OR long $00030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$38.b		; C0 38 ; Compare #$38.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$38.b		; E0 38 ; Compare #$38.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F00AF8.l		; 22 F8 0A F0 ; Jump to subroutine long $F00AF8.l [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3C1F38.l,X		; 1F 38 1F 3C ; Logical OR long $3C1F38.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $B7831F.l,X		; 1F 1F 83 B7 ; Logical OR long $B7831F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $01C384.l,X		; 3F 84 C3 01 ; AND accumulator with memory (long,X) $01C384.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $DC.b		; 05 DC ; Logical OR $DC.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	trb $3CF8.w		; 1C F8 3C ; Test and reset bits $3CF8.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $CE.b		; 84 CE ; Store Y register to $CE.b [Reads: Y Index]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($DB84.w,X)		; FC 84 DB ; Jump to subroutine indirect indexed ($DB84.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $689B08.l,X		; FF 08 9B 68 ; Subtract with carry (long,X) $689B08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $143E08.l,X		; 7F 08 3E 14 ; Add long $143E08.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $240101.l,X		; 1F 01 01 24 ; Logical OR long $240101.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $F6.b,X		; 95 F6 ; Store accumulator to $F6.b,X [Reads: Accumulator, X Index]
	adc $3B.b,X		; 75 3B ; Add $3B.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	asl $0001.w,X		; 1E 01 00 ; Arithmetic shift left $0001.w,X [Reads: X Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $D8		; 10 D8 ; Branch if plus to $10, $D8 [Flow: branch]
	.db $10, $FC		; 10 FC ; Branch if plus to $10, $FC [Flow: branch]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	jmp.w [$38E6]		; DC E6 38 ; Jump long indirect [$38E6] [Flow: jump]
	bit $0022.w,X		; 3C 22 00 ; Test bits $0022.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx #$38.b		; E0 38 ; Compare #$38.b with X register [Reads: X Index] [Flags: ZNC]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	ldy $3EDC.w		; AC DC 3E ; Load $3EDC.w into Y register [Writes: Y Index] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	bit $2900.w,X		; 3C 00 29 ; Test bits $2900.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $377D16.l,X		; 5F 16 7D 37 ; Exclusive OR accumulator with memory (long,X) $377D16.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $1703.w,X		; 3E 03 17 ; Rotate left $1703.w,X [Reads: X Index] [Flags: ZNC]
	ora $2F.b		; 05 2F ; Logical OR $2F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $001E.w		; 0C 1E 00 ; Test and set bits $001E.w [Reads: Accumulator] [Flags: Z]
	rol $6F67.w,X		; 3E 67 6F ; Rotate left $6F67.w,X [Reads: X Index] [Flags: ZNC]
	eor $331B3F.l		; 4F 3F 1B 33 ; Exclusive OR accumulator with memory (long) $331B3F.l [Writes: Accumulator] [Flags: ZN]
	asl $0094.w,X		; 1E 94 00 ; Arithmetic shift left $0094.w,X [Reads: X Index] [Flags: ZNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	ldx $7CEC.w,Y		; BE EC 7C ; Load X register $7CEC.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	cpy #$E8.b		; C0 E8 ; Compare #$E8.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$F4.b		; A0 F4 ; Load #$F4.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F6.b		; E6 F6 ; Increment $F6.b [Reads: Direct Page] [Flags: ZN]
	sbc ($FC.b)		; F2 FC ; Subtract with carry (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpy $1E78.w		; CC 78 1E ; Compare $1E78.w with Y register [Reads: Y Index] [Flags: ZNC]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0D0807.l,X		; 1F 07 08 0D ; Logical OR long $0D0807.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $171400.l		; 22 00 14 17 ; Jump to subroutine long $171400.l [Writes: Stack Pointer] [Flow: call]
	ora $0F16.w,Y		; 19 16 0F ; OR accumulator with memory $0F16.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $00070B.l		; 0F 0B 07 00 ; OR accumulator with memory (long) $00070B.l [Writes: Accumulator] [Flags: ZN]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldy $F040.w,X		; BC 40 F0 ; Load Y register $F040.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $EC0900.l		; 22 00 09 EC ; Jump to subroutine long $EC0900.l [Writes: Stack Pointer] [Flow: call]
	inc $7C.b,X		; F6 7C ; Increment memory $7C.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $68.b,S		; 43 68 ; Exclusive OR accumulator with stack relative $68.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $43		; 30 43 ; Branch if minus to $30, $43 [Flow: branch]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $3C.b		; 05 3C ; Logical OR $3C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	jsr $0025.w		; 20 25 00 ; Jump to subroutine at $0025.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx #$94.b		; E0 94 ; Compare #$94.b with X register [Reads: X Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $10, $80		; 10 80 ; Branch if plus to $10, $80 [Flow: branch]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($0078.w,X)		; FC 78 00 ; Jump to subroutine indirect indexed ($0078.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $3F01.w,Y		; 19 01 3F ; OR accumulator with memory $3F01.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $183D05.l,X		; 1F 05 3D 18 ; Logical OR long $183D05.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $1F0024.l,X		; 1F 24 00 1F ; Logical OR long $1F0024.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $3F24.w,X		; 1E 24 3F ; Arithmetic shift left $3F24.w,X [Reads: X Index] [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and $00001F.l,X		; 3F 1F 00 00 ; AND accumulator with memory (long,X) $00001F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec $9558.w,X		; DE 58 95 ; Decrement memory $9558.w,X [Reads: X Index] [Flags: ZN]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $FE20.w,X		; 3C 20 FE ; Test bits $FE20.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jmp $1CEE.w		; 4C EE 1C ; Jump to $1CEE.w [Flow: jump]
	jmp ($3818.w)		; 6C 18 38 ; Jump indirect to ($3818.w) [Flow: jump]
	brk $A6.b		; 00 A6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BEDCD6.l		; EF D6 DC BE ; Subtract with carry (long) $BEDCD6.l [Writes: Accumulator] [Flags: ZVNC]
	inc $385C.w,X		; FE 5C 38 ; Increment memory $385C.w,X [Reads: X Index] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $98.b,S		; 83 98 ; Store accumulator (stack relative) $98.b,S [Reads: Accumulator, Stack Pointer]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $BB1C.w,X		; 9E 1C BB ; Store zero to $BB1C.w,X [Reads: X Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc $002268.l,X		; FF 68 22 00 ; Subtract with carry (long,X) $002268.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $30.b		; 04 30 ; Test and set bits $30.b [Reads: Accumulator] [Flags: Z]
	jmp ($D7E2.w)		; 6C E2 D7 ; Jump indirect to ($D7E2.w) [Flow: jump]
	sta $25.b,X		; 95 25 ; Store accumulator to $25.b,X [Reads: Accumulator, X Index]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3200.w		; 0C 00 32 ; Test and set bits $3200.w [Reads: Accumulator] [Flags: Z]
	brk $79.b		; 00 79 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp $FF14.w,X		; DD 14 FF ; Compare accumulator $FF14.w,X [Reads: X Index] [Flags: ZNC]
	asl $22.b,X		; 16 22 ; Arithmetic shift left $22.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $473E.w		; 0C 3E 47 ; Test and set bits $473E.w [Reads: Accumulator] [Flags: Z]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	lda #$25.b		; A9 25 ; Load #$25.b into accumulator [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $6CFF.w		; 20 FF 6C ; Jump to subroutine at $6CFF.w [Writes: Stack Pointer] [Flow: call]
	adc $00221F.l,X		; 7F 1F 22 00 ; Add long $00221F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $20.b		; 04 20 ; Test and set bits $20.b [Reads: Accumulator] [Flags: Z]
	.db $70, $DC		; 70 DC ; Branch if overflow set to $70, $DC [Flow: branch]
	sta ($60.b,S),Y		; 93 60 ; Store accumulator (stack relative indirect indexed) ($60.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $FF34.w,X		; FD 34 FF ; Subtract with carry $FF34.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $CB36.w		; 0C 36 CB ; Test and set bits $CB36.w [Reads: Accumulator] [Flags: Z]
	ora $830025.l		; 0F 25 00 83 ; OR accumulator with memory (long) $830025.l [Writes: Accumulator] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $2BBB1C.l,X		; 9F 1C BB 2B ; Store accumulator (long,X) $2BBB1C.l,X [Reads: Accumulator, X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	jsl $300400.l		; 22 00 04 30 ; Jump to subroutine long $300400.l [Writes: Stack Pointer] [Flow: call]
	jmp ($D4E3.w)		; 6C E3 D4 ; Jump indirect to ($D4E3.w) [Flow: jump]
	cmp [$25.b],Y		; D7 25 ; Compare accumulator (long indexed) [$25.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $03		; 50 03 ; Branch if overflow clear to $50, $03 [Flow: branch]
	ora $F9.b		; 05 F9 ; Logical OR $F9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp $1FD4.w,X		; DD D4 1F ; Compare accumulator $1FD4.w,X [Reads: X Index] [Flags: ZNC]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $360C.w		; 4C 0C 36 ; Jump to $360C.w [Flow: jump]
	cmp [$2B.b]		; C7 2B ; Compare accumulator (long) [$2B.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $2F01.w,X		; 1E 01 2F ; Arithmetic shift left $2F01.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $5C		; 10 5C ; Branch if plus to $10, $5C [Flow: branch]
	and $5E.b,S		; 23 5E ; AND accumulator with stack relative $5E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $99.b,S		; 03 99 ; OR accumulator with stack relative $99.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $07.b		; 66 07 ; Rotate right $07.b [Reads: Direct Page] [Flags: ZNC]
	ora $6330.w,Y		; 19 30 63 ; OR accumulator with memory $6330.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($A9.b,X)		; 61 A9 ; Add with carry ($A9.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	sbc $7000E0.l		; EF E0 00 70 ; Subtract with carry (long) $7000E0.l [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $58		; 80 58 ; Branch always to $80, $58 [Flow: branch]
	ldy #$30.b		; A0 30 ; Load #$30.b into Y register [Writes: Y Index] [Flags: ZN]
	cpy #$B8.b		; C0 B8 ; Compare #$B8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $58		; F0 58 ; Branch if equal to $F0, $58 [Flow: branch]
	.db $F0, $3C		; F0 3C ; Branch if equal to $F0, $3C [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($E018.w,X)		; FC 18 E0 ; Jump to subroutine indirect indexed ($E018.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $90, $E8		; 90 E8 ; Branch if carry clear to $90, $E8 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($4FFC.w,X)		; FC FC 4F ; Jump to subroutine indirect indexed ($4FFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	stz $9B73.w		; 9C 73 9B ; Store zero to $9B73.w
	adc [$B6.b]		; 67 B6 ; Add with carry (long) [$B6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $A85FAC.l		; 4F AC 5F A8 ; Exclusive OR accumulator with memory (long) $A85FAC.l [Writes: Accumulator] [Flags: ZN]
	eor $BF3FDF.l,X		; 5F DF 3F BF ; Exclusive OR accumulator with memory (long,X) $BF3FDF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor $B79B9C.l		; 4F 9C 9B B7 ; Exclusive OR accumulator with memory (long) $B79B9C.l [Writes: Accumulator] [Flags: ZN]
	lda $BFDFAF.l		; AF AF DF BF ; Load long $BFDFAF.l into accumulator [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $30.b,S		; 23 30 ; AND accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $35.b		; 06 35 ; Arithmetic shift left $35.b [Reads: Direct Page] [Flags: ZNC]
	asl $126F.w		; 0E 6F 12 ; Arithmetic shift left $126F.w [Flags: ZNC]
	jmp $5D13.w		; 4C 13 5D ; Jump to $5D13.w [Flow: jump]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$2E.b],Y		; 17 2E ; OR accumulator with memory (long indexed) [$2E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $637F.w,X		; 5E 7F 63 ; Logical shift right $637F.w,X [Reads: X Index] [Flags: ZNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $80.b		; 45 80 ; Exclusive OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$24.b		; C0 24 ; Compare #$24.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$F6.b		; 89 F6 ; Test bits #$F6.b with accumulator [Reads: Accumulator] [Flags: Z]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F00.w,X		; 1E 00 3F ; Arithmetic shift left $3F00.w,X [Reads: X Index] [Flags: ZNC]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $D8		; 10 D8 ; Branch if plus to $10, $D8 [Flow: branch]
	.db $30, $F4		; 30 F4 ; Branch if minus to $30, $F4 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	mvp $00,$00		; 44 00 00 ; Move block positive $00,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	asl $DE21.w,X		; 1E 21 DE ; Arithmetic shift left $DE21.w,X [Reads: X Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy $006E.w,X		; BC 6E 00 ; Load Y register $006E.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $54,$2B		; 44 2B 54 ; Move block positive $54,$2B [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $55.b,S		; 23 55 ; AND accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $540777.l		; 22 77 07 54 ; Jump to subroutine long $540777.l [Writes: Stack Pointer] [Flow: call]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $EE00.w,X		; FE 00 EE ; Increment memory $EE00.w,X [Reads: X Index] [Flags: ZN]
	mvp $2A,$D4		; 44 D4 2A ; Move block positive $2A,$D4 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $6A.b		; C4 6A ; Compare $6A.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	pei ($00.b)		; D4 00 ; Push effective indirect address ($00.b) [Reads: Direct Page] [Writes: Stack Pointer]
	inc $EE22.w,X		; FE 22 EE ; Increment memory $EE22.w,X [Reads: X Index] [Flags: ZN]
	ora $EE2A.w		; 0D 2A EE ; Logical OR $EE2A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $08FB.w		; EE FB 08 ; Increment $08FB.w [Flags: ZN]
	cmp $54BE28.l,X		; DF 28 BE 54 ; Compare accumulator (long,X) $54BE28.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $0C371B.l		; 6F 1B 37 0C ; Add with carry (long) $0C371B.l [Writes: Accumulator] [Flags: ZVNC]
	trb $0024.w		; 1C 24 00 ; Test and reset bits $0024.w [Reads: Accumulator] [Flags: Z]
	ora ($F6.b)		; 12 F6 ; OR accumulator with memory (indirect) ($F6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $FB.b,X		; B5 FB ; Load $FB.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp ($1C2F.w,X)		; 7C 2F 1C ; Jump indirect indexed to ($1C2F.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $14FB10.l,X		; DF 10 FB 14 ; Compare accumulator (long,X) $14FB10.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $F62A.w,X		; 7D 2A F6 ; Add $F62A.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpx $7830.w		; EC 30 78 ; Compare $7830.w with X register [Reads: X Index] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($6F.b)		; 12 6F ; OR accumulator with memory (indirect) ($6F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $3EDF.w		; AD DF 3E ; Load $3EDF.w into accumulator [Writes: Accumulator] [Flags: ZN]
	pea $0078.w		; F4 78 00 ; Push absolute address $0078.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $3F0C.w,X		; 3C 0C 3F ; Test bits $3F0C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $1F.b,X		; 16 1F ; Arithmetic shift left $1F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	trb $24.b		; 14 24 ; Test and reset bits $24.b [Reads: Accumulator] [Flags: Z]
	and [$33.b]		; 27 33 ; AND accumulator with memory (long) [$33.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $011F.w,Y		; 39 1F 01 ; AND accumulator with memory $011F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $1619D0.l,X		; DF D0 19 16 ; Compare accumulator (long,X) $1619D0.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	rol $7C38.w,X		; 3E 38 7C ; Rotate left $7C38.w,X [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx $B8.b		; E4 B8 ; Compare $B8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	jsr ($7840.w,X)		; FC 40 78 ; Jump to subroutine indirect indexed ($7840.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $291200.l		; 22 00 12 29 ; Jump to subroutine long $291200.l [Writes: Stack Pointer] [Flow: call]
	sbc $7CBCC6.l		; EF C6 BC 7C ; Subtract with carry (long) $7CBCC6.l [Writes: Accumulator] [Flags: ZVNC]
	jsr ($0078.w,X)		; FC 78 00 ; Jump to subroutine indirect indexed ($0078.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldy $DE4C.w,X		; BC 4C DE ; Load Y register $DE4C.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	rol $077F.w		; 2E 7F 07 ; Rotate left $077F.w [Flags: ZNC]
	and $1C2712.l,X		; 3F 12 27 1C ; AND accumulator with memory (long,X) $1C2712.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0024.w,X		; 1E 24 00 ; Arithmetic shift left $0024.w,X [Reads: X Index] [Flags: ZNC]
	ora ($F3.b)		; 12 F3 ; OR accumulator with memory (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda ($78.b),Y		; B1 78 ; Load accumulator ($78.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1E3F.w,X		; 3D 3F 1E ; AND accumulator with memory $1E3F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7B32.w,X		; 3D 32 7B ; AND accumulator with memory $7B32.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stz $FE.b,X		; 74 FE ; Store zero to $FE.b,X [Reads: X Index]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cpx $38.b		; E4 38 ; Compare $38.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$44.b		; E0 44 ; Compare #$44.b with X register [Reads: X Index] [Flags: ZNC]
	cmp $BC1E8D.l		; CF 8D 1E BC ; Compare accumulator (long) $BC1E8D.l [Reads: Accumulator] [Flags: ZNC]
	jsr ($0078.w,X)		; FC 78 00 ; Jump to subroutine indirect indexed ($0078.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $00FF.w		; 1C FF 00 ; Test and reset bits $00FF.w [Reads: Accumulator] [Flags: Z]
	eor ($22.b,S),Y		; 53 22 ; XOR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $007F70.l		; 8F 70 7F 00 ; Store accumulator (long) $007F70.l [Reads: Accumulator]
	inc $8F01.w,X		; FE 01 8F ; Increment memory $8F01.w,X [Reads: X Index] [Flags: ZN]
	.db $70, $77		; 70 77 ; Branch if overflow set to $70, $77 [Flow: branch]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $7A8E5D.l		; AF 5D 8E 7A ; Load long $7A8E5D.l into accumulator [Writes: Accumulator] [Flags: ZN]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	bit #$77.b		; 89 77 ; Test bits #$77.b with accumulator [Reads: Accumulator] [Flags: Z]
	jsr ($BC08.w,X)		; FC 08 BC ; Jump to subroutine indirect indexed ($BC08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $A6		; 70 A6 ; Branch if overflow set to $70, $A6 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc ($AE.b),Y		; 71 AE ; Add with carry ($AE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $BCBC.w,X		; 5E BC BC ; Logical shift right $BCBC.w,X [Reads: X Index] [Flags: ZNC]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $7E78.w		; 4C 78 7E ; Jump to $7E78.w [Flow: jump]
	sbc $F0FCFE.l,X		; FF FE FC F0 ; Subtract with carry (long,X) $F0FCFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $207F70.l,X		; BF 70 7F 20 ; Load long $207F70.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $387730.l		; 6F 30 77 38 ; Add with carry (long) $387730.l [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $07071F.l,X		; 1F 1F 07 07 ; Logical OR long $07071F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $BF0600.l		; 22 00 06 BF ; Jump to subroutine long $BF0600.l [Writes: Stack Pointer] [Flow: call]
	adc $38776F.l,X		; 7F 6F 77 38 ; Add long $38776F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $003807.l,X		; 1F 07 38 00 ; Logical OR long $003807.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$3C.b		; E0 3C ; Compare #$3C.b with X register [Reads: X Index] [Flags: ZNC]
	eor $083F01.l,X		; 5F 01 3F 08 ; Exclusive OR accumulator with memory (long,X) $083F01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $017312.l		; 2F 12 73 01 ; AND accumulator with memory (long) $017312.l [Writes: Accumulator] [Flags: ZN]
	adc ($00.b),Y		; 71 00 ; Add with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $533F3F.l,X		; 7F 3F 3F 53 ; Add long $533F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($21.b),Y		; 51 21 ; Exclusive OR accumulator with memory ($21.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F7		; 80 F7 ; Branch always to $80, $F7 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldx $DC40.w,Y		; BE 40 DC ; Load X register $DC40.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ldy #$F8.b		; A0 F8 ; Load #$F8.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $A8		; B0 A8 ; Branch if carry set to $B0, $A8 [Flow: branch]
	dec $DD.b,X		; D6 DD ; Decrement memory $DD.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	ldx $F8F4.w		; AE F4 F8 ; Load $F8F4.w into X register [Writes: X Index] [Flags: ZN]
	eor $002100.l,X		; 5F 00 21 00 ; Exclusive OR accumulator with memory (long,X) $002100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $061300.l		; 0F 00 13 06 ; OR accumulator with memory (long) $061300.l [Writes: Accumulator] [Flags: ZN]
	ora $E00022.l		; 0F 22 00 E0 ; OR accumulator with memory (long) $E00022.l [Writes: Accumulator] [Flags: ZN]
	eor $01217E.l		; 4F 7E 21 01 ; Exclusive OR accumulator with memory (long) $01217E.l [Writes: Accumulator] [Flags: ZN]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $6A000F.l,X		; 1F 0F 00 6A ; Logical OR long $6A000F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sty $F4.b		; 84 F4 ; Store Y register to $F4.b [Reads: Y Index]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FE		; 80 FE ; Branch always to $80, $FE [Flow: branch]
	jsr $0837.w		; 20 37 08 ; Jump to subroutine at $0837.w [Writes: Stack Pointer] [Flow: call]
	inc $7010.w		; EE 10 70 ; Increment $7010.w [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($A8.b)		; D4 A8 ; Push effective indirect address ($A8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	inc $3D.b,X		; F6 3D ; Increment memory $3D.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	dec $C0B0.w,X		; DE B0 C0 ; Decrement memory $C0B0.w,X [Reads: X Index] [Flags: ZN]
	adc [$2B.b],Y		; 77 2B ; Add with carry (long indexed) [$2B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$2A.b],Y		; 77 2A ; Add with carry (long indexed) [$2A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($3E.b,X)		; 41 3E ; Exclusive OR accumulator with memory ($3E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $2A7700.l,X		; 7F 00 77 2A ; Add long $2A7700.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$2B.b],Y		; 77 2B ; Add with carry (long indexed) [$2B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $77007F.l,X		; 3F 7F 00 77 ; AND accumulator with memory (long,X) $77007F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$40.b],Y		; 77 40 ; Add with carry (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $7777.w,X		; 7E 77 77 ; Rotate right $7777.w,X [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $EED4EE.l,X		; 7F EE D4 EE ; Add long $EED4EE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	mvn $7C,$82		; 54 82 7C ; Move block negative $7C,$82 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	inc $EE00.w,X		; FE 00 EE ; Increment memory $EE00.w,X [Reads: X Index] [Flags: ZN]
	mvn $D4,$EE		; 54 EE D4 ; Move block negative $D4,$EE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $EE00.w,X		; FE 00 EE ; Increment memory $EE00.w,X [Reads: X Index] [Flags: ZN]
	inc $7E02.w		; EE 02 7E ; Increment $7E02.w [Flags: ZN]
	inc $02EE.w		; EE EE 02 ; Increment $02EE.w [Flags: ZN]
	inc $E0FF.w,X		; FE FF E0 ; Increment memory $E0FF.w,X [Reads: X Index] [Flags: ZN]
	sta $030001.l		; 8F 01 00 03 ; Store accumulator (long) $030001.l [Reads: Accumulator]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $193A.w		; 0D 3A 19 ; Logical OR $193A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $BE18.w,Y		; 79 18 BE ; Add $BE18.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $5EDF.w,X		; 1E DF 5E ; Arithmetic shift left $5EDF.w,X [Reads: X Index] [Flags: ZNC]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $672612.l		; 0F 12 26 67 ; OR accumulator with memory (long) $672612.l [Writes: Accumulator] [Flags: ZN]
	sbc ($A1.b,X)		; E1 A1 ; Subtract with carry ($A1.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $B0, $7C		; B0 7C ; Branch if carry set to $B0, $7C [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $2D08.w,X		; FE 08 2D ; Increment memory $2D08.w,X [Reads: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	.db $F0, $48		; F0 48 ; Branch if equal to $F0, $48 [Flow: branch]
	mvp $D7,$86		; 44 86 D7 ; Move block positive $D7,$86 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sbc $00.b,X		; F5 00 ; Subtract $00.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$3B.b]		; 07 3B ; OR accumulator with memory (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $E9237F.l		; 22 7F 23 E9 ; Jump to subroutine long $E9237F.l [Writes: Stack Pointer] [Flow: call]
	adc ($F0.b,X)		; 61 F0 ; Add with carry ($F0.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $55.b		; 25 55 ; Logical AND $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	stx $CF.b,Y		; 96 CF ; Store X register $CF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $3F00.w,X		; FD 00 3F ; Subtract with carry $3F00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$1F.b		; C0 1F ; Compare #$1F.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$BF.b		; E0 BF ; Compare #$BF.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $707FA0.l,X		; FF A0 7F 70 ; Subtract with carry (long,X) $707FA0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1122.w,X		; FD 22 11 ; Subtract with carry $1122.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sta $0003.w		; 8D 03 00 ; Store accumulator to $0003.w [Reads: Accumulator]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora $1F02.w		; 0D 02 1F ; Logical OR $1F02.w with accumulator [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $187F1C.l,X		; 3F 1C 7F 18 ; AND accumulator with memory (long,X) $187F1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $58DF10.l,X		; BF 10 DF 58 ; Load long $58DF10.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $2216.w		; 0D 16 22 ; Logical OR $2216.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $E8.b		; 65 E8 ; Add $E8.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ldy $C0.b		; A4 C0 ; Load $C0.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $EC		; 10 EC ; Branch if plus to $10, $EC [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	inc $F508.w		; EE 08 F5 ; Increment $F508.w [Flags: ZN]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $B0, $68		; B0 68 ; Branch if carry set to $B0, $68 [Flow: branch]
	mvn $1F,$36		; 54 36 1F ; Move block negative $1F,$36 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $0027.w,X		; 5D 27 00 ; Exclusive OR accumulator with memory $0027.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$30.b]		; 07 30 ; OR accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	eor [$FF.b]		; 47 FF ; Exclusive OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $30.b,S		; 03 30 ; OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $279FB8.l		; 6F B8 9F 27 ; Add with carry (long) $279FB8.l [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $F400.w		; 0C 00 F4 ; Test and set bits $F400.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $FFE0.w,X		; 1E E0 FF ; Arithmetic shift left $FFE0.w,X [Reads: X Index] [Flags: ZNC]
	trb $23.b		; 14 23 ; Test and reset bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0C.b,S		; 63 0C ; Add with carry (stack relative) $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	pea $FB1E.w		; F4 1E FB ; Push absolute address $FB1E.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $031F06.l		; 0F 06 1F 03 ; OR accumulator with memory (long) $031F06.l [Writes: Accumulator] [Flags: ZN]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $5F37.w		; 4E 37 5F ; Logical shift right $5F37.w [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	jmp ($7927.w,X)		; 7C 27 79 ; Jump indirect indexed to ($7927.w,X) [Reads: X Index] [Flow: jump]
	rol $2D7B.w		; 2E 7B 2D ; Rotate left $2D7B.w [Flags: ZNC]
	ora $7E3F1F.l		; 0F 1F 3F 7E ; OR accumulator with memory (long) $7E3F1F.l [Writes: Accumulator] [Flags: ZN]
	adc [$7F.b],Y		; 77 7F ; Add with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $3CD27E.l,X		; 7F 7E D2 3C ; Add long $3CD27E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $FC6C.w,Y		; BE 6C FC ; Load X register $FC6C.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy #$4E.b		; A0 4E ; Load #$4E.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $F0, $E9		; F0 E9 ; Branch if equal to $F0, $E9 [Flow: branch]
	rol $F7.b,X		; 36 F7 ; Rotate left $F7.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldx $D8FE.w,Y		; BE FE D8 ; Load X register $D8FE.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	inc $FCFE.w,X		; FE FE FC ; Increment memory $FCFE.w,X [Reads: X Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ror $7FFF.w,X		; 7E FF 7F ; Rotate right $7FFF.w,X [Reads: X Index] [Flags: ZNC]
	rol $063F.w,X		; 3E 3F 06 ; Rotate left $063F.w,X [Reads: X Index] [Flags: ZNC]
	eor [$3B.b]		; 47 3B ; Exclusive OR accumulator with memory (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy $7F.b,X		; B4 7F ; Load Y register $7F.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	inc $FE61.w,X		; FE 61 FE ; Increment memory $FE61.w,X [Reads: X Index] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $FD56.w,X		; FD 56 FD ; Subtract with carry $FD56.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $7D.b		; 46 7D ; Logical shift right $7D.b [Reads: Direct Page] [Flags: ZNC]
	asl $3F.b,X		; 16 3F ; Arithmetic shift left $3F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc $F7FEFC.l,X		; 7F FC FE F7 ; Add long $F7FEFC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $BF6FFF.l		; EF FF 6F BF ; Subtract with carry (long) $BF6FFF.l [Writes: Accumulator] [Flags: ZVNC]
	ror $F6.b,X		; 76 F6 ; Rotate right $F6.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $B0, $64		; B0 64 ; Branch if carry set to $B0, $64 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($9C.b)		; F2 9C ; Subtract with carry (indirect) ($9C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	jmp ($ECFE.w)		; 6C FE EC ; Jump indirect to ($ECFE.w) [Flow: jump]
	ldx $FFAC.w,Y		; BE AC FF ; Load X register $FFAC.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	inc $78.b,X		; F6 78 ; Increment memory $78.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	jmp ($9EFE.w,X)		; 7C FE 9E ; Jump indirect indexed to ($9EFE.w,X) [Reads: X Index] [Flow: jump]
	asl $2D5E.w,X		; 1E 5E 2D ; Arithmetic shift left $2D5E.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $30, $EC		; 30 EC ; Branch if minus to $30, $EC [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	inc $B8.b		; E6 B8 ; Increment $B8.b [Reads: Direct Page] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $70.b,S		; 03 70 ; OR accumulator with stack relative $70.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($E4FE.w,X)		; FC FE E4 ; Jump to subroutine indirect indexed ($E4FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $40.b		; 85 40 ; Store accumulator to $40.b [Reads: Accumulator]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FC7870.l,X		; 3F 70 78 FC ; AND accumulator with memory (long,X) $FC7870.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $2C6F7C.l,X		; FF 7C 6F 2C ; Subtract with carry (long,X) $2C6F7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$04.b]		; 27 04 ; AND accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $39		; 50 39 ; Branch if overflow clear to $50, $39 [Flow: branch]
	and $10.b		; 25 10 ; Logical AND $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0307.w		; 0C 07 03 ; Test and set bits $0307.w [Reads: Accumulator] [Flags: Z]
	sbc $2CEE3E.l,X		; FF 3E EE 2C ; Subtract with carry (long,X) $2CEE3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	stz $3808.w		; 9C 08 38 ; Store zero to $3808.w
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($BC.b)		; 12 BC ; OR accumulator with memory (indirect) ($BC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx $C8.b		; E4 C8 ; Compare $C8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	cpy #$F9.b		; C0 F9 ; Compare #$F9.b with Y register [Reads: Y Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $7EFF1F.l,X		; FF 1F FF 7E ; Subtract with carry (long,X) $7EFF1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $073F16.l,X		; 7F 16 3F 07 ; Add long $073F16.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $140022.l,X		; 1F 22 00 14 ; Logical OR long $140022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda [$85.b]		; A7 85 ; Load accumulator (long) [$85.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy #$81.b		; C0 81 ; Compare #$81.b with Y register [Reads: Y Index] [Flags: ZNC]
	adc ($20.b,X)		; 61 20 ; Add with carry ($20.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $70FA00.l,X		; 1F 00 FA 70 ; Logical OR long $70FA00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $B0, $F8		; B0 F8 ; Branch if carry set to $B0, $F8 [Flow: branch]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $8A1400.l		; 22 00 14 8A ; Jump to subroutine long $8A1400.l [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $10, $60		; 10 60 ; Branch if plus to $10, $60 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc [$74.b],Y		; F7 74 ; Subtract with carry (long indexed) [$74.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$24.b]		; 67 24 ; Add with carry (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and [$14.b],Y		; 37 14 ; AND accumulator with memory (long indexed) [$14.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $030F0F.l,X		; 1F 0F 0F 03 ; Logical OR long $030F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $10.b		; 25 10 ; Logical AND $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	sbc [$06.b]		; E7 06 ; Subtract with carry (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $04.b		; E6 04 ; Increment $04.b [Reads: Direct Page] [Flags: ZN]
	cpx $DC28.w		; EC 28 DC ; Compare $DC28.w with X register [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $391000.l		; 22 00 10 39 ; Jump to subroutine long $391000.l [Writes: Stack Pointer] [Flow: call]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	pei ($24.b)		; D4 24 ; Push effective indirect address ($24.b) [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $27FC.w		; 6D FC 27 ; Add $27FC.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	sbc $58DF13.l,X		; FF 13 DF 58 ; Subtract with carry (long,X) $58DF13.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($0026.w,X)		; FC 26 00 ; Jump to subroutine indirect indexed ($0026.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $9F.b		; 04 9F ; Test and set bits $9F.b [Reads: Accumulator] [Flags: Z]
	cmp $FCA7EF.l,X		; DF EF A7 FC ; Compare accumulator (long,X) $FCA7EF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	jsl $49E000.l		; 22 00 E0 49 ; Jump to subroutine long $49E000.l [Writes: Stack Pointer] [Flow: call]
	adc $EE3FA6.l,X		; 7F A6 3F EE ; Add long $EE3FA6.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0CEFDE.l,X		; FF DE EF 0C ; Subtract with carry (long,X) $0CEFDE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $38792E.l,X		; 7F 2E 79 38 ; Add long $38792E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $003E30.l,X		; 7F 30 3E 00 ; Add long $003E30.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E1F1.w,Y		; F9 F1 E1 ; Subtract with carry $E1F1.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($51.b,S),Y		; F3 51 ; Subtract with carry (stack relative indirect indexed) ($51.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor [$4F.b]		; 47 4F ; Exclusive OR accumulator with memory (long) [$4F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $4DFF.w,X		; 3E FF 4D ; Rotate left $4DFF.w,X [Reads: X Index] [Flags: ZNC]
	sbc $66FF4E.l,X		; FF 4E FF 66 ; Subtract with carry (long,X) $66FF4E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $5FFF59.l,X		; FF 59 FF 5F ; Subtract with carry (long,X) $5FFF59.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $041F0E.l,X		; 7F 0E 1F 04 ; Add long $041F0E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $9FFF.w,X		; FE FF 9F ; Increment memory $9FFF.w,X [Reads: X Index] [Flags: ZN]
	ldx $A0.b		; A6 A0 ; Load $A0.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	adc ($1B.b),Y		; 71 1B ; Add with carry ($1B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$BC.b]		; 07 BC ; OR accumulator with memory (long) [$BC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy #$9E.b		; A0 9E ; Load #$9E.b into Y register [Writes: Y Index] [Flags: ZN]
	stz $9099.w		; 9C 99 90 ; Store zero to $9099.w
	ora $CF08.w		; 0D 08 CF ; Logical OR $CF08.w with accumulator [Writes: Accumulator] [Flags: ZN]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	inc $F870.w,X		; FE 70 F8 ; Increment memory $F870.w,X [Reads: X Index] [Flags: ZN]
	jsr $00E0.w		; 20 E0 00 ; Jump to subroutine at $00E0.w [Writes: Stack Pointer] [Flow: call]
	jmp $F76F62.l		; 5C 62 6F F7 ; Jump long to $F76F62.l [Flow: jump]
	and $8E.b,X		; 35 8E ; Logical AND $8E.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpx #$3D.b		; E0 3D ; Compare #$3D.b with X register [Reads: X Index] [Flags: ZNC]
	asl $44.b,X		; 16 44 ; Arithmetic shift left $44.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc $5AE036.l,X		; 7F 36 E0 5A ; Add long $5AE036.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $043F.w		; 2E 3F 04 ; Rotate left $043F.w [Flags: ZNC]
	ora $000700.l,X		; 1F 00 07 00 ; Logical OR long $000700.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $564F4F.l		; 2F 4F 4F 56 ; AND accumulator with memory (long) $564F4F.l [Writes: Accumulator] [Flags: ZN]
	eor ($3B.b),Y		; 51 3B ; Exclusive OR accumulator with memory ($3B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $909C07.l,X		; 1F 07 9C 90 ; Logical OR long $909C07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stx $868C.w		; 8E 8C 86 ; Store X register to $868C.w [Reads: X Index]
	sty $DA.b		; 84 DA ; Store Y register to $DA.b [Reads: Y Index]
	.db $D0, $DE		; D0 DE ; Branch if not equal to $D0, $DE [Flow: branch]
	mvn $20,$FC		; 54 FC 20 ; Move block negative $20,$FC [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($7A.b)		; 72 7A ; Add with carry (indirect) ($7A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rol $DCAA.w		; 2E AA DC ; Rotate left $DCAA.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$19.b		; E0 19 ; Compare #$19.b with X register [Reads: X Index] [Flags: ZNC]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $3B		; 10 3B ; Branch if plus to $10, $3B [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and ($13.b,S),Y		; 33 13 ; AND accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	adc $472D.w		; 6D 2D 47 ; Add $472D.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	ora $4F.b		; 05 4F ; Logical OR $4F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $3F1F.w		; 0C 1F 3F ; Test and set bits $3F1F.w [Reads: Accumulator] [Flags: Z]
	bit $2C.b,X		; 34 2C ; Test bits $2C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $52.b,X		; 34 52 ; Test bits $52.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	adc ($EE.b,S),Y		; 73 EE ; Add with carry (stack relative indirect indexed) ($EE.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	lsr $FFF4.w,X		; 5E F4 FF ; Logical shift right $FFF4.w,X [Reads: X Index] [Flags: ZNC]
	ror $BAF7.w,X		; 7E F7 BA ; Rotate right $BAF7.w,X [Reads: X Index] [Flags: ZNC]
	sbc $32FDBC.l		; EF BC FD 32 ; Subtract with carry (long) $32FDBC.l [Writes: Accumulator] [Flags: ZVNC]
	sbc ($2C.b,S),Y		; F3 2C ; Subtract with carry (stack relative indirect indexed) ($2C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FEFE12.l		; EF 12 FE FE ; Subtract with carry (long) $FEFE12.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $FD7F7F.l,X		; FF 7F 7F FD ; Subtract with carry (long,X) $FD7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($EF.b,S),Y		; F3 EF ; Subtract with carry (stack relative indirect indexed) ($EF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $02A0.w		; 8D A0 02 ; Store accumulator to $02A0.w [Reads: Accumulator]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $B0.b		; 86 B0 ; Store X register to $B0.b [Reads: X Index]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $B8.b		; E6 B8 ; Increment $B8.b [Reads: Direct Page] [Flags: ZN]
	sta $02B8.w		; 8D B8 02 ; Store accumulator to $02B8.w [Reads: Accumulator]
	jsl $CA84FE.l		; 22 FE 84 CA ; Jump to subroutine long $CA84FE.l [Writes: Stack Pointer] [Flow: call]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $266E13.l,X		; 3F 13 6E 26 ; AND accumulator with memory (long,X) $266E13.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $FF45.w		; CD 45 FF ; Compare $FF45.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	adc [$7D.b],Y		; 77 7D ; Add with carry (long indexed) [$7D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $1939.w		; 2D 39 19 ; Logical AND $1939.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $BA59.w		; 2C 59 BA ; Test bits $BA59.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	eor ($26.b)		; 52 26 ; Exclusive OR accumulator with memory (indirect) ($26.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $6FFE47.l,X		; FF 47 FE 6F ; Subtract with carry (long,X) $6FFE47.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda $EFBCC7.l,X		; BF C7 BC EF ; Load long $EFBCC7.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	cpx $F8BF.w		; EC BF F8 ; Compare $F8BF.w with X register [Reads: X Index] [Flags: ZNC]
	and $FFFF47.l,X		; 3F 47 FF FF ; AND accumulator with memory (long,X) $FFFF47.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $7F.b,S		; 23 7F ; AND accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $38FF.w		; 1C FF 38 ; Test and reset bits $38FF.w [Reads: Accumulator] [Flags: Z]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $5DDF05.l		; 8F 05 DF 5D ; Store accumulator (long) $5DDF05.l [Reads: Accumulator]
	inc $32.b,X		; F6 32 ; Increment memory $32.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	adc [$05.b]		; 67 05 ; Add with carry (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($33.b,S),Y		; 73 33 ; Add with carry (stack relative indirect indexed) ($33.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $77381E.l,X		; 7F 1E 38 77 ; Add long $77381E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ldx #$CD.b		; A2 CD ; Load #$CD.b into X register [Writes: X Index] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	jmp $2E61.w		; 4C 61 2E ; Jump to $2E61.w [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	lsr $8674.w,X		; 5E 74 86 ; Logical shift right $8674.w,X [Reads: X Index] [Flags: ZNC]
	ldy $0C02.w,X		; BC 02 0C ; Load Y register $0C02.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	lda ($F3.b)		; B2 F3 ; Load accumulator (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp ($12EF.w)		; 6C EF 12 ; Jump indirect to ($12EF.w) [Flow: jump]
	rol $FF7E.w,X		; 3E 7E FF ; Rotate left $FF7E.w,X [Reads: X Index] [Flags: ZNC]
	adc $F37D7F.l,X		; 7F 7F 7D F3 ; Add long $F37D7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $130023.l		; EF 23 00 13 ; Subtract with carry (long) $130023.l [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $1904.w		; 0C 04 19 ; Test and set bits $1904.w [Reads: Accumulator] [Flags: Z]
	ora #$1B.b		; 09 1B ; Logical OR #$1B.b with accumulator [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $00000F.l,X		; 1F 0F 00 00 ; Logical OR long $00000F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $14.b,X		; 16 14 ; Arithmetic shift left $14.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $10, $84		; 10 84 ; Branch if plus to $10, $84 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $847FDB.l		; 2F DB 7F 84 ; AND accumulator with memory (long) $847FDB.l [Writes: Accumulator] [Flags: ZN]
	jsr $0303.w		; 20 03 03 ; Jump to subroutine at $0303.w [Writes: Stack Pointer] [Flow: call]
	cmp $475F78.l,X		; DF 78 5F 47 ; Compare accumulator (long,X) $475F78.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	jsl $7F03FF.l		; 22 FF 03 7F ; Jump to subroutine long $7F03FF.l [Writes: Stack Pointer] [Flow: call]
	adc $23BF3F.l,X		; 7F 3F BF 23 ; Add long $23BF3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($1C.b)		; 32 1C ; AND accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $0E19.w		; 0C 19 0E ; Test and set bits $0E19.w [Reads: Accumulator] [Flags: Z]
	ora $0006.w		; 0D 06 00 ; Logical OR $0006.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1E3E.w,X		; 3C 3E 1E ; Test bits $1E3E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $002B0F.l,X		; 1F 0F 2B 00 ; Logical OR long $002B0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $0018.w,X		; 3C 18 00 ; Test bits $0018.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $005C00.l,X		; 5F 00 5C 00 ; Exclusive OR accumulator with memory (long,X) $005C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $7C8300.l,X		; 3F 00 83 7C ; AND accumulator with memory (long,X) $7C8300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3C1F00.l		; 0F 00 1F 3C ; OR accumulator with memory (long) $3C1F00.l [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $051F2F.l,X		; 7F 2F 1F 05 ; Add long $051F2F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $011F.w		; 0D 1F 01 ; Logical OR $011F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc [$02.b]		; E7 02 ; Subtract with carry (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FF,$00		; 44 00 FF ; Move block positive $FF,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$21.b		; E0 21 ; Compare #$21.b with X register [Reads: X Index] [Flags: ZNC]
	lda $1FFF40.l,X		; BF 40 FF 1F ; Load long $1FFF40.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$EB.b],Y		; 17 EB ; OR accumulator with memory (long indexed) [$EB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$6D.b],Y		; 77 6D ; Add with carry (long indexed) [$6D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F8AE.w		; ED AE F8 ; Subtract $F8AE.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	cpy #$C4.b		; C0 C4 ; Compare #$C4.b with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $FCFC.w,X		; 1E FC FC ; Arithmetic shift left $FCFC.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$C4.b		; C0 C4 ; Compare #$C4.b with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	stz $E4.b		; 64 E4 ; Store zero to $E4.b
	clc		; 18 ; Clear carry flag [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	trb $FCF8.w		; 1C F8 FC ; Test and reset bits $FCF8.w [Reads: Accumulator] [Flags: Z]
	inc $FCFC.w,X		; FE FC FC ; Increment memory $FCFC.w,X [Reads: X Index] [Flags: ZN]
	inc $7EFC.w,X		; FE FC 7E ; Increment memory $7EFC.w,X [Reads: X Index] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $59BE.w		; 1C BE 59 ; Test and reset bits $59BE.w [Reads: Accumulator] [Flags: Z]
	jsr ($2313.w,X)		; FC 13 23 ; Jump to subroutine indirect indexed ($2313.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	trb $FF7F.w		; 1C 7F FF ; Test and reset bits $FF7F.w [Reads: Accumulator] [Flags: Z]
	sbc $FF2C6F.l,X		; FF 6F 2C FF ; Subtract with carry (long,X) $FF2C6F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $51DF.w,Y		; 39 DF 51 ; AND accumulator with memory $51DF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $6BFF20.l,X		; BF 20 FF 6B ; Load long $6BFF20.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($3230.w,X)		; 7C 30 32 ; Jump indirect indexed to ($3230.w,X) [Reads: X Index] [Flow: jump]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $53.b		; 00 53 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $AE.b		; C6 AE ; Decrement $AE.b [Reads: Direct Page] [Flags: ZN]
	cmp $334F94.l,X		; DF 94 4F 33 ; Compare accumulator (long,X) $334F94.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpx $343E.w		; EC 3E 34 ; Compare $343E.w with X register [Reads: X Index] [Flags: ZNC]
	bit $DC28.w,X		; 3C 28 DC ; Test bits $DC28.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $D0, $DC		; D0 DC ; Branch if not equal to $D0, $DC [Flow: branch]
	.db $10, $BC		; 10 BC ; Branch if plus to $10, $BC [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jsr ($F8F0.w,X)		; FC F0 F8 ; Jump to subroutine indirect indexed ($F8F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $2CD4.w		; CE D4 2C ; Decrement $2CD4.w [Flags: ZN]
	cpx $0C44.w		; EC 44 0C ; Compare $0C44.w with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $6DEF0C.l		; 4F 0C EF 6D ; Exclusive OR accumulator with memory (long) $6DEF0C.l [Writes: Accumulator] [Flags: ZN]
	inc $DF38.w,X		; FE 38 DF ; Increment memory $DF38.w,X [Reads: X Index] [Flags: ZN]
	.db $50, $BF		; 50 BF ; Branch if overflow clear to $50, $BF [Flow: branch]
	and $FE.b,S		; 23 FE ; AND accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	adc $3735.w,X		; 7D 35 37 ; Add $3735.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($C7.b)		; 92 C7 ; Store accumulator (indirect) ($C7.b) [Reads: Accumulator, Direct Page]
	lda $4A95DC.l		; AF DC 95 4A ; Load long $4A95DC.l into accumulator [Writes: Accumulator] [Flags: ZN]
	and [$EF.b],Y		; 37 EF ; AND accumulator with memory (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp ($3E.b)		; D2 3E ; Compare accumulator (indirect) ($3E.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	bit $6C7F.w		; 2C 7F 6C ; Test bits $6C7F.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	adc $CCFD62.l,X		; 7F 62 FD CC ; Add long $CCFD62.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $C080.w		; EE 80 C0 ; Increment $C080.w [Flags: ZN]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $9D9F.w,X		; DE 9F 9D ; Decrement memory $9D9F.w,X [Reads: X Index] [Flags: ZN]
	and ($6E.b,S),Y		; 33 6E ; AND accumulator (stack relative indirect indexed) ($6E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $3B		; 80 3B ; Branch always to $80, $3B [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $2A0E0E.l,X		; 1F 0E 0E 2A ; Logical OR long $2A0E0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $11.b		; 24 11 ; Test bits $11.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl $0024.w		; 0E 24 00 ; Arithmetic shift left $0024.w [Flags: ZNC]
	asl $6D.b		; 06 6D ; Arithmetic shift left $6D.b [Reads: Direct Page] [Flags: ZNC]
	and $1F1F7F.l,X		; 3F 7F 1F 1F ; AND accumulator with memory (long,X) $1F1F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $071F7F.l,X		; 7F 7F 1F 07 ; Add long $071F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $3F.b,X		; 16 3F ; Arithmetic shift left $3F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $011F.w		; 0C 1F 01 ; Test and set bits $011F.w [Reads: Accumulator] [Flags: Z]
	ora $000705.l		; 0F 05 07 00 ; OR accumulator with memory (long) $000705.l [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($1E.b,S),Y		; 33 1E ; AND accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0407.w		; 0E 07 04 ; Arithmetic shift left $0407.w [Flags: ZNC]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$04.b],Y		; 37 04 ; AND accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $1139.w,X		; 1E 39 11 ; Arithmetic shift left $1139.w,X [Reads: X Index] [Flags: ZNC]
	and ($12.b,S),Y		; 33 12 ; AND accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $15.b,X		; 35 15 ; Logical AND $15.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$16.b],Y		; 37 16 ; AND accumulator with memory (long indexed) [$16.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $06170D.l,X		; 1F 0D 17 06 ; Logical OR long $06170D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $292A.w		; 2D 2A 29 ; Logical AND $292A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($19.b)		; 12 19 ; OR accumulator with memory (indirect) ($19.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $ED07.w		; 0C 07 ED ; Test and set bits $ED07.w [Reads: Accumulator] [Flags: Z]
	lda $9F1FFF.l,X		; BF FF 1F 9F ; Load long $9F1FFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $079FFF.l,X		; 7F FF 9F 07 ; Add long $079FFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $002680.l		; 22 80 26 00 ; Jump to subroutine long $002680.l [Writes: Stack Pointer] [Flow: call]
	ora #$38.b		; 09 38 ; Logical OR #$38.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc ($7C.b)		; F2 7C ; Subtract with carry (indirect) ($7C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	jmp ($267D.w)		; 6C 7D 26 ; Jump indirect to ($267D.w) [Flow: jump]
	jsl $380400.l		; 22 00 04 38 ; Jump to subroutine long $380400.l [Writes: Stack Pointer] [Flow: call]
	jmp ($FEFE.w,X)		; 7C FE FE ; Jump indirect indexed to ($FEFE.w,X) [Reads: X Index] [Flow: jump]
	adc $050029.l,X		; 7F 29 00 05 ; Add long $050029.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $2200.w		; 1C 00 22 ; Test and reset bits $2200.w [Reads: Accumulator] [Flags: Z]
	trb $3E4D.w		; 1C 4D 3E ; Test and reset bits $3E4D.w [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $7F3E1C.l		; 0F 1C 3E 7F ; OR accumulator with memory (long) $7F3E1C.l [Writes: Accumulator] [Flags: ZN]
	ora $011E00.l,X		; 1F 00 1E 01 ; Logical OR long $011E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3B02.w,X		; 1D 02 3B ; OR accumulator with memory $3B02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $171400.l		; 22 00 14 17 ; Jump to subroutine long $171400.l [Writes: Stack Pointer] [Flow: call]
	asl $15.b,X		; 16 15 ; Arithmetic shift left $15.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	rol $0F11.w		; 2E 11 0F ; Rotate left $0F11.w [Flags: ZNC]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	and $3BC0.w,X		; 3D C0 3B ; AND accumulator with memory $3BC0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$F4.b		; C0 F4 ; Compare #$F4.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $161400.l		; 22 00 14 16 ; Jump to subroutine long $161400.l [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	and [$CC.b]		; 27 CC ; AND accumulator with memory (long) [$CC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $FC		; 10 FC ; Branch if plus to $10, $FC [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	jmp ($22FC.w,X)		; 7C FC 22 ; Jump indirect indexed to ($22FC.w,X) [Reads: X Index] [Flow: jump]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $78DCBA.l,X		; 3F BA DC 78 ; AND accumulator with memory (long,X) $78DCBA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp $FC82.w		; 4C 82 FC ; Jump to $FC82.w [Flow: jump]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $02.b,S		; 83 02 ; Store accumulator (stack relative) $02.b,S [Reads: Accumulator, Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,X		; 15 00 ; OR accumulator with memory $00.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $341A.w		; 0C 1A 34 ; Test and set bits $341A.w [Reads: Accumulator] [Flags: Z]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $F0.b		; 06 F0 ; Arithmetic shift left $F0.b [Reads: Direct Page] [Flags: ZNC]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $030E.w,X		; 3C 0E 03 ; Test bits $030E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp $FF4386.l		; 5C 86 43 FF ; Jump long to $FF4386.l [Flow: jump]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $4500.w		; 1C 00 45 ; Test and reset bits $4500.w [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $27		; F0 27 ; Branch if equal to $F0, $27 [Flow: branch]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $30FF.w		; 20 FF 30 ; Jump to subroutine at $30FF.w [Writes: Stack Pointer] [Flow: call]
	lda [$1F.b],Y		; B7 1F ; Load accumulator (long indexed) [$1F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	and $050022.l		; 2F 22 00 05 ; AND accumulator with memory (long) $050022.l [Writes: Accumulator] [Flags: ZN]
	jsr $FF70.w		; 20 70 FF ; Jump to subroutine at $FF70.w [Writes: Stack Pointer] [Flow: call]
	sbc $4406DF.l,X		; FF DF 06 44 ; Subtract with carry (long,X) $4406DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$A1.b		; E0 A1 ; Compare #$A1.b with X register [Reads: X Index] [Flags: ZNC]
	ora $041F02.l		; 0F 02 1F 04 ; OR accumulator with memory (long) $041F02.l [Writes: Accumulator] [Flags: ZN]
	sbc $EE12.w,X		; FD 12 EE ; Subtract with carry $EE12.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pea $F81C.w		; F4 1C F8 ; Push absolute address $F81C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	ora $FF1B0D.l		; 0F 0D 1B FF ; OR accumulator with memory (long) $FF1B0D.l [Writes: Accumulator] [Flags: ZN]
	inc $00FC.w,X		; FE FC 00 ; Increment memory $00FC.w,X [Reads: X Index] [Flags: ZN]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FA.b,S		; 03 FA ; OR accumulator with stack relative $FA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sbc $167E77.l,X		; FF 77 7E 16 ; Subtract with carry (long,X) $167E77.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $000E.w,X		; 1E 0E 00 ; Arithmetic shift left $000E.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $3B		; 10 3B ; Branch if plus to $10, $3B [Flow: branch]
	jmp ($8885.w,X)		; 7C 85 88 ; Jump indirect indexed to ($8885.w,X) [Reads: X Index] [Flow: jump]
	adc #$11.b		; 69 11 ; Add #$11.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$39.b		; C0 39 ; Compare #$39.b with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	and $5E2C.w,X		; 3D 2C 5E ; AND accumulator with memory $5E2C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp.w [$C73E]		; DC 3E C7 ; Jump long indirect [$C73E] [Flow: jump]
	cmp ($B6.b,S),Y		; D3 B6 ; Compare accumulator (stack relative indirect indexed) ($B6.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($FA.b,S),Y		; 33 FA ; AND accumulator (stack relative indirect indexed) ($FA.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jmp ($1E04.w,X)		; 7C 04 1E ; Jump indirect indexed to ($1E04.w,X) [Reads: X Index] [Flow: jump]
	asl $133F.w		; 0E 3F 13 ; Arithmetic shift left $133F.w [Flags: ZNC]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp $7B95.w		; 4C 95 7B ; Jump to $7B95.w [Flow: jump]
	ora ($2C.b),Y		; 11 2C ; OR accumulator with memory ($2C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $D200.w		; 0C 00 D2 ; Test and set bits $D200.w [Reads: Accumulator] [Flags: Z]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	and $5E34.w,X		; 3D 34 5E ; AND accumulator with memory $5E34.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $7C		; 30 7C ; Branch if minus to $30, $7C [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $CB26.w,X		; DE 26 CB ; Decrement memory $CB26.w,X [Reads: X Index] [Flags: ZN]
	ldx $B4C8.w,Y		; BE C8 B4 ; Load X register $B4C8.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0A04.w		; 0C 04 0A ; Test and set bits $0A04.w [Reads: Accumulator] [Flags: Z]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0C3F0F.l,X		; 1F 0F 3F 0C ; Logical OR long $0C3F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora $1017.w		; 0D 17 10 ; Logical OR $1017.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$64.b		; E0 64 ; Compare #$64.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx $C0.b		; E4 C0 ; Compare $C0.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	dec $FECC.w		; CE CC FE ; Decrement $FECC.w [Flags: ZN]
	cpy $C000.w		; CC 00 C0 ; Compare $C000.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $BC18.w		; 20 18 BC ; Jump to subroutine at $BC18.w [Writes: Stack Pointer] [Flow: call]
	bit $3232.w,X		; 3C 32 32 ; Test bits $3232.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$20.b		; 09 20 ; Logical OR #$20.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc $18B458.l		; EF 58 B4 18 ; Subtract with carry (long) $18B458.l [Writes: Accumulator] [Flags: ZVNC]
	adc ($0C.b)		; 72 0C ; Add with carry (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsl $200400.l		; 22 00 04 20 ; Jump to subroutine long $200400.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda $257FFF.l,X		; BF FF 7F 25 ; Load long $257FFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $FF16.w,X		; 1D 16 FF ; OR accumulator with memory $FF16.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and $365F14.l		; 2F 14 5F 36 ; AND accumulator with memory (long) $365F14.l [Writes: Accumulator] [Flags: ZN]
	jsl $4CE000.l		; 22 00 E0 4C ; Jump to subroutine long $4CE000.l [Writes: Stack Pointer] [Flow: call]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	sbc $08F9FB.l,X		; FF FB F9 08 ; Subtract with carry (long,X) $08F9FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $77		; 10 77 ; Branch if plus to $10, $77 [Flow: branch]
	jsr $40EF.w		; 20 EF 40 ; Jump to subroutine at $40EF.w [Writes: Stack Pointer] [Flow: call]
	adc $005F00.l		; 6F 00 5F 00 ; Add with carry (long) $005F00.l [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$2C.b],Y		; 17 2C ; OR accumulator with memory (long indexed) [$2C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $B0, $70		; B0 70 ; Branch if carry set to $B0, $70 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $000F0F.l,X		; FF 0F 0F 00 ; Subtract with carry (long,X) $000F0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$05.b],Y		; F7 05 ; Subtract with carry (long indexed) [$05.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora ($F3.b,X)		; 01 F3 ; Logical OR ($F3.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $EB.b		; 02 EB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $D3.b		; 02 D3 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $A7.b		; 02 A7 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	sbc $0D170B.l,X		; FF 0B 17 0D ; Subtract with carry (long,X) $0D170B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $2D.b,X		; 15 2D ; OR accumulator with memory $2D.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	jsr ($8600.w,X)		; FC 00 86 ; Jump to subroutine indirect indexed ($8600.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp ($F01C.w,X)		; 7C 1C F0 ; Jump indirect indexed to ($F01C.w,X) [Reads: X Index] [Flow: jump]
	jmp ($FEE8.w,X)		; 7C E8 FE ; Jump indirect indexed to ($FEE8.w,X) [Reads: X Index] [Flow: jump]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $E202.w,X		; FD 02 E2 ; Subtract with carry $E202.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $10FC.w		; 1C FC 10 ; Test and reset bits $10FC.w [Reads: Accumulator] [Flags: Z]
	jsr ($FCFE.w,X)		; FC FE FC ; Jump to subroutine indirect indexed ($FCFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($BFFE.w,X)		; FC FE BF ; Jump to subroutine indirect indexed ($BFFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldx $253C.w,Y		; BE 3C 25 ; Load X register $253C.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1200.w		; 0C 00 12 ; Test and set bits $1200.w [Reads: Accumulator] [Flags: Z]
	tsb $186D.w		; 0C 6D 18 ; Test and set bits $186D.w [Reads: Accumulator] [Flags: Z]
	ldx $B859.w		; AE 59 B8 ; Load $B859.w into X register [Writes: X Index] [Flags: ZN]
	eor [$22.b],Y		; 57 22 ; Exclusive OR accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $7D1E.w		; 0C 1E 7D ; Test and set bits $7D1E.w [Reads: Accumulator] [Flags: Z]
	sbc $0008FF.l,X		; FF FF 08 00 ; Subtract with carry (long,X) $0008FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $0800.w		; 1C 00 08 ; Test and reset bits $0800.w [Reads: Accumulator] [Flags: Z]
	mvp $2A,$00		; 44 00 2A ; Move block positive $2A,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$14.b]		; 47 14 ; Exclusive OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	and $14.b,S		; 23 14 ; AND accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $BC0C00.l		; 22 00 0C BC ; Jump to subroutine long $BC0C00.l [Writes: Stack Pointer] [Flow: call]
	and $3414EF.l		; 2F EF 14 34 ; AND accumulator with memory (long) $3414EF.l [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $3F08.w,X		; 3D 08 3F ; AND accumulator with memory $3F08.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($2F.b,S),Y		; 13 2F ; OR accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0022.w,X		; 1E 22 00 ; Arithmetic shift left $0022.w,X [Reads: X Index] [Flags: ZNC]
	trb $DF.b		; 14 DF ; Test and reset bits $DF.b [Reads: Accumulator] [Flags: Z]
	sbc $2C3F37.l		; EF 37 3F 2C ; Subtract with carry (long) $2C3F37.l [Writes: Accumulator] [Flags: ZVNC]
	and [$1E.b],Y		; 37 1E ; AND accumulator with memory (long indexed) [$1E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx $1C18.w		; EC 18 1C ; Compare $1C18.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	pea $7810.w		; F4 10 78 ; Push absolute address $7810.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jsl $FC1400.l		; 22 00 14 FC ; Jump to subroutine long $FC1400.l [Writes: Stack Pointer] [Flow: call]
	pea $1CEC.w		; F4 EC 1C ; Push absolute address $1CEC.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	stz $EC.b,X		; 74 EC ; Store zero to $EC.b,X [Reads: X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7F.b,S),Y		; 13 7F ; OR accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $3C3C7C.l,X		; 3F 7C 3C 3C ; AND accumulator with memory (long,X) $3C3C7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $1E3E.w		; 1C 3E 1E ; Test and reset bits $1E3E.w [Reads: Accumulator] [Flags: Z]
	ora $220707.l,X		; 1F 07 07 22 ; Logical OR long $220707.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $4340.w		; 2C 40 43 ; Test bits $4340.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $EE38.w,X		; 3C 38 EE ; Test bits $EE38.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx $0C0E.w		; EC 0E 0C ; Compare $0C0E.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $1C08.w		; 0C 08 1C ; Test and set bits $1C08.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	jsl $C40700.l		; 22 00 07 C4 ; Jump to subroutine long $C40700.l [Writes: Stack Pointer] [Flow: call]
	ora ($F2.b)		; 12 F2 ; OR accumulator with memory (indirect) ($F2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pea $18E4.w		; F4 E4 18 ; Push absolute address $18E4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	eor $7F.b,S		; 43 7F ; Exclusive OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($13.b),Y		; 31 13 ; AND accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $347729.l		; 6F 29 77 34 ; Add with carry (long) $347729.l [Writes: Accumulator] [Flags: ZVNC]
	rol $1F12.w,X		; 3E 12 1F ; Rotate left $1F12.w,X [Reads: X Index] [Flags: ZNC]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $50		; 42 50 ; Reserved instruction
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $1412.w		; 2D 12 14 ; Logical AND $1412.w with accumulator [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sty $2FE0.w		; 8C E0 2F ; Store Y register to $2FE0.w [Reads: Y Index]
	sbc ($90.b)		; F2 90 ; Subtract with carry (indirect) ($90.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $24.b		; E6 24 ; Increment $24.b [Reads: Direct Page] [Flags: ZN]
	bit $5808.w,X		; 3C 08 58 ; Test bits $5808.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$D0.b		; C0 D0 ; Compare #$D0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $0E		; 42 0E ; Reserved instruction
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	pea $28E8.w		; F4 E8 28 ; Push absolute address $28E8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $D0, $7F		; D0 7F ; Branch if not equal to $D0, $7F [Flow: branch]
	and ($4F.b,X)		; 21 4F ; Logical AND ($4F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($5F.b,X)		; 01 5F ; Logical OR ($5F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($7E.b),Y		; 11 7E ; OR accumulator with memory ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $0E7E.w,X		; 3E 7E 0E ; Rotate left $0E7E.w,X [Reads: X Index] [Flags: ZNC]
	and $003F03.l,X		; 3F 03 3F 00 ; AND accumulator with memory (long,X) $003F03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	lsr $6078.w,X		; 5E 78 60 ; Logical shift right $6078.w,X [Reads: X Index] [Flags: ZNC]
	eor ($71.b,X)		; 41 71 ; Exclusive OR accumulator with memory ($71.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $102F.w		; 2C 2F 10 ; Test bits $102F.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	jsr ($BCE8.w,X)		; FC E8 BC ; Jump to subroutine indirect indexed ($BCE8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $B0, $43		; B0 43 ; Branch if carry set to $B0, $43 [Flow: branch]
	trb $0418.w		; 1C 18 04 ; Test and reset bits $0418.w [Reads: Accumulator] [Flags: Z]
	bit $F838.w,X		; 3C 38 F8 ; Test bits $F838.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	jsl $2AE000.l		; 22 00 E0 2A ; Jump to subroutine long $2AE000.l [Writes: Stack Pointer] [Flow: call]
	trb $4C.b		; 14 4C ; Test and reset bits $4C.b [Reads: Accumulator] [Flags: Z]
	cpx $E4.b		; E4 E4 ; Compare $E4.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy $18.b		; C4 18 ; Compare $18.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	ora $2F0E.w,Y		; 19 0E 2F ; OR accumulator with memory $2F0E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $391837.l,X		; 1F 37 18 39 ; Logical OR long $391837.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $133F.w		; 0E 3F 13 ; Arithmetic shift left $133F.w [Flags: ZNC]
	and $04360C.l		; 2F 0C 36 04 ; AND accumulator with memory (long) $04360C.l [Writes: Accumulator] [Flags: ZN]
	trb $1F00.w		; 1C 00 1F ; Test and reset bits $1F00.w [Reads: Accumulator] [Flags: Z]
	and $2F3836.l		; 2F 36 38 2F ; AND accumulator with memory (long) $2F3836.l [Writes: Accumulator] [Flags: ZN]
	and ($2A.b,S),Y		; 33 2A ; AND accumulator (stack relative indirect indexed) ($2A.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $6C9D.w		; 1C 9D 6C ; Test and reset bits $6C9D.w [Reads: Accumulator] [Flags: Z]
	sbc $EAE8.w,Y		; F9 E8 EA ; Subtract with carry $EAE8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $9E		; 10 9E ; Branch if plus to $10, $9E [Flow: branch]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl $F7F3.w		; 0E F3 F7 ; Arithmetic shift left $F7F3.w [Flags: ZNC]
	ror $F41E.w		; 6E 1E F4 ; Rotate right $F41E.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $BA00.w,X		; 5D 00 BA ; Exclusive OR accumulator with memory $BA00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	and $172EE0.l,X		; 3F E0 2E 17 ; AND accumulator with memory (long,X) $172EE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $CF.b		; C5 CF ; Compare $CF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	adc $292E3E.l,X		; 7F 3E 2E 29 ; Add long $292E3E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $C0FD30.l,X		; 3F 30 FD C0 ; AND accumulator with memory (long,X) $C0FD30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $EF2B.w		; CE 2B EF ; Decrement $EF2B.w [Flags: ZN]
	jmp.w [$F1B9]		; DC B9 F1 ; Jump long indirect [$F1B9] [Flow: jump]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($F8F8.w,X)		; FC F8 F8 ; Jump to subroutine indirect indexed ($F8F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $300600.l		; 22 00 06 30 ; Jump to subroutine long $300600.l [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy $98F8.w,X		; BC F8 98 ; Load Y register $98F8.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$70.b		; 09 70 ; Logical OR #$70.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $4FF728.l,X		; FF 28 F7 4F ; Subtract with carry (long,X) $4FF728.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $040022.l,X		; 5F 22 00 04 ; Exclusive OR accumulator with memory (long,X) $040022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	sbc $25BFBF.l,X		; FF BF BF 25 ; Subtract with carry (long,X) $25BFBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1A00.w		; 0C 00 1A ; Test and set bits $1A00.w [Reads: Accumulator] [Flags: Z]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $E41DF6.l		; EF F6 1D E4 ; Subtract with carry (long) $E41DF6.l [Writes: Accumulator] [Flags: ZVNC]
	jsl $0C0400.l		; 22 00 04 0C ; Jump to subroutine long $0C0400.l [Writes: Stack Pointer] [Flow: call]
	asl $F9FD.w,X		; 1E FD F9 ; Arithmetic shift left $F9FD.w,X [Reads: X Index] [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $13.b		; 04 13 ; Test and set bits $13.b [Reads: Accumulator] [Flags: Z]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $23.b		; 05 23 ; Logical OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1D0B.w		; 0C 0B 1D ; Test and set bits $1D0B.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $B8		; 10 B8 ; Branch if plus to $10, $B8 [Flow: branch]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	.db $10, $B8		; 10 B8 ; Branch if plus to $10, $B8 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($7068.w,X)		; FC 68 70 ; Jump to subroutine indirect indexed ($7068.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $B0, $88		; B0 88 ; Branch if carry set to $B0, $88 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0029.w,X)		; FC 29 00 ; Jump to subroutine indirect indexed ($0029.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0516.w		; 0C 16 05 ; Test and set bits $0516.w [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1B.b,S),Y		; 13 1B ; OR accumulator (stack relative indirect indexed) ($1B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $30.b		; 05 30 ; Logical OR $30.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $E8		; 30 E8 ; Branch if minus to $30, $E8 [Flow: branch]
	.db $B0, $24		; B0 24 ; Branch if carry set to $B0, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $6A.b,S		; 83 6A ; Store accumulator (stack relative) $6A.b,S [Reads: Accumulator, Stack Pointer]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($02.b,S),Y		; 13 02 ; OR accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$04.b],Y		; 17 04 ; OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($1D.b,S),Y		; 13 1D ; OR accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $82.b		; 84 82 ; Store Y register to $82.b [Reads: Y Index]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $D0, $6C		; D0 6C ; Branch if not equal to $D0, $6C [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0070.w,X)		; FC 70 00 ; Jump to subroutine indirect indexed ($0070.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $D0		; 10 D0 ; Branch if plus to $10, $D0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $70, $20		; 70 20 ; Branch if overflow set to $70, $20 [Flow: branch]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	mvn $3A,$38		; 54 38 3A ; Move block negative $3A,$38 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	trb $70.b		; 14 70 ; Test and reset bits $70.b [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $B0, $50		; B0 50 ; Branch if carry set to $B0, $50 [Flow: branch]
	adc [$7F.b],Y		; 77 7F ; Add with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $090025.l,X		; 3F 25 00 09 ; AND accumulator with memory (long,X) $090025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $E7.b		; 04 E7 ; Test and set bits $E7.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $4914.w		; 2D 14 49 ; Logical AND $4914.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $30, $22		; 30 22 ; Branch if minus to $30, $22 [Flow: branch]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	sbc $FFFB.w		; ED FB FF ; Subtract $FFFB.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $51.b		; 00 51 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $7A.b,X		; 74 7A ; Store zero to $7A.b,X [Reads: X Index]
	adc $363E7F.l,X		; 7F 7F 3E 36 ; Add long $363E7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FD00.l,X		; FF 00 FD 00 ; Subtract with carry (long,X) $00FD00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	mvn $AB,$00		; 54 00 AB ; Move block negative $AB,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $D7.b		; 00 D7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $E6.b,S		; 43 E6 ; Exclusive OR accumulator with stack relative $E6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $AB.b		; 02 AB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$AF.b],Y		; D7 AF ; Compare accumulator (long indexed) [$AF.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	eor $008043.l,X		; 5F 43 80 00 ; Exclusive OR accumulator with memory (long,X) $008043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $004C.w		; 0E 4C 00 ; Arithmetic shift left $004C.w [Flags: ZNC]
	adc ($0C.b)		; 72 0C ; Add with carry (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sty $F270.w		; 8C 70 F2 ; Store Y register to $F270.w [Reads: Y Index]
	jmp ($88FC.w,X)		; 7C FC 88 ; Jump indirect indexed to ($88FC.w,X) [Reads: X Index] [Flow: jump]
	asl $80E0.w,X		; 1E E0 80 ; Arithmetic shift left $80E0.w,X [Reads: X Index] [Flags: ZNC]
	.db $80, $CC		; 80 CC ; Branch always to $80, $CC [Flow: branch]
	mvp $FC,$FE		; 44 FE FC ; Move block positive $FC,$FE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1E00.w		; 0E 00 1E ; Arithmetic shift left $1E00.w [Flags: ZNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $59.b		; 00 59 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $5D.b		; 06 5D ; Arithmetic shift left $5D.b [Reads: Direct Page] [Flags: ZNC]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1F03.w		; 2C 03 1F ; Test bits $1F03.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($2F.b,S),Y		; 13 2F ; OR accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc #$69.b		; 69 69 ; Add #$69.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	ror $5E00.w,X		; 7E 00 5E ; Rotate right $5E00.w,X [Reads: X Index] [Flags: ZNC]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A9.b		; 00 A9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($81.b,X)		; 01 81 ; Logical OR ($81.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	lda ($D0.b,X)		; A1 D0 ; Load accumulator ($D0.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy #$D4.b		; A0 D4 ; Load #$D4.b into Y register [Writes: Y Index] [Flags: ZN]
	sbc #$D7.b		; E9 D7 ; Subtract #$D7.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	sbc $008043.l		; EF 43 80 00 ; Subtract with carry (long) $008043.l [Writes: Accumulator] [Flags: ZVNC]
	eor $40.b		; 45 40 ; Exclusive OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	nop		; EA ; No operation
	stz $80.b,X		; 74 80 ; Store zero to $80.b,X [Reads: X Index]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	and $F8.b		; 25 F8 ; Logical AND $F8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr ($7CFE.w,X)		; FC FE 7C ; Jump to subroutine indirect indexed ($7CFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $77172F.l		; 0F 2F 17 77 ; OR accumulator with memory (long) $77172F.l [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $6F0E.w,Y		; 79 0E 6F ; Add $6F0E.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($73.b,X)		; 21 73 ; Logical AND ($73.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $30, $7E		; 30 7E ; Branch if minus to $30, $7E [Flow: branch]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $5E7977.l		; 2F 77 79 5E ; AND accumulator with memory (long) $5E7977.l [Writes: Accumulator] [Flags: ZN]
	eor $393C7A.l		; 4F 7A 3C 39 ; Exclusive OR accumulator with memory (long) $393C7A.l [Writes: Accumulator] [Flags: ZN]
	.db $F0, $EB		; F0 EB ; Branch if equal to $F0, $EB [Flow: branch]
	and ($3E.b)		; 32 3E ; AND accumulator with memory (indirect) ($3E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $7810.w,X		; 3C 10 78 ; Test bits $7810.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$27.b		; E0 27 ; Compare #$27.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $FCFEED.l,X		; FF ED FE FC ; Subtract with carry (long,X) $FCFEED.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora [$31.b],Y		; 17 31 ; OR accumulator with memory (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0F0F1C.l,X		; 1F 1C 0F 0F ; Logical OR long $0F0F1C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0F1C33.l		; 2F 33 1C 0F ; AND accumulator with memory (long) $0F1C33.l [Writes: Accumulator] [Flags: ZN]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	pea $FCE6.w		; F4 E6 FC ; Push absolute address $FCE6.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	trb $83F8.w		; 1C F8 83 ; Test and reset bits $83F8.w [Reads: Accumulator] [Flags: Z]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $E0.b,X		; 16 E0 ; Arithmetic shift left $E0.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	inc $1C.b		; E6 1C ; Increment $1C.b [Reads: Direct Page] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$1D.b		; C0 1D ; Compare #$1D.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7F.b		; 05 7F ; Logical OR $7F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $337F.w		; 0C 7F 33 ; Test and set bits $337F.w [Reads: Accumulator] [Flags: Z]
	and $E00024.l,X		; 3F 24 00 E0 ; AND accumulator with memory (long,X) $E00024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $733A.w,X		; 3C 3A 73 ; Test bits $733A.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	eor $00003F.l		; 4F 3F 00 00 ; Exclusive OR accumulator with memory (long) $00003F.l [Writes: Accumulator] [Flags: ZN]
	cpx $FCB8.w		; EC B8 FC ; Compare $FCB8.w with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $E2		; 30 E2 ; Branch if minus to $30, $E2 [Flow: branch]
	jsr ($F81E.w,X)		; FC 1E F8 ; Jump to subroutine indirect indexed ($F81E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FEE4.w,X		; FE E4 FE ; Increment memory $FEE4.w,X [Reads: X Index] [Flags: ZN]
	trb $084C.w		; 1C 4C 08 ; Test and reset bits $084C.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($1EE2.w,X)		; FC E2 1E ; Jump to subroutine indirect indexed ($1EE2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
.ACCU 8
.INDEX 8
	sep #$74		; E2 74
	sec		; 38 ; Set carry flag [Flags: C]
	ora $162B0A.l,X		; 1F 0A 2B 16 ; Logical OR long $162B0A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($1E.b,S),Y		; 33 1E ; AND accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0F0E.w,X		; 1D 0E 0F ; OR accumulator with memory $0F0E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $88.b		; 02 88 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $C483.w,X		; 1D 83 C4 ; OR accumulator with memory $C483.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	trb $76.b		; 14 76 ; Test and reset bits $76.b [Reads: Accumulator] [Flags: Z]
	jmp $3818EC.l		; 5C EC 18 38 ; Jump long to $3818EC.l [Flow: jump]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sta $D2.b		; 85 D2 ; Store accumulator to $D2.b [Reads: Accumulator]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ldx $EC.b,Y		; B6 EC ; Load X register $EC.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $E0		; B0 E0 ; Branch if carry set to $B0, $E0 [Flow: branch]
	jsr $19C0.w		; 20 C0 19 ; Jump to subroutine at $19C0.w [Writes: Stack Pointer] [Flow: call]
	asl $172F.w		; 0E 2F 17 ; Arithmetic shift left $172F.w [Flags: ZNC]
	sta $74.b		; 85 74 ; Store accumulator to $74.b [Reads: Accumulator]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$04.b],Y		; 37 04 ; AND accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0022.w,X		; 1E 22 00 ; Arithmetic shift left $0022.w,X [Reads: X Index] [Flags: ZNC]
	sty $80.b		; 84 80 ; Store Y register to $80.b [Reads: Y Index]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	asl $9B00.w,X		; 1E 00 9B ; Arithmetic shift left $9B00.w,X [Reads: X Index] [Flags: ZNC]
	adc ($F6.b)		; 72 F6 ; Add with carry (indirect) ($F6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx $9C18.w		; EC 18 9C ; Compare $9C18.w with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpx $7820.w		; EC 20 78 ; Compare $7820.w with X register [Reads: X Index] [Flags: ZNC]
	jsl $FD0A00.l		; 22 00 0A FD ; Jump to subroutine long $FD0A00.l [Writes: Stack Pointer] [Flow: call]
	inc $6C.b,X		; F6 6C ; Increment memory $6C.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	trb $D4F4.w		; 1C F4 D4 ; Test and reset bits $D4F4.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $03,$00		; 44 00 03 ; Move block positive $03,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00220F.l		; 0F 0F 22 00 ; OR accumulator with memory (long) $00220F.l [Writes: Accumulator] [Flags: ZN]
	trb $0E.b		; 14 0E ; Test and reset bits $0E.b [Reads: Accumulator] [Flags: Z]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: ZNC]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: ZNC]
	ora [$FD.b],Y		; 17 FD ; OR accumulator with memory (long indexed) [$FD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($F6.b,S),Y		; 33 F6 ; AND accumulator (stack relative indirect indexed) ($F6.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0C97.w		; 0D 97 0C ; Logical OR $0C97.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cmp #$86.b		; C9 86 ; Compare #$86.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	dec $22.b		; C6 22 ; Decrement $22.b [Reads: Direct Page] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FFCFAF.l,X		; 3F AF CF FF ; AND accumulator with memory (long,X) $FFCFAF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $00C64F.l,X		; 9F 4F C6 00 ; Store accumulator (long,X) $00C64F.l,X [Reads: Accumulator, X Index]
	sta $00FE76.l		; 8F 76 FE 00 ; Store accumulator (long) $00FE76.l [Reads: Accumulator]
	jsr ($7C18.w,X)		; FC 18 7C ; Jump to subroutine indirect indexed ($7C18.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sed		; F8 ; Set decimal flag [Flags: D]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FCFCFE.l,X		; FF FE FC FC ; Subtract with carry (long,X) $FCFCFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $6F.b		; 84 6F ; Store Y register to $6F.b [Reads: Y Index]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0C3E00.l		; 0F 00 3E 0C ; OR accumulator with memory (long) $0C3E00.l [Writes: Accumulator] [Flags: ZN]
	adc $223F3E.l,X		; 7F 3E 3F 22 ; Add long $223F3E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$1B.b],Y		; 37 1B ; AND accumulator with memory (long indexed) [$1B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0F05.w		; 0E 05 0F ; Arithmetic shift left $0F05.w [Flags: ZNC]
	and ($41.b)		; 32 41 ; AND accumulator with memory (indirect) ($41.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $03C600.l,X		; 3F 00 C6 03 ; AND accumulator with memory (long,X) $03C600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $F9.b		; 05 F9 ; Logical OR $F9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $FD.b,X		; 16 FD ; Arithmetic shift left $FD.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $7D.b,X		; 36 7D ; Rotate left $7D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $0A.b,X		; 15 0A ; OR accumulator with memory $0A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $7F00.w		; 0D 00 7F ; Logical OR $7F00.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $7FCFAF.l,X		; 3F AF CF 7F ; AND accumulator with memory (long,X) $7FCFAF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $740D1F.l,X		; 1F 1F 0D 74 ; Logical OR long $740D1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $BEC0.w,X		; 3C C0 BE ; Test bits $BEC0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jmp.w [$C0BC]		; DC BC C0 ; Jump long indirect [$C0BC] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FCFE.w,X)		; FC FE FC ; Jump to subroutine indirect indexed ($FCFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	sbc $3847E0.l,X		; FF E0 47 38 ; Subtract with carry (long,X) $3847E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $3D7B38.l		; 6F 38 7B 3D ; Add with carry (long) $3D7B38.l [Writes: Accumulator] [Flags: ZVNC]
	and [$0D.b],Y		; 37 0D ; AND accumulator with memory (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $063E07.l		; 0F 07 3E 06 ; OR accumulator with memory (long) $063E07.l [Writes: Accumulator] [Flags: ZN]
	jmp $7C382C.l		; 5C 2C 38 7C ; Jump long to $7C382C.l [Flow: jump]
	adc $08325A.l,X		; 7F 5A 32 08 ; Add long $08325A.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $1C5F.w,X		; 3D 5F 1C ; AND accumulator with memory $1C5F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1CF6.w		; 1C F6 1C ; Test and reset bits $1CF6.w [Reads: Accumulator] [Flags: Z]
	dec $ECBC.w,X		; DE BC EC ; Decrement memory $ECBC.w,X [Reads: X Index] [Flags: ZN]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	cpx #$7C.b		; E0 7C ; Compare #$7C.b with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	bit $1C.b,X		; 34 1C ; Test bits $1C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	rol $5AFE.w,X		; 3E FE 5A ; Rotate left $5AFE.w,X [Reads: X Index] [Flags: ZNC]
	jmp $BC10.w		; 4C 10 BC ; Jump to $BC10.w [Flow: jump]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	.db $70, $DF		; 70 DF ; Branch if overflow set to $70, $DF [Flow: branch]
	adc ($FF.b,S),Y		; 73 FF ; Add with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$67.b],Y		; 77 67 ; Add with carry (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($3E.b,S),Y		; 13 3E ; OR accumulator (stack relative indirect indexed) ($3E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	asl $7000.w		; 0E 00 70 ; Arithmetic shift left $7000.w [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($6CB8.w,X)		; FC B8 6C ; Jump to subroutine indirect indexed ($6CB8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $8339.w,X		; 3D 39 83 ; AND accumulator with memory $8339.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($EC.b,S),Y		; 13 EC ; OR accumulator (stack relative indirect indexed) ($EC.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp.w [$A8B8]		; DC B8 A8 ; Jump long indirect [$A8B8] [Flow: jump]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	jsr $203E.w		; 20 3E 20 ; Jump to subroutine at $203E.w [Writes: Stack Pointer] [Flow: call]
	adc $7C3876.l,X		; 7F 76 38 7C ; Add long $7C3876.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($C854.w,X)		; FC 54 C8 ; Jump to subroutine indirect indexed ($C854.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $D0, $FE		; D0 FE ; Branch if not equal to $D0, $FE [Flow: branch]
	sbc $100023.l,X		; FF 23 00 10 ; Subtract with carry (long,X) $100023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $00230F.l		; 22 0F 23 00 ; Jump to subroutine long $00230F.l [Writes: Stack Pointer] [Flow: call]
	ora $E000C0.l		; 0F C0 00 E0 ; OR accumulator with memory (long) $E000C0.l [Writes: Accumulator] [Flags: ZN]
	cpy #$70.b		; C0 70 ; Compare #$70.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	and $F0.b,S		; 23 F0 ; AND accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $38.b		; 04 38 ; Test and set bits $38.b [Reads: Accumulator] [Flags: Z]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $380200.l		; 0F 00 02 38 ; OR accumulator with memory (long) $380200.l [Writes: Accumulator] [Flags: ZN]
	mvp $22,$3A		; 44 3A 22 ; Move block positive $22,$3A [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $E0.b		; 05 E0 ; Logical OR $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp ($0B.b,X)		; C1 0B ; Compare accumulator ($0B.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $5E335E.l,X		; 1F 5E 33 5E ; Logical OR long $5E335E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $BF.b,S		; 23 BF ; AND accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $9878E3.l,X		; 3F E3 78 98 ; AND accumulator with memory (long,X) $9878E3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$53.b]		; 27 53 ; AND accumulator with memory (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$A7.b]		; 47 A7 ; Exclusive OR accumulator with memory (long) [$A7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $1067.w,X		; 3C 67 10 ; Test bits $1067.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora [$67.b],Y		; 17 67 ; OR accumulator with memory (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $26FE.w,Y		; 99 FE 26 ; Store accumulator to $26FE.w,Y [Reads: Accumulator, Y Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor $DE35FF.l		; 4F FF 35 DE ; Exclusive OR accumulator with memory (long) $DE35FF.l [Writes: Accumulator] [Flags: ZN]
	bit $495B.w		; 2C 5B 49 ; Test bits $495B.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ldx $10.b,Y		; B6 10 ; Load X register $10.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	adc $DA.b,S		; 63 DA ; Add with carry (stack relative) $DA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	lda ($7F.b,S),Y		; B3 7F ; Load accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $4B.b,X		; 56 4B ; Logical shift right $4B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	lda [$00.b]		; A7 00 ; Load accumulator (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	sbc $3DC8.w,Y		; F9 C8 3D ; Subtract with carry $3DC8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $CE.b,X		; 34 CE ; Test bits $CE.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sty $FF.b		; 84 FF ; Store Y register to $FF.b [Reads: Y Index]
	.db $F0, $7F		; F0 7F ; Branch if equal to $F0, $7F [Flow: branch]
	trb $EF.b		; 14 EF ; Test and reset bits $EF.b [Reads: Accumulator] [Flags: Z]
	sty $C27F.w		; 8C 7F C2 ; Store Y register to $C27F.w [Reads: Y Index]
	and ($19.b),Y		; 31 19 ; AND accumulator with memory ($19.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpy $758D.w		; CC 8D 75 ; Compare $758D.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $98		; 80 98 ; Branch always to $80, $98 [Flow: branch]
	sbc ($4E.b,X)		; E1 4E ; Subtract with carry ($4E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($62.b,S),Y		; 73 62 ; Add with carry (stack relative indirect indexed) ($62.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $3D1B.w,X		; 7D 1B 3D ; Add $3D1B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $040E.w		; 0D 0E 04 ; Logical OR $040E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $E18000.l		; 0F 00 80 E1 ; OR accumulator with memory (long) $E18000.l [Writes: Accumulator] [Flags: ZN]
	adc ($7D.b,S),Y		; 73 7D ; Add with carry (stack relative indirect indexed) ($7D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $0F0E.w,X		; 3D 0E 0F ; AND accumulator with memory $0F0E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $70, $4C		; 70 4C ; Branch if overflow set to $70, $4C [Flow: branch]
	cmp $B0.b,S		; C3 B0 ; Compare accumulator (stack relative) $B0.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	.db $42, $A1		; 42 A1 ; Reserved instruction
	tsb $E3.b		; 04 E3 ; Test and set bits $E3.b [Reads: Accumulator] [Flags: Z]
	tsb $C2.b		; 04 C2 ; Test and set bits $C2.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp $A1B0.w		; 4C B0 A1 ; Jump to $A1B0.w [Flow: jump]
	sbc $C2.b,S		; E3 C2 ; Subtract stack-relative $C2.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $1D.b,S		; 03 1D ; OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $32		; 10 32 ; Branch if plus to $10, $32 [Flow: branch]
	ora ($3D.b),Y		; 11 3D ; OR accumulator with memory ($3D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1F1E.w		; 0C 1E 1F ; Test and set bits $1F1E.w [Reads: Accumulator] [Flags: Z]
	and $FF252E.l		; 2F 2E 25 FF ; AND accumulator with memory (long) $FF252E.l [Writes: Accumulator] [Flags: ZN]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $81		; 70 81 ; Branch if overflow set to $70, $81 [Flow: branch]
	ror $4FB8.w,X		; 7E B8 4F ; Rotate right $4FB8.w,X [Reads: X Index] [Flags: ZNC]
	ror $738F.w,X		; 7E 8F 73 ; Rotate right $738F.w,X [Reads: X Index] [Flags: ZNC]
	sbc $F8E7.w,X		; FD E7 F8 ; Subtract with carry $F8E7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
.ACCU 8
.INDEX 8
	sep #$3D		; E2 3D
	.db $F0, $8E		; F0 8E ; Branch if equal to $F0, $8E [Flow: branch]
	sta ($88.b,X)		; 81 88 ; Store accumulator ($88.b,X) [Reads: Accumulator, X Index, Direct Page]
	ror $F87D.w		; 6E 7D F8 ; Rotate right $F87D.w [Flags: ZNC]
	lda $00C0.w,X		; BD C0 00 ; Load $00C0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	mvn $D8,$E0		; 54 E0 D8 ; Move block negative $D8,$E0 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$68.b		; E0 68 ; Compare #$68.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpx $F6.b		; E4 F6 ; Compare $F6.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	ldx $D85C.w,Y		; BE 5C D8 ; Load X register $D85C.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$62.b		; E0 62 ; Compare #$62.b with X register [Reads: X Index] [Flags: ZNC]
	stz $7F6C.w		; 9C 6C 7F ; Store zero to $7F6C.w
	ora $7F0F3F.l,X		; 1F 3F 0F 7F ; Logical OR long $7F0F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$CF.b],Y		; 37 CF ; AND accumulator with memory (long indexed) [$CF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $BE.b,X		; 76 BE ; Rotate right $BE.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $014F.w		; 4D 4F 01 ; Exclusive OR $014F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta ($61.b,S),Y		; 93 61 ; Store accumulator (stack relative indirect indexed) ($61.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	and ($79.b,S),Y		; 33 79 ; AND accumulator (stack relative indirect indexed) ($79.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp #$B2.b		; C9 B2 ; Compare #$B2.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	eor $363901.l		; 4F 01 39 36 ; Exclusive OR accumulator with memory (long) $363901.l [Writes: Accumulator] [Flags: ZN]
	inc $FCF8.w,X		; FE F8 FC ; Increment memory $FCF8.w,X [Reads: X Index] [Flags: ZN]
	.db $F0, $FE		; F0 FE ; Branch if equal to $F0, $FE [Flow: branch]
	cpx $6EF3.w		; EC F3 6E ; Compare $6EF3.w with X register [Reads: X Index] [Flags: ZNC]
	adc $F2B2.w,X		; 7D B2 F2 ; Add $F2B2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $CC.b		; 86 CC ; Store X register to $CC.b [Reads: X Index]
	stz $4D93.w,X		; 9E 93 4D ; Store zero to $4D93.w,X [Reads: X Index]
	sbc ($80.b)		; F2 80 ; Subtract with carry (indirect) ($80.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $5FBF2F.l,X		; 5F 2F BF 5F ; Exclusive OR accumulator with memory (long,X) $5FBF2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $173F0F.l,X		; 7F 0F 3F 17 ; Add long $173F0F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$3A.b]		; 67 3A ; Add with carry (long) [$3A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $2F35.w		; 6E 35 2F ; Rotate right $2F35.w [Flags: ZNC]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	brk $52.b		; 00 52 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$72.b]		; A7 72 ; Load accumulator (long) [$72.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $6A.b		; 65 6A ; Add $6A.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $343A11.l		; 2F 11 3A 34 ; AND accumulator with memory (long) $343A11.l [Writes: Accumulator] [Flags: ZN]
	jsr ($FEF8.w,X)		; FC F8 FE ; Jump to subroutine indirect indexed ($FEF8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	inc $6CF2.w		; EE F2 6C ; Increment $6CF2.w [Flags: ZN]
	jsr ($70B0.w,X)		; FC B0 70 ; Jump to subroutine indirect indexed ($70B0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	ora $70CC92.l,X		; 1F 92 CC 70 ; Logical OR long $70CC92.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$07.b		; E0 07 ; Compare #$07.b with X register [Reads: X Index] [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $030000.l		; 22 00 00 03 ; Jump to subroutine long $030000.l [Writes: Stack Pointer] [Flow: call]
	mvp $0F,$00		; 44 00 0F ; Move block positive $0F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $070A00.l		; 22 00 0A 07 ; Jump to subroutine long $070A00.l [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $E00003.l		; 0F 03 00 E0 ; OR accumulator with memory (long) $E00003.l [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $C00000.l		; 22 00 00 C0 ; Jump to subroutine long $C00000.l [Writes: Stack Pointer] [Flow: call]
	mvp $F0,$00		; 44 00 F0 ; Move block positive $F0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E00E00.l		; 22 00 0E E0 ; Jump to subroutine long $E00E00.l [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $13,$00		; 44 00 13 ; Move block positive $13,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $77E000.l		; 22 00 E0 77 ; Jump to subroutine long $77E000.l [Writes: Stack Pointer] [Flow: call]
	cpx #$60.b		; E0 60 ; Compare #$60.b with X register [Reads: X Index] [Flags: ZNC]
	cmp $A0BFD7.l,X		; DF D7 BF A0 ; Compare accumulator (long,X) $A0BFD7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $C0FFE0.l,X		; FF E0 FF C0 ; Subtract with carry (long,X) $C0FFE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $28FF20.l,X		; FF 20 FF 28 ; Subtract with carry (long,X) $28FF20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $289F00.l,X		; 3F 00 9F 28 ; AND accumulator with memory (long,X) $289F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $CF371C.l,X		; 5F 1C 37 CF ; Exclusive OR accumulator with memory (long,X) $CF371C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor [$33.b]		; 47 33 ; Exclusive OR accumulator with memory (long) [$33.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	pea $DEA9.w		; F4 A9 DE ; Push absolute address $DEA9.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	lda $DF.b		; A5 DF ; Load $DF.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta ($EF.b)		; 92 EF ; Store accumulator (indirect) ($EF.b) [Reads: Accumulator, Direct Page]
	sta $7FC677.l		; 8F 77 C6 7F ; Store accumulator (long) $7FC677.l [Reads: Accumulator]
	.db $30, $3F		; 30 3F ; Branch if minus to $30, $3F [Flow: branch]
	asl $E709.w		; 0E 09 E7 ; Arithmetic shift left $E709.w [Flags: ZNC]
	cmp $27AFDF.l,X		; DF DF AF 27 ; Compare accumulator (long,X) $27AFDF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	eor [$31.b]		; 47 31 ; Exclusive OR accumulator with memory (long) [$31.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	nop		; EA ; No operation
	trb $3EE8.w		; 1C E8 3E ; Test and reset bits $3EE8.w [Reads: Accumulator] [Flags: Z]
	ldy $ED.b,X		; B4 ED ; Load Y register $ED.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $62, $DD, $82		; 62 DD 82 ; Push effective relative address $62, $DD, $82 [Writes: Stack Pointer]
	sbc $B21EE4.l,X		; FF E4 1E B2 ; Subtract with carry (long,X) $B21EE4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($F00C.w,X)		; 7C 0C F0 ; Jump indirect indexed to ($F00C.w,X) [Reads: X Index] [Flow: jump]
	jmp.w [$ECBC]		; DC BC EC ; Jump long indirect [$ECBC] [Flow: jump]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	dec $1C.b,X		; D6 1C ; Decrement memory $1C.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $0406.w		; 0C 06 04 ; Test and set bits $0406.w [Reads: Accumulator] [Flags: Z]
	jsr $0002.w		; 20 02 00 ; Jump to subroutine at $0002.w [Writes: Stack Pointer] [Flow: call]
	jsr $7804.w		; 20 04 78 ; Jump to subroutine at $7804.w [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: ZNC]
	tsb $0204.w		; 0C 04 02 ; Test and set bits $0204.w [Reads: Accumulator] [Flags: Z]
	jsr $0078.w		; 20 78 00 ; Jump to subroutine at $0078.w [Writes: Stack Pointer] [Flow: call]
	ora ($C1.b,S),Y		; 13 C1 ; OR accumulator (stack relative indirect indexed) ($C1.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($80.b)		; 12 80 ; OR accumulator with memory (indirect) ($80.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $80		; 10 80 ; Branch if plus to $10, $80 [Flow: branch]
	jsr $2210.w		; 20 10 22 ; Jump to subroutine at $2210.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $40		; 10 40 ; Branch if plus to $10, $40 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $60.b		; 14 60 ; Test and reset bits $60.b [Reads: Accumulator] [Flags: Z]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	cmp ($80.b,X)		; C1 80 ; Compare accumulator ($80.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1306.w,Y		; 19 06 13 ; OR accumulator with memory $1306.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $3803.w,X		; 3C 03 38 ; Test bits $3803.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora [$74.b]		; 07 74 ; OR accumulator with memory (long) [$74.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $73.b,S		; 03 73 ; OR accumulator with stack relative $73.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $72.b		; 00 72 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $75.b		; 00 75 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $28.b		; 24 28 ; Test bits $28.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	mvn $53,$53		; 54 53 53 ; Move block negative $53,$53 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	lsr $43.b,X		; 56 43 ; Logical shift right $43.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: ZNC]
	ora ($F0.b,S),Y		; 13 F0 ; OR accumulator (stack relative indirect indexed) ($F0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $8DFF3E.l,X		; FF 3E FF 8D ; Subtract with carry (long,X) $8DFF3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $F23F42.l,X		; 7F 42 3F F2 ; Add long $F23F42.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $BF0FF3.l		; 0F F3 0F BF ; OR accumulator with memory (long) $BF0FF3.l [Writes: Accumulator] [Flags: ZN]
	and $8D3FFF.l,X		; 3F FF 3F 8D ; AND accumulator with memory (long,X) $8D3FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $33.b,S		; C3 33 ; Compare accumulator (stack relative) $33.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	and ($47.b,S),Y		; 33 47 ; AND accumulator (stack relative indirect indexed) ($47.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $F0, $43		; F0 43 ; Branch if equal to $F0, $43 [Flow: branch]
	.db $50, $E0		; 50 E0 ; Branch if overflow clear to $50, $E0 [Flow: branch]
	ora ($A0.b,X)		; 01 A0 ; Logical OR ($A0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpy #$24.b		; C0 24 ; Compare #$24.b with Y register [Reads: Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cop $D0.b		; 02 D0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $A0		; D0 A0 ; Branch if not equal to $D0, $A0 [Flow: branch]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$1C.b],Y		; 17 1C ; OR accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $003F.w		; 1C 3F 00 ; Test and reset bits $003F.w [Reads: Accumulator] [Flags: Z]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $1E.b,X		; 35 1E ; Logical AND $1E.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	asl $011F.w,X		; 1E 1F 01 ; Arithmetic shift left $011F.w,X [Reads: X Index] [Flags: ZNC]
	ora $3E1C0D.l,X		; 1F 0D 1C 3E ; Logical OR long $3E1C0D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $393D3E.l,X		; 3F 3E 3D 39 ; AND accumulator with memory (long,X) $393D3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $2312.w,X		; 1E 12 23 ; Arithmetic shift left $2312.w,X [Reads: X Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $B0, $A0		; B0 A0 ; Branch if carry set to $B0, $A0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	jsr $10A0.w		; 20 A0 10 ; Jump to subroutine at $10A0.w [Writes: Stack Pointer] [Flow: call]
	.db $70, $0E		; 70 0E ; Branch if overflow set to $70, $0E [Flow: branch]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0C1F.w		; 0E 1F 0C ; Arithmetic shift left $0C1F.w [Flags: ZNC]
	ora $1C2301.l,X		; 1F 01 23 1C ; Logical OR long $1C2301.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $1E.b,X		; 34 1E ; Test bits $1E.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0E011F.l,X		; 1F 1F 01 0E ; Logical OR long $0E011F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3F1E1F.l,X		; 1F 1F 1E 3F ; Logical OR long $3F1E1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $1E38.w,X		; 3D 38 1E ; AND accumulator with memory $1E38.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($1C.b,S),Y		; 93 1C ; Store accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $070001.l		; 2F 01 00 07 ; AND accumulator with memory (long) $070001.l [Writes: Accumulator] [Flags: ZN]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $48DF1C.l,X		; BF 1C DF 48 ; Load long $48DF1C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $060150.l,X		; FF 50 01 06 ; Subtract with carry (long,X) $060150.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$17.b		; 09 17 ; Logical OR #$17.b with accumulator [Writes: Accumulator] [Flags: ZN]
	mvn $B7,$E3		; 54 E3 B7 ; Move block negative $B7,$E3 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ldy $0080.w		; AC 80 00 ; Load $0080.w into Y register [Writes: Y Index] [Flags: ZN]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $DA		; 10 DA ; Branch if plus to $10, $DA [Flow: branch]
	.db $D0, $FD		; D0 FD ; Branch if not equal to $D0, $FD [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	.db $90, $E8		; 90 E8 ; Branch if carry clear to $90, $E8 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cmp [$ED.b]		; C7 ED ; Compare accumulator (long) [$ED.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	and $83.b,X		; 35 83 ; Logical AND $83.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $62, $00, $13		; 62 00 13 ; Push effective relative address $62, $00, $13 [Writes: Stack Pointer]
	asl $1F02.w		; 0E 02 1F ; Arithmetic shift left $1F02.w [Flags: ZNC]
	tsb $183F.w		; 0C 3F 18 ; Test and set bits $183F.w [Reads: Accumulator] [Flags: Z]
	adc $10BF10.l,X		; 7F 10 BF 10 ; Add long $10BF10.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $030040.l,X		; FF 40 00 03 ; Subtract with carry (long,X) $030040.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $2413.w		; 0D 13 24 ; Logical OR $2413.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc #$E9.b		; 69 E9 ; Add #$E9.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sta $7A.b,S		; 83 7A ; Store accumulator (stack relative) $7A.b,S [Reads: Accumulator, Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $FC		; 30 FC ; Branch if minus to $30, $FC [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $FD08.w,X		; FE 08 FD ; Increment memory $FD08.w,X [Reads: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $C00002.l,X		; FF 02 00 C0 ; Subtract with carry (long,X) $C00002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $B0, $C8		; B0 C8 ; Branch if carry set to $B0, $C8 [Flow: branch]
	bit $96.b		; 24 96 ; Test bits $96.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta [$1D.b],Y		; 97 1D ; Store accumulator (long indexed) [$1D.b],Y [Reads: Accumulator, Direct Page, Y Index]
	asl $20.b		; 06 20 ; Arithmetic shift left $20.b [Reads: Direct Page] [Flags: ZNC]
	bit $6857.w,X		; 3C 57 68 ; Test bits $6857.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	rol $BB66.w,X		; 3E 66 BB ; Rotate left $BB66.w,X [Reads: X Index] [Flags: ZNC]
	and $DD.b,S		; 23 DD ; AND accumulator with stack relative $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7576.w,Y		; 19 76 75 ; OR accumulator with memory $7576.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $1E6C.w		; 6E 6C 1E ; Rotate right $1E6C.w [Flags: ZNC]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	lda ($5D.b)		; B2 5D ; Load accumulator (indirect) ($5D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($66.b)		; 12 66 ; OR accumulator with memory (indirect) ($66.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0000.w		; 0C 00 00 ; Test and set bits $0000.w [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($40.b),Y		; 11 40 ; OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $B0, $40		; B0 40 ; Branch if carry set to $B0, $40 [Flow: branch]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7E.b		; 66 7E ; Rotate right $7E.b [Reads: Direct Page] [Flags: ZNC]
	bit $243C.w,X		; 3C 3C 24 ; Test bits $243C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FF7E.w,X		; 3C 7E FF ; Test bits $FF7E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta $3C42.w,Y		; 99 42 3C ; Store accumulator to $3C42.w,Y [Reads: Accumulator, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $48,$00		; 44 00 48 ; Move block positive $48,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $10, $78		; 10 78 ; Branch if plus to $10, $78 [Flow: branch]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	jsr $0060.w		; 20 60 00 ; Jump to subroutine at $0060.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $50, $60		; 50 60 ; Branch if overflow clear to $50, $60 [Flow: branch]
	bit $3A00.w,X		; 3C 00 3A ; Test bits $3A00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $2F.b		; 04 2F ; Test and set bits $2F.b [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	and #$50.b		; 29 50 ; Logical AND #$50.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jsr $0022.w		; 20 22 00 ; Jump to subroutine at $0022.w [Writes: Stack Pointer] [Flow: call]
	ora [$EB.b],Y		; 17 EB ; OR accumulator with memory (long indexed) [$EB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$49.b]		; 07 49 ; OR accumulator with memory (long) [$49.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$95.b]		; 07 95 ; OR accumulator with memory (long) [$95.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3A.b,S		; 03 3A ; OR accumulator with stack relative $3A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3D.b,X)		; 01 3D ; Logical OR ($3D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$9D.b		; C9 9D ; Compare #$9D.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	rol $23.b		; 26 23 ; Rotate left $23.b [Reads: Direct Page] [Flags: ZNC]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $13		; 80 13 ; Branch always to $80, $13 [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	jsr $C000.w		; 20 00 C0 ; Jump to subroutine at $C000.w [Writes: Stack Pointer] [Flow: call]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $70		; F0 70 ; Branch if equal to $F0, $70 [Flow: branch]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: ZNC]
	ora $1E3E0F.l,X		; 1F 0F 3E 1E ; Logical OR long $1E3E0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $3F1C.w,X		; 3C 1C 3F ; Test bits $3F1C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora [$3F.b],Y		; 17 3F ; OR accumulator with memory (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and [$1A.b],Y		; 37 1A ; AND accumulator with memory (long indexed) [$1A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $003931.l		; 6F 31 39 00 ; Add with carry (long) $003931.l [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	and $28.b,S		; 23 28 ; AND accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $6F35.w,X		; 3D 35 6F ; AND accumulator with memory $6F35.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $B0B8.w,Y		; 39 B8 B0 ; AND accumulator with memory $B0B8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $34		; 70 34 ; Branch if overflow set to $70, $34 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc ($2C.b)		; F2 2C ; Subtract with carry (indirect) ($2C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	pei ($B4.b)		; D4 B4 ; Push effective indirect address ($B4.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cpy #$20.b		; C0 20 ; Compare #$20.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	pea $AAD2.w		; F4 D2 AA ; Push absolute address $AAD2.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldy $20.b,X		; B4 20 ; Load Y register $20.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	cpy #$84.b		; C0 84 ; Compare #$84.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $7AC737.l,X		; 7F 37 C7 7A ; Add long $7AC737.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $221010.l		; 6F 10 10 22 ; Add with carry (long) $221010.l [Writes: Accumulator] [Flags: ZVNC]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	and ($78.b,S),Y		; 33 78 ; AND accumulator (stack relative indirect indexed) ($78.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $6F.b		; C5 6F ; Compare $6F.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $B0, $7E		; B0 7E ; Branch if carry set to $B0, $7E [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	adc [$1E.b]		; 67 1E ; Add with carry (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $48.b,X		; F6 48 ; Increment memory $48.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx #$98.b		; E0 98 ; Compare #$98.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	jsl $63E000.l		; 22 00 E0 63 ; Jump to subroutine long $63E000.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $F6E7.w,X		; FE E7 F6 ; Increment memory $F6E7.w,X [Reads: X Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cmp $385F20.l,X		; DF 20 5F 38 ; Compare accumulator (long,X) $385F20.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora $3F0C13.l,X		; 1F 13 0C 3F ; Logical OR long $3F0C13.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0B2F.w		; 0C 2F 0B ; Test and set bits $0B2F.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cmp $285F.w,Y		; D9 5F 28 ; Compare accumulator $285F.w,Y [Reads: Y Index] [Flags: ZNC]
	ora ($1C.b,S),Y		; 13 1C ; OR accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FA.b		; 04 FA ; Test and set bits $FA.b [Reads: Accumulator] [Flags: Z]
	trb $F834.w		; 1C 34 F8 ; Test and reset bits $F834.w [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $32		; 10 32 ; Branch if plus to $10, $32 [Flow: branch]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9B.b		; 00 9B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	bit $C8.b,X		; 34 C8 ; Test bits $C8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx $C0.b		; E4 C0 ; Compare $C0.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $171C23.l,X		; 3F 23 1C 17 ; AND accumulator with memory (long,X) $171C23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp ($3F13.w,X)		; 7C 13 3F ; Jump indirect indexed to ($3F13.w,X) [Reads: X Index] [Flow: jump]
	tsb $0B4F.w		; 0C 4F 0B ; Test and set bits $0B4F.w [Reads: Accumulator] [Flags: Z]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $14234B.l,X		; BF 4B 23 14 ; Load long $14234B.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0023.w		; 0C 23 00 ; Test and set bits $0023.w [Reads: Accumulator] [Flags: Z]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc ($FC.b)		; F2 FC ; Subtract with carry (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $3C		; 10 3C ; Branch if plus to $10, $3C [Flow: branch]
	cpy #$DC.b		; C0 DC ; Compare #$DC.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $31		; 10 31 ; Branch if plus to $10, $31 [Flow: branch]
	.db $10, $C2		; 10 C2 ; Branch if plus to $10, $C2 [Flow: branch]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($C4.b)		; F2 C4 ; Subtract with carry (indirect) ($C4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sta $0C.b,S		; 83 0C ; Store accumulator (stack relative) $0C.b,S [Reads: Accumulator, Stack Pointer]
	ora $17.b		; 05 17 ; Logical OR $17.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	jmp ($C620.w)		; 6C 20 C6 ; Jump indirect to ($C620.w) [Flow: jump]
	mvp $6C,$EE		; 44 EE 6C ; Move block positive $6C,$EE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	adc $7D38.w,X		; 7D 38 7D ; Add $7D38.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $3F.b,X		; 34 3F ; Test bits $3F.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	asl $000E.w		; 0E 0E 00 ; Arithmetic shift left $000E.w [Flags: ZNC]
	.db $30, $5C		; 30 5C ; Branch if minus to $30, $5C [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	sta ($47.b)		; 92 47 ; Store accumulator (indirect) ($47.b) [Reads: Accumulator, Direct Page]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $08.b,S		; 83 08 ; Store accumulator (stack relative) $08.b,S [Reads: Accumulator, Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $8B.b		; 24 8B ; Test bits $8B.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sbc ($03.b),Y		; F1 03 ; Subtract with carry ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	tsb $85.b		; 04 85 ; Test and set bits $85.b [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $FF00.w,X		; BD 00 FF ; Load $FF00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $42, $FF		; 42 FF ; Reserved instruction
	bit $227E.w,X		; 3C 7E 22 ; Test bits $227E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc #$05.b		; 69 05 ; Add #$05.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	cop $BD.b		; 02 BD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	jsl $400100.l		; 22 00 01 40 ; Jump to subroutine long $400100.l [Writes: Stack Pointer] [Flow: call]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $04,$04		; 54 04 04 ; Move block negative $04,$04 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $B0, $20		; B0 20 ; Branch if carry set to $B0, $20 [Flow: branch]
	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($40.b,S),Y		; 13 40 ; OR accumulator (stack relative indirect indexed) ($40.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $A0		; D0 A0 ; Branch if not equal to $D0, $A0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	jsl $300700.l		; 22 00 07 30 ; Jump to subroutine long $300700.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $04		; 30 04 ; Branch if minus to $30, $04 [Flow: branch]
	asl $0044.w		; 0E 44 00 ; Arithmetic shift left $0044.w [Flags: ZNC]
	sta $A8.b		; 85 A8 ; Store accumulator to $A8.b [Reads: Accumulator]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$4F.b		; 29 4F ; Logical AND #$4F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and $CE7F9E.l,X		; 3F 9E 7F CE ; AND accumulator with memory (long,X) $CE7F9E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $007F08.l,X		; FF 08 7F 00 ; Subtract with carry (long,X) $007F08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$0F.b]		; 27 0F ; AND accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $4EBC4B.l,X		; 1F 4B BC 4E ; Logical OR long $4EBC4B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$E4.b		; E0 E4 ; Compare #$E4.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($FC.b)		; F2 FC ; Subtract with carry (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $73FE.w,Y		; 79 FE 73 ; Add $73FE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp.w [$10FF]		; DC FF 10 ; Jump long indirect [$10FF] [Flow: jump]
	inc $E000.w,X		; FE 00 E0 ; Increment memory $E000.w,X [Reads: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $F0.b		; E4 F0 ; Compare $F0.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp ($3D.b)		; D2 3D ; Compare accumulator (indirect) ($3D.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	adc ($37.b)		; 72 37 ; Add with carry (indirect) ($37.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $070027.l		; 0F 27 00 07 ; OR accumulator with memory (long) $070027.l [Writes: Accumulator] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$C0.b		; A0 C0 ; Load #$C0.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $50, $E0		; 50 E0 ; Branch if overflow clear to $50, $E0 [Flow: branch]
	.db $30, $60		; 30 60 ; Branch if minus to $30, $60 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldy #$D0.b		; A0 D0 ; Load #$D0.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $F0, $29		; F0 29 ; Branch if equal to $F0, $29 [Flow: branch]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $A0		; 80 A0 ; Branch always to $80, $A0 [Flow: branch]
	cpy #$24.b		; C0 24 ; Compare #$24.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $A04080.l		; 22 80 40 A0 ; Jump to subroutine long $A04080.l [Writes: Stack Pointer] [Flow: call]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$88.b]		; 07 88 ; OR accumulator with memory (long) [$88.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	.db $62, $44, $33		; 62 44 33 ; Push effective relative address $62, $44, $33 [Writes: Stack Pointer]
	.db $42, $31		; 42 31 ; Reserved instruction
	.db $42, $39		; 42 39 ; Reserved instruction
	and ($1C.b,X)		; 21 1C ; Logical AND ($1C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$78.b]		; 07 78 ; OR accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta $4E4C.w,X		; 9D 4C 4E ; Store accumulator to $4E4C.w,X [Reads: Accumulator, X Index]
	lsr $23.b		; 46 23 ; Logical shift right $23.b [Reads: Direct Page] [Flags: ZNC]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ror $1E80.w		; 6E 80 1E ; Rotate right $1E80.w [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: ZNC]
	.db $62, $94, $02		; 62 94 02 ; Push effective relative address $62, $94, $02 [Writes: Stack Pointer]
	cpx #$84.b		; E0 84 ; Compare #$84.b with X register [Reads: X Index] [Flags: ZNC]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sta ($E6.b)		; 92 E6 ; Store accumulator (indirect) ($E6.b) [Reads: Accumulator, Direct Page]
	jmp ($2A24.w,X)		; 7C 24 2A ; Jump indirect indexed to ($2A24.w,X) [Reads: X Index] [Flow: jump]
	asl $0000.w,X		; 1E 00 00 ; Arithmetic shift left $0000.w,X [Reads: X Index] [Flags: ZNC]
	ora $0F1000.l		; 0F 00 10 0F ; OR accumulator with memory (long) $0F1000.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $12.b,S		; 03 12 ; OR accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1D62.w		; 0D 62 1D ; Logical OR $1D62.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $0B		; 10 0B ; Branch if plus to $10, $0B [Flow: branch]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($62.b)		; 12 62 ; OR accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Accumulator, Direct Page]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cop $62.b		; 02 62 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b,X		; 94 00 ; Store Y register $00.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	stx $88.b		; 86 88 ; Store X register to $88.b [Reads: X Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $20001F.l		; 2F 1F 00 20 ; AND accumulator with memory (long) $20001F.l [Writes: Accumulator] [Flags: ZN]
	ora $213041.l,X		; 1F 41 30 21 ; Logical OR long $213041.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $1804.w,Y		; 19 04 18 ; OR accumulator with memory $1804.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$7C.b]		; 07 7C ; OR accumulator with memory (long) [$7C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $B4.b		; 02 B4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $264F20.l,X		; 1F 20 4F 26 ; Logical OR long $264F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $88B4.w,X		; 7D B4 88 ; Add $88B4.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $34		; 80 34 ; Branch always to $80, $34 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $F4		; 30 F4 ; Branch if minus to $30, $F4 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
.ACCU 16
.INDEX 16
	rep #$34		; C2 34
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($88.b),Y		; [PATTERN: Memory clearing operation] 71 88 ; Add with carry ($88.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	stz $AC.b,X		; 74 AC ; Store zero to $AC.b,X [Reads: X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $4A.b,X		; 74 4A ; Store zero to $4A.b,X [Reads: X Index]
	rol $2777.w,X		; 3E 77 27 ; Rotate left $2777.w,X [Reads: X Index] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F1E03.l		; 0F 03 1E 0F ; OR accumulator with memory (long) $0F1E03.l [Writes: Accumulator] [Flags: ZN]
	trb $230F.w		; 1C 0F 23 ; Test and reset bits $230F.w [Reads: Accumulator] [Flags: Z]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $18FF1F.l,X		; 1F 1F FF 18 ; Logical OR long $18FF1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $60FB08.l,X		; 9F 08 FB 60 ; Store accumulator (long,X) $60FB08.l,X [Reads: Accumulator, X Index]
	jmp ($2F18.w,X)		; 7C 18 2F ; Jump indirect indexed to ($2F18.w,X) [Reads: X Index] [Flow: jump]
	tsb $0123.w		; 0C 23 01 ; Test and set bits $0123.w [Reads: Accumulator] [Flags: Z]
	ora $0022.w,X		; 1D 22 00 ; OR accumulator with memory $0022.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $9CF8FB.l,X		; 1F FB F8 9C ; Logical OR long $9CF8FB.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $1D3F33.l,X		; 7F 33 3F 1D ; Add long $1D3F33.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $FC45.w,X		; DD 45 FC ; Compare accumulator $FC45.w,X [Reads: X Index] [Flags: ZNC]
	stz $DF.b		; 64 DF ; Store zero to $DF.b
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp ($3F18.w,X)		; 7C 18 3F ; Jump indirect indexed to ($3F18.w,X) [Reads: X Index] [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	adc [$BA.b],Y		; 77 BA ; Add with carry (long indexed) [$BA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	jsr ($7BFF.w,X)		; FC FF 7B ; Jump to subroutine indirect indexed ($7BFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($0039.w,X)		; 7C 39 00 ; Jump indirect indexed to ($0039.w,X) [Reads: X Index] [Flow: jump]
	sta [$F8.b]		; 87 F8 ; Store accumulator (long) [$F8.b] [Reads: Accumulator, Direct Page]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3E1F.w,X		; 3C 1F 3E ; Test bits $3E1F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $841F37.l,X		; 1F 37 1F 84 ; Logical OR long $841F37.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $1E833F.l		; 22 3F 83 1E ; Jump to subroutine long $1E833F.l [Writes: Stack Pointer] [Flow: call]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$30C0.w		; E0 C0 30 ; Compare #$30C0.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$F018.w		; E0 18 F0 ; Compare #$F018.w with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$E024.w		; E0 24 E0 ; Compare #$E024.w with X register [Reads: X Index] [Flags: ZNC]
	inc $00E8.w		; EE E8 00 ; Increment $00E8.w [Flags: ZN]
	cpy #$F0E0.w		; C0 E0 F0 ; Compare #$F0E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0CF6.w,X)		; FC F6 0C ; Jump to subroutine indirect indexed ($0CF6.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: ZNC]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03050B.l		; 0F 0B 05 03 ; OR accumulator with memory (long) $03050B.l [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $30.b		; 06 30 ; Arithmetic shift left $30.b [Reads: Direct Page] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $50, $E0		; 50 E0 ; Branch if overflow clear to $50, $E0 [Flow: branch]
	ldy #$C0C0.w		; A0 C0 C0 ; Load #$C0C0.w into Y register [Writes: Y Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $D0		; F0 D0 ; Branch if equal to $F0, $D0 [Flow: branch]
	ldy #$23C0.w		; A0 C0 23 ; Load #$23C0.w into Y register [Writes: Y Index] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2A.b,X)		; 01 2A ; Logical OR ($2A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$40C0.w		; A0 C0 40 ; Load #$40C0.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$8040.w		; A0 40 80 ; Load #$8040.w into Y register [Writes: Y Index] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $0639.w		; 0C 39 06 ; Test and set bits $0639.w [Reads: Accumulator] [Flags: Z]
	and ($1D.b,X)		; 21 1D ; Logical AND ($1D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($08.b)		; 12 08 ; OR accumulator with memory (indirect) ($08.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $081F10.l,X		; 3F 10 1F 08 ; AND accumulator with memory (long,X) $081F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $220A0A.l,X		; 1F 0A 0A 22 ; Logical OR long $220A0A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1522.w,Y		; 39 22 15 ; AND accumulator with memory $1522.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $1517.w		; 2C 17 15 ; Test bits $1517.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $F1		; 90 F1 ; Branch if carry clear to $90, $F1 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp #$FDA4.w		; C9 A4 FD ; Compare #$FDA4.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	cop $E2.b		; 02 E2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $5BB76F.l		; 0F 6F B7 5B ; OR accumulator with memory (long) $5BB76F.l [Writes: Accumulator] [Flags: ZN]
	sbc $40A2.w,X		; FD A2 40 ; Subtract with carry $40A2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($7C.b,X)		; 81 7C ; Store accumulator ($7C.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($50.b,X)		; 81 50 ; Store accumulator ($50.b,X) [Reads: Accumulator, X Index, Direct Page]
	adc $01.b,S		; 63 01 ; Add with carry (stack relative) $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	bit $8700.w,X		; 3C 00 87 ; Test bits $8700.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inc $01.b		; E6 01 ; Increment $01.b [Reads: Direct Page] [Flags: ZN]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda $833F7E.l		; AF 7E 3F 83 ; Load long $833F7E.l into accumulator [Writes: Accumulator] [Flags: ZN]
	sbc ($01.b,S),Y		; F3 01 ; Subtract with carry (stack relative indirect indexed) ($01.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpx #$F88A.w		; E0 8A F8 ; Compare #$F88A.w with X register [Reads: X Index] [Flags: ZNC]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0886.w,X		; 1E 86 08 ; Arithmetic shift left $0886.w,X [Reads: X Index] [Flags: ZNC]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C3.b		; 24 C3 ; Test bits $C3.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $7983.w,X		; 3C 83 79 ; Test bits $7983.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta $20.b,S		; 83 20 ; Store accumulator (stack relative) $20.b,S [Reads: Accumulator, Stack Pointer]
	eor [$02.b]		; 47 02 ; Exclusive OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $1F00.w,X		; 3C 00 1F ; Test bits $1F00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora $C3000F.l		; 0F 0F 00 C3 ; OR accumulator with memory (long) $C3000F.l [Writes: Accumulator] [Flags: ZN]
	stx $DE.b		; 86 DE ; Store X register to $DE.b [Reads: X Index]
	jmp ($1B3F.w,X)		; 7C 3F 1B ; Jump indirect indexed to ($1B3F.w,X) [Reads: X Index] [Flow: jump]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	adc $F680.w,X		; 7D 80 F6 ; Add $F680.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $5F1F00.l		; 22 00 1F 5F ; Jump to subroutine long $5F1F00.l [Writes: Stack Pointer] [Flow: call]
	dec $7078.w,X		; DE 78 70 ; Decrement memory $7078.w,X [Reads: X Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor $0E5F05.l,X		; 5F 05 5F 0E ; Exclusive OR accumulator with memory (long,X) $0E5F05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($7A28.w)		; 6C 28 7A ; Jump indirect to ($7A28.w) [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $9C35.w		; 4D 35 9C ; Exclusive OR $9C35.w with accumulator [Writes: Accumulator] [Flags: ZN]
	stz $BF.b,X		; 74 BF ; Store zero to $BF.b,X [Reads: X Index]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $57717B.l,X		; 3F 7B 71 57 ; AND accumulator with memory (long,X) $57717B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$7A.b],Y		; 77 7A ; Add with carry (long indexed) [$7A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($F887.w,X)		; FC 87 F8 ; Jump to subroutine indirect indexed ($F887.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $02		; 70 02 ; Branch if overflow set to $70, $02 [Flow: branch]
	sty $61.b		; 84 61 ; Store Y register to $61.b [Reads: Y Index]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc ($57.b),Y		; 71 57 ; Add with carry ($57.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $FF08.w		; 9C 08 FF ; Store zero to $FF08.w
	.db $30, $73		; 30 73 ; Branch if minus to $30, $73 [Flow: branch]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	cmp $010373.l		; CF 73 03 01 ; Compare accumulator (long) $010373.l [Reads: Accumulator] [Flags: ZNC]
	jsl $390A00.l		; 22 00 0A 39 ; Jump to subroutine long $390A00.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	tsb $009E.w		; 0C 9E 00 ; Test and set bits $009E.w [Reads: Accumulator] [Flags: Z]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	cpx #$24E0.w		; E0 E0 24 ; Compare #$24E0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F89EF3.l,X		; FF F3 9E F8 ; Subtract with carry (long,X) $F89EF3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3F1F.w,Y		; 39 1F 3F ; AND accumulator with memory $3F1F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $1F0F1F.l,X		; 1F 1F 0F 1F ; Logical OR long $1F0F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	and $071F1F.l,X		; 3F 1F 1F 07 ; AND accumulator with memory (long,X) $071F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $FE0800.l		; 22 00 08 FE ; Jump to subroutine long $FE0800.l [Writes: Stack Pointer] [Flow: call]
	cld		; D8 ; Clear decimal flag [Flags: D]
	inc $F4E4.w,X		; FE E4 F4 ; Increment memory $F4E4.w,X [Reads: X Index] [Flags: ZN]
	.db $D0, $F8		; D0 F8 ; Branch if not equal to $D0, $F8 [Flow: branch]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $E6.b		; 04 E6 ; Test and set bits $E6.b [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cpx $F0C8.w		; EC C8 F0 ; Compare $F0C8.w with X register [Reads: X Index] [Flags: ZNC]
	jsl $2FE000.l		; 22 00 E0 2F ; Jump to subroutine long $2FE000.l [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $1F00.w		; 0E 00 1F ; Arithmetic shift left $1F00.w [Flags: ZNC]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($5D.b,X)		; 01 5D ; Logical OR ($5D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($04.b,S),Y		; 13 04 ; OR accumulator (stack relative indirect indexed) ($04.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora [$25.b],Y		; 17 25 ; OR accumulator with memory (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $33.b		; 26 33 ; Rotate left $33.b [Reads: Direct Page] [Flags: ZNC]
	rol $206D.w,X		; 3E 6D 20 ; Rotate left $206D.w,X [Reads: X Index] [Flags: ZNC]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0FC.w		; C0 FC C0 ; Compare #$C0FC.w with Y register [Reads: Y Index] [Flags: ZNC]
	pea $4C00.w		; F4 00 4C ; Push absolute address $4C00.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $80, $BA		; 80 BA ; Branch always to $80, $BA [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr $E850.w		; 20 50 E8 ; Jump to subroutine at $E850.w [Writes: Stack Pointer] [Flow: call]
	ldy $64.b		; A4 64 ; Load $64.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	cpy $B67C.w		; CC 7C B6 ; Compare $B67C.w with Y register [Reads: Y Index] [Flags: ZNC]
	sta $02.b,S		; 83 02 ; Store accumulator (stack relative) $02.b,S [Reads: Accumulator, Stack Pointer]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $004700.l		; 0F 00 47 00 ; OR accumulator with memory (long) $004700.l [Writes: Accumulator] [Flags: ZN]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $F6.b		; 04 F6 ; Test and set bits $F6.b [Reads: Accumulator] [Flags: Z]
	tsb $02FF.w		; 0C FF 02 ; Test and set bits $02FF.w [Reads: Accumulator] [Flags: Z]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $AA.b		; 46 AA ; Logical shift right $AA.b [Reads: Direct Page] [Flags: ZNC]
	lda ($9F.b,S),Y		; B3 9F ; Load accumulator (stack relative indirect indexed) ($9F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $23.b		; 46 23 ; Logical shift right $23.b [Reads: Direct Page] [Flags: ZNC]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	jsr $3078.w		; 20 78 30 ; Jump to subroutine at $3078.w [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $D8		; B0 D8 ; Branch if carry set to $B0, $D8 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pea $3883.w		; F4 83 38 ; Push absolute address $3883.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3B00.w,X		; 1E 00 3B ; Arithmetic shift left $3B00.w,X [Reads: X Index] [Flags: ZNC]
	ora ($7D.b,X)		; 01 7D ; Logical OR ($7D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1B3D.w,Y		; 19 3D 1B ; OR accumulator with memory $1B3D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $BB4326.l,X		; 1F 26 43 BB ; Logical OR long $BB4326.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $8335.w		; 6E 35 83 ; Rotate right $8335.w [Flags: ZNC]
	.db $50, $00		; 50 00 ; Branch if overflow clear to $50, $00 [Flow: branch]
	ora ($C0.b,S),Y		; 13 C0 ; OR accumulator (stack relative indirect indexed) ($C0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	.db $80, $88		; 80 88 ; Branch always to $80, $88 [Flow: branch]
	.db $70, $68		; 70 68 ; Branch if overflow set to $70, $68 [Flow: branch]
	.db $F0, $B4		; F0 B4 ; Branch if equal to $F0, $B4 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $F8.b,X		; 94 F8 ; Store Y register $F8.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $70, $88		; 70 88 ; Branch if overflow set to $70, $88 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	pea $23F4.w		; F4 F4 23 ; Push absolute address $23F4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3D00.w,X		; 1E 00 3D ; Arithmetic shift left $3D00.w,X [Reads: X Index] [Flags: ZNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0CD6.w		; 0C D6 0C ; Test and set bits $0CD6.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1923.w,X		; 1E 23 19 ; Arithmetic shift left $1923.w,X [Reads: X Index] [Flags: ZNC]
	ora $5793.w		; 0D 93 57 ; Logical OR $5793.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$C02E.w		; E0 2E C0 ; Compare #$C02E.w with X register [Reads: X Index] [Flags: ZNC]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $50A8.w		; 20 A8 50 ; Jump to subroutine at $50A8.w [Writes: Stack Pointer] [Flow: call]
	pea $5478.w		; F4 78 54 ; Push absolute address $5478.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$D8F0.w		; C0 F0 D8 ; Compare #$D8F0.w with Y register [Reads: Y Index] [Flags: ZNC]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	pea $0374.w		; F4 74 03 ; Push absolute address $0374.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3D.b,S		; 03 3D ; OR accumulator with stack relative $3D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	bit $3325.w		; 2C 25 33 ; Test bits $3325.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $E000C0.l,X		; 1F C0 00 E0 ; Logical OR long $E000C0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	mvp $F0,$00		; 44 00 F0 ; Move block positive $F0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $FC0098.l		; 0F 98 00 FC ; OR accumulator with memory (long) $FC0098.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $3430.w		; 0C 30 34 ; Test and set bits $3430.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy #$9020.w		; C0 20 90 ; Compare #$9020.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $90, $F8		; 90 F8 ; Branch if carry clear to $90, $F8 [Flow: branch]
	pea $B4CC.w		; F4 CC B4 ; Push absolute address $B4CC.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0003.w		; 09 03 00 ; Logical OR #$0003.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $0F1407.l		; 0F 07 14 0F ; OR accumulator with memory (long) $0F1407.l [Writes: Accumulator] [Flags: ZN]
	trb $0E.b		; 14 0E ; Test and reset bits $0E.b [Reads: Accumulator] [Flags: Z]
	jsl $030400.l		; 22 00 04 03 ; Jump to subroutine long $030400.l [Writes: Stack Pointer] [Flow: call]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora ($17.b),Y		; 11 17 ; OR accumulator with memory ($17.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$00C0.w		; 09 C0 00 ; Logical OR #$00C0.w with accumulator [Writes: Accumulator] [Flags: ZN]
	jsr $F0C0.w		; 20 C0 F0 ; Jump to subroutine at $F0C0.w [Writes: Stack Pointer] [Flow: call]
	cpx #$F028.w		; E0 28 F0 ; Compare #$F028.w with X register [Reads: X Index] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $70, $22		; 70 22 ; Branch if overflow set to $70, $22 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$9020.w		; C0 20 90 ; Compare #$9020.w with Y register [Reads: Y Index] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0010.w		; 09 10 00 ; Logical OR #$0010.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $3F7710.l,X		; 3F 10 77 3F ; AND accumulator with memory (long,X) $3F7710.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $3F		; 70 3F ; Branch if overflow set to $70, $3F [Flow: branch]
	sbc $227F.w,X		; FD 7F 22 ; Subtract with carry $227F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	adc $00FF7F.l,X		; 7F 7F FF 00 ; Add long $00FF7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pea $EC18.w		; F4 18 EC ; Push absolute address $EC18.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($F6B0.w,X)		; FC B0 F6 ; Jump to subroutine indirect indexed ($F6B0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$0600.w		; C0 00 06 ; Compare #$0600.w with Y register [Reads: Y Index] [Flags: ZNC]
	asl $221E.w		; 0E 1E 22 ; Arithmetic shift left $221E.w [Flags: ZNC]
	jsr ($FE00.w,X)		; FC 00 FE ; Jump to subroutine indirect indexed ($FE00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0008.w		; 09 08 00 ; Logical OR #$0008.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $47BB08.l,X		; 5F 08 BB 47 ; Exclusive OR accumulator with memory (long,X) $47BB08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldy $DB5F.w,X		; BC 5F DB ; Load Y register $DB5F.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc [$22.b]		; 67 22 ; Add with carry (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $FBFFFF.l,X		; 5F FF FF FB ; Exclusive OR accumulator with memory (long,X) $FBFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sty $06.b		; 84 06 ; Store Y register to $06.b [Reads: Y Index]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FA.b		; 04 FA ; Test and set bits $FA.b [Reads: Accumulator] [Flags: Z]
	tsb $FCF6.w		; 0C F6 FC ; Test and set bits $FCF6.w [Reads: Accumulator] [Flags: Z]
	jsr ($F8D8.w,X)		; FC D8 F8 ; Jump to subroutine indirect indexed ($F8D8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$0300.w		; E0 00 03 ; Compare #$0300.w with X register [Reads: X Index] [Flags: ZNC]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $FCFE.w,X		; FE FE FC ; Increment memory $FCFE.w,X [Reads: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$34.b],Y		; 37 34 ; AND accumulator with memory (long indexed) [$34.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $130F16.l		; 0F 16 0F 13 ; OR accumulator with memory (long) $130F16.l [Writes: Accumulator] [Flags: ZN]
	ora $03030C.l		; 0F 0C 03 03 ; OR accumulator with memory (long) $03030C.l [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($4B.b)		; 12 4B ; OR accumulator with memory (indirect) ($4B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$17.b],Y		; 37 17 ; AND accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $F02C.w		; EC 2C F0 ; Compare $F02C.w with X register [Reads: X Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $F0, $C8		; F0 C8 ; Branch if equal to $F0, $C8 [Flow: branch]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$24C0.w		; C0 C0 24 ; Compare #$24C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($EC.b)		; D2 EC ; Compare accumulator (indirect) ($EC.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $03.b		; 25 03 ; Logical AND $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora [$2D.b]		; 07 2D ; OR accumulator with memory (long) [$2D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $1E1B.w,X		; 3D 1B 1E ; AND accumulator with memory $1E1B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($3D.b)		; 12 3D ; OR accumulator with memory (indirect) ($3D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $25.b,X		; 35 25 ; Logical AND $25.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0001.w,X		; 1E 01 00 ; Arithmetic shift left $0001.w,X [Reads: X Index] [Flags: ZNC]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $F8.b,X		; 94 F8 ; Store Y register $F8.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	bit $F8.b,X		; 34 F8 ; Test bits $F8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	cpx #$24E0.w		; E0 E0 24 ; Compare #$24E0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $E802.w		; F4 02 E8 ; Push absolute address $E802.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$BE83.w		; E0 83 BE ; Compare #$BE83.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	ror $FD19.w		; 6E 19 FD ; Rotate right $FD19.w [Flags: ZNC]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $351400.l		; 22 00 14 35 ; Jump to subroutine long $351400.l [Writes: Stack Pointer] [Flow: call]
	ror $43BB.w		; 6E BB 43 ; Rotate right $43BB.w [Flags: ZNC]
	rol $1F.b		; 26 1F ; Rotate left $1F.b [Reads: Direct Page] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sty $F8.b,X		; 94 F8 ; Store Y register $F8.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	ldy $F8.b,X		; B4 F8 ; Load Y register $F8.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $F0, $88		; F0 88 ; Branch if equal to $F0, $88 [Flow: branch]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $F41200.l		; 22 00 12 F4 ; Jump to subroutine long $F41200.l [Writes: Stack Pointer] [Flow: call]
	pea $8868.w		; F4 68 88 ; Push absolute address $8868.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	jsr ($F400.w,X)		; FC 00 F4 ; Jump to subroutine indirect indexed ($F400.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($75.b,X)		; 01 75 ; Logical OR ($75.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $3D.b,S		; 03 3D ; OR accumulator with stack relative $3D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $8EBF.w		; 0C BF 8E ; Test and set bits $8EBF.w [Reads: Accumulator] [Flags: Z]
	eor $0A3D.w		; 4D 3D 0A ; Exclusive OR $0A3D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $F8.b,X		; 94 F8 ; Store Y register $F8.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sta $9D.b		; 85 9D ; Store accumulator to $9D.b [Reads: Accumulator]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $F4.b,X		; 74 F4 ; Store zero to $F4.b,X [Reads: X Index]
	sta $AA.b		; 85 AA ; Store accumulator to $AA.b [Reads: Accumulator]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	rol $2B01.w,X		; 3E 01 2B ; Rotate left $2B01.w,X [Reads: X Index] [Flags: ZNC]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0403.w		; 0D 03 04 ; Logical OR $0403.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	rol $173B.w,X		; 3E 3B 17 ; Rotate left $173B.w,X [Reads: X Index] [Flags: ZNC]
	ora $0304.w		; 0D 04 03 ; Logical OR $0304.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $14,$F8		; 54 F8 14 ; Move block negative $14,$F8 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sta [$2B.b]		; 87 2B ; Store accumulator (long) [$2B.b] [Reads: Accumulator, Direct Page]
	ora $24.b		; 05 24 ; Logical OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $0E.b		; 14 0E ; Test and reset bits $0E.b [Reads: Accumulator] [Flags: Z]
	trb $0F.b		; 14 0F ; Test and reset bits $0F.b [Reads: Accumulator] [Flags: Z]
	ora $030407.l		; 0F 07 04 03 ; OR accumulator with memory (long) $030407.l [Writes: Accumulator] [Flags: ZN]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$11.b],Y		; 17 11 ; OR accumulator with memory (long indexed) [$11.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$0304.w		; 09 04 03 ; Logical OR #$0304.w with accumulator [Writes: Accumulator] [Flags: ZN]
	jsl $280800.l		; 22 00 08 28 ; Jump to subroutine long $280800.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $28		; 70 28 ; Branch if overflow set to $70, $28 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$C020.w		; E0 20 C0 ; Compare #$C020.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$0026.w		; C0 26 00 ; Compare #$0026.w with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $E8.b		; 04 E8 ; Test and set bits $E8.b [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $90, $20		; 90 20 ; Branch if carry clear to $90, $20 [Flow: branch]
	cpy #$0022.w		; C0 22 00 ; Compare #$0022.w with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $77CB.w		; 0C CB 77 ; Test and set bits $77CB.w [Reads: Accumulator] [Flags: Z]
	jmp.w [$7C6B]		; DC 6B 7C ; Jump long indirect [$7C6B] [Flow: jump]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $2E16.w,Y		; 39 16 2E ; AND accumulator with memory $2E16.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	jsl $CB0E00.l		; 22 00 0E CB ; Jump to subroutine long $CB0E00.l [Writes: Stack Pointer] [Flow: call]
	jmp.w [$397C]		; DC 7C 39 ; Jump long indirect [$397C] [Flow: jump]
	rol $1038.w,X		; 3E 38 10 ; Rotate left $1038.w,X [Reads: X Index] [Flags: ZNC]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($F8F8.w,X)		; FC F8 F8 ; Jump to subroutine indirect indexed ($F8F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$28C0.w		; C0 C0 28 ; Compare #$28C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F4.b,X		; F6 F4 ; Increment memory $F4.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$0023.w		; C0 23 00 ; Compare #$0023.w with Y register [Reads: Y Index] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	adc $7737.w,Y		; 79 37 77 ; Add $7737.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$22FF.w		; 09 FF 22 ; Logical OR #$22FF.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cmp $BB45.w,X		; DD 45 BB ; Compare accumulator $BB45.w,X [Reads: X Index] [Flags: ZNC]
	ora #$247F.w		; 09 7F 24 ; Logical OR #$247F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $DD77.w,Y		; 79 77 DD ; Add $DD77.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	sbc [$7F.b],Y		; F7 7F ; Subtract with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $F0, $B8		; F0 B8 ; Branch if equal to $F0, $B8 [Flow: branch]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpx #$8080.w		; E0 80 80 ; Compare #$8080.w with X register [Reads: X Index] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$0080.w		; E0 80 00 ; Compare #$0080.w with X register [Reads: X Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($45.b,X)		; 01 45 ; Logical OR ($45.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00020D.l		; 0F 0D 02 00 ; OR accumulator with memory (long) $00020D.l [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: ZNC]
	ora $FC0003.l		; 0F 03 00 FC ; OR accumulator with memory (long) $FC0003.l [Writes: Accumulator] [Flags: ZN]
	ora $77.b,S		; 03 77 ; OR accumulator with stack relative $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	eor $F9.b,S		; 43 F9 ; Exclusive OR accumulator with stack relative $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $E0.b		; 06 E0 ; Arithmetic shift left $E0.b [Reads: Direct Page] [Flags: ZNC]
	jsl $692ED1.l		; 22 D1 2E 69 ; Jump to subroutine long $692ED1.l [Writes: Stack Pointer] [Flow: call]
	sty $0B.b,X		; 94 0B ; Store Y register $0B.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	sbc ($03.b)		; F2 03 ; Subtract with carry (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $07078F.l,X		; FF 8F 07 07 ; Subtract with carry (long,X) $07078F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $F8FD9F.l,X		; 3F 9F FD F8 ; AND accumulator with memory (long,X) $F8FD9F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FB		; 80 FB ; Branch always to $80, $FB [Flow: branch]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$86.b]		; 07 86 ; OR accumulator with memory (long) [$86.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $7D82.w,Y		; 79 82 7D ; Add $7D82.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta [$FC.b]		; 87 FC ; Store accumulator (long) [$FC.b] [Reads: Accumulator, Direct Page]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	jsl $0002FF.l		; 22 FF 02 00 ; Jump to subroutine long $0002FF.l [Writes: Stack Pointer] [Flow: call]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F0,$00		; 44 00 F0 ; Move block positive $F0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $DC20D8.l		; 0F D8 20 DC ; OR accumulator with memory (long) $DC20D8.l [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	jmp $CC76A8.l		; 5C A8 76 CC ; Jump long to $CC76A8.l [Flow: jump]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $90		; B0 90 ; Branch if carry set to $B0, $90 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp ($FEFC.w,X)		; 7C FC FE ; Jump indirect indexed to ($FEFC.w,X) [Reads: X Index] [Flow: jump]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $1B.b		; 04 1B ; Test and set bits $1B.b [Reads: Accumulator] [Flags: Z]
	asl $34.b		; 06 34 ; Arithmetic shift left $34.b [Reads: Direct Page] [Flags: ZNC]
	ora $2B7F.w,Y		; 19 7F 2B ; OR accumulator with memory $2B7F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $FD55.w		; EE 55 FD ; Increment $FD55.w [Flags: ZN]
	ldx $B7EC.w		; AE EC B7 ; Load $B7EC.w into X register [Writes: X Index] [Flags: ZN]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	rol $7E.b,X		; 36 7E ; Rotate left $7E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $2DEFFF.l		; EF FF EF 2D ; Subtract with carry (long) $2DEFFF.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0103.w,X		; 3D 03 01 ; AND accumulator with memory $0103.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($BF.b,X)		; 01 BF ; Logical OR ($BF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor ($9E.b,X)		; 41 9E ; Exclusive OR accumulator with memory ($9E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $8E.b,S		; 63 8E ; Add with carry (stack relative) $8E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc [$87.b],Y		; 77 87 ; Add with carry (long indexed) [$87.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $C5.b		; 04 C5 ; Test and set bits $C5.b [Reads: Accumulator] [Flags: Z]
	sbc $FEEA.w,Y		; F9 EA FE ; Subtract with carry $FEEA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F400E3.l,X		; FF E3 00 F4 ; Subtract with carry (long,X) $F400E3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $BB.b,S		; 23 BB ; AND accumulator with stack relative $BB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc [$9B.b],Y		; F7 9B ; Subtract with carry (long indexed) [$9B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $B65F.w,X		; FE 5F B6 ; Increment memory $B65F.w,X [Reads: X Index] [Flags: ZN]
	sbc [$5B.b],Y		; F7 5B ; Subtract with carry (long indexed) [$5B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ora [$F4.b]		; 07 F4 ; OR accumulator with memory (long) [$F4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $E3.b,S		; 23 E3 ; AND accumulator with stack relative $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $BB.b,X		; 34 BB ; Test bits $BB.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	lsr $B3.b,X		; 56 B3 ; Logical shift right $B3.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc ($F8.b,S),Y		; F3 F8 ; Subtract with carry (stack relative indirect indexed) ($F8.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0B00.w		; 0C 00 0B ; Test and set bits $0B00.w [Reads: Accumulator] [Flags: Z]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $6D.b,S		; 83 6D ; Store accumulator (stack relative) $6D.b,S [Reads: Accumulator, Stack Pointer]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $050B.w		; 0C 0B 05 ; Test and set bits $050B.w [Reads: Accumulator] [Flags: Z]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $C0		; B0 C0 ; Branch if carry set to $B0, $C0 [Flow: branch]
	.db $70, $C0		; 70 C0 ; Branch if overflow set to $70, $C0 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cpy #$B0C0.w		; C0 C0 B0 ; Compare #$B0C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($060E.w,X)		; 7C 0E 06 ; Jump indirect indexed to ($060E.w,X) [Reads: X Index] [Flow: jump]
	jsl $002202.l		; 22 02 22 00 ; Jump to subroutine long $002202.l [Writes: Stack Pointer] [Flow: call]
	ora $07.b,X		; 15 07 ; OR accumulator with memory $07.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	cpy $FC.b		; C4 FC ; Compare $FC.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	adc $83FF.w,Y		; 79 FF 83 ; Add $83FF.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $769DF5.l,X		; 1F F5 9D 76 ; Logical OR long $769DF5.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $FF.b		; C4 FF ; Compare $FF.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	inc $1EFE.w,X		; FE FE 1E ; Increment memory $1EFE.w,X [Reads: X Index] [Flags: ZN]
	sta $5800E0.l,X		; 9F E0 00 58 ; Store accumulator (long,X) $5800E0.l,X [Reads: Accumulator, X Index]
	jsr $182C.w		; 20 2C 18 ; Jump to subroutine at $182C.w [Writes: Stack Pointer] [Flow: call]
	asl $0C.b,X		; 16 0C ; Arithmetic shift left $0C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $1D.b		; 06 1D ; Arithmetic shift left $1D.b [Reads: Direct Page] [Flags: ZNC]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $58E0.w		; 0C E0 58 ; Test and set bits $58E0.w [Reads: Accumulator] [Flags: Z]
	bit $1B16.w		; 2C 16 1B ; Test bits $1B16.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $131E.w,X		; 1D 1E 13 ; OR accumulator with memory $131E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and #$0500.w		; 29 00 05 ; Logical AND #$0500.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$2080.w		; C0 80 20 ; Compare #$2080.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$0024.w		; C0 24 00 ; Compare #$0024.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$802D.w		; E0 2D 80 ; Compare #$802D.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$1760.w		; C0 60 17 ; Compare #$1760.w with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $182E.w		; 0C 2E 18 ; Test and set bits $182E.w [Reads: Accumulator] [Flags: Z]
	eor $387F38.l,X		; 5F 38 7F 38 ; Exclusive OR accumulator with memory (long,X) $387F38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$7F.b]		; 27 7F ; AND accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b,S),Y		; 13 3F ; OR accumulator (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF7F7F.l,X		; 3F 7F 7F FF ; AND accumulator with memory (long,X) $FF7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jmp ($D63F.w)		; 6C 3F D6 ; Jump indirect to ($D63F.w) [Flow: jump]
	bit $2D.b		; 24 2D ; Test bits $2D.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc ($FD.b,X)		; E1 FD ; Subtract with carry ($FD.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $F3.b,S		; 03 F3 ; OR accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $FF0F7F.l		; 0F 7F 0F FF ; OR accumulator with memory (long) $FF0F7F.l [Writes: Accumulator] [Flags: ZN]
	asl $00FF.w,X		; 1E FF 00 ; Arithmetic shift left $00FF.w,X [Reads: X Index] [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc [$1F.b],Y		; F7 1F ; Subtract with carry (long indexed) [$1F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $2F7E9F.l		; 0F 9F 7E 2F ; OR accumulator with memory (long) $2F7E9F.l [Writes: Accumulator] [Flags: ZN]
	inc $FE37.w,X		; FE 37 FE ; Increment memory $FE37.w,X [Reads: X Index] [Flags: ZN]
	cmp $74DFF4.l,X		; DF F4 DF 74 ; Compare accumulator (long,X) $74DFF4.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	inc $FF79.w,X		; FE 79 FF ; Increment memory $FF79.w,X [Reads: X Index] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFE0F.l,X		; FF 0F FE FF ; Subtract with carry (long,X) $FFFE0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $1C.b,X		; F6 1C ; Increment memory $1C.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	inc $FA3C.w,X		; FE 3C FA ; Increment memory $FA3C.w,X [Reads: X Index] [Flags: ZN]
	jmp ($18FC.w,X)		; 7C FC 18 ; Jump indirect indexed to ($18FC.w,X) [Reads: X Index] [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$E010.w		; E0 10 E0 ; Compare #$E010.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$0022.w		; E0 22 00 ; Compare #$0022.w with X register [Reads: X Index] [Flags: ZNC]
	jsl $FC04FE.l		; 22 FE 04 FC ; Jump to subroutine long $FC04FE.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F05.w		; 0E 05 0F ; Arithmetic shift left $0F05.w [Flags: ZNC]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $9F0404.l		; 0F 04 04 9F ; OR accumulator with memory (long) $9F0404.l [Writes: Accumulator] [Flags: ZN]
	adc ($B5.b,S),Y		; 73 B5 ; Add with carry (stack relative indirect indexed) ($B5.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($56.b,S),Y		; 53 56 ; XOR accumulator (stack relative indirect indexed) ($56.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta ($49.b,X)		; 81 49 ; Store accumulator ($49.b,X) [Reads: Accumulator, X Index, Direct Page]
	sty $89.b		; 84 89 ; Store Y register to $89.b [Reads: Y Index]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $9F.b		; 04 9F ; Test and set bits $9F.b [Reads: Accumulator] [Flags: Z]
	lda $56.b,X		; B5 56 ; Load $56.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor #$2289.w		; 49 89 22 ; Exclusive OR #$2289.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1403.w		; 0C 03 14 ; Test and set bits $1403.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $0D.b,X		; 16 0D ; Arithmetic shift left $0D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and $43.b,S		; 23 43 ; AND accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1E002F.l,X		; 1F 2F 00 1E ; Logical OR long $1E002F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpx #$0C38.w		; E0 38 0C ; Compare #$0C38.w with X register [Reads: X Index] [Flags: ZNC]
	trb $16.b		; 14 16 ; Test and reset bits $16.b [Reads: Accumulator] [Flags: Z]
	and $2F.b,S		; 23 2F ; AND accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $432B2B.l		; 2F 2B 2B 43 ; AND accumulator with memory (long) $432B2B.l [Writes: Accumulator] [Flags: ZN]
	ldy $DC22.w,X		; BC 22 DC ; Load Y register $DC22.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sbc ($EE.b,S),Y		; F3 EE ; Subtract with carry (stack relative indirect indexed) ($EE.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $9AE772.l		; EF 72 E7 9A ; Subtract with carry (long) $9AE772.l [Writes: Accumulator] [Flags: ZVNC]
	adc $0EFFF6.l		; 6F F6 FF 0E ; Add with carry (long) $0EFFF6.l [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ror $FD3F.w,X		; 7E 3F FD ; Rotate right $FD3F.w,X [Reads: X Index] [Flags: ZNC]
	adc $6985.w		; 6D 85 69 ; Add $6985.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	sbc ($65.b),Y		; F1 65 ; Subtract with carry ($65.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	adc ($BD.b),Y		; 71 BD ; Add with carry ($BD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $3DCB.w,X		; 7E CB 3D ; Rotate right $3DCB.w,X [Reads: X Index] [Flags: ZNC]
	lda ($0F.b,S),Y		; B3 0F ; Load accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $03FF05.l,X		; 3F 05 FF 03 ; AND accumulator with memory (long,X) $03FF05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $807980.l		; 6F 80 79 80 ; Add with carry (long) $807980.l [Writes: Accumulator] [Flags: ZVNC]
	ldy $C9BC.w,X		; BC BC C9 ; Load Y register $C9BC.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc $EF.b,S		; 63 EF ; Add with carry (stack relative) $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	cmp $01FEDF.l,X		; DF DF FE 01 ; Compare accumulator (long,X) $01FEDF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	rol $0000.w		; 2E 00 00 ; Rotate left $0000.w [Flags: ZNC]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($4410.w,X)		; FC 10 44 ; Jump to subroutine indirect indexed ($4410.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $26.b		; 04 26 ; Test and set bits $26.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($3A44.w,X)		; FC 44 3A ; Jump to subroutine indirect indexed ($3A44.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rol $25.b		; 26 25 ; Rotate left $25.b [Reads: Direct Page] [Flags: ZNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0800.w		; C0 00 08 ; Compare #$0800.w with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $02.b,S		; 83 02 ; Store accumulator (stack relative) $02.b,S [Reads: Accumulator, Stack Pointer]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$7E70.w		; E0 70 7E ; Compare #$7E70.w with X register [Reads: X Index] [Flags: ZNC]
	asl $02.b,X		; 16 02 ; Arithmetic shift left $02.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $0000.w		; 2E 00 00 ; Rotate left $0000.w [Flags: ZNC]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$3A.b],Y		; 57 3A ; Exclusive OR accumulator with memory (long indexed) [$3A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1213.w,X		; 3D 13 12 ; AND accumulator with memory $1213.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $3D.b,X		; 56 3D ; Logical shift right $3D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora ($01.b)		; 12 01 ; OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $19		; 10 19 ; Branch if plus to $10, $19 [Flow: branch]
	asl $0F14.w		; 0E 14 0F ; Arithmetic shift left $0F14.w [Flags: ZNC]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	jsr $3C1F.w		; 20 1F 3C ; Jump to subroutine at $3C1F.w [Writes: Stack Pointer] [Flow: call]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $02FE.w,X		; 3C FE 02 ; Test bits $02FE.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $FD7F.w,X		; 3C 7F FD ; Test bits $FD7F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx #$9040.w		; E0 40 90 ; Compare #$9040.w with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $B0, $60		; B0 60 ; Branch if carry set to $B0, $60 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $B0, $58		; B0 58 ; Branch if carry set to $B0, $58 [Flow: branch]
	.db $B0, $54		; B0 54 ; Branch if carry set to $B0, $54 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	cmp $A7DA24.l,X		; DF 24 DA A7 ; Compare accumulator (long,X) $A7DA24.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	cpx #$B0B0.w		; E0 B0 B0 ; Compare #$B0B0.w with X register [Reads: X Index] [Flags: ZNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jmp $7C5BDF.l		; 5C DF 5B 7C ; Jump long to $7C5BDF.l [Flow: jump]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($037F.w,X)		; 7C 7F 03 ; Jump indirect indexed to ($037F.w,X) [Reads: X Index] [Flow: jump]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $08.b,S		; 43 08 ; Exclusive OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora [$7C.b]		; 07 7C ; OR accumulator with memory (long) [$7C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $08137F.l,X		; FF 7F 13 08 ; Subtract with carry (long,X) $08137F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($84.b,S),Y		; 13 84 ; OR accumulator (stack relative indirect indexed) ($84.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $FB.b		; 84 FB ; Store Y register to $FB.b [Reads: Y Index]
	ror $F4.b		; 66 F4 ; Rotate right $F4.b [Reads: Direct Page] [Flags: ZNC]
	lda $CB3F.w,Y		; B9 3F CB ; Load $CB3F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $00F5.w		; 0E F5 00 ; Arithmetic shift left $00F5.w [Flags: ZNC]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F6FB.w		; EE FB F6 ; Increment $F6FB.w [Flags: ZN]
	rol $270F.w,X		; 3E 0F 27 ; Rotate left $270F.w,X [Reads: X Index] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $187F07.l,X		; 1F 07 7F 18 ; Logical OR long $187F07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $2367.w,Y		; F9 67 23 ; Subtract with carry $2367.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $0000F9.l,X		; 7F F9 00 00 ; Add long $0000F9.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $78.b,S		; 83 78 ; Store accumulator (stack relative) $78.b,S [Reads: Accumulator, Stack Pointer]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $E4.b		; 06 E4 ; Arithmetic shift left $E4.b [Reads: Direct Page] [Flags: ZNC]
	sbc $0BFF.w,Y		; F9 FF 0B ; Subtract with carry $0BFF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $1DF5.w		; 0E F5 1D ; Arithmetic shift left $1DF5.w [Flags: ZNC]
	inc $0400.w		; EE 00 04 ; Increment $0400.w [Flags: ZN]
	asl $E6FB.w		; 0E FB E6 ; Arithmetic shift left $E6FB.w [Flags: ZNC]
	inc $1F0F.w,X		; FE 0F 1F ; Increment memory $1F0F.w,X [Reads: X Index] [Flags: ZN]
	and #$0400.w		; 29 00 04 ; Logical AND #$0400.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $0E1300.l		; 0F 00 13 0E ; OR accumulator with memory (long) $0E1300.l [Writes: Accumulator] [Flags: ZN]
	and $020025.l,X		; 3F 25 00 02 ; AND accumulator with memory (long,X) $020025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $273F13.l		; 0F 13 3F 27 ; OR accumulator with memory (long) $273F13.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sty $F9.b		; 84 F9 ; Store Y register to $F9.b [Reads: Y Index]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$0023.w		; C0 23 00 ; Compare #$0023.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$402E.w		; E0 2E 40 ; Compare #$402E.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$60B0.w		; C0 B0 60 ; Compare #$60B0.w with Y register [Reads: Y Index] [Flags: ZNC]
	bit $381F.w,X		; 3C 1F 38 ; Test bits $381F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $3B1F39.l,X		; 1F 39 1F 3B ; Logical OR long $3B1F39.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $0C1B.w		; 1C 1B 0C ; Test and reset bits $0C1B.w [Reads: Accumulator] [Flags: Z]
	trb $1E0F.w		; 1C 0F 1E ; Test and reset bits $1E0F.w [Reads: Accumulator] [Flags: Z]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	and $1B3B.w,Y		; 39 3B 1B ; AND accumulator with memory $1B3B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $141A.w		; 1C 1A 14 ; Test and reset bits $141A.w [Reads: Accumulator] [Flags: Z]
	inc $FC0C.w,X		; FE 0C FC ; Increment memory $FC0C.w,X [Reads: X Index] [Flags: ZN]
	lda ($FC.b),Y		; B1 FC ; Load accumulator ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp ($B0.b),Y		; D1 B0 ; Compare accumulator ($B0.b),Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	cmp $A1.b,S		; C3 A1 ; Compare accumulator (stack relative) $A1.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	dec $00FF.w,X		; DE FF 00 ; Decrement memory $00FF.w,X [Reads: X Index] [Flags: ZN]
	adc $51F19E.l,X		; 7F 9E F1 51 ; Add long $51F19E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($CF.b,S),Y		; F3 CF ; Subtract with carry (stack relative indirect indexed) ($CF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $03FF22.l		; EF 22 FF 03 ; Subtract with carry (long) $03FF22.l [Writes: Accumulator] [Flags: ZVNC]
	adc ($EE.b,X)		; 61 EE ; Add with carry ($EE.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($80.b,S),Y		; 73 80 ; Add with carry (stack relative indirect indexed) ($80.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $F7.b,S		; 43 F7 ; Exclusive OR accumulator with stack relative $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $307F20.l,X		; 7F 20 7F 30 ; Add long $307F20.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $02DF18.l,X		; BF 18 DF 02 ; Load long $02DF18.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($FEFC.w,X)		; FC FC FE ; Jump to subroutine indirect indexed ($FEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FF22F9.l,X		; FF F9 22 FF ; Subtract with carry (long,X) $FF22F9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $91.b		; 84 91 ; Store Y register to $91.b [Reads: Y Index]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $26E0.w		; 1C E0 26 ; Test and reset bits $26E0.w [Reads: Accumulator] [Flags: Z]
	trb $1E0F.w		; 1C 0F 1E ; Test and reset bits $1E0F.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $382C04.l		; 0F 04 2C 38 ; OR accumulator with memory (long) $382C04.l [Writes: Accumulator] [Flags: ZN]
	and $3B3B.w,Y		; 39 3B 3B ; AND accumulator with memory $3B3B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $0C1A.w		; 1C 1A 0C ; Test and reset bits $0C1A.w [Reads: Accumulator] [Flags: Z]
	cmp $B1CF2C.l,X		; DF 2C CF B1 ; Compare accumulator (long,X) $B1CF2C.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $84F6D4.l		; EF D4 F6 84 ; Subtract with carry (long) $84F6D4.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $82.b,S		; E3 82 ; Subtract stack-relative $82.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc $7601.w		; ED 01 76 ; Subtract $7601.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	.db $90, $F9		; 90 F9 ; Branch if carry clear to $90, $F9 [Flow: branch]
	eor #$FEF3.w		; 49 F3 FE ; Exclusive OR #$FEF3.w with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $BDBB.w,X		; FE BB BD ; Increment memory $BDBB.w,X [Reads: X Index] [Flags: ZN]
	sbc ($69.b)		; F2 69 ; Subtract with carry (indirect) ($69.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $F3.b,X		; F6 F3 ; Increment memory $F3.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sta $C1.b,S		; 83 C1 ; Store accumulator (stack relative) $C1.b,S [Reads: Accumulator, Stack Pointer]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	sbc $00BF30.l,X		; FF 30 BF 00 ; Subtract with carry (long,X) $00BF30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rep #$80		; C2 80 ; Reset processor status bits #$80 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	adc $847C80.l,X		; 7F 80 7C 84 ; Add long $847C80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp ($03.b),Y		; D1 03 ; Compare accumulator ($03.b),Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	ora ($7D.b,X)		; 01 7D ; Logical OR ($7D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $1B003B.l,X		; 7F 3B 00 1B ; Add long $1B003B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	ora #$133F.w		; 09 3F 13 ; Logical OR #$133F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $56FD25.l,X		; 7F 25 FD 56 ; Add long $56FD25.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	asl $7E3E.w,X		; 1E 3E 7E ; Arithmetic shift left $7E3E.w,X [Reads: X Index] [Flags: ZNC]
	sbc $08040B.l,X		; FF 0B 04 08 ; Subtract with carry (long,X) $08040B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $01.b		; E6 01 ; Increment $01.b [Reads: Direct Page] [Flags: ZN]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $080B00.l,X		; 1F 00 0B 08 ; Logical OR long $080B00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $62, $05, $1F		; 62 05 1F ; Push effective relative address $62, $05, $1F [Writes: Stack Pointer]
	asl $1F1C.w		; 0E 1C 1F ; Arithmetic shift left $1F1C.w [Flags: ZNC]
	cmp $EE27.w,Y		; D9 27 EE ; Compare accumulator $EE27.w,Y [Reads: Y Index] [Flags: ZNC]
	ora $6A.b,X		; 15 6A ; OR accumulator with memory $6A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$ED.b],Y		; 57 ED ; Exclusive OR accumulator with memory (long indexed) [$ED.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $9C69.w,X		; 1D 69 9C ; OR accumulator with memory $9C69.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $CE.b,X		; 34 CE ; Test bits $CE.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sta ($6F.b)		; 92 6F ; Store accumulator (indirect) ($6F.b) [Reads: Accumulator, Direct Page]
	cmp $AAEC.w,Y		; D9 EC AA ; Compare accumulator $AAEC.w,Y [Reads: Y Index] [Flags: ZNC]
	cpx $6FEE.w		; EC EE 6F ; Compare $6FEE.w with X register [Reads: X Index] [Flags: ZNC]
	and [$93.b],Y		; 37 93 ; AND accumulator with memory (long indexed) [$93.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $1F07.w		; 0C 07 1F ; Test and set bits $1F07.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $181F.w		; 0C 1F 18 ; Test and set bits $181F.w [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $EE1D.w		; 0C 1D EE ; Test and set bits $EE1D.w [Reads: Accumulator] [Flags: Z]
	tsb $EFF7.w		; 0C F7 EF ; Test and set bits $EFF7.w [Reads: Accumulator] [Flags: Z]
	and ($75.b,S),Y		; 33 75 ; AND accumulator (stack relative indirect indexed) ($75.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $26.b,S		; 23 26 ; AND accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	jsl $1F0E00.l		; 22 00 0E 1F ; Jump to subroutine long $1F0E00.l [Writes: Stack Pointer] [Flow: call]
	ora $2675EF.l		; 0F EF 75 26 ; OR accumulator with memory (long) $2675EF.l [Writes: Accumulator] [Flags: ZN]
	ora #$0009.w		; 09 09 00 ; Logical OR #$0009.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc ($1F.b,X)		; 61 1F ; Add with carry ($1F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($1A.b,X)		; 61 1A ; Add with carry ($1A.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$0104.w		; A9 04 01 ; Load #$0104.w into accumulator [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010000.l		; 22 00 00 01 ; Jump to subroutine long $010000.l [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E000.w		; E0 00 E0 ; Compare #$E000.w with X register [Reads: X Index] [Flags: ZNC]
	mvp $A0,$40		; 44 40 A0 ; Move block positive $A0,$40 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cpx #$A0E0.w		; E0 E0 A0 ; Compare #$A0E0.w with X register [Reads: X Index] [Flags: ZNC]
	ldy #$80C0.w		; A0 C0 80 ; Load #$80C0.w into Y register [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $041B00.l,X		; 1F 00 1B 04 ; Logical OR long $041B00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor [$30.b]		; 47 30 ; Exclusive OR accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $071805.l		; 0F 05 18 07 ; OR accumulator with memory (long) $071805.l [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $2F.b,S		; 23 2F ; AND accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$1F38.w		; E0 38 1F ; Compare #$1F38.w with X register [Reads: X Index] [Flags: ZNC]
	ora [$F6.b]		; 07 F6 ; OR accumulator with memory (long) [$F6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $B7		; B0 B7 ; Branch if carry set to $B0, $B7 [Flow: branch]
	.db $50, $3B		; 50 3B ; Branch if overflow clear to $50, $3B [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	lda $78BF7B.l,X		; BF 7B BF 78 ; Load long $78BF7B.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $67FE63.l,X		; BF 63 FE 67 ; Load long $67FE63.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	cmp #$F4E8.w		; C9 E8 F4 ; Compare #$F4E8.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	ldy $A3BB.w,X		; BC BB A3 ; Load Y register $A3BB.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $80.b		; E6 80 ; Increment $80.b [Reads: Direct Page] [Flags: ZN]
	sbc [$80.b]		; E7 80 ; Subtract with carry (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $0CFE20.l,X		; 3F 20 FE 0C ; AND accumulator with memory (long,X) $0CFE20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $16C4.w,X		; 3D C4 16 ; AND accumulator with memory $16C4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	nop		; EA ; No operation
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $FF.b,X		; 95 FF ; Store accumulator to $FF.b,X [Reads: Accumulator, X Index]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $3AF1DF.l,X		; BF DF F1 3A ; Load long $3AF1DF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $FF7E.w,X		; 1D 7E FF ; OR accumulator with memory $FF7E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000700.l		; 0F 00 07 00 ; OR accumulator with memory (long) $000700.l [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $010307.l		; 0F 07 03 01 ; OR accumulator with memory (long) $010307.l [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$FF23.w		; E0 23 FF ; Compare #$FF23.w with X register [Reads: X Index] [Flags: ZNC]
	ldx $BF.b,Y		; [PATTERN: Memory clearing operation] B6 BF ; Load X register $BF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	stz $EC77.w,X		; 9E 77 EC ; Store zero to $EC77.w,X [Reads: X Index]
	sta $7B4FF0.l,X		; 9F F0 4F 7B ; Store accumulator (long,X) $7B4FF0.l,X [Reads: Accumulator, X Index]
	stz $3F.b		; 64 3F ; Store zero to $3F.b
	and $0C0C.w,Y		; 39 0C 0C ; AND accumulator with memory $0C0C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $96AF.w,Y		; F9 AF 96 ; Subtract with carry $96AF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $7BF0.w		; EC F0 7B ; Compare $7BF0.w with X register [Reads: X Index] [Flags: ZNC]
	and $08F90C.l,X		; 3F 0C F9 08 ; AND accumulator with memory (long,X) $08F90C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy $8734.w		; CC 34 87 ; Compare $8734.w with Y register [Reads: Y Index] [Flags: ZNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $20E141.l,X		; BF 41 E1 20 ; Load long $20E141.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$23C0.w		; C0 C0 23 ; Compare #$23C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FB.b,X		; F6 FB ; Increment memory $FB.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	jsr ($E1FE.w,X)		; FC FE E1 ; Jump to subroutine indirect indexed ($E1FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$0023.w		; C0 23 00 ; Compare #$0023.w with Y register [Reads: Y Index] [Flags: ZNC]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $EE.b,S		; 83 EE ; Store accumulator (stack relative) $EE.b,S [Reads: Accumulator, Stack Pointer]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ABDD5A.l		; EF 5A DD AB ; Subtract with carry (long) $ABDD5A.l [Writes: Accumulator] [Flags: ZVNC]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sta ($C1.b,X)		; 81 C1 ; Store accumulator ($C1.b,X) [Reads: Accumulator, X Index, Direct Page]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $EE.b		; 04 EE ; Test and set bits $EE.b [Reads: Accumulator] [Flags: Z]
	cmp $C1EA.w,X		; DD EA C1 ; Compare accumulator $C1EA.w,X [Reads: X Index] [Flags: ZNC]
	.db $80, $3A		; 80 3A ; Branch always to $80, $3A [Flow: branch]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0D07.w,Y		; 79 07 0D ; Add $0D07.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$79.b]		; 07 79 ; OR accumulator with memory (long) [$79.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0204.w		; 0D 04 02 ; Logical OR $0204.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000109.l,X		; FF 09 01 00 ; Subtract with carry (long,X) $000109.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0D01.w		; 0E 01 0D ; Arithmetic shift left $0D01.w [Flags: ZNC]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	and ($0B.b,X)		; 21 0B ; Logical AND ($0B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$160B.w		; 09 0B 16 ; Logical OR #$160B.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0E.b,X		; 16 0E ; Arithmetic shift left $0E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx #$F300.w		; E0 00 F3 ; Compare #$F300.w with X register [Reads: X Index] [Flags: ZNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $1C.b,S		; 83 1C ; Store accumulator (stack relative) $1C.b,S [Reads: Accumulator, Stack Pointer]
	sbc [$B8.b]		; E7 B8 ; Subtract with carry (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $ECBF78.l		; 4F 78 BF EC ; Exclusive OR accumulator with memory (long) $ECBF78.l [Writes: Accumulator] [Flags: ZN]
	adc $E07FC7.l,X		; 7F C7 7F E0 ; Add long $E07FC7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($8F.b,S),Y		; 13 8F ; OR accumulator (stack relative indirect indexed) ($8F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $EEFC7E.l		; EF 7E FC EE ; Subtract with carry (long) $EEFC7E.l [Writes: Accumulator] [Flags: ZVNC]
	cmp [$27.b]		; C7 27 ; Compare accumulator (long) [$27.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2A.b,X)		; 01 2A ; Logical OR ($2A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0BF7.w		; 0C F7 0B ; Test and set bits $0BF7.w [Reads: Accumulator] [Flags: Z]
	cpy $B837.w		; CC 37 B8 ; Compare $B837.w with Y register [Reads: Y Index] [Flags: ZNC]
	eor $EC3F78.l		; 4F 78 3F EC ; Exclusive OR accumulator with memory (long) $EC3F78.l [Writes: Accumulator] [Flags: ZN]
	adc $4F2418.l,X		; 7F 18 24 4F ; Add long $4F2418.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $7CFE7F.l		; AF 7F FE 7C ; Load long $7CFE7F.l into accumulator [Writes: Accumulator] [Flags: ZN]
	inc $0000.w		; EE 00 00 ; Increment $0000.w [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $104307.l		; 0F 07 43 10 ; OR accumulator with memory (long) $104307.l [Writes: Accumulator] [Flags: ZN]
	ora $1F7015.l		; 0F 15 70 1F ; OR accumulator with memory (long) $1F7015.l [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc $007F90.l,X		; 7F 90 7F 00 ; Add long $007F90.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $00B0F9.l,X		; 7F F9 B0 00 ; Add long $00B0F9.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $EC		; 80 EC ; Branch always to $80, $EC [Flow: branch]
	.db $90, $43		; 90 43 ; Branch if carry clear to $90, $43 [Flow: branch]
	ror $0BC0.w,X		; 7E C0 0B ; Rotate right $0BC0.w,X [Reads: X Index] [Flags: ZNC]
	inc $F780.w,X		; FE 80 F7 ; Increment memory $F780.w,X [Reads: X Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	pea $E6FA.w		; F4 FA E6 ; Push absolute address $E6FA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rep #$C9		; C2 C9 ; Reset processor status bits #$C9 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sta $62.b,S		; 83 62 ; Store accumulator (stack relative) $62.b,S [Reads: Accumulator, Stack Pointer]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	sta $6A.b		; 85 6A ; Store accumulator to $6A.b [Reads: Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $863F.w,Y		; D9 3F 86 ; Compare accumulator $863F.w,Y [Reads: Y Index] [Flags: ZNC]
	adc ($00.b),Y		; 71 00 ; Add with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $D9.b		; 02 D9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	eor ($60.b,X)		; 41 60 ; Exclusive OR accumulator with memory ($60.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy #$E058.w		; C0 58 E0 ; Compare #$E058.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx $D8.b		; E4 D8 ; Compare $D8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	jsr ($FC88.w,X)		; FC 88 FC ; Jump to subroutine indirect indexed ($FC88.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0C0.w		; C0 C0 E0 ; Compare #$E0C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpx $DC.b		; E4 DC ; Compare $DC.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	jmp.w [$0007]		; DC 07 00 ; Jump long indirect [$0007] [Flow: jump]
	tsb $1B07.w		; 0C 07 1B ; Test and set bits $1B07.w [Reads: Accumulator] [Flags: Z]
	asl $1D2E.w		; 0E 2E 1D ; Arithmetic shift left $1D2E.w [Flags: ZNC]
	rol $5E1B.w		; 2E 1B 5E ; Rotate left $5E1B.w [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $37DB37.l,X		; 5F 37 DB 37 ; Exclusive OR accumulator with memory (long,X) $37DB37.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $5F2F2F.l,X		; 1F 2F 2F 5F ; Logical OR long $5F2F2F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $00E0DB.l,X		; 5F DB E0 00 ; Exclusive OR accumulator with memory (long,X) $00E0DB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $70, $54		; 70 54 ; Branch if overflow set to $70, $54 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	bit $D8.b,X		; 34 D8 ; Test bits $D8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	jmp $1BEC1A.l		; 5C 1A EC 1B ; Jump long to $1BEC1A.l [Flow: jump]
	cpx $70E0.w		; EC E0 70 ; Compare $70E0.w with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp.w [$6EFC]		; DC FC 6E ; Jump long indirect [$6EFC] [Flow: jump]
	inc $83FF.w,X		; FE FF 83 ; Increment memory $83FF.w,X [Reads: X Index] [Flags: ZN]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora ($06.b,S),Y		; 13 06 ; OR accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $37.b		; 04 37 ; Test and set bits $37.b [Reads: Accumulator] [Flags: Z]
	trb $3B6E.w		; 1C 6E 3B ; Test and reset bits $3B6E.w [Reads: Accumulator] [Flags: Z]
	jmp ($BA3B.w)		; 6C 3B BA ; Jump indirect to ($BA3B.w) [Flow: jump]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $7F7F3F.l,X		; 1F 3F 7F 7F ; Logical OR long $7F7F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sta $78.b,S		; 83 78 ; Store accumulator (stack relative) $78.b,S [Reads: Accumulator, Stack Pointer]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $D8		; 80 D8 ; Branch always to $80, $D8 [Flow: branch]
	jsr $38E4.w		; 20 E4 38 ; Jump to subroutine at $38E4.w [Writes: Stack Pointer] [Flow: call]
	and ($DC.b)		; 32 DC ; AND accumulator with memory (indirect) ($DC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	trb $EE19.w		; 1C 19 EE ; Test and reset bits $EE19.w [Reads: Accumulator] [Flags: Z]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($3EFE.w,X)		; FC FE 3E ; Jump to subroutine indirect indexed ($3EFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $150039.l,X		; FF 39 00 15 ; Subtract with carry (long,X) $150039.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $2A00.w		; 1C 00 2A ; Test and reset bits $2A00.w [Reads: Accumulator] [Flags: Z]
	trb $3854.w		; 1C 54 38 ; Test and reset bits $3854.w [Reads: Accumulator] [Flags: Z]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $AB.b,X		; 34 AB ; Test bits $AB.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ror $AC.b,X		; 76 AC ; Rotate right $AC.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc ($BE.b,S),Y		; 73 BE ; Add with carry (stack relative indirect indexed) ($BE.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($00.b),Y		; 71 00 ; Add with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $5C2E.w		; 1C 2E 5C ; Test and reset bits $5C2E.w [Reads: Accumulator] [Flags: Z]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ldy $23BE.w,X		; BC BE 23 ; Load Y register $23BE.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $021D03.l		; 22 03 1D 02 ; Jump to subroutine long $021D03.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$7000.w		; C0 00 70 ; Compare #$7000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$B078.w		; C0 78 B0 ; Compare #$B078.w with Y register [Reads: Y Index] [Flags: ZNC]
	jmp ($7798.w)		; 6C 98 77 ; Jump indirect to ($7798.w) [Flow: jump]
	sty $8778.w		; 8C 78 87 ; Store Y register to $8778.w [Reads: Y Index]
	ldx $00C1.w,Y		; BE C1 00 ; Load X register $00C1.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	cpy #$F8F0.w		; C0 F0 F8 ; Compare #$F8F0.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx $F8F7.w		; EC F7 F8 ; Compare $F8F7.w with X register [Reads: X Index] [Flags: ZNC]
	inc $0007.w,X		; FE 07 00 ; Increment memory $0007.w,X [Reads: X Index] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1FBC3F.l		; EF 3F BC 1F ; Subtract with carry (long) $1FBC3F.l [Writes: Accumulator] [Flags: ZVNC]
	ror $FF01.w,X		; 7E 01 FF ; Rotate right $FF01.w,X [Reads: X Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	jmp.w [$7714]		; DC 14 77 ; Jump long indirect [$7714] [Flow: jump]
	jsl $EF0600.l		; 22 00 06 EF ; Jump to subroutine long $EF0600.l [Writes: Stack Pointer] [Flow: call]
	ldy $957E.w,X		; BC 7E 95 ; Load Y register $957E.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	pei ($EB.b)		; D4 EB ; Push effective indirect address ($EB.b) [Reads: Direct Page] [Writes: Stack Pointer]
	adc [$2A.b],Y		; 77 2A ; Add with carry (long indexed) [$2A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $3C3F6F.l,X		; 7F 6F 3F 3C ; Add long $3C3F6F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $6FC700.l,X		; 7F 00 C7 6F ; Add long $6FC700.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $AA83.w,X		; 3C 83 AA ; Test bits $AA83.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $7F.b		; 25 7F ; Logical AND $7F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $7F3F.w,Y		; D9 3F 7F ; Compare accumulator $7F3F.w,Y [Reads: Y Index] [Flags: ZNC]
	ora $7F077F.l,X		; 1F 7F 07 7F ; Logical OR long $7F077F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $7B		; 30 7B ; Branch if minus to $30, $7B [Flow: branch]
	and $0627.w,Y		; 39 27 06 ; AND accumulator with memory $0627.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and $000E06.l,X		; 3F 06 0E 00 ; AND accumulator with memory (long,X) $000E06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $5F7F.w,Y		; D9 7F 5F ; Compare accumulator $5F7F.w,Y [Reads: Y Index] [Flags: ZNC]
	eor $393946.l		; 4F 46 39 39 ; Exclusive OR accumulator with memory (long) $393946.l [Writes: Accumulator] [Flags: ZN]
	asl $04FB.w		; 0E FB 04 ; Arithmetic shift left $04FB.w [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	bit $AD.b		; 24 AD ; Test bits $AD.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	eor ($A6.b)		; 52 A6 ; Exclusive OR accumulator with memory (indirect) ($A6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	pea $F488.w		; F4 88 F4 ; Push absolute address $F488.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsl $8D0700.l		; 22 00 07 8D ; Jump to subroutine long $8D0700.l [Writes: Stack Pointer] [Flow: call]
	lda $FEF7.w		; AD F7 FE ; Load $FEF7.w into accumulator [Writes: Accumulator] [Flags: ZN]
	jmp ($C83C.w,X)		; 7C 3C C8 ; Jump indirect indexed to ($C83C.w,X) [Reads: X Index] [Flow: jump]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sep #$01		; E2 01 ; Set processor status bits #$01 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F18500.l		; 22 00 85 F1 ; Jump to subroutine long $F18500.l [Writes: Stack Pointer] [Flow: call]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $000F.w,Y		; 79 0F 00 ; Add $000F.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $30C8.w		; 20 C8 30 ; Jump to subroutine at $30C8.w [Writes: Stack Pointer] [Flow: call]
	ldy $48.b,X		; B4 48 ; Load Y register $48.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ldy #$80F0.w		; A0 F0 80 ; Load #$80F0.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jmp.w [$5078]		; DC 78 50 ; Jump long indirect [$5078] [Flow: jump]
	.db $D0, $60		; D0 60 ; Branch if not equal to $D0, $60 [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda [$C9.b],Y		; B7 C9 ; Load accumulator (long indexed) [$C9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$A4.b],Y		; 37 A4 ; AND accumulator with memory (long indexed) [$A4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jmp.w [$6F43]		; DC 43 6F ; Jump long indirect [$6F43] [Flow: jump]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	and $001E1B.l,X		; 3F 1B 1E 00 ; AND accumulator with memory (long,X) $001E1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	cmp #$BCE4.w		; C9 E4 BC ; Compare #$BCE4.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	eor [$24.b],Y		; 57 24 ; Exclusive OR accumulator with memory (long indexed) [$24.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $EDBB01.l,X		; 1F 01 BB ED ; Logical OR long $EDBB01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($EC.b,S),Y		; F3 EC ; Subtract with carry (stack relative indirect indexed) ($EC.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $D8.b		; E5 D8 ; Subtract $D8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
.ACCU 16
.INDEX 16
	rep #$F6		; C2 F6
	trb $F4.b		; 14 F4 ; Test and reset bits $F4.b [Reads: Accumulator] [Flags: Z]
	cpy #$0078.w		; C0 78 00 ; Compare #$0078.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sbc ($E7.b,S),Y		; F3 E7 ; Subtract with carry (stack relative indirect indexed) ($E7.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $3CEA.w,X		; 3D EA 3C ; AND accumulator with memory $3CEA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $80, $B9		; 80 B9 ; Branch always to $80, $B9 [Flow: branch]
	adc [$88.b],Y		; 77 88 ; Add with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$C8.b],Y		; 77 C8 ; Add with carry (long indexed) [$C8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda [$A7.b],Y		; B7 A7 ; Load accumulator (long indexed) [$A7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tsb $6F.b		; 04 6F ; Test and set bits $6F.b [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	sbc $007272.l,X		; FF 72 72 00 ; Subtract with carry (long,X) $007272.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $4888.w,Y		; B9 88 48 ; Load $4888.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	lda [$7B.b]		; A7 7B ; Load accumulator (long) [$7B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvn $72,$8D		; 54 8D 72 ; Move block negative $72,$8D [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	inc $EED5.w		; EE D5 EE ; Increment $EED5.w [Flags: ZN]
	ora ($ED.b,S),Y		; 13 ED ; OR accumulator (stack relative indirect indexed) ($ED.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $18.b		; E5 18 ; Subtract $18.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsr $D8FA.w		; 20 FA D8 ; Jump to subroutine at $D8FA.w [Writes: Stack Pointer] [Flow: call]
	sbc $004E4E.l,X		; FF 4E 4E 00 ; Subtract with carry (long,X) $004E4E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E512D5.l,X		; FF D5 12 E5 ; Subtract with carry (long,X) $E512D5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $B126.w,X		; DE 26 B1 ; Decrement memory $B126.w,X [Reads: X Index] [Flags: ZN]
	lsr $0029.w		; 4E 29 00 ; Logical shift right $0029.w [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$1B00.w		; 29 00 1B ; Logical AND #$1B00.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $5E		; 70 5E ; Branch if overflow set to $70, $5E [Flow: branch]
	and $073C.w,Y		; 39 3C 07 ; AND accumulator with memory $073C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $1F.b		; 66 1F ; Rotate right $1F.b [Reads: Direct Page] [Flags: ZNC]
	sbc ($4F.b,S),Y		; F3 4F ; Subtract with carry (stack relative indirect indexed) ($4F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sta [$FF.b]		; 87 FF ; Store accumulator (long) [$FF.b] [Reads: Accumulator, Direct Page]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $673F5F.l,X		; 9F 5F 3F 67 ; Store accumulator (long,X) $673F5F.l,X [Reads: Accumulator, X Index]
	lda ($78.b,S),Y		; B3 78 ; Load accumulator (stack relative indirect indexed) ($78.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $280177.l,X		; 9F 77 01 28 ; Store accumulator (long,X) $280177.l,X [Reads: Accumulator, X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $DD		; F0 DD ; Branch if equal to $F0, $DD [Flow: branch]
	rol $3B.b,X		; 36 3B ; Rotate left $3B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $1877.w		; 0C 77 18 ; Test and set bits $1877.w [Reads: Accumulator] [Flags: Z]
	inc $AD59.w,X		; FE 59 AD ; Increment memory $AD59.w,X [Reads: X Index] [Flags: ZN]
	sta $7767FA.l,X		; 9F FA 67 77 ; Store accumulator (long,X) $7767FA.l,X [Reads: Accumulator, X Index]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $773B.w,X		; DD 3B 77 ; Compare accumulator $773B.w,X [Reads: X Index] [Flags: ZNC]
	lda $779A6F.l,X		; BF 6F 9A 77 ; Load long $779A6F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $07,$00		; 44 00 07 ; Move block positive $07,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $0E.b,S		; 43 0E ; Exclusive OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora #$0009.w		; 09 09 00 ; Logical OR #$0009.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr ($0D07.w,X)		; FC 07 0D ; Jump to subroutine indirect indexed ($0D07.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $CB.b,X		; 34 CB ; Test bits $CB.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	mvn $E2,$AB		; 54 AB E2 ; Move block negative $E2,$AB [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $E300.w,X		; 1D 00 E3 ; OR accumulator with memory $E300.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $EECC.w		; 0E CC EE ; Arithmetic shift left $EECC.w [Flags: ZNC]
	sta $020027.l,X		; 9F 27 00 02 ; Store accumulator (long,X) $020027.l,X [Reads: Accumulator, X Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $01.b,X		; 94 01 ; Store Y register $01.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	ora [$30.b],Y		; 17 30 ; OR accumulator with memory (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $BE.b,S		; 23 BE ; AND accumulator with stack relative $BE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor ($76.b,X)		; 41 76 ; Exclusive OR accumulator with memory ($76.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit #$29D6.w		; 89 D6 29 ; Test bits #$29D6.w with accumulator [Reads: Accumulator] [Flags: Z]
	ldy $4B.b,X		; B4 4B ; Load Y register $4B.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $30, $48		; 30 48 ; Branch if minus to $30, $48 [Flow: branch]
	sta [$A7.b]		; 87 A7 ; Store accumulator (long) [$A7.b] [Reads: Accumulator, Direct Page]
	adc $CA.b,S		; 63 CA ; Add with carry (stack relative) $CA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	inc $0027.w,X		; FE 27 00 ; Increment memory $0027.w,X [Reads: X Index] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsr ($F807.w,X)		; FC 07 F8 ; Jump to subroutine indirect indexed ($F807.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $833FF8.l		; 0F F8 3F 83 ; OR accumulator with memory (long) $833FF8.l [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and [$4F.b]		; 27 4F ; AND accumulator with memory (long) [$4F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $002C85.l		; AF 85 2C 00 ; Load long $002C85.l into accumulator [Writes: Accumulator] [Flags: ZN]
	sta $56.b,S		; 83 56 ; Store accumulator (stack relative) $56.b,S [Reads: Accumulator, Stack Pointer]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $3803.w		; 0C 03 38 ; Test and set bits $3803.w [Reads: Accumulator] [Flags: Z]
	ora $3F5843.l		; 0F 43 58 3F ; OR accumulator with memory (long) $3F5843.l [Writes: Accumulator] [Flags: ZN]
	ora #$3F7C.w		; 09 7C 3F ; Logical OR #$3F7C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $837C7C.l,X		; 7F 7C 7C 83 ; Add long $837C7C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$D0EC.w		; C0 EC D0 ; Compare #$D0EC.w with Y register [Reads: Y Index] [Flags: ZNC]
	eor $7E.b,S		; 43 7E ; Exclusive OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpy #$FE06.w		; C0 06 FE ; Compare #$FE06.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $77		; 80 77 ; Branch always to $80, $77 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $8B.b,S		; 83 8B ; Store accumulator (stack relative) $8B.b,S [Reads: Accumulator, Stack Pointer]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor #$384F.w		; 49 4F 38 ; Exclusive OR #$384F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	stz $9B73.w		; 9C 73 9B ; Store zero to $9B73.w
	adc [$B6.b]		; 67 B6 ; Add with carry (long) [$B6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $A85FAC.l		; 4F AC 5F A8 ; Exclusive OR accumulator with memory (long) $A85FAC.l [Writes: Accumulator] [Flags: ZN]
	eor $BF3FDF.l,X		; 5F DF 3F BF ; Exclusive OR accumulator with memory (long,X) $BF3FDF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor $B79B9C.l		; 4F 9C 9B B7 ; Exclusive OR accumulator with memory (long) $B79B9C.l [Writes: Accumulator] [Flags: ZN]
	lda $BFDFAF.l		; AF AF DF BF ; Load long $BFDFAF.l into accumulator [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $30.b,S		; 23 30 ; AND accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0B03.w		; 0C 03 0B ; Test and set bits $0B03.w [Reads: Accumulator] [Flags: Z]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $070400.l		; 22 00 04 07 ; Jump to subroutine long $070400.l [Writes: Stack Pointer] [Flow: call]
	tsb $170B.w		; 0C 0B 17 ; Test and set bits $170B.w [Reads: Accumulator] [Flags: Z]
	ora [$25.b],Y		; 17 25 ; OR accumulator with memory (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$F0E8.w		; E0 E8 F0 ; Compare #$F0E8.w with X register [Reads: X Index] [Flags: ZNC]
	eor $F4.b,S		; 43 F4 ; Exclusive OR accumulator with stack relative $F4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $F00400.l		; 22 00 04 F0 ; Jump to subroutine long $F00400.l [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($29FC.w,X)		; FC FC 29 ; Jump to subroutine indirect indexed ($29FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $43		; 42 43 ; Reserved instruction
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $42.b		; 02 42 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $4381.w,X		; BD 81 43 ; Load $4381.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	eor $32.b,S		; 43 32 ; Exclusive OR accumulator with stack relative $32.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	eor $74.b,S		; 43 74 ; Exclusive OR accumulator with stack relative $74.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $09		; 30 09 ; Branch if minus to $30, $09 [Flow: branch]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $2E2C.w		; 2C 2C 2E ; Test bits $2E2C.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	rol $4C2C.w		; 2E 2C 4C ; Rotate left $4C2C.w [Flags: ZNC]
	jmp $832C.w		; 4C 2C 83 ; Jump to $832C.w [Flow: jump]
	lsr $03.b		; 46 03 ; Logical shift right $03.b [Reads: Direct Page] [Flags: ZNC]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF2200.l		; 22 00 22 FF ; Jump to subroutine long $FF2200.l [Writes: Stack Pointer] [Flow: call]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $30.b,S		; 23 30 ; AND accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $F900FF.l,X		; FF FF 00 F9 ; Subtract with carry (long,X) $F900FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: ZN]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $0C7FBF.l,X		; DF BF 7F 0C ; Compare accumulator (long,X) $0C7FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $C30C00.l		; 22 00 0C C3 ; Jump to subroutine long $C30C00.l [Writes: Stack Pointer] [Flow: call]
	and $5DA2.w,X		; 3D A2 5D ; AND accumulator with memory $5DA2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($3734.w,X)		; FC 34 37 ; Jump to subroutine indirect indexed ($3734.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $BF0600.l		; 22 00 06 BF ; Jump to subroutine long $BF0600.l [Writes: Stack Pointer] [Flow: call]
	adc $94D77F.l,X		; 7F 7F D7 94 ; Add long $94D77F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	wai		; CB ; Wait for interrupt
	and [$2A.b],Y		; 37 2A ; AND accumulator with memory (long indexed) [$2A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $6B.b,X		; 35 6B ; Logical AND $6B.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $3E.b,X		; 35 3E ; Logical AND $3E.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $9E8707.l,X		; 3F 07 87 9E ; AND accumulator with memory (long,X) $9E8707.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	cmp $3F3F6F.l		; CF 6F 3F 3F ; Compare accumulator (long) $3F3F6F.l [Reads: Accumulator] [Flags: ZNC]
	sta $AB.b,S		; 83 AB ; Store accumulator (stack relative) $AB.b,S [Reads: Accumulator, Stack Pointer]
	tsb $2B.b		; 04 2B ; Test and set bits $2B.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($01.b),Y		; 31 01 ; AND accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($6F.b,X)		; 01 6F ; Logical OR ($6F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $3F183F.l,X		; 3F 3F 18 3F ; AND accumulator with memory (long,X) $3F183F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $6CFF.w		; 0E FF 6C ; Arithmetic shift left $6CFF.w [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $30, $1D		; 30 1D ; Branch if minus to $30, $1D [Flow: branch]
	trb $FF.b		; 14 FF ; Test and reset bits $FF.b [Reads: Accumulator] [Flags: Z]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $93713D.l,X		; 3F 3D 71 93 ; AND accumulator with memory (long,X) $93713D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $7EFFEB.l		; CF EB FF 7E ; Compare accumulator (long) $7EFFEB.l [Reads: Accumulator] [Flags: ZNC]
	ora $7F077F.l		; 0F 7F 07 7F ; OR accumulator with memory (long) $7F077F.l [Writes: Accumulator] [Flags: ZN]
	ora ($7F.b),Y		; 11 7F ; OR accumulator with memory ($7F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0377.w		; 0C 77 03 ; Test and set bits $0377.w [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	ora $37.b,S		; 03 37 ; OR accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $7C736F.l,X		; 5F 6F 73 7C ; Exclusive OR accumulator with memory (long,X) $7C736F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $0F38.w,X		; 3C 38 0F ; Test bits $0F38.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pea $C848.w		; F4 48 C8 ; Push absolute address $C848.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $07.b		; 84 07 ; Store Y register to $07.b [Reads: Y Index]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($C8BC.w,X)		; FC BC C8 ; Jump to subroutine indirect indexed ($C8BC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $BF		; 80 BF ; Branch always to $80, $BF [Flow: branch]
	.db $70, $7F		; 70 7F ; Branch if overflow set to $70, $7F [Flow: branch]
	jsr $306F.w		; 20 6F 30 ; Jump to subroutine at $306F.w [Writes: Stack Pointer] [Flow: call]
	adc [$38.b],Y		; 77 38 ; Add with carry (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $07071F.l,X		; 1F 1F 07 07 ; Logical OR long $07071F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $BF0600.l		; 22 00 06 BF ; Jump to subroutine long $BF0600.l [Writes: Stack Pointer] [Flow: call]
	adc $38776F.l,X		; 7F 6F 77 38 ; Add long $38776F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $003807.l,X		; 1F 07 38 00 ; Logical OR long $003807.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $16,$0F		; 44 0F 16 ; Move block positive $16,$0F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $0B.b,S		; 43 0B ; Exclusive OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1716.w,X		; 1D 16 17 ; OR accumulator with memory $1716.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldy $F8.b,X		; B4 F8 ; Load Y register $F8.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	bit $F8.b,X		; 34 F8 ; Test bits $F8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	cpx #$22E0.w		; E0 E0 22 ; Compare #$22E0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($B4.b)		; D4 B4 ; Push effective indirect address ($B4.b) [Reads: Direct Page] [Writes: Stack Pointer]
	stz $E8.b,X		; 74 E8 ; Store zero to $E8.b,X [Reads: X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $3C.b		; 46 3C ; Logical shift right $3C.b [Reads: Direct Page] [Flags: ZNC]
	sbc [$04.b]		; E7 04 ; Subtract with carry (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C18.w,X		; 7E 18 3C ; Rotate right $3C18.w,X [Reads: X Index] [Flags: ZNC]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $BD2300.l		; 22 00 23 BD ; Jump to subroutine long $BD2300.l [Writes: Stack Pointer] [Flow: call]
	cpx #$5A21.w		; E0 21 5A ; Compare #$5A21.w with X register [Reads: X Index] [Flags: ZNC]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $D8		; 80 D8 ; Branch always to $80, $D8 [Flow: branch]
	cpy #$60E4.w		; C0 E4 60 ; Compare #$60E4.w with Y register [Reads: Y Index] [Flags: ZNC]
	stz $30.b,X		; 74 30 ; Store zero to $30.b,X [Reads: X Index]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $1E0C.w,X		; 1D 0C 1E ; OR accumulator with memory $1E0C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $030F.w		; 0E 0F 03 ; Arithmetic shift left $030F.w [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	stz $264C.w		; 9C 4C 26 ; Store zero to $264C.w
	ora ($11.b,S),Y		; 13 11 ; OR accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0004.w		; 0C 04 00 ; Test and set bits $0004.w [Reads: Accumulator] [Flags: Z]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	brk $9A.b		; 00 9A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $66.b,S		; 43 66 ; Exclusive OR accumulator with stack relative $66.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $0D.b		; 24 0D ; Test bits $0D.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	eor $5E18.w,Y		; 59 18 5E ; Exclusive OR accumulator with memory $5E18.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $5AE6.w,X		; 7E E6 5A ; Rotate right $5AE6.w,X [Reads: X Index] [Flags: ZNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	adc [$7E.b]		; 67 7E ; Add with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsr $4683.w		; 20 83 46 ; Jump to subroutine at $4683.w [Writes: Stack Pointer] [Flow: call]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $62, $3C, $76		; 62 3C 76 ; Push effective relative address $62, $3C, $76 [Writes: Stack Pointer]
	bit $183C.w,X		; 3C 3C 18 ; Test bits $183C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: ZNC]
	bit $7E7E.w,X		; 3C 7E 7E ; Test bits $7E7E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $0018.w,X		; 3C 18 00 ; Test bits $0018.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $130023.l,X		; FF 23 00 13 ; Subtract with carry (long,X) $130023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0B3F0C.l		; 2F 0C 3F 0B ; AND accumulator with memory (long) $0B3F0C.l [Writes: Accumulator] [Flags: ZN]
	lsr $5F23.w,X		; 5E 23 5F ; Logical shift right $5F23.w,X [Reads: X Index] [Flags: ZNC]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3737.w		; 1C 37 37 ; Test and reset bits $3737.w [Reads: Accumulator] [Flags: Z]
	adc $00237B.l,X		; 7F 7B 23 00 ; Add long $00237B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F4		; 10 F4 ; Branch if plus to $10, $F4 [Flow: branch]
	.db $30, $FC		; 30 FC ; Branch if minus to $30, $FC [Flow: branch]
	.db $D0, $7A		; D0 7A ; Branch if not equal to $D0, $7A [Flow: branch]
	cpy $FA.b		; C4 FA ; Compare $FA.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	sty $0000.w		; 8C 00 00 ; Store Y register to $0000.w [Reads: Y Index]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	cpx $FEEC.w		; EC EC FE ; Compare $FEEC.w with X register [Reads: X Index] [Flags: ZNC]
	dec $0025.w,X		; DE 25 00 ; Decrement memory $0025.w,X [Reads: X Index] [Flags: ZN]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $031E0B.l,X		; 1F 0B 1E 03 ; Logical OR long $031E0B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $080400.l		; 22 00 04 08 ; Jump to subroutine long $080400.l [Writes: Stack Pointer] [Flow: call]
	trb $1737.w		; 1C 37 17 ; Test and reset bits $1737.w [Reads: Accumulator] [Flags: Z]
	ora $850025.l,X		; 1F 25 00 85 ; Logical OR long $850025.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $0300.w		; 1C 00 03 ; Test and reset bits $0300.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $D0, $78		; D0 78 ; Branch if not equal to $D0, $78 [Flow: branch]
	cpy #$0022.w		; C0 22 00 ; Compare #$0022.w with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx $F8E8.w		; EC E8 F8 ; Compare $F8E8.w with X register [Reads: X Index] [Flags: ZNC]
	bit #$0034.w		; 89 34 00 ; Test bits #$0034.w with accumulator [Reads: Accumulator] [Flags: Z]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $84.b		; 05 84 ; Logical OR $84.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $42, $00		; 42 00 ; Reserved instruction
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $4C89.w,X		; 1D 89 4C ; OR accumulator with memory $4C89.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $C0		; 70 C0 ; Branch if overflow set to $70, $C0 [Flow: branch]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldy #$5A84.w		; A0 84 5A ; Load #$5A84.w into Y register [Writes: Y Index] [Flags: ZN]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $D0		; F0 D0 ; Branch if equal to $F0, $D0 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	and $061700.l		; 2F 00 17 06 ; AND accumulator with memory (long) $061700.l [Writes: Accumulator] [Flags: ZN]
	ora $070F01.l		; 0F 01 0F 07 ; OR accumulator with memory (long) $070F01.l [Writes: Accumulator] [Flags: ZN]
	ora $1E0F.w,X		; 1D 0F 1E ; OR accumulator with memory $1E0F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$37.b]		; 07 37 ; OR accumulator with memory (long) [$37.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	ora $0F0F.w,Y		; 19 0F 0F ; OR accumulator with memory $0F0F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $233F1F.l,X		; 1F 1F 3F 23 ; Logical OR long $233F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$B080.w		; E0 80 B0 ; Compare #$B080.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$F0B8.w		; E0 B8 F0 ; Compare #$F0B8.w with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$D0EC.w		; E0 EC D0 ; Compare #$D0EC.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0023.w,X)		; FC 23 00 ; Jump to subroutine indirect indexed ($0023.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($03.b,S),Y		; 13 03 ; OR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($3D.b,X)		; 01 3D ; Logical OR ($3D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	adc $000036.l,X		; 7F 36 00 00 ; Add long $000036.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7F3F1F.l		; 0F 1F 3F 7F ; OR accumulator with memory (long) $7F3F1F.l [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $82.b		; 02 82 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	tsb $FDB0.w		; 0C B0 FD ; Test and set bits $FDB0.w [Reads: Accumulator] [Flags: Z]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc $0038.w		; 6D 38 00 ; Add $0038.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$FE.b]		; C7 FE ; Compare accumulator (long) [$FE.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	inc $FF7F.w,X		; FE 7F FF ; Increment memory $FF7F.w,X [Reads: X Index] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($C4.b,S),Y		; 93 C4 ; Store accumulator (stack relative indirect indexed) ($C4.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sep #$00		; E2 00 ; Set processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc $FA60.w,X		; FD 60 FA ; Subtract with carry $FA60.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $83		; 30 83 ; Branch if minus to $30, $83 [Flow: branch]
	sep #$00		; E2 00 ; Set processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora $7D.b		; 05 7D ; Logical OR $7D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 8
.INDEX 8
	sep #$FF		; E2 FF
	sta $EC.b		; 85 EC ; Store accumulator to $EC.b [Reads: Accumulator]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1700.w		; 0E 00 17 ; Arithmetic shift left $1700.w [Flags: ZNC]
	asl $2F.b		; 06 2F ; Arithmetic shift left $2F.b [Reads: Direct Page] [Flags: ZNC]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: ZNC]
	ora $37142F.l		; 0F 2F 14 37 ; OR accumulator with memory (long) $37142F.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F3E.w,Y		; 19 3E 1F ; OR accumulator with memory $1F3E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $252F3F.l,X		; 1F 3F 2F 25 ; Logical OR long $252F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cpx $22D8.w		; EC D8 22 ; Compare $22D8.w with X register [Reads: X Index] [Flags: ZNC]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($01F4.w,X)		; FC F4 01 ; Jump to subroutine indirect indexed ($01F4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1B3F.w		; 0D 3F 1B ; Logical OR $1B3F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $377E13.l,X		; 3F 13 7E 37 ; AND accumulator with memory (long,X) $377E13.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp ($00.b)		; D2 00 ; Compare accumulator (indirect) ($00.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	ora ($3B.b)		; 12 3B ; OR accumulator with memory (indirect) ($3B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc [$C0.b],Y		; 77 C0 ; Add with carry (long indexed) [$C0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$B0.b		; C0 B0 ; Compare #$B0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $EC		; 90 EC ; Branch if carry clear to $90, $EC [Flow: branch]
	.db $B0, $C0		; B0 C0 ; Branch if carry set to $B0, $C0 [Flow: branch]
	jsl $A010E0.l		; 22 E0 10 A0 ; Jump to subroutine long $A010E0.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($6DAF.w,X)		; FC AF 6D ; Jump to subroutine indirect indexed ($6DAF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp [$43.b],Y		; D7 43 ; Compare accumulator (long indexed) [$43.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	lda $02AE05.l		; AF 05 AE 02 ; Load long $02AE05.l into accumulator [Writes: Accumulator] [Flags: ZN]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FD1400.l		; 22 00 14 FD ; Jump to subroutine long $FD1400.l [Writes: Stack Pointer] [Flow: call]
	sbc $4FEDE9.l,X		; FF E9 ED 4F ; Subtract with carry (long,X) $4FEDE9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sbc $B6.b,X		; F5 B6 ; Subtract $B6.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
.ACCU 16
.INDEX 16
	rep #$F5		; C2 F5
	ldy #$4075.w		; A0 75 40 ; Load #$4075.w into Y register [Writes: Y Index] [Flags: ZN]
	cmp ($00.b)		; D2 00 ; Compare accumulator (indirect) ($00.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	jsr $0022.w		; 20 22 00 ; Jump to subroutine at $0022.w [Writes: Stack Pointer] [Flow: call]
	ora $FFBF.w,Y		; 19 BF FF ; OR accumulator with memory $FFBF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta [$B7.b],Y		; 97 B7 ; Store accumulator (long indexed) [$B7.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sbc ($50.b)		; F2 50 ; Subtract with carry (indirect) ($50.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsr $3F00.w		; 20 00 3F ; Jump to subroutine at $3F00.w [Writes: Stack Pointer] [Flow: call]
	ora ($27.b),Y		; 11 27 ; OR accumulator with memory ($27.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $1B27.w,Y		; 19 27 1B ; OR accumulator with memory $1B27.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($1D.b,S),Y		; 33 1D ; AND accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $1C.b,X		; 36 1C ; Rotate left $1C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $081E0C.l,X		; 1F 0C 1E 08 ; Logical OR long $081E0C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $3B00.w		; 0C 00 3B ; Test and set bits $3B00.w [Reads: Accumulator] [Flags: Z]
	and $3F22.w,X		; 3D 22 3F ; AND accumulator with memory $3F22.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	asl $FC0C.w,X		; 1E 0C FC ; Arithmetic shift left $FC0C.w,X [Reads: X Index] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpx $98.b		; E4 98 ; Compare $98.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx $D8.b		; E4 D8 ; Compare $D8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy $6CB8.w		; CC B8 6C ; Compare $6CB8.w with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $FC22.w,X		; BC 22 FC ; Load Y register $FC22.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	ora $3078F8.l		; 0F F8 78 30 ; OR accumulator with memory (long) $3078F8.l [Writes: Accumulator] [Flags: ZN]
	and [$1B.b],Y		; 37 1B ; AND accumulator with memory (long indexed) [$1B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($1D.b,S),Y		; 33 1D ; AND accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $1D0E.w,Y		; 19 0E 1D ; OR accumulator with memory $1D0E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0C1F.w		; 0E 1F 0C ; Arithmetic shift left $0C1F.w [Flags: ZNC]
	asl $0404.w		; 0E 04 04 ; Arithmetic shift left $0404.w [Flags: ZNC]
	jsl $3F0100.l		; 22 00 01 3F ; Jump to subroutine long $3F0100.l [Writes: Stack Pointer] [Flow: call]
	and $0F1F22.l,X		; 3F 22 1F 0F ; AND accumulator with memory (long,X) $0F1F22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0004.w		; 0E 04 00 ; Arithmetic shift left $0004.w [Flags: ZNC]
	cpx $CCD8.w		; EC D8 CC ; Compare $CCD8.w with X register [Reads: X Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $B8		; 70 B8 ; Branch if overflow set to $70, $B8 [Flow: branch]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	jsr $2220.w		; 20 20 22 ; Jump to subroutine at $2220.w [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($22FC.w,X)		; FC FC 22 ; Jump to subroutine indirect indexed ($22FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$703D.w		; E0 3D 70 ; Compare #$703D.w with X register [Reads: X Index] [Flags: ZNC]
	jsr $3B00.w		; 20 00 3B ; Jump to subroutine at $3B00.w [Writes: Stack Pointer] [Flow: call]
	tsb $0737.w		; 0C 37 07 ; Test and set bits $0737.w [Reads: Accumulator] [Flags: Z]
	ora $091F03.l,X		; 1F 03 1F 09 ; Logical OR long $091F03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $030705.l		; 0F 05 07 03 ; OR accumulator with memory (long) $030705.l [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and [$3F.b],Y		; 37 3F ; AND accumulator with memory (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $070D1B.l,X		; 1F 1B 0D 07 ; Logical OR long $070D1B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp.w [$EC30]		; DC 30 EC ; Jump long indirect [$EC30] [Flow: jump]
	cpx #$C078.w		; E0 78 C0 ; Compare #$C078.w with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $90, $F0		; 90 F0 ; Branch if carry clear to $90, $F0 [Flow: branch]
	ldy #$C0E0.w		; A0 E0 C0 ; Load #$C0E0.w into Y register [Writes: Y Index] [Flags: ZN]
	cpy #$8080.w		; C0 80 80 ; Compare #$8080.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($D8F8.w,X)		; FC F8 D8 ; Jump to subroutine indirect indexed ($D8F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $B0, $E0		; B0 E0 ; Branch if carry set to $B0, $E0 [Flow: branch]
	cpy #$7F80.w		; C0 80 7F ; Compare #$7F80.w with Y register [Reads: Y Index] [Flags: ZNC]
	and [$FD.b]		; 27 FD ; AND accumulator with memory (long) [$FD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $7F7EF9.l		; 6F F9 7E 7F ; Add with carry (long) $7F7EF9.l [Writes: Accumulator] [Flags: ZVNC]
	ora $01010F.l		; 0F 0F 01 01 ; OR accumulator with memory (long) $01010F.l [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($77.b)		; 12 77 ; OR accumulator with memory (indirect) ($77.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $0F7FFF.l		; EF FF 7F 0F ; Subtract with carry (long) $0F7FFF.l [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7CDE.w,X		; 3C DE 7C ; Test bits $7CDE.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	stz $CCFC.w,X		; 9E FC CC ; Store zero to $CCFC.w,X [Reads: X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	jsl $FC04FE.l		; 22 FE 04 FC ; Jump to subroutine long $FC04FE.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $260E.w		; 0E 0E 26 ; Arithmetic shift left $260E.w [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $02		; 50 02 ; Branch if overflow clear to $50, $02 [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF0800.l		; 22 00 08 FF ; Jump to subroutine long $FF0800.l [Writes: Stack Pointer] [Flow: call]
	bit $7EDF.w,X		; 3C DF 7E ; Test bits $7EDF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	stz $FCFC.w,X		; 9E FC FC ; Store zero to $FCFC.w,X [Reads: X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	sbc $38FCFE.l,X		; FF FE FC 38 ; Subtract with carry (long,X) $38FCFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $2E0100.l		; 22 00 01 2E ; Jump to subroutine long $2E0100.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	mvp $09,$3F		; 44 3F 09 ; Move block positive $09,$3F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $15.b		; 05 15 ; Logical OR $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $010B0B.l,X		; 1F 0B 0B 01 ; Logical OR long $010B0B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $2D393B.l,X		; 3F 3B 39 2D ; AND accumulator with memory (long,X) $2D393B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	stz $D0.b,X		; 74 D0 ; Store zero to $D0.b,X [Reads: X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $90.b,S		; 43 90 ; Exclusive OR accumulator with stack relative $90.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr ($A81D.w,X)		; FC 1D A8 ; Jump to subroutine indirect indexed ($A81D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $D0, $F8		; D0 F8 ; Branch if not equal to $D0, $F8 [Flow: branch]
	.db $B0, $D0		; B0 D0 ; Branch if carry set to $B0, $D0 [Flow: branch]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	stz $E8BC.w		; 9C BC E8 ; Store zero to $E8BC.w
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	jmp ($3F3F.w,X)		; 7C 3F 3F ; Jump indirect indexed to ($3F3F.w,X) [Reads: X Index] [Flow: jump]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $7F0200.l		; 22 00 02 7F ; Jump to subroutine long $7F0200.l [Writes: Stack Pointer] [Flow: call]
	and $24830F.l,X		; 3F 0F 83 24 ; AND accumulator with memory (long,X) $24830F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $FC.b		; E6 FC ; Increment $FC.b [Reads: Direct Page] [Flags: ZN]
	sbc $DAEFDA.l,X		; FF DA EF DA ; Subtract with carry (long,X) $DAEFDA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FAB8.w,X		; DD B8 FA ; Compare accumulator $FAB8.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $74		; 10 74 ; Branch if plus to $10, $74 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($FC00.w,X)		; FC 00 FC ; Jump to subroutine indirect indexed ($FC00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FDFD.w,X		; FE FD FD ; Increment memory $FDFD.w,X [Reads: X Index] [Flags: ZN]
	sbc $FCFCFE.l,X		; FF FE FC FC ; Subtract with carry (long,X) $FCFCFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $50, $01		; 50 01 ; Branch if overflow clear to $50, $01 [Flow: branch]
	jsl $7C83E0.l		; 22 E0 83 7C ; Jump to subroutine long $7C83E0.l [Writes: Stack Pointer] [Flow: call]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0F1300.l		; 0F 00 13 0F ; OR accumulator with memory (long) $0F1300.l [Writes: Accumulator] [Flags: ZN]
	ora $030700.l		; 0F 00 07 03 ; OR accumulator with memory (long) $030700.l [Writes: Accumulator] [Flags: ZN]
	tsb $1E07.w		; 0C 07 1E ; Test and set bits $1E07.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and [$19.b],Y		; 37 19 ; AND accumulator with memory (long indexed) [$19.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$19.b]		; 27 19 ; AND accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $070F1F.l		; 0F 1F 0F 07 ; OR accumulator with memory (long) $070F1F.l [Writes: Accumulator] [Flags: ZN]
	ora $393B1F.l		; 0F 1F 3B 39 ; OR accumulator with memory (long) $393B1F.l [Writes: Accumulator] [Flags: ZN]
	sta $AA.b,S		; 83 AA ; Store accumulator (stack relative) $AA.b,S [Reads: Accumulator, Stack Pointer]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cpx $D47E.w		; EC 7E D4 ; Compare $D47E.w with X register [Reads: X Index] [Flags: ZNC]
	inc $E498.w		; EE 98 E4 ; Increment $E498.w [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	dec $039C.w,X		; DE 9C 03 ; Decrement memory $039C.w,X [Reads: X Index] [Flags: ZN]
	sta $65.b		; 85 65 ; Store accumulator to $65.b [Reads: Accumulator]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$2E.b]		; 07 2E ; OR accumulator with memory (long) [$2E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $2F1F27.l,X		; 1F 27 1F 2F ; Logical OR long $2F1F27.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0F1E.w,X		; 1E 1E 0F ; Arithmetic shift left $0F1E.w,X [Reads: X Index] [Flags: ZNC]
	sta $D2.b,S		; 83 D2 ; Store accumulator (stack relative) $D2.b,S [Reads: Accumulator, Stack Pointer]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $C01F14.l,X		; 3F 14 1F C0 ; AND accumulator with memory (long,X) $C01F14.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E070.w		; C0 70 E0 ; Compare #$E070.w with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx #$F874.w		; E0 74 F8 ; Compare #$F874.w with X register [Reads: X Index] [Flags: ZNC]
	cpx $F8.b		; E4 F8 ; Compare $F8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	pea $7878.w		; F4 78 78 ; Push absolute address $7878.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $B0, $C0		; B0 C0 ; Branch if carry set to $B0, $C0 [Flow: branch]
	cpx #$F8F0.w		; E0 F0 F8 ; Compare #$F8F0.w with X register [Reads: X Index] [Flags: ZNC]
	jsl $F818FC.l		; 22 FC 18 F8 ; Jump to subroutine long $F818FC.l [Writes: Stack Pointer] [Flow: call]
	asl $1F00.w		; 0E 00 1F ; Arithmetic shift left $1F00.w [Flags: ZNC]
	asl $1F3F.w		; 0E 3F 1F ; Arithmetic shift left $1F3F.w [Flags: ZNC]
	adc $63FE32.l,X		; 7F 32 FE 63 ; Add long $63FE32.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $7C67.w,X		; FE 67 7C ; Increment memory $7C67.w,X [Reads: X Index] [Flags: ZN]
	and $0E0F7E.l,X		; 3F 7E 0F 0E ; AND accumulator with memory (long,X) $0E0F7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $F37F3F.l,X		; 1F 3F 7F F3 ; Logical OR long $F37F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$7F.b]		; E7 7F ; Subtract with carry (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $430023.l,X		; 7F 23 00 43 ; Add long $430023.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	eor $40.b		; 45 40 ; Exclusive OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$0022.w		; C0 22 00 ; Compare #$0022.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	cpy #$070F.w		; C0 0F 07 ; Compare #$070F.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $7F193F.l		; 0F 3F 19 7F ; OR accumulator with memory (long) $7F193F.l [Writes: Accumulator] [Flags: ZN]
	and ($7F.b),Y		; 31 7F ; AND accumulator with memory ($7F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($3E.b,S),Y		; 33 3E ; AND accumulator (stack relative indirect indexed) ($3E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $83073F.l,X		; 1F 3F 07 83 ; Logical OR long $83073F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp ($00.b,S),Y		; D3 00 ; Compare accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	ora $79.b,S		; 03 79 ; OR accumulator with stack relative $79.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc ($3F.b,S),Y		; 73 3F ; Add with carry (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00AA83.l,X		; 3F 83 AA 00 ; AND accumulator with memory (long,X) $00AA83.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $05C0.w		; 20 C0 05 ; Jump to subroutine at $05C0.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpy #$E022.w		; C0 22 E0 ; Compare #$E022.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $C2.b,S		; 83 C2 ; Store accumulator (stack relative) $C2.b,S [Reads: Accumulator, Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	ora $0C3C03.l		; 0F 03 3C 0C ; OR accumulator with memory (long) $0C3C03.l [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($000C.w,X)		; FC 0C 00 ; Jump to subroutine indirect indexed ($000C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($57.b,S),Y		; 33 57 ; AND accumulator (stack relative indirect indexed) ($57.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda [$97.b]		; A7 97 ; Load accumulator (long) [$97.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta ($00.b,S),Y		; 93 00 ; Store accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$307C.w		; C0 7C 30 ; Compare #$307C.w with Y register [Reads: Y Index] [Flags: ZNC]
	inc $4F10.w,X		; FE 10 4F ; Increment memory $4F10.w,X [Reads: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $8C		; 30 8C ; Branch if minus to $30, $8C [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	lda $E9.b,X		; B5 E9 ; Load $E9.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $0025.w,Y		; F9 25 00 ; Subtract with carry $0025.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($60.b,X)		; 01 60 ; Logical OR ($60.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $60		; B0 60 ; Branch if carry set to $B0, $60 [Flow: branch]
	ora $F7.b,S		; 03 F7 ; OR accumulator with stack relative $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $002215.l,X		; 7F 15 22 00 ; Add long $002215.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $60.b		; 04 60 ; Test and set bits $60.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sbc [$7F.b],Y		; F7 7F ; Subtract with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0306.w		; 0D 06 03 ; Logical OR $0306.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $A8FE02.l		; EF 02 FE A8 ; Subtract with carry (long) $A8FE02.l [Writes: Accumulator] [Flags: ZVNC]
	jsl $060400.l		; 22 00 04 06 ; Jump to subroutine long $060400.l [Writes: Stack Pointer] [Flow: call]
	ora $FEEF0F.l		; 0F 0F EF FE ; OR accumulator with memory (long) $FEEF0F.l [Writes: Accumulator] [Flags: ZN]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($3F3F.w,X)		; 7C 3F 3F ; Jump indirect indexed to ($3F3F.w,X) [Reads: X Index] [Flow: jump]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $7F0200.l		; 22 00 02 7F ; Jump to subroutine long $7F0200.l [Writes: Stack Pointer] [Flow: call]
	and $032206.l,X		; 3F 06 22 03 ; AND accumulator with memory (long,X) $032206.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sty $E6.b		; 84 E6 ; Store Y register to $E6.b [Reads: Y Index]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($AAFF.w,X)		; 7C FF AA ; Jump indirect indexed to ($AAFF.w,X) [Reads: X Index] [Flow: jump]
	sbc $38DDDA.l		; EF DA DD 38 ; Subtract with carry (long) $38DDDA.l [Writes: Accumulator] [Flags: ZVNC]
	sta $02F2.w		; 8D F2 02 ; Store accumulator to $02F2.w [Reads: Accumulator]
	cpx #$2F53.w		; E0 53 2F ; Compare #$2F53.w with X register [Reads: X Index] [Flags: ZNC]
	ora $2E.b,X		; 15 2E ; OR accumulator with memory $2E.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $000F01.l,X		; 1F 01 0F 00 ; Logical OR long $000F01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0D02.w		; 0E 02 0D ; Arithmetic shift left $0D02.w [Flags: ZNC]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0D0B1B.l,X		; 3F 1B 0B 0D ; AND accumulator with memory (long,X) $0D0B1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	pea $74A8.w		; F4 A8 74 ; Push absolute address $74A8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $B0, $20		; B0 20 ; Branch if carry set to $B0, $20 [Flow: branch]
	ldy #$C000.w		; A0 00 C0 ; Load #$C000.w into Y register [Writes: Y Index] [Flags: ZN]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($D0D8.w,X)		; FC D8 D0 ; Jump to subroutine indirect indexed ($D0D8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $B0, $D0		; B0 D0 ; Branch if carry set to $B0, $D0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$071C.w		; C0 1C 07 ; Compare #$071C.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora $060F0F.l,X		; 1F 0F 0F 06 ; Logical OR long $060F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0F1C01.l		; 0F 01 1C 0F ; OR accumulator with memory (long) $0F1C01.l [Writes: Accumulator] [Flags: ZN]
	and [$1C.b],Y		; 37 1C ; AND accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0F0F.w,Y		; 19 0F 0F ; OR accumulator with memory $0F0F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F0F0F.l,X		; 1F 0F 0F 1F ; Logical OR long $1F0F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $780F1F.l,X		; 3F 1F 0F 78 ; AND accumulator with memory (long,X) $780F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $D0, $70		; D0 70 ; Branch if not equal to $D0, $70 [Flow: branch]
	.db $80, $B8		; 80 B8 ; Branch always to $80, $B8 [Flow: branch]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	.db $F0, $70		; F0 70 ; Branch if equal to $F0, $70 [Flow: branch]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: ZNC]
	sta $34.b,S		; 83 34 ; Store accumulator (stack relative) $34.b,S [Reads: Accumulator, Stack Pointer]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $83		; F0 83 ; Branch if equal to $F0, $83 [Flow: branch]
	and $E002.w,X		; 3D 02 E0 ; AND accumulator with memory $E002.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $0E.b,S		; 23 0E ; AND accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $1E7F1C.l,X		; 7F 1C 7F 1E ; Add long $1E7F1C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $0F7E07.l		; 4F 07 7E 0F ; Exclusive OR accumulator with memory (long) $0F7E07.l [Writes: Accumulator] [Flags: ZN]
	and $021B03.l,X		; 3F 03 1B 02 ; AND accumulator with memory (long,X) $021B03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $5F00.w		; 0E 00 5F ; Arithmetic shift left $5F00.w [Flags: ZNC]
	adc $777F4F.l,X		; 7F 4F 7F 77 ; Add long $777F4F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$1D.b]		; 27 1D ; AND accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $00F0.w		; 0E F0 00 ; Arithmetic shift left $00F0.w [Flags: ZNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $6D		; F0 6D ; Branch if equal to $F0, $6D [Flow: branch]
	sbc ($F5.b)		; F2 F5 ; Subtract with carry (indirect) ($F5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sta $220E0E.l,X		; 9F 0E 0E 22 ; Store accumulator (long,X) $220E0E.l,X [Reads: Accumulator, X Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($F0.b)		; 72 F0 ; Add with carry (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $FA		; F0 FA ; Branch if equal to $F0, $FA [Flow: branch]
	sbc $0E9FFF.l,X		; FF FF 9F 0E ; Subtract with carry (long,X) $0E9FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0E3F.w		; 0E 3F 0E ; Arithmetic shift left $0E3F.w [Flags: ZNC]
	and [$03.b]		; 27 03 ; AND accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $1F07.w,X		; 3E 07 1F ; Rotate left $1F07.w,X [Reads: X Index] [Flags: ZNC]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3B3F27.l,X		; 1F 27 3F 3B ; Logical OR long $3B3F27.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$B8.b]		; 07 B8 ; OR accumulator with memory (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	ror $DE3C.w		; 6E 3C DE ; Rotate right $DE3C.w [Flags: ZNC]
	stz $9F.b,X		; 74 9F ; Store zero to $9F.b,X [Reads: X Index]
	sbc ($35.b)		; F2 35 ; Subtract with carry (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
.ACCU 8
	sep #$E2		; E2 E2
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jmp ($FE7E.w,X)		; 7C 7E FE ; Jump indirect indexed to ($FE7E.w,X) [Reads: X Index] [Flow: jump]
	sbc $C0E2F7.l,X		; FF F7 E2 C0 ; Subtract with carry (long,X) $C0E2F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $35771F.l,X		; FF 1F 77 35 ; Subtract with carry (long,X) $35771F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	.db $10, $3B		; 10 3B ; Branch if plus to $10, $3B [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $011F08.l,X		; 1F 08 1F 01 ; Logical OR long $011F08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000800.l,X		; 1F 00 08 00 ; Logical OR long $000800.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldy #$2F4A.w		; A0 4A 2F ; Load #$2F4A.w into Y register [Writes: Y Index] [Flags: ZN]
	bit $10.b		; 24 10 ; Test bits $10.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $10, $17		; 10 17 ; Branch if plus to $10, $17 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $A4E618.l,X		; 1F 18 E6 A4 ; Logical OR long $A4E618.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	mvn $9C,$00		; 54 00 9C ; Move block negative $9C,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsr ($0864.w,X)		; FC 64 08 ; Jump to subroutine indirect indexed ($0864.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $6E		; 10 6E ; Branch if plus to $10, $6E [Flow: branch]
	and $3B6E.w,X		; 3D 6E 3B ; AND accumulator with memory $3B6E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $3817.w,X		; 3E 17 38 ; Rotate left $3817.w,X [Reads: X Index] [Flags: ZNC]
	ora $07070F.l		; 0F 0F 07 07 ; OR accumulator with memory (long) $07070F.l [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $10, $7F		; 10 7F ; Branch if plus to $10, $7F [Flow: branch]
	adc $0F383F.l,X		; 7F 3F 38 0F ; Add long $0F383F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $DC76.w,X		; BC 76 DC ; Load Y register $DC76.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	bit $F8E8.w,X		; 3C E8 F8 ; Test bits $F8E8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx #$26E0.w		; E0 E0 26 ; Compare #$26E0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $3CFE.w,X		; FE FE 3C ; Increment memory $3CFE.w,X [Reads: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$0022.w		; E0 22 00 ; Compare #$0022.w with X register [Reads: X Index] [Flags: ZNC]
	sbc $000201.l,X		; FF 01 02 00 ; Subtract with carry (long,X) $000201.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $05.b,S		; 43 05 ; Exclusive OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C06.w		; 0D 06 0C ; Logical OR $0C06.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $12.b,S		; 03 12 ; OR accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $1F010F.l		; 22 0F 01 1F ; Jump to subroutine long $1F010F.l [Writes: Stack Pointer] [Flow: call]
	ora ($23.b,S),Y		; 13 23 ; OR accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F9C07.l		; 0F 07 9C 0F ; OR accumulator with memory (long) $0F9C07.l [Writes: Accumulator] [Flags: ZN]
	sbc $3B0E.w,Y		; F9 0E 3B ; Subtract with carry $3B0E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $EC7B.w		; EC 7B EC ; Compare $EC7B.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $FCFCFE.l,X		; 9F FE FC FC ; Store accumulator (long,X) $FCFCFE.l,X [Reads: Accumulator, X Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $E0.b,X		; 15 E0 ; OR accumulator with memory $E0.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F039.w		; E0 39 F0 ; Compare #$F039.w with X register [Reads: X Index] [Flags: ZNC]
	sta $37DC70.l,X		; 9F 70 DC 37 ; Store accumulator (long,X) $37DC70.l,X [Reads: Accumulator, X Index]
	dec $0037.w,X		; DE 37 00 ; Decrement memory $0037.w,X [Reads: X Index] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F9		; F0 F9 ; Branch if equal to $F0, $F9 [Flow: branch]
	adc $403F3F.l,X		; 7F 3F 3F 40 ; Add long $403F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$0240.w		; A0 40 02 ; Load #$0240.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $B0, $60		; B0 60 ; Branch if carry set to $B0, $60 [Flow: branch]
	.db $30, $44		; 30 44 ; Branch if minus to $30, $44 [Flow: branch]
	cpx #$0470.w		; E0 70 04 ; Compare #$0470.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$24E0.w		; E0 E0 24 ; Compare #$24E0.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $6022.w		; 20 22 60 ; Jump to subroutine at $6022.w [Writes: Stack Pointer] [Flow: call]
	asl $1100.w		; 0E 00 11 ; Arithmetic shift left $1100.w [Flags: ZNC]
	.db $90, $B3		; 90 B3 ; Branch if carry clear to $90, $B3 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sbc $81FFA1.l,X		; FF A1 FF 81 ; Subtract with carry (long,X) $81FFA1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $606000.l,X		; FF 00 60 60 ; Subtract with carry (long,X) $606000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($B3.b),Y		; 11 B3 ; OR accumulator with memory ($B3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $6083FF.l		; 22 FF 83 60 ; Jump to subroutine long $6083FF.l [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$20.b],Y		; 37 20 ; AND accumulator with memory (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$C040.w		; E0 40 C0 ; Compare #$C040.w with X register [Reads: X Index] [Flags: ZNC]
	cpy $CC.b		; C4 CC ; Compare $CC.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	sty $008C.w		; 8C 8C 00 ; Store Y register to $008C.w [Reads: Y Index]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$CCC0.w		; E0 C0 CC ; Compare #$CCC0.w with X register [Reads: X Index] [Flags: ZNC]
	sty $3701.w		; 8C 01 37 ; Store Y register to $3701.w [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $44.b		; 64 44 ; Store zero to $44.b
	adc $3F20.w		; 6D 20 3F ; Add $3F20.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($63.b,X)		; 01 63 ; Logical OR ($63.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $3F3F.w		; 6D 3F 3F ; Add $3F3F.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $63		; 30 63 ; Branch if minus to $30, $63 [Flow: branch]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	cpx #$8080.w		; E0 80 80 ; Compare #$8080.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $080C.w		; 0C 0C 08 ; Test and set bits $080C.w [Reads: Accumulator] [Flags: Z]
	tsb $8483.w		; 0C 83 84 ; Test and set bits $8483.w [Reads: Accumulator] [Flags: Z]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpx #$0C80.w		; E0 80 0C ; Compare #$0C80.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $3701.w		; 0C 01 37 ; Test and set bits $3701.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $0C.b,S		; 43 0C ; Exclusive OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$0326.w		; E0 26 03 ; Compare #$0326.w with X register [Reads: X Index] [Flags: ZNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1A0C.w		; 0C 0C 1A ; Test and set bits $1A0C.w [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $82.b		; 02 82 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $400C.w		; 0C 0C 40 ; Test and set bits $400C.w [Reads: Accumulator] [Flags: Z]
	cpy #$9B80.w		; C0 80 9B ; Compare #$9B80.w with Y register [Reads: Y Index] [Flags: ZNC]
	eor #$DB.b		; 49 DB ; Exclusive OR #$DB.b with accumulator [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $82, $40, $88		; 82 40 88 ; Branch always long to $82, $40, $88 [Flow: branch]
	tsb $9BC0.w		; 0C C0 9B ; Test and set bits $9BC0.w [Reads: Accumulator] [Flags: Z]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	trb $2200.w		; 1C 00 22 ; Test and reset bits $2200.w [Reads: Accumulator] [Flags: Z]
	trb $4D43.w		; 1C 43 4D ; Test and reset bits $4D43.w [Reads: Accumulator] [Flags: Z]
	and ($0C.b)		; 32 0C ; AND accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($3E.b,X)		; 41 3E ; Exclusive OR accumulator with memory ($3E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $003E1C.l		; 22 1C 3E 00 ; Jump to subroutine long $003E1C.l [Writes: Stack Pointer] [Flow: call]
	jsl $3E1C00.l		; 22 00 1C 3E ; Jump to subroutine long $3E1C00.l [Writes: Stack Pointer] [Flow: call]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $033E22.l,X		; 7F 22 3E 03 ; Add long $033E22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $2E00.w		; 1C 00 2E ; Test and reset bits $2E00.w [Reads: Accumulator] [Flags: Z]
	trb $5343.w		; 1C 43 53 ; Test and reset bits $5343.w [Reads: Accumulator] [Flags: Z]
	rol $4D00.w,X		; 3E 00 4D ; Rotate left $4D00.w,X [Reads: X Index] [Flags: ZNC]
	sty $F9.b		; 84 F9 ; Store Y register to $F9.b [Reads: Y Index]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $1C1C.w,X		; 3E 1C 1C ; Rotate left $1C1C.w,X [Reads: X Index] [Flags: ZNC]
	rol $5F5F.w		; 2E 5F 5F ; Rotate left $5F5F.w [Flags: ZNC]
	eor $3E22.w		; 4D 22 3E ; Exclusive OR $3E22.w with accumulator [Writes: Accumulator] [Flags: ZN]
	jsl $010000.l		; 22 00 00 01 ; Jump to subroutine long $010000.l [Writes: Stack Pointer] [Flow: call]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($45.b,X)		; 01 45 ; Logical OR ($45.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	trb $03.b		; 14 03 ; Test and reset bits $03.b [Reads: Accumulator] [Flags: Z]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$23.b],Y		; 17 23 ; OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	eor $50.b		; 45 50 ; Exclusive OR $50.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$E4D0.w		; C0 D0 E4 ; Compare #$E4D0.w with Y register [Reads: Y Index] [Flags: ZNC]
	and $5FE000.l		; 2F 00 E0 5F ; AND accumulator with memory (long) $5FE000.l [Writes: Accumulator] [Flags: ZN]
	ora $003F01.l,X		; 1F 01 3F 00 ; Logical OR long $003F01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $20BF00.l,X		; 5F 00 BF 20 ; Exclusive OR accumulator with memory (long,X) $20BF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $ED00.w		; AD 00 ED ; Load $ED00.w into accumulator [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $6D00.w		; ED 00 6D ; Subtract $6D00.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($73.b,S),Y		; 33 73 ; AND accumulator (stack relative indirect indexed) ($73.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp ($F3.b,S),Y		; D3 F3 ; Compare accumulator (stack relative indirect indexed) ($F3.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	lda ($F3.b,S),Y		; B3 F3 ; Load accumulator (stack relative indirect indexed) ($F3.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($F9.b,S),Y		; 73 F9 ; Add with carry (stack relative indirect indexed) ($F9.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $DFFC.w		; EE FC DF ; Increment $DFFC.w [Flags: ZN]
	sbc $7EDF3E.l,X		; FF 3E DF 7E ; Subtract with carry (long,X) $7EDF3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $D7F6.w,X		; DE F6 D7 ; Decrement memory $D7F6.w,X [Reads: X Index] [Flags: ZN]
	sbc ($8B.b,S),Y		; F3 8B ; Subtract with carry (stack relative indirect indexed) ($8B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $FE3F.w		; CE 3F FE ; Decrement $FE3F.w [Flags: ZN]
	sbc $F7FEFE.l,X		; FF FE FE F7 ; Subtract with carry (long,X) $F7FEFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $779FFF.l,X		; FF FF 9F 77 ; Subtract with carry (long,X) $779FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $7CFFFB.l,X		; 3F FB FF 7C ; AND accumulator with memory (long,X) $7CFFFB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ror $6F7B.w,X		; 7E 7B 6F ; Rotate right $6F7B.w,X [Reads: X Index] [Flags: ZNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cmp $70C0DF.l		; CF DF C0 70 ; Compare accumulator (long) $70C0DF.l [Reads: Accumulator] [Flags: ZNC]
	cpy #$FF7F.w		; C0 7F FF ; Compare #$FF7F.w with Y register [Reads: Y Index] [Flags: ZNC]
	adc $DFEF7F.l,X		; 7F 7F EF DF ; Add long $DFEF7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C0F0FF.l,X		; FF FF F0 C0 ; Subtract with carry (long,X) $C0F0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F200.w,X)		; FC 00 F2 ; Jump to subroutine indirect indexed ($F200.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $AD		; 30 AD ; Branch if minus to $30, $AD [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $60.b		; A5 60 ; Load $60.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $04FB3E.l		; CF 3E FB 04 ; Compare accumulator (long) $04FB3E.l [Reads: Accumulator] [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	dec $9B93.w		; CE 93 9B ; Decrement $9B93.w [Flags: ZN]
	cmp ($FB.b,X)		; C1 FB ; Compare accumulator ($FB.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	inc $4343.w,X		; FE 43 43 ; Increment memory $4343.w,X [Reads: X Index] [Flags: ZN]
	cmp $204FE0.l		; CF E0 4F 20 ; Compare accumulator (long) $204FE0.l [Reads: Accumulator] [Flags: ZNC]
	and $3EFF48.l		; 2F 48 FF 3E ; AND accumulator with memory (long) $3EFF48.l [Writes: Accumulator] [Flags: ZN]
	sbc $0B3F0D.l,X		; FF 0D 3F 0B ; Subtract with carry (long,X) $0B3F0D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $CF9D05.l,X		; 7F 05 9D CF ; Add long $CF9D05.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FFFF2F.l		; CF 2F FF FF ; Compare accumulator (long) $FFFF2F.l [Reads: Accumulator] [Flags: ZNC]
	and $929D7F.l,X		; 3F 7F 9D 92 ; AND accumulator with memory (long,X) $929D7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FC24.w,X		; FE 24 FC ; Increment memory $FC24.w,X [Reads: X Index] [Flags: ZN]
	stz $FE.b,X		; 74 FE ; Store zero to $FE.b,X [Reads: X Index]
	.db $42, $FE		; 42 FE ; Reserved instruction
	sty $98FC.w		; 8C FC 98 ; Store Y register to $98FC.w [Reads: Y Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $80, $AC		; 80 AC ; Branch always to $80, $AC [Flow: branch]
	bit $FE7F.w,X		; 3C 7F FE ; Test bits $FE7F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($ACF8.w,X)		; FC F8 AC ; Jump to subroutine indirect indexed ($ACF8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $100B08.l,X		; 7F 08 0B 10 ; Add long $100B08.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $013F03.l,X		; 3F 03 3F 01 ; AND accumulator with memory (long,X) $013F03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $001F03.l		; 0F 03 1F 00 ; OR accumulator with memory (long) $001F03.l [Writes: Accumulator] [Flags: ZN]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1F0F3F.l,X		; 3F 3F 0F 1F ; AND accumulator with memory (long,X) $1F0F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FC34.w,X		; FE 34 FC ; Increment memory $FC34.w,X [Reads: X Index] [Flags: ZN]
	bit $FE.b,X		; 34 FE ; Test bits $FE.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ldx #$C2FE.w		; A2 FE C2 ; Load #$C2FE.w into X register [Writes: X Index] [Flags: ZN]
	dec $9C84.w		; CE 84 9C ; Decrement $9C84.w [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $08.b,S		; 83 08 ; Store accumulator (stack relative) $08.b,S [Reads: Accumulator, Stack Pointer]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $009C.w		; CE 9C 00 ; Decrement $009C.w [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $1A.b		; 04 1A ; Test and set bits $1A.b [Reads: Accumulator] [Flags: Z]
	ora $0C01.w,Y		; 19 01 0C ; OR accumulator with memory $0C01.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($92.b)		; 92 92 ; Store accumulator (indirect) ($92.b) [Reads: Accumulator, Direct Page]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc ($E7.b,X)		; 61 E7 ; Add with carry ($E7.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $42, $CE		; 42 CE ; Reserved instruction
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $92.b		; 06 92 ; Arithmetic shift left $92.b [Reads: Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$E7.b]		; 07 E7 ; OR accumulator with memory (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $0080.w		; CE 80 00 ; Decrement $0080.w [Flags: ZN]
	mvp $14,$00		; 44 00 14 ; Move block positive $14,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($3E.b,S),Y		; 13 3E ; OR accumulator (stack relative indirect indexed) ($3E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $7F08.w,X		; 5D 08 7F ; Exclusive OR accumulator with memory $7F08.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $003E.w		; 1C 3E 00 ; Test and reset bits $003E.w [Reads: Accumulator] [Flags: Z]
	trb $361C.w		; 1C 1C 36 ; Test and reset bits $361C.w [Reads: Accumulator] [Flags: Z]
	adc [$5D.b],Y		; 77 5D ; Add with carry (long indexed) [$5D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $433E63.l,X		; 7F 63 3E 43 ; Add long $433E63.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $8B08.w		; 1C 08 8B ; Test and reset bits $8B08.w [Reads: Accumulator] [Flags: Z]
	stz $02.b,X		; 74 02 ; Store zero to $02.b,X [Reads: X Index]
	ora ($14.b,X)		; 01 14 ; Logical OR ($14.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	trb $85.b		; 14 85 ; Test and reset bits $85.b [Reads: Accumulator] [Flags: Z]
	.db $82, $02, $05		; 82 02 05 ; Branch always long to $82, $02, $05 [Flow: branch]
	.db $42, $3D		; 42 3D ; Reserved instruction
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and [$54.b],Y		; 37 54 ; AND accumulator with memory (long indexed) [$54.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $43.b,S		; 23 43 ; AND accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $010201.l		; 22 01 02 01 ; Jump to subroutine long $010201.l [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3F0400.l		; 22 00 04 3F ; Jump to subroutine long $3F0400.l [Writes: Stack Pointer] [Flow: call]
	and [$23.b],Y		; 37 23 ; AND accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $840800.l		; 22 00 08 84 ; Jump to subroutine long $840800.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $D8.b		; 24 D8 ; Test bits $D8.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	mvn $88,$88		; 54 88 88 ; Move block negative $88,$88 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpx $34.b		; E4 34 ; Compare $34.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0000.w		; 6D 00 00 ; Add $0000.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	sbc $4043.w		; ED 43 40 ; Subtract $4043.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF7305.l,X		; FF 05 73 FF ; Subtract with carry (long,X) $FF7305.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $61BF.w,X		; 1E BF 61 ; Arithmetic shift left $61BF.w,X [Reads: X Index] [Flags: ZNC]
	dec $7322.w,X		; DE 22 73 ; Decrement memory $7322.w,X [Reads: X Index] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	lda ($B3.b,S),Y		; B3 B3 ; Load accumulator (stack relative indirect indexed) ($B3.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sty $FFE1.w		; 8C E1 FF ; Store Y register to $FFE1.w [Reads: Y Index]
	sbc $FB1EF9.l,X		; FF F9 1E FB ; Subtract with carry (long,X) $FB1EF9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $94FF.w		; 0C FF 94 ; Test and set bits $94FF.w [Reads: Accumulator] [Flags: Z]
	sbc $9FF798.l,X		; FF 98 F7 9F ; Subtract with carry (long,X) $9FF798.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($5F.b,S),Y		; F3 5F ; Subtract with carry (stack relative indirect indexed) ($5F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp $FFC6FD.l		; CF FD C6 FF ; Compare accumulator (long) $FFC6FD.l [Reads: Accumulator] [Flags: ZNC]
	sbc $7F7F7D.l,X		; FF 7D 7F 7F ; Subtract with carry (long,X) $7F7F7D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $2FE0FF.l		; 22 FF E0 2F ; Jump to subroutine long $2FE0FF.l [Writes: Stack Pointer] [Flow: call]
	lda [$47.b],Y		; B7 47 ; Load accumulator (long indexed) [$47.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $90DF08.l		; EF 08 DF 90 ; Subtract with carry (long) $90DF08.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $B0FBB4.l,X		; FF B4 FB B0 ; Subtract with carry (long,X) $B0FBB4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda ($FF.b,S),Y		; B3 FF ; Load accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $FE.b,X		; 34 FE ; Test bits $FE.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $30, $E8		; 30 E8 ; Branch if minus to $30, $E8 [Flow: branch]
	cmp [$EF.b],Y		; D7 EF ; Compare accumulator (long indexed) [$EF.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	wai		; CB ; Wait for interrupt
	cmp $CFCBCC.l		; CF CC CB CF ; Compare accumulator (long) $CFCBCC.l [Reads: Accumulator] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $FF8C.w,X		; FD 8C FF ; Subtract with carry $FF8C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $FF.b		; 86 FF ; Store X register to $FF.b [Reads: X Index]
	stx $EF.b,Y		; 96 EF ; Store X register $EF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	stx $6F.b		; 86 6F ; Store X register to $6F.b [Reads: X Index]
	ror $FF.b		; 66 FF ; Rotate right $FF.b [Reads: Direct Page] [Flags: ZNC]
	stx $3F.b,Y		; 96 3F ; Store X register $3F.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	adc ($79.b,S),Y		; 73 79 ; Add with carry (stack relative indirect indexed) ($79.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc #$79.b		; 69 79 ; Add #$79.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	sta $F969.w,Y		; 99 69 F9 ; Store accumulator to $F969.w,Y [Reads: Accumulator, Y Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $0F,$00		; 44 00 0F ; Move block positive $0F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010800.l		; 22 00 08 01 ; Jump to subroutine long $010800.l [Writes: Stack Pointer] [Flow: call]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $001F1F.l		; 0F 1F 1F 00 ; OR accumulator with memory (long) $001F1F.l [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $FF00.w		; 4C 00 FF ; Jump to $FF00.w [Flow: jump]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $24FF25.l,X		; 3F 25 FF 24 ; AND accumulator with memory (long,X) $24FF25.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $F4.b		; 64 F4 ; Store zero to $F4.b
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $0B.b		; 64 0B ; Store zero to $0B.b
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($40.b,S),Y		; 13 40 ; OR accumulator (stack relative indirect indexed) ($40.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $5050.w		; 0C 50 50 ; Test and set bits $5050.w [Reads: Accumulator] [Flags: Z]
	lda $A3.b,S		; A3 A3 ; Load accumulator (stack relative) $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp $0000.w		; 4C 00 00 ; Jump to $0000.w [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $500C.w		; 20 0C 50 ; Jump to subroutine at $500C.w [Writes: Stack Pointer] [Flow: call]
	lda $4C.b,S		; A3 4C ; Load accumulator (stack relative) $4C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr $1201.w		; 20 01 12 ; Jump to subroutine at $1201.w [Writes: Stack Pointer] [Flow: call]
	sta $01.b,S		; 83 01 ; Store accumulator (stack relative) $01.b,S [Reads: Accumulator, Stack Pointer]
	sta $03.b,S		; 83 03 ; Store accumulator (stack relative) $03.b,S [Reads: Accumulator, Stack Pointer]
	cmp [$42.b]		; C7 42 ; Compare accumulator (long) [$42.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc [$64.b],Y		; F7 64 ; Subtract with carry (long indexed) [$64.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ror $00F9.w,X		; 7E F9 00 ; Rotate right $00F9.w,X [Reads: X Index] [Flags: ZNC]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $C7.b,S		; 83 C7 ; Store accumulator (stack relative) $C7.b,S [Reads: Accumulator, Stack Pointer]
	inc $F8.b,X		; F6 F8 ; Increment memory $F8.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$8244.w		; E0 44 82 ; Compare #$8244.w with X register [Reads: X Index] [Flags: ZNC]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C6		; 80 C6 ; Branch always to $80, $C6 [Flow: branch]
	sty $DE.b		; 84 DE ; Store Y register to $DE.b [Reads: Y Index]
	jmp $3EFCBE.l		; 5C BE FC 3E ; Jump long to $3EFCBE.l [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $82, $C6		; 82 82 C6 ; Branch always long to $82, $82, $C6 [Flow: branch]
	dec $3E3E.w,X		; DE 3E 3E ; Decrement memory $3E3E.w,X [Reads: X Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $96.b		; 00 96 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $9F.b		; 02 9F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($DF.b,X)		; 01 DF ; Logical OR ($DF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jmp $6EEE.w		; 4C EE 6E ; Jump to $6EEE.w [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($E77E.w,X)		; 7C 7E E7 ; Jump indirect indexed to ($E77E.w,X) [Reads: X Index] [Flow: jump]
	sbc $FA.b,X		; F5 FA ; Subtract $FA.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda ($91.b),Y		; B1 91 ; Load accumulator ($91.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $2200.w		; 1C 00 22 ; Test and reset bits $2200.w [Reads: Accumulator] [Flags: Z]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $FB80.w,Y		; F9 80 FB ; Subtract with carry $FB80.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($77.b)		; 32 77 ; AND accumulator with memory (indirect) ($77.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $1C.b,X		; 76 1C ; Rotate right $1C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $E77E.w,X		; 3E 7E E7 ; Rotate left $E77E.w,X [Reads: X Index] [Flags: ZNC]
	lda $898D5F.l		; AF 5F 8D 89 ; Load long $898D5F.l into accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $F0.b,S		; 83 F0 ; Store accumulator (stack relative) $F0.b,S [Reads: Accumulator, Stack Pointer]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($6F.b),Y		; 11 6F ; OR accumulator with memory ($6F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($073E.w,X)		; 7C 3E 07 ; Jump indirect indexed to ($073E.w,X) [Reads: X Index] [Flow: jump]
	asl $2A.b,X		; 16 2A ; Arithmetic shift left $2A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $00.b,X		; 55 00 ; Exclusive OR accumulator with memory $00.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $11.b		; 04 11 ; Test and set bits $11.b [Reads: Accumulator] [Flags: Z]
	jmp $00A000.l		; 5C 00 A0 00 ; Jump long to $00A000.l [Flow: jump]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	inc $14.b,X		; F6 14 ; Increment memory $14.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $E07C.w,X		; 3E 7C E0 ; Rotate left $E07C.w,X [Reads: X Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	mvn $E4,$AA		; 54 AA E4 ; Move block negative $E4,$AA [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $ED0F00.l		; 2F 00 0F ED ; AND accumulator with memory (long) $ED0F00.l [Writes: Accumulator] [Flags: ZN]
	and ($FF.b,S),Y		; 33 FF ; AND accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cmp $03FF78.l		; CF 78 FF 03 ; Compare accumulator (long) $03FF78.l [Reads: Accumulator] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $073F12.l,X		; FF 12 3F 07 ; Subtract with carry (long,X) $073F12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$DC.b]		; 27 DC ; AND accumulator with memory (long) [$DC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$FC.b],Y		; 37 FC ; AND accumulator with memory (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$CE.b],Y		; 37 CE ; AND accumulator with memory (long indexed) [$CE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $F0FFF9.l		; 0F F9 FF F0 ; OR accumulator with memory (long) $F0FFF9.l [Writes: Accumulator] [Flags: ZN]
	sbc $2600.w,Y		; F9 00 26 ; Subtract with carry $2600.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F930E0.l,X		; FF E0 30 F9 ; Subtract with carry (long,X) $F930E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $B0FB31.l,X		; FF 31 FB B0 ; Subtract with carry (long,X) $B0FB31.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $9A7FB6.l,X		; 7F B6 7F 9A ; Add long $9A7FB6.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $E77FCC.l,X		; 7F CC 7F E7 ; Add long $E77FCC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FFE6.l,X		; FF E6 FF 00 ; Subtract with carry (long,X) $00FFE6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $C9CF.w		; CE CF C9 ; Decrement $C9CF.w [Flags: ZN]
	sbc $F3.b		; E5 F3 ; Subtract $F3.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $7FFF.w,Y		; F9 FF 7F ; Subtract with carry $7FFF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $EF.b		; 46 EF ; Logical shift right $EF.b [Reads: Direct Page] [Flags: ZNC]
	stx $FF.b		; 86 FF ; Store X register to $FF.b [Reads: X Index]
	ldx $FF.b,Y		; B6 FF ; Load X register $FF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	ldy $98FE.w		; AC FE 98 ; Load $98FE.w into Y register [Writes: Y Index] [Flags: ZN]
	jsr ($D8F0.w,X)		; FC F0 D8 ; Jump to subroutine indirect indexed ($D8F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $5349.w,Y		; 79 49 53 ; Add $5349.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $0C.b		; 66 0C ; Rotate right $0C.b [Reads: Direct Page] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $1F.b,S		; 43 1F ; Exclusive OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $070200.l		; 0F 00 02 07 ; OR accumulator with memory (long) $070200.l [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	ora $070F0F.l,X		; 1F 0F 0F 07 ; Logical OR long $070F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jmp $FF00.w		; 4C 00 FF ; Jump to $FF00.w [Flow: jump]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF2500.l		; 22 00 25 FF ; Jump to subroutine long $FF2500.l [Writes: Stack Pointer] [Flow: call]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $27.b		; E4 27 ; Compare $27.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	and [$22.b]		; 27 22 ; AND accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $10.b		; E4 10 ; Compare $10.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $3211.w		; AE 11 32 ; Load $3211.w into X register [Writes: X Index] [Flags: ZN]
	sty $3280.w		; 8C 80 32 ; Store Y register to $3280.w [Reads: Y Index]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $328C11.l		; 0F 11 8C 32 ; OR accumulator with memory (long) $328C11.l [Writes: Accumulator] [Flags: ZN]
	.db $80, $30		; 80 30 ; Branch always to $80, $30 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BF14.w,X		; FD 14 BF ; Subtract with carry $BF14.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $97.b		; 02 97 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldy $1696.w,X		; BC 96 16 ; Load Y register $1696.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ror $FA50.w,X		; 7E 50 FA ; Rotate right $FA50.w,X [Reads: X Index] [Flags: ZNC]
	.db $80, $D2		; 80 D2 ; Branch always to $80, $D2 [Flow: branch]
	.db $80, $D0		; 80 D0 ; Branch always to $80, $D0 [Flow: branch]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $D27A.w,X		; 3E 7A D2 ; Rotate left $D27A.w,X [Reads: X Index] [Flags: ZNC]
	.db $D0, $83		; D0 83 ; Branch if not equal to $D0, $83 [Flow: branch]
	.db $62, $02, $E0		; 62 02 E0 ; Push effective relative address $62, $02, $E0 [Writes: Stack Pointer]
	eor $FF78FF.l,X		; 5F FF 78 FF ; Exclusive OR accumulator with memory (long,X) $FF78FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $4BFB.w		; 6D FB 4B ; Add $4BFB.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	jmp ($3F00.w,X)		; 7C 00 3F ; Jump indirect indexed to ($3F00.w,X) [Reads: X Index] [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $7C0C.w,X		; 3E 0C 7C ; Rotate left $7C0C.w,X [Reads: X Index] [Flags: ZNC]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($B4.b),Y		; 91 B4 ; Store accumulator ($B4.b),Y [Reads: Accumulator, Direct Page, Y Index]
	adc $5C2227.l,X		; 7F 27 22 5C ; Add long $5C2227.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $1EFF.w		; 20 FF 1E ; Jump to subroutine at $1EFF.w [Writes: Stack Pointer] [Flow: call]
	sbc $D2DFB6.l,X		; FF B6 DF D2 ; Subtract with carry (long,X) $D2DFB6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $FC00.w,X		; 3E 00 FC ; Rotate left $FC00.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp ($3E30.w,X)		; 7C 30 3E ; Jump indirect indexed to ($3E30.w,X) [Reads: X Index] [Flow: jump]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A1.b		; 00 A1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$2D.b		; 89 2D ; Test bits #$2D.b with accumulator [Reads: Accumulator] [Flags: Z]
	inc $44E4.w,X		; FE E4 44 ; Increment memory $44E4.w,X [Reads: X Index] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $46.b		; 04 46 ; Test and set bits $46.b [Reads: Accumulator] [Flags: Z]
	cop $67.b		; 02 67 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3177.w		; 20 77 31 ; Jump to subroutine at $3177.w [Writes: Stack Pointer] [Flow: call]
	and $083C1B.l,X		; 3F 1B 3C 08 ; AND accumulator with memory (long,X) $083C1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $083E08.l,X		; 1F 08 3E 08 ; Logical OR long $083E08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($7D00.w,X)		; 7C 00 7D ; Jump indirect indexed to ($7D00.w,X) [Reads: X Index] [Flow: jump]
	eor $244D.w,X		; 5D 4D 24 ; Exclusive OR accumulator with memory $244D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$17.b],Y		; 37 17 ; AND accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $5C.b,X		; 36 5C ; Rotate left $5C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $62, $40, $E6		; 62 40 E6 ; Push effective relative address $62, $40, $E6 [Writes: Stack Pointer]
	tsb $EE.b		; 04 EE ; Test and set bits $EE.b [Reads: Accumulator] [Flags: Z]
	sty $D8FC.w		; 8C FC D8 ; Store Y register to $D8FC.w [Reads: Y Index]
	bit $F810.w,X		; 3C 10 F8 ; Test bits $F810.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	lda ($24.b)		; B2 24 ; Load accumulator (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx $6CE8.w		; EC E8 6C ; Compare $6CE8.w with X register [Reads: X Index] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	asl $180C.w,X		; 1E 0C 18 ; Arithmetic shift left $180C.w,X [Reads: X Index] [Flags: ZNC]
	jsr $09FF.w		; 20 FF 09 ; Jump to subroutine at $09FF.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F1E07.l		; 0F 07 1E 0F ; OR accumulator with memory (long) $0F1E07.l [Writes: Accumulator] [Flags: ZN]
	trb $430F.w		; 1C 0F 43 ; Test and reset bits $430F.w [Reads: Accumulator] [Flags: Z]
	bit $E01F.w,X		; 3C 1F E0 ; Test bits $E01F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and ($7E.b,X)		; 21 7E ; Logical AND ($7E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0F0701.l		; 0F 01 07 0F ; OR accumulator with memory (long) $0F0701.l [Writes: Accumulator] [Flags: ZN]
	ora $3F3F1F.l,X		; 1F 1F 3F 3F ; Logical OR long $3F3F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $E00080.l,X		; 5F 80 00 E0 ; Exclusive OR accumulator with memory (long,X) $E00080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	cpx #$F018.w		; E0 18 F0 ; Compare #$F018.w with X register [Reads: X Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $B0, $EC		; B0 EC ; Branch if carry set to $B0, $EC [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp $1EB8.w		; 4C B8 1E ; Jump to $1EB8.w [Flow: jump]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	cpx #$F8F0.w		; E0 F0 F8 ; Compare #$F8F0.w with X register [Reads: X Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	trb $FABC.w		; 1C BC FA ; Test and reset bits $FABC.w [Reads: Accumulator] [Flags: Z]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $E0.b		; 06 E0 ; Arithmetic shift left $E0.b [Reads: Direct Page] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jmp ($27E6.w,X)		; 7C E6 27 ; Jump indirect indexed to ($27E6.w,X) [Reads: X Index] [Flow: jump]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $003900.l,X		; 1F 00 39 00 ; Logical OR long $003900.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $0024.w,X		; 7D 24 00 ; Add $0024.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	rol $2567.w,X		; 3E 67 25 ; Rotate left $2567.w,X [Reads: X Index] [Flags: ZNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5800.w		; 20 00 58 ; Jump to subroutine at $5800.w [Writes: Stack Pointer] [Flow: call]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B3.b		; 00 B3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $20.b		; 04 20 ; Test and set bits $20.b [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldx $25EF.w,Y		; BE EF 25 ; Load X register $25EF.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CD.b		; 00 CD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	ora $F77D.w,X		; 1D 7D F7 ; OR accumulator with memory $F77D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1E4503.l		; 0F 03 45 1E ; OR accumulator with memory (long) $1E4503.l [Writes: Accumulator] [Flags: ZN]
	ora $0FDF07.l		; 0F 07 DF 0F ; OR accumulator with memory (long) $0FDF07.l [Writes: Accumulator] [Flags: ZN]
	sbc $00FF07.l,X		; FF 07 FF 00 ; Subtract with carry (long,X) $00FF07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $DF1A1F.l		; 22 1F 1A DF ; Jump to subroutine long $DF1A1F.l [Writes: Stack Pointer] [Flow: call]
	and $00C0A7.l,X		; 3F A7 C0 00 ; AND accumulator with memory (long,X) $00C0A7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $90, $38		; 90 38 ; Branch if carry clear to $90, $38 [Flow: branch]
	.db $D0, $18		; D0 18 ; Branch if not equal to $D0, $18 [Flow: branch]
	.db $F0, $3B		; F0 3B ; Branch if equal to $F0, $3B [Flow: branch]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	cpx #$00FF.w		; E0 FF 00 ; Compare #$00FF.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$98F0.w		; C0 F0 98 ; Compare #$98F0.w with Y register [Reads: Y Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($23E5.w,X)		; FC E5 23 ; Jump to subroutine indirect indexed ($23E5.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $0E.b,S		; 43 0E ; Exclusive OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $227F07.l,X		; 3F 07 7F 22 ; AND accumulator with memory (long,X) $227F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $4F3F0F.l		; 0F 0F 3F 4F ; OR accumulator with memory (long) $4F3F0F.l [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cpy #$2000.w		; C0 00 20 ; Compare #$2000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$A050.w		; C0 50 A0 ; Compare #$A050.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	bit $FEE0.w,X		; 3C E0 FE ; Test bits $FEE0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jsl $C00500.l		; 22 00 05 C0 ; Jump to subroutine long $C00500.l [Writes: Stack Pointer] [Flow: call]
	cpx #$F0B0.w		; E0 B0 F0 ; Compare #$F0B0.w with X register [Reads: X Index] [Flags: ZNC]
	jsr ($25F2.w,X)		; FC F2 25 ; Jump to subroutine indirect indexed ($25F2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	ora $231F03.l		; 0F 03 1F 23 ; OR accumulator with memory (long) $231F03.l [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$25.b],Y		; 17 25 ; OR accumulator with memory (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	cpy #$C070.w		; C0 70 C0 ; Compare #$C070.w with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($80.b),Y		; 11 80 ; OR accumulator with memory ($80.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$F0E0.w		; C0 E0 F0 ; Compare #$F0E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $18.b,X		; 76 18 ; Rotate right $18.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	lda $5A00.w,X		; BD 00 5A ; Load $5A00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $E77E.w,X		; 3C 7E E7 ; Test bits $E77E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ror $223C.w,X		; 7E 3C 22 ; Rotate right $223C.w,X [Reads: X Index] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7E,$00		; 44 00 7E ; Move block positive $7E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $3C.b		; 02 3C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $5A.b		; 24 5A ; Test bits $5A.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $27181F.l,X		; 1F 1F 18 27 ; Logical OR long $27181F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E000.w		; C0 00 E0 ; Compare #$E000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$E0B0.w		; C0 B0 E0 ; Compare #$E0B0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$C03A.w		; E0 3A C0 ; Compare #$C03A.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$F0F0.w		; E0 F0 F0 ; Compare #$F0F0.w with X register [Reads: X Index] [Flags: ZNC]
	sbc $07FF0F.l,X		; FF 0F FF 07 ; Subtract with carry (long,X) $07FF0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $003F03.l,X		; 7F 03 3F 00 ; Add long $003F03.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $081300.l,X		; 1F 00 13 08 ; Logical OR long $081300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	lda $2B47BF.l,X		; BF BF 47 2B ; Load long $2B47BF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $0B17.w		; 1C 17 0B ; Test and reset bits $0B17.w [Reads: Accumulator] [Flags: Z]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: ZNC]
	.db $F0, $7F		; F0 7F ; Branch if equal to $F0, $7F [Flow: branch]
	cpx #$C0FE.w		; E0 FE C0 ; Compare #$C0FE.w with X register [Reads: X Index] [Flags: ZNC]
	jsr ($F800.w,X)		; FC 00 F8 ; Jump to subroutine indirect indexed ($F800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $90		; 10 90 ; Branch if plus to $10, $90 [Flow: branch]
	jsr $0060.w		; 20 60 00 ; Jump to subroutine at $0060.w [Writes: Stack Pointer] [Flow: call]
	sbc $E2FD.w,X		; FD FD E2 ; Subtract with carry $E2FD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pei ($38.b)		; D4 38 ; Push effective indirect address ($38.b) [Reads: Direct Page] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $D0, $60		; D0 60 ; Branch if not equal to $D0, $60 [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $3F.b		; 84 3F ; Store Y register to $3F.b [Reads: Y Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $140022.l		; 0F 22 00 14 ; OR accumulator with memory (long) $140022.l [Writes: Accumulator] [Flags: ZN]
	sbc [$4F.b]		; E7 4F ; Subtract with carry (long) [$4F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda $3F7F7F.l,X		; BF 7F 7F 3F ; Load long $3F7F7F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00DF00.l		; 0F 00 DF 00 ; OR accumulator with memory (long) $00DF00.l [Writes: Accumulator] [Flags: ZN]
	cmp $00E300.l		; CF 00 E3 00 ; Compare accumulator (long) $00E300.l [Reads: Accumulator] [Flags: ZNC]
	cmp ($00.b)		; D2 00 ; Compare accumulator (indirect) ($00.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	inc $7C00.w,X		; FE 00 7C ; Increment memory $7C00.w,X [Reads: X Index] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E71400.l		; 22 00 14 E7 ; Jump to subroutine long $E71400.l [Writes: Stack Pointer] [Flow: call]
	sbc ($7D.b)		; F2 7D ; Subtract with carry (indirect) ($7D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ldx $BC7E.w,Y		; BE 7E BC ; Load X register $BC7E.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: ZN]
	sbc $9C00.w		; ED 00 9C ; Subtract $9C00.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $CF0300.l		; 22 00 03 CF ; Jump to subroutine long $CF0300.l [Writes: Stack Pointer] [Flow: call]
	cmp $83FFDE.l,X		; DF DE FF 83 ; Compare accumulator (long,X) $83FFDE.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	cpy $01.b		; C4 01 ; Compare $01.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	asl $EF.b		; 06 EF ; Arithmetic shift left $EF.b [Reads: Direct Page] [Flags: ZNC]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $CF.b		; 85 CF ; Store accumulator to $CF.b [Reads: Accumulator]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7B,$F3		; 44 F3 7B ; Move block positive $7B,$F3 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $F0FC7E.l,X		; 7F 7E FC F0 ; Add long $F0FC7E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $F9.b		; 04 F9 ; Test and set bits $F9.b [Reads: Accumulator] [Flags: Z]
	asl $F6.b		; 06 F6 ; Arithmetic shift left $F6.b [Reads: Direct Page] [Flags: ZNC]
	brk $65.b		; 00 65 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $EF39FB.l		; EF FB 39 EF ; Subtract with carry (long) $EF39FB.l [Writes: Accumulator] [Flags: ZVNC]
	lsr $1C3F.w,X		; 5E 3F 1C ; Logical shift right $1C3F.w,X [Reads: X Index] [Flags: ZNC]
	sbc $F900.w,X		; FD 00 F9 ; Subtract with carry $F900.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $9B.b		; 00 9B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $609F.w		; 20 9F 60 ; Jump to subroutine at $609F.w [Writes: Stack Pointer] [Flow: call]
	sbc $00E600.l		; EF 00 E6 00 ; Subtract with carry (long) $00E600.l [Writes: Accumulator] [Flags: ZVNC]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $3A77.w		; 9C 77 3A ; Store zero to $3A77.w
	jmp ($2FB8.w,X)		; 7C B8 2F ; Jump indirect indexed to ($2FB8.w,X) [Reads: X Index] [Flow: jump]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $6F.b		; 02 6F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $381400.l		; 22 00 14 38 ; Jump to subroutine long $381400.l [Writes: Stack Pointer] [Flow: call]
	and $375F3D.l,X		; 3F 3D 5F 37 ; AND accumulator with memory (long,X) $375F3D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $000D.w,X		; 1E 0D 00 ; Arithmetic shift left $000D.w,X [Reads: X Index] [Flags: ZNC]
	pea $E400.w		; F4 00 E4 ; Push absolute address $E400.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	jmp $00C800.l		; 5C 00 C8 00 ; Jump long to $00C800.l [Flow: jump]
	.db $B0, $22		; B0 22 ; Branch if carry set to $B0, $22 [Flow: branch]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $BCFC.w		; 1C FC BC ; Test and reset bits $BCFC.w [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cpx $B078.w		; EC 78 B0 ; Compare $B078.w with X register [Reads: X Index] [Flags: ZNC]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($1C.b)		; 12 1C ; OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F0F1E.l		; 0F 1E 0F 0F ; OR accumulator with memory (long) $0F0F1E.l [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $50		; 80 50 ; Branch always to $80, $50 [Flow: branch]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $78F038.l,X		; 1F 38 F0 78 ; Logical OR long $78F038.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	bit $7E00.w		; 2C 00 7E ; Test bits $7E00.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	bit $067F.w		; 2C 7F 06 ; Test bits $067F.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	lda $187E1A.l,X		; BF 1A 7E 18 ; Load long $187E1A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $001602.l,X		; 1F 02 16 00 ; Logical OR long $001602.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $E77F.w,X		; 5E 7F E7 ; Logical shift right $E77F.w,X [Reads: X Index] [Flags: ZNC]
	ror $1D.b		; 66 1D ; Rotate right $1D.b [Reads: Direct Page] [Flags: ZNC]
	asl $8408.w,X		; 1E 08 84 ; Arithmetic shift left $8408.w,X [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $66.b,S		; 43 66 ; Exclusive OR accumulator with stack relative $66.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $02.b		; 24 02 ; Test bits $02.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stx $49.b		; 86 49 ; Store X register to $49.b [Reads: X Index]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $0604.w		; 2C 04 06 ; Test bits $0604.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $000707.l,X		; 1F 07 07 00 ; Logical OR long $000707.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	ldy #$80F0.w		; A0 F0 80 ; Load #$80F0.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	cpx #$0026.w		; E0 26 00 ; Compare #$0026.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $78.b		; 04 78 ; Test and set bits $78.b [Reads: Accumulator] [Flags: Z]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	jsl $020100.l		; 22 00 01 02 ; Jump to subroutine long $020100.l [Writes: Stack Pointer] [Flow: call]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	cpx #$1F29.w		; E0 29 1F ; Compare #$1F29.w with X register [Reads: X Index] [Flags: ZNC]
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	trb $30F1.w		; 1C F1 30 ; Test and reset bits $30F1.w [Reads: Accumulator] [Flags: Z]
	adc ($30.b,S),Y		; 73 30 ; Add with carry (stack relative indirect indexed) ($30.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3B18.w		; 0C 18 3B ; Test and set bits $3B18.w [Reads: Accumulator] [Flags: Z]
	and $4E.b,S		; 23 4E ; AND accumulator with stack relative $4E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp $0040.w		; 4C 40 00 ; Jump to $0040.w [Flow: jump]
	cpy #$F000.w		; C0 00 F0 ; Compare #$F000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$E0F8.w		; C0 F8 E0 ; Compare #$E0F8.w with Y register [Reads: Y Index] [Flags: ZNC]
	bit $3C20.w,X		; 3C 20 3C ; Test bits $3C20.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sta $0CCE0C.l		; 8F 0C CE 0C ; Store accumulator (long) $0CCE0C.l [Reads: Accumulator]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	jmp.w [$72C4]		; DC C4 72 ; Jump long indirect [$72C4] [Flow: jump]
	and ($23.b)		; 32 23 ; AND accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $3D.b		; 06 3D ; Arithmetic shift left $3D.b [Reads: Direct Page] [Flags: ZNC]
	tsb $091B.w		; 0C 1B 09 ; Test and set bits $091B.w [Reads: Accumulator] [Flags: Z]
	jsl $030400.l		; 22 00 04 03 ; Jump to subroutine long $030400.l [Writes: Stack Pointer] [Flow: call]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora ($15.b)		; 12 15 ; OR accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $18.b,S		; 83 18 ; Store accumulator (stack relative) $18.b,S [Reads: Accumulator, Stack Pointer]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$70C0.w		; E0 C0 70 ; Compare #$70C0.w with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy $D830.w,X		; BC 30 D8 ; Load Y register $D830.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $90, $22		; 90 22 ; Branch if carry clear to $90, $22 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$9020.w		; C0 20 90 ; Compare #$9020.w with Y register [Reads: Y Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	bit $7B04.w,X		; 3C 04 7B ; Test bits $7B04.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	lda $53FC1C.l,X		; BF 1C FC 53 ; Load long $53FC1C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $E326.w,Y		; 59 26 E3 ; Exclusive OR accumulator with memory $E326.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $0601.w,X		; 3C 01 06 ; Test bits $0601.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	mvn $AF,$E3		; 54 E3 AF ; Move block negative $AF,$E3 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ror $80FC.w,X		; 7E FC 80 ; Rotate right $80FC.w,X [Reads: X Index] [Flags: ZNC]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $3A		; 80 3A ; Branch always to $80, $3A [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cmp $FFCC.w,X		; DD CC FF ; Compare accumulator $FFCC.w,X [Reads: X Index] [Flags: ZNC]
	rol $3F.b,X		; 36 3F ; Rotate left $3F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	stz $C7.b		; 64 C7 ; Store zero to $C7.b
	bit $6C80.w,X		; 3C 80 6C ; Test bits $6C80.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	dec $33.b,X		; D6 33 ; Decrement memory $33.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cmp #$F5.b		; C9 F5 ; Compare #$F5.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	adc $00233F.l,X		; 7F 3F 23 00 ; Add long $00233F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	asl $1103.w		; 0E 03 11 ; Arithmetic shift left $1103.w [Flags: ZNC]
	ora $5D1729.l		; 0F 29 17 5D ; OR accumulator with memory (long) $5D1729.l [Writes: Accumulator] [Flags: ZN]
	and $4B.b,S		; 23 4B ; AND accumulator with stack relative $4B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $9F.b,S		; 83 9F ; Store accumulator (stack relative) $9F.b,S [Reads: Accumulator, Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$63.b],Y		; 37 63 ; AND accumulator with memory (long indexed) [$63.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$25.b],Y		; 77 25 ; Add with carry (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	jsr ($CEB0.w,X)		; FC B0 CE ; Jump to subroutine indirect indexed ($CEB0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp $44C6.w		; 4C C6 44 ; Jump to $44C6.w [Flow: jump]
	jsl $800400.l		; 22 00 04 80 ; Jump to subroutine long $800400.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $CC		; F0 CC ; Branch if equal to $F0, $CC [Flow: branch]
	lda ($BA.b)		; B2 BA ; Load accumulator (indirect) ($BA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit #$94.b		; 89 94 ; Test bits #$94.b with accumulator [Reads: Accumulator] [Flags: Z]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$2703.w		; A2 03 27 ; Load #$2703.w into X register [Writes: X Index] [Flags: ZN]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $2303.w		; AE 03 23 ; Load $2303.w into X register [Writes: X Index] [Flags: ZN]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rep #$00		; C2 00 ; Reset processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $5C0E59.l		; 0F 59 0E 5C ; OR accumulator with memory (long) $5C0E59.l [Writes: Accumulator] [Flags: ZN]
	ora [$53.b]		; 07 53 ; OR accumulator with memory (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $03DF.w		; 0C DF 03 ; Test and set bits $03DF.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7F7E3F.l		; 0F 3F 7E 7F ; OR accumulator with memory (long) $7F7E3F.l [Writes: Accumulator] [Flags: ZN]
	adc $DA83BC.l,X		; 7F BC 83 DA ; Add long $DA83BC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $F0.b		; 25 F0 ; Logical AND $F0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy #$F038.w		; C0 38 F0 ; Compare #$F038.w with Y register [Reads: Y Index] [Flags: ZNC]
	stz $3C78.w		; 9C 78 3C ; Store zero to $3C78.w
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $30, $F6		; 30 F6 ; Branch if minus to $30, $F6 [Flow: branch]
	cpy #$C000.w		; C0 00 C0 ; Compare #$C000.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jmp ($FEFC.w,X)		; 7C FC FE ; Jump indirect indexed to ($FEFC.w,X) [Reads: X Index] [Flow: jump]
	rol $0000.w,X		; 3E 00 00 ; Rotate left $0000.w,X [Reads: X Index] [Flags: ZNC]
	ora $032700.l,X		; 1F 00 27 03 ; Logical OR long $032700.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $002707.l		; 2F 07 27 00 ; AND accumulator with memory (long) $002707.l [Writes: Accumulator] [Flags: ZN]
	adc [$03.b]		; 67 03 ; Add with carry (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	stz $9A04.w		; 9C 04 9A ; Store zero to $9A04.w
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $7C1A3F.l		; 22 3F 1A 7C ; Jump to subroutine long $7C1A3F.l [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $E0.b,X		; F5 E0 ; Subtract $E0.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E83C.w		; C0 3C E8 ; Compare #$E83C.w with Y register [Reads: Y Index] [Flags: ZNC]
	dec $FC.b		; C6 FC ; Decrement $FC.b [Reads: Direct Page] [Flags: ZN]
	inc $38.b		; E6 38 ; Increment $38.b [Reads: Direct Page] [Flags: ZN]
	sbc [$1C.b],Y		; F7 1C ; Subtract with carry (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	stx $4E7B.w		; 8E 7B 4E ; Store X register to $4E7B.w [Reads: X Index]
	cpx #$FCF8.w		; E0 F8 FC ; Compare #$FCF8.w with X register [Reads: X Index] [Flags: ZNC]
	inc $FFFE.w,X		; FE FE FF ; Increment memory $FFFE.w,X [Reads: X Index] [Flags: ZN]
	adc $0023BF.l,X		; 7F BF 23 00 ; Add long $0023BF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta [$56.b]		; 87 56 ; Store accumulator (long) [$56.b] [Reads: Accumulator, Direct Page]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and [$03.b],Y		; 37 03 ; AND accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $8504.w		; 4E 04 85 ; Logical shift right $8504.w [Flags: ZNC]
	adc ($01.b,X)		; 61 01 ; Add with carry ($01.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora ($3C.b,X)		; 01 3C ; Logical OR ($3C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $0023.w,Y		; 79 23 00 ; Add $0023.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $1A.b,S		; 83 1A ; Store accumulator (stack relative) $1A.b,S [Reads: Accumulator, Stack Pointer]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $F0, $D8		; F0 D8 ; Branch if equal to $F0, $D8 [Flow: branch]
	.db $70, $EC		; 70 EC ; Branch if overflow set to $70, $EC [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($0098.w,X)		; FC 98 00 ; Jump to subroutine indirect indexed ($0098.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $18.b,S		; 83 18 ; Store accumulator (stack relative) $18.b,S [Reads: Accumulator, Stack Pointer]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	and $FCF8.w,Y		; 39 F8 FC ; AND accumulator with memory $FCF8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($3073.w,X)		; 7C 73 30 ; Jump indirect indexed to ($3073.w,X) [Reads: X Index] [Flow: jump]
	sbc ($30.b),Y		; F1 30 ; Subtract with carry ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $3C1C.w,X		; 3C 1C 3C ; Test bits $3C1C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $3B23.w		; 4E 23 3B ; Logical shift right $3B23.w [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	dec $8F0C.w		; CE 0C 8F ; Decrement $8F0C.w [Flags: ZN]
	tsb $383C.w		; 0C 3C 38 ; Test and set bits $383C.w [Reads: Accumulator] [Flags: Z]
	bit $F820.w,X		; 3C 20 F8 ; Test bits $F820.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx #$C0F0.w		; E0 F0 C0 ; Compare #$C0F0.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$4000.w		; C0 00 40 ; Compare #$4000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($C4.b)		; 72 C4 ; Add with carry (indirect) ($C4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jmp.w [$3018]		; DC 18 30 ; Jump long indirect [$3018] [Flow: jump]
	cpy #$1B00.w		; C0 00 1B ; Compare #$1B00.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora #$3D.b		; 09 3D ; Logical OR #$3D.b with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $060E.w		; 0C 0E 06 ; Test and set bits $060E.w [Reads: Accumulator] [Flags: Z]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $12.b,X		; 15 12 ; OR accumulator with memory $12.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $90, $BC		; 90 BC ; Branch if carry clear to $90, $BC [Flow: branch]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$A383.w		; E0 83 A3 ; Compare #$A383.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $90, $20		; 90 20 ; Branch if carry clear to $90, $20 [Flow: branch]
	cpy #$0022.w		; C0 22 00 ; Compare #$0022.w with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $3EE1.w		; 0C E1 3E ; Test and set bits $3EE1.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $F71F7E.l,X		; 3F 7E 1F F7 ; AND accumulator with memory (long,X) $F71F7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0D7B.w,Y		; 19 7B 0D ; OR accumulator with memory $0D7B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	jsl $FE1400.l		; 22 00 14 FE ; Jump to subroutine long $FE1400.l [Writes: Stack Pointer] [Flow: call]
	adc $7FBF7F.l,X		; 7F 7F BF 7F ; Add long $7FBF7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $860003.l		; 0F 03 00 86 ; OR accumulator with memory (long) $860003.l [Writes: Accumulator] [Flags: ZN]
	jmp ($FC1F.w,X)		; 7C 1F FC ; Jump indirect indexed to ($FC1F.w,X) [Reads: X Index] [Flow: jump]
	adc $EFF8.w,X		; 7D F8 EF ; Add $EFF8.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	dec $3BB4.w,X		; DE B4 3B ; Decrement memory $3BB4.w,X [Reads: X Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	dec $0022.w,X		; DE 22 00 ; Decrement memory $0022.w,X [Reads: X Index] [Flags: ZN]
	trb $7E.b		; 14 7E ; Test and reset bits $7E.b [Reads: Accumulator] [Flags: Z]
	sbc $FAFDFF.l,X		; FF FF FD FA ; Subtract with carry (long,X) $FAFDFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $DE.b,X		; F5 DE ; Subtract $DE.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7CF3.w,X		; 7E F3 7C ; Rotate right $7CF3.w,X [Reads: X Index] [Flags: ZNC]
	sbc $FC48.w,X		; FD 48 FC ; Subtract with carry $FC48.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $3B30.w		; 4D 30 3B ; Exclusive OR $3B30.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $FF2300.l		; 22 00 23 FF ; Jump to subroutine long $FF2300.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $7B		; 10 7B ; Branch if plus to $10, $7B [Flow: branch]
	and [$0F.b],Y		; 37 0F ; AND accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $D2DF.w		; 8E DF D2 ; Store X register to $D2DF.w [Reads: X Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($20.b)		; 72 20 ; Add with carry (indirect) ($20.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	jsr $00F9.w		; 20 F9 00 ; Jump to subroutine at $00F9.w [Writes: Stack Pointer] [Flow: call]
	stx $0022.w		; 8E 22 00 ; Store X register to $0022.w [Reads: X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($2D.b),Y		; 71 2D ; Add with carry ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta [$DE.b],Y		; 97 DE ; Store accumulator (long indexed) [$DE.b],Y [Reads: Accumulator, Direct Page, Y Index]
	dec $8EF7.w,X		; DE F7 8E ; Decrement memory $8EF7.w,X [Reads: X Index] [Flags: ZN]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$C3.b],Y		; 37 C3 ; AND accumulator with memory (long indexed) [$C3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $7EF3.w,X		; 7E F3 7E ; Rotate right $7EF3.w,X [Reads: X Index] [Flags: ZNC]
	sbc $0CFE4E.l,X		; FF 4E FE 0C ; Subtract with carry (long,X) $0CFE4E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $0E333E.l		; 4F 3E 33 0E ; Exclusive OR accumulator with memory (long) $0E333E.l [Writes: Accumulator] [Flags: ZN]
	ora $237700.l		; 0F 00 77 23 ; OR accumulator with memory (long) $237700.l [Writes: Accumulator] [Flags: ZN]
	sbc $7F27E0.l,X		; FF E0 27 7F ; Subtract with carry (long,X) $7F27E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $44C60F.l,X		; 3F 0F C6 44 ; AND accumulator with memory (long,X) $44C60F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $26FF8E.l		; 8F 8E FF 26 ; Store accumulator (long) $26FF8E.l [Reads: Accumulator]
	and [$02.b],Y		; 37 02 ; AND accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ldy $A800.w		; AC 00 A8 ; Load $A800.w into Y register [Writes: Y Index] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BA.b		; 00 BA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($D9.b),Y		; 71 D9 ; Add with carry ($D9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FCFE.w		; ED FE FC ; Subtract $FCFE.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $7C		; F0 7C ; Branch if equal to $F0, $7C [Flow: branch]
	tsb $0838.w		; 0C 38 08 ; Test and set bits $0838.w [Reads: Accumulator] [Flags: Z]
	jmp $4E04.w		; 4C 04 4E ; Jump to $4E04.w [Flow: jump]
	asl $5F.b		; 06 5F ; Arithmetic shift left $5F.b [Reads: Direct Page] [Flags: ZNC]
	ora [$D7.b]		; 07 D7 ; OR accumulator with memory (long) [$D7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($61.b,X)		; 01 61 ; Logical OR ($61.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $731400.l		; 22 00 14 73 ; Jump to subroutine long $731400.l [Writes: Stack Pointer] [Flow: call]
	and [$7B.b],Y		; 37 7B ; AND accumulator with memory (long indexed) [$7B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $B678.w,Y		; 79 78 B6 ; Add $B678.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($00.b,X)		; 61 00 ; Add with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr $2032.w		; 20 32 20 ; Jump to subroutine at $2032.w [Writes: Stack Pointer] [Flow: call]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	jsr $707B.w		; 20 7B 70 ; Jump to subroutine at $707B.w [Writes: Stack Pointer] [Flow: call]
	inc $E0E0.w,X		; FE E0 E0 ; Increment memory $E0E0.w,X [Reads: X Index] [Flags: ZN]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $DF0F00.l		; 22 00 0F DF ; Jump to subroutine long $DF0F00.l [Writes: Stack Pointer] [Flow: call]
	dec $8DDE.w,X		; DE DE 8D ; Decrement memory $8DDE.w,X [Reads: X Index] [Flags: ZN]
	asl $8060.w,X		; 1E 60 80 ; Arithmetic shift left $8060.w,X [Reads: X Index] [Flags: ZNC]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldy $5A18.w,X		; BC 18 5A ; Load Y register $5A18.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $8A830F.l,X		; 1F 0F 83 8A ; Logical OR long $8A830F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $E6.b		; 26 E6 ; Rotate left $E6.b [Reads: Direct Page] [Flags: ZNC]
	sbc $55.b,S		; E3 55 ; Subtract stack-relative $55.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $2CBE.w		; 2C BE 2C ; Test bits $2CBE.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $CA48.w,X		; 7E 48 CA ; Rotate right $CA48.w,X [Reads: X Index] [Flags: ZNC]
	.db $80, $C2		; 80 C2 ; Branch always to $80, $C2 [Flow: branch]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $7EBE.w,X		; 5E BE 7E ; Logical shift right $7EBE.w,X [Reads: X Index] [Flags: ZNC]
	inc $E0FC.w,X		; FE FC E0 ; Increment memory $E0FC.w,X [Reads: X Index] [Flags: ZN]
	cpy #$0859.w		; C0 59 08 ; Compare #$0859.w with Y register [Reads: Y Index] [Flags: ZNC]
	jmp $083A08.l		; 5C 08 3A 08 ; Jump long to $083A08.l [Flow: jump]
	ora $02D585.l		; 0F 85 D5 02 ; OR accumulator with memory (long) $02D585.l [Writes: Accumulator] [Flags: ZN]
	jsl $760300.l		; 22 00 03 76 ; Jump to subroutine long $760300.l [Writes: Stack Pointer] [Flow: call]
	adc ($35.b,S),Y		; 73 35 ; Add with carry (stack relative indirect indexed) ($35.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $E3.b,S		; 83 E3 ; Store accumulator (stack relative) $E3.b,S [Reads: Accumulator, Stack Pointer]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($F858.w,X)		; 7C 58 F8 ; Jump indirect indexed to ($F858.w,X) [Reads: X Index] [Flow: jump]
	.db $50, $F8		; 50 F8 ; Branch if overflow clear to $50, $F8 [Flow: branch]
	.db $80, $88		; 80 88 ; Branch always to $80, $88 [Flow: branch]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $BC0700.l		; 22 00 07 BC ; Jump to subroutine long $BC0700.l [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $004FE0.l,X		; FF E0 4F 00 ; Subtract with carry (long,X) $004FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $0817.w		; 0C 17 08 ; Test and set bits $0817.w [Reads: Accumulator] [Flags: Z]
	rol $19.b		; 26 19 ; Rotate left $19.b [Reads: Direct Page] [Flags: ZNC]
	rol $2F11.w		; 2E 11 2F ; Rotate left $2F11.w [Flags: ZNC]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $3918.w		; 1C 18 39 ; Test and reset bits $3918.w [Reads: Accumulator] [Flags: Z]
	and ($30.b),Y		; 31 30 ; AND accumulator with memory ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$3000.w		; C0 00 30 ; Compare #$3000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$50A8.w		; C0 A8 50 ; Compare #$50A8.w with Y register [Reads: Y Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $90, $F4		; 90 F4 ; Branch if carry clear to $90, $F4 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $68.b,X		; 94 68 ; Store Y register $68.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpx $8CFC.w		; EC FC 8C ; Compare $8CFC.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $09.b,X		; 16 09 ; Arithmetic shift left $09.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and $1A.b		; 25 1A ; Logical AND $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $010010.l		; 2F 10 00 01 ; AND accumulator with memory (long) $010010.l [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3A1B.w,X		; 1D 1B 3A ; OR accumulator with memory $3A1B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	cpx #$1E83.w		; E0 83 1E ; Compare #$1E83.w with X register [Reads: X Index] [Flags: ZNC]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $58.b		; A4 58 ; Load $58.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$D8F0.w		; E0 F0 D8 ; Compare #$D8F0.w with X register [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jmp $00851C.l		; 5C 1C 85 00 ; Jump long to $00851C.l [Flow: jump]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b,X		; 15 0A ; OR accumulator with memory $0A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $09.b,X		; 16 09 ; Arithmetic shift left $09.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and $2F12.w		; 2D 12 2F ; Logical AND $2F12.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $10, $2B		; 10 2B ; Branch if plus to $10, $2B [Flow: branch]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $321B.w,X		; 1E 1B 32 ; Arithmetic shift left $321B.w,X [Reads: X Index] [Flags: ZNC]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	sta $18.b		; 85 18 ; Store accumulator to $18.b [Reads: Accumulator]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $E8		; 30 E8 ; Branch if minus to $30, $E8 [Flow: branch]
	.db $10, $43		; 10 43 ; Branch if plus to $10, $43 [Flow: branch]
	pea $0908.w		; F4 08 09 ; Push absolute address $0908.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	pei ($28.b)		; D4 28 ; Push effective indirect address ($28.b) [Reads: Direct Page] [Writes: Stack Pointer]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $2C0C.w		; 0C 0C 2C ; Test and set bits $2C0C.w [Reads: Accumulator] [Flags: Z]
	sta $30.b,S		; 83 30 ; Store accumulator (stack relative) $30.b,S [Reads: Accumulator, Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor $7F4330.l		; 4F 30 43 7F ; Exclusive OR accumulator with memory (long) $7F4330.l [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	lsr $D8.b,X		; 56 D8 ; Logical shift right $D8.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ror $5678.w,X		; 7E 78 56 ; Rotate right $5678.w,X [Reads: X Index] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sty $00.b,X		; 94 00 ; Store Y register $00.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	inc $FD00.w,X		; FE 00 FD ; Increment memory $FD00.w,X [Reads: X Index] [Flags: ZN]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $940800.l		; 22 00 08 94 ; Jump to subroutine long $940800.l [Writes: Stack Pointer] [Flow: call]
	nop		; EA ; No operation
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $00FD1D.l		; EF 1D FD 00 ; Subtract with carry (long) $00FD1D.l [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $0F,$00		; 44 00 0F ; Move block positive $0F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $1F.b		; 45 1F ; Exclusive OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $070000.l		; 6F 00 00 07 ; Add with carry (long) $070000.l [Writes: Accumulator] [Flags: ZVNC]
	ora #$0E.b		; 09 0E ; Logical OR #$0E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $18.b,X		; 16 18 ; Arithmetic shift left $18.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	asl $68.b,X		; 16 68 ; Arithmetic shift left $68.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$D000.w		; E0 00 D0 ; Compare #$D000.w with X register [Reads: X Index] [Flags: ZNC]
	jsr $807C.w		; 20 7C 80 ; Jump to subroutine at $807C.w [Writes: Stack Pointer] [Flow: call]
	dec $4530.w		; CE 30 45 ; Decrement $4530.w [Flags: ZN]
	inc $E000.w,X		; FE 00 E0 ; Increment memory $E000.w,X [Reads: X Index] [Flags: ZN]
	and [$80.b],Y		; 37 80 ; AND accumulator with memory (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $CC		; 70 CC ; Branch if overflow set to $70, $CC [Flow: branch]
	sbc ($3A.b)		; F2 3A ; Subtract with carry (indirect) ($3A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($32.b)		; F2 32 ; Subtract with carry (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc ($00.b,S),Y		; 73 00 ; Add with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $08D710.l		; EF 10 D7 08 ; Subtract with carry (long) $08D710.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $00FF00.l		; CF 00 FF 00 ; Compare accumulator (long) $00FF00.l [Reads: Accumulator] [Flags: ZNC]
	adc $210080.l,X		; 7F 80 00 21 ; Add long $210080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($BC.b)		; 52 BC ; Exclusive OR accumulator with memory (indirect) ($BC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $3648.w,X		; 5E 48 36 ; Logical shift right $3648.w,X [Reads: X Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	stx $D700.w		; 8E 00 D7 ; Store X register to $D700.w [Reads: X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	.db $10, $F3		; 10 F3 ; Branch if plus to $10, $F3 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $8A.b		; 04 8A ; Test and set bits $8A.b [Reads: Accumulator] [Flags: Z]
	eor $12FA.w,X		; 5D FA 12 ; Exclusive OR accumulator with memory $12FA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx $891D.w		; EC 1D 89 ; Compare $891D.w with X register [Reads: X Index] [Flags: ZNC]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	ora ($DF.b,X)		; 01 DF ; Logical OR ($DF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr $FF43.w		; 20 43 FF ; Jump to subroutine at $FF43.w [Writes: Stack Pointer] [Flow: call]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$0200.w		; A0 00 02 ; Load #$0200.w into Y register [Writes: Y Index] [Flags: ZN]
	inc $B8.b,X		; F6 B8 ; Increment memory $B8.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	ldx $0023.w,Y		; BE 23 00 ; Load X register $0023.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldy $2200.w		; AC 00 22 ; Load $2200.w into Y register [Writes: Y Index] [Flags: ZN]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$44.b]		; 07 44 ; OR accumulator with memory (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora #$0E.b		; 09 0E ; Logical OR #$0E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $80.b		; 02 80 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F0,$00		; 44 00 F0 ; Move block positive $F0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $800500.l		; 22 00 05 80 ; Jump to subroutine long $800500.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $50, $30		; 50 30 ; Branch if overflow clear to $50, $30 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $2F.b		; 45 2F ; Exclusive OR $2F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	and [$08.b],Y		; 37 08 ; AND accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $300700.l		; 22 00 07 30 ; Jump to subroutine long $300700.l [Writes: Stack Pointer] [Flow: call]
	bit $3E3E.w,X		; 3C 3E 3E ; Test bits $3E3E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora [$09.b],Y		; 17 09 ; OR accumulator with memory (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $F4.b		; 45 F4 ; Exclusive OR $F4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $EC.b		; 06 EC ; Arithmetic shift left $EC.b [Reads: Direct Page] [Flags: ZNC]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	cpx #$00F0.w		; E0 F0 00 ; Compare #$00F0.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$0022.w		; E0 22 00 ; Compare #$0022.w with X register [Reads: X Index] [Flags: ZNC]
	ora #$0C.b		; 09 0C ; Logical OR #$0C.b with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $7C7C.w,X		; 3C 7C 7C ; Test bits $7C7C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $90, $E0		; 90 E0 ; Branch if carry clear to $90, $E0 [Flow: branch]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $43		; 10 43 ; Branch if plus to $10, $43 [Flow: branch]
	rol $0611.w		; 2E 11 06 ; Rotate left $0611.w [Flags: ZNC]
	and $083700.l,X		; 3F 00 37 08 ; AND accumulator with memory (long,X) $083700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $1B.b		; 24 1B ; Test bits $1B.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $140022.l,X		; 1F 22 00 14 ; Logical OR long $140022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $37		; 30 37 ; Branch if minus to $30, $37 [Flow: branch]
	and $3F282E.l,X		; 3F 2E 28 3F ; AND accumulator with memory (long,X) $3F282E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $18E400.l,X		; 1F 00 E4 18 ; Logical OR long $18E400.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	cpy #$8060.w		; C0 60 80 ; Compare #$8060.w with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $1C1400.l		; 22 00 14 1C ; Jump to subroutine long $1C1400.l [Writes: Stack Pointer] [Flow: call]
	bit $F078.w,X		; 3C 78 F0 ; Test bits $F078.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx #$80C0.w		; E0 C0 80 ; Compare #$80C0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2F.b,S),Y		; 13 2F ; OR accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $27		; 10 27 ; Branch if plus to $10, $27 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($0C.b,S),Y		; 33 0C ; AND accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $220303.l		; 0F 03 03 22 ; OR accumulator with memory (long) $220303.l [Writes: Accumulator] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($30.b,S),Y		; 33 30 ; AND accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $0F1F.w,X		; 3C 1F 0F ; Test bits $0F1F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $C8.b,X		; 34 C8 ; Test bits $C8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	pea $E408.w		; F4 08 E4 ; Push absolute address $E408.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpy $8830.w		; CC 30 88 ; Compare $8830.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$22C0.w		; C0 C0 22 ; Compare #$22C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $1C0C.w		; CC 0C 1C ; Compare $1C0C.w with Y register [Reads: Y Index] [Flags: ZNC]
	bit $F0F8.w,X		; 3C F8 F0 ; Test bits $F0F8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpy #$0046.w		; C0 46 00 ; Compare #$0046.w with Y register [Reads: Y Index] [Flags: ZNC]
	adc $003F43.l,X		; 7F 43 3F 00 ; Add long $003F43.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	lsr $3A49.w		; 4E 49 3A ; Logical shift right $3A49.w [Flags: ZNC]
	and $001E.w		; 2D 1E 00 ; Logical AND $001E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F8,$00		; 44 00 F8 ; Move block positive $F8,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7C,$00		; 44 00 7C ; Move block positive $7C,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$3823.w		; E0 23 38 ; Compare #$3823.w with X register [Reads: X Index] [Flags: ZNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $6888.w		; F4 88 68 ; Push absolute address $6888.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jmp.w [$4444]		; DC 44 44 ; Jump long indirect [$4444] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $619E00.l,X		; FF 00 9E 61 ; Subtract with carry (long,X) $619E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $027D00.l,X		; 7F 00 7D 02 ; Add long $027D00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $9D01.w,X		; FE 01 9D ; Increment memory $9D01.w,X [Reads: X Index] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($0800.w,X)		; 7C 00 08 ; Jump indirect indexed to ($0800.w,X) [Reads: X Index] [Flow: jump]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc #$7F.b		; E9 7F ; Subtract #$7F.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	adc ($97.b,S),Y		; 73 97 ; Add with carry (stack relative indirect indexed) ($97.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0874.w		; ED 74 08 ; Subtract $0874.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	jmp.w [$4320]		; DC 20 43 ; Jump long indirect [$4320] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	cpy #$24C0.w		; C0 C0 24 ; Compare #$24C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($88E8.w,X)		; FC E8 88 ; Jump to subroutine indirect indexed ($88E8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $F6.b		; 14 F6 ; Test and reset bits $F6.b [Reads: Accumulator] [Flags: Z]
	ora #$FF.b		; 09 FF ; Logical OR #$FF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F60600.l		; 22 00 06 F6 ; Jump to subroutine long $F60600.l [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	stz $AFDF.w,X		; 9E DF AF ; Store zero to $AFDF.w,X [Reads: X Index]
	sta $138370.l		; 8F 70 83 13 ; Store accumulator (long) $138370.l [Reads: Accumulator]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D7.b		; 00 D7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	adc $00FF90.l		; 6F 90 FF 00 ; Add with carry (long) $00FF90.l [Writes: Accumulator] [Flags: ZVNC]
	asl $0022.w		; 0E 22 00 ; Arithmetic shift left $0022.w [Flags: ZNC]
	asl $EF.b		; 06 EF ; Arithmetic shift left $EF.b [Reads: Direct Page] [Flags: ZNC]
	ora ($F9.b)		; 12 F9 ; OR accumulator with memory (indirect) ($F9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $F1.b,X		; F5 F1 ; Subtract $F1.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	asl $0044.w		; 0E 44 00 ; Arithmetic shift left $0044.w [Flags: ZNC]
	sbc $057A02.l,X		; FF 02 7A 05 ; Subtract with carry (long,X) $057A02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $3E0044.l,X		; 1F 44 00 3E ; Logical OR long $3E0044.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $980600.l		; 22 00 06 98 ; Jump to subroutine long $980600.l [Writes: Stack Pointer] [Flow: call]
	stz $1777.w,X		; 9E 77 17 ; Store zero to $1777.w,X [Reads: X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsl $00441C.l		; 22 1C 44 00 ; Jump to subroutine long $00441C.l [Writes: Stack Pointer] [Flow: call]
	sbc $A05E02.l,X		; FF 02 5E A0 ; Subtract with carry (long,X) $A05E02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	mvp $7C,$00		; 44 00 7C ; Move block positive $7C,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $190600.l		; 22 00 06 19 ; Jump to subroutine long $190600.l [Writes: Stack Pointer] [Flow: call]
	sbc $E8EE.w,Y		; F9 EE E8 ; Subtract with carry $E8EE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	mvn $38,$44		; 54 44 38 ; Move block negative $38,$44 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	and $007F43.l,X		; 3F 43 7F 00 ; AND accumulator with memory (long,X) $007F43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $27.b,S		; 23 27 ; AND accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $384F.w,X		; 5E 4F 38 ; Logical shift right $384F.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	mvp $F0,$00		; 44 00 F0 ; Move block positive $F0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sta $2E.b,S		; 83 2E ; Store accumulator (stack relative) $2E.b,S [Reads: Accumulator, Stack Pointer]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	bit $02.b,X		; 34 02 ; Test bits $02.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cpx #$682E.w		; E0 2E 68 ; Compare #$682E.w with X register [Reads: X Index] [Flags: ZNC]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cpx $4456.w		; EC 56 44 ; Compare $4456.w with X register [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $5A00.w,X		; 3C 00 5A ; Test bits $5A00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $3C42.w,X		; 3C 42 3C ; Test bits $3C42.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	ror $5A00.w,X		; 7E 00 5A ; Rotate right $5A00.w,X [Reads: X Index] [Flags: ZNC]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $425A.w,X		; 3C 5A 42 ; Test bits $425A.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $42, $66		; 42 66 ; Reserved instruction
	ror $8824.w,X		; 7E 24 88 ; Rotate right $8824.w,X [Reads: X Index] [Flags: ZNC]
	brk $79.b		; 00 79 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $6E		; 10 6E ; Branch if plus to $10, $6E [Flow: branch]
	.db $30, $42		; 30 42 ; Branch if minus to $30, $42 [Flow: branch]
	bit $1826.w,X		; 3C 26 18 ; Test bits $1826.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $100300.l		; 22 00 03 10 ; Jump to subroutine long $100300.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $02.b,S		; 83 02 ; Store accumulator (stack relative) $02.b,S [Reads: Accumulator, Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$11.b		; 29 11 ; Logical AND #$11.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $251F22.l		; 0F 22 1F 25 ; OR accumulator with memory (long) $251F22.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ror $39.b		; 66 39 ; Rotate right $39.b [Reads: Direct Page] [Flags: ZNC]
	lsr $39.b,X		; 56 39 ; Logical shift right $39.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2311.w		; 0C 11 23 ; Test and set bits $2311.w [Reads: Accumulator] [Flags: Z]
	and $62.b		; 25 62 ; Logical AND $62.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $70, $07		; 70 07 ; Branch if overflow set to $70, $07 [Flow: branch]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $473F46.l,X		; 1F 46 3F 47 ; Logical OR long $473F46.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta [$79.b]		; 87 79 ; Store accumulator (long) [$79.b] [Reads: Accumulator, Direct Page]
	dec $79.b		; C6 79 ; Decrement $79.b [Reads: Direct Page] [Flags: ZN]
	ldx #$077D.w		; A2 7D 07 ; Load #$077D.w into X register [Writes: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($47.b,X)		; 21 47 ; Logical AND ($47.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor [$83.b]		; 47 83 ; Exclusive OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy #$23E0.w		; C0 E0 23 ; Compare #$23E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$44.b]		; 07 44 ; OR accumulator with memory (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $830022.l		; 0F 22 00 83 ; OR accumulator with memory (long) $830022.l [Writes: Accumulator] [Flags: ZN]
	adc $01.b,S		; 63 01 ; Add with carry (stack relative) $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $016A84.l		; 0F 84 6A 01 ; OR accumulator with memory (long) $016A84.l [Writes: Accumulator] [Flags: ZN]
	mvp $F0,$00		; 44 00 F0 ; Move block positive $F0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sta $E8.b,S		; 83 E8 ; Store accumulator (stack relative) $E8.b,S [Reads: Accumulator, Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	stx $78.b		; 86 78 ; Store X register to $78.b [Reads: X Index]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $68		; 10 68 ; Branch if plus to $10, $68 [Flow: branch]
	ora $039F00.l		; 0F 00 9F 03 ; OR accumulator with memory (long) $039F00.l [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	ora $1E61.w,X		; 1D 61 1E ; OR accumulator with memory $1E61.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($2C.b,S),Y		; 73 2C ; Add with carry (stack relative indirect indexed) ($2C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $C7.b		; 45 C7 ; Exclusive OR $C7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx #$074F.w		; E0 4F 07 ; Compare #$074F.w with X register [Reads: X Index] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $6C5E.w,X		; 3D 5E 6C ; AND accumulator with memory $6C5E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($FAFE.w,X)		; FC FE FA ; Jump to subroutine indirect indexed ($FAFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$F900.w		; E0 00 F9 ; Compare #$F900.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$F81E.w		; E0 1E F8 ; Compare #$F81E.w with X register [Reads: X Index] [Flags: ZNC]
	stx $78.b		; 86 78 ; Store X register to $78.b [Reads: X Index]
	dec $E334.w		; CE 34 E3 ; Decrement $E334.w [Flags: ZN]
	asl $1CE3.w,X		; 1E E3 1C ; Arithmetic shift left $1CE3.w,X [Reads: X Index] [Flags: ZNC]
	sbc [$1A.b]		; E7 1A ; Subtract with carry (long) [$1A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$FCF8.w		; E0 F8 FC ; Compare #$FCF8.w with X register [Reads: X Index] [Flags: ZNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	rol $3E.b,X		; 36 3E ; Rotate left $3E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc $015B.w,X		; 7D 5B 01 ; Add $015B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $0C1F0C.l		; 4F 0C 1F 0C ; Exclusive OR accumulator with memory (long) $0C1F0C.l [Writes: Accumulator] [Flags: ZN]
	and $1F3A15.l,X		; 3F 15 3A 1F ; AND accumulator with memory (long,X) $1F3A15.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $00017C.l,X		; 1F 7C 01 00 ; Logical OR long $00017C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $0D.b,S		; 43 0D ; Exclusive OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1C5812.l		; 0F 12 58 1C ; OR accumulator with memory (long) $1C5812.l [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$50E0.w		; E0 E0 50 ; Compare #$50E0.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	bit $1CE8.w,X		; 3C E8 1C ; Test bits $1CE8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F8F0.w		; E0 F0 F8 ; Compare #$F8F0.w with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $271C.w,X		; 3C 1C 27 ; Test bits $271C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E5100.l		; 0F 00 51 0E ; OR accumulator with memory (long) $0E5100.l [Writes: Accumulator] [Flags: ZN]
	eor $EF.b,S		; 43 EF ; Exclusive OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $B2B15F.l		; 0F 5F B1 B2 ; OR accumulator with memory (long) $B2B15F.l [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$E0.b		; 09 E0 ; Logical OR #$E0.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$709E.w		; E0 9E 70 ; Compare #$709E.w with X register [Reads: X Index] [Flags: ZNC]
	sta $729D70.l,X		; 9F 70 9D 72 ; Store accumulator (long,X) $729D70.l,X [Reads: Accumulator, X Index]
	jsl $E00900.l		; 22 00 09 E0 ; Jump to subroutine long $E00900.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $7E		; F0 7E ; Branch if equal to $F0, $7E [Flow: branch]
	adc $607B.w,X		; 7D 7B 60 ; Add $607B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FF,$00		; 44 00 FF ; Move block positive $FF,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($BF.b)		; 12 BF ; OR accumulator with memory (indirect) ($BF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor $002F20.l,X		; 5F 20 2F 00 ; Exclusive OR accumulator with memory (long,X) $002F20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta ($9A.b),Y		; 91 9A ; Store accumulator ($9A.b),Y [Reads: Accumulator, Direct Page, Y Index]
	ldx $B8.b,Y		; B6 B8 ; Load X register $B8.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	dec $78.b,X		; D6 78 ; Decrement memory $78.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	rol $0006.w		; 2E 06 00 ; Rotate left $0006.w [Flags: ZNC]
	ora $449F00.l		; 0F 00 9F 44 ; OR accumulator with memory (long) $449F00.l [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $02FD.w		; 0E FD 02 ; Arithmetic shift left $02FD.w [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$99.b		; 09 99 ; Logical OR #$99.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $EB1D.w		; ED 1D EB ; Subtract $EB1D.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	asl $10FC.w,X		; 1E FC 10 ; Arithmetic shift left $10FC.w,X [Reads: X Index] [Flags: ZNC]
	mvp $38,$00		; 44 00 38 ; Move block positive $38,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $78.b		; 45 78 ; Exclusive OR $78.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $100600.l		; 22 00 06 10 ; Jump to subroutine long $100600.l [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	sty $31.b		; 84 31 ; Store Y register to $31.b [Reads: Y Index]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $037C00.l,X		; 3F 00 7C 03 ; AND accumulator with memory (long,X) $037C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	bit $43.b		; 24 43 ; Test bits $43.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $E000.w,X		; 3C 00 E0 ; Test bits $E000.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $18.b		; 25 18 ; Logical AND $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$38.b]		; 07 38 ; OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $67.b,S		; 43 67 ; Exclusive OR accumulator with stack relative $67.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $24.b,X		; 34 24 ; Test bits $24.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $4200.w,X		; 3C 00 42 ; Test bits $4200.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $7E99.w,X		; 3C 99 7E ; Test bits $7E99.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $00FF3C.l,X		; FF 3C FF 00 ; Subtract with carry (long,X) $00FF3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $6600.w,X		; BD 00 66 ; Load $6600.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $99		; 42 99 ; Reserved instruction
	cmp $BD.b,S		; C3 BD ; Compare accumulator (stack relative) $BD.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ror $003C.w,X		; 7E 3C 00 ; Rotate right $003C.w,X [Reads: X Index] [Flags: ZNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $B543.w,X		; 3C 43 B5 ; Test bits $B543.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lsr $3FE0.w		; 4E E0 3F ; Logical shift right $3FE0.w [Flags: ZNC]
	cmp #$7E.b		; C9 7E ; Compare #$7E.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	lda ($7E.b),Y		; B1 7E ; Load accumulator ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $42, $3C		; 42 3C ; Reserved instruction
	bit $3C00.w,X		; 3C 00 3C ; Test bits $3C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	cmp $F9CD.w		; CD CD F9 ; Compare $F9CD.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	lda ($42.b),Y		; B1 42 ; Load accumulator ($42.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $1D6E.w,X		; 3C 6E 1D ; Test bits $1D6E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	adc $003F03.l,X		; 7F 03 3F 00 ; Add long $003F03.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $002F10.l,X		; 3F 10 2F 00 ; AND accumulator with memory (long,X) $002F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0500.w,Y		; 19 00 05 ; OR accumulator with memory $0500.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $30.b,S		; 43 30 ; Exclusive OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	and $02071F.l,X		; 3F 1F 07 02 ; AND accumulator with memory (long,X) $02071F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $50, $3F		; 50 3F ; Branch if overflow clear to $50, $3F [Flow: branch]
	jmp ($3F0F.w,X)		; 7C 0F 3F ; Jump indirect indexed to ($3F0F.w,X) [Reads: X Index] [Flow: jump]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr $08AF.w		; 20 AF 08 ; Jump to subroutine at $08AF.w [Writes: Stack Pointer] [Flow: call]
	eor ($00.b,S),Y		; 53 00 ; XOR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $70, $4C		; 70 4C ; Branch if overflow set to $70, $4C [Flow: branch]
	and $58.b,S		; 23 58 ; AND accumulator with stack relative $58.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	pea $1F5F.w		; F4 5F 1F ; Push absolute address $1F5F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora #$45.b		; 09 45 ; Logical OR #$45.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $070200.l		; 0F 00 02 07 ; OR accumulator with memory (long) $070200.l [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $07,$00		; 44 00 07 ; Move block positive $07,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $030708.l		; 0F 08 07 03 ; OR accumulator with memory (long) $030708.l [Writes: Accumulator] [Flags: ZN]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $F8.b,S		; 03 F8 ; OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	mvp $F0,$00		; 44 00 F0 ; Move block positive $F0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $E0.b		; 05 E0 ; Logical OR $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	sta $A2.b,S		; 83 A2 ; Store accumulator (stack relative) $A2.b,S [Reads: Accumulator, Stack Pointer]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor $18.b,S		; 43 18 ; Exclusive OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $70, $10		; 70 10 ; Branch if overflow set to $70, $10 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $90		; 30 90 ; Branch if minus to $30, $90 [Flow: branch]
	cpx #$3C63.w		; E0 63 3C ; Compare #$3C63.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $4F47BC.l,X		; 1F BC 47 4F ; Logical OR long $4F47BC.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($37.b,S),Y		; 33 37 ; AND accumulator (stack relative indirect indexed) ($37.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $1212.w		; 2D 12 12 ; Logical AND $1212.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7FFF7F.l		; 0F 7F FF 7F ; OR accumulator with memory (long) $7FFF7F.l [Writes: Accumulator] [Flags: ZN]
	and $C6123F.l,X		; 3F 3F 12 C6 ; AND accumulator with memory (long,X) $C6123F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $DC26.w,X		; 3C 26 DC ; Test bits $DC26.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $3DE8.w,X		; 1E E8 3D ; Arithmetic shift left $3DE8.w,X [Reads: X Index] [Flags: ZNC]
.ACCU 8
.INDEX 8
	sep #$FE		; E2 FE
	cpy #$EC.b		; C0 EC ; Compare #$EC.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $B4		; 10 B4 ; Branch if plus to $10, $B4 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $F7EE.w,X		; DE EE F7 ; Decrement memory $F7EE.w,X [Reads: X Index] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	jsr ($48FC.w,X)		; FC FC 48 ; Jump to subroutine indirect indexed ($48FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $8F7E.w,X		; 1D 7E 8F ; OR accumulator with memory $8F7E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($7F0F.w,X)		; FC 0F 7F ; Jump to subroutine indirect indexed ($7F0F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $8B.b,S		; 83 8B ; Store accumulator (stack relative) $8B.b,S [Reads: Accumulator, Stack Pointer]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and [$1C.b],Y		; 37 1C ; AND accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sty $070F.w		; 8C 0F 07 ; Store Y register to $070F.w [Reads: Y Index]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	jmp $F0F830.l		; 5C 30 F8 F0 ; Jump long to $F0F830.l [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cop $E2.b		; 02 E2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $F8F8.w		; 1C F8 F8 ; Test and reset bits $F8F8.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $57.b		; 00 57 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	nop		; EA ; No operation
	ora $FF.b,X		; 15 FF ; OR accumulator with memory $FF.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$57.b		; 09 57 ; Logical OR #$57.b with accumulator [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	adc $043B10.l		; 6F 10 3B 04 ; Add with carry (long) $043B10.l [Writes: Accumulator] [Flags: ZVNC]
	ora $FF7A00.l		; 0F 00 7A FF ; OR accumulator with memory (long) $FF7A00.l [Writes: Accumulator] [Flags: ZN]
	ldy $6F8D.w,X		; BC 8D 6F ; Load Y register $6F8D.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc $430F3C.l,X		; 7F 3C 0F 43 ; Add long $430F3C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $1370.w,X		; 9E 70 13 ; Store zero to $1370.w,X [Reads: X Index]
	and $DCE3E0.l,X		; 3F E0 E3 DC ; AND accumulator with memory (long,X) $DCE3E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $7606.w,Y		; F9 06 76 ; Subtract with carry $7606.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	bit $D8.b		; 24 D8 ; Test bits $D8.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FFF9.w,X		; 7E F9 FF ; Rotate right $FFF9.w,X [Reads: X Index] [Flags: ZNC]
	cmp $F8FCEE.l,X		; DF EE FC F8 ; Compare accumulator (long,X) $F8FCEE.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	eor $0F.b,S		; 43 0F ; Exclusive OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $3E,$00		; 44 00 3E ; Move block positive $3E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $080200.l		; 22 00 02 08 ; Jump to subroutine long $080200.l [Writes: Stack Pointer] [Flow: call]
	asl $8317.w		; 0E 17 83 ; Arithmetic shift left $8317.w [Flags: ZNC]
	lda ($02.b,S),Y		; B3 02 ; Load accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	mvp $F0,$00		; 44 00 F0 ; Move block positive $F0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $58.b		; 02 58 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$F8.b		; A0 F8 ; Load #$F8.b into Y register [Writes: Y Index] [Flags: ZN]
	mvp $7C,$00		; 44 00 7C ; Move block positive $7C,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $100200.l		; 22 00 02 10 ; Jump to subroutine long $100200.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	sta $CB.b,S		; 83 CB ; Store accumulator (stack relative) $CB.b,S [Reads: Accumulator, Stack Pointer]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$24.b		; 09 24 ; Logical OR #$24.b with accumulator [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sta $2C.b,S		; 83 2C ; Store accumulator (stack relative) $2C.b,S [Reads: Accumulator, Stack Pointer]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $43		; 10 43 ; Branch if plus to $10, $43 [Flow: branch]
	jsr ($0D00.w,X)		; FC 00 0D ; Jump to subroutine indirect indexed ($0D00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ror $1610.w		; 6E 10 16 ; Rotate right $1610.w [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0A.b,X		; 15 0A ; OR accumulator with memory $0A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $A4.b,X		; 74 A4 ; Store zero to $A4.b,X [Reads: X Index]
	sty $72.b		; 84 72 ; Store Y register to $72.b [Reads: Y Index]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $03002B.l,X		; FF 2B 00 03 ; Subtract with carry (long,X) $03002B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$2B.b]		; 07 2B ; OR accumulator with memory (long) [$2B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($C0.b,X)		; 01 C0 ; Logical OR ($C0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: ZNC]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0D07.w		; 0E 07 0D ; Arithmetic shift left $0D07.w [Flags: ZNC]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $001483.l		; 0F 83 14 00 ; OR accumulator with memory (long) $001483.l [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $1F0D.w		; 0E 0D 1F ; Arithmetic shift left $1F0D.w [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$43.b		; C0 43 ; Compare #$43.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	ora $78.b,S		; 03 78 ; OR accumulator with stack relative $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	.db $F0, $83		; F0 83 ; Branch if equal to $F0, $83 [Flow: branch]
	bit $0300.w		; 2C 00 03 ; Test bits $0300.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1A.b]		; 07 1A ; OR accumulator with memory (long) [$1A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0024.w		; 0D 24 00 ; Logical OR $0024.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00291D.l		; 0F 1D 29 00 ; OR accumulator with memory (long) $00291D.l [Writes: Accumulator] [Flags: ZN]
	ora $C0.b		; 05 C0 ; Logical OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$38.b		; C0 38 ; Compare #$38.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	mvp $27,$00		; 44 00 27 ; Move block positive $27,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($47.b)		; 12 47 ; OR accumulator with memory (indirect) ($47.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3838.w		; 1C 38 38 ; Test and reset bits $3838.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp ($7F7E.w,X)		; 7C 7E 7F ; Jump indirect indexed to ($7F7E.w,X) [Reads: X Index] [Flow: jump]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	mvp $FC,$00		; 44 00 FC ; Move block positive $FC,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $00FE.w,Y		; 19 FE 00 ; OR accumulator with memory $00FE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $CE00.w		; EE 00 CE ; Increment $CE00.w [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($72.b)		; 32 72 ; AND accumulator with memory (indirect) ($72.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $8600.w,Y		; 79 00 86 ; Add $8600.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $82, $7C, $84		; 82 7C 84 ; Branch always long to $82, $7C, $84 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor $44.b		; 45 44 ; Exclusive OR $44.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	adc $8387.w,Y		; 79 87 83 ; Add $8387.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta [$22.b]		; 87 22 ; Store accumulator (long) [$22.b] [Reads: Accumulator, Direct Page]
	eor [$02.b]		; 47 02 ; Exclusive OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $BF00.w,X		; 7E 00 BF ; Rotate right $BF00.w,X [Reads: X Index] [Flags: ZNC]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	adc $003E07.l,X		; 7F 07 3E 00 ; Add long $003E07.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $EF00.w		; 1C 00 EF ; Test and reset bits $EF00.w [Reads: Accumulator] [Flags: Z]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($22.b,X)		; C1 22 ; Compare accumulator ($22.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	cmp ($E3.b,X)		; C1 E3 ; Compare accumulator ($E3.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $C0,$00		; 44 00 C0 ; Move block positive $C0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor [$E0.b]		; 47 E0 ; Exclusive OR accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$4A.b		; E0 4A ; Compare #$4A.b with X register [Reads: X Index] [Flags: ZNC]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $7B.b		; 04 7B ; Test and set bits $7B.b [Reads: Accumulator] [Flags: Z]
	tsb $FD.b		; 04 FD ; Test and set bits $FD.b [Reads: Accumulator] [Flags: Z]
	cop $5D.b		; 02 5D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($36.b)		; 12 36 ; OR accumulator with memory (indirect) ($36.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1D.b		; 05 1D ; Logical OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $867D.w		; 0D 7D 86 ; Logical OR $867D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ror $0B3B.w		; 6E 3B 0B ; Rotate right $0B3B.w [Flags: ZNC]
	ora $FF00FD.l,X		; 1F FD 00 FF ; Logical OR long $FF00FD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00DE.w,X		; 1E DE 00 ; Arithmetic shift left $00DE.w,X [Reads: X Index] [Flags: ZNC]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($80.b,X)		; 61 80 ; Add with carry ($80.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $BFF1CE.l,X		; 3F CE F1 BF ; AND accumulator with memory (long,X) $BFF1CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($5E.b,X)		; E1 5E ; Subtract with carry ($5E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($A1.b,X)		; 61 A1 ; Add with carry ($A1.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F800.w,X)		; FC 00 F8 ; Jump to subroutine indirect indexed ($F800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $30		; 80 30 ; Branch always to $80, $30 [Flow: branch]
	cpy #$7C.b		; C0 7C ; Compare #$7C.b with Y register [Reads: Y Index] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $F681.w,X		; FE 81 F6 ; Increment memory $F681.w,X [Reads: X Index] [Flags: ZN]
	jsr ($F0F0.w,X)		; FC F0 F0 ; Jump to subroutine indirect indexed ($F0F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $4C.b		; 02 4C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	asl $0F03.w		; 0E 03 0F ; Arithmetic shift left $0F03.w [Flags: ZNC]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $3F,$00		; 44 00 3F ; Move block positive $3F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0F0D00.l		; 22 00 0D 0F ; Jump to subroutine long $0F0D00.l [Writes: Stack Pointer] [Flow: call]
	tsb $3F1C.w		; 0C 1C 3F ; Test and set bits $3F1C.w [Reads: Accumulator] [Flags: Z]
	and $00071F.l,X		; 3F 1F 07 00 ; AND accumulator with memory (long,X) $00071F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $C0		; 70 C0 ; Branch if overflow set to $70, $C0 [Flow: branch]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	jsr ($0200.w,X)		; FC 00 02 ; Jump to subroutine indirect indexed ($0200.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F00C00.l		; 22 00 0C F0 ; Jump to subroutine long $F00C00.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	ora $310E.w,Y		; 19 0E 31 ; OR accumulator with memory $310E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $4439.w,X		; 1E 39 44 ; Arithmetic shift left $4439.w,X [Reads: X Index] [Flags: ZNC]
	ora $1F073F.l,X		; 1F 3F 07 1F ; Logical OR long $1F073F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3F22.w,X		; 3E 22 3F ; Rotate left $3F22.w,X [Reads: X Index] [Flags: ZNC]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora $50F803.l		; 0F 03 F8 50 ; OR accumulator with memory (long) $50F803.l [Writes: Accumulator] [Flags: ZN]
	mvp $58,$FC		; 44 FC 58 ; Move block positive $58,$FC [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $F8.b,S		; 43 F8 ; Exclusive OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jmp $CE835C.l		; 5C 5C 83 CE ; Jump long to $CE835C.l [Flow: jump]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpy #$18.b		; C0 18 ; Compare #$18.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora $611E31.l		; 0F 31 1E 61 ; OR accumulator with memory (long) $611E31.l [Writes: Accumulator] [Flags: ZN]
	rol $3F73.w,X		; 3E 73 3F ; Rotate left $3F73.w,X [Reads: X Index] [Flags: ZNC]
	adc $1F3F3F.l,X		; 7F 3F 3F 1F ; Add long $1F3F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $000303.l,X		; 1F 03 03 00 ; Logical OR long $000303.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $7F7E3E.l,X		; 1F 3E 7E 7F ; Logical OR long $7F7E3E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $031F3F.l,X		; 7F 3F 1F 03 ; Add long $031F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $FCF8.w		; 1C F8 FC ; Test and reset bits $FCF8.w [Reads: Accumulator] [Flags: Z]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	mvp $5C,$FE		; 44 FE 5C ; Move block positive $5C,$FE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$3E.b		; E0 3E ; Compare #$3E.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $FE5E5E.l		; 5C 5E 5E FE ; Jump long to $FE5E5E.l [Flow: jump]
	jsr ($C0F8.w,X)		; FC F8 C0 ; Jump to subroutine indirect indexed ($C0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $2D.b		; 04 2D ; Test and set bits $2D.b [Reads: Accumulator] [Flags: Z]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $182F.w,X		; 3E 2F 18 ; Rotate left $182F.w,X [Reads: X Index] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $DC.b,S		; 03 DC ; OR accumulator with stack relative $DC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr $00B4.w		; 20 B4 00 ; Jump to subroutine at $00B4.w [Writes: Stack Pointer] [Flow: call]
	cpy $F800.w		; CC 00 F8 ; Compare $F800.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($18B4.w,X)		; 7C B4 18 ; Jump indirect indexed to ($18B4.w,X) [Reads: X Index] [Flow: jump]
	.db $50, $70		; 50 70 ; Branch if overflow clear to $50, $70 [Flow: branch]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	eor $3E.b,S		; 43 3E ; Exclusive OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $005D00.l,X		; 7F 00 5D 00 ; Add long $005D00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp $003E00.l		; 5C 00 3E 00 ; Jump long to $003E00.l [Flow: jump]
	and $083600.l,X		; 3F 00 36 08 ; AND accumulator with memory (long,X) $083600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $7F5E2F.l,X		; 3F 2F 5E 7F ; AND accumulator with memory (long,X) $7F5E2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$23.b],Y		; 77 23 ; Add with carry (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $AD3B.w		; 2D 3B AD ; Logical AND $AD3B.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $42, $DB		; 42 DB ; Reserved instruction
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	sbc $007D13.l,X		; FF 13 7D 00 ; Subtract with carry (long,X) $007D13.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $00.b,S		; C3 00 ; Compare accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	lda $E7.b,X		; B5 E7 ; Load $E7.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta ($E5.b,X)		; 81 E5 ; Store accumulator ($E5.b,X) [Reads: Accumulator, X Index, Direct Page]
	lda $F0FFD7.l		; AF D7 FF F0 ; Load long $F0FFD7.l into accumulator [Writes: Accumulator] [Flags: ZN]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $C4		; 30 C4 ; Branch if minus to $30, $C4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $82, $7C, $45		; 82 7C 45 ; Branch always long to $82, $7C, $45 [Flow: branch]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $82.b		; 05 82 ; Logical OR $82.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp ($C870.w,X)		; 7C 70 C8 ; Jump indirect indexed to ($C870.w,X) [Reads: X Index] [Flow: jump]
	mvp $22,$82		; 44 82 22 ; Move block positive $22,$82 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $82, $39, $06		; 82 39 06 ; Branch always long to $82, $39, $06 [Flow: branch]
	.db $42, $3C		; 42 3C ; Reserved instruction
	jmp ($002A.w,X)		; 7C 2A 00 ; Jump indirect indexed to ($002A.w,X) [Reads: X Index] [Flow: jump]
	cop $27.b		; 02 27 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $247C.w,X		; 7E 7C 24 ; Rotate right $247C.w,X [Reads: X Index] [Flags: ZNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($80.b),Y		; 71 80 ; Add with carry ($80.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda ($40.b),Y		; B1 40 ; Load accumulator ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $5840.w,Y		; B9 40 58 ; Load $5840.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $205C.w		; 20 5C 20 ; Jump to subroutine at $205C.w [Writes: Stack Pointer] [Flow: call]
	eor $2C.b,S		; 43 2C ; Exclusive OR accumulator with stack relative $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $B1.b		; 00 B1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($D9.b),Y		; D1 D9 ; Compare accumulator ($D9.b),Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	jmp ($3434.w)		; 6C 34 34 ; Jump indirect to ($3434.w) [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	.db $D0, $90		; D0 90 ; Branch if not equal to $D0, $90 [Flow: branch]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	jsl $074300.l		; 22 00 43 07 ; Jump to subroutine long $074300.l [Writes: Stack Pointer] [Flow: call]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $4F1000.l		; 0F 00 10 4F ; OR accumulator with memory (long) $4F1000.l [Writes: Accumulator] [Flags: ZN]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $7F6F4F.l		; 0F 4F 6F 7F ; OR accumulator with memory (long) $7F6F4F.l [Writes: Accumulator] [Flags: ZN]
	eor $0048C0.l,X		; 5F C0 48 00 ; Exclusive OR accumulator with memory (long,X) $0048C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$45.b		; E0 45 ; Compare #$45.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $E0.b,S		; 23 E0 ; AND accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $0C83F0.l		; 22 F0 83 0C ; Jump to subroutine long $0C83F0.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F0044.l,X		; 1F 44 00 3F ; Logical OR long $3F0044.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030300.l		; 22 00 03 03 ; Jump to subroutine long $030300.l [Writes: Stack Pointer] [Flow: call]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $9483.w,X		; 3C 83 94 ; Test bits $9483.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $136C10.l		; 2F 10 6C 13 ; AND accumulator with memory (long) $136C10.l [Writes: Accumulator] [Flags: ZN]
	eor $96.b,S		; 43 96 ; Exclusive OR accumulator with stack relative $96.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc #$0F.b		; 69 0F ; Add #$0F.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	lsr $29.b,X		; 56 29 ; Logical shift right $29.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ror $09.b,X		; 76 09 ; Rotate right $09.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $5B.b		; 24 5B ; Test bits $5B.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $37.b		; 04 37 ; Test and set bits $37.b [Reads: Accumulator] [Flags: Z]
	stz $9A.b,X		; 74 9A ; Store zero to $9A.b,X [Reads: X Index]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	eor $437D.w,X		; 5D 7D 43 ; Exclusive OR accumulator with memory $437D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $BD4300.l,X		; FF 00 43 BD ; Subtract with carry (long,X) $BD4300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$24.b]		; E7 24 ; Subtract with carry (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda $6618.w,X		; BD 18 66 ; Load $6618.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E7DB43.l,X		; FF 43 DB E7 ; Subtract with carry (long,X) $E7DB43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $F8.b,S		; 03 F8 ; OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $0213.w,X		; FE 13 02 ; Increment memory $0213.w,X [Reads: X Index] [Flags: ZN]
	jsr ($F804.w,X)		; FC 04 F8 ; Jump to subroutine indirect indexed ($F804.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($3400.w,X)		; FC 00 34 ; Jump to subroutine indirect indexed ($3400.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	eor [$58.b]		; 47 58 ; Exclusive OR accumulator with memory (long) [$58.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $2C43.w		; 20 43 2C ; Jump to subroutine at $2C43.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $68.b,S		; 23 68 ; AND accumulator with stack relative $68.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $3434.w		; 1C 34 34 ; Test and reset bits $3434.w [Reads: Accumulator] [Flags: Z]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $3600.w,X		; 7E 00 36 ; Rotate right $3600.w,X [Reads: X Index] [Flags: ZNC]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($1E.b,X)		; 61 1E ; Add with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor ($3E.b,X)		; 41 3E ; Exclusive OR accumulator with memory ($3E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $2F00.w,X		; 3E 00 2F ; Rotate left $2F00.w,X [Reads: X Index] [Flags: ZNC]
	lsr $1F2E.w,X		; 5E 2E 1F ; Logical shift right $1F2E.w,X [Reads: X Index] [Flags: ZNC]
	and $3E7F5F.l,X		; 3F 5F 7F 3E ; AND accumulator with memory (long,X) $3E7F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$44.b]		; 07 44 ; OR accumulator with memory (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $1F.b,S		; 43 1F ; Exclusive OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $060100.l,X		; 1F 00 01 06 ; Logical OR long $060100.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	trb $F01E.w		; 1C 1E F0 ; Test and reset bits $F01E.w [Reads: Accumulator] [Flags: Z]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F9,$00		; 44 00 F9 ; Move block positive $F9,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$74.b		; E0 74 ; Compare #$74.b with X register [Reads: X Index] [Flags: ZNC]
	and $F100.w,Y		; 39 00 F1 ; AND accumulator with memory $F100.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0F1E.w,X		; 3C 1E 0F ; Test bits $0F1E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp [$4F.b]		; C7 4F ; Compare accumulator (long) [$4F.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	rep #$00		; C2 00 ; Reset processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda [$40.b],Y		; B7 40 ; Load accumulator (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $2D20.w,X		; 5D 20 2D ; Exclusive OR accumulator with memory $2D20.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $77		; 10 77 ; Branch if plus to $10, $77 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	tsb $3D.b		; 04 3D ; Test and set bits $3D.b [Reads: Accumulator] [Flags: Z]
	cop $C2.b		; 02 C2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $D5.b		; A5 D5 ; Load $D5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $6D5B37.l		; 6F 37 5B 6D ; Add with carry (long) $6D5B37.l [Writes: Accumulator] [Flags: ZVNC]
	rol $0040.w,X		; 3E 40 00 ; Rotate left $0040.w,X [Reads: X Index] [Flags: ZNC]
	inc $7700.w		; EE 00 77 ; Increment $7700.w [Flags: ZN]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $BF59.w		; AE 59 BF ; Load $BF59.w into X register [Writes: X Index] [Flags: ZN]
	stz $B7CF.w,X		; 9E CF B7 ; Store zero to $B7CF.w,X [Reads: X Index]
	jsr ($0040.w,X)		; FC 40 00 ; Jump to subroutine indirect indexed ($0040.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $5200.w		; EC 00 52 ; Compare $5200.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $1CE2.w		; 0C E2 1C ; Test and set bits $1CE2.w [Reads: Accumulator] [Flags: Z]
	cmp ($3E.b,X)		; C1 3E ; Compare accumulator ($3E.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	eor $3C.b,S		; 43 3C ; Exclusive OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $DF00.w,X		; FD 00 DF ; Subtract with carry $DF00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $E272.w		; AC 72 E2 ; Load $E272.w into Y register [Writes: Y Index] [Flags: ZN]
	eor ($C3.b,X)		; 41 C3 ; Exclusive OR accumulator with memory ($C3.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $000275.l,X		; BF 75 02 00 ; Load long $000275.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $083700.l,X		; 1F 00 37 08 ; Logical OR long $083700.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $007F10.l		; 6F 10 7F 00 ; Add with carry (long) $007F10.l [Writes: Accumulator] [Flags: ZVNC]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7F6F37.l,X		; 1F 37 6F 7F ; Logical OR long $7F6F37.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	sbc $F00004.l,X		; FF 04 00 F0 ; Subtract with carry (long,X) $F00004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $0029FF.l		; 22 FF 29 00 ; Jump to subroutine long $0029FF.l [Writes: Stack Pointer] [Flow: call]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $FCFE01.l		; 0F 01 FE FC ; OR accumulator with memory (long) $FCFE01.l [Writes: Accumulator] [Flags: ZN]
	eor $00EF00.l,X		; 5F 00 EF 00 ; Exclusive OR accumulator with memory (long,X) $00EF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $040B00.l		; 4F 00 0B 04 ; Exclusive OR accumulator with memory (long) $040B00.l [Writes: Accumulator] [Flags: ZN]
	ora $0702.w		; 0D 02 07 ; Logical OR $0702.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $5F0600.l		; 22 00 06 5F ; Jump to subroutine long $5F0600.l [Writes: Stack Pointer] [Flow: call]
	sbc $0D0B4F.l		; EF 4F 0B 0D ; Subtract with carry (long) $0D0B4F.l [Writes: Accumulator] [Flags: ZVNC]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $A9.b		; 84 A9 ; Store Y register to $A9.b [Reads: Y Index]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	dec $20.b,X		; D6 20 ; Decrement memory $20.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	lda ($40.b)		; B2 40 ; Load accumulator (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	nop		; EA ; No operation
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($D6F6.w,X)		; FC F6 D6 ; Jump to subroutine indirect indexed ($D6F6.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lda ($EA.b)		; B2 EA ; Load accumulator (indirect) ($EA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy $0C.b		; C4 0C ; Compare $0C.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	sta $24.b,S		; 83 24 ; Store accumulator (stack relative) $24.b,S [Reads: Accumulator, Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	mvp $FC,$00		; 44 00 FC ; Move block positive $FC,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $C00300.l		; 22 00 03 C0 ; Jump to subroutine long $C00300.l [Writes: Stack Pointer] [Flow: call]
	cpx #$98.b		; E0 98 ; Compare #$98.b with X register [Reads: X Index] [Flags: ZNC]
	stz $AC83.w		; 9C 83 AC ; Store zero to $AC83.w
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	tsb $7B.b		; 04 7B ; Test and set bits $7B.b [Reads: Accumulator] [Flags: Z]
	tsb $7F.b		; 04 7F ; Test and set bits $7F.b [Reads: Accumulator] [Flags: Z]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $07,$00		; 44 00 07 ; Move block positive $07,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$26.b		; E0 26 ; Compare #$26.b with X register [Reads: X Index] [Flags: ZNC]
	adc $565D.w,X		; 7D 5D 56 ; Add $565D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	asl $0708.w,X		; 1E 08 07 ; Arithmetic shift left $0708.w,X [Reads: X Index] [Flags: ZNC]
	ora $C3.b		; 05 C3 ; Logical OR $C3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $FF.b		; A5 FF ; Load $FF.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $64FFE7.l,X		; FF E7 FF 64 ; Subtract with carry (long,X) $64FFE7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	cpy #$09.b		; C0 09 ; Compare #$09.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($B0D8.w,X)		; FC D8 B0 ; Jump to subroutine indirect indexed ($B0D8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $C0C0.w		; 20 C0 C0 ; Jump to subroutine at $C0C0.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy #$43.b		; A0 43 ; Load #$43.b into Y register [Writes: Y Index] [Flags: ZN]
	asl $1300.w		; 0E 00 13 ; Arithmetic shift left $1300.w [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D2.b		; 00 D2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3CC2.w		; 20 C2 3C ; Jump to subroutine at $3CC2.w [Writes: Stack Pointer] [Flow: call]
	.db $82, $7C, $7C		; 82 7C 7C ; Branch always long to $82, $7C, $7C [Flow: branch]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl $FE7E.w		; 0E 7E FE ; Arithmetic shift left $FE7E.w [Flags: ZNC]
	ldx $7CFE.w,Y		; BE FE 7C ; Load X register $7CFE.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $24E000.l		; 22 00 E0 24 ; Jump to subroutine long $24E000.l [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $37.b		; 04 37 ; Test and set bits $37.b [Reads: Accumulator] [Flags: Z]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $312C.w		; 2E 2C 31 ; Rotate left $312C.w [Flags: ZNC]
	and $0B.b,X		; 35 0B ; Logical AND $0B.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$3E.b]		; 27 3E ; AND accumulator with memory (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $38E000.l		; 22 00 E0 38 ; Jump to subroutine long $38E000.l [Writes: Stack Pointer] [Flow: call]
	eor $6CB6F6.l,X		; 5F F6 B6 6C ; Exclusive OR accumulator with memory (long,X) $6CB6F6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3C43.w,Y		; 19 43 3C ; OR accumulator with memory $3C43.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $7C.b,S		; 83 7C ; Store accumulator (stack relative) $7C.b,S [Reads: Accumulator, Stack Pointer]
	sta [$78.b]		; 87 78 ; Store accumulator (long) [$78.b] [Reads: Accumulator, Direct Page]
	jmp ($6F00.w,X)		; 7C 00 6F ; Jump indirect indexed to ($6F00.w,X) [Reads: X Index] [Flow: jump]
	.db $10, $46		; 10 46 ; Branch if plus to $10, $46 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	and $432700.l,X		; 3F 00 27 43 ; AND accumulator with memory (long,X) $432700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $84.b,S		; 83 84 ; Store accumulator (stack relative) $84.b,S [Reads: Accumulator, Stack Pointer]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $DF3F7D.l,X		; 5F 7D 3F DF ; Exclusive OR accumulator with memory (long,X) $DF3F7D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $BF		; 80 BF ; Branch always to $80, $BF [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor $18E720.l,X		; 5F 20 E7 18 ; Exclusive OR accumulator with memory (long,X) $18E720.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	eor ($0C.b,S),Y		; 53 0C ; XOR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sty $6300.w		; 8C 00 63 ; Store Y register to $6300.w [Reads: Y Index]
	lda $FCD3.w,X		; BD D3 FC ; Load $FCD3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda [$62.b]		; A7 62 ; Load accumulator (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp ($8C.b,S),Y		; D3 8C ; Compare accumulator (stack relative indirect indexed) ($8C.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	sbc $00B384.l,X		; FF 84 B3 00 ; Subtract with carry (long,X) $00B384.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $00EC.w,X		; 1E EC 00 ; Arithmetic shift left $00EC.w,X [Reads: X Index] [Flags: ZNC]
	pei ($08.b)		; D4 08 ; Push effective indirect address ($08.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ldx $18.b		; A6 18 ; Load $18.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
.ACCU 16
.INDEX 16
	rep #$3C		; C2 3C
	inc $FD00.w,X		; FE 00 FD ; Increment memory $FD00.w,X [Reads: X Index] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	jmp.w [$7ABC]		; DC BC 7A ; Jump long indirect [$7ABC] [Flow: jump]
	inc $7FFE.w,X		; FE FE 7F ; Increment memory $7FFE.w,X [Reads: X Index] [Flags: ZN]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $37		; 10 37 ; Branch if plus to $10, $37 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $00A300.l,X		; 1F 00 A3 00 ; Logical OR long $00A300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec $3C00.w		; CE 00 3C ; Decrement $3C00.w [Flags: ZN]
	jsl $7F0600.l		; 22 00 06 7F ; Jump to subroutine long $7F0600.l [Writes: Stack Pointer] [Flow: call]
	adc $A31F37.l		; 6F 37 1F A3 ; Add with carry (long) $A31F37.l [Writes: Accumulator] [Flags: ZVNC]
	dec $443C.w		; CE 3C 44 ; Decrement $443C.w [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E0FEFF.l,X		; FF FF FE E0 ; Subtract with carry (long,X) $E0FEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0100.w		; 2C 00 01 ; Test bits $0100.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7E,$00		; 44 00 7E ; Move block positive $7E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0900.w,X		; 7E 00 09 ; Rotate right $0900.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FF7E.w,X		; 7E 7E FF ; Rotate right $FF7E.w,X [Reads: X Index] [Flags: ZNC]
	sbc $187E56.l,X		; FF 56 7E 18 ; Subtract with carry (long,X) $187E56.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $B6.b,S		; 83 B6 ; Store accumulator (stack relative) $B6.b,S [Reads: Accumulator, Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	bit $0044.w,X		; 3C 44 00 ; Test bits $0044.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ror $3C00.w,X		; 7E 00 3C ; Rotate right $3C00.w,X [Reads: X Index] [Flags: ZNC]
	jsl $3C4300.l		; 22 00 43 3C ; Jump to subroutine long $3C4300.l [Writes: Stack Pointer] [Flow: call]
	ror $5601.w,X		; 7E 01 56 ; Rotate right $5601.w,X [Reads: X Index] [Flags: ZNC]
	bit $05FF.w,X		; 3C FF 05 ; Test bits $05FF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $04.b,S		; 43 04 ; Exclusive OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $0709.w,X		; 3D 09 07 ; AND accumulator with memory $0709.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $000E0E.l		; 0F 0E 0E 00 ; OR accumulator with memory (long) $000E0E.l [Writes: Accumulator] [Flags: ZN]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1B.b,S		; E3 1B ; Subtract stack-relative $1B.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc [$98.b],Y		; F7 98 ; Subtract with carry (long indexed) [$98.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F2BF54.l,X		; FF 54 BF F2 ; Subtract with carry (long,X) $F2BF54.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $0007BB.l,X		; 5F BB 07 00 ; Exclusive OR accumulator with memory (long,X) $0007BB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F4.b,S		; E3 F4 ; Subtract stack-relative $F4.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	eor $00F3B7.l,X		; 5F B7 F3 00 ; Exclusive OR accumulator with memory (long,X) $00F3B7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($D8.b,X)		; 01 D8 ; Logical OR ($D8.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$E340.w		; C0 40 E3 ; Compare #$E340.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $62, $7F, $3C		; 62 7F 3C ; Push effective relative address $62, $7F, $3C [Writes: Stack Pointer]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BFA7FE.l,X		; FF FE A7 BF ; Subtract with carry (long,X) $BFA7FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $2343.w,X		; 9D 43 23 ; Store accumulator to $2343.w,X [Reads: Accumulator, X Index]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$FF00.w		; E0 00 FF ; Compare #$FF00.w with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $9F		; 80 9F ; Branch always to $80, $9F [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta [$68.b],Y		; 97 68 ; Store accumulator (long indexed) [$68.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$BC.b]		; 07 BC ; OR accumulator with memory (long) [$BC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($00.b,S),Y		; 53 00 ; XOR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FF9F9F.l,X		; 7F 9F 9F FF ; Add long $FF9F9F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $090025.l		; 2F 25 00 09 ; AND accumulator with memory (long) $090025.l [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $001C04.l		; 0F 04 1C 00 ; OR accumulator with memory (long) $001C04.l [Writes: Accumulator] [Flags: ZN]
	and $2209.w,Y		; 39 09 22 ; AND accumulator with memory $2209.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $23361F.l		; 0F 1F 36 23 ; OR accumulator with memory (long) $23361F.l [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $F007FF.l		; 22 FF 07 F0 ; Jump to subroutine long $F007FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $609F40.l,X		; FF 40 9F 60 ; Subtract with carry (long,X) $609F40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$9F2C.w		; E0 2C 9F ; Compare #$9F2C.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $071C06.l		; 0F 06 1C 07 ; OR accumulator with memory (long) $071C06.l [Writes: Accumulator] [Flags: ZN]
	rol $1B.b,X		; 36 1B ; Rotate left $1B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3E71.w,X		; 1D 71 3E ; OR accumulator with memory $3E71.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $0036.w		; 6D 36 00 ; Add $0036.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $773F3F.l,X		; 1F 3F 3F 77 ; Logical OR long $773F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $C00000.l		; 6F 00 00 C0 ; Add with carry (long) $C00000.l [Writes: Accumulator] [Flags: ZVNC]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$40A0.w		; C0 A0 40 ; Compare #$40A0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $A0		; 70 A0 ; Branch if overflow set to $70, $A0 [Flow: branch]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	.db $50, $E0		; 50 E0 ; Branch if overflow clear to $50, $E0 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$22A0.w		; E0 A0 22 ; Compare #$22A0.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $D0, $27		; D0 27 ; Branch if not equal to $D0, $27 [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $3E00.w		; 1C 00 3E ; Test and reset bits $3E00.w [Reads: Accumulator] [Flags: Z]
	trb $3273.w		; 1C 73 32 ; Test and reset bits $3273.w [Reads: Accumulator] [Flags: Z]
	lda $F68F4E.l,X		; BF 4E 8F F6 ; Load long $F68F4E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$FA.b],Y		; 17 FA ; OR accumulator with memory (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$FA.b],Y		; 37 FA ; AND accumulator with memory (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda [$FA.b],Y		; B7 FA ; Load accumulator (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $4D22.w		; 1C 22 4D ; Test and reset bits $4D22.w [Reads: Accumulator] [Flags: Z]
	lda ($C9.b),Y		; B1 C9 ; Load accumulator ($C9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $9083F5.l		; 22 F5 83 90 ; Jump to subroutine long $9083F5.l [Writes: Stack Pointer] [Flow: call]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $12.b		; 06 12 ; Arithmetic shift left $12.b [Reads: Direct Page] [Flags: ZNC]
	ora $170F16.l		; 0F 16 0F 17 ; OR accumulator with memory (long) $170F16.l [Writes: Accumulator] [Flags: ZN]
	ora $001F2D.l		; 0F 2D 1F 00 ; OR accumulator with memory (long) $001F2D.l [Writes: Accumulator] [Flags: ZN]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$1612.w		; 09 12 16 ; Logical OR #$1612.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$2D.b],Y		; 17 2D ; OR accumulator with memory (long indexed) [$2D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$E000.w		; C0 00 E0 ; Compare #$E000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$2030.w		; C0 30 20 ; Compare #$2030.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	eor $70.b,S		; 43 70 ; Exclusive OR accumulator with stack relative $70.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldy #$6013.w		; A0 13 60 ; Load #$6013.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	jsr $10D0.w		; 20 D0 10 ; Jump to subroutine at $10D0.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $50		; 90 50 ; Branch if carry clear to $90, $50 [Flow: branch]
	.db $50, $60		; 50 60 ; Branch if overflow clear to $50, $60 [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $1A07.w		; 0C 07 1A ; Test and set bits $1A07.w [Reads: Accumulator] [Flags: Z]
	ora $430F1C.l		; 0F 1C 0F 43 ; OR accumulator with memory (long) $430F1C.l [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $3913.w		; 1C 13 39 ; Test and reset bits $3913.w [Reads: Accumulator] [Flags: Z]
	ora $0F0703.l,X		; 1F 03 07 0F ; Logical OR long $0F0703.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $3B1C.w,X		; 1E 1C 3B ; Arithmetic shift left $3B1C.w,X [Reads: X Index] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $0080.w,Y		; 39 80 00 ; AND accumulator with memory $0080.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$E080.w		; C0 80 E0 ; Compare #$E080.w with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$05C0.w		; A0 C0 05 ; Load #$05C0.w into Y register [Writes: Y Index] [Flags: ZN]
	cpx #$80C0.w		; E0 C0 80 ; Compare #$80C0.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$60E0.w		; C0 E0 60 ; Compare #$60E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	and $E0.b,S		; 23 E0 ; AND accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$C7.b]		; 07 C7 ; OR accumulator with memory (long) [$C7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$E1.b]		; 47 E1 ; Exclusive OR accumulator with memory (long) [$E1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $3CFF.w		; 20 FF 3C ; Jump to subroutine at $3CFF.w [Writes: Stack Pointer] [Flow: call]
	ror $001D.w,X		; 7E 1D 00 ; Rotate right $001D.w,X [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $DFB8E0.l,X		; FF E0 B8 DF ; Subtract with carry (long,X) $DFB8E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
.ACCU 16
	rep #$62		; C2 62
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $F70E60.l,X		; 9F 60 0E F7 ; Store accumulator (long,X) $F70E60.l,X [Reads: Accumulator, X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$7C.b]		; 87 7C ; Store accumulator (long) [$7C.b] [Reads: Accumulator, Direct Page]
	sta ($00.b,S),Y		; 93 00 ; Store accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $7FFF9F.l,X		; 9F 9F FF 7F ; Store accumulator (long,X) $7FFF9F.l,X [Reads: Accumulator, X Index]
	adc $002E07.l		; 6F 07 2E 00 ; Add with carry (long) $002E07.l [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	cpx #$F429.w		; E0 29 F4 ; Compare #$F429.w with X register [Reads: X Index] [Flags: ZNC]
	and $AA.b,S		; 23 AA ; AND accumulator with stack relative $AA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc ($B0.b),Y		; 71 B0 ; Add with carry ($B0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $313F48.l,X		; 7F 48 3F 31 ; Add long $313F48.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $1F053F.l		; 0F 3F 05 1F ; OR accumulator with memory (long) $1F053F.l [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $4BBD.w,X		; BC BD 4B ; Load Y register $4BBD.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	and $2F.b,S		; 23 2F ; AND accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1C3F03.l,X		; 1F 03 3F 1C ; Logical OR long $1C3F03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $001F0E.l,X		; 1F 0E 1F 00 ; Logical OR long $001F0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0F1F0E.l,X		; 1F 0E 1F 0F ; Logical OR long $0F1F0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $783B7D.l,X		; 1F 7D 3B 78 ; Logical OR long $783B7D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$23.b],Y		; 37 23 ; AND accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $7F3F0C.l,X		; 1F 0C 3F 7F ; Logical OR long $7F3F0C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $EED83F.l,X		; 7F 3F D8 EE ; Add long $EED83F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$24D7.w		; 09 D7 24 ; Logical OR #$24D7.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sta [$64.b],Y		; 97 64 ; Store accumulator (long indexed) [$64.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sbc [$04.b],Y		; F7 04 ; Subtract with carry (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $CC.b,S		; 83 CC ; Store accumulator (stack relative) $CC.b,S [Reads: Accumulator, Stack Pointer]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sbc $F62780.l,X		; FF 80 27 F6 ; Subtract with carry (long,X) $F62780.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sbc $8D1959.l,X		; FF 59 19 8D ; Subtract with carry (long,X) $8D1959.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $02B3.w		; 0C B3 02 ; Test and set bits $02B3.w [Reads: Accumulator] [Flags: Z]
	sta $02.b,S		; 83 02 ; Store accumulator (stack relative) $02.b,S [Reads: Accumulator, Stack Pointer]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $0F3F1E.l,X		; 3F 1E 3F 0F ; AND accumulator with memory (long,X) $0F3F1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $F36610.l,X		; 7F 10 66 F3 ; Add long $F36610.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $7DFD.w		; CD FD 7D ; Compare $7DFD.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	and ($30.b,X)		; 21 30 ; Logical AND ($30.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $3700FF.l,X		; 7F FF 00 37 ; Add long $3700FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$FC.b]		; C7 FC ; Compare accumulator (long) [$FC.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	ora $BF.b,S		; 03 BF ; OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and [$C4.b],Y		; 37 C4 ; AND accumulator with memory (long indexed) [$C4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$04.b],Y		; F7 04 ; Subtract with carry (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3FFF2C.l,X		; DF 2C FF 3F ; Compare accumulator (long,X) $3FFF2C.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	and $3B37FF.l,X		; 3F FF 37 3B ; AND accumulator with memory (long,X) $3B37FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta ($5F.b,S),Y		; 93 5F ; Store accumulator (stack relative indirect indexed) ($5F.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	jsl $38316E.l		; 22 6E 31 38 ; Jump to subroutine long $38316E.l [Writes: Stack Pointer] [Flow: call]
	ora $2A1F37.l,X		; 1F 37 1F 2A ; Logical OR long $2A1F37.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $141F28.l,X		; 1F 28 1F 14 ; Logical OR long $141F28.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $5F0F15.l		; 0F 15 0F 5F ; OR accumulator with memory (long) $5F0F15.l [Writes: Accumulator] [Flags: ZN]
	ror $3F38.w		; 6E 38 3F ; Rotate right $3F38.w [Flags: ZNC]
	and $17172F.l		; 2F 2F 17 17 ; AND accumulator with memory (long) $17172F.l [Writes: Accumulator] [Flags: ZN]
	ldy $DEC0.w		; AC C0 DE ; Load $DEC0.w into Y register [Writes: Y Index] [Flags: ZN]
	tsb $9A7B.w		; 0C 7B 9A ; Test and set bits $9A7B.w [Reads: Accumulator] [Flags: Z]
	lda $B6CFCE.l,X		; BF CE CF B6 ; Load long $B6CFCE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$BA.b]		; C7 BA ; Compare accumulator (long) [$BA.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	lda [$FA.b],Y		; B7 FA ; Load accumulator (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $D2ACFA.l,X		; DF FA AC D2 ; Compare accumulator (long,X) $D2ACFA.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $B1.b		; 65 B1 ; Add $B1.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp #$B5C5.w		; C9 C5 B5 ; Compare #$B5C5.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	sbc $0306.w,X		; FD 06 03 ; Subtract with carry $0306.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0D07.w		; 0E 07 0D ; Arithmetic shift left $0D07.w [Flags: ZNC]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $0C1C0F.l		; 22 0F 1C 0C ; Jump to subroutine long $0C1C0F.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldx $48F0.w		; AE F0 48 ; Load $48F0.w into X register [Writes: X Index] [Flags: ZN]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	cpy #$E018.w		; C0 18 E0 ; Compare #$E018.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $B0, $74		; B0 74 ; Branch if carry set to $B0, $74 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ldx $B848.w		; AE 48 B8 ; Load $B848.w into X register [Writes: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $D0, $30		; D0 30 ; Branch if not equal to $D0, $30 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsr ($432D.w,X)		; FC 2D 43 ; Jump to subroutine indirect indexed ($432D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $1C022B.l,X		; 1F 2B 02 1C ; Logical OR long $1C022B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $831F.w		; 2E 1F 83 ; Rotate left $831F.w [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $172E04.l		; 2F 04 2E 17 ; AND accumulator with memory (long) $172E04.l [Writes: Accumulator] [Flags: ZN]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $83.b		; 05 83 ; Logical OR $83.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $1601.w,X		; 3E 01 16 ; Rotate left $1601.w,X [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $30		; 80 30 ; Branch always to $80, $30 [Flow: branch]
	cpy #$C0BC.w		; C0 BC C0 ; Compare #$C0BC.w with Y register [Reads: Y Index] [Flags: ZNC]
	cmp ($EC.b)		; D2 EC ; Compare accumulator (indirect) ($EC.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	lda $FA9FDC.l		; AF DC 9F FA ; Load long $FA9FDC.l into accumulator [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$B060.w		; E0 60 B0 ; Compare #$B060.w with X register [Reads: X Index] [Flags: ZNC]
	ldy $FFDE.w,X		; BC DE FF ; Load Y register $FFDE.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sbc $2C1F38.l,X		; FF 38 1F 2C ; Subtract with carry (long,X) $2C1F38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	mvp $2B,$1F		; 44 1F 2B ; Move block positive $2B,$1F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora #$1E2F.w		; 09 2F 1E ; Logical OR #$1E2F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and [$1F.b]		; 27 1F ; AND accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0D.b,X		; 16 0D ; Arithmetic shift left $0D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $2F22.w		; 2C 22 2F ; Test bits $2F22.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	tsb $27.b		; 04 27 ; Test and set bits $27.b [Reads: Accumulator] [Flags: Z]
	ora ($16.b,S),Y		; 13 16 ; OR accumulator (stack relative indirect indexed) ($16.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpy $8380.w		; CC 80 83 ; Compare $8380.w with Y register [Reads: Y Index] [Flags: ZNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $6F0EFF.l,X		; 5F FF 0E 6F ; Exclusive OR accumulator with memory (long,X) $6F0EFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $87.b,X		; F6 87 ; Increment memory $87.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	adc [$FA.b]		; 67 FA ; Add with carry (long) [$FA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$FA.b],Y		; F7 FA ; Subtract with carry (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy $65D2.w		; CC D2 65 ; Compare $65D2.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc ($69.b),Y		; F1 69 ; Subtract with carry ($69.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $3F.b,X		; F5 3F ; Subtract $3F.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsb $001F.w		; 0C 1F 00 ; Test and set bits $001F.w [Reads: Accumulator] [Flags: Z]
	ora $1D3F08.l,X		; 1F 08 3F 1D ; Logical OR long $1D3F08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $3C.b,X		; 76 3C ; Rotate right $3C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inc $7C.b,X		; F6 7C ; Increment memory $7C.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	inc $FD5C.w		; EE 5C FD ; Increment $FD5C.w [Flags: ZN]
	and $1F33.w,Y		; 39 33 1F ; AND accumulator with memory $1F33.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $FF7F3E.l,X		; 1F 3E 7F FF ; Logical OR long $FF7F3E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $38FFFE.l,X		; FF FE FF 38 ; Subtract with carry (long,X) $38FFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $3F49.w		; AE 49 3F ; Load $3F49.w into X register [Writes: X Index] [Flags: ZN]
	cpy $FF.b		; C4 FF ; Compare $FF.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $EC		; 90 EC ; Branch if carry clear to $90, $EC [Flow: branch]
	sta ($F9.b,S),Y		; 93 F9 ; Store accumulator (stack relative indirect indexed) ($F9.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	stx $F3.b		; 86 F3 ; Store X register to $F3.b [Reads: X Index]
	tsb $36C7.w		; 0C C7 36 ; Test and set bits $36C7.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $784C4F.l,X		; FF 4F 4C 78 ; Subtract with carry (long,X) $784C4F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $180F14.l		; 0F 14 0F 18 ; OR accumulator with memory (long) $180F14.l [Writes: Accumulator] [Flags: ZN]
	ora $0B030D.l		; 0F 0D 03 0B ; OR accumulator with memory (long) $0B030D.l [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $F00F0F.l,X		; 1F 0F 0F F0 ; Logical OR long $F00F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $E4		; F0 E4 ; Branch if equal to $F0, $E4 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $62.b,S		; 43 62 ; Exclusive OR accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr ($21E0.w,X)		; FC E0 21 ; Jump to subroutine indirect indexed ($21E0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy $38F0.w		; CC F0 38 ; Compare $38F0.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$E0D8.w		; C0 D8 E0 ; Compare #$E0D8.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $C8		; F0 C8 ; Branch if equal to $F0, $C8 [Flow: branch]
	cpx $E2.b		; E4 E2 ; Compare $E2.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sep #$CC		; E2 CC ; Set processor status bits #$CC [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sec		; 38 ; Set carry flag [Flags: C]
	cld		; D8 ; Clear decimal flag [Flags: D]
	adc $5F17.w,X		; 7D 17 5F ; Add $5F17.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$E7.b]		; 07 E7 ; OR accumulator with memory (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $FB.b,S		; 03 FB ; OR accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $FF02.w,X		; FE 02 FF ; Increment memory $FF02.w,X [Reads: X Index] [Flags: ZN]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $7F7F1E.l,X		; FF 1E 7F 7F ; Subtract with carry (long,X) $7F7F1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FD62F7.l,X		; FF F7 62 FD ; Subtract with carry (long,X) $FD62F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $A488F7.l,X		; FF F7 88 A4 ; Subtract with carry (long,X) $A488F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda $7326.w,Y		; B9 26 73 ; Load $7326.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($C8F7.w)		; 6C F7 C8 ; Jump indirect to ($C8F7.w) [Flow: jump]
	sbc [$88.b],Y		; F7 88 ; Subtract with carry (long indexed) [$88.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	and [$CF.b]		; 27 CF ; AND accumulator with memory (long) [$CF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $70, $E7		; 70 E7 ; Branch if overflow set to $70, $E7 [Flow: branch]
	cpx $D8.b		; E4 D8 ; Compare $D8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $90, $34		; 90 34 ; Branch if carry clear to $90, $34 [Flow: branch]
	ror $F8.b,X		; 76 F8 ; Rotate right $F8.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $1A7F.w,Y		; F9 7F 1A ; Subtract with carry $1A7F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $FF2F43.l,X		; 7F 43 2F FF ; Add long $FF2F43.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$172D.w		; E0 2D 17 ; Compare #$172D.w with X register [Reads: X Index] [Flags: ZNC]
	sbc $0CFF1B.l,X		; FF 1B FF 0C ; Subtract with carry (long,X) $0CFF1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $31FF17.l,X		; FF 17 FF 31 ; Subtract with carry (long,X) $31FF17.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $EFDF5F.l,X		; 7F 5F DF EF ; Add long $EFDF5F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$F3.b]		; E7 F3 ; Subtract with carry (long) [$F3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $689F.w,X		; FE 9F 68 ; Increment memory $689F.w,X [Reads: X Index] [Flags: ZN]
	sbc $88F780.l,X		; FF 80 F7 88 ; Subtract with carry (long,X) $88F780.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$38.b]		; E7 38 ; Subtract with carry (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F863.w,X)		; FC 63 F8 ; Jump to subroutine indirect indexed ($F863.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc [$E8.b]		; 67 E8 ; Add with carry (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$FE.b]		; C7 FE ; Compare accumulator (long) [$FE.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta ($97.b,X)		; 81 97 ; Store accumulator ($97.b,X) [Reads: Accumulator, X Index, Direct Page]
	sbc $9CC7E7.l,X		; FF E7 C7 9C ; Subtract with carry (long,X) $9CC7E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($0708.w,X)		; 7C 08 07 ; Jump indirect indexed to ($0708.w,X) [Reads: X Index] [Flow: jump]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $2A.b,S		; 03 2A ; OR accumulator with stack relative $2A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl $8A.b		; 06 8A ; Arithmetic shift left $8A.b [Reads: Direct Page] [Flags: ZNC]
	jsr ($F874.w,X)		; FC 74 F8 ; Jump to subroutine indirect indexed ($F874.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	stz $08.b,X		; 74 08 ; Store zero to $08.b,X [Reads: X Index]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0D05.w		; 0E 05 0D ; Arithmetic shift left $0D05.w [Flags: ZNC]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($0E.b)		; 12 0E ; OR accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $050F07.l		; 0F 07 0F 05 ; OR accumulator with memory (long) $050F07.l [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$30C8.w		; C0 C8 30 ; Compare #$30C8.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	cpx #$C080.w		; E0 80 C0 ; Compare #$C080.w with X register [Reads: X Index] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsr ($C838.w,X)		; FC 38 C8 ; Jump to subroutine indirect indexed ($C838.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $90, $E0		; 90 E0 ; Branch if carry clear to $90, $E0 [Flow: branch]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2C.b,X)		; 01 2C ; Logical OR ($2C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $DD.b		; 06 DD ; Arithmetic shift left $DD.b [Reads: Direct Page] [Flags: ZNC]
	inc $FC32.w,X		; FE 32 FC ; Increment memory $FC32.w,X [Reads: X Index] [Flags: ZN]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C432.w,X		; FD 32 C4 ; Subtract with carry $C432.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0304.w		; 0C 04 03 ; Test and set bits $0304.w [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($8304.w,X)		; FC 04 83 ; Jump to subroutine indirect indexed ($8304.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	ora $28.b,S		; 03 28 ; OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $F00804.l		; 22 04 08 F0 ; Jump to subroutine long $F00804.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($FD.b,S),Y		; 13 FD ; OR accumulator (stack relative indirect indexed) ($FD.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor ($71.b),Y		; 51 71 ; Exclusive OR accumulator with memory ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($7F.b,X)		; 21 7F ; Logical AND ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $007F.w,X		; 1E 7F 00 ; Arithmetic shift left $007F.w,X [Reads: X Index] [Flags: ZNC]
	sbc $3FF51E.l,X		; FF 1E F5 3F ; Subtract with carry (long,X) $3FF51E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $615EBE.l,X		; 1F BE 5E 61 ; Logical OR long $615EBE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $13FF23.l,X		; 7F 23 FF 13 ; Add long $13FF23.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$48.b],Y		; F7 48 ; Subtract with carry (long indexed) [$48.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and [$7F.b]		; 27 7F ; AND accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $BF		; 30 BF ; Branch if minus to $30, $BF [Flow: branch]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	cop $E7.b		; 02 E7 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $78		; 80 78 ; Branch always to $80, $78 [Flow: branch]
	cpy #$F6F4.w		; C0 F4 F6 ; Compare #$F6F4.w with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $FF23.w,Y		; F9 23 FF ; Subtract with carry $FF23.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $0F.b,X		; 15 0F ; OR accumulator with memory $0F.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $2B0B.w,X		; 1D 0B 2B ; OR accumulator with memory $2B0B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $3D.b		; 14 3D ; Test and reset bits $3D.b [Reads: Accumulator] [Flags: Z]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora $1B2B3F.l,X		; 1F 3F 2B 1B ; Logical OR long $1B2B3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	.db $F0, $48		; F0 48 ; Branch if equal to $F0, $48 [Flow: branch]
	.db $B0, $B0		; B0 B0 ; Branch if carry set to $B0, $B0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy #$C040.w		; A0 40 C0 ; Load #$C040.w into Y register [Writes: Y Index] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E81000.l		; 22 00 10 E8 ; Jump to subroutine long $E81000.l [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $07FE0F.l,X		; FF 0F FE 07 ; Subtract with carry (long,X) $07FE0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00F303.l,X		; FF 03 F3 00 ; Subtract with carry (long,X) $00F303.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$0026.w		; C0 26 00 ; Compare #$0026.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $F301FF.l		; 22 FF 01 F3 ; Jump to subroutine long $F301FF.l [Writes: Stack Pointer] [Flow: call]
	cpy #$0022.w		; C0 22 00 ; Compare #$0022.w with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $E0BF.w		; 0C BF E0 ; Test and set bits $E0BF.w [Reads: Accumulator] [Flags: Z]
	sbc $FCCF.w,X		; FD CF FC ; Subtract with carry $FCCF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $FF2200.l		; 22 00 22 FF ; Jump to subroutine long $FF2200.l [Writes: Stack Pointer] [Flow: call]
	ora $0F1F1F.l		; 0F 1F 1F 0F ; OR accumulator with memory (long) $0F1F1F.l [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $0EFF18.l,X		; FF 18 FF 0E ; Subtract with carry (long,X) $0EFF18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $E503.w,X		; FE 03 E5 ; Increment memory $E503.w,X [Reads: X Index] [Flags: ZN]
	ora $E7.b,S		; 03 E7 ; OR accumulator with stack relative $E7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $82.b		; 02 82 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	jsl $E70FFF.l		; 22 FF 0F E7 ; Jump to subroutine long $E70FFF.l [Writes: Stack Pointer] [Flow: call]
	sbc [$82.b]		; E7 82 ; Subtract with carry (long) [$82.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $47F840.l,X		; FF 40 F8 47 ; Subtract with carry (long,X) $47F840.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFCA.w,X		; FD CA FF ; Subtract with carry $FFCA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $FE.b		; 05 FE ; Logical OR $FE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $3FFF.w,X		; FD FF 3F ; Subtract with carry $3FFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0F0023.l,X		; 1F 23 00 0F ; Logical OR long $0F0023.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $1D00.w		; 0E 00 1D ; Arithmetic shift left $1D00.w [Flags: ZNC]
	asl $113E.w		; 0E 3E 11 ; Arithmetic shift left $113E.w [Flags: ZNC]
	adc $7E3E.w,Y		; 79 3E 7E ; Add $7E3E.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $F3.b,S		; 23 F3 ; AND accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp ($7EC9.w,X)		; 7C C9 7E ; Jump indirect indexed to ($7EC9.w,X) [Reads: X Index] [Flow: jump]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $C4.b,S		; 83 C4 ; Store accumulator (stack relative) $C4.b,S [Reads: Accumulator, Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $0025CF.l,X		; FF CF 25 00 ; Subtract with carry (long,X) $0025CF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$0080.w		; 09 80 00 ; Logical OR #$0080.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $60C0.w		; 20 C0 60 ; Jump to subroutine at $60C0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$0022.w		; C0 22 00 ; Compare #$0022.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsl $0025E0.l		; 22 E0 25 00 ; Jump to subroutine long $0025E0.l [Writes: Stack Pointer] [Flow: call]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0F.b,X		; 16 0F ; Arithmetic shift left $0F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jsl $031900.l		; 22 00 19 03 ; Jump to subroutine long $031900.l [Writes: Stack Pointer] [Flow: call]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$0C.b],Y		; 17 0C ; OR accumulator with memory (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $12F3.w		; 0C F3 12 ; Test and set bits $12F3.w [Reads: Accumulator] [Flags: Z]
	ora $F6EFEE.l,X		; 1F EE EF F6 ; Logical OR long $F6EFEE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda [$FA.b],Y		; B7 FA ; Load accumulator (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$FA.b],Y		; 17 FA ; OR accumulator with memory (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$FA.b],Y		; F7 FA ; Subtract with carry (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $ED32.w		; 0C 32 ED ; Test and set bits $ED32.w [Reads: Accumulator] [Flags: Z]
	ora ($E9.b),Y		; 11 E9 ; OR accumulator with memory ($E9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $0712F5.l		; 22 F5 12 07 ; Jump to subroutine long $0712F5.l [Writes: Stack Pointer] [Flow: call]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $033E.w		; 0E 3E 03 ; Arithmetic shift left $033E.w [Flags: ZNC]
	and [$1C.b],Y		; 37 1C ; AND accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3D77.w,X		; 1D 77 3D ; OR accumulator with memory $3D77.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $0F0733.l		; 6F 33 07 0F ; Add with carry (long) $0F0733.l [Writes: Accumulator] [Flags: ZVNC]
	ora $833F22.l,X		; 1F 22 3F 83 ; Logical OR long $833F22.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	sta $38.b,S		; 83 38 ; Store accumulator (stack relative) $38.b,S [Reads: Accumulator, Stack Pointer]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$0001.w		; C0 01 00 ; Compare #$0001.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	cpy #$E001.w		; C0 01 E0 ; Compare #$E001.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$0029.w		; E0 29 00 ; Compare #$0029.w with X register [Reads: X Index] [Flags: ZNC]
	mvp $00,$01		; 44 01 00 ; Move block positive $00,$01 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $20E001.l		; 22 01 E0 20 ; Jump to subroutine long $20E001.l [Writes: Stack Pointer] [Flow: call]
	asl $1F00.w		; 0E 00 1F ; Arithmetic shift left $1F00.w [Flags: ZNC]
	asl $1979.w		; 0E 79 19 ; Arithmetic shift left $1979.w [Flags: ZNC]
	sbc $7BE727.l,X		; FF 27 E7 7B ; Subtract with carry (long,X) $7BE727.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	wai		; CB ; Wait for interrupt
	sbc $FD9B.w,X		; FD 9B FD ; Subtract with carry $FD9B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $110E.w,X		; FD 0E 11 ; Subtract with carry $110E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $F8.b		; 66 F8 ; Rotate right $F8.b [Reads: Direct Page] [Flags: ZNC]
	cpx $FA.b		; E4 FA ; Compare $FA.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	jsr ($FF0F.w,X)		; FC 0F FF ; Jump to subroutine indirect indexed ($FF0F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $E3.b,S		; 03 E3 ; OR accumulator with stack relative $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	jsl $E301FF.l		; 22 FF 01 E3 ; Jump to subroutine long $E301FF.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $04C98B.l,X		; FF 8B C9 04 ; Subtract with carry (long,X) $04C98B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $FF2200.l		; 22 00 22 FF ; Jump to subroutine long $FF2200.l [Writes: Stack Pointer] [Flow: call]
	sta $DB.b,S		; 83 DB ; Store accumulator (stack relative) $DB.b,S [Reads: Accumulator, Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$0034.w		; E0 34 00 ; Compare #$0034.w with X register [Reads: X Index] [Flags: ZNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc #$0FFF.w		; 69 FF 0F ; Add #$0FFF.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	sta $629F67.l,X		; 9F 67 9F 62 ; Store accumulator (long,X) $629F67.l,X [Reads: Accumulator, X Index]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $7F.b		; 14 7F ; Test and reset bits $7F.b [Reads: Accumulator] [Flags: Z]
	inc $F0.b,X		; F6 F0 ; Increment memory $F0.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $00.b,X		; F5 00 ; Subtract $00.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FD.b		; 06 FD ; Arithmetic shift left $FD.b [Reads: Direct Page] [Flags: ZNC]
	asl $3ED9.w		; 0E D9 3E ; Arithmetic shift left $3ED9.w [Flags: ZNC]
.INDEX 8
	sep #$1C		; E2 1C
	pea $0008.w		; F4 08 00 ; Push absolute address $0008.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldx $2F.b		; A6 2F ; Load $2F.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	sbc $A2D9.w,X		; FD D9 A2 ; Subtract with carry $A2D9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	mvn $00,$00		; 54 00 00 ; Move block negative $00,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $000587.l		; 0F 87 05 00 ; OR accumulator with memory (long) $000587.l [Writes: Accumulator] [Flags: ZN]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sta $040060.l,X		; 9F 60 00 04 ; Store accumulator (long,X) $040060.l,X [Reads: Accumulator, X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	adc $F7F0F6.l,X		; 7F F6 F0 F7 ; Add long $F7F0F6.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0000.w,Y		; F9 00 00 ; Subtract with carry $0000.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: ZN]
	cmp $0EFD06.l,X		; DF 06 FD 0E ; Compare accumulator (long,X) $0EFD06.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sta $C27E.w,Y		; 99 7E C2 ; Store accumulator to $C27E.w,Y [Reads: Accumulator, Y Index]
	bit $18E4.w,X		; 3C E4 18 ; Test bits $18E4.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $5F.b		; 46 5F ; Logical shift right $5F.b [Reads: Direct Page] [Flags: ZNC]
	sbc $4299.w,X		; FD 99 42 ; Subtract with carry $4299.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $7F.b		; 04 7F ; Test and set bits $7F.b [Reads: Accumulator] [Flags: Z]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $6F.b		; 24 6F ; Test bits $6F.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta $14.b,S		; 83 14 ; Store accumulator (stack relative) $14.b,S [Reads: Accumulator, Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sta $1A.b,S		; 83 1A ; Store accumulator (stack relative) $1A.b,S [Reads: Accumulator, Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $001F88.l,X		; FF 88 1F 00 ; Subtract with carry (long,X) $001F88.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $5F.b		; A6 5F ; Load $5F.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	sta $2C.b,S		; 83 2C ; Store accumulator (stack relative) $2C.b,S [Reads: Accumulator, Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($40.b),Y		; 11 40 ; OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $FF.b,X		; 76 FF ; Rotate right $FF.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	bit $7E.b,X		; 34 7E ; Test bits $7E.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $187E.w,X		; 3C 7E 18 ; Test bits $187E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $1800.w,X		; 3C 00 18 ; Test bits $1800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ror $3C3C.w,X		; 7E 3C 3C ; Rotate right $3C3C.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl $41.b		; 06 41 ; Arithmetic shift left $41.b [Reads: Direct Page] [Flags: ZNC]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $031400.l		; 2F 00 14 03 ; AND accumulator with memory (long) $031400.l [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $191F.w		; 0C 1F 19 ; Test and set bits $191F.w [Reads: Accumulator] [Flags: Z]
	rol $3F18.w,X		; 3E 18 3F ; Rotate left $3F18.w,X [Reads: X Index] [Flags: ZNC]
	trb $007F.w		; 1C 7F 00 ; Test and reset bits $007F.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1F1F.w,X		; 1E 1F 1F ; Arithmetic shift left $1F1F.w,X [Reads: X Index] [Flags: ZNC]
	jsl $C01400.l		; 22 00 14 C0 ; Jump to subroutine long $C01400.l [Writes: Stack Pointer] [Flow: call]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($FC18.w,X)		; 7C 18 FC ; Jump indirect indexed to ($FC18.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: ZN]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $031400.l		; 22 00 14 03 ; Jump to subroutine long $031400.l [Writes: Stack Pointer] [Flow: call]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $1D.b		; 02 1D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $67FF2D.l,X		; 7F 2D FF 67 ; Add long $67FF2D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FF2B.l,X		; FF 2B FF 00 ; Subtract with carry (long,X) $00FF2B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $222F6F.l		; 6F 6F 2F 22 ; Add with carry (long) $222F6F.l [Writes: Accumulator] [Flags: ZVNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $FE		; F0 FE ; Branch if equal to $F0, $FE [Flow: branch]
	pea $F0FF.w		; F4 FF F0 ; Push absolute address $F0FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $84FFF4.l,X		; FF F4 FF 84 ; Subtract with carry (long,X) $84FFF4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	pea $8301.w		; F4 01 83 ; Push absolute address $8301.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc ($00.b)		; F2 00 ; Subtract with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0E.b,S		; 43 0E ; Exclusive OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $45.b		; 06 45 ; Arithmetic shift left $45.b [Reads: Direct Page] [Flags: ZNC]
	trb $040C.w		; 1C 0C 04 ; Test and reset bits $040C.w [Reads: Accumulator] [Flags: Z]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora #$1322.w		; 09 22 13 ; Logical OR #$1322.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $C0.b		; 05 C0 ; Logical OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$4A.b		; E0 4A ; Compare #$4A.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	cpy #$20.b		; C0 20 ; Compare #$20.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $90A0.w		; 20 A0 90 ; Jump to subroutine at $90A0.w [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $2E0D05.l		; 22 05 0D 2E ; Jump to subroutine long $2E0D05.l [Writes: Stack Pointer] [Flow: call]
	ora ($7D.b,S),Y		; 13 7D ; OR accumulator (stack relative indirect indexed) ($7D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$18.b],Y		; 37 18 ; AND accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$28.b],Y		; 77 28 ; Add with carry (long indexed) [$28.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $354E25.l,X		; 7F 25 4E 35 ; Add long $354E25.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $387D.w		; 2E 7D 38 ; Rotate left $387D.w [Flags: ZNC]
	and #$3B23.w		; 29 23 3B ; Logical AND #$3B23.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$6C.b		; C0 6C ; Compare #$6C.b with Y register [Reads: Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	bit $F4.b		; 24 F4 ; Test bits $F4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cmp ($FC.b)		; D2 FC ; Compare accumulator (indirect) ($FC.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($FC0C.w,X)		; FC 0C FC ; Jump to subroutine indirect indexed ($FC0C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	mvp $6C,$00		; 44 00 6C ; Move block positive $6C,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	bit $D2.b		; 24 D2 ; Test bits $D2.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy $7FA4.w		; CC A4 7F ; Compare $7FA4.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A3.b		; 00 A3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $6A0400.l		; 22 00 04 6A ; Jump to subroutine long $6A0400.l [Writes: Stack Pointer] [Flow: call]
	eor [$50.b],Y		; 57 50 ; Exclusive OR accumulator with memory (long indexed) [$50.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	jsl $F80000.l		; 22 00 00 F8 ; Jump to subroutine long $F80000.l [Writes: Stack Pointer] [Flow: call]
	mvp $38,$00		; 44 00 38 ; Move block positive $38,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $BC.b		; 02 BC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $89.b,S		; 83 89 ; Store accumulator (stack relative) $89.b,S [Reads: Accumulator, Stack Pointer]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jsl $100028.l		; 22 28 00 10 ; Jump to subroutine long $100028.l [Writes: Stack Pointer] [Flow: call]
	jsl $7F0000.l		; 22 00 00 7F ; Jump to subroutine long $7F0000.l [Writes: Stack Pointer] [Flow: call]
	mvp $1C,$00		; 44 00 1C ; Move block positive $1C,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: ZNC]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $7B0000.l		; 22 00 00 7B ; Jump to subroutine long $7B0000.l [Writes: Stack Pointer] [Flow: call]
	jsl $080014.l		; 22 14 00 08 ; Jump to subroutine long $080014.l [Writes: Stack Pointer] [Flow: call]
	jsl $F80000.l		; 22 00 00 F8 ; Jump to subroutine long $F80000.l [Writes: Stack Pointer] [Flow: call]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $B80000.l		; 22 00 00 B8 ; Jump to subroutine long $B80000.l [Writes: Stack Pointer] [Flow: call]
	jsl $4000A0.l		; 22 A0 00 40 ; Jump to subroutine long $4000A0.l [Writes: Stack Pointer] [Flow: call]
	jsl $3F0000.l		; 22 00 00 3F ; Jump to subroutine long $3F0000.l [Writes: Stack Pointer] [Flow: call]
	mvp $70,$00		; 44 00 70 ; Move block positive $70,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $74.b		; 04 74 ; Test and set bits $74.b [Reads: Accumulator] [Flags: Z]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $200050.l		; 22 50 00 20 ; Jump to subroutine long $200050.l [Writes: Stack Pointer] [Flow: call]
	jsl $700000.l		; 22 00 00 70 ; Jump to subroutine long $700000.l [Writes: Stack Pointer] [Flow: call]
	mvp $38,$00		; 44 00 38 ; Move block positive $38,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $7C.b		; 04 7C ; Test and set bits $7C.b [Reads: Accumulator] [Flags: Z]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $100028.l		; 22 28 00 10 ; Jump to subroutine long $100028.l [Writes: Stack Pointer] [Flow: call]
	jsl $101E00.l		; 22 00 1E 10 ; Jump to subroutine long $101E00.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	trb $1C.b		; 14 1C ; Test and reset bits $1C.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	trb $0008.w		; 1C 08 00 ; Test and reset bits $0008.w [Reads: Accumulator] [Flags: Z]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $300400.l		; 22 00 04 30 ; Jump to subroutine long $300400.l [Writes: Stack Pointer] [Flow: call]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7F0B7F.l,X		; 1F 7F 0B 7F ; Logical OR long $7F0B7F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr $1B7F.w		; 20 7F 1B ; Jump to subroutine at $1B7F.w [Writes: Stack Pointer] [Flow: call]
	adc $003F0E.l,X		; 7F 0E 3F 00 ; Add long $003F0E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0023.w,X		; 1E 23 00 ; Arithmetic shift left $0023.w,X [Reads: X Index] [Flags: ZNC]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora $0E1B23.l		; 0F 23 1B 0E ; OR accumulator with memory (long) $0E1B23.l [Writes: Accumulator] [Flags: ZN]
	jsl $F80B00.l		; 22 00 0B F8 ; Jump to subroutine long $F80B00.l [Writes: Stack Pointer] [Flow: call]
	inc $FED0.w,X		; FE D0 FE ; Increment memory $FED0.w,X [Reads: X Index] [Flags: ZN]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	cld		; D8 ; Clear decimal flag [Flags: D]
	inc $FC70.w,X		; FE 70 FC ; Increment memory $FC70.w,X [Reads: X Index] [Flags: ZN]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $C4		; F0 C4 ; Branch if equal to $F0, $C4 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $70, $22		; 70 22 ; Branch if overflow set to $70, $22 [Flow: branch]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0B7F.w		; 1C 7F 0B ; Test and reset bits $0B7F.w [Reads: Accumulator] [Flags: Z]
	adc $266F14.l,X		; 7F 14 6F 26 ; Add long $266F14.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $003E1C.l,X		; 7F 1C 3E 00 ; Add long $003E1C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $0023.w		; 1C 23 00 ; Test and reset bits $0023.w [Reads: Accumulator] [Flags: Z]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $1C3E.w		; 2C 3E 1C ; Test bits $1C3E.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	jsl $F80B00.l		; 22 00 0B F8 ; Jump to subroutine long $F80B00.l [Writes: Stack Pointer] [Flow: call]
	inc $FEC4.w,X		; FE C4 FE ; Increment memory $FEC4.w,X [Reads: X Index] [Flags: ZN]
	trb $EE.b		; 14 EE ; Test and reset bits $EE.b [Reads: Accumulator] [Flags: Z]
	jmp $38FE.w		; 4C FE 38 ; Jump to $38FE.w [Flow: jump]
	jmp ($3800.w,X)		; 7C 00 38 ; Jump indirect indexed to ($3800.w,X) [Reads: X Index] [Flow: jump]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	jmp.w [$7C2C]		; DC 2C 7C ; Jump long indirect [$7C2C] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $1B0300.l		; 22 00 03 1B ; Jump to subroutine long $1B0300.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $3F431A.l,X		; 3F 1A 43 3F ; AND accumulator with memory (long,X) $3F431A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3E09.w,X		; 1D 09 3E ; OR accumulator with memory $3E09.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0B1C.w,X		; 1D 1C 0B ; OR accumulator with memory $0B1C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0303.w		; 0E 03 03 ; Arithmetic shift left $0303.w [Flags: ZNC]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $22.b		; 25 22 ; Logical AND $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $E0.b,S		; 23 E0 ; AND accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $B0.b,S		; 03 B0 ; OR accumulator with stack relative $B0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldy #$F8.b		; A0 F8 ; Load #$F8.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $B0, $F8		; B0 F8 ; Branch if carry set to $B0, $F8 [Flow: branch]
	.db $70, $B8		; 70 B8 ; Branch if overflow set to $70, $B8 [Flow: branch]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	ldy #$E0.b		; A0 E0 ; Load #$E0.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	.db $80, $1A		; 80 1A ; Branch always to $80, $1A [Flow: branch]
	adc #$593B.w		; 69 3B 59 ; Add #$593B.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	lda $9E90.w,X		; BD 90 9E ; Load $9E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	bit $1704.w		; 2C 04 17 ; Test bits $1704.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$A7.b]		; 67 A7 ; Add with carry (long) [$A7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta ($30.b,S),Y		; 93 30 ; Store accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	clv		; B8 ; Clear overflow flag [Flags: V]
	bit $BC.b		; 24 BC ; Test bits $BC.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $70.b,X		; 34 70 ; Test bits $70.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	sbc ($A2.b)		; F2 A2 ; Subtract with carry (indirect) ($A2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $62, $42, $C8		; 62 42 C8 ; Push effective relative address $62, $42, $C8 [Writes: Stack Pointer]
	sty $90.b		; 84 90 ; Store Y register to $90.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pei ($C4.b)		; D4 C4 ; Push effective indirect address ($C4.b) [Reads: Direct Page] [Writes: Stack Pointer]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($A2.b)		; 12 A2 ; OR accumulator with memory (indirect) ($A2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $2C,$88		; 44 88 2C ; Move block positive $2C,$88 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2C.b,X)		; 01 2C ; Logical OR ($2C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$26.b		; C0 26 ; Compare #$26.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $24		; 80 24 ; Branch always to $80, $24 [Flow: branch]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $00.b,S		; C3 00 ; Compare accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $3F0C43.l,X		; 1F 43 0C 3F ; Logical OR long $3F0C43.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $030100.l		; 22 00 01 03 ; Jump to subroutine long $030100.l [Writes: Stack Pointer] [Flow: call]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $060024.l		; 0F 24 00 06 ; OR accumulator with memory (long) $060024.l [Writes: Accumulator] [Flags: ZN]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	eor $68.b,S		; 43 68 ; Exclusive OR accumulator with stack relative $68.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $0022.w		; 9C 22 00 ; Store zero to $0022.w
	tsb $C0.b		; 04 C0 ; Test and set bits $C0.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $030A00.l		; 22 00 0A 03 ; Jump to subroutine long $030A00.l [Writes: Stack Pointer] [Flow: call]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $0E.b,S		; 83 0E ; Store accumulator (stack relative) $0E.b,S [Reads: Accumulator, Stack Pointer]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $2CE000.l		; 22 00 E0 2C ; Jump to subroutine long $2CE000.l [Writes: Stack Pointer] [Flow: call]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$A0.b		; E0 A0 ; Compare #$A0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	eor $55.b,X		; 55 55 ; Exclusive OR accumulator with memory $55.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $00.b,X		; 15 00 ; OR accumulator with memory $00.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $2A.b,X		; 15 2A ; OR accumulator with memory $2A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $2A.b,X		; 55 2A ; Exclusive OR accumulator with memory $2A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($40.b,S),Y		; 13 40 ; OR accumulator (stack relative indirect indexed) ($40.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $A0		; 80 A0 ; Branch always to $80, $A0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $50, $A8		; 50 A8 ; Branch if overflow clear to $50, $A8 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	mvn $A8,$54		; 54 54 A8 ; Move block negative $A8,$54 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	mvn $00,$00		; 54 00 00 ; Move block negative $00,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy #$50.b		; A0 50 ; Load #$50.b into Y register [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	mvn $22,$AA		; 54 AA 22 ; Move block negative $22,$AA [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $03.b,S		; 63 03 ; Add with carry (stack relative) $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $2C7E.w		; 0D 7E 2C ; Logical OR $2C7E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $2B7F0E.l,X		; 7F 0E 7F 2B ; Add long $2B7F0E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $CF.b		; 84 CF ; Store Y register to $CF.b [Reads: Y Index]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0F2F.w		; 2E 2F 0F ; Rotate left $0F2F.w [Flags: ZNC]
	and $0B0022.l		; 2F 22 00 0B ; AND accumulator with memory (long) $0B0022.l [Writes: Accumulator] [Flags: ZN]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$60.b		; E0 60 ; Compare #$60.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($7EB0.w,X)		; FC B0 7E ; Jump to subroutine indirect indexed ($7EB0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $FE.b,X		; 34 FE ; Test bits $FE.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $70, $FE		; 70 FE ; Branch if overflow set to $70, $FE [Flow: branch]
	pei ($84.b)		; D4 84 ; Push effective indirect address ($84.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $74.b,S		; 03 74 ; OR accumulator with stack relative $74.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	pea $F4F0.w		; F4 F0 F4 ; Push absolute address $F4F0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($1E.b,S),Y		; 13 1E ; OR accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F7F.w,X		; 1E 7F 3F ; Arithmetic shift left $3F7F.w,X [Reads: X Index] [Flags: ZNC]
	ror $DF1C.w,X		; 7E 1C DF ; Rotate right $DF1C.w,X [Reads: X Index] [Flags: ZNC]
	adc $8F.b,S		; 63 8F ; Add with carry (stack relative) $8F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc $0000.w,X		; 7D 00 00 ; Add $0000.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $4021.w,X		; 1E 21 40 ; Arithmetic shift left $4021.w,X [Reads: X Index] [Flags: ZNC]
	adc $FC.b,S		; 63 FC ; Add with carry (stack relative) $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	inc $0025.w,X		; FE 25 00 ; Increment memory $0025.w,X [Reads: X Index] [Flags: ZN]
	ora #$00E0.w		; 09 E0 00 ; Logical OR #$00E0.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl $071C.w,X		; 1E 1C 07 ; Arithmetic shift left $071C.w,X [Reads: X Index] [Flags: ZNC]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E0.b,X		; 34 E0 ; Test bits $E0.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $E2.b		; 04 E2 ; Test and set bits $E2.b [Reads: Accumulator] [Flags: Z]
	sbc $0C0C.w,Y		; F9 0C 0C ; Subtract with carry $0C0C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $11.b		; 26 11 ; Rotate left $11.b [Reads: Direct Page] [Flags: ZNC]
	eor $133F06.l,X		; 5F 06 3F 13 ; Exclusive OR accumulator with memory (long,X) $133F06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($DB20.w,X)		; 7C 20 DB ; Jump indirect indexed to ($DB20.w,X) [Reads: X Index] [Flow: jump]
	.db $50, $D6		; 50 D6 ; Branch if overflow clear to $50, $D6 [Flow: branch]
	eor ($0C.b,S),Y		; 53 0C ; XOR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $4720.w,Y		; 19 20 47 ; OR accumulator with memory $4720.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $0000AF.l		; AF AF 00 00 ; Load long $0000AF.l into accumulator [Writes: Accumulator] [Flags: ZN]
	cpx #$08.b		; E0 08 ; Compare #$08.b with X register [Reads: X Index] [Flags: ZNC]
	adc ($EC.b)		; 72 EC ; Add with carry (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy $5C.b		; A4 5C ; Load $5C.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	pei ($EE.b)		; D4 EE ; Push effective indirect address ($EE.b) [Reads: Direct Page] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $7D.b		; 24 7D ; Test bits $7D.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($DCB8.w,X)		; FC B8 DC ; Jump to subroutine indirect indexed ($DCB8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rol $EAE4.w		; 2E E4 EA ; Rotate left $EAE4.w [Flags: ZNC]
	sta $15.b,S		; 83 15 ; Store accumulator (stack relative) $15.b,S [Reads: Accumulator, Stack Pointer]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0E1E07.l		; 0F 07 1E 0E ; OR accumulator with memory (long) $0E1E07.l [Writes: Accumulator] [Flags: ZN]
	lsr $BF0A.w,X		; 5E 0A BF ; Logical shift right $BF0A.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr $0000.w,X		; 5E 00 00 ; Logical shift right $0000.w,X [Reads: X Index] [Flags: ZNC]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($55.b),Y		; 11 55 ; OR accumulator with memory ($55.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $73.b,S		; E3 73 ; Subtract stack-relative $73.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sta $0C.b,S		; 83 0C ; Store accumulator (stack relative) $0C.b,S [Reads: Accumulator, Stack Pointer]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	eor $242038.l		; 4F 38 20 24 ; Exclusive OR accumulator with memory (long) $242038.l [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $38.b,X		; 74 38 ; Store zero to $38.b,X [Reads: X Index]
	dec $BE74.w,X		; DE 74 BE ; Decrement memory $BE74.w,X [Reads: X Index] [Flags: ZN]
	cpx $44E6.w		; EC E6 44 ; Compare $44E6.w with X register [Reads: X Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpx $F4.b		; E4 F4 ; Compare $F4.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sbc ($FA.b)		; F2 FA ; Subtract with carry (indirect) ($FA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $377F3B.l,X		; 3F 3B 7F 37 ; AND accumulator with memory (long,X) $377F3B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $073F19.l,X		; 7F 19 3F 07 ; Add long $073F19.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $030700.l,X		; 1F 00 07 03 ; Logical OR long $030700.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $071F3F.l,X		; 3F 3F 1F 07 ; AND accumulator with memory (long,X) $071F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$60.b		; E0 60 ; Compare #$60.b with X register [Reads: X Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldy $DE3C.w,X		; BC 3C DE ; Load Y register $DE3C.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	tsb $98FE.w		; 0C FE 98 ; Test and set bits $98FE.w [Reads: Accumulator] [Flags: Z]
	jsr ($F8E0.w,X)		; FC E0 F8 ; Jump to subroutine indirect indexed ($F8E0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jmp.w [$F8FC]		; DC FC F8 ; Jump long indirect [$F8FC] [Flow: jump]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	tsb $0A3F.w		; 0C 3F 0A ; Test and set bits $0A3F.w [Reads: Accumulator] [Flags: Z]
	and $031F07.l,X		; 3F 07 1F 03 ; AND accumulator with memory (long,X) $031F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03070F.l		; 0F 0F 07 03 ; OR accumulator with memory (long) $03070F.l [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($FC18.w,X)		; FC 18 FC ; Jump to subroutine indirect indexed ($FC18.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $F8.b,S		; 03 F8 ; OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $07,$03		; 44 03 07 ; Move block positive $07,$03 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$3F.b],Y		; 17 3F ; OR accumulator with memory (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $8A.b		; 85 8A ; Store accumulator to $8A.b [Reads: Accumulator]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00071F.l,X		; 1F 1F 07 00 ; Logical OR long $00071F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $40.b,S		; 43 40 ; Exclusive OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldy #$03.b		; A0 03 ; Load #$03.b into Y register [Writes: Y Index] [Flags: ZN]
	jsr $08D8.w		; 20 D8 08 ; Jump to subroutine at $08D8.w [Writes: Stack Pointer] [Flow: call]
	jsr ($A285.w,X)		; FC 85 A2 ; Jump to subroutine indirect indexed ($A285.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	ora $85.b,X		; 15 85 ; OR accumulator with memory $85.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $03.b,X		; 95 03 ; Store accumulator to $03.b,X [Reads: Accumulator, X Index]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	ora $2A.b,X		; 15 2A ; OR accumulator with memory $2A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $23.b,X		; 15 23 ; OR accumulator with memory $23.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b,X		; 15 0A ; OR accumulator with memory $0A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $2A.b,X		; 15 2A ; OR accumulator with memory $2A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0A.b,X		; 15 0A ; OR accumulator with memory $0A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $AA,$AA		; 54 AA AA ; Move block negative $AA,$AA [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	mvn $A8,$54		; 54 54 A8 ; Move block negative $A8,$54 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	mvn $28,$10		; 54 10 28 ; Move block negative $28,$10 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $54.b		; 04 54 ; Test and set bits $54.b [Reads: Accumulator] [Flags: Z]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	mvn $10,$A8		; 54 A8 10 ; Move block negative $10,$A8 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	jsl $5C0B00.l		; 22 00 0B 5C ; Jump to subroutine long $5C0B00.l [Writes: Stack Pointer] [Flow: call]
	sbc $5CDF2B.l,X		; FF 2B DF 5C ; Subtract with carry (long,X) $5CDF2B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $027F36.l,X		; FF 36 7F 02 ; Subtract with carry (long,X) $027F36.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$01.b],Y		; 37 01 ; AND accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	jmp ($8337.w,X)		; 7C 37 83 ; Jump indirect indexed to ($8337.w,X) [Reads: X Index] [Flow: jump]
	ror $03.b,X		; 76 03 ; Rotate right $03.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $3AFBD4.l,X		; FF D4 FB 3A ; Subtract with carry (long,X) $3AFBD4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C0FE6C.l,X		; FF 6C FE C0 ; Subtract with carry (long,X) $C0FE6C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($C080.w)		; 6C 80 C0 ; Jump indirect to ($C080.w) [Flow: jump]
	sta $2E.b,S		; 83 2E ; Store accumulator (stack relative) $2E.b,S [Reads: Accumulator, Stack Pointer]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $3EDA.w,X		; FE DA 3E ; Increment memory $3EDA.w,X [Reads: X Index] [Flags: ZN]
	cpx $8040.w		; EC 40 80 ; Compare $8040.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $147663.l,X		; DF 63 76 14 ; Compare accumulator (long,X) $147663.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $1E3F3F.l,X		; 7F 3F 3F 1E ; Add long $1E3F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0026.w,X		; 1E 26 00 ; Arithmetic shift left $0026.w,X [Reads: X Index] [Flags: ZNC]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $3B0600.l		; 22 00 06 3B ; Jump to subroutine long $3B0600.l [Writes: Stack Pointer] [Flow: call]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $80E2E2.l,X		; FF E2 E2 80 ; Subtract with carry (long,X) $80E2E2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $28		; 80 28 ; Branch always to $80, $28 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $1D.b		; C5 1D ; Compare $1D.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	.db $62, $80, $23		; 62 80 23 ; Push effective relative address $62, $80, $23 [Writes: Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $DB.b,S		; 23 DB ; AND accumulator with stack relative $DB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $50, $7C		; 50 7C ; Branch if overflow clear to $50, $7C [Flow: branch]
	jsr $133F.w		; 20 3F 13 ; Jump to subroutine at $133F.w [Writes: Stack Pointer] [Flow: call]
	sta $8C4306.l,X		; 9F 06 43 8C ; Store accumulator (long,X) $8C4306.l,X [Reads: Accumulator, X Index]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $192047.l		; AF 47 20 19 ; Load long $192047.l into accumulator [Writes: Accumulator] [Flags: ZN]
	sty $3043.w		; 8C 43 30 ; Store Y register to $3043.w [Reads: Y Index]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	dec $BCAA.w,X		; DE AA BC ; Decrement memory $BCAA.w,X [Reads: X Index] [Flags: ZN]
	lsr $78.b,X		; 56 78 ; Logical shift right $78.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	pea $D872.w		; F4 72 D8 ; Push absolute address $D872.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	dec $83.b		; C6 83 ; Decrement $83.b [Reads: Direct Page] [Flags: ZN]
	stz $E000.w,X		; 9E 00 E0 ; Store zero to $E000.w,X [Reads: X Index]
	and [$E8.b],Y		; 37 E8 ; AND accumulator with memory (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	dec $98.b,X		; D6 98 ; Decrement memory $98.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	adc ($C6.b)		; 72 C6 ; Add with carry (indirect) ($C6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($5F.b,X)		; 01 5F ; Logical OR ($5F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $73.b		; 06 73 ; Arithmetic shift left $73.b [Reads: Direct Page] [Flags: ZNC]
	ora ($93.b)		; 12 93 ; OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $72.b		; 00 72 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FE6C.w,Y		; 79 6C FE ; Add $FE6C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $4E081F.l,X		; 1F 1F 08 4E ; Logical OR long $4E081F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $38FC.w		; 0C FC 38 ; Test and set bits $38FC.w [Reads: Accumulator] [Flags: Z]
	jsr ($F818.w,X)		; FC 18 F8 ; Jump to subroutine indirect indexed ($F818.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $24.b		; C4 24 ; Compare $24.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $B0, $C0		; B0 C0 ; Branch if carry set to $B0, $C0 [Flow: branch]
	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $0338E0.l,X		; FF E0 38 03 ; Subtract with carry (long,X) $0338E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $331C.w,X		; 1E 1C 33 ; Arithmetic shift left $331C.w,X [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $C03F.w,X		; 3C 3F C0 ; Test bits $C03F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $6930.w,X		; DE 30 69 ; Decrement memory $6930.w,X [Reads: X Index] [Flags: ZN]
	.db $90, $EA		; 90 EA ; Branch if carry clear to $90, $EA [Flow: branch]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $F5, $BA		; 62 F5 BA ; Push effective relative address $62, $F5, $BA [Writes: Stack Pointer]
	sta $161EFE.l,X		; 9F FE 1E 16 ; Store accumulator (long,X) $161EFE.l,X [Reads: Accumulator, X Index]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1F05.w		; 0E 05 1F ; Arithmetic shift left $1F05.w [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $0041E0.l		; 2F E0 41 00 ; AND accumulator with memory (long) $0041E0.l [Writes: Accumulator] [Flags: ZN]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F18.w		; 0D 18 3F ; Logical OR $3F18.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $C03837.l,X		; 3F 37 38 C0 ; AND accumulator with memory (long,X) $C03837.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$6C.b		; C0 6C ; Compare #$6C.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$CC.b		; C0 CC ; Compare #$CC.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $EC		; 80 EC ; Branch always to $80, $EC [Flow: branch]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	pea $BCF4.w		; F4 F4 BC ; Push absolute address $BCF4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	pea $0003.w		; F4 03 00 ; Push absolute address $0003.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $0E1B00.l		; 0F 00 1B 0E ; OR accumulator with memory (long) $0E1B00.l [Writes: Accumulator] [Flags: ZN]
	ora $1B3509.l,X		; 1F 09 35 1B ; Logical OR long $1B3509.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$1C.b],Y		; 37 1C ; AND accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $00F818.l,X		; 7F 18 F8 00 ; Add long $00F818.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F3B19.l,X		; 1F 19 3B 3F ; Logical OR long $3F3B19.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($C09F.w,X)		; 7C 9F C0 ; Jump indirect indexed to ($C09F.w,X) [Reads: X Index] [Flow: jump]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F4,$00		; 44 00 F4 ; Move block positive $F4,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: ZNC]
	cpx $3C00.w		; EC 00 3C ; Compare $3C00.w with X register [Reads: X Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $B8		; 30 B8 ; Branch if minus to $30, $B8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx $1C8C.w		; EC 8C 1C ; Compare $1C8C.w with X register [Reads: X Index] [Flags: ZNC]
	pea $0003.w		; F4 03 00 ; Push absolute address $0003.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2D.b,X)		; 01 2D ; Logical OR ($2D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $2E.b		; 06 2E ; Arithmetic shift left $2E.b [Reads: Direct Page] [Flags: ZNC]
	ora ($37.b,X)		; 01 37 ; Logical OR ($37.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	ora $39373E.l,X		; 1F 3E 37 39 ; Logical OR long $39373E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $7883.w,X		; 3C 83 78 ; Test bits $7883.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jsr $D038.w		; 20 38 D0 ; Jump to subroutine at $D038.w [Writes: Stack Pointer] [Flow: call]
	jsr ($7C20.w,X)		; FC 20 7C ; Jump to subroutine indirect indexed ($7C20.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$EA.b		; E0 EA ; Compare #$EA.b with X register [Reads: X Index] [Flags: ZNC]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	bit $F4.b,X		; 34 F4 ; Test bits $F4.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	inc $03FE.w,X		; FE FE 03 ; Increment memory $03FE.w,X [Reads: X Index] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $19.b		; 02 19 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $260D1A.l		; 0F 1A 0D 26 ; OR accumulator with memory (long) $260D1A.l [Writes: Accumulator] [Flags: ZN]
	ora $0F31.w,Y		; 19 31 0F ; OR accumulator with memory $0F31.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $76.b		; 06 76 ; Arithmetic shift left $76.b [Reads: Direct Page] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $391D1F.l		; 0F 1F 1D 39 ; OR accumulator with memory (long) $391D1F.l [Writes: Accumulator] [Flags: ZN]
	and $835F7F.l,X		; 3F 7F 5F 83 ; AND accumulator with memory (long,X) $835F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00B8.w		; 2E B8 00 ; Rotate left $00B8.w [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $80, $D4		; 80 D4 ; Branch always to $80, $D4 [Flow: branch]
	.db $80, $E4		; 80 E4 ; Branch always to $80, $E4 [Flow: branch]
	.db $80, $94		; 80 94 ; Branch always to $80, $94 [Flow: branch]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($ECFC.w,X)		; FC FC EC ; Jump to subroutine indirect indexed ($ECFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stz $0020.w		; 9C 20 00 ; Store zero to $0020.w
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sbc $04FFBF.l,X		; FF BF FF 04 ; Subtract with carry (long,X) $04FFBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $0F,$00		; 44 00 0F ; Move block positive $0F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $F7001F.l		; 0F 1F 00 F7 ; OR accumulator with memory (long) $F7001F.l [Writes: Accumulator] [Flags: ZN]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $FDFB.w,X		; 1D FB FD ; OR accumulator with memory $FDFB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $0A0023.l,X		; FF 23 00 0A ; Subtract with carry (long,X) $0A0023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $7C00.w,X		; 3C 00 7C ; Test bits $7C00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3C0500.l		; 22 00 05 3C ; Jump to subroutine long $3C0500.l [Writes: Stack Pointer] [Flow: call]
	.db $50, $BC		; 50 BC ; Branch if overflow clear to $50, $BC [Flow: branch]
	sbc $2795C5.l,X		; FF C5 95 27 ; Subtract with carry (long,X) $2795C5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cpx $FC00.w		; EC 00 FC ; Compare $FC00.w with X register [Reads: X Index] [Flags: ZNC]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $EC54.w		; 9C 54 EC ; Store zero to $EC54.w
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sty $32.b		; 84 32 ; Store Y register to $32.b [Reads: Y Index]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $549C.w		; 0C 9C 54 ; Test and set bits $549C.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	ora ($3E.b,S),Y		; 13 3E ; OR accumulator (stack relative indirect indexed) ($3E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $370900.l		; 22 00 09 37 ; Jump to subroutine long $370900.l [Writes: Stack Pointer] [Flow: call]
	and $1C2F3F.l		; 2F 3F 2F 1C ; AND accumulator with memory (long) $1C2F3F.l [Writes: Accumulator] [Flags: ZN]
	ora $160003.l		; 0F 03 00 16 ; OR accumulator with memory (long) $160003.l [Writes: Accumulator] [Flags: ZN]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	cpx $0600.w		; EC 00 06 ; Compare $0600.w with X register [Reads: X Index] [Flags: ZNC]
	jmp.w [$6808]		; DC 08 68 ; Jump long indirect [$6808] [Flow: jump]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FA1400.l		; 22 00 14 FA ; Jump to subroutine long $FA1400.l [Writes: Stack Pointer] [Flow: call]
	jsr ($34DC.w,X)		; FC DC 34 ; Jump to subroutine indirect indexed ($34DC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3F0600.l		; 22 00 06 3F ; Jump to subroutine long $3F0600.l [Writes: Stack Pointer] [Flow: call]
	rol $5D7F.w,X		; 3E 7F 5D ; Rotate left $5D7F.w,X [Reads: X Index] [Flags: ZNC]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $5C0043.l		; 0F 43 00 5C ; OR accumulator with memory (long) $5C0043.l [Writes: Accumulator] [Flags: ZN]
	ora #$FC08.w		; 09 08 FC ; Logical OR #$FC08.w with accumulator [Writes: Accumulator] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $D8		; 10 D8 ; Branch if plus to $10, $D8 [Flow: branch]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FC0E00.l		; 22 00 0E FC ; Jump to subroutine long $FC0E00.l [Writes: Stack Pointer] [Flow: call]
	pea $C864.w		; F4 64 C8 ; Push absolute address $C864.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $87.b		; 85 87 ; Store accumulator to $87.b [Reads: Accumulator]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $3B3F34.l,X		; 7F 34 3F 3B ; Add long $3B3F34.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $94.b,S		; 83 94 ; Store accumulator (stack relative) $94.b,S [Reads: Accumulator, Stack Pointer]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	pea $BC00.w		; F4 00 BC ; Push absolute address $BC00.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FC0D00.l		; 22 00 0D FC ; Jump to subroutine long $FC0D00.l [Writes: Stack Pointer] [Flow: call]
	cpy $FCE4.w		; CC E4 FC ; Compare $FCE4.w with Y register [Reads: Y Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $09.b,X		; 36 09 ; Rotate left $09.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sta $08.b,S		; 83 08 ; Store accumulator (stack relative) $08.b,S [Reads: Accumulator, Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3E0000.l		; 22 00 00 3E ; Jump to subroutine long $3E0000.l [Writes: Stack Pointer] [Flow: call]
	jsl $38103F.l		; 22 3F 10 38 ; Jump to subroutine long $38103F.l [Writes: Stack Pointer] [Flow: call]
	ora $6A0007.l,X		; 1F 07 00 6A ; Logical OR long $6A0007.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $FC		; 10 FC ; Branch if plus to $10, $FC [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldy $5808.w		; AC 08 58 ; Load $5808.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $10, $B0		; 10 B0 ; Branch if plus to $10, $B0 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $DE0E00.l		; 22 00 0E DE ; Jump to subroutine long $DE0E00.l [Writes: Stack Pointer] [Flow: call]
	cpx $74F4.w		; EC F4 74 ; Compare $74F4.w with X register [Reads: X Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2E.b		; 04 2E ; Test and set bits $2E.b [Reads: Accumulator] [Flags: Z]
	sta $87.b		; 85 87 ; Store accumulator to $87.b [Reads: Accumulator]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3B37.w,X		; 3E 37 3B ; Rotate left $3B37.w,X [Reads: X Index] [Flags: ZNC]
	and $9483.w,X		; 3D 83 94 ; AND accumulator with memory $9483.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr ($EC00.w,X)		; FC 00 EC ; Jump to subroutine indirect indexed ($EC00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $01.b,S		; 83 01 ; Store accumulator (stack relative) $01.b,S [Reads: Accumulator, Stack Pointer]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $B4.b,X		; 74 B4 ; Store zero to $B4.b,X [Reads: X Index]
	jsr ($83FC.w,X)		; FC FC 83 ; Jump to subroutine indirect indexed ($83FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldy $0A01.w		; AC 01 0A ; Load $0A01.w into Y register [Writes: Y Index] [Flags: ZN]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6B.b		; 00 6B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: ZNC]
	sta $3F7FBF.l,X		; 9F BF 7F 3F ; Store accumulator (long,X) $3F7FBF.l,X [Reads: Accumulator, X Index]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$00.b],Y		; D7 00 ; Compare accumulator (long indexed) [$00.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	dec $00.b,X		; D6 00 ; Decrement memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	inc $7A00.w		; EE 00 7A ; Increment $7A00.w [Flags: ZN]
	brk $72.b		; 00 72 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DEFE.w,X		; FD FE DE ; Subtract with carry $DEFE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $664E.w,X		; 7E 4E 66 ; Rotate right $664E.w,X [Reads: X Index] [Flags: ZNC]
	bit $00D5.w,X		; 3C D5 00 ; Test bits $00D5.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lda $464800.l,X		; BF 00 48 46 ; Load long $464800.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$48.b		; E0 48 ; Compare #$48.b with X register [Reads: X Index] [Flags: ZNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	lda $074FFF.l,X		; BF FF 4F 07 ; Load long $074FFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $7C00.w		; 8C 00 7C ; Store Y register to $7C00.w [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $78F8.w		; F4 F8 78 ; Push absolute address $78F8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	sbc $00D500.l		; EF 00 D5 00 ; Subtract with carry (long) $00D500.l [Writes: Accumulator] [Flags: ZVNC]
	ldx $4F00.w,Y		; BE 00 4F ; Load X register $4F00.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $95.b		; 00 95 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $144CFF.l,X		; BF FF 4C 14 ; Load long $144CFF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $17.b,S		; 23 17 ; AND accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $9C0074.l		; 0F 74 00 9C ; OR accumulator with memory (long) $9C0074.l [Writes: Accumulator] [Flags: ZN]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $56.b		; 04 56 ; Test and set bits $56.b [Reads: Accumulator] [Flags: Z]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $EC0A00.l		; 22 00 0A EC ; Jump to subroutine long $EC0A00.l [Writes: Stack Pointer] [Flow: call]
	jsr ($7AEE.w,X)		; FC EE 7A ; Jump to subroutine indirect indexed ($7AEE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $80FC.w,X		; FE FC 80 ; Increment memory $80FC.w,X [Reads: X Index] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F0,$00		; 44 00 F0 ; Move block positive $F0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($CC.b)		; 12 CC ; OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$90.b		; A0 90 ; Load #$90.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $D0, $BC		; D0 BC ; Branch if not equal to $D0, $BC [Flow: branch]
	lda $023C7B.l,X		; BF 7B 3C 02 ; Load long $023C7B.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $0F,$00		; 44 00 0F ; Move block positive $0F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: ZNC]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$00.b],Y		; D7 00 ; Compare accumulator (long indexed) [$00.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $DEFD.w,X		; 3D FD DE ; AND accumulator with memory $DEFD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $0007.w,X		; 3C 07 00 ; Test bits $0007.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora #$1700.w		; 09 00 17 ; Logical OR #$1700.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CD.b		; 00 CD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $77231B.l		; 0F 1B 23 77 ; OR accumulator with memory (long) $77231B.l [Writes: Accumulator] [Flags: ZN]
	sta $80FEBF.l,X		; 9F BF FE 80 ; Store accumulator (long,X) $80FEBF.l,X [Reads: Accumulator, X Index]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6D.b		; 00 6D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F9FE.w,X)		; FC FE F9 ; Jump to subroutine indirect indexed ($F9FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc [$BF.b],Y		; F7 BF ; Subtract with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $23FE.w,X		; 1E FE 23 ; Arithmetic shift left $23FE.w,X [Reads: X Index] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $2B.b		; 84 2B ; Store Y register to $2B.b [Reads: Y Index]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ldx $6600.w		; AE 00 66 ; Load $6600.w into X register [Writes: X Index] [Flags: ZN]
	jsl $3B0800.l		; 22 00 08 3B ; Jump to subroutine long $3B0800.l [Writes: Stack Pointer] [Flow: call]
	eor $F5B39F.l		; 4F 9F B3 F5 ; Exclusive OR accumulator with memory (long) $F5B39F.l [Writes: Accumulator] [Flags: ZN]
	adc $003C.w,X		; 7D 3C 00 ; Add $003C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $0046.w,X		; FE 46 00 ; Increment memory $0046.w,X [Reads: X Index] [Flags: ZN]
	sbc $FE0D.w,X		; FD 0D FE ; Subtract with carry $FE0D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc [$E7.b],Y		; F7 E7 ; Subtract with carry (long indexed) [$E7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $ECFC.w		; 0E FC EC ; Arithmetic shift left $ECFC.w [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,S),Y		; 13 03 ; OR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $003F47.l		; 0F 47 3F 00 ; OR accumulator with memory (long) $003F47.l [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $237737.l,X		; 1F 37 77 23 ; Logical OR long $237737.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$1F.b		; C0 1F ; Compare #$1F.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $FF101F.l		; EF 1F 10 FF ; Subtract with carry (long) $FF101F.l [Writes: Accumulator] [Flags: ZVNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sbc $C00000.l,X		; FF 00 00 C0 ; Subtract with carry (long,X) $C00000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $EFFFEF.l,X		; 1F EF FF EF ; Logical OR long $EFFFEF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($0F.b,S),Y		; F3 0F ; Subtract with carry (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$F5FF.w		; 09 FF F5 ; Logical OR #$F5FF.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $FBFF07.l,X		; FF 07 FF FB ; Subtract with carry (long,X) $FBFF07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$46.b]		; 07 46 ; OR accumulator with memory (long) [$46.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $0F7E8D.l,X		; 3F 8D 7E 0F ; AND accumulator with memory (long,X) $0F7E8D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $07F7FF.l,X		; FF FF F7 07 ; Subtract with carry (long,X) $07F7FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $24FD7E.l,X		; FF 7E FD 24 ; Subtract with carry (long,X) $24FD7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl $F8.b,X		; 16 F8 ; Arithmetic shift left $F8.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora ($FC.b)		; 12 FC ; OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $F40AFC.l		; 22 FC 0A F4 ; Jump to subroutine long $F40AFC.l [Writes: Stack Pointer] [Flow: call]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: ZNC]
	.db $62, $BC, $A2		; 62 BC A2 ; Push effective relative address $62, $BC, $A2 [Writes: Stack Pointer]
	jmp ($F6E4.w,X)		; 7C E4 F6 ; Jump indirect indexed to ($F6E4.w,X) [Reads: X Index] [Flow: jump]
	sbc ($62.b)		; F2 62 ; Subtract with carry (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl $62.b		; 06 62 ; Arithmetic shift left $62.b [Reads: Direct Page] [Flags: ZNC]
	ldx #$25.b		; A2 25 ; Load #$25.b into X register [Writes: X Index] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $68		; F0 68 ; Branch if equal to $F0, $68 [Flow: branch]
	.db $F0, $2C		; F0 2C ; Branch if equal to $F0, $2C [Flow: branch]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx $0029.w		; EC 29 00 ; Compare $0029.w with X register [Reads: X Index] [Flags: ZNC]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $7C0030.l		; 22 30 00 7C ; Jump to subroutine long $7C0030.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $FA		; 30 FA ; Branch if minus to $30, $FA [Flow: branch]
	tsb $7D.b		; 04 7D ; Test and set bits $7D.b [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $F1FF.w		; 0E FF F1 ; Arithmetic shift left $F1FF.w [Flags: ZNC]
	ora $300000.l		; 0F 00 00 30 ; OR accumulator with memory (long) $300000.l [Writes: Accumulator] [Flags: ZN]
	jmp ($7DFA.w,X)		; 7C FA 7D ; Jump indirect indexed to ($7DFA.w,X) [Reads: X Index] [Flow: jump]
	asl $38F7.w		; 0E F7 38 ; Arithmetic shift left $38F7.w [Flags: ZNC]
	sbc [$8C.b],Y		; F7 8C ; Subtract with carry (long indexed) [$8C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $CCFF32.l,X		; FF 32 FF CC ; Subtract with carry (long,X) $CCFF32.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($FA.b,S),Y		; 33 FA ; AND accumulator (stack relative indirect indexed) ($FA.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $477FE0.l		; 0F E0 7F 47 ; OR accumulator with memory (long) $477FE0.l [Writes: Accumulator] [Flags: ZN]
	sbc $FF224C.l,X		; FF 4C 22 FF ; Subtract with carry (long,X) $FF224C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $CD33.w,X		; 1D 33 CD ; OR accumulator with memory $CD33.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $CCDFFF.l,X		; FF FF DF CC ; Subtract with carry (long,X) $CCDFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FC.b)		; 12 FC ; OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($FEC1.w,X)		; FC C1 FE ; Jump to subroutine indirect indexed ($FEC1.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor ($FE.b,X)		; 41 FE ; Exclusive OR accumulator with memory ($FE.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor #$D9FE.w		; 49 FE D9 ; Exclusive OR #$D9FE.w with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $FC13.w,X		; FE 13 FC ; Increment memory $FC13.w,X [Reads: X Index] [Flags: ZN]
.ACCU 16
.INDEX 16
	rep #$3C		; C2 3C
	sbc ($FA.b)		; F2 FA ; Subtract with carry (indirect) ($FA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $D9F9.w,Y		; F9 F9 D9 ; Subtract with carry $D9F9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $C213.w,Y		; D9 13 C2 ; Compare accumulator $C213.w,Y [Reads: Y Index] [Flags: ZNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$70.b]		; 07 70 ; OR accumulator with memory (long) [$70.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $64		; 70 64 ; Branch if overflow set to $70, $64 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $F8.b,X		; 94 F8 ; Store Y register $F8.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $70.b		; 04 70 ; Test and set bits $70.b [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	stz $F4.b		; 64 F4 ; Store zero to $F4.b
	and ($84.b,S),Y		; 33 84 ; AND accumulator (stack relative indirect indexed) ($84.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $2A.b		; 04 2A ; Test and set bits $2A.b [Reads: Accumulator] [Flags: Z]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: ZNC]
	bit $3D3B.w,X		; 3C 3B 3D ; Test bits $3D3B.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $84001E.l		; 2F 1E 00 84 ; AND accumulator with memory (long) $84001E.l [Writes: Accumulator] [Flags: ZN]
	eor ($01.b,X)		; 41 01 ; Exclusive OR accumulator with memory ($01.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $00D4.w,X		; 1E D4 00 ; Arithmetic shift left $00D4.w,X [Reads: X Index] [Flags: ZNC]
	rol $EE00.w		; 2E 00 EE ; Rotate left $EE00.w [Flags: ZNC]
	brk $56.b		; 00 56 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F6FC.w,X		; 3C FC F6 ; Test bits $F6FC.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inc $7A.b,X		; F6 7A ; Increment memory $7A.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	ror $673C.w,X		; 7E 3C 67 ; Rotate right $673C.w,X [Reads: X Index] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$64.b],Y		; 17 64 ; OR accumulator with memory (long indexed) [$64.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	ora [$13.b],Y		; 17 13 ; OR accumulator with memory (long indexed) [$13.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $320000.l		; 0F 00 00 32 ; OR accumulator with memory (long) $320000.l [Writes: Accumulator] [Flags: ZN]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FC04.w,X		; FE 04 FC ; Increment memory $FC04.w,X [Reads: X Index] [Flags: ZN]
	dec $9CBE.w,X		; DE BE 9C ; Decrement memory $9CBE.w,X [Reads: X Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $DC.b,S		; 83 DC ; Store accumulator (stack relative) $DC.b,S [Reads: Accumulator, Stack Pointer]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $15100F.l		; 22 0F 10 15 ; Jump to subroutine long $15100F.l [Writes: Stack Pointer] [Flow: call]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$74.b]		; 07 74 ; OR accumulator with memory (long) [$74.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $9C0000.l		; 22 00 00 9C ; Jump to subroutine long $9C0000.l [Writes: Stack Pointer] [Flow: call]
	and $FC.b,S		; 23 FC ; AND accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $80F8.w		; 0E F8 80 ; Arithmetic shift left $80F8.w [Flags: ZNC]
	brk $57.b		; 00 57 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	lda #$DF70.w		; A9 70 DF ; Load #$DF70.w into accumulator [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pea $534F.w		; F4 4F 53 ; Push absolute address $534F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $831F28.l		; 0F 28 1F 83 ; OR accumulator with memory (long) $831F28.l [Writes: Accumulator] [Flags: ZN]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	ora [$77.b]		; 07 77 ; OR accumulator with memory (long) [$77.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc #$F7DF.w		; E9 DF F7 ; Subtract #$F7DF.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	sec		; 38 ; Set carry flag [Flags: C]
	adc [$E9.b],Y		; 77 E9 ; Add with carry (long indexed) [$E9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta [$C0.b],Y		; 97 C0 ; Store accumulator (long indexed) [$C0.b],Y [Reads: Accumulator, Direct Page, Y Index]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	jsr ($F8C4.w,X)		; FC C4 F8 ; Jump to subroutine indirect indexed ($F8C4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$22C0.w		; C0 C0 22 ; Compare #$22C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b)		; 12 04 ; OR accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$0149.w		; E0 49 01 ; Compare #$0149.w with X register [Reads: X Index] [Flags: ZNC]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	cpy #$0100.w		; C0 00 01 ; Compare #$0100.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda ($7C.b)		; B2 7C ; Load accumulator (indirect) ($7C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($3E.b),Y		; 51 3E ; Exclusive OR accumulator with memory ($3E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc #$491E.w		; 69 1E 49 ; Add #$491E.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	rol $7C92.w,X		; 3E 92 7C ; Rotate left $7C92.w,X [Reads: X Index] [Flags: ZNC]
	bit $F8.b,X		; 34 F8 ; Test bits $F8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($79.b),Y		; 71 79 ; Add with carry ($79.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $F4F2.w,Y		; 79 F2 F4 ; Add $F4F2.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $B3		; F0 B3 ; Branch if equal to $F0, $B3 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pei ($63.b)		; D4 63 ; Push effective indirect address ($63.b) [Reads: Direct Page] [Writes: Stack Pointer]
	eor $3227.w,Y		; 59 27 32 ; Exclusive OR accumulator with memory $3227.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $1E0E15.l		; 0F 15 0E 1E ; OR accumulator with memory (long) $1E0E15.l [Writes: Accumulator] [Flags: ZN]
	tsb $040A.w		; 0C 0A 04 ; Test and set bits $040A.w [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sbc ($D7.b,S),Y		; F3 D7 ; Subtract with carry (stack relative indirect indexed) ($D7.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $1E1D3E.l,X		; 5F 3E 1D 1E ; Exclusive OR accumulator with memory (long,X) $1E1D3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: ZNC]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: ZNC]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: ZNC]
	ora $8E0B0D.l		; 0F 0D 0B 8E ; OR accumulator with memory (long) $8E0B0D.l [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	sbc $044A85.l,X		; FF 85 4A 04 ; Subtract with carry (long,X) $044A85.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $CCB3.w		; 0C B3 CC ; Test and set bits $CCB3.w [Reads: Accumulator] [Flags: Z]
	adc $844B80.l,X		; 7F 80 4B 84 ; Add long $844B80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta [$A8.b]		; 87 A8 ; Store accumulator (long) [$A8.b] [Reads: Accumulator, Direct Page]
	cmp [$EC.b]		; C7 EC ; Compare accumulator (long) [$EC.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $B31200.l		; 22 00 12 B3 ; Jump to subroutine long $B31200.l [Writes: Stack Pointer] [Flow: call]
	adc $AB6F4B.l,X		; 7F 4B 6F AB ; Add long $AB6F4B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $0007.w		; EC 07 00 ; Compare $0007.w with X register [Reads: X Index] [Flags: ZNC]
	inc $38.b		; E6 38 ; Increment $38.b [Reads: Direct Page] [Flags: ZN]
	pea $9478.w		; F4 78 94 ; Push absolute address $9478.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $F8.b		; 24 F8 ; Test bits $F8.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc $F4.b		; E6 F4 ; Increment $F4.b [Reads: Direct Page] [Flags: ZN]
	pea $08E4.w		; F4 E4 08 ; Push absolute address $08E4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $03,$01		; 44 01 03 ; Move block positive $03,$01 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $27FF00.l		; 22 00 FF 27 ; Jump to subroutine long $27FF00.l [Writes: Stack Pointer] [Flow: call]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr $B70C.w		; 4E 0C B7 ; Logical shift right $B70C.w [Flags: ZNC]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $FB76.w,X		; 3C 76 FB ; Test bits $FB76.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($30.b)		; 72 30 ; Add with carry (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $2360.w		; ED 60 23 ; Subtract $2360.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $DF6E.w,X		; 3C 6E DF ; Test bits $DF6E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsb $1400.w		; 0C 00 14 ; Test and set bits $1400.w [Reads: Accumulator] [Flags: Z]
	mvp $2C,$08		; 44 08 2C ; Move block positive $2C,$08 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($26.b)		; 12 26 ; OR accumulator with memory (indirect) ($26.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	tsb $060D.w		; 0C 0D 06 ; Test and set bits $060D.w [Reads: Accumulator] [Flags: Z]
	tsb $3C1C.w		; 0C 1C 3C ; Test and set bits $3C1C.w [Reads: Accumulator] [Flags: Z]
	bit $1E3E.w,X		; 3C 3E 1E ; Test bits $1E3E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $0F.b,X		; 16 0F ; Arithmetic shift left $0F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	mvp $34,$10		; 44 10 34 ; Move block positive $34,$10 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $682064.l		; 0F 64 20 68 ; OR accumulator with memory (long) $682064.l [Writes: Accumulator] [Flags: ZN]
	jsr $3078.w		; 20 78 30 ; Jump to subroutine at $3078.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $60		; B0 60 ; Branch if carry set to $B0, $60 [Flow: branch]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	bit $7C3C.w,X		; 3C 3C 7C ; Test bits $7C3C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $F0, $27		; F0 27 ; Branch if equal to $F0, $27 [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1600.w		; 0C 00 16 ; Test and set bits $1600.w [Reads: Accumulator] [Flags: Z]
	tsb $1C2F.w		; 0C 2F 1C ; Test and set bits $1C2F.w [Reads: Accumulator] [Flags: Z]
	and $00231C.l,X		; 3F 1C 23 00 ; AND accumulator with memory (long,X) $00231C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $3B3B.w,X		; 1E 3B 3B ; Arithmetic shift left $3B3B.w,X [Reads: X Index] [Flags: ZNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$30.b]		; 07 30 ; OR accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F4		; 30 F4 ; Branch if minus to $30, $F4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($2338.w,X)		; FC 38 23 ; Jump to subroutine indirect indexed ($2338.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	jmp.w [$00DC]		; DC DC 00 ; Jump long indirect [$00DC] [Flow: jump]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($3E.b,X)		; 21 3E ; Logical AND ($3E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($3F.b,S),Y		; 13 3F ; OR accumulator (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($2F.b)		; 12 2F ; OR accumulator with memory (indirect) ($2F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1C.b,X		; 16 1C ; Arithmetic shift left $1C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($73.b,X)		; 21 73 ; Logical AND ($73.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $1F3E3E.l,X		; 3F 3E 3E 1F ; AND accumulator with memory (long,X) $1F3E3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $A000E0.l		; 0F E0 00 A0 ; OR accumulator with memory (long) $A000E0.l [Writes: Accumulator] [Flags: ZN]
	cpy #$C060.w		; C0 60 C0 ; Compare #$C060.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx $40.b		; E4 40 ; Compare $40.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	inc $7C44.w		; EE 44 7C ; Increment $7C44.w [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	bit $B4E8.w,X		; 3C E8 B4 ; Test bits $B4E8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jsl $6401E0.l		; 22 E0 01 64 ; Jump to subroutine long $6401E0.l [Writes: Stack Pointer] [Flow: call]
	ror $FC22.w		; 6E 22 FC ; Rotate right $FC22.w [Flags: ZNC]
	cpx #$0038.w		; E0 38 00 ; Compare #$0038.w with X register [Reads: X Index] [Flags: ZNC]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	stz $38.b,X		; 74 38 ; Store zero to $38.b,X [Reads: X Index]
	and $173E00.l,X		; 3F 00 3E 17 ; AND accumulator with memory (long,X) $173E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $77F90B.l,X		; 5F 0B F9 77 ; Exclusive OR accumulator with memory (long,X) $77F90B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp ($273F.w,X)		; 7C 3F 27 ; Jump indirect indexed to ($273F.w,X) [Reads: X Index] [Flow: jump]
	adc $0000FF.l		; 6F FF 00 00 ; Add with carry (long) $0000FF.l [Writes: Accumulator] [Flags: ZVNC]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	rol $5C04.w,X		; 3E 04 5C ; Rotate left $5C04.w,X [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F83C.w		; E0 3C F8 ; Compare #$F83C.w with X register [Reads: X Index] [Flags: ZNC]
	rol $CC.b,X		; 36 CC ; Rotate left $CC.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $F87C.w,X		; 3E 7C F8 ; Rotate left $F87C.w,X [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($00CE.w,X)		; FC CE 00 ; Jump to subroutine indirect indexed ($00CE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $1D		; 10 1D ; Branch if plus to $10, $1D [Flow: branch]
	asl $871F.w		; 0E 1F 87 ; Arithmetic shift left $871F.w [Flags: ZNC]
	cmp #$0300.w		; C9 00 03 ; Compare #$0300.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	.db $10, $3E		; 10 3E ; Branch if plus to $10, $3E [Flow: branch]
	ora $D5841F.l,X		; 1F 1F 84 D5 ; Logical OR long $D5841F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: ZNC]
	sbc $FE3DE0.l,X		; FF E0 3D FE ; Subtract with carry (long,X) $FE3DE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: ZN]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	sbc $01E7FF.l,X		; FF FF E7 01 ; Subtract with carry (long,X) $01E7FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($8B.b,X)		; 01 8B ; Logical OR ($8B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sty $00.b,X		; 94 00 ; Store Y register $00.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $85.b,S		; 23 85 ; AND accumulator with stack relative $85.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldx #$1F00.w		; A2 00 1F ; Load #$1F00.w into X register [Writes: X Index] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy $80.b		; C4 80 ; Compare $80.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	dec $7C84.w		; CE 84 7C ; Decrement $7C84.w [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($F448.w,X)		; FC 48 F4 ; Jump to subroutine indirect indexed ($F448.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx #$E030.w		; E0 30 E0 ; Compare #$E030.w with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $C4		; 80 C4 ; Branch always to $80, $C4 [Flow: branch]
	dec $7CFC.w		; CE FC 7C ; Decrement $7CFC.w [Flags: ZN]
	jmp ($F0F8.w,X)		; 7C F8 F0 ; Jump indirect indexed to ($F0F8.w,X) [Reads: X Index] [Flow: jump]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $40BC.w		; 20 BC 40 ; Jump to subroutine at $40BC.w [Writes: Stack Pointer] [Flow: call]
	adc ($3C.b)		; 72 3C ; Add with carry (indirect) ($3C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta [$C8.b]		; 87 C8 ; Store accumulator (long) [$C8.b] [Reads: Accumulator, Direct Page]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FC70.w		; 20 70 FC ; Jump to subroutine at $FC70.w [Writes: Stack Pointer] [Flow: call]
	ror $D48F.w,X		; 7E 8F D4 ; Rotate right $D48F.w,X [Reads: X Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $37F8.w,X		; 3E F8 37 ; Rotate left $37F8.w,X [Reads: X Index] [Flags: ZNC]
	dec $E885.w		; CE 85 E8 ; Decrement $E885.w [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $FE		; Opcode FE overrunning bank boundry at 0AFFFF. Skipping. ; Increment memory $FE [Reads: X Index] [Flags: ZN]
.ENDS
