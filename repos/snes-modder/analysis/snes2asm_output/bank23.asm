.BANK 23 SLOT 0
.ORG $0000

.SECTION "Bank23" FORCE

	bit $38F8.w,X		; 3C F8 38 ; Test bits $38F8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: ZNC]
	adc $767B.w,X		; 7D 7B 76 ; Add $767B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $7C.b		; 86 7C ; Store X register to $7C.b [Reads: X Index]
	ldy $E0F8.w,X		; BC F8 E0 ; Load Y register $E0F8.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $80, $2E		; 80 2E ; Branch always to $80, $2E [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $2C		; 80 2C ; Branch always to $80, $2C [Flow: branch]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1B07.w		; 0D 07 1B ; Logical OR $1B07.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $220E1F.l		; 0F 1F 0E 22 ; OR accumulator with memory (long) $220E1F.l [Writes: Accumulator] [Flags: ZN]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$13.b		; 09 13 ; Logical OR #$13.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $3C000F.l,X		; 1F 0F 00 3C ; Logical OR long $3C000F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$F8.b]		; 07 F8 ; OR accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $F143.w		; 2D 43 F1 ; Logical AND $F143.w with accumulator [Writes: Accumulator] [Flags: ZN]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora $BBE8.w		; 0D E8 BB ; Logical OR $BBE8.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $D0, $77		; D0 77 ; Branch if not equal to $D0, $77 [Flow: branch]
	sta ($F2.b)		; 92 F2 ; Store accumulator (indirect) ($F2.b) [Reads: Accumulator, Direct Page]
	ora $76FB3C.l		; 0F 3C FB 76 ; OR accumulator with memory (long) $76FB3C.l [Writes: Accumulator] [Flags: ZN]
	inc $E7.b,X		; F6 E7 ; Increment memory $E7.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cmp $08838D.l		; CF 8D 83 08 ; Compare accumulator (long) $08838D.l [Reads: Accumulator] [Flags: ZNC]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $1C00.w		; 0D 00 1C ; Logical OR $1C00.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora #$36.b		; 09 36 ; Logical OR #$36.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $62, $35, $00		; 62 35 00 ; Push effective relative address $62, $35, $00 [Writes: Stack Pointer]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $3D1F.w		; 0E 1F 3D ; Arithmetic shift left $3D1F.w [Flags: ZNC]
	bit $6A.b,X		; 34 6A ; Test bits $6A.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sta $4A.b,S		; 83 4A ; Store accumulator (stack relative) $4A.b,S [Reads: Accumulator, Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $60.b,S		; 43 60 ; Exclusive OR accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $6C		; 90 6C ; Branch if carry clear to $90, $6C [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $46D8.w		; AC D8 46 ; Load $46D8.w into Y register [Writes: Y Index] [Flags: ZN]
	ldy $8000.w		; AC 00 80 ; Load $8000.w into Y register [Writes: Y Index] [Flags: ZN]
	cpx #$F870.w		; E0 70 F8 ; Compare #$F870.w with X register [Reads: X Index] [Flags: ZNC]
	ldy $562C.w,X		; BC 2C 56 ; Load Y register $562C.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $173F18.l		; 2F 18 3F 17 ; AND accumulator with memory (long) $173F18.l [Writes: Accumulator] [Flags: ZN]
	and $2809.w,Y		; 39 09 28 ; AND accumulator with memory $2809.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor #$39.b		; 49 39 ; Exclusive OR #$39.b with accumulator [Writes: Accumulator] [Flags: ZN]
	adc ($31.b),Y		; 71 31 ; Add with carry ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $2F1703.l,X		; BF 03 17 2F ; Load long $2F1703.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	rol $27.b,X		; 36 27 ; Rotate left $27.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	lsr $6E.b		; 46 6E ; Logical shift right $6E.b [Reads: Direct Page] [Flags: ZNC]
	jsr ($B85C.w,X)		; FC 5C B8 ; Jump to subroutine indirect indexed ($B85C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp.w [$F4B0]		; DC B0 F4 ; Jump long indirect [$F4B0] [Flow: jump]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cpx $98.b		; E4 98 ; Compare $98.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	jmp.w [$82E0]		; DC E0 82 ; Jump long indirect [$82E0] [Flow: jump]
	jsr ($DC22.w,X)		; FC 22 DC ; Jump to subroutine indirect indexed ($DC22.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc ($8C.b)		; 72 8C ; Add with carry (indirect) ($8C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jmp $F4DC.w		; 4C DC F4 ; Jump to $F4DC.w [Flow: jump]
	stz $1C.b		; 64 1C ; Store zero to $1C.b
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($25.b)		; 52 25 ; Exclusive OR accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1402.w		; 0E 02 14 ; Arithmetic shift left $1402.w [Flags: ZNC]
	cop $13.b		; 02 13 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0022.w		; 0C 22 00 ; Test and set bits $0022.w [Reads: Accumulator] [Flags: Z]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	ora $2513.w,X		; 1D 13 25 ; OR accumulator with memory $2513.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E000.w		; C0 00 E0 ; Compare #$E000.w with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $22		; 30 22 ; Branch if minus to $30, $22 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$B020.w		; C0 20 B0 ; Compare #$B020.w with Y register [Reads: Y Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F7C1.w,X		; FE C1 F7 ; Increment memory $F7C1.w,X [Reads: X Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	adc [$66.b]		; 67 66 ; Add with carry (long) [$66.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $040026.l,X		; FF 26 00 04 ; Subtract with carry (long,X) $040026.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $9FC7.w,X		; FE C7 9F ; Increment memory $9FC7.w,X [Reads: X Index] [Flags: ZN]
	sbc ($FF.b,S),Y		; F3 FF ; Subtract with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $7F0800.l		; 22 00 08 7F ; Jump to subroutine long $7F0800.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E0FC.w		; 1C FC E0 ; Test and reset bits $E0FC.w [Reads: Accumulator] [Flags: Z]
	cpx #$0026.w		; E0 26 00 ; Compare #$0026.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $7F.b		; 04 7F ; Test and set bits $7F.b [Reads: Accumulator] [Flags: Z]
	sbc $E0FCFF.l,X		; FF FF FC E0 ; Subtract with carry (long,X) $E0FCFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $E00400.l		; 22 00 04 E0 ; Jump to subroutine long $E00400.l [Writes: Stack Pointer] [Flow: call]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$80C0.w		; E0 C0 80 ; Compare #$80C0.w with X register [Reads: X Index] [Flags: ZNC]
	cpx $34.b		; E4 34 ; Compare $34.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $163F18.l,X		; 3F 18 3F 16 ; AND accumulator with memory (long,X) $163F18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $F11F71.l		; 2F 71 1F F1 ; AND accumulator with memory (long) $F11F71.l [Writes: Accumulator] [Flags: ZN]
	mvp $E3,$7F		; 44 7F E3 ; Move block positive $E3,$7F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	asl $E7.b		; 06 E7 ; Arithmetic shift left $E7.b [Reads: Direct Page] [Flags: ZNC]
	adc $7A3D3F.l,X		; 7F 3F 3D 7A ; Add long $7A3D3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($F0.b),Y		; 71 F0 ; Add with carry ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $9F0BE0.l		; 22 E0 0B 9F ; Jump to subroutine long $9F0BE0.l [Writes: Stack Pointer] [Flow: call]
	sbc $E3FF89.l,X		; FF 89 FF E3 ; Subtract with carry (long,X) $E3FF89.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $7C9CF7.l,X		; 7F F7 9C 7C ; Add long $7C9CF7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	lda [$43.b],Y		; B7 43 ; Load accumulator (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	dec $14.b,X		; D6 14 ; Decrement memory $14.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	sbc $77.b,S		; E3 77 ; Subtract stack-relative $77.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	stz $2948.w		; 9C 48 29 ; Store zero to $2948.w
	and #$62.b		; 29 62 ; Logical AND #$62.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and $35.b,X		; 35 35 ; Logical AND $35.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $19.b		; 14 19 ; Test and reset bits $19.b [Reads: Accumulator] [Flags: Z]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $6A1400.l		; 22 00 14 6A ; Jump to subroutine long $6A1400.l [Writes: Stack Pointer] [Flow: call]
	and $3B.b,X		; 35 3B ; Logical AND $3B.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $0107.w		; 0E 07 01 ; Arithmetic shift left $0107.w [Flags: ZNC]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $58AC.w		; AC AC 58 ; Load $58AC.w into Y register [Writes: Y Index] [Flags: ZN]
	trb $9828.w		; 1C 28 98 ; Test and reset bits $9828.w [Reads: Accumulator] [Flags: Z]
	cpx #$E070.w		; E0 70 E0 ; Compare #$E070.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$8080.w		; E0 80 80 ; Compare #$8080.w with X register [Reads: X Index] [Flags: ZNC]
	jsl $561400.l		; 22 00 14 56 ; Jump to subroutine long $561400.l [Writes: Stack Pointer] [Flow: call]
	ldy $18DC.w		; AC DC 18 ; Load $18DC.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	inc $F921.w,X		; FE 21 F9 ; Increment memory $F921.w,X [Reads: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $07.b,X		; B5 07 ; Load $07.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	ora $7C1C7F.l		; 0F 7F 1C 7C ; OR accumulator with memory (long) $7C1C7F.l [Writes: Accumulator] [Flags: ZN]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	jsl $CA1200.l		; 22 00 12 CA ; Jump to subroutine long $CA1200.l [Writes: Stack Pointer] [Flow: call]
	sta [$E8.b],Y		; 97 E8 ; Store accumulator (long indexed) [$E8.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sbc ($6F.b)		; F2 6F ; Subtract with carry (indirect) ($6F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($0030.w,X)		; 7C 30 00 ; Jump indirect indexed to ($0030.w,X) [Reads: X Index] [Flow: jump]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	tsb $EE.b		; 04 EE ; Test and set bits $EE.b [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pea $DE10.w		; F4 10 DE ; Push absolute address $DE10.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0404.w		; 0E 04 04 ; Arithmetic shift left $0404.w [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $10, $EA		; 10 EA ; Branch if plus to $10, $EA [Flow: branch]
	stx $EC.b,Y		; 96 EC ; Store X register $EC.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	cmp ($0A.b)		; D2 0A ; Compare accumulator (indirect) ($0A.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$1C.b		; 09 1C ; Logical OR #$1C.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $0707.w		; 0C 07 07 ; Test and set bits $0707.w [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	ora $070C.w,X		; 1D 0C 07 ; OR accumulator with memory $070C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $90, $38		; 90 38 ; Branch if carry clear to $90, $38 [Flow: branch]
	.db $50, $30		; 50 30 ; Branch if overflow clear to $50, $30 [Flow: branch]
	cpx #$C0E0.w		; E0 E0 C0 ; Compare #$C0E0.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$0026.w		; C0 26 00 ; Compare #$0026.w with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $78.b		; 04 78 ; Test and set bits $78.b [Reads: Accumulator] [Flags: Z]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	cpy #$32E4.w		; C0 E4 32 ; Compare #$32E4.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$1E2F.w		; E0 2F 1E ; Compare #$1E2F.w with X register [Reads: X Index] [Flags: ZNC]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3B54.w		; 1C 54 3B ; Test and reset bits $3B54.w [Reads: Accumulator] [Flags: Z]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and [$E8.b],Y		; 37 E8 ; AND accumulator with memory (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$D4.b],Y		; 77 D4 ; Add with carry (long indexed) [$D4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $5B077C.l		; 6F 7C 07 5B ; Add with carry (long) $5B077C.l [Writes: Accumulator] [Flags: ZVNC]
	and [$1E.b]		; 27 1E ; AND accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $6B.b,X		; 74 6B ; Store zero to $6B.b,X [Reads: X Index]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cmp [$77.b],Y		; D7 77 ; Compare accumulator (long indexed) [$77.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	eor ($00.b,S),Y		; 53 00 ; XOR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F7E8.w		; E0 E8 F7 ; Compare #$F7E8.w with X register [Reads: X Index] [Flags: ZNC]
	trb $6CEF.w		; 1C EF 6C ; Test and reset bits $6CEF.w [Reads: Accumulator] [Flags: Z]
	sbc $7CFFB2.l,X		; FF B2 FF 7C ; Subtract with carry (long,X) $7CFFB2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta ($00.b,S),Y		; 93 00 ; Store accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	cpx #$EF1F.w		; E0 1F EF ; Compare #$EF1F.w with X register [Reads: X Index] [Flags: ZNC]
	cmp $3DB3EF.l,X		; DF EF B3 3D ; Compare accumulator (long,X) $3DB3EF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	cpy #$0023.w		; C0 23 00 ; Compare #$0023.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	asl $0B.b,X		; 16 0B ; Arithmetic shift left $0B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $2307.w		; 0D 07 23 ; Logical OR $2307.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $20.b,S		; 63 20 ; Add with carry (stack relative) $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $BA.b		; 04 BA ; Test and set bits $BA.b [Reads: Accumulator] [Flags: Z]
	tsb $EA.b		; 04 EA ; Test and set bits $EA.b [Reads: Accumulator] [Flags: Z]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	bit $B616.w		; 2C 16 B6 ; Test bits $B616.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	dec $669D.w,X		; DE 9D 66 ; Decrement memory $669D.w,X [Reads: X Index] [Flags: ZN]
	sta $71CE62.l,X		; 9F 62 CE 71 ; Store accumulator (long,X) $71CE62.l,X [Reads: Accumulator, X Index]
	sbc ($7F.b,X)		; E1 7F ; Subtract with carry ($7F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $3F533F.l		; 6F 3F 53 3F ; Add with carry (long) $3F533F.l [Writes: Accumulator] [Flags: ZVNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	and $9F1F29.l,X		; 3F 29 1F 9F ; AND accumulator with memory (long,X) $9F1F29.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $7FE1CE.l,X		; 9F CE E1 7F ; Store accumulator (long,X) $7FE1CE.l,X [Reads: Accumulator, X Index]
	eor $AC2F5F.l,X		; 5F 5F 2F AC ; Exclusive OR accumulator with memory (long,X) $AC2F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$8C5E.w		; C0 5E 8C ; Compare #$8C5E.w with Y register [Reads: Y Index] [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and $B64FCE.l,X		; 3F CE 4F B6 ; AND accumulator with memory (long,X) $B64FCE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor [$BA.b]		; 47 BA ; Exclusive OR accumulator with memory (long) [$BA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$FA.b],Y		; 57 FA ; Exclusive OR accumulator with memory (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda [$FA.b],Y		; B7 FA ; Load accumulator (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ldy $E552.w		; AC 52 E5 ; Load $E552.w into Y register [Writes: Y Index] [Flags: ZN]
	and ($49.b),Y		; 31 49 ; AND accumulator with memory ($49.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $55.b		; 45 55 ; Exclusive OR $55.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $17.b,X		; F5 17 ; Subtract $17.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $231F2E.l		; 0F 2E 1F 23 ; OR accumulator with memory (long) $231F2E.l [Writes: Accumulator] [Flags: ZN]
	ora $5C073D.l,X		; 1F 3D 07 5C ; Logical OR long $5C073D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $973F6E.l,X		; 3F 6E 3F 97 ; AND accumulator with memory (long,X) $973F6E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $7699.w,X		; 7E 99 76 ; Rotate right $7699.w,X [Reads: X Index] [Flags: ZNC]
	ora [$2E.b],Y		; 17 2E ; OR accumulator with memory (long indexed) [$2E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $3D.b,S		; 23 3D ; AND accumulator with stack relative $3D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp $BBB77E.l		; 5C 7E B7 BB ; Jump long to $BBB77E.l [Flow: jump]
	ldx $C8F0.w		; AE F0 C8 ; Load $C8F0.w into X register [Writes: X Index] [Flags: ZN]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	.db $80, $44		; 80 44 ; Branch always to $80, $44 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	jsl $AE0300.l		; 22 00 03 AE ; Jump to subroutine long $AE0300.l [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	jsl $001880.l		; 22 80 18 00 ; Jump to subroutine long $001880.l [Writes: Stack Pointer] [Flow: call]
	adc $5433.w		; 6D 33 54 ; Add $5433.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $2A3E.w,Y		; 59 3E 2A ; Exclusive OR accumulator with memory $2A3E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $171F2D.l,X		; 1F 2D 1F 17 ; Logical OR long $171F2D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $160F13.l		; 0F 13 0F 16 ; OR accumulator with memory (long) $160F13.l [Writes: Accumulator] [Flags: ZN]
	ora $546D.w		; 0D 6D 54 ; Logical OR $546D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $2F2E.w,Y		; 59 2E 2F ; Exclusive OR accumulator with memory $2F2E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$13.b],Y		; 17 13 ; OR accumulator with memory (long indexed) [$13.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $87.b,X		; 16 87 ; Arithmetic shift left $87.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $BA67D6.l		; AF D6 67 BA ; Load long $BA67D6.l into accumulator [Writes: Accumulator] [Flags: ZN]
	cmp [$FA.b]		; C7 FA ; Compare accumulator (long) [$FA.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc [$84.b],Y		; F7 84 ; Subtract with carry (long indexed) [$84.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda [$00.b],Y		; B7 00 ; Load accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $A9.b,S		; 03 A9 ; OR accumulator with stack relative $A9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $E5.b		; 65 E5 ; Add $E5.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $46.b,X		; F5 46 ; Subtract $46.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($FC.b,S),Y		; 33 FC ; AND accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($FC.b)		; 72 FC ; Add with carry (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($FC.b)		; F2 FC ; Subtract with carry (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $62, $FC, $84		; 62 FC 84 ; Push effective relative address $62, $FC, $84 [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	mvp $38,$38		; 44 38 38 ; Move block positive $38,$38 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	jsl $B30600.l		; 22 00 06 B3 ; Jump to subroutine long $B30600.l [Writes: Stack Pointer] [Flow: call]
	sbc ($F2.b)		; F2 F2 ; Subtract with carry (indirect) ($F2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $62, $84, $44		; 62 84 44 ; Push effective relative address $62, $84, $44 [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($40.b,S),Y		; 13 40 ; OR accumulator (stack relative indirect indexed) ($40.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B3.b		; 00 B3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $D1.b,S		; 03 D1 ; OR accumulator with stack relative $D1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor ($E1.b,X)		; 41 E1 ; Exclusive OR accumulator with memory ($E1.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$CCFF.w		; E0 FF CC ; Compare #$CCFF.w with X register [Reads: X Index] [Flags: ZNC]
	ldx $279F.w		; AE 9F 27 ; Load $279F.w into X register [Writes: X Index] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sbc $6FB390.l		; EF 90 B3 6F ; Subtract with carry (long) $6FB390.l [Writes: Accumulator] [Flags: ZVNC]
	adc $0023F0.l,X		; 7F F0 23 00 ; Add long $0023F0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $37FFFF.l,X		; 7F FF FF 37 ; Add long $37FFFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $72.b		; 24 72 ; Test bits $72.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and $403E71.l		; 2F 71 3E 40 ; AND accumulator with memory (long) $403E71.l [Writes: Accumulator] [Flags: ZN]
	and $3C1F60.l,X		; 3F 60 1F 3C ; AND accumulator with memory (long,X) $3C1F60.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $1F1A3F.l		; 0F 3F 1A 1F ; OR accumulator with memory (long) $1F1A3F.l [Writes: Accumulator] [Flags: ZN]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	brk $72.b		; 00 72 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $4C		; 70 4C ; Branch if overflow set to $70, $4C [Flow: branch]
	ror $3F3E.w,X		; 7E 3E 3F ; Rotate right $3F3E.w,X [Reads: X Index] [Flags: ZNC]
	ora $1BBC06.l,X		; 1F 06 BC 1B ; Logical OR long $1BBC06.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FCCA38.l		; 6F 38 CA FC ; Add with carry (long) $FCCA38.l [Writes: Accumulator] [Flags: ZVNC]
	adc ($FC.b)		; 72 FC ; Add with carry (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sty $78.b		; 84 78 ; Store Y register to $78.b [Reads: Y Index]
	clv		; B8 ; Clear overflow flag [Flags: V]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$0022.w		; C0 22 00 ; Compare #$0022.w with Y register [Reads: Y Index] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jmp ($FAFF.w,X)		; 7C FF FA ; Jump indirect indexed to ($FAFF.w,X) [Reads: X Index] [Flow: jump]
	adc ($04.b)		; 72 04 ; Add with carry (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$C000.w		; C0 00 C0 ; Compare #$C000.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	bit $0100.w		; 2C 00 01 ; Test bits $0100.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cpy #$2580.w		; C0 80 25 ; Compare #$2580.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $26E000.l		; 22 00 E0 26 ; Jump to subroutine long $26E000.l [Writes: Stack Pointer] [Flow: call]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora [$19.b],Y		; 17 19 ; OR accumulator with memory (long indexed) [$19.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $F60007.l		; 0F 07 00 F6 ; OR accumulator with memory (long) $F60007.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pea $CC08.w		; F4 08 CC ; Push absolute address $CC08.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $30, $D4		; 30 D4 ; Branch if minus to $30, $D4 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pei ($F5.b)		; D4 F5 ; Push effective indirect address ($F5.b) [Reads: Direct Page] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $ECF4.w,X		; 3C F4 EC ; Test bits $ECF4.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	dec $8EFB.w,X		; DE FB 8E ; Decrement memory $8EFB.w,X [Reads: X Index] [Flags: ZN]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	ora $080F13.l,X		; 1F 13 0F 08 ; Logical OR long $080F13.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$13.b]		; 27 13 ; AND accumulator with memory (long) [$13.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FC.b)		; 12 FC ; OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx $F8.b		; E4 F8 ; Compare $F8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($E4.b)		; F2 E4 ; Subtract with carry (indirect) ($E4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $AB36.w,Y		; D9 36 AB ; Compare accumulator $AB36.w,Y [Reads: Y Index] [Flags: ZNC]
	lsr $D6.b,X		; 56 D6 ; Logical shift right $D6.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	cpx #$6040.w		; E0 40 60 ; Compare #$6040.w with X register [Reads: X Index] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $FB.b		; 05 FB ; Logical OR $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $E0F0D6.l,X		; BF D6 F0 E0 ; Load long $E0F0D6.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $0400.w,Y		; 39 00 04 ; AND accumulator with memory $0400.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0403.w		; 0C 03 04 ; Test and set bits $0403.w [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0304.w		; 0C 04 03 ; Test and set bits $0304.w [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $72.b		; 02 72 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($8304.w,X)		; FC 04 83 ; Jump to subroutine indirect indexed ($8304.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	cop $28.b		; 02 28 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($04.b)		; 72 04 ; Add with carry (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $E4		; F0 E4 ; Branch if equal to $F0, $E4 [Flow: branch]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $59FE3E.l,X		; FF 3E FE 59 ; Subtract with carry (long,X) $59FE3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $267F65.l,X		; FF 65 7F 26 ; Subtract with carry (long,X) $267F65.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $2F7F27.l,X		; 7F 27 7F 2F ; Add long $2F7F27.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $E7C117.l		; 0F 17 C1 E7 ; OR accumulator with memory (long) $E7C117.l [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $7078.w,Y		; 79 78 70 ; Add $7078.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	adc $FF74EF.l,X		; 7F EF 74 FF ; Add long $FF74EF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FF.b,S),Y		; 13 FF ; OR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $3FE7FF.l		; CF FF E7 3F ; Compare accumulator (long) $3FE7FF.l [Reads: Accumulator] [Flags: ZNC]
	sbc ($DF.b,S),Y		; F3 DF ; Subtract with carry (stack relative indirect indexed) ($DF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7CEF.w,Y		; F9 EF 7C ; Subtract with carry $7CEF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$24.b],Y		; 77 24 ; Add with carry (long indexed) [$24.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1F3F1A.l,X		; FF 1A 3F 1F ; Subtract with carry (long,X) $1F3F1A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $070000.l		; 8F 00 00 07 ; Store accumulator (long) $070000.l [Reads: Accumulator]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($0700.w,X)		; 7C 00 07 ; Jump indirect indexed to ($0700.w,X) [Reads: X Index] [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $FE72.w		; 0E 72 FE ; Arithmetic shift left $FE72.w [Flags: ZNC]
	sta $30.b,S		; 83 30 ; Store accumulator (stack relative) $30.b,S [Reads: Accumulator, Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	eor $E8.b,S		; 43 E8 ; Exclusive OR accumulator with stack relative $E8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cpx #$D830.w		; E0 30 D8 ; Compare #$D830.w with X register [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	cld		; D8 ; Clear decimal flag [Flags: D]
	asl $01D9.w		; 0E D9 01 ; Arithmetic shift left $01D9.w [Flags: ZNC]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $03.b,X		; 74 03 ; Store zero to $03.b,X [Reads: X Index]
	adc [$00.b],Y		; 77 00 ; Add with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	jsl $220402.l		; 22 02 04 22 ; Jump to subroutine long $220402.l [Writes: Stack Pointer] [Flow: call]
	eor [$57.b],Y		; 57 57 ; Exclusive OR accumulator with memory (long indexed) [$57.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp $004600.l		; 5C 00 46 00 ; Jump long to $004600.l [Flow: jump]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $DC		; 80 DC ; Branch always to $80, $DC [Flow: branch]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $1B		; 80 1B ; Branch always to $80, $1B [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	pei ($D4.b)		; D4 D4 ; Push effective indirect address ($D4.b) [Reads: Direct Page] [Writes: Stack Pointer]
	stz $A0.b,X		; 74 A0 ; Store zero to $A0.b,X [Reads: X Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $50, $A0		; 50 A0 ; Branch if overflow clear to $50, $A0 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	.db $50, $54		; 50 54 ; Branch if overflow clear to $50, $54 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	trb $15.b		; 14 15 ; Test and reset bits $15.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $D8		; B0 D8 ; Branch if carry set to $B0, $D8 [Flow: branch]
	jmp ($1B36.w)		; 6C 36 1B ; Jump indirect to ($1B36.w) [Flow: jump]
	asl $4D04.w		; 0E 04 4D ; Arithmetic shift left $4D04.w [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	rol $28.b		; 26 28 ; Rotate left $28.b [Reads: Direct Page] [Flags: ZNC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $17.b,S		; 43 17 ; Exclusive OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	tsb $85.b		; 04 85 ; Test and set bits $85.b [Reads: Accumulator] [Flags: Z]
	.db $62, $00, $00		; 62 00 00 ; Push effective relative address $62, $00, $00 [Writes: Stack Pointer]
	.db $B0, $22		; B0 22 ; Branch if carry set to $B0, $22 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sta $62.b,S		; 83 62 ; Store accumulator (stack relative) $62.b,S [Reads: Accumulator, Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $211E.w,X		; 1E 1E 21 ; Arithmetic shift left $211E.w,X [Reads: X Index] [Flags: ZNC]
	and $001F00.l,X		; 3F 00 1F 00 ; AND accumulator with memory (long,X) $001F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $070044.l		; 0F 44 00 07 ; OR accumulator with memory (long) $070044.l [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2321.w,X		; 1E 21 23 ; Arithmetic shift left $2321.w,X [Reads: X Index] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	mvp $42,$DC		; 44 DC 42 ; Move block positive $42,$DC [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	inc $FBB9.w		; EE B9 FB ; Increment $FBB9.w [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $00FF05.l,X		; FF 05 FF 00 ; Subtract with carry (long,X) $00FF05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$B962]		; DC 62 B9 ; Jump long indirect [$B962] [Flow: jump]
	asl $0107.w		; 0E 07 01 ; Arithmetic shift left $0107.w [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cpx #$0725.w		; E0 25 07 ; Compare #$0725.w with X register [Reads: X Index] [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $C30307.l		; 0F 07 03 C3 ; OR accumulator with memory (long) $C30307.l [Writes: Accumulator] [Flags: ZN]
	brk $65.b		; 00 65 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $BA.b,S		; C3 BA ; Compare accumulator (stack relative) $BA.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc [$98.b]		; E7 98 ; Subtract with carry (long) [$98.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $7DB75A.l,X		; FF 5A B7 7D ; Subtract with carry (long,X) $7DB75A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta ($7E.b,S),Y		; 93 7E ; Store accumulator (stack relative indirect indexed) ($7E.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	sta ($BE.b,X)		; 81 BE ; Store accumulator ($BE.b,X) [Reads: Accumulator, X Index, Direct Page]
	adc ($C3.b,X)		; 61 C3 ; Add with carry ($C3.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $BB.b		; E5 BB ; Subtract $BB.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	eor ($71.b,S),Y		; 53 71 ; XOR accumulator (stack relative indirect indexed) ($71.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $B8		; 70 B8 ; Branch if overflow set to $70, $B8 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $F0.b,S		; 83 F0 ; Store accumulator (stack relative) $F0.b,S [Reads: Accumulator, Stack Pointer]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$86.b]		; 07 86 ; OR accumulator with memory (long) [$86.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $0E1803.l,X		; FF 03 18 0E ; Subtract with carry (long,X) $0E1803.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00.b,S		; E3 00 ; Subtract stack-relative $00.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	bit $E3.b,X		; 34 E3 ; Test bits $E3.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	sbc [$78.b],Y		; F7 78 ; Subtract with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $36FFDC.l,X		; FF DC FF 36 ; Subtract with carry (long,X) $36FFDC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $00BF58.l,X		; DF 58 BF 00 ; Compare accumulator (long,X) $00BF58.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $F4.b,S		; E3 F4 ; Subtract stack-relative $F4.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp $455F3F.l,X		; DF 3F 5F 45 ; Compare accumulator (long,X) $455F3F.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ora $3F010F.l,X		; 1F 0F 01 3F ; Logical OR long $3F010F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $1E3E45.l,X		; 1F 45 3E 1E ; Logical OR long $1E3E45.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($7E.b,X)		; 01 7E ; Logical OR ($7E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rol $1022.w,X		; 3E 22 10 ; Rotate left $1022.w,X [Reads: X Index] [Flags: ZNC]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $410821.l		; 22 21 08 41 ; Jump to subroutine long $410821.l [Writes: Stack Pointer] [Flow: call]
	rol $1E3B.w,X		; 3E 3B 1E ; Rotate left $1E3B.w,X [Reads: X Index] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $1E1F1D.l,X		; 1F 1D 1F 1E ; Logical OR long $1E1F1D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$1D.b]		; 27 1D ; AND accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $C7.b,S		; 03 C7 ; OR accumulator with stack relative $C7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc [$E3.b]		; E7 E3 ; Subtract with carry (long) [$E3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($23.b,X)		; E1 23 ; Subtract with carry ($23.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sep #$04		; E2 04 ; Set processor status bits #$04 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	adc ($0D.b)		; 72 0D ; Add with carry (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	asl $0101.w		; 0E 01 01 ; Arithmetic shift left $0101.w [Flags: ZNC]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $07010F.l,X		; 7F 0F 01 07 ; Add long $07010F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $22.b,S		; 83 22 ; Store accumulator (stack relative) $22.b,S [Reads: Accumulator, Stack Pointer]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $1810.w		; EE 10 18 ; Increment $1810.w [Flags: ZN]
	cpx #$D028.w		; E0 28 D0 ; Compare #$D028.w with X register [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	cpx #$24E0.w		; E0 E0 24 ; Compare #$24E0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $F822.w,X		; DE 22 F8 ; Decrement memory $F822.w,X [Reads: X Index] [Flags: ZN]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$0000.w		; E0 00 00 ; Compare #$0000.w with X register [Reads: X Index] [Flags: ZNC]
	eor $77.b,S		; 43 77 ; Exclusive OR accumulator with stack relative $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $5B.b		; 04 5B ; Test and set bits $5B.b [Reads: Accumulator] [Flags: Z]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $030044.l,X		; 1F 44 00 03 ; Logical OR long $030044.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $3F6C.w,X		; 5E 6C 3F ; Logical shift right $3F6C.w,X [Reads: X Index] [Flags: ZNC]
	ora $010202.l,X		; 1F 02 02 01 ; Logical OR long $010202.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $DC.b,S		; 43 DC ; Exclusive OR accumulator with stack relative $DC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr $B404.w		; 20 04 B4 ; Jump to subroutine at $B404.w [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $6CF4.w		; F4 F4 6C ; Push absolute address $6CF4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	.db $80, $26		; 80 26 ; Branch always to $80, $26 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$FE50.w		; E0 50 FE ; Compare #$FE50.w with X register [Reads: X Index] [Flags: ZNC]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: ZN]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $047FBF.l,X		; DF BF 7F 04 ; Compare accumulator (long,X) $047FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ora $0F0D07.l		; 0F 07 0D 0F ; OR accumulator with memory (long) $0F0D07.l [Writes: Accumulator] [Flags: ZN]
	ora $1F08.w,X		; 1D 08 1F ; OR accumulator with memory $1F08.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0C0718.l		; 0F 18 07 0C ; OR accumulator with memory (long) $0C0718.l [Writes: Accumulator] [Flags: ZN]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: ZNC]
	ora $080F.w		; 0D 0F 08 ; Logical OR $080F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $40		; 70 40 ; Branch if overflow set to $70, $40 [Flow: branch]
	cpx #$F0A0.w		; E0 A0 F0 ; Compare #$F0A0.w with X register [Reads: X Index] [Flags: ZNC]
	.db $B0, $D8		; B0 D8 ; Branch if carry set to $B0, $D8 [Flow: branch]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	cpx #$C030.w		; E0 30 C0 ; Compare #$C030.w with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	cpy #$4020.w		; C0 20 40 ; Compare #$4020.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$F0D0.w		; E0 D0 F0 ; Compare #$F0D0.w with X register [Reads: X Index] [Flags: ZNC]
	jsr $0040.w		; 20 40 00 ; Jump to subroutine at $0040.w [Writes: Stack Pointer] [Flow: call]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0B.b		; 09 0B ; Logical OR #$0B.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jsr ($FE05.w,X)		; FC 05 FE ; Jump to subroutine indirect indexed ($FE05.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $232037.l		; 22 37 20 23 ; Jump to subroutine long $232037.l [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: ZNC]
	jsr $0023.w		; 20 23 00 ; Jump to subroutine at $0023.w [Writes: Stack Pointer] [Flow: call]
	mvp $00,$01		; 44 01 00 ; Move block positive $00,$01 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: ZNC]
	.db $70, $FF		; 70 FF ; Branch if overflow set to $70, $FF [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $6D97.w,X		; FD 97 6D ; Subtract with carry $6D97.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $031F05.l,X		; 7F 05 1F 03 ; Add long $031F05.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $873B7C.l,X		; 7F 7C 3B 87 ; Add long $873B7C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $00031F.l		; 6F 1F 03 00 ; Add with carry (long) $00031F.l [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $0100.w		; 2C 00 01 ; Test bits $0100.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$25.b]		; 07 25 ; OR accumulator with memory (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $7F44.w,X		; BC 44 7F ; Load Y register $7F44.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	lda $3F5F43.l,X		; BF 43 5F 3F ; Load long $3F5F43.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $23.b		; 05 23 ; Logical OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03031C.l,X		; 1F 1C 03 03 ; Logical OR long $03031C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $5F5F06.l,X		; BF 06 5F 5F ; Load long $5F5F06.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7E.b,S		; 03 7E ; OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol $FC43.w,X		; 3E 43 FC ; Rotate left $FC43.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($FE04.w,X)		; 7C 04 FE ; Jump indirect indexed to ($FE04.w,X) [Reads: X Index] [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $246140.l,X		; FF 40 61 24 ; Subtract with carry (long,X) $246140.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($83.b,X)		; 41 83 ; Exclusive OR accumulator with memory ($83.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $9F.b,S		; 83 9F ; Store accumulator (stack relative) $9F.b,S [Reads: Accumulator, Stack Pointer]
	lda $000061.l,X		; BF 61 00 00 ; Load long $000061.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$1D.b]		; 27 1D ; AND accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$9D.b]		; 07 9D ; OR accumulator with memory (long) [$9D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1DDD.w,X		; 1D DD 1D ; OR accumulator with memory $1DDD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $0F0D.w,X		; 3D 0D 0F ; AND accumulator with memory $0F0D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sep #$01		; E2 01 ; Set processor status bits #$01 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and ($0F.b)		; 32 0F ; AND accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $E00023.l,X		; FF 23 00 E0 ; Subtract with carry (long,X) $E00023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $B7.b		; 04 B7 ; Test and set bits $B7.b [Reads: Accumulator] [Flags: Z]
	tsb $DC.b		; 04 DC ; Test and set bits $DC.b [Reads: Accumulator] [Flags: Z]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $0029.w,X		; FD 29 00 ; Subtract with carry $0029.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $FB7A.w		; 1C 7A FB ; Test and reset bits $FB7A.w [Reads: Accumulator] [Flags: Z]
	lda [$D6.b],Y		; B7 D6 ; Load accumulator (long indexed) [$D6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $3303.w		; 0C 03 33 ; Test and set bits $3303.w [Reads: Accumulator] [Flags: Z]
	tsb $2857.w		; 0C 57 28 ; Test and set bits $2857.w [Reads: Accumulator] [Flags: Z]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($D113.w)		; 6C 13 D1 ; Jump indirect to ($D113.w) [Flow: jump]
	stx $0300.w		; 8E 00 03 ; Store X register to $0300.w [Reads: X Index]
	ora $F8783C.l		; 0F 3C 78 F8 ; OR accumulator with memory (long) $F8783C.l [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $02002B.l,X		; 7F 2B 00 02 ; Add long $02002B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $18.b		; 85 18 ; Store accumulator to $18.b [Reads: Accumulator]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx $D113.w		; EC 13 D1 ; Compare $D113.w with X register [Reads: X Index] [Flags: ZNC]
	asl $0300.w		; 0E 00 03 ; Arithmetic shift left $0300.w [Flags: ZNC]
	ora $38181C.l		; 0F 1C 18 38 ; OR accumulator with memory (long) $38181C.l [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $03002B.l,X		; 7F 2B 00 03 ; Add long $03002B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $87.b		; 06 87 ; Arithmetic shift left $87.b [Reads: Direct Page] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $4F.b,S		; 43 4F ; Exclusive OR accumulator with stack relative $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $01		; 30 01 ; Branch if minus to $30, $01 [Flow: branch]
	cmp [$38.b]		; C7 38 ; Compare accumulator (long) [$38.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta $58.b,S		; 83 58 ; Store accumulator (stack relative) $58.b,S [Reads: Accumulator, Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $6C.b,S		; 83 6C ; Store accumulator (stack relative) $6C.b,S [Reads: Accumulator, Stack Pointer]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1704.w		; 0D 04 17 ; Logical OR $1704.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: ZNC]
	trb $2B18.w		; 1C 18 2B ; Test and reset bits $2B18.w [Reads: Accumulator] [Flags: Z]
	ora $00000F.l,X		; 1F 0F 00 00 ; Logical OR long $00000F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer]
	cpy $F303.w		; CC 03 F3 ; Compare $F303.w with Y register [Reads: Y Index] [Flags: ZNC]
	jmp $98E7.w		; 4C E7 98 ; Jump to $98E7.w [Flow: jump]
	eor $CF.b,S		; 43 CF ; Exclusive OR accumulator with stack relative $CF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $09		; 30 09 ; Branch if minus to $30, $09 [Flow: branch]
	cmp [$B8.b]		; C7 B8 ; Compare accumulator (long) [$B8.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $F078BC.l		; CF BC 78 F0 ; Compare accumulator (long) $F078BC.l [Reads: Accumulator] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	and $0000.w		; 2D 00 00 ; Logical AND $0000.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $30, $27		; 30 27 ; Branch if minus to $30, $27 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1E02.w		; 0D 02 1E ; Logical OR $1E02.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($39.b,X)		; 01 39 ; Logical OR ($39.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $2B.b		; 06 2B ; Arithmetic shift left $2B.b [Reads: Direct Page] [Flags: ZNC]
	trb $33.b		; 14 33 ; Test and reset bits $33.b [Reads: Accumulator] [Flags: Z]
	tsb $045B.w		; 0C 5B 04 ; Test and set bits $045B.w [Reads: Accumulator] [Flags: Z]
	eor $0302.w,X		; 5D 02 03 ; Exclusive OR accumulator with memory $0302.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3C2E17.l		; 0F 17 2E 3C ; OR accumulator with memory (long) $3C2E17.l [Writes: Accumulator] [Flags: ZN]
	bit $7E7C.w,X		; 3C 7C 7E ; Test bits $7E7C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$1800.w		; E0 00 18 ; Compare #$1800.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$38C4.w		; E0 C4 38 ; Compare #$38C4.w with X register [Reads: X Index] [Flags: ZNC]
.INDEX 8
	sep #$1C		; E2 1C
	sbc $1C.b,S		; E3 1C ; Subtract stack-relative $1C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp ($3E.b,X)		; C1 3E ; Compare accumulator ($3E.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $1F1E.w,X		; 3C 1E 1F ; Test bits $1F1E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $003B7F.l,X		; 3F 7F 3B 00 ; AND accumulator with memory (long,X) $003B7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $6E.b		; 04 6E ; Test and set bits $6E.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda $7F21.w,X		; BD 21 7F ; Load $7F21.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($3B.b)		; 12 3B ; OR accumulator with memory (indirect) ($3B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $771B.w		; 0C 1B 77 ; Test and set bits $771B.w [Reads: Accumulator] [Flags: Z]
	dec $276D.w,X		; DE 6D 27 ; Decrement memory $276D.w,X [Reads: X Index] [Flags: ZN]
	sta [$D8.b]		; 87 D8 ; Store accumulator (long) [$D8.b] [Reads: Accumulator, Direct Page]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	trb $F3.b		; 14 F3 ; Test and reset bits $F3.b [Reads: Accumulator] [Flags: Z]
	tsb $04DB.w		; 0C DB 04 ; Test and set bits $04DB.w [Reads: Accumulator] [Flags: Z]
	cmp $E784.w,X		; DD 84 E7 ; Compare accumulator $E784.w,X [Reads: X Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $FCFC.w,X		; BC FC FC ; Load Y register $FCFC.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $F087.w,X		; FE 87 F0 ; Increment memory $F087.w,X [Reads: X Index] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.INDEX 8
	sep #$1C		; E2 1C
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($0200.w,X)		; FC 00 02 ; Jump to subroutine indirect indexed ($0200.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl $7F3F.w,X		; 1E 3F 7F ; Arithmetic shift left $7F3F.w,X [Reads: X Index] [Flags: ZNC]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$46.b],Y		; F7 46 ; Subtract with carry (long indexed) [$46.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $197E6C.l,X		; FF 6C 7E 19 ; Subtract with carry (long,X) $197E6C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $3E0D.w,X		; 3E 0D 3E ; Rotate left $3E0D.w,X [Reads: X Index] [Flags: ZNC]
	ora $0B7C.w,X		; 1D 7C 0B ; OR accumulator with memory $0B7C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7C.b,S		; 43 7C ; Exclusive OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $E0.b,S		; 23 E0 ; AND accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor [$B9.b]		; 47 B9 ; Exclusive OR accumulator with memory (long) [$B9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta ($66.b,S),Y		; 93 66 ; Store accumulator (stack relative indirect indexed) ($66.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	and ($22.b)		; 32 22 ; AND accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $7D.b,X		; 75 7D ; Add $7D.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $0CD3.w,X		; 7D D3 0C ; Add $0CD3.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $40A200.l		; EF 00 A2 40 ; Subtract with carry (long) $40A200.l [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	cpy $DEB1.w		; CC B1 DE ; Compare $DEB1.w with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$FF.b		; A0 FF ; Load #$FF.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: ZNC]
	inc $DEFD.w,X		; FE FD DE ; Increment memory $DEFD.w,X [Reads: X Index] [Flags: ZN]
	inc $FBFF.w,X		; FE FF FB ; Increment memory $FBFF.w,X [Reads: X Index] [Flags: ZN]
	sbc $0003.w,X		; FD 03 00 ; Subtract with carry $0003.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	asl $1E01.w		; 0E 01 1E ; Arithmetic shift left $1E01.w [Flags: ZNC]
	ora ($37.b,X)		; 01 37 ; Logical OR ($37.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $2F03.w,X		; 3C 03 2F ; Test bits $2F03.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora $2F17.w		; 0D 17 2F ; Logical OR $2F17.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $8C533F.l		; 2F 3F 53 8C ; AND accumulator with memory (long) $8C533F.l [Writes: Accumulator] [Flags: ZN]
	sbc $00E200.l		; EF 00 E2 00 ; Subtract with carry (long) $00E200.l [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $81		; 70 81 ; Branch if overflow set to $70, $81 [Flow: branch]
	cpy $DE31.w		; CC 31 DE ; Compare $DE31.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $A0DF.w		; 20 DF A0 ; Jump to subroutine at $A0DF.w [Writes: Stack Pointer] [Flow: call]
	cmp $A88320.l,X		; DF 20 83 A8 ; Compare accumulator (long,X) $A88320.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ldx $FBBF.w,Y		; BE BF FB ; Load X register $FBBF.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sbc $060F.w,X		; FD 0F 06 ; Subtract with carry $060F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $061F08.l,X		; 1F 08 1F 06 ; Logical OR long $061F08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $390F.w,X		; 1D 0F 39 ; OR accumulator with memory $390F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $331E31.l,X		; 1F 31 1E 33 ; Logical OR long $331E31.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $1E3B.w,X		; 1E 3B 1E ; Arithmetic shift left $1E3B.w,X [Reads: X Index] [Flags: ZNC]
	ora #$17.b		; 09 17 ; Logical OR #$17.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $3F231F.l,X		; 1F 1F 23 3F ; Logical OR long $3F231F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $D3		; 10 D3 ; Branch if plus to $10, $D3 [Flow: branch]
	bit $1FE0.w		; 2C E0 1F ; Test bits $1FE0.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	eor [$A7.b]		; 47 A7 ; Exclusive OR accumulator with memory (long) [$A7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy #$27.b		; A0 27 ; Load #$27.b into Y register [Writes: Y Index] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$FC.b]		; 67 FC ; Add with carry (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $BF.b		; 05 BF ; Logical OR $BF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $070CFF.l,X		; DF FF 0C 07 ; Compare accumulator (long,X) $070CFF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	trb $0F44.w		; 1C 44 0F ; Test and reset bits $0F44.w [Reads: Accumulator] [Flags: Z]
	ora $1B03.w,Y		; 19 03 1B ; OR accumulator with memory $1B03.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $430E1B.l		; 0F 1B 0E 43 ; OR accumulator with memory (long) $430E1B.l [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $051F24.l		; 0F 24 1F 05 ; OR accumulator with memory (long) $051F24.l [Writes: Accumulator] [Flags: ZN]
	ora $2CD30F.l		; 0F 0F D3 2C ; OR accumulator with memory (long) $2CD30F.l [Writes: Accumulator] [Flags: ZN]
	cpx #$9F.b		; E0 9F ; Compare #$9F.b with X register [Reads: X Index] [Flags: ZNC]
	sty $01FC.w		; 8C FC 01 ; Store Y register to $01FC.w [Reads: Y Index]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$42.b		; E0 42 ; Compare #$42.b with X register [Reads: X Index] [Flags: ZNC]
	lda $78FFDF.l,X		; BF DF FF 78 ; Load long $78FFDF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr $48EE.w		; 20 EE 48 ; Jump to subroutine at $48EE.w [Writes: Stack Pointer] [Flow: call]
	adc $7A02.w		; 6D 02 7A ; Add $7A02.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	ora ($77.b,X)		; 01 77 ; Logical OR ($77.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rol $7F.b		; 26 7F ; Rotate left $7F.b [Reads: Direct Page] [Flags: ZNC]
	bit $3F.b,X		; 34 3F ; Test bits $3F.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	and [$10.b],Y		; 37 10 ; AND accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldx $7F.b,Y		; B6 7F ; Load X register $7F.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	adc $274B59.l,X		; 7F 59 4B 27 ; Add long $274B59.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $A641BE.l		; 2F BE 41 A6 ; AND accumulator with memory (long) $A641BE.l [Writes: Accumulator] [Flags: ZN]
	eor ($E3.b,X)		; 41 E3 ; Exclusive OR accumulator with memory ($E3.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$18.b		; E0 18 ; Compare #$18.b with X register [Reads: X Index] [Flags: ZNC]
	lda ($40.b)		; B2 40 ; Load accumulator (indirect) ($40.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $80FF40.l,X		; BF 40 FF 80 ; Load long $80FF40.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FBE788.l,X		; FF 88 E7 FB ; Subtract with carry (long,X) $FBE788.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $A7.b		; E5 A7 ; Subtract $A7.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $F7F9EF.l,X		; FF EF F9 F7 ; Subtract with carry (long,X) $F7F9EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $F3F0.w		; 0D F0 F3 ; Logical OR $F3F0.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E6.b		; 05 E6 ; Logical OR $E6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $E21D.w,Y		; 19 1D E2 ; OR accumulator with memory $E21D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $2346.w,Y		; B9 46 23 ; Load $2346.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F9FD07.l,X		; FF 07 FD F9 ; Subtract with carry (long,X) $F9FD07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C7.b,S		; E3 C7 ; Subtract stack-relative $C7.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	eor $B0.b,S		; 43 B0 ; Exclusive OR accumulator with stack relative $B0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora ($98.b,S),Y		; 13 98 ; OR accumulator (stack relative indirect indexed) ($98.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cld		; D8 ; Clear decimal flag [Flags: D]
	jsr $A0DC.w		; 20 DC A0 ; Jump to subroutine at $A0DC.w [Writes: Stack Pointer] [Flow: call]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx $3CDC.w		; EC DC 3C ; Compare $3CDC.w with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0F470F.l,X		; 1F 0F 47 0F ; Logical OR long $0F470F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	ora $070701.l		; 0F 01 07 07 ; OR accumulator with memory (long) $070701.l [Writes: Accumulator] [Flags: ZN]
	sta $58.b,S		; 83 58 ; Store accumulator (stack relative) $58.b,S [Reads: Accumulator, Stack Pointer]
	cop $13.b		; 02 13 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $44B710.l		; EF 10 B7 44 ; Subtract with carry (long) $44B710.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $ED41.w,X		; FD 41 ED ; Subtract with carry $ED41.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	inc $FE9C.w,X		; FE 9C FE ; Increment memory $FE9C.w,X [Reads: X Index] [Flags: ZN]
	sty $E7.b		; 84 E7 ; Store Y register to $E7.b [Reads: Y Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $FEFB.w		; ED FB FE ; Subtract $FEFB.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	sbc [$E3.b],Y		; F7 E3 ; Subtract with carry (long indexed) [$E3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta $70.b		; 85 70 ; Store accumulator to $70.b [Reads: Accumulator]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ora $DE.b		; 05 DE ; Logical OR $DE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $1C6F.w,Y		; 39 6F 1C ; AND accumulator with memory $1C6F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DF.b,S		; E3 DF ; Subtract stack-relative $DF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cmp $2FEF.w,X		; DD EF 2F ; Compare accumulator $2FEF.w,X [Reads: X Index] [Flags: ZNC]
	sta $88.b,S		; 83 88 ; Store accumulator (stack relative) $88.b,S [Reads: Accumulator, Stack Pointer]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $40		; B0 40 ; Branch if carry set to $B0, $40 [Flow: branch]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $8708.w		; F4 08 87 ; Push absolute address $8708.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	and [$78.b]		; 27 78 ; AND accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$79.b]		; 27 79 ; AND accumulator with memory (long) [$79.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$0F.b],Y		; 37 0F ; AND accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($2A.b,X)		; 01 2A ; Logical OR ($2A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	and [$37.b],Y		; 37 37 ; AND accumulator with memory (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $7F2A2F.l		; 2F 2F 2A 7F ; AND accumulator with memory (long) $7F2A2F.l [Writes: Accumulator] [Flags: ZN]
	sbc #$FF.b		; E9 FF ; Subtract #$FF.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	lda ($DF.b)		; B2 DF ; Load accumulator (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc $9A.b,X		; 75 9A ; Add $9A.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $DA.b,X		; F5 DA ; Subtract $DA.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FA.b,X		; F5 FA ; Subtract $FA.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $F6.b,X		; 75 F6 ; Add $F6.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FFFD.w,Y		; F9 FD FF ; Subtract with carry $FFFD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FB.b,S		; 23 FB ; AND accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F0019.l,X		; 1F 19 00 3F ; Logical OR long $3F0019.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $2F.b,X		; 16 2F ; Arithmetic shift left $2F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora #$6D.b		; 09 6D ; Logical OR #$6D.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora #$5F.b		; 09 5F ; Logical OR #$5F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$36.b		; 29 36 ; Logical AND #$36.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ror $78.b,X		; 76 78 ; Rotate right $78.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and $FF0F1E.l		; 2F 1E 0F FF ; AND accumulator with memory (long) $FF0F1E.l [Writes: Accumulator] [Flags: ZN]
	bit #$FF.b		; 89 FF ; Test bits #$FF.b with accumulator [Reads: Accumulator] [Flags: Z]
	rol $3F.b,X		; 36 3F ; Rotate left $3F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	eor $DA.b,S		; 43 DA ; Exclusive OR accumulator with stack relative $DA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $43.b,X		; 75 43 ; Add $43.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	eor $03.b,X		; 55 03 ; Exclusive OR accumulator with memory $03.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $F9.b,X		; 76 F9 ; Rotate right $F9.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $237F.w,X		; FD 7F 23 ; Subtract with carry $237F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $3B.b		; 05 3B ; Logical OR $3B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1F3B.w,X		; 1E 3B 1F ; Arithmetic shift left $1F3B.w,X [Reads: X Index] [Flags: ZNC]
	and $441E.w,X		; 3D 1E 44 ; AND accumulator with memory $441E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0C040E.l,X		; 1F 0E 04 0C ; Logical OR long $0C040E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000F08.l,X		; 1F 08 0F 00 ; Logical OR long $000F08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $1F223F.l		; 22 3F 22 1F ; Jump to subroutine long $1F223F.l [Writes: Stack Pointer] [Flow: call]
	trb $1E.b		; 14 1E ; Test and reset bits $1E.b [Reads: Accumulator] [Flags: Z]
	asl $827D.w		; 0E 7D 82 ; Arithmetic shift left $827D.w [Flags: ZNC]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($0D.b)		; F2 0D ; Subtract with carry (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	nop		; EA ; No operation
	ora $EF.b,X		; 15 EF ; OR accumulator with memory $EF.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	trb $6F.b		; 14 6F ; Test and reset bits $6F.b [Reads: Accumulator] [Flags: Z]
	sta ($4C.b,S),Y		; 93 4C ; Store accumulator (stack relative indirect indexed) ($4C.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	lda [$E6.b],Y		; B7 E6 ; Load accumulator (long indexed) [$E6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ldx $226F.w		; AE 6F 22 ; Load $226F.w into X register [Writes: X Index] [Flags: ZN]
	eor $FFDF05.l,X		; 5F 05 DF FF ; Exclusive OR accumulator with memory (long,X) $FFDF05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $050F06.l		; 0F 06 0F 05 ; OR accumulator with memory (long) $050F06.l [Writes: Accumulator] [Flags: ZN]
	eor $0F.b,S		; 43 0F ; Exclusive OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $92.b		; 02 92 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $FFDF04.l,X		; 5F 04 DF FF ; Exclusive OR accumulator with memory (long,X) $FFDF04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$10.b],Y		; 37 10 ; AND accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $0F0144.l,X		; 1F 44 01 0F ; Logical OR long $0F0144.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda ($01.b)		; B2 01 ; Load accumulator (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02B483.l,X		; 1F 83 B4 02 ; Logical OR long $02B483.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$2C.b		; E0 2C ; Compare #$2C.b with X register [Reads: X Index] [Flags: ZNC]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	cmp $84F791.l,X		; DF 91 F7 84 ; Compare accumulator (long,X) $84F791.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	lda [$20.b],Y		; B7 20 ; Load accumulator (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FB70.w,Y		; F9 70 FB ; Subtract with carry $FB70.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FF.b,S),Y		; 13 FF ; OR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp #$DF.b		; C9 DF ; Compare #$DF.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	bit $5F.b		; 24 5F ; Test bits $5F.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ldy #$EF.b		; A0 EF ; Load #$EF.b into Y register [Writes: Y Index] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp $F6EC8F.l,X		; DF 8F EC F6 ; Compare accumulator (long,X) $F6EC8F.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	eor $7F84FB.l,X		; 5F FB 84 7F ; Exclusive OR accumulator with memory (long,X) $7F84FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
.INDEX 8
	sep #$1D		; E2 1D
	inc $7C83.w,X		; FE 83 7C ; Increment memory $7C83.w,X [Reads: X Index] [Flags: ZN]
	sta $7F8D7B.l		; 8F 7B 8D 7F ; Store accumulator (long) $7F8D7B.l [Reads: Accumulator]
	ldx $7E7D.w,Y		; BE 7D 7E ; Load X register $7E7D.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $07BF23.l,X		; 7F 23 BF 07 ; Add long $07BF23.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $DC8874.l,X		; 7F 74 88 DC ; Add long $DC8874.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $10AC.w		; 20 AC 10 ; Jump to subroutine at $10AC.w [Writes: Stack Pointer] [Flow: call]
	ldy $0044.w,X		; BC 44 00 ; Load Y register $0044.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	tsb $80D0.w		; 0C D0 80 ; Test and set bits $80D0.w [Reads: Accumulator] [Flags: Z]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	jmp.w [$B4F4]		; DC F4 B4 ; Jump long indirect [$B4F4] [Flow: jump]
	ldy $A8.b		; A4 A8 ; Load $A8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $62, $00, $04		; 62 00 04 ; Push effective relative address $62, $00, $04 [Writes: Stack Pointer]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta ($FF.b)		; 92 FF ; Store accumulator (indirect) ($FF.b) [Reads: Accumulator, Direct Page]
	lda $43.b		; A5 43 ; Load $43.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $EF0952.l		; AF 52 09 EF ; Load long $EF0952.l into accumulator [Writes: Accumulator] [Flags: ZN]
	eor ($CB.b)		; 52 CB ; Exclusive OR accumulator with memory (indirect) ($CB.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $D3.b,X		; B5 D3 ; Load $D3.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $AD57.w		; 2D 57 AD ; Logical AND $AD57.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $22FA.w		; ED FA 22 ; Subtract $22FA.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	sbc $DFCF01.l		; EF 01 CF DF ; Subtract with carry (long) $DFCF01.l [Writes: Accumulator] [Flags: ZVNC]
	eor $5F.b,S		; 43 5F ; Exclusive OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc ($0E.b,X)		; E1 0E ; Subtract with carry ($0E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $C33FC1.l,X		; 1F C1 3F C3 ; Logical OR long $C33FC1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $DD3ECF.l,X		; 3F CF 3E DD ; AND accumulator with memory (long,X) $DD3ECF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	dec $BE37.w,X		; DE 37 BE ; Decrement memory $BE37.w,X [Reads: X Index] [Flags: ZN]
	sbc $24EFAF.l		; EF AF EF 24 ; Subtract with carry (long) $24EFAF.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $F4BF07.l,X		; DF 07 BF F4 ; Compare accumulator (long,X) $F4BF07.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jmp.w [$ACA0]		; DC A0 AC ; Jump long indirect [$ACA0] [Flow: jump]
	.db $10, $BC		; 10 BC ; Branch if plus to $10, $BC [Flow: branch]
	mvp $B8,$00		; 44 00 B8 ; Move block positive $B8,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,S),Y		; 13 23 ; OR accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $AA.b,X		; 75 AA ; Add $AA.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda $5A.b		; A5 5A ; Load $5A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	stz $CC.b,X		; 74 CC ; Store zero to $CC.b,X [Reads: X Index]
	lda ($FF.b,S),Y		; B3 FF ; Load accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	pea $7870.w		; F4 70 78 ; Push absolute address $7870.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $8C.b		; A6 8C ; Load $8C.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	eor $488C37.l		; 4F 37 8C 48 ; Exclusive OR accumulator with memory (long) $488C37.l [Writes: Accumulator] [Flags: ZN]
	.db $30, $0F		; 30 0F ; Branch if minus to $30, $0F [Flow: branch]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $03,$01		; 44 01 03 ; Move block positive $03,$01 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$84.b]		; 07 84 ; OR accumulator with memory (long) [$84.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $04		; 30 04 ; Branch if minus to $30, $04 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sbc $DA.b		; E5 DA ; Subtract $DA.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	wai		; CB ; Wait for interrupt
	ldy $CC.b,X		; B4 CC ; Load Y register $CC.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	lda ($FF.b,S),Y		; B3 FF ; Load accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sta $A2.b		; 85 A2 ; Store accumulator to $A2.b [Reads: Accumulator]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	inc $E6.b,X		; F6 E6 ; Increment memory $E6.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cpy $B7CF.w		; CC CF B7 ; Compare $B7CF.w with Y register [Reads: Y Index] [Flags: ZNC]
	sty $3048.w		; 8C 48 30 ; Store Y register to $3048.w [Reads: Y Index]
	sta $20.b,S		; 83 20 ; Store accumulator (stack relative) $20.b,S [Reads: Accumulator, Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $24.b		; 84 24 ; Store Y register to $24.b [Reads: Y Index]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	jmp ($7E97.w,X)		; 7C 97 7E ; Jump indirect indexed to ($7E97.w,X) [Reads: X Index] [Flow: jump]
	sta $67A65F.l		; 8F 5F A6 67 ; Store accumulator (long) $67A65F.l [Reads: Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $FFA6.w,Y		; 79 A6 FF ; Add $FFA6.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	jsl $FF0600.l		; 22 00 06 FF ; Jump to subroutine long $FF0600.l [Writes: Stack Pointer] [Flow: call]
	sbc $D9E7DF.l,X		; FF DF E7 D9 ; Subtract with carry (long,X) $D9E7DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $0044F0.l		; 8F F0 44 00 ; Store accumulator (long) $0044F0.l [Reads: Accumulator]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($F1.b,S),Y		; 93 F1 ; Store accumulator (stack relative indirect indexed) ($F1.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $38.b		; 05 38 ; Logical OR $38.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $44BF64.l,X		; 9F 64 BF 44 ; Store accumulator (long,X) $44BF64.l,X [Reads: Accumulator, X Index]
	sbc $3B7E12.l,X		; FF 12 7E 3B ; Subtract with carry (long,X) $3B7E12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $0201.w,X		; 3E 01 02 ; Rotate left $0201.w,X [Reads: X Index] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $26E000.l		; 22 00 E0 26 ; Jump to subroutine long $26E000.l [Writes: Stack Pointer] [Flow: call]
	sta $46EFBF.l,X		; 9F BF EF 46 ; Store accumulator (long,X) $46EFBF.l,X [Reads: Accumulator, X Index]
	rol $0102.w,X		; 3E 02 01 ; Rotate left $0102.w,X [Reads: X Index] [Flags: ZNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$7F.b]		; E7 7F ; Subtract with carry (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $D16E.w		; EE 6E D1 ; Increment $D16E.w [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $FE38C7.l,X		; 9F C7 38 FE ; Store accumulator (long,X) $FE38C7.l,X [Reads: Accumulator, X Index]
	mvp $F0,$FC		; 44 FC F0 ; Move block positive $F0,$FC [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	adc $606E7F.l,X		; 7F 7F 6E 60 ; Add long $606E7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp [$BA.b]		; C7 BA ; Compare accumulator (long) [$BA.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tsb $D0F0.w		; 0C F0 D0 ; Test and set bits $D0F0.w [Reads: Accumulator] [Flags: Z]
	ldy #$A0.b		; A0 A0 ; Load #$A0.b into Y register [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $A0		; D0 A0 ; Branch if not equal to $D0, $A0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $3B		; 80 3B ; Branch always to $80, $3B [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($6E.b,S),Y		; 93 6E ; Store accumulator (stack relative indirect indexed) ($6E.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	lda ($4F.b),Y		; B1 4F ; Load accumulator ($4F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($7F13.w,X)		; FC 13 7F ; Jump to subroutine indirect indexed ($7F13.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	rol $0022.w,X		; 3E 22 00 ; Rotate left $0022.w,X [Reads: X Index] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $9F0F00.l		; 22 00 0F 9F ; Jump to subroutine long $9F0F00.l [Writes: Stack Pointer] [Flow: call]
	lda $3E47EF.l,X		; BF EF 47 3E ; Load long $3E47EF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $4E4EBF.l		; 4F BF 4E 4E ; Exclusive OR accumulator with memory (long) $4E4EBF.l [Writes: Accumulator] [Flags: ZN]
	lda ($C0.b),Y		; B1 C0 ; Load accumulator ($C0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $057887.l,X		; 3F 87 78 05 ; AND accumulator with memory (long,X) $057887.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $BF.b,S		; 03 BF ; OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda $8AC0CE.l,X		; BF CE C0 8A ; Load long $8AC0CE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sty $05.b		; 84 05 ; Store Y register to $05.b [Reads: Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $23.b		; 05 23 ; Logical OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0500.w,Y		; 39 00 05 ; AND accumulator with memory $0500.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	adc $09F600.l,X		; 7F 00 F6 09 ; Add long $09F600.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $303018.l		; 0F 18 30 30 ; OR accumulator with memory (long) $303018.l [Writes: Accumulator] [Flags: ZN]
	.db $70, $99		; 70 99 ; Branch if overflow set to $70, $99 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $10C0.w		; 20 C0 10 ; Jump to subroutine at $10C0.w [Writes: Stack Pointer] [Flow: call]
	cpx #$43.b		; E0 43 ; Compare #$43.b with X register [Reads: X Index] [Flags: ZNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $0B		; 70 0B ; Branch if overflow set to $70, $0B [Flow: branch]
	trb $1CF8.w		; 1C F8 1C ; Test and reset bits $1CF8.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($E4FC.w,X)		; FC FC E4 ; Jump to subroutine indirect indexed ($E4FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$18.b]		; 87 18 ; Store accumulator (long) [$18.b] [Reads: Accumulator, Direct Page]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $248C10.l		; 2F 10 8C 24 ; AND accumulator with memory (long) $248C10.l [Writes: Accumulator] [Flags: ZN]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $131F0C.l		; 0F 0C 1F 13 ; OR accumulator with memory (long) $131F0C.l [Writes: Accumulator] [Flags: ZN]
	bit $7827.w,X		; 3C 27 78 ; Test bits $7827.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and $5F4370.l		; 2F 70 43 5F ; AND accumulator with memory (long) $5F4370.l [Writes: Accumulator] [Flags: ZN]
	cpx #$13.b		; E0 13 ; Compare #$13.b with X register [Reads: X Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $30381C.l		; 0F 1C 38 30 ; OR accumulator with memory (long) $30381C.l [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	bit $1EE4.w,X		; 3C E4 1E ; Test bits $1EE4.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	pea $430E.w		; F4 0E 43 ; Push absolute address $430E.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	trb $060C.w		; 1C 0C 06 ; Test and reset bits $060C.w [Reads: Accumulator] [Flags: Z]
	asl $25.b		; 06 25 ; Arithmetic shift left $25.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $23.b		; 05 23 ; Logical OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$27.b]		; 67 27 ; Add with carry (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	adc $19E690.l		; 6F 90 E6 19 ; Add with carry (long) $19E690.l [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$27.b		; C0 27 ; Compare #$27.b with Y register [Reads: Y Index] [Flags: ZNC]
	adc $F9F0F8.l,X		; 7F F8 F0 F9 ; Add long $F9F0F8.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1303.w		; 0C 03 13 ; Test and set bits $1303.w [Reads: Accumulator] [Flags: Z]
	tsb $2743.w		; 0C 43 27 ; Test and set bits $2743.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $8400.w,X		; 3C 00 84 ; Test bits $8400.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: ZN]
	ora ($38.b,X)		; 01 38 ; Logical OR ($38.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jmp ($0024.w,X)		; 7C 24 00 ; Jump indirect indexed to ($0024.w,X) [Reads: X Index] [Flow: jump]
	sty $91.b		; 84 91 ; Store Y register to $91.b [Reads: Y Index]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $1743.w		; 1C 43 17 ; Test and reset bits $1743.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $030400.l		; 22 00 04 03 ; Jump to subroutine long $030400.l [Writes: Stack Pointer] [Flow: call]
	ora $18180C.l		; 0F 0C 18 18 ; OR accumulator with memory (long) $18180C.l [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sty $A9.b		; 84 A9 ; Store Y register to $A9.b [Reads: Y Index]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $38		; D0 38 ; Branch if not equal to $D0, $38 [Flow: branch]
	eor $E8.b,S		; 43 E8 ; Exclusive OR accumulator with stack relative $E8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $0022.w		; 1C 22 00 ; Test and reset bits $0022.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $427E.w,X		; 3C 7E 42 ; Test bits $427E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $E75A43.l,X		; FF 43 5A E7 ; Subtract with carry (long,X) $E75A43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $42.b,S		; 03 42 ; OR accumulator with stack relative $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $437E3C.l,X		; FF 3C 7E 43 ; Subtract with carry (long,X) $437E3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $667E.w,X		; 1E 7E 66 ; Arithmetic shift left $667E.w,X [Reads: X Index] [Flags: ZNC]
	ror $7E.b		; 66 7E ; Rotate right $7E.b [Reads: Direct Page] [Flags: ZNC]
	bit $FE00.w,X		; 3C 00 FE ; Test bits $FE00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	adc $FBBFFD.l,X		; 7F FD BF FB ; Add long $FBBFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $007FBF.l,X		; DF BF 7F 00 ; Compare accumulator (long,X) $007FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	mvp $01,$00		; 44 00 01 ; Move block positive $01,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($45.b,X)		; 01 45 ; Logical OR ($45.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $2AE003.l		; 22 03 E0 2A ; Jump to subroutine long $2AE003.l [Writes: Stack Pointer] [Flow: call]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora [$69.b]		; 07 69 ; OR accumulator with memory (long) [$69.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$F7.b]		; 47 F7 ; Exclusive OR accumulator with memory (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $7078.w		; 20 78 70 ; Jump to subroutine at $7078.w [Writes: Stack Pointer] [Flow: call]
	jsr ($BF30.w,X)		; FC 30 BF ; Jump to subroutine indirect indexed ($BF30.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $7B		; 30 7B ; Branch if minus to $30, $7B [Flow: branch]
	stz $FB.b,X		; 74 FB ; Store zero to $FB.b,X [Reads: X Index]
	sta [$FF.b],Y		; 97 FF ; Store accumulator (long indexed) [$FF.b],Y [Reads: Accumulator, Direct Page, Y Index]
	lda $CF8FDF.l,X		; BF DF 8F CF ; Load long $CF8FDF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $346B8B.l		; CF 8B 6B 34 ; Compare accumulator (long) $346B8B.l [Reads: Accumulator] [Flags: ZNC]
	cpx #$F4.b		; E0 F4 ; Compare #$F4.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$CD.b		; C0 CD ; Compare #$CD.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $76.b		; 05 76 ; Logical OR $76.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $6C97.w		; 0D 97 6C ; Logical OR $6C97.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc [$1C.b]		; E7 1C ; Subtract with carry (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $1D.b		; E6 1D ; Increment $1D.b [Reads: Direct Page] [Flags: ZN]
	jsr ($FDFC.w,X)		; FC FC FD ; Jump to subroutine indirect indexed ($FDFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $9E01FF.l		; 22 FF 01 9E ; Jump to subroutine long $9E01FF.l [Writes: Stack Pointer] [Flow: call]
	sta $010023.l,X		; 9F 23 00 01 ; Store accumulator (long,X) $010023.l,X [Reads: Accumulator, X Index]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	eor $40.b,S		; 43 40 ; Exclusive OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $44		; 80 44 ; Branch always to $80, $44 [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $800000.l		; 22 00 00 80 ; Jump to subroutine long $800000.l [Writes: Stack Pointer] [Flow: call]
	and $C0.b,S		; 23 C0 ; AND accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$2A.b		; E0 2A ; Compare #$2A.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora $030F06.l		; 0F 06 0F 03 ; OR accumulator with memory (long) $030F06.l [Writes: Accumulator] [Flags: ZN]
	ora [$07.b],Y		; 17 07 ; OR accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $020B09.l,X		; 1F 09 0B 02 ; Logical OR long $020B09.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000F07.l		; 0F 07 0F 00 ; OR accumulator with memory (long) $000F07.l [Writes: Accumulator] [Flags: ZN]
	ora [$04.b],Y		; 17 04 ; OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$0C.b		; 09 0C ; Logical OR #$0C.b with accumulator [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $0D.b,X		; 16 0D ; Arithmetic shift left $0D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $47981B.l		; 0F 1B 98 47 ; OR accumulator with memory (long) $47981B.l [Writes: Accumulator] [Flags: ZN]
	bit #$47.b		; 89 47 ; Test bits #$47.b with accumulator [Reads: Accumulator] [Flags: Z]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Accumulator, Direct Page]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsr ($FF00.w,X)		; FC 00 FF ; Jump to subroutine indirect indexed ($FF00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $BFA4FB.l		; 8F FB A4 BF ; Store accumulator (long) $BFA4FB.l [Reads: Accumulator]
	lda $02FF22.l,X		; BF 22 FF 02 ; Load long $02FF22.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $43DCFF.l		; CF FF DC 43 ; Compare accumulator (long) $43DCFF.l [Reads: Accumulator] [Flags: ZNC]
	eor $2F13E0.l,X		; 5F E0 13 2F ; Exclusive OR accumulator with memory (long,X) $2F13E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $27		; 70 27 ; Branch if overflow set to $70, $27 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($3C.b,S),Y		; 13 3C ; OR accumulator (stack relative indirect indexed) ($3C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $031F.w		; 0C 1F 03 ; Test and set bits $031F.w [Reads: Accumulator] [Flags: Z]
	ora $600300.l		; 0F 00 03 60 ; OR accumulator with memory (long) $600300.l [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	trb $030F.w		; 1C 0F 03 ; Test and reset bits $030F.w [Reads: Accumulator] [Flags: Z]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ora [$E0.b]		; 07 E0 ; OR accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $F4.b,S		; 43 F4 ; Exclusive OR accumulator with stack relative $F4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $1EE4.w		; 0E E4 1E ; Arithmetic shift left $1EE4.w [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	bit $F830.w,X		; 3C 30 F8 ; Test bits $F830.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	tsb $381C.w		; 0C 1C 38 ; Test and set bits $381C.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $08.b,X		; 36 08 ; Rotate left $08.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	bit $08.b,X		; 34 08 ; Test bits $08.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	and $2E10.w		; 2D 10 2E ; Logical AND $2E10.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($0D.b),Y		; 11 0D ; OR accumulator with memory ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $2C2E.w		; 2D 2E 2C ; Logical AND $2C2E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $E43F.w,X		; 3D 3F E4 ; AND accumulator with memory $E43F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cmp ($0E.b),Y		; D1 0E ; Compare accumulator ($0E.b),Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	tsb $67.b		; 04 67 ; Test and set bits $67.b [Reads: Accumulator] [Flags: Z]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cld		; D8 ; Clear decimal flag [Flags: D]
	and ($FE.b,X)		; 21 FE ; Logical AND ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $80, $DF		; 80 DF ; Branch always to $80, $DF [Flow: branch]
	jsr $FFFB.w		; 20 FB FF ; Jump to subroutine at $FFFB.w [Writes: Stack Pointer] [Flow: call]
	adc $BEFD7E.l,X		; 7F 7E FD BE ; Add long $BEFD7E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $0025FF.l,X		; DF FF 25 00 ; Compare accumulator (long,X) $0025FF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: ZNC]
	mvp $13,$0E		; 44 0E 13 ; Move block positive $13,$0E [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	jsl $070100.l		; 22 00 01 07 ; Jump to subroutine long $070100.l [Writes: Stack Pointer] [Flow: call]
	ora $0F1F22.l		; 0F 22 1F 0F ; OR accumulator with memory (long) $0F1F22.l [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$47.b]		; 07 47 ; OR accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	stz $7D.b		; 64 7D ; Store zero to $7D.b
	.db $82, $F2, $0D		; 82 F2 0D ; Branch always long to $82, $F2, $0D [Flow: branch]
	jsl $FF047F.l		; 22 7F 04 FF ; Jump to subroutine long $FF047F.l [Writes: Stack Pointer] [Flow: call]
	sbc $CFE6FC.l		; EF FC E6 CF ; Subtract with carry (long) $CFE6FC.l [Writes: Accumulator] [Flags: ZVNC]
	eor $17.b,S		; 43 17 ; Exclusive OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	trb $1A85.w		; 1C 85 1A ; Test and reset bits $1A85.w [Reads: Accumulator] [Flags: Z]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $030F.w		; 0C 0F 03 ; Test and set bits $030F.w [Reads: Accumulator] [Flags: Z]
	jsl $E84300.l		; 22 00 43 E8 ; Jump to subroutine long $E84300.l [Writes: Stack Pointer] [Flow: call]
	trb $D001.w		; 1C 01 D0 ; Test and reset bits $D001.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	sta $32.b		; 85 32 ; Store accumulator to $32.b [Reads: Accumulator]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1F0044.l		; 0F 44 00 1F ; OR accumulator with memory (long) $1F0044.l [Writes: Accumulator] [Flags: ZN]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $030600.l		; 22 00 06 03 ; Jump to subroutine long $030600.l [Writes: Stack Pointer] [Flow: call]
	ora $3F1F1F.l		; 0F 1F 1F 3F ; OR accumulator with memory (long) $3F1F1F.l [Writes: Accumulator] [Flags: ZN]
	and $002E01.l,X		; 3F 01 2E 00 ; AND accumulator with memory (long,X) $002E01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora ($F8.b,X)		; 01 F8 ; Logical OR ($F8.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor [$43.b]		; 47 43 ; Exclusive OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $4F		; F0 4F ; Branch if equal to $F0, $4F [Flow: branch]
	ora $77.b		; 05 77 ; Logical OR $77.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $BF5CAF.l		; 2F AF 5C BF ; AND accumulator with memory (long) $BF5CAF.l [Writes: Accumulator] [Flags: ZN]
	adc $22.b,S		; 63 22 ; Add with carry (stack relative) $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora [$F3.b],Y		; 17 F3 ; OR accumulator with memory (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$77.b],Y		; F7 77 ; Subtract with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $99EEFF.l		; EF FF EE 99 ; Subtract with carry (long) $99EEFF.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $CA7DB0.l		; CF B0 7D CA ; Compare accumulator (long) $CA7DB0.l [Reads: Accumulator] [Flags: ZNC]
	bit $FB.b,X		; 34 FB ; Test bits $FB.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cpx $FB.b		; E4 FB ; Compare $FB.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	inc $B9.b		; E6 B9 ; Increment $B9.b [Reads: Direct Page] [Flags: ZN]
	sbc $FE877C.l		; EF 7C 87 FE ; Subtract with carry (long) $FE877C.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $24FEFE.l,X		; DF FE FE 24 ; Compare accumulator (long,X) $24FEFE.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $00C001.l,X		; FF 01 C0 00 ; Subtract with carry (long,X) $00C001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $60.b		; 45 60 ; Exclusive OR $60.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	ldy #$40.b		; A0 40 ; Load #$40.b into Y register [Writes: Y Index] [Flags: ZN]
	tsb $60.b		; 04 60 ; Test and set bits $60.b [Reads: Accumulator] [Flags: Z]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E0.b		; 24 E0 ; Test bits $E0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldy #$20.b		; A0 20 ; Load #$20.b into Y register [Writes: Y Index] [Flags: ZN]
	ora $072702.l,X		; 1F 02 27 07 ; Logical OR long $072702.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $841B13.l,X		; 3F 13 1B 84 ; AND accumulator with memory (long,X) $841B13.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $01.b,S		; E3 01 ; Subtract stack-relative $01.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	asl $0009.w,X		; 1E 09 00 ; Arithmetic shift left $0009.w,X [Reads: X Index] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $2C38.w,X		; 1D 38 2C ; OR accumulator with memory $2C38.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $1618.w		; 1C 18 16 ; Test and reset bits $1618.w [Reads: Accumulator] [Flags: Z]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	bit $FD.b,X		; 34 FD ; Test bits $FD.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $42, $BE		; 42 BE ; Reserved instruction
	adc ($8F.b),Y		; 71 8F ; Add with carry ($8F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $7F83.w,X		; 7E 83 7F ; Rotate right $7F83.w,X [Reads: X Index] [Flags: ZNC]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Accumulator, X Index, Direct Page]
	.db $82, $7F, $97		; 82 7F 97 ; Branch always long to $82, $7F, $97 [Flow: branch]
	ror $FECC.w,X		; 7E CC FE ; Rotate right $FECC.w,X [Reads: X Index] [Flags: ZNC]
	sbc $12BF24.l,X		; FF 24 BF 12 ; Subtract with carry (long,X) $12BF24.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $CF19.w		; EE 19 CF ; Increment $CF19.w [Flags: ZN]
	.db $30, $3D		; 30 3D ; Branch if minus to $30, $3D [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	pea $E41B.w		; F4 1B E4 ; Push absolute address $E41B.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: ZNC]
	sbc $3CDF7C.l		; EF 7C DF 3C ; Subtract with carry (long) $3CDF7C.l [Writes: Accumulator] [Flags: ZVNC]
	ora $24FE3E.l,X		; 1F 3E FE 24 ; Logical OR long $24FE3E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00C001.l,X		; FF 01 C0 00 ; Subtract with carry (long,X) $00C001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $60.b		; 45 60 ; Exclusive OR $60.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	ldy #$40.b		; A0 40 ; Load #$40.b into Y register [Writes: Y Index] [Flags: ZN]
	sty $54.b		; 84 54 ; Store Y register to $54.b [Reads: Y Index]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	and ($A0.b),Y		; 31 A0 ; AND accumulator with memory ($A0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $031D.w		; 20 1D 03 ; Jump to subroutine at $031D.w [Writes: Stack Pointer] [Flow: call]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $020F01.l		; 0F 01 0F 02 ; OR accumulator with memory (long) $020F01.l [Writes: Accumulator] [Flags: ZN]
	ora $040F03.l		; 0F 03 0F 04 ; OR accumulator with memory (long) $040F03.l [Writes: Accumulator] [Flags: ZN]
	ora $071F06.l		; 0F 06 1F 07 ; OR accumulator with memory (long) $071F06.l [Writes: Accumulator] [Flags: ZN]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F0C.w		; 0D 0C 0F ; Logical OR $0F0C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $9F00FF.l		; 0F FF 00 9F ; OR accumulator with memory (long) $9F00FF.l [Writes: Accumulator] [Flags: ZN]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $149B8B.l,X		; FF 8B 9B 14 ; Subtract with carry (long,X) $149B8B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	and $FA.b		; 25 FA ; Logical AND $FA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $FD.b,X		; 95 FD ; Store accumulator to $FD.b,X [Reads: Accumulator, X Index]
	.db $42, $F9		; 42 F9 ; Reserved instruction
	sbc $7CBF.w,Y		; F9 BF 7C ; Subtract with carry $7CBF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $1343.w,X		; FE 43 13 ; Increment memory $1343.w,X [Reads: X Index] [Flags: ZN]
	asl $1B03.w		; 0E 03 1B ; Arithmetic shift left $1B03.w [Flags: ZNC]
	asl $0C1F.w		; 0E 1F 0C ; Arithmetic shift left $0C1F.w [Flags: ZNC]
	eor $0F.b,S		; 43 0F ; Exclusive OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $1E141F.l		; 22 1F 14 1E ; Jump to subroutine long $1E141F.l [Writes: Stack Pointer] [Flow: call]
	asl $060E.w		; 0E 0E 06 ; Arithmetic shift left $060E.w [Flags: ZNC]
	ora $E3.b		; 05 E3 ; Logical OR $E3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $14EB.w		; 1C EB 14 ; Test and reset bits $14EB.w [Reads: Accumulator] [Flags: Z]
	sbc $17EF13.l		; EF 13 EF 17 ; Subtract with carry (long) $17EF13.l [Writes: Accumulator] [Flags: ZVNC]
	ror $6C97.w		; 6E 97 6C ; Rotate right $6C97.w [Flags: ZNC]
	sta [$7C.b],Y		; 97 7C ; Store accumulator (long indexed) [$7C.b],Y [Reads: Accumulator, Direct Page, Y Index]
	lda [$7C.b]		; A7 7C ; Load accumulator (long) [$7C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $005F23.l,X		; BF 23 5F 00 ; Load long $005F23.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $2DFF22.l,X		; DF 22 FF 2D ; Compare accumulator (long,X) $2DFF22.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $437F00.l,X		; 1F 00 7F 43 ; Logical OR long $437F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $FFFF7F.l,X		; 1F 7F FF FF ; Logical OR long $FFFF7F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx $23.b		; E4 23 ; Compare $23.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $010026.l,X		; 1F 26 00 01 ; Logical OR long $010026.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: ZNC]
	lda [$6B.b],Y		; B7 6B ; Load accumulator (long indexed) [$6B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	and $3B.b,X		; 35 3B ; Logical AND $3B.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1B.b		; 05 1B ; Logical OR $1B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	ora $0F0E11.l		; 0F 11 0E 0F ; OR accumulator with memory (long) $0F0E11.l [Writes: Accumulator] [Flags: ZN]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	asl $1E07.w		; 0E 07 1E ; Arithmetic shift left $1E07.w [Flags: ZNC]
	sbc $E17E.w		; ED 7E E1 ; Subtract $E17E.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	sbc #$D6.b		; E9 D6 ; Subtract #$D6.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	cmp [$20.b],Y		; D7 20 ; Compare accumulator (long indexed) [$20.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $D7E9FF.l,X		; FF FF E9 D7 ; Subtract with carry (long,X) $D7E9FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	jsr $43C0.w		; 20 C0 43 ; Jump to subroutine at $43C0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	eor $40.b,S		; 43 40 ; Exclusive OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $80, $26		; 80 26 ; Branch always to $80, $26 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $39053D.l,X		; DF 3D 05 39 ; Compare accumulator (long,X) $39053D.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	bit $50.b,X		; 34 50 ; Test bits $50.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	and $A38431.l		; 2F 31 84 A3 ; AND accumulator with memory (long) $A38431.l [Writes: Accumulator] [Flags: ZN]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	cmp $505B07.l,X		; DF 07 5B 50 ; Compare accumulator (long,X) $505B07.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$BE.b]		; 07 BE ; OR accumulator with memory (long) [$BE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $94FE.w		; ED FE 94 ; Subtract $94FE.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	lda ($04.b,S),Y		; B3 04 ; Load accumulator (stack relative indirect indexed) ($04.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $80, $26		; 80 26 ; Branch always to $80, $26 [Flow: branch]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $03.b,S		; 43 03 ; Exclusive OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $42, $05		; 42 05 ; Reserved instruction
	jsl $CD0A00.l		; 22 00 0A CD ; Jump to subroutine long $CD0A00.l [Writes: Stack Pointer] [Flow: call]
	cop $F6.b		; 02 F6 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($FF.b),Y		; 71 FF ; Add with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $04FE.w		; 0C FE 04 ; Test and set bits $04FE.w [Reads: Accumulator] [Flags: Z]
	jsr ($7800.w,X)		; FC 00 78 ; Jump to subroutine indirect indexed ($7800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $FCFAF3.l		; 8F F3 FA FC ; Store accumulator (long) $FCFAF3.l [Reads: Accumulator]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $42.b,S		; 83 42 ; Store accumulator (stack relative) $42.b,S [Reads: Accumulator, Stack Pointer]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($2A.b,X)		; 01 2A ; Logical OR ($2A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F75F.w		; EE 5F F7 ; Increment $F75F.w [Flags: ZN]
	adc $5766B9.l		; 6F B9 66 57 ; Add with carry (long) $5766B9.l [Writes: Accumulator] [Flags: ZVNC]
	jsr $2620.w		; 20 20 26 ; Jump to subroutine at $2620.w [Writes: Stack Pointer] [Flow: call]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $57B9F7.l		; EF F7 B9 57 ; Subtract with carry (long) $57B9F7.l [Writes: Accumulator] [Flags: ZVNC]
	jsr $0022.w		; 20 22 00 ; Jump to subroutine at $0022.w [Writes: Stack Pointer] [Flow: call]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $07,$00		; 44 00 07 ; Move block positive $07,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $0F.b		; 45 0F ; Exclusive OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $030200.l,X		; 1F 00 02 03 ; Logical OR long $030200.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $1F010F.l		; 22 0F 01 1F ; Jump to subroutine long $1F010F.l [Writes: Stack Pointer] [Flow: call]
	ora $00FF4F.l,X		; 1F 4F FF 00 ; Logical OR long $00FF4F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $FF004E.l,X		; 7F 4E 00 FF ; Add long $FF004E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $FF.b		; 26 FF ; Rotate left $FF.b [Reads: Direct Page] [Flags: ZNC]
	sbc $002FE0.l,X		; FF E0 2F 00 ; Subtract with carry (long,X) $002FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0F3C.w,X		; 3C 3C 0F ; Test bits $0F3C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $1B03.w,X		; 1E 03 1B ; Arithmetic shift left $1B03.w,X [Reads: X Index] [Flags: ZNC]
	ora $0E1D.w		; 0D 1D 0E ; Logical OR $0E1D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $000F.w		; 1C 0F 00 ; Test and reset bits $000F.w [Reads: Accumulator] [Flags: Z]
	bit $3F7F.w,X		; 3C 7F 3F ; Test bits $3F7F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $1C1D1B.l,X		; 1F 1B 1D 1C ; Logical OR long $1C1D1B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	stx $03.b		; 86 03 ; Store X register to $03.b [Reads: X Index]
	cmp $DBFE83.l,X		; DF 83 FE DB ; Compare accumulator (long,X) $DBFE83.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $3BFDDB.l,X		; FF DB FD 3B ; Subtract with carry (long,X) $3BFDDB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $86.b		; 04 86 ; Test and set bits $86.b [Reads: Accumulator] [Flags: Z]
	cmp $C5E7E7.l,X		; DF E7 E7 C5 ; Compare accumulator (long,X) $C5E7E7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$3E.b		; 09 3E ; Logical OR #$3E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $033E.w,X		; 3E 3E 03 ; Rotate left $033E.w,X [Reads: X Index] [Flags: ZNC]
	ora ($0D.b,S),Y		; 13 0D ; OR accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $2206.w,Y		; 79 06 22 ; Add $2206.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3F7F.w,X		; 3E 7F 3F ; Rotate left $3F7F.w,X [Reads: X Index] [Flags: ZNC]
	ora ($79.b,S),Y		; 13 79 ; OR accumulator (stack relative indirect indexed) ($79.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $18.b,S		; 83 18 ; Store accumulator (stack relative) $18.b,S [Reads: Accumulator, Stack Pointer]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	sta $FA03.w,X		; 9D 03 FA ; Store accumulator to $FA03.w,X [Reads: Accumulator, X Index]
	sta $24FD.w,Y		; 99 FD 24 ; Store accumulator to $24FD.w,Y [Reads: Accumulator, Y Index]
	lda $006221.l,X		; BF 21 62 00 ; Load long $006221.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	sta $DBE6.w,X		; 9D E6 DB ; Store accumulator to $DBE6.w,X [Reads: Accumulator, X Index]
	dec $27.b		; C6 27 ; Decrement $27.b [Reads: Direct Page] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $0905.w		; 0C 05 09 ; Test and set bits $0905.w [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$24.b		; 09 24 ; Logical OR #$24.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $98E383.l		; 0F 83 E3 98 ; OR accumulator with memory (long) $98E383.l [Writes: Accumulator] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $E6E201.l,X		; 1F 01 E2 E6 ; Logical OR long $E6E201.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00FF.w,Y		; F9 FF 00 ; Subtract with carry $00FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $98.b,S		; E3 98 ; Subtract stack-relative $98.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	ora ($E6.b,X)		; 01 E6 ; Logical OR ($E6.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $130023.l,X		; FF 23 00 13 ; Subtract with carry (long,X) $130023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl $E31E.w,X		; 1E 1E E3 ; Arithmetic shift left $E31E.w,X [Reads: X Index] [Flags: ZNC]
	ora [$DB.b]		; 07 DB ; OR accumulator with memory (long) [$DB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $C00000.l		; EF 00 00 C0 ; Subtract with carry (long) $C00000.l [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $FA		; F0 FA ; Branch if equal to $F0, $FA [Flow: branch]
	asl $EF07.w,X		; 1E 07 EF ; Arithmetic shift left $EF07.w,X [Reads: X Index] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$33.b		; E0 33 ; Compare #$33.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $5F.b,X		; 15 5F ; OR accumulator with memory $5F.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $5F.b		; 26 5F ; Rotate left $5F.b [Reads: Direct Page] [Flags: ZNC]
	and #$AF.b		; 29 AF ; Logical AND #$AF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor ($5F.b),Y		; 51 5F ; Exclusive OR accumulator with memory ($5F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $793A.w,X		; 1E 3A 79 ; Arithmetic shift left $793A.w,X [Reads: X Index] [Flags: ZNC]
	lsr $B8.b,X		; 56 B8 ; Logical shift right $B8.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc $C00080.l,X		; 7F 80 00 C0 ; Add long $C00080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $78		; 80 78 ; Branch always to $80, $78 [Flow: branch]
	.db $80, $74		; 80 74 ; Branch always to $80, $74 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	stz $FA.b		; 64 FA ; Store zero to $FA.b
	sty $F5.b,X		; 94 F5 ; Store Y register $F5.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	trb $80.b		; 14 80 ; Test and reset bits $80.b [Reads: Accumulator] [Flags: Z]
	cpy #$78.b		; C0 78 ; Compare #$78.b with Y register [Reads: Y Index] [Flags: ZNC]
	jmp $1D6A9E.l		; 5C 9E 6A 1D ; Jump long to $1D6A9E.l [Flow: jump]
	inc $0025.w,X		; FE 25 00 ; Increment memory $0025.w,X [Reads: X Index] [Flags: ZN]
	ora #$60.b		; 09 60 ; Logical OR #$60.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rol $1A1D.w,X		; 3E 1D 1A ; Rotate left $1A1D.w,X [Reads: X Index] [Flags: ZNC]
	ora #$22.b		; 09 22 ; Logical OR #$22.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor [$22.b],Y		; 57 22 ; Exclusive OR accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $27.b,X		; 16 27 ; Arithmetic shift left $27.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $F200.w		; 1C 00 F2 ; Test and reset bits $F200.w [Reads: Accumulator] [Flags: Z]
	.db $10, $79		; 10 79 ; Branch if plus to $10, $79 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cmp $002396.l,X		; DF 96 23 00 ; Compare accumulator (long,X) $002396.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $E947.w		; EE 47 E9 ; Increment $E947.w [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $261100.l		; 0F 00 11 26 ; OR accumulator with memory (long) $261100.l [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00271F.l		; 0F 1F 27 00 ; OR accumulator with memory (long) $00271F.l [Writes: Accumulator] [Flags: ZN]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FA.b		; 04 FA ; Test and set bits $FA.b [Reads: Accumulator] [Flags: Z]
	trb $FC.b		; 14 FC ; Test and reset bits $FC.b [Reads: Accumulator] [Flags: Z]
	.db $B0, $23		; B0 23 ; Branch if carry set to $B0, $23 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $1E04.w,X		; DD 04 1E ; Compare accumulator $1E04.w,X [Reads: X Index] [Flags: ZNC]
	nop		; EA ; No operation
	jmp $0003.w		; 4C 03 00 ; Jump to $0003.w [Flow: jump]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $1307.w		; 0C 07 13 ; Test and set bits $1307.w [Reads: Accumulator] [Flags: Z]
	tsb $031F.w		; 0C 1F 03 ; Test and set bits $031F.w [Reads: Accumulator] [Flags: Z]
	ora $3709.w,Y		; 19 09 37 ; OR accumulator with memory $3709.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($3E.b),Y		; 11 3E ; OR accumulator with memory ($3E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b)		; 12 03 ; OR accumulator with memory (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($1C.b,S),Y		; 13 1C ; OR accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $2E.b,X		; 16 2E ; Arithmetic shift left $2E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and #$C0.b		; 29 C0 ; Logical AND #$C0.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$30.b		; C0 30 ; Compare #$30.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpy $BCB0.w		; CC B0 BC ; Compare $BCB0.w with Y register [Reads: Y Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cpy #$A0.b		; C0 A0 ; Compare #$A0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $7C.b,X		; 34 7C ; Test bits $7C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	pea $037C.w		; F4 7C 03 ; Push absolute address $037C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sta [$7C.b]		; 87 7C ; Store accumulator (long) [$7C.b] [Reads: Accumulator, Direct Page]
	adc $324F0F.l,X		; 7F 0F 4F 32 ; Add long $324F0F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($1D.b,S),Y		; 33 1D ; AND accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $0917.w		; 0D 17 09 ; Logical OR $0917.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $FF7C14.l		; 2F 14 7C FF ; AND accumulator with memory (long) $FF7C14.l [Writes: Accumulator] [Flags: ZN]
	adc $1A324F.l,X		; 7F 4F 32 1A ; Add long $1A324F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $2F.b,X		; 16 2F ; Arithmetic shift left $2F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy $DE4B.w		; CC 4B DE ; Compare $DE4B.w with Y register [Reads: Y Index] [Flags: ZNC]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $42, $E7		; 42 E7 ; Reserved instruction
	cmp $7B.b,S		; C3 7B ; Compare accumulator (stack relative) $7B.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $3F05.w,X		; 3D 05 3F ; AND accumulator with memory $3F05.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $BF.b,S		; 23 BF ; AND accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda ($B4.b,X)		; A1 B4 ; Load accumulator ($B4.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	lda $843C.w,X		; BD 3C 84 ; Load $843C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cpy $8F42.w		; CC 42 8F ; Compare $8F42.w with Y register [Reads: Y Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $356F0E.l,X		; 7F 0E 6F 35 ; Add long $356F0E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$19.b],Y		; 37 19 ; AND accumulator with memory (long indexed) [$19.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$19.b]		; 27 19 ; AND accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $285F14.l		; 2F 14 5F 28 ; AND accumulator with memory (long) $285F14.l [Writes: Accumulator] [Flags: ZN]
	ror $FF11.w		; 6E 11 FF ; Rotate right $FF11.w [Flags: ZNC]
	adc $26366E.l,X		; 7F 6E 36 26 ; Add long $26366E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $BF7E5F.l		; 2F 5F 7E BF ; AND accumulator with memory (long) $BF7E5F.l [Writes: Accumulator] [Flags: ZN]
	lda ($3F.b,X)		; A1 3F ; Load accumulator ($3F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $7F		; 30 7F ; Branch if minus to $30, $7F [Flow: branch]
	eor $BCBFFF.l		; 4F FF BF BC ; Exclusive OR accumulator with memory (long) $BCBFFF.l [Writes: Accumulator] [Flags: ZN]
	adc $4FFF60.l,X		; 7F 60 FF 4F ; Add long $4FFF60.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	cmp $BC7FBF.l		; CF BF 7F BC ; Compare accumulator (long) $BC7FBF.l [Reads: Accumulator] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $130B3C.l		; 4F 3C 0B 13 ; Exclusive OR accumulator with memory (long) $130B3C.l [Writes: Accumulator] [Flags: ZN]
	tsb $0417.w		; 0C 17 04 ; Test and set bits $0417.w [Reads: Accumulator] [Flags: Z]
	ora $010E03.l		; 0F 03 0E 01 ; OR accumulator with memory (long) $010E03.l [Writes: Accumulator] [Flags: ZN]
	asl $0403.w		; 0E 03 04 ; Arithmetic shift left $0403.w [Flags: ZNC]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $171318.l		; 0F 18 13 17 ; OR accumulator with memory (long) $171318.l [Writes: Accumulator] [Flags: ZN]
	ora $040E0E.l		; 0F 0E 0E 04 ; OR accumulator with memory (long) $040E0E.l [Writes: Accumulator] [Flags: ZN]
	tsb $1F18.w		; 0C 18 1F ; Test and set bits $1F18.w [Reads: Accumulator] [Flags: Z]
	sta $7F.b,S		; 83 7F ; Store accumulator (stack relative) $7F.b,S [Reads: Accumulator, Stack Pointer]
	stz $18DF.w,X		; 9E DF 18 ; Store zero to $18DF.w,X [Reads: X Index]
	lda $AE36.w,Y		; B9 36 AE ; Load $AE36.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($6F.b),Y		; 31 6F ; AND accumulator with memory ($6F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $77		; 70 77 ; Branch if overflow set to $70, $77 [Flow: branch]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	adc $5A.b,X		; 75 5A ; Add $5A.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $9E.b,S		; 83 9E ; Store accumulator (stack relative) $9E.b,S [Reads: Accumulator, Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $31.b,X		; 36 31 ; Rotate left $31.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $70, $5B		; 70 5B ; Branch if overflow set to $70, $5B [Flow: branch]
	eor $BFED.w,Y		; 59 ED BF ; Exclusive OR accumulator with memory $BFED.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc #$0F.b		; E9 0F ; Subtract #$0F.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	lda $7D.b,X		; B5 7D ; Load $7D.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $4B3D.w,Y		; F9 3D 4B ; Subtract with carry $4B3D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FDA7.w,X		; FE A7 FD ; Increment memory $FDA7.w,X [Reads: X Index] [Flags: ZN]
	ldy $4F.b,X		; B4 4F ; Load Y register $4F.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	lda $7D2B0F.l,X		; BF 0F 2B 7D ; Load long $7D2B0F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $FDFE.w,X		; 3D FE FD ; AND accumulator with memory $FDFE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $23A0A0.l		; 8F A0 A0 23 ; Store accumulator (long) $23A0A0.l [Reads: Accumulator]
	.db $D0, $43		; D0 43 ; Branch if not equal to $D0, $43 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	clv		; B8 ; Clear overflow flag [Flags: V]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $B8		; 30 B8 ; Branch if minus to $30, $B8 [Flow: branch]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	cpx #$38.b		; E0 38 ; Compare #$38.b with X register [Reads: X Index] [Flags: ZNC]
	ldy #$D0.b		; A0 D0 ; Load #$D0.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $D0, $22		; D0 22 ; Branch if not equal to $D0, $22 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpx #$6C.b		; E0 6C ; Compare #$6C.b with X register [Reads: X Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$2F.b],Y		; D7 2F ; Compare accumulator (long indexed) [$2F.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	ora [$FD.b],Y		; 17 FD ; OR accumulator with memory (long indexed) [$FD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $62, $7F, $18		; 62 7F 18 ; Push effective relative address $62, $7F, $18 [Writes: Stack Pointer]
	lsr $7F0C.w		; 4E 0C 7F ; Logical shift right $7F0C.w [Flags: ZNC]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	nop		; EA ; No operation
	sta $7367.w,X		; 9D 67 73 ; Store accumulator to $7367.w,X [Reads: Accumulator, X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	and $F4EB3D.l,X		; 3F 3D EB F4 ; AND accumulator with memory (long,X) $F4EB3D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $BFE8.w,X		; 5D E8 BF ; Exclusive OR accumulator with memory $BFE8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lsr $FE.b		; 46 FE ; Logical shift right $FE.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($30.b)		; 72 30 ; Add with carry (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $7C20.w,X		; FE 20 7C ; Increment memory $7C20.w,X [Reads: X Index] [Flags: ZN]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$B9.b],Y		; 57 B9 ; Exclusive OR accumulator with memory (long indexed) [$B9.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $CE.b		; E6 CE ; Increment $CE.b [Reads: Direct Page] [Flags: ZN]
	lsr $BCFC.w,X		; 5E FC BC ; Logical shift right $BCFC.w,X [Reads: X Index] [Flags: ZNC]
	ora $2E08.w,Y		; 19 08 2E ; OR accumulator with memory $2E08.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0D2F.w		; 0E 2F 0D ; Arithmetic shift left $0D2F.w [Flags: ZNC]
	rol $1E03.w,X		; 3E 03 1E ; Rotate left $1E03.w,X [Reads: X Index] [Flags: ZNC]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($32.b),Y		; 31 32 ; AND accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $021D.w,X		; 3C 1D 02 ; Test bits $021D.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $787E16.l,X		; 9F 16 7E 78 ; Store accumulator (long,X) $787E16.l,X [Reads: Accumulator, X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $C8.b		; 86 C8 ; Store X register to $C8.b [Reads: X Index]
	.db $70, $A0		; 70 A0 ; Branch if overflow set to $70, $A0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $1E		; 80 1E ; Branch always to $80, $1E [Flow: branch]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$76.b		; A0 76 ; Load #$76.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $30, $F9		; 30 F9 ; Branch if minus to $30, $F9 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	inc $F050.w,X		; FE 50 F0 ; Increment memory $F050.w,X [Reads: X Index] [Flags: ZN]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	trb $58.b		; 14 58 ; Test and reset bits $58.b [Reads: Accumulator] [Flags: Z]
	dec $AEC7.w		; CE C7 AE ; Decrement $AEC7.w [Flags: ZN]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $327F02.l,X		; 3F 02 7F 32 ; AND accumulator with memory (long,X) $327F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $1D223C.l,X		; 5F 3C 22 1D ; Exclusive OR accumulator with memory (long,X) $1D223C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0F1000.l,X		; 1F 00 10 0F ; Logical OR long $0F1000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $140022.l		; 0F 22 00 14 ; OR accumulator with memory (long) $140022.l [Writes: Accumulator] [Flags: ZN]
	and ($7D.b),Y		; 31 7D ; AND accumulator with memory ($7D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $101D20.l,X		; 5F 20 1D 10 ; Exclusive OR accumulator with memory (long,X) $101D20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $B04C00.l		; 0F 00 4C B0 ; OR accumulator with memory (long) $B04C00.l [Writes: Accumulator] [Flags: ZN]
	ldy $4848.w,X		; BC 48 48 ; Load Y register $4848.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	ldy #$E0.b		; A0 E0 ; Load #$E0.b into Y register [Writes: Y Index] [Flags: ZN]
	jsl $3CE000.l		; 22 00 E0 3C ; Jump to subroutine long $3CE000.l [Writes: Stack Pointer] [Flow: call]
	cpy $F8F4.w		; CC F4 F8 ; Compare $F8F4.w with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $2A11.w		; 2E 11 2A ; Rotate left $2A11.w [Flags: ZNC]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1D.b]		; 07 1D ; OR accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3F.b		; 05 3F ; Logical OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $123A.w,X		; 3E 3A 12 ; Rotate left $123A.w,X [Reads: X Index] [Flags: ZNC]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $917761.l		; EF 61 77 91 ; Subtract with carry (long) $917761.l [Writes: Accumulator] [Flags: ZVNC]
	adc $FF3FE0.l,X		; 7F E0 3F FF ; Add long $FF3FE0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$EF.b],Y		; 17 EF ; OR accumulator with memory (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$FF.b]		; 67 FF ; Add with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$90.b		; A0 90 ; Load #$90.b into Y register [Writes: Y Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	adc $80073F.l,X		; 7F 3F 07 80 ; Add long $80073F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $53.b,S		; E3 53 ; Subtract stack-relative $53.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	eor ($21.b)		; 52 21 ; Exclusive OR accumulator with memory (indirect) ($21.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $830201.l		; 22 01 02 83 ; Jump to subroutine long $830201.l [Writes: Stack Pointer] [Flow: call]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora $0A1B06.l		; 0F 06 1B 0A ; OR accumulator with memory (long) $0A1B06.l [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,S),Y		; 13 03 ; OR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($22.b)		; 72 22 ; Add with carry (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0C.b,X		; 15 0C ; OR accumulator with memory $0C.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $7F45C0.l,X		; 3F C0 45 7F ; AND accumulator with memory (long,X) $7F45C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	sbc $7F0400.l,X		; FF 00 04 7F ; Subtract with carry (long,X) $7F0400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $BF		; 80 BF ; Branch always to $80, $BF [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $057F22.l,X		; 3F 22 7F 05 ; AND accumulator with memory (long,X) $057F22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $A367EF.l,X		; FF EF 67 A3 ; Subtract with carry (long,X) $A367EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $4319.w		; 0E 19 43 ; Arithmetic shift left $4319.w [Flags: ZNC]
	asl $E029.w		; 0E 29 E0 ; Arithmetic shift left $E029.w [Flags: ZNC]
	eor $3C1B.w		; 4D 1B 3C ; Exclusive OR $3C1B.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $12193C.l,X		; 1F 3C 19 12 ; Logical OR long $12193C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $2919.w,Y		; 19 19 29 ; OR accumulator with memory $2919.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and #$3C.b		; 29 3C ; Logical AND #$3C.b with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $1312.w,X		; 3C 12 13 ; Test bits $1312.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $186F.w,Y		; 19 6F 18 ; OR accumulator with memory $186F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $EEBA.w		; ED BA EE ; Subtract $EEBA.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	sta ($F7.b),Y		; 91 F7 ; Store accumulator ($F7.b),Y [Reads: Accumulator, Direct Page, Y Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sbc $06F941.l,X		; FF 41 F9 06 ; Subtract with carry (long,X) $06F941.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $1F.b		; E4 1F ; Compare $1F.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $70, $09		; 70 09 ; Branch if overflow set to $70, $09 [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	lda $8890.w,Y		; B9 90 88 ; Load $8890.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	eor ($06.b,X)		; 41 06 ; Exclusive OR accumulator with memory ($06.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $27DA09.l,X		; 1F 09 DA 27 ; Logical OR long $27DA09.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldx $FA71.w,Y		; BE 71 FA ; Load X register $FA71.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	adc $D1.b		; 65 D1 ; Add $D1.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $BAD5.w		; EE D5 BA ; Increment $BAD5.w [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	stz $1F.b		; 64 1F ; Store zero to $1F.b
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	cpx #$C7.b		; E0 C7 ; Compare #$C7.b with X register [Reads: X Index] [Flags: ZNC]
	lda ($65.b),Y		; B1 65 ; Load accumulator ($65.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $64BA.w		; EE BA 64 ; Increment $64BA.w [Flags: ZN]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpx #$30.b		; E0 30 ; Compare #$30.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$04.b		; C0 04 ; Compare #$04.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $D0, $14		; D0 14 ; Branch if not equal to $D0, $14 [Flow: branch]
	.db $90, $50		; 90 50 ; Branch if carry clear to $90, $50 [Flow: branch]
	cpx #$60.b		; E0 60 ; Compare #$60.b with X register [Reads: X Index] [Flags: ZNC]
	eor $60.b,S		; 43 60 ; Exclusive OR accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$07.b		; E0 07 ; Compare #$07.b with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	tsb $14.b		; 04 14 ; Test and set bits $14.b [Reads: Accumulator] [Flags: Z]
	.db $50, $60		; 50 60 ; Branch if overflow clear to $50, $60 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $5B		; 10 5B ; Branch if plus to $10, $5B [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $70, $34		; 70 34 ; Branch if overflow set to $70, $34 [Flow: branch]
	and ($04.b,S),Y		; 33 04 ; AND accumulator (stack relative indirect indexed) ($04.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $300400.l		; 22 00 04 30 ; Jump to subroutine long $300400.l [Writes: Stack Pointer] [Flow: call]
	jmp ($4F67.w)		; 6C 67 4F ; Jump indirect to ($4F67.w) [Flow: jump]
	bit $0025.w,X		; 3C 25 00 ; Test bits $0025.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora #$0C.b		; 09 0C ; Logical OR #$0C.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $0D1C.w,X		; DD 1C 0D ; Compare accumulator $0D1C.w,X [Reads: X Index] [Flags: ZNC]
	bit $CF.b		; 24 CF ; Test bits $CF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	rol $22.b		; 26 22 ; Rotate left $22.b [Reads: Direct Page] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $E336.w		; 0C 36 E3 ; Test and set bits $E336.w [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $890025.l,X		; 3F 25 00 89 ; AND accumulator with memory (long,X) $890025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jsl $438E00.l		; 22 00 8E 43 ; Jump to subroutine long $438E00.l [Writes: Stack Pointer] [Flow: call]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FF81.w,X		; FE 81 FF ; Increment memory $FF81.w,X [Reads: X Index] [Flags: ZN]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($62.b,X)		; 01 62 ; Logical OR ($62.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$9D.b]		; 07 9D ; OR accumulator with memory (long) [$9D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $E0F3.w,X		; FE F3 E0 ; Increment memory $E0F3.w,X [Reads: X Index] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $011100.l		; 0F 00 11 01 ; OR accumulator with memory (long) $011100.l [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $0027.w,X		; 1E 27 00 ; Arithmetic shift left $0027.w,X [Reads: X Index] [Flags: ZNC]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $BA.b		; 04 BA ; Test and set bits $BA.b [Reads: Accumulator] [Flags: Z]
	trb $DC.b		; 14 DC ; Test and reset bits $DC.b [Reads: Accumulator] [Flags: Z]
	cpy #$23.b		; C0 23 ; Compare #$23.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($0C.b,S),Y		; 33 0C ; AND accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $3CEA.w,X		; 5E EA 3C ; Logical shift right $3CEA.w,X [Reads: X Index] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $62, $01, $97		; 62 01 97 ; Push effective relative address $62, $01, $97 [Writes: Stack Pointer]
	adc ($6F.b,X)		; 61 6F ; Add with carry ($6F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $56.b,X		; 15 56 ; OR accumulator with memory $56.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and #$5E.b		; 29 5E ; Logical AND #$5E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and $8A.b		; 25 8A ; Logical AND $8A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc ($76.b),Y		; 71 76 ; Add with carry ($76.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $62, $F7, $7B		; 62 F7 7B ; Push effective relative address $62, $F7, $7B [Writes: Stack Pointer]
	lsr $FE5A.w,X		; 5E 5A FE ; Logical shift right $FE5A.w,X [Reads: X Index] [Flags: ZNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	lsr $80.b		; 46 80 ; Logical shift right $80.b [Reads: Direct Page] [Flags: ZNC]
	sbc #$86.b		; E9 86 ; Subtract #$86.b from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	inc $A8.b,X		; F6 A8 ; Increment memory $A8.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	nop		; EA ; No operation
	sty $7A.b,X		; 94 7A ; Store Y register $7A.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	ldy $51.b		; A4 51 ; Load $51.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	stx $804E.w		; 8E 4E 80 ; Store X register to $804E.w [Reads: X Index]
	.db $80, $46		; 80 46 ; Branch always to $80, $46 [Flow: branch]
	sbc $5AFADE.l		; EF DE FA 5A ; Subtract with carry (long) $5AFADE.l [Writes: Accumulator] [Flags: ZVNC]
	adc $38437E.l,X		; 7F 7E 43 38 ; Add long $38437E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $001705.l,X		; 1F 05 17 00 ; Logical OR long $001705.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0600.w		; 0D 00 06 ; Logical OR $0600.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $070400.l		; 22 00 04 07 ; Jump to subroutine long $070400.l [Writes: Stack Pointer] [Flow: call]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $22E000.l		; 22 00 E0 22 ; Jump to subroutine long $22E000.l [Writes: Stack Pointer] [Flow: call]
	cmp $F0B3.w		; CD B3 F0 ; Compare $F0B3.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	cmp $E070FF.l		; CF FF 70 E0 ; Compare accumulator (long) $E070FF.l [Reads: Accumulator] [Flags: ZNC]
	cpx #$C2.b		; E0 C2 ; Compare #$C2.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $00EF00.l,X		; FF 00 EF 00 ; Subtract with carry (long,X) $00EF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($00.b)		; 72 00 ; Add with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $8F30.w		; 4D 30 8F ; Exclusive OR $8F30.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $0330BD.l,X		; 1F BD 30 03 ; Logical OR long $0330BD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3B.b),Y		; 11 3B ; OR accumulator with memory ($3B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $002F00.l,X		; 1F 00 2F 00 ; Logical OR long $002F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	mvp $01,$00		; 44 00 01 ; Move block positive $01,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $9F1D00.l		; 22 00 1D 9F ; Jump to subroutine long $9F1D00.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp $F0B3.w		; CD B3 F0 ; Compare $F0B3.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	eor $CFF0FF.l		; 4F FF F0 CF ; Exclusive OR accumulator with memory (long) $CFF0FF.l [Writes: Accumulator] [Flags: ZN]
	eor $4F00F6.l		; 4F F6 00 4F ; Exclusive OR accumulator with memory (long) $4F00F6.l [Writes: Accumulator] [Flags: ZN]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0FB0.w		; 4D B0 0F ; Exclusive OR $0FB0.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $30, $79		; 30 79 ; Branch if minus to $30, $79 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0703.w		; 0C 03 07 ; Test and set bits $0703.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $7F1FF3.l,X		; FF F3 1F 7F ; Subtract with carry (long,X) $7F1FF3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $82, $9F, $01		; 82 9F 01 ; Branch always long to $82, $9F, $01 [Flow: branch]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $07.b,S		; 63 07 ; Add with carry (stack relative) $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $F3.b		; 04 F3 ; Test and set bits $F3.b [Reads: Accumulator] [Flags: Z]
	adc $63019F.l,X		; 7F 9F 01 63 ; Add long $63019F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $FC0B00.l		; 22 00 0B FC ; Jump to subroutine long $FC0B00.l [Writes: Stack Pointer] [Flow: call]
	cmp $FB.b		; C5 FB ; Compare $FB.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jmp ($F0FC.w,X)		; 7C FC F0 ; Jump indirect indexed to ($F0FC.w,X) [Reads: X Index] [Flow: jump]
	sbc ($CF.b,S),Y		; F3 CF ; Subtract with carry (stack relative indirect indexed) ($CF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy $70F0.w		; CC F0 70 ; Compare $70F0.w with Y register [Reads: Y Index] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $C5.b		; 05 C5 ; Logical OR $C5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jsr ($CCF3.w,X)		; FC F3 CC ; Jump to subroutine indirect indexed ($CCF3.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $83		; 70 83 ; Branch if overflow set to $70, $83 [Flow: branch]
	lda $200400.l		; AF 00 04 20 ; Load long $200400.l into accumulator [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	.db $80, $24		; 80 24 ; Branch always to $80, $24 [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $270A.w,Y		; 19 0A 27 ; OR accumulator with memory $270A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	asl $043F.w		; 0E 3F 04 ; Arithmetic shift left $043F.w [Flags: ZNC]
	asl $0026.w,X		; 1E 26 00 ; Arithmetic shift left $0026.w,X [Reads: X Index] [Flags: ZNC]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and ($3B.b,X)		; 21 3B ; Logical AND ($3B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $0022.w,X		; 1E 22 00 ; Arithmetic shift left $0022.w,X [Reads: X Index] [Flags: ZNC]
	asl $9E.b		; 06 9E ; Arithmetic shift left $9E.b [Reads: Direct Page] [Flags: ZNC]
	.db $50, $BC		; 50 BC ; Branch if overflow clear to $50, $BC [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$28.b		; C0 28 ; Compare #$28.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $B854.w		; 6E 54 B8 ; Rotate right $B854.w [Flags: ZNC]
	cpy #$23.b		; C0 23 ; Compare #$23.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$B0.b]		; 27 B0 ; AND accumulator with memory (long) [$B0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	mvp $D9,$86		; 44 86 D9 ; Move block positive $D9,$86 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $1D00.w,X		; 1E 00 1D ; Arithmetic shift left $1D00.w,X [Reads: X Index] [Flags: ZNC]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $33.b		; 05 33 ; Logical OR $33.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	asl $1A.b,X		; 16 1A ; Arithmetic shift left $1A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and $0718.w		; 2D 18 07 ; Logical AND $0718.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $F6		; 70 F6 ; Branch if overflow set to $70, $F6 [Flow: branch]
	ldy #$F9.b		; A0 F9 ; Load #$F9.b into Y register [Writes: Y Index] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	inc $F070.w,X		; FE 70 F0 ; Increment memory $F070.w,X [Reads: X Index] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $B8.b		; 04 B8 ; Test and set bits $B8.b [Reads: Accumulator] [Flags: Z]
	ror $8E27.w,X		; 7E 27 8E ; Rotate right $8E27.w,X [Reads: X Index] [Flags: ZNC]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $2FDF76.l		; 8F 76 DF 2F ; Store accumulator (long) $2FDF76.l [Reads: Accumulator]
	lda $0D7E5E.l,X		; BF 5E 7E 0D ; Load long $0D7E5E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0705.w,X		; 1E 05 07 ; Arithmetic shift left $0705.w,X [Reads: X Index] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($99.b)		; 12 99 ; OR accumulator with memory (indirect) ($99.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $E1		; F0 E1 ; Branch if equal to $F0, $E1 [Flow: branch]
	adc ($1A.b)		; 72 1A ; Add with carry (indirect) ($1A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $91.b		; 00 91 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $040B.w		; 0E 0B 04 ; Arithmetic shift left $040B.w [Flags: ZNC]
	cmp $FE5A.w,X		; DD 5A FE ; Compare accumulator $FE5A.w,X [Reads: X Index] [Flags: ZNC]
	.db $B0, $F8		; B0 F8 ; Branch if carry set to $B0, $F8 [Flow: branch]
	ldy #$E0.b		; A0 E0 ; Load #$E0.b into Y register [Writes: Y Index] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$F9.b]		; 07 F9 ; OR accumulator with memory (long) [$F9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $D8CEA7.l,X		; FF A7 CE D8 ; Subtract with carry (long,X) $D8CEA7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$32.b		; E0 32 ; Compare #$32.b with X register [Reads: X Index] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3B54.w		; 1C 54 3B ; Test and reset bits $3B54.w [Reads: Accumulator] [Flags: Z]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: ZN]
	adc [$D6.b],Y		; 77 D6 ; Add with carry (long indexed) [$D6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $20EFD4.l		; 6F D4 EF 20 ; Add with carry (long) $20EFD4.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $1E1FF9.l,X		; DF F9 1F 1E ; Compare accumulator (long,X) $1E1FF9.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $EB.b,X		; 74 EB ; Store zero to $EB.b,X [Reads: X Index]
	cmp [$DF.b],Y		; D7 DF ; Compare accumulator (long indexed) [$DF.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	and $0000FF.l		; 2F FF 00 00 ; AND accumulator with memory (long) $0000FF.l [Writes: Accumulator] [Flags: ZN]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	asl $E9E0.w,X		; 1E E0 E9 ; Arithmetic shift left $E9E0.w,X [Reads: X Index] [Flags: ZNC]
	inc $58.b,X		; F6 58 ; Increment memory $58.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $66FF2C.l		; EF 2C FF 66 ; Subtract with carry (long) $66FF2C.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $00F7AA.l,X		; FF AA F7 00 ; Subtract with carry (long,X) $00F7AA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$1E.b		; E0 1E ; Compare #$1E.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $E7EFDF.l		; EF DF EF E7 ; Subtract with carry (long) $E7EFDF.l [Writes: Accumulator] [Flags: ZVNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	cpy #$2D.b		; C0 2D ; Compare #$2D.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$2D.b]		; 07 2D ; OR accumulator with memory (long) [$2D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $27		; F0 27 ; Branch if equal to $F0, $27 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $25		; F0 25 ; Branch if equal to $F0, $25 [Flow: branch]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0E4F00.l,X		; 3F 00 4F 0E ; AND accumulator with memory (long,X) $0E4F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda [$06.b]		; A7 06 ; Load accumulator (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp ($40.b),Y		; D1 40 ; Compare accumulator ($40.b),Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	cmp ($40.b,X)		; C1 40 ; Compare accumulator ($40.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	jsl $3F0400.l		; 22 00 04 3F ; Jump to subroutine long $3F0400.l [Writes: Stack Pointer] [Flow: call]
	adc ($D9.b),Y		; 71 D9 ; Add with carry ($D9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $0025BF.l		; AF BF 25 00 ; Load long $0025BF.l into accumulator [Writes: Accumulator] [Flags: ZN]
	ora #$C0.b		; 09 C0 ; Logical OR #$C0.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$68.b		; C0 68 ; Compare #$68.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $D0, $77		; D0 77 ; Branch if not equal to $D0, $77 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jsl $C00400.l		; 22 00 04 C0 ; Jump to subroutine long $C00400.l [Writes: Stack Pointer] [Flow: call]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $0020E4.l,X		; FF E4 20 00 ; Subtract with carry (long,X) $0020E4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $3F19.w,X		; 1D 19 3F ; OR accumulator with memory $3F19.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b)		; 12 3F ; OR accumulator with memory (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $2617.w,Y		; 19 17 26 ; OR accumulator with memory $2617.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
.ACCU 8
	sep #$E0		; E2 E0
	sbc $FF79.w,Y		; F9 79 FF ; Subtract with carry $FF79.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	adc $233E05.l,X		; 7F 05 3E 23 ; Add long $233E05.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$79.b		; E0 79 ; Compare #$79.b with X register [Reads: X Index] [Flags: ZNC]
	and $002806.l,X		; 3F 06 28 00 ; AND accumulator with memory (long,X) $002806.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $24		; 80 24 ; Branch always to $80, $24 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $5F3F46.l		; 5C 46 3F 5F ; Jump long to $5F3F46.l [Flow: jump]
	ora [$2F.b]		; 07 2F ; OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $181F27.l,X		; 1F 27 1F 18 ; Logical OR long $181F27.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $2F20E0.l,X		; 5F E0 20 2F ; Exclusive OR accumulator with memory (long,X) $2F20E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$7A.b]		; 07 7A ; OR accumulator with memory (long) [$7A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc [$F4.b],Y		; F7 F4 ; Subtract with carry (long indexed) [$F4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $FCF2F8.l,X		; FF F8 F2 FC ; Subtract with carry (long,X) $FCF2F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pea $CCF8.w		; F4 F8 CC ; Push absolute address $CCF8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $F2FF.w		; F4 FF F2 ; Push absolute address $F2FF.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	pea $30CC.w		; F4 CC 30 ; Push absolute address $30CC.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $24		; 80 24 ; Branch always to $80, $24 [Flow: branch]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $4701.w,Y		; 39 01 47 ; AND accumulator with memory $4701.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc ($FF.b)		; 72 FF ; Add with carry (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc #$FF.b		; 69 FF ; Add #$FF.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	stz $43.b,X		; 74 43 ; Store zero to $43.b,X [Reads: X Index]
	adc $3E1837.l,X		; 7F 37 18 3E ; Add long $3E1837.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $FFFF.w		; 8D FF FF ; Store accumulator to $FFFF.w [Reads: Accumulator]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $6FB890.l		; EF 90 B8 6F ; Subtract with carry (long) $6FB890.l [Writes: Accumulator] [Flags: ZVNC]
	adc [$FF.b],Y		; 77 FF ; Add with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FFCFFF.l,X		; 3F FF CF FF ; AND accumulator with memory (long,X) $FFCFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($3F.b,S),Y		; F3 3F ; Subtract with carry (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FECF.w,X		; FD CF FE ; Subtract with carry $FECF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($7F.b,S),Y		; F3 7F ; Subtract with carry (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $0F3F.w		; 0D 3F 0F ; Logical OR $0F3F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $22.b,S		; E3 22 ; Subtract stack-relative $22.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	sbc $5DFE5E.l,X		; FF 5E FE 5D ; Subtract with carry (long,X) $5DFE5E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $367F21.l,X		; 7F 21 7F 36 ; Add long $367F21.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $3F432F.l,X		; 7F 2F 43 3F ; Add long $3F432F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $E1DD17.l		; 0F 17 DD E1 ; OR accumulator with memory (long) $E1DD17.l [Writes: Accumulator] [Flags: ZN]
	sbc $7F.b,S		; E3 7F ; Subtract stack-relative $7F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	adc $3070.w,Y		; 79 70 30 ; Add $3070.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $7F		; 30 7F ; Branch if minus to $30, $7F [Flow: branch]
	sbc [$7F.b],Y		; F7 7F ; Subtract with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jmp ($03FF.w,X)		; 7C FF 03 ; Jump indirect indexed to ($03FF.w,X) [Reads: X Index] [Flow: jump]
	sbc $E7FFCF.l,X		; FF CF FF E7 ; Subtract with carry (long,X) $E7FFCF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $F9DFF3.l,X		; 3F F3 DF F9 ; AND accumulator with memory (long,X) $F9DFF3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $01FF25.l		; EF 25 FF 01 ; Subtract with carry (long) $01FF25.l [Writes: Accumulator] [Flags: ZVNC]
	and $00371F.l,X		; 3F 1F 37 00 ; AND accumulator with memory (long,X) $00371F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0702.w,X		; 1E 02 07 ; Arithmetic shift left $0702.w,X [Reads: X Index] [Flags: ZNC]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	ora ($3C.b,X)		; 01 3C ; Logical OR ($3C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7E.b		; 25 7E ; Logical AND $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $62, $F7, $01		; 62 F7 01 ; Push effective relative address $62, $F7, $01 [Writes: Stack Pointer]
	adc $43.b,S		; 63 43 ; Add with carry (stack relative) $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $01.b,S		; 63 01 ; Add with carry (stack relative) $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	bit $0400.w,X		; 3C 00 04 ; Test bits $0400.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $1E.b		; 05 1E ; Logical OR $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $88.b		; 04 88 ; Test and set bits $88.b [Reads: Accumulator] [Flags: Z]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $04.b,S		; 43 04 ; Exclusive OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $170023.l		; 0F 23 00 17 ; OR accumulator with memory (long) $170023.l [Writes: Accumulator] [Flags: ZN]
	sbc $00.b,S		; E3 00 ; Subtract stack-relative $00.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	trb $E3.b		; 14 E3 ; Test and reset bits $E3.b [Reads: Accumulator] [Flags: Z]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc [$7C.b],Y		; F7 7C ; Subtract with carry (long indexed) [$7C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$FC.b],Y		; F7 FC ; Subtract with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $00FFC6.l,X		; FF C6 FF 00 ; Subtract with carry (long,X) $00FFC6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $FFFB.w		; F4 FB FF ; Push absolute address $FFFB.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $0000CF.l,X		; FF CF 00 00 ; Subtract with carry (long,X) $0000CF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $0C.b,S		; 83 0C ; Store accumulator (stack relative) $0C.b,S [Reads: Accumulator, Stack Pointer]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3D.b,S		; 03 3D ; OR accumulator with stack relative $3D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$0B.b		; 09 0B ; Logical OR #$0B.b with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $003D.w		; 1C 3D 00 ; Test and reset bits $003D.w [Reads: Accumulator] [Flags: Z]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($44.b)		; F2 44 ; Subtract with carry (indirect) ($44.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($0DFA.w,X)		; FC FA 0D ; Jump to subroutine indirect indexed ($0DFA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldx #$FC.b		; A2 FC ; Load #$FC.b into X register [Writes: X Index] [Flags: ZN]
	mvp $00,$B8		; 44 B8 00 ; Move block positive $00,$B8 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F2.b		; 04 F2 ; Test and set bits $F2.b [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ldx #$44.b		; A2 44 ; Load #$44.b into X register [Writes: X Index] [Flags: ZN]
	adc $3F432F.l,X		; 7F 2F 43 3F ; Add long $3F432F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0F1F01.l		; 0F 01 1F 0F ; OR accumulator with memory (long) $0F1F01.l [Writes: Accumulator] [Flags: ZN]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F7F0F.l,X		; 1F 0F 7F 3F ; Logical OR long $3F7F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $703E.w,X		; 7E 3E 70 ; Rotate right $703E.w,X [Reads: X Index] [Flags: ZNC]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	jsr $4140.w		; 20 40 41 ; Jump to subroutine at $4140.w [Writes: Stack Pointer] [Flow: call]
	sta $8C8F9B.l,X		; 9F 9B 8F 8C ; Store accumulator (long,X) $8C8F9B.l,X [Reads: Accumulator, X Index]
	and $0D.b		; 25 0D ; Logical AND $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $1D.b		; 25 1D ; Logical AND $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($67.b,X)		; 01 67 ; Logical OR ($67.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc ($22.b,S),Y		; 73 22 ; Add with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($22.b)		; F2 22 ; Subtract with carry (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sep #$45		; E2 45 ; Set processor status bits #$45 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora $3F010F.l,X		; 1F 0F 01 3F ; Logical OR long $3F010F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $1E3E45.l,X		; 1F 45 3E 1E ; Logical OR long $1E3E45.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($7E.b,X)		; 01 7E ; Logical OR ($7E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rol $1022.w,X		; 3E 22 10 ; Rotate left $1022.w,X [Reads: X Index] [Flags: ZNC]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $410C21.l		; 22 21 0C 41 ; Jump to subroutine long $410C21.l [Writes: Stack Pointer] [Flow: call]
	jmp ($3E77.w,X)		; 7C 77 3E ; Jump indirect indexed to ($3E77.w,X) [Reads: X Index] [Flow: jump]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $1F1B.w,X		; 1E 1B 1F ; Arithmetic shift left $1F1B.w,X [Reads: X Index] [Flags: ZNC]
	ora $1E1F.w,X		; 1D 1F 1E ; OR accumulator with memory $1E1F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $1D231F.l,X		; 1F 1F 23 1D ; Logical OR long $1D231F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$8F.b]		; 07 8F ; OR accumulator with memory (long) [$8F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp [$E7.b]		; C7 E7 ; Compare accumulator (long) [$E7.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc $E1.b,S		; E3 E1 ; Subtract stack-relative $E1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cpx #$E2.b		; E0 E2 ; Compare #$E2.b with X register [Reads: X Index] [Flags: ZNC]
.ACCU 8
.INDEX 8
	sep #$3D		; E2 3D
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $221F15.l		; 0F 15 1F 22 ; OR accumulator with memory (long) $221F15.l [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0102.w		; 1C 02 01 ; Test and reset bits $0102.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora [$2D.b],Y		; 17 2D ; OR accumulator with memory (long indexed) [$2D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $DE.b		; 85 DE ; Store accumulator to $DE.b [Reads: Accumulator]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sbc $22FF05.l,X		; FF 05 FF 22 ; Subtract with carry (long,X) $22FF05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0102.w		; 1C 02 01 ; Test and reset bits $0102.w [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sta [$2C.b]		; 87 2C ; Store accumulator (long) [$2C.b] [Reads: Accumulator, Direct Page]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$26.b]		; 07 26 ; OR accumulator with memory (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7020.w		; 20 20 70 ; Jump to subroutine at $7020.w [Writes: Stack Pointer] [Flow: call]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0501.w,Y		; 59 01 05 ; Exclusive OR accumulator with memory $0501.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00001D.l		; 0F 1D 00 00 ; OR accumulator with memory (long) $00001D.l [Writes: Accumulator] [Flags: ZN]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F8FF30.l,X		; FF 30 FF F8 ; Subtract with carry (long,X) $F8FF30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$FD.b],Y		; 37 FD ; AND accumulator with memory (long indexed) [$FD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($FE.b,S),Y		; 73 FE ; Add with carry (stack relative indirect indexed) ($FE.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sbc $D0FF.w		; ED FF D0 ; Subtract $D0FF.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFEFF.l,X		; FF FF FE FF ; Subtract with carry (long,X) $FFFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $070BFE.l,X		; FF FE 0B 07 ; Subtract with carry (long,X) $070BFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	ora $2A.b,S		; 03 2A ; OR accumulator with stack relative $2A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $240306.l		; 0F 06 03 24 ; OR accumulator with memory (long) $240306.l [Writes: Accumulator] [Flags: ZN]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cmp $9FBF5C.l,X		; DF 5C BF 9F ; Compare accumulator (long,X) $9FBF5C.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $407F8F.l,X		; 7F 8F 7F 40 ; Add long $407F8F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $A38420.l,X		; 3F 20 84 A3 ; AND accumulator with memory (long,X) $A38420.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $8F9F5F.l		; 2F 5F 9F 8F ; AND accumulator with memory (long) $8F9F5F.l [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $0718.w		; 20 18 07 ; Jump to subroutine at $0718.w [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	and [$D7.b]		; 27 D7 ; AND accumulator with memory (long) [$D7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $383F73.l,X		; 3F 73 3F 38 ; AND accumulator with memory (long,X) $383F73.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $7A.b		; 04 7A ; Test and set bits $7A.b [Reads: Accumulator] [Flags: Z]
	lda [$73.b],Y		; B7 73 ; Load accumulator (long indexed) [$73.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$30.b		; C0 30 ; Compare #$30.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $38.b		; 04 38 ; Test and set bits $38.b [Reads: Accumulator] [Flags: Z]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	jsl $FE0100.l		; 22 00 01 FE ; Jump to subroutine long $FE0100.l [Writes: Stack Pointer] [Flow: call]
	ror $FC44.w,X		; 7E 44 FC ; Rotate right $FC44.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($6403.w,X)		; 7C 03 64 ; Jump indirect indexed to ($6403.w,X) [Reads: X Index] [Flow: jump]
	cpx $40.b		; E4 40 ; Compare $40.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $24.b,S		; 43 24 ; Exclusive OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($83.b,X)		; 81 83 ; Store accumulator ($83.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta $9B.b,S		; 83 9B ; Store accumulator (stack relative) $9B.b,S [Reads: Accumulator, Stack Pointer]
	lda [$43.b]		; A7 43 ; Load accumulator (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	ora $FF03.w,X		; 1D 03 FF ; OR accumulator with memory $FF03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	and $E2.b		; 25 E2 ; Logical AND $E2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $E3.b,S		; 03 E3 ; OR accumulator with stack relative $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $3E7E.w		; 1C 7E 3E ; Test and reset bits $3E7E.w [Reads: Accumulator] [Flags: Z]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp ($FE04.w,X)		; 7C 04 FE ; Jump indirect indexed to ($FE04.w,X) [Reads: X Index] [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $246140.l,X		; FF 40 61 24 ; Subtract with carry (long,X) $246140.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($83.b,X)		; 41 83 ; Exclusive OR accumulator with memory ($83.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $9F.b,S		; 83 9F ; Store accumulator (stack relative) $9F.b,S [Reads: Accumulator, Stack Pointer]
	lda $000061.l,X		; BF 61 00 00 ; Load long $000061.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$1D.b]		; 27 1D ; AND accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$9D.b]		; 07 9D ; OR accumulator with memory (long) [$9D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1DDD.w,X		; 1D DD 1D ; OR accumulator with memory $1DDD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $0F0D.w,X		; 3D 0D 0F ; AND accumulator with memory $0F0D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sep #$01		; E2 01 ; Set processor status bits #$01 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and ($0F.b)		; 32 0F ; AND accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $01, $26		; 62 01 26 ; Push effective relative address $62, $01, $26 [Writes: Stack Pointer]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $7F52.w,X		; 3E 52 7F ; Rotate left $7F52.w,X [Reads: X Index] [Flags: ZNC]
	eor ($7B.b,X)		; 41 7B ; Exclusive OR accumulator with memory ($7B.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $80, $F3		; 80 F3 ; Branch always to $80, $F3 [Flow: branch]
	.db $80, $E1		; 80 E1 ; Branch always to $80, $E1 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $26.b		; 04 26 ; Test and set bits $26.b [Reads: Accumulator] [Flags: Z]
	eor ($51.b,S),Y		; 53 51 ; XOR accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $080500.l		; 22 00 05 08 ; Jump to subroutine long $080500.l [Writes: Stack Pointer] [Flow: call]
	ora $201F10.l		; 0F 10 1F 20 ; OR accumulator with memory (long) $201F10.l [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $EE01.w,X		; FE 01 EE ; Increment memory $EE01.w,X [Reads: X Index] [Flags: ZN]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $BE.b,S		; 83 BE ; Store accumulator (stack relative) $BE.b,S [Reads: Accumulator, Stack Pointer]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $02.b		; 86 02 ; Store X register to $02.b [Reads: X Index]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $05.b,S		; 43 05 ; Exclusive OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $0204.w		; 0E 04 02 ; Arithmetic shift left $0204.w [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $060001.l		; 22 01 00 06 ; Jump to subroutine long $060001.l [Writes: Stack Pointer] [Flow: call]
	sta $91.b,S		; 83 91 ; Store accumulator (stack relative) $91.b,S [Reads: Accumulator, Stack Pointer]
	tsb $1B.b		; 04 1B ; Test and set bits $1B.b [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$70.b		; A0 70 ; Load #$70.b into Y register [Writes: Y Index] [Flags: ZN]
	cpx #$30.b		; E0 30 ; Compare #$30.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $00C0.w		; 20 C0 00 ; Jump to subroutine at $00C0.w [Writes: Stack Pointer] [Flow: call]
	ora ($02.b,S),Y		; 13 02 ; OR accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $2A0E0E.l,X		; 1F 0E 0E 2A ; Logical OR long $2A0E0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E11.w,X		; 1D 11 0E ; OR accumulator with memory $0E11.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$F3.b],Y		; 17 F3 ; OR accumulator with memory (long indexed) [$F3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sty $3FC0.w		; 8C C0 3F ; Store Y register to $3FC0.w [Reads: Y Index]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	bit $FF.b,X		; 34 FF ; Test bits $FF.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $00FB08.l,X		; FF 08 FB 00 ; Subtract with carry (long,X) $00FB08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	sbc ($C0.b,S),Y		; F3 C0 ; Subtract with carry (stack relative indirect indexed) ($C0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $CB		; 70 CB ; Branch if overflow set to $70, $CB [Flow: branch]
	sbc [$F7.b]		; E7 F7 ; Subtract with carry (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $70, $FF		; 70 FF ; Branch if overflow set to $70, $FF [Flow: branch]
	cpx #$4F.b		; E0 4F ; Compare #$4F.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc ($01.b,S),Y		; 73 01 ; Add with carry (stack relative indirect indexed) ($01.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $0CFE00.l,X		; 7F 00 FE 0C ; Add long $0CFE00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $6D9F45.l,X		; BF 45 9F 6D ; Load long $6D9F45.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $21001E.l,X		; 7F 1E 00 21 ; Add long $21001E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($5E.b)		; 52 5E ; Exclusive OR accumulator with memory (indirect) ($5E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $7FFECE.l,X		; 9F CE FE 7F ; Store accumulator (long,X) $7FFECE.l,X [Reads: Accumulator, X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	dec $FE80.w		; CE 80 FE ; Decrement $FE80.w [Flags: ZN]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $DD		; 30 DD ; Branch if minus to $30, $DD [Flow: branch]
	ldx #$C9.b		; A2 C9 ; Load #$C9.b into X register [Writes: X Index] [Flags: ZN]
	ldx $C6.b,Y		; B6 C6 ; Load X register $C6.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sbc $7F73.w,Y		; F9 73 7F ; Subtract with carry $7F73.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $3700.w		; 1C 00 37 ; Test and reset bits $3700.w [Reads: Accumulator] [Flags: Z]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $1E6327.l,X		; 7F 27 63 1E ; Add long $1E6327.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $3C.b,S		; 43 3C ; Exclusive OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	eor [$5F.b]		; 47 5F ; Exclusive OR accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $00007E.l,X		; 7F 7E 00 00 ; Add long $00007E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $A0		; F0 A0 ; Branch if equal to $F0, $A0 [Flow: branch]
	eor $F8.b,S		; 43 F8 ; Exclusive OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $0B		; 10 0B ; Branch if plus to $10, $0B [Flow: branch]
	jsr ($BC18.w,X)		; FC 18 BC ; Jump to subroutine indirect indexed ($BC18.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$50.b		; E0 50 ; Compare #$50.b with X register [Reads: X Index] [Flags: ZNC]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	bit $74.b		; 24 74 ; Test bits $74.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $00.b,X		; 76 00 ; Rotate right $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	lda $6C9244.l,X		; BF 44 92 6C ; Load long $6C9244.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda ($5D.b,S),Y		; B3 5D ; Load accumulator (stack relative indirect indexed) ($5D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$2D.b],Y		; 77 2D ; Add with carry (long indexed) [$2D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($57.b)		; 52 57 ; Exclusive OR accumulator with memory (indirect) ($57.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $FEFF.w		; CE FF FE ; Decrement $FEFF.w [Flags: ZN]
	ror $1885.w,X		; 7E 85 18 ; Rotate right $1885.w,X [Reads: X Index] [Flags: ZNC]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FD00.w		; 6E 00 FD ; Rotate right $FD00.w [Flags: ZNC]
	jsl $DD3649.l		; 22 49 36 DD ; Jump to subroutine long $DD3649.l [Writes: Stack Pointer] [Flow: call]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	dec $00B4.w		; CE B4 00 ; Decrement $00B4.w [Flags: ZN]
	sty $4A.b		; 84 4A ; Store Y register to $4A.b [Reads: Y Index]
	nop		; EA ; No operation
	adc ($FF.b,S),Y		; 73 FF ; Add with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $007E7E.l		; 6F 7E 7E 00 ; Add with carry (long) $007E7E.l [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF4442.l,X		; FF 42 44 FF ; Subtract with carry (long,X) $FF4442.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta ($07.b,X)		; 81 07 ; Store accumulator ($07.b,X) [Reads: Accumulator, X Index, Direct Page]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ror $81FF.w,X		; 7E FF 81 ; Rotate right $81FF.w,X [Reads: X Index] [Flags: ZNC]
	ror $7EDB.w,X		; 7E DB 7E ; Rotate right $7EDB.w,X [Reads: X Index] [Flags: ZNC]
	rol $FF.b		; 26 FF ; Rotate left $FF.b [Reads: Direct Page] [Flags: ZNC]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $0F88.w		; EC 88 0F ; Compare $0F88.w with X register [Reads: X Index] [Flags: ZNC]
	jsr ($B818.w,X)		; FC 18 B8 ; Jump to subroutine indirect indexed ($B818.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $50, $F0		; 50 F0 ; Branch if overflow clear to $50, $F0 [Flow: branch]
	jsr $8060.w		; 20 60 80 ; Jump to subroutine at $8060.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($F4F4.w,X)		; FC F4 F4 ; Jump to subroutine indirect indexed ($F4F4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldy $E8.b		; A4 E8 ; Load $E8.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$60.b]		; 07 60 ; OR accumulator with memory (long) [$60.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($B7.b,X)		; 01 B7 ; Logical OR ($B7.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora #$F3.b		; 09 F3 ; Logical OR #$F3.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $0023.w,X		; 1D 23 00 ; OR accumulator with memory $0023.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $61.b,S		; 03 61 ; OR accumulator with stack relative $61.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	inc $29FE.w,X		; FE FE 29 ; Increment memory $29FE.w,X [Reads: X Index] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($23D8.w,X)		; FC D8 23 ; Jump to subroutine indirect indexed ($23D8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsr ($383C.w,X)		; FC 3C 38 ; Jump to subroutine indirect indexed ($383C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0F20.w		; 6E 20 0F ; Rotate right $0F20.w [Flags: ZNC]
	adc $1B3C38.l,X		; 7F 38 3C 1B ; Add long $1B3C38.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $010F08.l,X		; 1F 08 0F 01 ; Logical OR long $010F08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($5A5E.w,X)		; 7C 5E 5A ; Jump indirect indexed to ($5A5E.w,X) [Reads: X Index] [Flow: jump]
	eor $27.b		; 45 27 ; Exclusive OR $27.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$7E.b]		; 07 7E ; OR accumulator with memory (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FFFF.w,X		; 7E FF FF ; Rotate right $FFFF.w,X [Reads: X Index] [Flags: ZNC]
	bit $23FF.w,X		; 3C FF 23 ; Test bits $23FF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FF22.w,X		; 7E 22 FF ; Rotate right $FF22.w,X [Reads: X Index] [Flags: ZNC]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$11.b],Y		; 37 11 ; AND accumulator with memory (long indexed) [$11.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $183F.w		; 0D 3F 18 ; Logical OR $183F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $1F0A.w,X		; 3D 0A 1F ; AND accumulator with memory $1F0A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	trb $2F3F.w		; 1C 3F 2F ; Test and reset bits $2F3F.w [Reads: Accumulator] [Flags: Z]
	and $1B3725.l		; 2F 25 37 1B ; AND accumulator with memory (long) $1B3725.l [Writes: Accumulator] [Flags: ZN]
	sty $0E.b		; 84 0E ; Store Y register to $0E.b [Reads: Y Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $42, $44		; 42 44 ; Reserved instruction
	sbc $998481.l,X		; FF 81 84 99 ; Subtract with carry (long,X) $998481.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $E0.b,S		; 83 E0 ; Store accumulator (stack relative) $E0.b,S [Reads: Accumulator, Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	eor $EC.b,S		; 43 EC ; Exclusive OR accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sta $B0.b		; 85 B0 ; Store accumulator to $B0.b [Reads: Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: ZN]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3B7FBF.l,X		; DF BF 7F 3B ; Compare accumulator (long,X) $3B7FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ora $7E2F7C.l,X		; 1F 7C 2F 7E ; Logical OR long $7E2F7C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($7F.b,X)		; 21 7F ; Logical AND ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr $1837.w		; 20 37 18 ; Jump to subroutine at $1837.w [Writes: Stack Pointer] [Flow: call]
	and $1F1E.w,Y		; 39 1E 1F ; AND accumulator with memory $1F1E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3F147F.l		; 22 7F 14 3F ; Jump to subroutine long $3F147F.l [Writes: Stack Pointer] [Flow: call]
	and $94061F.l,X		; 3F 1F 06 94 ; AND accumulator with memory (long,X) $94061F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	asl $7EF4.w		; 0E F4 7E ; Arithmetic shift left $7EF4.w [Flags: ZNC]
	sty $FA.b		; 84 FA ; Store Y register to $FA.b [Reads: Y Index]
	tsb $E4.b		; 04 E4 ; Test and set bits $E4.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $F878.w		; 9C 78 F8 ; Store zero to $F878.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FC14FE.l		; 22 FE 14 FC ; Jump to subroutine long $FC14FE.l [Writes: Stack Pointer] [Flow: call]
	jsr ($60F8.w,X)		; FC F8 60 ; Jump to subroutine indirect indexed ($60F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor ($2D.b)		; 52 2D ; Exclusive OR accumulator with memory (indirect) ($2D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $1E.b,S		; 63 1E ; Add with carry (stack relative) $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc $7C03.w,X		; 7D 03 7C ; Add $7C03.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $58.b,S		; 03 58 ; OR accumulator with stack relative $58.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and [$67.b]		; 27 67 ; AND accumulator with memory (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $0F0F3F.l,X		; 3F 3F 0F 0F ; AND accumulator with memory (long,X) $0F0F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7F.b		; 24 7F ; Test bits $7F.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $0F3F.w,X		; 1D 3F 0F ; OR accumulator with memory $0F3F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $FFA8.w,X		; 7E A8 FF ; Rotate right $FFA8.w,X [Reads: X Index] [Flags: ZNC]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	lda $F07EEE.l,X		; BF EE 7E F0 ; Load long $F07EEE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F1.b,X		; F5 F1 ; Subtract $F1.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	inc $F0F8.w,X		; FE F8 F0 ; Increment memory $F0F8.w,X [Reads: X Index] [Flags: ZN]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	adc $3D6725.l,X		; 7F 25 67 3D ; Add long $3D6725.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $7F.b,S		; 43 7F ; Exclusive OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b,S),Y		; 13 3F ; OR accumulator (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $1E3F.w,X		; 1D 3F 1E ; OR accumulator with memory $1E3F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000707.l,X		; 1F 07 07 00 ; Logical OR long $000707.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $7C7E.w,X		; 7E 7E 7C ; Rotate right $7C7E.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($3F3E.w,X)		; 7C 3E 3F ; Jump indirect indexed to ($3F3E.w,X) [Reads: X Index] [Flow: jump]
	ora $A4FE07.l,X		; 1F 07 FE A4 ; Logical OR long $A4FE07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $BC.b		; E6 BC ; Increment $BC.b [Reads: Direct Page] [Flags: ZN]
	eor $F6.b,S		; 43 F6 ; Exclusive OR accumulator with stack relative $F6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp.w [$DC1F]		; DC 1F DC ; Jump long indirect [$DC1F] [Flow: jump]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jsr ($F878.w,X)		; FC 78 F8 ; Jump to subroutine indirect indexed ($F878.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $3E3E.w,X		; 7E 3E 3E ; Rotate right $3E3E.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($F8FC.w,X)		; 7C FC F8 ; Jump indirect indexed to ($F8FC.w,X) [Reads: X Index] [Flow: jump]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc $18E7E7.l,X		; FF E7 E7 18 ; Subtract with carry (long,X) $18E7E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $BD.b,S		; C3 BD ; Compare accumulator (stack relative) $BD.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc [$3C.b]		; E7 3C ; Subtract with carry (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C99.w,X		; 7E 99 3C ; Rotate right $3C99.w,X [Reads: X Index] [Flags: ZNC]
	cmp $E7.b,S		; C3 E7 ; Compare accumulator (stack relative) $E7.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3C7E0F.l,X		; FF 0F 7E 3C ; Subtract with carry (long,X) $3C7E0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$E0.b]		; E7 E0 ; Subtract with carry (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $C0C0.w		; 20 C0 C0 ; Jump to subroutine at $C0C0.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $E02200.l		; 22 00 22 E0 ; Jump to subroutine long $E02200.l [Writes: Stack Pointer] [Flow: call]
	trb $C0.b		; 14 C0 ; Test and reset bits $C0.b [Reads: Accumulator] [Flags: Z]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	adc $275D1E.l,X		; 7F 1E 5D 27 ; Add long $275D1E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $317E38.l		; 4F 38 7E 31 ; Exclusive OR accumulator with memory (long) $317E38.l [Writes: Accumulator] [Flags: ZN]
	and $0B03.w,X		; 3D 03 0B ; AND accumulator with memory $0B03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: ZNC]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0B3F14.l,X		; 7F 14 3F 0B ; Add long $0B3F14.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jsr ($FA88.w,X)		; FC 88 FA ; Jump to subroutine indirect indexed ($FA88.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stz $E6.b		; 64 E6 ; Store zero to $E6.b
	trb $A47E.w		; 1C 7E A4 ; Test and reset bits $A47E.w [Reads: Accumulator] [Flags: Z]
	jsr ($F0C0.w,X)		; FC C0 F0 ; Jump to subroutine indirect indexed ($F0C0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	jmp ($FE22.w,X)		; 7C 22 FE ; Jump indirect indexed to ($FE22.w,X) [Reads: X Index] [Flow: jump]
	.db $10, $FC		; 10 FC ; Branch if plus to $10, $FC [Flow: branch]
	.db $F0, $B0		; F0 B0 ; Branch if equal to $F0, $B0 [Flow: branch]
	cpx #$07.b		; E0 07 ; Compare #$07.b with X register [Reads: X Index] [Flags: ZNC]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $070700.l		; 22 00 07 07 ; Jump to subroutine long $070700.l [Writes: Stack Pointer] [Flow: call]
	ora $07070F.l		; 0F 0F 07 07 ; OR accumulator with memory (long) $07070F.l [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Accumulator, Direct Page, Y Index]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $817E.w,X		; 3C 7E 81 ; Test bits $817E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $1C833C.l,X		; FF 3C 83 1C ; Subtract with carry (long,X) $1C833C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E73C02.l,X		; FF 02 3C E7 ; Subtract with carry (long,X) $E73C02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: ZNC]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora $7E.b,S		; 03 7E ; OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stx $10.b		; 86 10 ; Store X register to $10.b [Reads: X Index]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $BC67.w,X		; 3D 67 BC ; AND accumulator with memory $BC67.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $00FC58.l,X		; BF 58 FC 00 ; Load long $00FC58.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda $4360FC.l,X		; BF FC 60 43 ; Load long $4360FC.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	stx $2B.b		; 86 2B ; Store X register to $2B.b [Reads: X Index]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sta [$68.b],Y		; 97 68 ; Store accumulator (long indexed) [$68.b],Y [Reads: Accumulator, Direct Page, Y Index]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $4E003C.l		; 2F 3C 00 4E ; AND accumulator with memory (long) $4E003C.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda $207330.l,X		; BF 30 73 20 ; Load long $207330.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $9F1C.w,X		; 3D 1C 9F ; AND accumulator with memory $9F1C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $E7.b		; 05 E7 ; Logical OR $E7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($FB.b,X)		; 41 FB ; Exclusive OR accumulator with memory ($FB.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $3C		; B0 3C ; Branch if carry set to $B0, $3C [Flow: branch]
	ror $CF.b,X		; 76 CF ; Rotate right $CF.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $BEFA23.l,X		; 5F 23 FA BE ; Exclusive OR accumulator with memory (long,X) $BEFA23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $640018.l		; 4F 18 00 64 ; Exclusive OR accumulator with memory (long) $640018.l [Writes: Accumulator] [Flags: ZN]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	dec $2700.w,X		; DE 00 27 ; Decrement memory $2700.w,X [Reads: X Index] [Flags: ZN]
	cop $9A.b		; 02 9A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	stz $9C84.w,X		; 9E 84 9C ; Store zero to $9C84.w,X [Reads: X Index]
	.db $80, $18		; 80 18 ; Branch always to $80, $18 [Flow: branch]
	jmp ($FEE6.w,X)		; 7C E6 FE ; Jump indirect indexed to ($FEE6.w,X) [Reads: X Index] [Flow: jump]
	sbc $7A76.w,X		; FD 76 7A ; Subtract with carry $7A76.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($0027.w,X)		; 7C 27 00 ; Jump indirect indexed to ($0027.w,X) [Reads: X Index] [Flow: jump]
	sta [$C8.b]		; 87 C8 ; Store accumulator (long) [$C8.b] [Reads: Accumulator, Direct Page]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($00.b)		; D4 00 ; Push effective indirect address ($00.b) [Reads: Direct Page] [Writes: Stack Pointer]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sta $E2.b		; 85 E2 ; Store accumulator to $E2.b [Reads: Accumulator]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $1300.w		; EC 00 13 ; Compare $1300.w with X register [Reads: X Index] [Flags: ZNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $031F03.l		; 0F 03 1F 03 ; OR accumulator with memory (long) $031F03.l [Writes: Accumulator] [Flags: ZN]
	rol $FE0F.w,X		; 3E 0F FE ; Rotate left $FE0F.w,X [Reads: X Index] [Flags: ZNC]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc [$BF.b]		; 67 BF ; Add with carry (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	stz $FF.b		; 64 FF ; Store zero to $FF.b
	and ($03.b,S),Y		; 33 03 ; AND accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $223F1F.l		; 0F 1F 3F 22 ; OR accumulator with memory (long) $223F1F.l [Writes: Accumulator] [Flags: ZN]
	sbc $C0BF18.l,X		; FF 18 BF C0 ; Subtract with carry (long,X) $C0BF18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$38.b		; C0 38 ; Compare #$38.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $5C		; F0 5C ; Branch if equal to $F0, $5C [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	eor $F6DFB8.l		; 4F B8 DF F6 ; Exclusive OR accumulator with memory (long) $F6DFB8.l [Writes: Accumulator] [Flags: ZN]
	sbc $BF36.w,Y		; F9 36 BF ; Subtract with carry $BF36.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldy $FFBF.w,X		; BC BF FF ; Load Y register $FFBF.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sbc $0023F9.l,X		; FF F9 23 00 ; Subtract with carry (long,X) $0023F9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $730001.l		; 0F 01 00 73 ; OR accumulator with memory (long) $730001.l [Writes: Accumulator] [Flags: ZN]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $FE.b,S		; 63 FE ; Add with carry (stack relative) $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $FD6F.w,X		; 9D 6F FD ; Store accumulator to $FD6F.w,X [Reads: Accumulator, X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($73.b,X)		; 01 73 ; Logical OR ($73.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $9B00FF.l		; 22 FF 00 9B ; Jump to subroutine long $9B00FF.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($E0.b,S),Y		; 13 E0 ; OR accumulator (stack relative indirect indexed) ($E0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$5C.b		; E0 5C ; Compare #$5C.b with X register [Reads: X Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	inc $C61C.w		; EE 1C C6 ; Increment $C61C.w [Flags: ZN]
	ldy $FEF7.w,X		; BC F7 FE ; Load Y register $FEF7.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	ldy $BE1E.w,X		; BC 1E BE ; Load Y register $BE1E.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sbc $036083.l,X		; FF 83 60 03 ; Subtract with carry (long,X) $036083.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0F1E.w		; 0E 1E 0F ; Arithmetic shift left $0F1E.w [Flags: ZNC]
	and $133F1C.l,X		; 3F 1C 3F 13 ; AND accumulator with memory (long,X) $133F1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $03FF10.l,X		; 3F 10 FF 03 ; AND accumulator with memory (long,X) $03FF10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $0347.w,X		; FE 47 03 ; Increment memory $0347.w,X [Reads: X Index] [Flags: ZN]
	ora $3F221F.l		; 0F 1F 22 3F ; OR accumulator with memory (long) $3F221F.l [Writes: Accumulator] [Flags: ZN]
	trb $FF.b		; 14 FF ; Test and reset bits $FF.b [Reads: Accumulator] [Flags: Z]
	sbc $F000C0.l,X		; FF C0 00 F0 ; Subtract with carry (long,X) $F000C0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $38		; 80 38 ; Branch always to $80, $38 [Flow: branch]
	.db $D0, $CC		; D0 CC ; Branch if not equal to $D0, $CC [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	pea $FCC8.w		; F4 C8 FC ; Push absolute address $FCC8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda $F27DE0.l,X		; BF E0 7D F2 ; Load long $F27DE0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$B0.b		; C0 B0 ; Compare #$B0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jsl $FF01FC.l		; 22 FC 01 FF ; Jump to subroutine long $FF01FC.l [Writes: Stack Pointer] [Flow: call]
	sbc $130023.l,X		; FF 23 00 13 ; Subtract with carry (long,X) $130023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $0A1D14.l,X		; 3F 14 1D 0A ; AND accumulator with memory (long,X) $0A1D14.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00000B.l,X		; 1F 0B 00 00 ; Logical OR long $00000B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($5B.b,X)		; 21 5B ; Logical AND ($5B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $1F1E3F.l		; 2F 3F 1E 1F ; AND accumulator with memory (long) $1F1E3F.l [Writes: Accumulator] [Flags: ZN]
	sta $48.b,S		; 83 48 ; Store accumulator (stack relative) $48.b,S [Reads: Accumulator, Stack Pointer]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $BC		; D0 BC ; Branch if not equal to $D0, $BC [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jsr ($D850.w,X)		; FC 50 D8 ; Jump to subroutine indirect indexed ($D850.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	pea $DCFC.w		; F4 FC DC ; Push absolute address $DCFC.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $E0.b,S		; 83 E0 ; Store accumulator (stack relative) $E0.b,S [Reads: Accumulator, Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $6C,$00		; 44 00 6C ; Move block positive $6C,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sbc $00.b,X		; F5 00 ; Subtract $00.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($835C.w,X)		; 7C 5C 83 ; Jump indirect indexed to ($835C.w,X) [Reads: X Index] [Flow: jump]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $7E.b		; 05 7E ; Logical OR $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FFFF.w,X		; 7E FF FF ; Rotate right $FFFF.w,X [Reads: X Index] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sty $45.b		; 84 45 ; Store Y register to $45.b [Reads: Y Index]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	bit $1C.b,X		; 34 1C ; Test bits $1C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $76.b		; 04 76 ; Test and set bits $76.b [Reads: Accumulator] [Flags: Z]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	trb $58BC.w		; 1C BC 58 ; Test and reset bits $58BC.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	trb $3A3E.w		; 1C 3E 3A ; Test and reset bits $3A3E.w [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ldx #$E4.b		; A2 E4 ; Load #$E4.b into X register [Writes: X Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $304C.w		; 20 4C 30 ; Jump to subroutine at $304C.w [Writes: Stack Pointer] [Flow: call]
	jmp ($6420.w,X)		; 7C 20 64 ; Jump indirect indexed to ($6420.w,X) [Reads: X Index] [Flow: jump]
	jsr $3074.w		; 20 74 30 ; Jump to subroutine at $3074.w [Writes: Stack Pointer] [Flow: call]
	trb $0818.w		; 1C 18 08 ; Test and reset bits $0818.w [Reads: Accumulator] [Flags: Z]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $74.b		; 64 74 ; Store zero to $74.b
	jmp $044C5C.l		; 5C 5C 4C 04 ; Jump long to $044C5C.l [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $1D0C.w,X		; 3D 0C 1D ; AND accumulator with memory $1D0C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $000A.w		; 0C 0A 00 ; Test and set bits $000A.w [Reads: Accumulator] [Flags: Z]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($13.b,S),Y		; 33 13 ; AND accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $2304.w		; 0E 04 23 ; Arithmetic shift left $2304.w [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $90.b,X		; B4 90 ; Load Y register $90.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jsr $2A70.w		; 20 70 2A ; Jump to subroutine at $2A70.w [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($70D8.w)		; 6C D8 70 ; Jump indirect to ($70D8.w) [Flow: jump]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $7F.b		; 02 7F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $845C.w,X		; 1E 5C 84 ; Arithmetic shift left $845C.w,X [Reads: X Index] [Flags: ZNC]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $35.b		; 04 35 ; Test and set bits $35.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $220101.l,X		; 1F 01 01 22 ; Logical OR long $220101.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $1F3703.l,X		; 7F 03 37 1F ; Add long $1F3703.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit #$58.b		; 89 58 ; Test bits #$58.b with accumulator [Reads: Accumulator] [Flags: Z]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $98.b		; E4 98 ; Compare $98.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sty $F870.w		; 8C 70 F8 ; Store Y register to $F870.w [Reads: Y Index]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FC13FE.l		; 22 FE 13 FC ; Jump to subroutine long $FC13FE.l [Writes: Stack Pointer] [Flow: call]
	cpx $8C.b		; E4 8C ; Compare $8C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldx $F96F.w,Y		; BE 6F F9 ; Load X register $F96F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	lsr $58F7.w,X		; 5E F7 58 ; Logical shift right $58F7.w,X [Reads: X Index] [Flags: ZNC]
	adc $183718.l,X		; 7F 18 37 18 ; Add long $183718.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0F0E.w,Y		; 19 0E 0F ; OR accumulator with memory $0F0E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7F2CE0.l,X		; FF E0 2C 7F ; Subtract with carry (long,X) $7F2CE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $030F1F.l,X		; 3F 1F 0F 03 ; AND accumulator with memory (long,X) $030F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $9FB6.w,Y		; 59 B6 9F ; Exclusive OR accumulator with memory $9FB6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sbc $18EE1A.l		; EF 1A EE 18 ; Subtract with carry (long) $18EE1A.l [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F818.w,X)		; FC 18 F8 ; Jump to subroutine indirect indexed ($F818.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FCFEFF.l,X		; FF FF FE FC ; Subtract with carry (long,X) $FCFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	sta $BB6F.w,Y		; 99 6F BB ; Store accumulator to $BB6F.w,Y [Reads: Accumulator, Y Index]
	ror $65BE.w		; 6E BE 65 ; Rotate right $65BE.w [Flags: ZNC]
	lda $00FF6A.l,X		; BF 6A FF 00 ; Load long $00FF6A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($00.b,S),Y		; 73 00 ; Add with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $010373.l,X		; 1F 73 03 01 ; Logical OR long $010373.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $EC3F1E.l,X		; FF 1E 3F EC ; Subtract with carry (long,X) $EC3F1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FE10.w,X		; FE 10 FE ; Increment memory $FE10.w,X [Reads: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($3800.w,X)		; FC 00 38 ; Jump to subroutine indirect indexed ($3800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sbc $FEFEFF.l,X		; FF FF FE FE ; Subtract with carry (long,X) $FEFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy $F8F8.w,X		; BC F8 F8 ; Load Y register $F8F8.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $BE		; F0 BE ; Branch if equal to $F0, $BE [Flow: branch]
	adc [$BD.b]		; 67 BD ; Add with carry (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $4F43FD.l		; 4F FD 43 4F ; Exclusive OR accumulator with memory (long) $4F43FD.l [Writes: Accumulator] [Flags: ZN]
	sbc $7F4706.l,X		; FF 06 47 7F ; Subtract with carry (long,X) $7F4706.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0F7F0E.l,X		; FF 0E 7F 0F ; Subtract with carry (long,X) $0F7F0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	pei ($7D.b)		; D4 7D ; Push effective indirect address ($7D.b) [Reads: Direct Page] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $DFFA.w,X		; 9D FA DF ; Store accumulator to $DFFA.w,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	lda $F0FEF2.l,X		; BF F2 FE F0 ; Load long $F0FEF2.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $04.b,S		; 83 04 ; Store accumulator (stack relative) $04.b,S [Reads: Accumulator, Stack Pointer]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $228F.w,X		; DD 8F 22 ; Compare accumulator $228F.w,X [Reads: X Index] [Flags: ZNC]
	sbc $F0FE0D.l,X		; FF 0D FE F0 ; Subtract with carry (long,X) $F0FE0D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$1F.b		; C0 1F ; Compare #$1F.b with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora [$2F.b]		; 07 2F ; OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $182F.w,Y		; 19 2F 18 ; OR accumulator with memory $182F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($21.b,X)		; 01 21 ; Logical OR ($21.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora $5B3F3F.l,X		; 1F 3F 3F 5B ; Logical OR long $5B3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $72		; D0 72 ; Branch if not equal to $D0, $72 [Flow: branch]
	jmp.w [$C0FC]		; DC FC C0 ; Jump long indirect [$C0FC] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $E8		; 10 E8 ; Branch if plus to $10, $E8 [Flow: branch]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $FC0900.l		; 22 00 09 FC ; Jump to subroutine long $FC0900.l [Writes: Stack Pointer] [Flow: call]
	inc $F8FC.w,X		; FE FC F8 ; Increment memory $F8FC.w,X [Reads: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $0008.w,X		; 3C 08 00 ; Test bits $0008.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $708701.l		; 0F 01 87 70 ; OR accumulator with memory (long) $708701.l [Writes: Accumulator] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $028083.l		; 0F 83 80 02 ; OR accumulator with memory (long) $028083.l [Writes: Accumulator] [Flags: ZN]
	ora ($03.b)		; 12 03 ; OR accumulator with memory (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $83FF.w,X		; 3C FF 83 ; Test bits $83FF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $FFFCC7.l,X		; FF C7 FC FF ; Subtract with carry (long,X) $FFFCC7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $C6.b		; 84 C6 ; Store Y register to $C6.b [Reads: Y Index]
	lda $1AFD.w,X		; BD FD 1A ; Load $1AFD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $FF2400.l,X		; 3F 00 24 FF ; AND accumulator with memory (long,X) $FF2400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$27.b		; E0 27 ; Compare #$27.b with X register [Reads: X Index] [Flags: ZNC]
	inc $3FFD.w,X		; FE FD 3F ; Increment memory $3FFD.w,X [Reads: X Index] [Flags: ZN]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	.db $50, $A0		; 50 A0 ; Branch if overflow clear to $50, $A0 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $E0C0.w		; 20 C0 E0 ; Jump to subroutine at $E0C0.w [Writes: Stack Pointer] [Flow: call]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	jsr $C0E0.w		; 20 E0 C0 ; Jump to subroutine at $C0E0.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $7E.b		; 24 7E ; Test bits $7E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: ZNC]
	bit $7E7E.w,X		; 3C 7E 7E ; Test bits $7E7E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $0018.w,X		; 3C 18 00 ; Test bits $0018.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $7FFE17.l,X		; FF 17 FE 7F ; Subtract with carry (long,X) $7FFE17.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FBBF.w,X		; FD BF FB ; Subtract with carry $FBBF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $977FBF.l,X		; DF BF 7F 97 ; Compare accumulator (long,X) $977FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $2F		; F0 2F ; Branch if equal to $F0, $2F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $2F		; F0 2F ; Branch if equal to $F0, $2F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $07,$00		; 44 00 07 ; Move block positive $07,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $106C.w		; 20 6C 10 ; Jump to subroutine at $106C.w [Writes: Stack Pointer] [Flow: call]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $23.b,X		; 34 23 ; Test bits $23.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7C70.w		; 20 70 7C ; Jump to subroutine at $7C70.w [Writes: Stack Pointer] [Flow: call]
	adc [$27.b],Y		; 77 27 ; Add with carry (long indexed) [$27.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $36.b		; 04 36 ; Test and set bits $36.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec $232C.w,X		; DE 2C 23 ; Decrement memory $232C.w,X [Reads: X Index] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	rol $23EE.w,X		; 3E EE 23 ; Rotate left $23EE.w,X [Reads: X Index] [Flags: ZNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0D1F01.l		; 0F 01 1F 0D ; OR accumulator with memory (long) $0D1F01.l [Writes: Accumulator] [Flags: ZN]
	eor $33.b,S		; 43 33 ; Exclusive OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $3706.w,X		; 1E 06 37 ; Arithmetic shift left $3706.w,X [Reads: X Index] [Flags: ZNC]
	asl $0000.w,X		; 1E 00 00 ; Arithmetic shift left $0000.w,X [Reads: X Index] [Flags: ZNC]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $3F22.w,X		; 1E 22 3F ; Arithmetic shift left $3F22.w,X [Reads: X Index] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $F8.b		; 14 F8 ; Test and reset bits $F8.b [Reads: Accumulator] [Flags: Z]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $7E		; D0 7E ; Branch if not equal to $D0, $7E [Flow: branch]
	mvp $02,$3B		; 44 3B 02 ; Move block positive $02,$3B [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	lda $A580.w,X		; BD 80 A5 ; Load $A580.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $BA.b,X		; 34 BA ; Test bits $BA.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sbc $7F67.w,X		; FD 67 7F ; Subtract with carry $7F67.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($45.b,X)		; 01 45 ; Logical OR ($45.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$4F.b		; E0 4F ; Compare #$4F.b with X register [Reads: X Index] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $040C.w		; 0D 0C 04 ; Logical OR $040C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BA.b		; 00 BA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec $AE2C.w,X		; DE 2C AE ; Decrement memory $AE2C.w,X [Reads: X Index] [Flags: ZN]
	.db $70, $5F		; 70 5F ; Branch if overflow set to $70, $5F [Flow: branch]
	.db $F0, $9B		; F0 9B ; Branch if equal to $F0, $9B [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	pea $76FE.w		; F4 FE 76 ; Push absolute address $76FE.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	adc ($FE.b)		; 72 FE ; Add with carry (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $3E07.w		; 0E 07 3E ; Arithmetic shift left $3E07.w [Flags: ZNC]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $7F.b		; 04 7F ; Test and set bits $7F.b [Reads: Accumulator] [Flags: Z]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $4B4F3F.l		; 0F 3F 4F 4B ; OR accumulator with memory (long) $4B4F3F.l [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	bit $FEE0.w,X		; 3C E0 FE ; Test bits $FEE0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpy #$FE.b		; C0 FE ; Compare #$FE.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $C0DE.w		; 20 DE C0 ; Jump to subroutine at $C0DE.w [Writes: Stack Pointer] [Flow: call]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($D2F2.w,X)		; FC F2 D2 ; Jump to subroutine indirect indexed ($D2F2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $8F		; F0 8F ; Branch if equal to $F0, $8F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0D.b,S		; 43 0D ; Exclusive OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: ZNC]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $070F0F.l		; 0F 0F 0F 07 ; OR accumulator with memory (long) $070F0F.l [Writes: Accumulator] [Flags: ZN]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	pea $FCF8.w		; F4 F8 FC ; Push absolute address $FCF8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	mvp $38,$7C		; 44 7C 38 ; Move block positive $38,$7C [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	jsl $FC2300.l		; 22 00 23 FC ; Jump to subroutine long $FC2300.l [Writes: Stack Pointer] [Flow: call]
	jsl $3DE07C.l		; 22 7C E0 3D ; Jump to subroutine long $3DE07C.l [Writes: Stack Pointer] [Flow: call]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $BF.b,S		; 63 BF ; Add with carry (stack relative) $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	inc $9F09.w,X		; FE 09 9F ; Increment memory $9F09.w,X [Reads: X Index] [Flags: ZN]
	tsb $6EFD.w		; 0C FD 6E ; Test and set bits $6EFD.w [Reads: Accumulator] [Flags: Z]
	adc $130E.w,X		; 7D 0E 13 ; Add $130E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $000E.w		; 0E 0E 00 ; Arithmetic shift left $000E.w [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($FEFC.w,X)		; FC FC FE ; Jump to subroutine indirect indexed ($FEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $0E1F7F.l,X		; 9F 7F 1F 0E ; Store accumulator (long,X) $0E1F7F.l,X [Reads: Accumulator, X Index]
	and $FDC6.w,X		; 3D C6 FD ; AND accumulator with memory $FDC6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $7F.b,X		; 16 7F ; Arithmetic shift left $7F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sta ($F3.b)		; 92 F3 ; Store accumulator (indirect) ($F3.b) [Reads: Accumulator, Direct Page]
	jsr $6CBE.w		; 20 BE 6C ; Jump to subroutine at $6CBE.w [Writes: Stack Pointer] [Flow: call]
	lda $7CCE72.l,X		; BF 72 CE 7C ; Load long $7CCE72.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($DF00.w,X)		; 7C 00 DF ; Jump indirect indexed to ($DF00.w,X) [Reads: X Index] [Flow: jump]
	and $F27F3F.l,X		; 3F 3F 7F F2 ; AND accumulator with memory (long,X) $F27F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $377CFE.l,X		; FF FE 7C 37 ; Subtract with carry (long,X) $377CFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $1E3F.w,X		; 1E 3F 1E ; Arithmetic shift left $1E3F.w,X [Reads: X Index] [Flags: ZNC]
	ora $010E0C.l,X		; 1F 0C 0E 01 ; Logical OR long $010E0C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $3F		; 42 3F ; Reserved instruction
	and $060F1F.l,X		; 3F 1F 0F 06 ; AND accumulator with memory (long,X) $060F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FE.b)		; 12 FE ; OR accumulator with memory (indirect) ($FE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $1CDE.w		; 0C DE 1C ; Test and set bits $1CDE.w [Reads: Accumulator] [Flags: Z]
	ldy $7030.w,X		; BC 30 70 ; Load Y register $7030.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $6222.w		; 6D 22 62 ; Add $6222.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	cpy $F0F0.w		; CC F0 F0 ; Compare $F0F0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $07		; 30 07 ; Branch if minus to $30, $07 [Flow: branch]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: ZNC]
	asl $1E33.w		; 0E 33 1E ; Arithmetic shift left $1E33.w [Flags: ZNC]
	and $0C2F02.l,X		; 3F 02 2F 0C ; AND accumulator with memory (long,X) $0C2F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $04.b		; 26 04 ; Rotate left $04.b [Reads: Direct Page] [Flags: ZNC]
	trb $0700.w		; 1C 00 07 ; Test and reset bits $0700.w [Reads: Accumulator] [Flags: Z]
	ora $3F3F1F.l		; 0F 1F 3F 3F ; OR accumulator with memory (long) $3F3F1F.l [Writes: Accumulator] [Flags: ZN]
	and ($3A.b,S),Y		; 33 3A ; AND accumulator (stack relative indirect indexed) ($3A.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $F0BB.w		; 1C BB F0 ; Test and reset bits $F0BB.w [Reads: Accumulator] [Flags: Z]
	sbc $ACFF6C.l,X		; FF 6C FF AC ; Subtract with carry (long,X) $ACFF6C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FC60.w,X		; FE 60 FC ; Increment memory $FC60.w,X [Reads: X Index] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$37.b		; E0 37 ; Compare #$37.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $FEF3F3.l,X		; FF F3 F3 FE ; Subtract with carry (long,X) $FEF3F3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($00F0.w,X)		; FC F0 00 ; Jump to subroutine indirect indexed ($00F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $41DF.w		; 0E DF 41 ; Arithmetic shift left $41DF.w [Flags: ZNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	stz $77.b		; 64 77 ; Store zero to $77.b
	ora #$3E.b		; 09 3E ; Logical OR #$3E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	tsb $030F.w		; 0C 0F 03 ; Test and set bits $030F.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc ($BE.b),Y		; F1 BE ; Subtract with carry ($BE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta [$7A.b],Y		; 97 7A ; Store accumulator (long indexed) [$7A.b],Y [Reads: Accumulator, Direct Page, Y Index]
	and $030C13.l		; 2F 13 0C 03 ; AND accumulator with memory (long) $030C13.l [Writes: Accumulator] [Flags: ZN]
	ora $FB10.w,X		; 1D 10 FB ; OR accumulator with memory $FB10.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $82, $EF, $16		; 82 EF 16 ; Branch always long to $82, $EF, $16 [Flow: branch]
	lsr $7C20.w,X		; 5E 20 7C ; Logical shift right $7C20.w,X [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $EED9.w,X		; 7D D9 EE ; Add $EED9.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pea $F0E8.w		; F4 E8 F0 ; Push absolute address $F0E8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpy #$87.b		; C0 87 ; Compare #$87.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $50, $01		; 50 01 ; Branch if overflow clear to $50, $01 [Flow: branch]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$2F.b]		; 07 2F ; OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($37.b,S),Y		; 13 37 ; OR accumulator (stack relative indirect indexed) ($37.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc ($0C.b,S),Y		; 73 0C ; Add with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $60.b,S		; 83 60 ; Store accumulator (stack relative) $60.b,S [Reads: Accumulator, Stack Pointer]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $4F2C3B.l,X		; 1F 3B 2C 4F ; Logical OR long $4F2C3B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta [$68.b]		; 87 68 ; Store accumulator (long) [$68.b] [Reads: Accumulator, Direct Page]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx #$F4.b		; E0 F4 ; Compare #$F4.b with X register [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cpx $CE10.w		; EC 10 CE ; Compare $CE10.w with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $83		; 30 83 ; Branch if minus to $30, $83 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp.w [$F234]		; DC 34 F2 ; Jump long indirect [$F234] [Flow: jump]
	sta $50.b,S		; 83 50 ; Store accumulator (stack relative) $50.b,S [Reads: Accumulator, Stack Pointer]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	tsb $0F07.w		; 0C 07 0F ; Test and set bits $0F07.w [Reads: Accumulator] [Flags: Z]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $14371C.l,X		; 3F 1C 37 14 ; AND accumulator with memory (long,X) $14371C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $60.b,S		; 83 60 ; Store accumulator (stack relative) $60.b,S [Reads: Accumulator, Stack Pointer]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $2A2317.l		; 0F 17 23 2A ; OR accumulator with memory (long) $2A2317.l [Writes: Accumulator] [Flags: ZN]
	sta $68.b,S		; 83 68 ; Store accumulator (stack relative) $68.b,S [Reads: Accumulator, Stack Pointer]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$78.b		; C0 78 ; Compare #$78.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$F4.b		; E0 F4 ; Compare #$F4.b with X register [Reads: X Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx $C6D0.w		; EC D0 C6 ; Compare $C6D0.w with X register [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	stx $0070.w		; 8E 70 00 ; Store X register to $0070.w [Reads: X Index]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FAF4.w,X)		; FC F4 FA ; Jump to subroutine indirect indexed ($FAF4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc ($27.b)		; 72 27 ; Add with carry (indirect) ($27.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	stz $23.b,X		; 74 23 ; Store zero to $23.b,X [Reads: X Index]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7C70.w		; 20 70 7C ; Jump to subroutine at $7C70.w [Writes: Stack Pointer] [Flow: call]
	sbc [$27.b],Y		; F7 27 ; Subtract with carry (long indexed) [$27.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	ora ($DD.b,X)		; 01 DD ; Logical OR ($DD.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rol $0023.w		; 2E 23 00 ; Rotate left $0023.w [Flags: ZNC]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $EF3E.w		; 0E 3E EF ; Arithmetic shift left $EF3E.w [Flags: ZNC]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $30.b		; 05 30 ; Logical OR $30.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $77		; 30 77 ; Branch if minus to $30, $77 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $30.b		; 02 30 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $070027.l,X		; 7F 27 00 07 ; Add long $070027.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $17.b		; 04 17 ; Test and set bits $17.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc $2310.w		; EE 10 23 ; Increment $2310.w [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	ora $002BFE.l,X		; 1F FE 2B 00 ; Logical OR long $002BFE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($38.b,X)		; 01 38 ; Logical OR ($38.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $050029.l,X		; 3F 29 00 05 ; AND accumulator with memory (long,X) $050029.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy $2430.w		; CC 30 24 ; Compare $2430.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $2BF4.w,X		; 3C F4 2B ; Test bits $2BF4.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $2503.w		; CC 03 25 ; Compare $2503.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	and $850029.l,X		; 3F 29 00 85 ; AND accumulator with memory (long,X) $850029.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sep #$03		; E2 03 ; Set processor status bits #$03 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($08.b)		; 12 08 ; OR accumulator with memory (indirect) ($08.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $0FF4.w,X		; 3C F4 0F ; Test bits $0FF4.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $671F30.l		; 0F 30 1F 67 ; OR accumulator with memory (long) $671F30.l [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	sta $609F70.l		; 8F 70 9F 60 ; Store accumulator (long) $609F70.l [Reads: Accumulator]
	sbc $7FFF00.l,X		; FF 00 FF 7F ; Subtract with carry (long,X) $7FFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $FD00FF.l		; 0F FF 00 FD ; OR accumulator with memory (long) $FD00FF.l [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$FA.b],Y		; F7 FA ; Subtract with carry (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$F9.b]		; 07 F9 ; OR accumulator with memory (long) [$F9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $FB.b		; 06 FB ; Arithmetic shift left $FB.b [Reads: Direct Page] [Flags: ZNC]
	ora $FA.b		; 05 FA ; Logical OR $FA.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $FB.b		; 05 FB ; Logical OR $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $24.b		; 05 24 ; Logical OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp [$38.b]		; C7 38 ; Compare accumulator (long) [$38.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: ZNC]
	cmp [$38.b]		; C7 38 ; Compare accumulator (long) [$38.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	eor $DF.b		; 45 DF ; Exclusive OR $DF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $FB.b,S		; 03 FB ; OR accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1EED.w,X		; 1D ED 1E ; OR accumulator with memory $1EED.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $032200.l		; 22 00 22 03 ; Jump to subroutine long $032200.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	brk $E9.b		; 00 E9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$34.b],Y		; 17 34 ; OR accumulator with memory (long indexed) [$34.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	wai		; CB ; Wait for interrupt
	sbc ($0D.b)		; F2 0D ; Subtract with carry (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($EE.b,S),Y		; F3 EE ; Subtract with carry (stack relative indirect indexed) ($EE.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FCE7.w,Y		; F9 E7 FC ; Subtract with carry $FCE7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF.b,S		; E3 FF ; Subtract stack-relative $FF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $E0.b,S		; 23 E0 ; AND accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $F800.w		; 0C 00 F8 ; Test and set bits $F800.w [Reads: Accumulator] [Flags: Z]
	ora [$9E.b]		; 07 9E ; OR accumulator with memory (long) [$9E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $083F30.l,X		; 7F 30 3F 08 ; Add long $083F30.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $DC830E.l,X		; 1F 0E 83 DC ; Logical OR long $DC830E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$E7.b],Y		; 37 E7 ; AND accumulator with memory (long indexed) [$E7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($90.b),Y		; F1 90 ; Subtract with carry ($90.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	rol $11.b,X		; 36 11 ; Rotate left $11.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $1F03.w		; 0C 03 1F ; Test and set bits $1F03.w [Reads: Accumulator] [Flags: Z]
	cpx #$79.b		; E0 79 ; Compare #$79.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	asl $FE.b		; 06 FE ; Arithmetic shift left $FE.b [Reads: Direct Page] [Flags: ZNC]
	tsb $10FC.w		; 0C FC 10 ; Test and set bits $10FC.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $6C1209.l		; 8F 09 12 6C ; Store accumulator (long) $6C1209.l [Reads: Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	and ($12.b,S),Y		; 33 12 ; AND accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $083707.l,X		; 3F 07 37 08 ; AND accumulator with memory (long,X) $083707.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$0B.b],Y		; 37 0B ; AND accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $3805.w,X		; 5D 05 38 ; Exclusive OR accumulator with memory $3805.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0705.w,X		; 1D 05 07 ; OR accumulator with memory $0705.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	and $277A2C.l		; 2F 2C 7A 27 ; AND accumulator with memory (long) $277A2C.l [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $0500.w,X		; FE 00 05 ; Increment memory $0500.w,X [Reads: X Index] [Flags: ZN]
	jsr ($7C00.w,X)		; FC 00 7C ; Jump to subroutine indirect indexed ($7C00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $A2.b		; 85 A2 ; Store accumulator to $A2.b [Reads: Accumulator]
	tsb $13.b		; 04 13 ; Test and set bits $13.b [Reads: Accumulator] [Flags: Z]
	.db $82, $82, $C4		; 82 82 C4 ; Branch always long to $82, $82, $C4 [Flow: branch]
	jmp.w [$8864]		; DC 64 88 ; Jump long indirect [$8864] [Flow: jump]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	ldy $FF63.w,X		; BC 63 FF ; Load Y register $FF63.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	inc $49.b,X		; F6 49 ; Increment memory $49.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jmp $1E7D.w		; 4C 7D 1E ; Jump to $1E7D.w [Flow: jump]
	and $851E.w		; 2D 1E 85 ; Logical AND $851E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	jmp $0302.w		; 4C 02 03 ; Jump to $0302.w [Flow: jump]
	ldy $7FBE.w,X		; BC BE 7F ; Load Y register $7FBE.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	and $025683.l,X		; 3F 83 56 02 ; AND accumulator with memory (long,X) $025683.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $14FF.w		; 0C FF 14 ; Test and set bits $14FF.w [Reads: Accumulator] [Flags: Z]
	adc $DD90.w		; 6D 90 DD ; Add $DD90.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	bit $BE.b,X		; 34 BE ; Test bits $BE.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldy $78.b,X		; B4 78 ; Load Y register $78.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	sta $67.b,S		; 83 67 ; Store accumulator (stack relative) $67.b,S [Reads: Accumulator, Stack Pointer]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $FE7B.w		; 4E 7B FE ; Logical shift right $FE7B.w [Flags: ZNC]
	jsr ($70F8.w,X)		; FC F8 70 ; Jump to subroutine indirect indexed ($70F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldy $FF73.w,X		; BC 73 FF ; Load Y register $FF73.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cmp $377B14.l,X		; DF 14 7B 37 ; Compare accumulator (long,X) $377B14.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	bit $130F.w,X		; 3C 0F 13 ; Test bits $130F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $020D.w		; 0E 0D 02 ; Arithmetic shift left $020D.w [Flags: ZNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($4FEF.w,X)		; FC EF 4F ; Jump to subroutine indirect indexed ($4FEF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $030F1F.l,X		; 3F 1F 0F 03 ; AND accumulator with memory (long,X) $030F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $FEC8.w,X		; 3C C8 FE ; Test bits $FEC8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	trb $3CEA.w		; 1C EA 3C ; Test and reset bits $3CEA.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsr ($F834.w,X)		; FC 34 F8 ; Jump to subroutine indirect indexed ($F834.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $FEFE.w,X		; 3E FE FE ; Rotate left $FEFE.w,X [Reads: X Index] [Flags: ZNC]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$4B.b		; E0 4B ; Compare #$4B.b with X register [Reads: X Index] [Flags: ZNC]
	and $56.b,X		; 35 56 ; Logical AND $56.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and #$76.b		; 29 76 ; Logical AND #$76.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora #$5B.b		; 09 5B ; Logical OR #$5B.b with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $6A.b		; 24 6A ; Test bits $6A.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $3B.b,X		; 34 3B ; Test bits $3B.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	asl $1C.b,X		; 16 1C ; Arithmetic shift left $1C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $7F7F6F.l		; 4F 6F 7F 7F ; Exclusive OR accumulator with memory (long) $7F7F6F.l [Writes: Accumulator] [Flags: ZN]
	and $FC071F.l,X		; 3F 1F 07 FC ; AND accumulator with memory (long,X) $FC071F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	jsr ($7A18.w,X)		; FC 18 7A ; Jump to subroutine indirect indexed ($7A18.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp $8330EC.l		; 5C EC 30 83 ; Jump long to $8330EC.l [Flow: jump]
	bit $05.b,X		; 34 05 ; Test bits $05.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cpx #$31.b		; E0 31 ; Compare #$31.b with X register [Reads: X Index] [Flags: ZNC]
	pea $F8F8.w		; F4 F8 F8 ; Push absolute address $F8F8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jsr ($FCBE.w,X)		; FC BE FC ; Jump to subroutine indirect indexed ($FCBE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	eor $5933.w		; 4D 33 59 ; Exclusive OR $5933.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and [$77.b]		; 27 77 ; AND accumulator with memory (long) [$77.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $37.b,S		; 03 37 ; OR accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $2F.b		; 04 2F ; Test and set bits $2F.b [Reads: Accumulator] [Flags: Z]
	asl $17.b,X		; 16 17 ; Arithmetic shift left $17.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora #$0C.b		; 09 0C ; Logical OR #$0C.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $393B7F.l		; 4F 7F 3B 39 ; Exclusive OR accumulator with memory (long) $393B7F.l [Writes: Accumulator] [Flags: ZN]
	ora $FC030F.l,X		; 1F 0F 03 FC ; Logical OR long $FC030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $DE		; B0 DE ; Branch if carry set to $B0, $DE [Flow: branch]
	stz $9A.b,X		; 74 9A ; Store zero to $9A.b,X [Reads: X Index]
	jsr ($B8C4.w,X)		; FC C4 B8 ; Jump to subroutine indirect indexed ($B8C4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $90, $30		; 90 30 ; Branch if carry clear to $90, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($3A84.w,X)		; FC 84 3A ; Jump to subroutine indirect indexed ($3A84.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $13.b		; 05 13 ; Logical OR $13.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy #$C6.b		; C0 C6 ; Compare #$C6.b with Y register [Reads: Y Index] [Flags: ZNC]
	and $0AF7.w,Y		; 39 F7 0A ; AND accumulator with memory $0AF7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc $9D.b		; 65 9D ; Add $9D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $62, $BE, $61		; 62 BE 61 ; Push effective relative address $62, $BE, $61 [Writes: Stack Pointer]
	lda $38DF70.l,X		; BF 70 DF 38 ; Load long $38DF70.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp [$38.b]		; C7 38 ; Compare accumulator (long) [$38.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta $79.b		; 85 79 ; Store accumulator to $79.b [Reads: Accumulator]
	dec $FD.b		; C6 FD ; Decrement $FD.b [Reads: Direct Page] [Flags: ZN]
	eor $BF.b,S		; 43 BF ; Exclusive OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr $2AB1.w,X		; 5E B1 2A ; Logical shift right $2AB1.w,X [Reads: X Index] [Flags: ZNC]
	cmp $99.b,X		; D5 99 ; Compare accumulator $99.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ror $CA.b		; 66 CA ; Rotate right $CA.b [Reads: Direct Page] [Flags: ZNC]
	and [$01.b],Y		; 37 01 ; AND accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	asl $2F57.w		; 0E 57 2F ; Arithmetic shift left $2F57.w [Flags: ZNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and [$5F.b]		; 27 5F ; AND accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $245B.w		; 20 5B 24 ; Jump to subroutine at $245B.w [Writes: Stack Pointer] [Flow: call]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	bit $63.b,X		; 34 63 ; Test bits $63.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	trb $0F30.w		; 1C 30 0F ; Test and reset bits $0F30.w [Reads: Accumulator] [Flags: Z]
	ora $0E0028.l,X		; 1F 28 00 0E ; Logical OR long $0E0028.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $E01FFF.l,X		; FF FF 1F E0 ; Subtract with carry (long,X) $E01FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $FD.b		; 04 FD ; Test and set bits $FD.b [Reads: Accumulator] [Flags: Z]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $22FF.w,X		; FE FF 22 ; Increment memory $22FF.w,X [Reads: X Index] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$FF.b		; 09 FF ; Logical OR #$FF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7F4FF0.l,X		; 3F F0 4F 7F ; AND accumulator with memory (long,X) $7F4FF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $BF		; 30 BF ; Branch if minus to $30, $BF [Flow: branch]
	eor $220022.l,X		; 5F 22 00 22 ; Exclusive OR accumulator with memory (long,X) $220022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FF7F01.l,X		; FF 01 7F FF ; Subtract with carry (long,X) $FF7F01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$FF.b		; 09 FF ; Logical OR #$FF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $827F.w		; EC 7F 82 ; Compare $827F.w with X register [Reads: X Index] [Flags: ZNC]
	inc $FD0C.w,X		; FE 0C FD ; Increment memory $FD0C.w,X [Reads: X Index] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	jsl $FF0400.l		; 22 00 04 FF ; Jump to subroutine long $FF0400.l [Writes: Stack Pointer] [Flow: call]
	sbc $FFFE8F.l		; EF 8F FE FF ; Subtract with carry (long) $FFFE8F.l [Writes: Accumulator] [Flags: ZVNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $020000.l		; 22 00 00 02 ; Jump to subroutine long $020000.l [Writes: Stack Pointer] [Flow: call]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $81.b		; 05 81 ; Logical OR $81.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $24		; 80 24 ; Branch always to $80, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($7F.b,X)		; 81 7F ; Store accumulator ($7F.b,X) [Reads: Accumulator, X Index, Direct Page]
	sta ($23.b,S),Y		; 93 23 ; Store accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $10, $C8		; 10 C8 ; Branch if plus to $10, $C8 [Flow: branch]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	jsr $50F8.w		; 20 F8 50 ; Jump to subroutine at $50F8.w [Writes: Stack Pointer] [Flow: call]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sed		; F8 ; Set decimal flag [Flags: D]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$28.b		; E0 28 ; Compare #$28.b with X register [Reads: X Index] [Flags: ZNC]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0D0B.w		; 0E 0B 0D ; Arithmetic shift left $0D0B.w [Flags: ZNC]
	ora $00000B.l		; 0F 0B 00 00 ; OR accumulator with memory (long) $00000B.l [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $7E01.w		; 0E 01 7E ; Arithmetic shift left $7E01.w [Flags: ZNC]
	ora $7EFF.w		; 0D FF 7E ; Logical OR $7EFF.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $31FF.w,X		; FD FF 31 ; Subtract with carry $31FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $030200.l,X		; FF 00 02 03 ; Subtract with carry (long,X) $030200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FF227F.l		; 0F 7F 22 FF ; OR accumulator with memory (long) $FF227F.l [Writes: Accumulator] [Flags: ZN]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	ora #$C0.b		; 09 C0 ; Logical OR #$C0.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	jsr $60A0.w		; 20 A0 60 ; Jump to subroutine at $60A0.w [Writes: Stack Pointer] [Flow: call]
	ldy #$A0.b		; A0 A0 ; Load #$A0.b into Y register [Writes: Y Index] [Flags: ZN]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$60.b]		; 07 60 ; OR accumulator with memory (long) [$60.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BB.b		; 00 BB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $F7.b		; 04 F7 ; Test and set bits $F7.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $60.b,S		; 03 60 ; OR accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldy $EEE7.w,X		; BC E7 EE ; Load Y register $EEE7.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp.w [$2428]		; DC 28 24 ; Jump long indirect [$2428] [Flow: jump]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($7F3C.w,X)		; FC 3C 7F ; Jump to subroutine indirect indexed ($7F3C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsr $1827.w		; 20 27 18 ; Jump to subroutine at $1827.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	jsl $401300.l		; 22 00 13 40 ; Jump to subroutine long $401300.l [Writes: Stack Pointer] [Flow: call]
	ldy #$58.b		; A0 58 ; Load #$58.b into Y register [Writes: Y Index] [Flags: ZN]
	and [$10.b]		; 27 10 ; AND accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $18.b		; 25 18 ; Logical AND $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and #$10.b		; 29 10 ; Logical AND #$10.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $49.b,S		; 43 49 ; Exclusive OR accumulator with stack relative $49.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $07		; 30 07 ; Branch if minus to $30, $07 [Flow: branch]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	trb $24.b		; 14 24 ; Test and reset bits $24.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $7E.b,S		; 03 7E ; OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit #$22.b		; 89 22 ; Test bits #$22.b with accumulator [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta [$7F.b]		; 87 7F ; Store accumulator (long) [$7F.b] [Reads: Accumulator, Direct Page]
	sta $006283.l,X		; 9F 83 62 00 ; Store accumulator (long,X) $006283.l,X [Reads: Accumulator, X Index]
	ora $58.b		; 05 58 ; Logical OR $58.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $B8		; 10 B8 ; Branch if plus to $10, $B8 [Flow: branch]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $30, $43		; 30 43 ; Branch if minus to $30, $43 [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $68		; 30 68 ; Branch if minus to $30, $68 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	.db $F0, $27		; F0 27 ; Branch if equal to $F0, $27 [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc [$18.b],Y		; F7 18 ; Subtract with carry (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $60.b,S		; 03 60 ; OR accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	jsr ($27FC.w,X)		; FC FC 27 ; Jump to subroutine indirect indexed ($27FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	pea $BEEC.w		; F4 EC BE ; Push absolute address $BEEC.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor [$DF.b]		; 47 DF ; Exclusive OR accumulator with memory (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($0C.b,S),Y		; 73 0C ; Add with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($BF33.w)		; 6C 33 BF ; Jump indirect to ($BF33.w) [Flow: jump]
	jmp $DA4FBB.l		; 5C BB 4F DA ; Jump long to $DA4FBB.l [Flow: jump]
	adc $9F0F7C.l		; 6F 7C 0F 9F ; Add with carry (long) $9F0F7C.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $FF7F7F.l,X		; DF 7F 7F FF ; Compare accumulator (long,X) $FF7F7F.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sta $7D7FDF.l,X		; 9F DF 7F 7D ; Store accumulator (long,X) $7D7FDF.l,X [Reads: Accumulator, X Index]
.ACCU 8
.INDEX 8
	sep #$FB		; E2 FB
	asl $CE.b		; 06 CE ; Arithmetic shift left $CE.b [Reads: Direct Page] [Flags: ZNC]
	.db $30, $36		; 30 36 ; Branch if minus to $30, $36 [Flow: branch]
	cpy $3AFD.w		; CC FD 3A ; Compare $3AFD.w with Y register [Reads: Y Index] [Flags: ZNC]
	cmp $5BF2.w,X		; DD F2 5B ; Compare accumulator $5BF2.w,X [Reads: X Index] [Flags: ZNC]
	inc $BE.b,X		; F6 BE ; Increment memory $BE.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	.db $D0, $F9		; D0 F9 ; Branch if not equal to $D0, $F9 [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $FFFE.w,X		; FE FE FF ; Increment memory $FFFE.w,X [Reads: X Index] [Flags: ZN]
	sbc $DEFB.w,Y		; F9 FB DE ; Subtract with carry $DEFB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $84.b,S		; 03 84 ; OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta ($00.b),Y		; 91 00 ; Store accumulator ($00.b),Y [Reads: Accumulator, Direct Page, Y Index]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $030300.l		; 22 00 03 03 ; Jump to subroutine long $030300.l [Writes: Stack Pointer] [Flow: call]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $FB.b		; 84 FB ; Store Y register to $FB.b [Reads: Y Index]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $FB		; 10 FB ; Branch if plus to $10, $FB [Flow: branch]
	ora $DC37.w		; 0D 37 DC ; Logical OR $DC37.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $E01C18.l,X		; FF 18 1C E0 ; Subtract with carry (long,X) $E01C18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	lda [$FE.b],Y		; B7 FE ; Load accumulator (long indexed) [$FE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $FFFF1F.l,X		; 3F 1F FF FF ; AND accumulator with memory (long,X) $FFFF1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $30E0.w		; 1C E0 30 ; Test and reset bits $30E0.w [Reads: Accumulator] [Flags: Z]
	jsr $C0E0.w		; 20 E0 C0 ; Jump to subroutine at $C0E0.w [Writes: Stack Pointer] [Flow: call]
	sta $B4.b,S		; 83 B4 ; Store accumulator (stack relative) $B4.b,S [Reads: Accumulator, Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$26.b		; C0 26 ; Compare #$26.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $050E06.l		; 0F 06 0E 05 ; OR accumulator with memory (long) $050E06.l [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $020707.l		; 0F 07 07 02 ; OR accumulator with memory (long) $020707.l [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $FF.b,S		; 83 FF ; Store accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer]
	cmp $39FEFC.l		; CF FC FE 39 ; Compare accumulator (long) $39FEFC.l [Reads: Accumulator] [Flags: ZNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stx $C7.b		; 86 C7 ; Store X register to $C7.b [Reads: X Index]
	jmp ($38FF.w,X)		; 7C FF 38 ; Jump indirect indexed to ($38FF.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E03804.l,X		; FF 04 38 E0 ; Subtract with carry (long,X) $E03804.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$01.b		; E0 01 ; Compare #$01.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $C000E0.l		; 22 E0 00 C0 ; Jump to subroutine long $C000E0.l [Writes: Stack Pointer] [Flow: call]
	jsl $3B0C00.l		; 22 00 0C 3B ; Jump to subroutine long $3B0C00.l [Writes: Stack Pointer] [Flow: call]
	cop $5D.b		; 02 5D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $304F.w		; 2D 4F 30 ; Logical AND $304F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ror $3531.w,X		; 7E 31 35 ; Rotate right $3531.w,X [Reads: X Index] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $220101.l,X		; 1F 01 01 22 ; Logical OR long $220101.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7F72.w,X		; 3D 72 7F ; AND accumulator with memory $7F72.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $011F37.l,X		; 7F 37 1F 01 ; Add long $011F37.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	bit $E6.b		; 24 E6 ; Test bits $E6.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	trb $A47E.w		; 1C 7E A4 ; Test and reset bits $A47E.w [Reads: Accumulator] [Flags: Z]
	jsr ($E4C0.w,X)		; FC C0 E4 ; Jump to subroutine indirect indexed ($E4C0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sty $F870.w		; 8C 70 F8 ; Store Y register to $F870.w [Reads: Y Index]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $37E0FE.l		; 22 FE E0 37 ; Jump to subroutine long $37E0FE.l [Writes: Stack Pointer] [Flow: call]
	jsr ($8CE4.w,X)		; FC E4 8C ; Jump to subroutine indirect indexed ($8CE4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsr $2050.w		; 20 50 20 ; Jump to subroutine at $2050.w [Writes: Stack Pointer] [Flow: call]
	bit $1310.w		; 2C 10 13 ; Test bits $1310.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	tsb $0708.w		; 0C 08 07 ; Test and set bits $0708.w [Reads: Accumulator] [Flags: Z]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr $5050.w		; 20 50 50 ; Jump to subroutine at $5050.w [Writes: Stack Pointer] [Flow: call]
	bit $0813.w		; 2C 13 08 ; Test bits $0813.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $08.b,X		; 16 08 ; Arithmetic shift left $08.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $10, $49		; 10 49 ; Branch if plus to $10, $49 [Flow: branch]
	.db $30, $51		; 30 51 ; Branch if minus to $30, $51 [Flow: branch]
	jsr $6090.w		; 20 90 60 ; Jump to subroutine at $6090.w [Writes: Stack Pointer] [Flow: call]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$16.b		; 09 16 ; Logical OR #$16.b with accumulator [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $50, $90		; 50 90 ; Branch if overflow clear to $50, $90 [Flow: branch]
	adc [$8C.b],Y		; 77 8C ; Add with carry (long indexed) [$8C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$0B.b],Y		; F7 0B ; Subtract with carry (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	cpy $0101.w		; CC 01 01 ; Compare $0101.w with Y register [Reads: Y Index] [Flags: ZNC]
	lda $DA85FF.l,X		; BF FF 85 DA ; Load long $DA85FF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $C0C0.w		; 20 C0 C0 ; Jump to subroutine at $C0C0.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	jsl $C001E0.l		; 22 E0 01 C0 ; Jump to subroutine long $C001E0.l [Writes: Stack Pointer] [Flow: call]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $275C1C.l,X		; 3F 1C 5C 27 ; AND accumulator with memory (long,X) $275C1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $46863A.l		; 4F 3A 86 46 ; Exclusive OR accumulator with memory (long) $46863A.l [Writes: Accumulator] [Flags: ZN]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $837F22.l,X		; 3F 22 7F 83 ; AND accumulator with memory (long,X) $837F22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	mvn $05,$02		; 54 02 05 ; Move block negative $05,$02 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	trb $FA10.w		; 1C 10 FA ; Test and reset bits $FA10.w [Reads: Accumulator] [Flags: Z]
	stz $F6.b,X		; 74 F6 ; Store zero to $F6.b,X [Reads: X Index]
	tsb $5E89.w		; 0C 89 5E ; Test and set bits $5E89.w [Reads: Accumulator] [Flags: Z]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $858E.w		; EC 8E 85 ; Compare $858E.w with X register [Reads: X Index] [Flags: ZNC]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $500020.l		; 2F 20 00 50 ; AND accumulator with memory (long) $500020.l [Writes: Accumulator] [Flags: ZN]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $B3		; 30 B3 ; Branch if minus to $30, $B3 [Flow: branch]
	jsr $1C7D.w		; 20 7D 1C ; Jump to subroutine at $1C7D.w [Writes: Stack Pointer] [Flow: call]
	sta $41E705.l,X		; 9F 05 E7 41 ; Store accumulator (long,X) $41E705.l,X [Reads: Accumulator, X Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $B0, $20		; B0 20 ; Branch if carry set to $B0, $20 [Flow: branch]
	.db $70, $CE		; 70 CE ; Branch if overflow set to $70, $CE [Flow: branch]
	cmp $BEFA63.l,X		; DF 63 FA BE ; Compare accumulator (long,X) $BEFA63.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	eor $240018.l		; 4F 18 00 24 ; Exclusive OR accumulator with memory (long) $240018.l [Writes: Accumulator] [Flags: ZN]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	dec $2700.w,X		; DE 00 27 ; Decrement memory $2700.w,X [Reads: X Index] [Flags: ZN]
	cop $9A.b		; 02 9A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	stz $9C84.w,X		; 9E 84 9C ; Store zero to $9C84.w,X [Reads: X Index]
	.db $80, $18		; 80 18 ; Branch always to $80, $18 [Flow: branch]
	bit $FE66.w,X		; 3C 66 FE ; Test bits $FE66.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $7A76.w,X		; FD 76 7A ; Subtract with carry $7A76.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($0025.w,X)		; 7C 25 00 ; Jump indirect indexed to ($0025.w,X) [Reads: X Index] [Flow: jump]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $19.b		; 04 19 ; Test and set bits $19.b [Reads: Accumulator] [Flags: Z]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $060400.l		; 22 00 04 06 ; Jump to subroutine long $060400.l [Writes: Stack Pointer] [Flow: call]
	ora $1E0D.w		; 0D 0D 1E ; Logical OR $1E0D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$8B.b],Y		; 17 8B ; OR accumulator with memory (long indexed) [$8B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	ora $7D.b,S		; 03 7D ; OR accumulator with stack relative $7D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda $847FE9.l,X		; BF E9 7F 84 ; Load long $847FE9.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: ZN]
	jsl $0025FF.l		; 22 FF 25 00 ; Jump to subroutine long $0025FF.l [Writes: Stack Pointer] [Flow: call]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1C.b		; 02 1C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $020300.l		; 22 00 03 02 ; Jump to subroutine long $020300.l [Writes: Stack Pointer] [Flow: call]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sty $0347.w		; 8C 47 03 ; Store Y register to $0347.w [Reads: Y Index]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $9F8599.l,X		; 7F 99 85 9F ; Add long $9F8599.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $090025.l,X		; FF 25 00 09 ; Subtract with carry (long,X) $090025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0F3000.l		; 0F 00 30 0F ; OR accumulator with memory (long) $0F3000.l [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $BF30FF.l,X		; 3F FF 30 BF ; AND accumulator with memory (long,X) $BF30FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	mvp $00,$22		; 44 22 00 ; Move block positive $00,$22 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	and $FFFF7F.l,X		; 3F 7F FF FF ; AND accumulator with memory (long,X) $FFFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$F0.b		; 09 F0 ; Logical OR #$F0.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $16		; 80 16 ; Branch always to $80, $16 [Flow: branch]
	cpx $0CFF.w		; EC FF 0C ; Compare $0CFF.w with X register [Reads: X Index] [Flags: ZNC]
	sbc $2222.w,X		; FD 22 22 ; Subtract with carry $2222.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $8C,$F0		; 44 F0 8C ; Move block positive $8C,$F0 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	inc $FFFF.w		; EE FF FF ; Increment $FFFF.w [Flags: ZN]
	and $5E1F.w,X		; 3D 1F 5E ; AND accumulator with memory $5E1F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $6E265F.l		; 2F 5F 26 6E ; AND accumulator with memory (long) $6E265F.l [Writes: Accumulator] [Flags: ZN]
	and $3D.b,X		; 35 3D ; Logical AND $3D.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $3F6D4E.l,X		; 7F 4E 6D 3F ; Add long $3F6D4E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $5C030F.l,X		; 1F 0F 03 5C ; Logical OR long $5C030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	stz $7A.b,X		; 74 7A ; Store zero to $7A.b,X [Reads: X Index]
	cpx $B6.b		; E4 B6 ; Compare $B6.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx $E03C.w		; EC 3C E0 ; Compare $E03C.w with X register [Reads: X Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $F6F2.w,X		; 7E F2 F6 ; Rotate right $F6F2.w,X [Reads: X Index] [Flags: ZNC]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$3B.b		; C0 3B ; Compare #$3B.b with Y register [Reads: Y Index] [Flags: ZNC]
	asl $3F.b,X		; 16 3F ; Arithmetic shift left $3F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	and [$1C.b],Y		; 37 1C ; AND accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $023D0A.l,X		; 3F 0A 3D 02 ; AND accumulator with memory (long,X) $023D0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	asl $3F.b,X		; 16 3F ; Arithmetic shift left $3F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and $3F.b,S		; 23 3F ; AND accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $3F3B.w,Y		; 39 3B 3F ; AND accumulator with memory $3F3B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and $FD7FFE.l,X		; 3F FE 7F FD ; AND accumulator with memory (long,X) $FD7FFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $977FBF.l,X		; DF BF 7F 97 ; Compare accumulator (long,X) $977FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	lsr $0007.w		; 4E 07 00 ; Logical shift right $0007.w [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $235E.w,Y		; 19 5E 23 ; OR accumulator with memory $235E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ldx $BD63.w,Y		; BE 63 BD ; Load X register $BD63.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	adc $BE.b,S		; 63 BE ; Add with carry (stack relative) $BE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc ($AF.b,X)		; 61 AF ; Add with carry ($AF.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $30, $B7		; 30 B7 ; Branch if minus to $30, $B7 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and $273F5F.l,X		; 3F 5F 3F 27 ; AND accumulator with memory (long,X) $273F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $A707F8.l,X		; 1F F8 07 A7 ; Logical OR long $A707F8.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	eor $385FAB.l,X		; 5F AB 5F 38 ; Exclusive OR accumulator with memory (long,X) $385FAB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00071F.l,X		; 1F 1F 07 00 ; Logical OR long $00071F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1A1EED.l		; 0F ED 1E 1A ; OR accumulator with memory (long) $1A1EED.l [Writes: Accumulator] [Flags: ZN]
	jsr ($FCFA.w,X)		; FC FA FC ; Jump to subroutine indirect indexed ($FCFA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $F8.b		; E4 F8 ; Compare $F8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $1AE5E0.l,X		; 1F E0 E5 1A ; Logical OR long $1AE5E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $FA.b,X		; 15 FA ; OR accumulator with memory $FA.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $FA.b,X		; D5 FA ; Compare accumulator $FA.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	trb $F8F8.w		; 1C F8 F8 ; Test and reset bits $F8F8.w [Reads: Accumulator] [Flags: Z]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $3D		; F0 3D ; Branch if equal to $F0, $3D [Flow: branch]
	tsb $0C1D.w		; 0C 1D 0C ; Test and set bits $0C1D.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($13.b,S),Y		; 33 13 ; AND accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $2304.w		; 0E 04 23 ; Arithmetic shift left $2304.w [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $90.b,X		; B4 90 ; Load Y register $90.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jsr $2A70.w		; 20 70 2A ; Jump to subroutine at $2A70.w [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($70D8.w)		; 6C D8 70 ; Jump indirect to ($70D8.w) [Flow: jump]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $17.b		; 05 17 ; Logical OR $17.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: ZNC]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $4301.w,X		; FE 01 43 ; Increment memory $4301.w,X [Reads: X Index] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $09.b		; 86 09 ; Store X register to $09.b [Reads: X Index]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc [$86.b]		; E7 86 ; Subtract with carry (long) [$86.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora ($02.b,S),Y		; 13 02 ; OR accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $1B.b		; 84 1B ; Store Y register to $1B.b [Reads: Y Index]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $38FC06.l,X		; FF 06 FC 38 ; Subtract with carry (long,X) $38FC06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$17.b		; E0 17 ; Compare #$17.b with X register [Reads: X Index] [Flags: ZNC]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	tsb $85.b		; 04 85 ; Test and set bits $85.b [Reads: Accumulator] [Flags: Z]
	ldy $04.b,X		; B4 04 ; Load Y register $04.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $950B.w,Y		; 19 0B 95 ; OR accumulator with memory $950B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rep #$04		; C2 04 ; Reset processor status bits #$04 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl $FC.b,X		; 16 FC ; Arithmetic shift left $FC.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $087F54.l,X		; FF 54 7F 08 ; Subtract with carry (long,X) $087F54.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $48BF14.l,X		; 7F 14 BF 48 ; Add long $48BF14.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $48FF50.l,X		; FF 50 FF 48 ; Subtract with carry (long,X) $48FF50.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $FFFF10.l,X		; 7F 10 FF FF ; Add long $FFFF10.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $FF227F.l,X		; 7F 7F 22 FF ; Add long $FF227F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $7F.b		; 14 7F ; Test and reset bits $7F.b [Reads: Accumulator] [Flags: Z]
	sbc $2AFF12.l,X		; FF 12 FF 2A ; Subtract with carry (long,X) $2AFF12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $FE10.w,X		; FE 10 FE ; Increment memory $FE10.w,X [Reads: X Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	sbc $FF12.w,X		; FD 12 FF ; Subtract with carry $FF12.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $08FE12.l,X		; FF 12 FE 08 ; Subtract with carry (long,X) $08FE12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FEFEFF.l,X		; FF FF FE FE ; Subtract with carry (long,X) $FEFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $FE11FF.l		; 22 FF 11 FE ; Jump to subroutine long $FE11FF.l [Writes: Stack Pointer] [Flow: call]
	and $247F08.l,X		; 3F 08 7F 24 ; AND accumulator with memory (long,X) $247F08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $247F28.l,X		; 7F 28 7F 24 ; Add long $247F28.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $041F08.l,X		; 3F 08 1F 04 ; AND accumulator with memory (long,X) $041F08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000300.l		; 0F 00 03 00 ; OR accumulator with memory (long) $000300.l [Writes: Accumulator] [Flags: ZN]
	and $837F22.l,X		; 3F 22 7F 83 ; AND accumulator with memory (long,X) $837F22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	pei ($03.b)		; D4 03 ; Push effective indirect address ($03.b) [Reads: Direct Page] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $0C1206.l		; 0F 06 12 0C ; OR accumulator with memory (long) $0C1206.l [Writes: Accumulator] [Flags: ZN]
	and ($0C.b)		; 32 0C ; AND accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $3B.b		; 04 3B ; Test and set bits $3B.b [Reads: Accumulator] [Flags: Z]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $363E1E.l		; 0F 1E 3E 36 ; OR accumulator with memory (long) $363E1E.l [Writes: Accumulator] [Flags: ZN]
	and [$2D.b],Y		; 37 2D ; AND accumulator with memory (long indexed) [$2D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($2B.b)		; 12 2B ; OR accumulator with memory (indirect) ($2B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $2F.b,X		; 16 2F ; Arithmetic shift left $2F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $123D1A.l		; 2F 1A 3D 12 ; AND accumulator with memory (long) $123D1A.l [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $1F.b,X		; 16 1F ; Arithmetic shift left $1F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $048300.l		; 0F 00 83 04 ; OR accumulator with memory (long) $048300.l [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	and $1F3B.w,Y		; 39 3B 1F ; AND accumulator with memory $1F3B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $082FF0.l		; 0F F0 2F 08 ; OR accumulator with memory (long) $082FF0.l [Writes: Accumulator] [Flags: ZN]
	tsb $97.b		; 04 97 ; Test and set bits $97.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	and $ED5CEF.l		; 2F EF 5C ED ; AND accumulator with memory (long) $ED5CEF.l [Writes: Accumulator] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc $F866.w,Y		; F9 66 F8 ; Subtract with carry $F866.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$FF.b],Y		; 77 FF ; Add with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	sbc $4A4C00.l,X		; FF 00 4C 4A ; Subtract with carry (long,X) $4A4C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $77.b		; 66 77 ; Rotate right $77.b [Reads: Direct Page] [Flags: ZNC]
	ora [$78.b]		; 07 78 ; OR accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$3A.b],Y		; F7 3A ; Subtract with carry (long indexed) [$3A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda [$5A.b],Y		; B7 5A ; Load accumulator (long indexed) [$5A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $EE1F66.l,X		; 9F 66 1F EE ; Store accumulator (long,X) $EE1F66.l,X [Reads: Accumulator, X Index]
	sbc $1EFFE0.l,X		; FF E0 FF 1E ; Subtract with carry (long,X) $1EFFE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $523200.l,X		; FF 00 32 52 ; Subtract with carry (long,X) $523200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $EE.b		; 66 EE ; Rotate right $EE.b [Reads: Direct Page] [Flags: ZNC]
	cpx #$1E.b		; E0 1E ; Compare #$1E.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000113.l,X		; FF 13 01 00 ; Subtract with carry (long,X) $000113.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0C1F00.l		; 0F 00 1F 0C ; OR accumulator with memory (long) $0C1F00.l [Writes: Accumulator] [Flags: ZN]
	bit $361B.w,X		; 3C 1B 36 ; Test bits $361B.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $1D3E.w,X		; 1D 3E 1D ; OR accumulator with memory $1D3E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $0122.w,X		; 7D 22 01 ; Add $0122.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $3F22.w,X		; 1E 22 3F ; Arithmetic shift left $3F22.w,X [Reads: X Index] [Flags: ZNC]
	cpx #$30.b		; E0 30 ; Compare #$30.b with X register [Reads: X Index] [Flags: ZNC]
	ror $0080.w,X		; 7E 80 00 ; Rotate right $0080.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $EC		; 30 EC ; Branch if minus to $30, $EC [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp.w [$EC28]		; DC 28 EC ; Jump long indirect [$EC28] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	inc $8004.w,X		; FE 04 80 ; Increment memory $8004.w,X [Reads: X Index] [Flags: ZN]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $7C6C.w,X		; 3C 6C 7C ; Test bits $7C6C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	rol $0010.w,X		; 3E 10 00 ; Rotate left $0010.w,X [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $6C.b,S		; 03 6C ; OR accumulator with stack relative $6C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$45.b],Y		; 17 45 ; OR accumulator with memory (long indexed) [$45.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	jmp $2C37.w		; 4C 37 2C ; Jump to $2C37.w [Flow: jump]
	ora [$10.b],Y		; 17 10 ; OR accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	eor $7F7E5F.l,X		; 5F 5F 7E 7F ; Exclusive OR accumulator with memory (long,X) $7F7E5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $E00023.l,X		; 3F 23 00 E0 ; AND accumulator with memory (long,X) $E00023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $7200DC.l,X		; 5F DC 00 72 ; Exclusive OR accumulator with memory (long,X) $7200DC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy $6EB9.w		; CC B9 6E ; Compare $6EB9.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $9F2E.w,Y		; F9 2E 9F ; Subtract with carry $9F2E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $1F.b,X		; 76 1F ; Rotate right $1F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$7FFE]		; DC FE 7F ; Jump long indirect [$7FFE] [Flow: jump]
	and $01FF7F.l,X		; 3F 7F FF 01 ; AND accumulator with memory (long,X) $01FF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora $3A0F17.l		; 0F 17 0F 3A ; OR accumulator with memory (long) $3A0F17.l [Writes: Accumulator] [Flags: ZN]
	ora $011F7E.l,X		; 1F 7E 1F 01 ; Logical OR long $011F7E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F1F1F.l		; 0F 1F 1F 3F ; OR accumulator with memory (long) $3F1F1F.l [Writes: Accumulator] [Flags: ZN]
	adc $400080.l,X		; 7F 80 00 40 ; Add long $400080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $A0		; 80 A0 ; Branch always to $80, $A0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	.db $D0, $7C		; D0 7C ; Branch if not equal to $D0, $7C [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	rol $80D8.w		; 2E D8 80 ; Rotate left $80D8.w [Flags: ZNC]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sty $00DE.w		; 8C DE 00 ; Store Y register to $00DE.w [Reads: Y Index]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($2F.b,X)		; 01 2F ; Logical OR ($2F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $73		; 10 73 ; Branch if plus to $10, $73 [Flow: branch]
	bit $025D.w		; 2C 5D 02 ; Test bits $025D.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $0029.w		; 6E 29 00 ; Rotate right $0029.w [Flags: ZNC]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($31.b,S),Y		; 13 31 ; OR accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $577F.w,X		; 5D 7F 57 ; Exclusive OR accumulator with memory $577F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $FF00.w,X		; 7E 00 FF ; Rotate right $FF00.w,X [Reads: X Index] [Flags: ZNC]
	.db $42, $44		; 42 44 ; Reserved instruction
	sbc $C30781.l,X		; FF 81 07 C3 ; Subtract with carry (long,X) $C30781.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $81FF7E.l,X		; FF 7E FF 81 ; Subtract with carry (long,X) $81FF7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $7EDB.w,X		; 7E DB 7E ; Rotate right $7EDB.w,X [Reads: X Index] [Flags: ZNC]
	rol $FF.b		; 26 FF ; Rotate left $FF.b [Reads: Direct Page] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta [$92.b]		; 87 92 ; Store accumulator (long) [$92.b] [Reads: Accumulator, Direct Page]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($0C.b,S),Y		; 33 0C ; AND accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $0022.w,X		; 7D 22 00 ; Add $0022.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $A0.b		; 84 A0 ; Store Y register to $A0.b [Reads: Y Index]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $005F.w,X		; 3D 5F 00 ; AND accumulator with memory $005F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $B18481.l,X		; FF 81 84 B1 ; Subtract with carry (long,X) $B18481.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($80.b,S),Y		; 13 80 ; OR accumulator (stack relative indirect indexed) ($80.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	.db $80, $F4		; 80 F4 ; Branch always to $80, $F4 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy $BE30.w		; CC 30 BE ; Compare $BE30.w with Y register [Reads: Y Index] [Flags: ZNC]
	mvp $00,$00		; 44 00 00 ; Move block positive $00,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sty $FABC.w		; 8C BC FA ; Store Y register to $FABC.w [Reads: Y Index]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $D3.b,S		; 83 D3 ; Store accumulator (stack relative) $D3.b,S [Reads: Accumulator, Stack Pointer]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E38681.l,X		; FF 81 86 E3 ; Subtract with carry (long,X) $E38681.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $080025.l,X		; FF 25 00 08 ; Subtract with carry (long,X) $080025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $2C00.w		; 1C 00 2C ; Test and reset bits $2C00.w [Reads: Accumulator] [Flags: Z]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	bit $3C.b,X		; 34 3C ; Test bits $3C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	bit $272C.w,X		; 3C 2C 27 ; Test bits $272C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc ($1C.b,S),Y		; F3 1C ; Subtract with carry (stack relative indirect indexed) ($1C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $60.b,S		; 03 60 ; OR accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sbc $0029FE.l,X		; FF FE 29 00 ; Subtract with carry (long,X) $0029FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp.w [$2428]		; DC 28 24 ; Jump long indirect [$2428] [Flow: jump]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($5E3C.w,X)		; FC 3C 5E ; Jump to subroutine indirect indexed ($5E3C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $7F.b,S		; 23 7F ; AND accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($7F.b,X)		; 21 7F ; Logical AND ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr $107F.w		; 20 7F 10 ; Jump to subroutine at $107F.w [Writes: Stack Pointer] [Flow: call]
	and [$19.b],Y		; 37 19 ; AND accumulator with memory (long indexed) [$19.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $050F.w		; 0C 0F 05 ; Test and set bits $050F.w [Reads: Accumulator] [Flags: Z]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $797B7F.l,X		; 7F 7F 7B 79 ; Add long $797B7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $0E1F.w,X		; 3E 1F 0E ; Rotate left $0E1F.w,X [Reads: X Index] [Flags: ZNC]
	ora [$7A.b]		; 07 7A ; OR accumulator with memory (long) [$7A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy $FE.b		; C4 FE ; Compare $FE.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	sty $FE.b		; 84 FE ; Store Y register to $FE.b [Reads: Y Index]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx $5898.w		; EC 98 58 ; Compare $5898.w with X register [Reads: X Index] [Flags: ZNC]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	ldy #$E0.b		; A0 E0 ; Load #$E0.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $9EDE.w,X		; FE DE 9E ; Increment memory $9EDE.w,X [Reads: X Index] [Flags: ZN]
	jmp ($70F8.w,X)		; 7C F8 70 ; Jump indirect indexed to ($70F8.w,X) [Reads: X Index] [Flow: jump]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: ZNC]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($5F.b,X)		; 01 5F ; Logical OR ($5F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $77		; 30 77 ; Branch if minus to $30, $77 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $071F.w,X		; 1D 1F 07 ; OR accumulator with memory $071F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $4F733F.l,X		; 3F 3F 73 4F ; AND accumulator with memory (long,X) $4F733F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $071F3F.l,X		; 5F 3F 1F 07 ; Exclusive OR accumulator with memory (long,X) $071F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $FEFC.w		; 2E FC FE ; Rotate left $FEFC.w [Flags: ZNC]
	pea $0CFE.w		; F4 FE 0C ; Push absolute address $0CFE.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	dec $FC2C.w,X		; DE 2C FC ; Decrement memory $FC2C.w,X [Reads: X Index] [Flags: ZN]
	.db $70, $7C		; 70 7C ; Branch if overflow set to $70, $7C [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $BE14.w,X		; FE 14 BE ; Increment memory $BE14.w,X [Reads: X Index] [Flags: ZN]
	jmp ($F8FC.w,X)		; 7C FC F8 ; Jump indirect indexed to ($F8FC.w,X) [Reads: X Index] [Flow: jump]
	cpx #$5F.b		; E0 5F ; Compare #$5F.b with X register [Reads: X Index] [Flags: ZNC]
	and $7E2E7F.l		; 2F 7F 2E 7E ; AND accumulator with memory (long) $7E2E7F.l [Writes: Accumulator] [Flags: ZN]
	and $1B3C.w,X		; 3D 3C 1B ; AND accumulator with memory $1B3C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0C1F0B.l,X		; 1F 0B 1F 0C ; Logical OR long $0C1F0B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000702.l		; 0F 02 07 00 ; OR accumulator with memory (long) $000702.l [Writes: Accumulator] [Flags: ZN]
	jsl $3F147F.l		; 22 7F 14 3F ; Jump to subroutine long $3F147F.l [Writes: Stack Pointer] [Flow: call]
	ora $070F1F.l,X		; 1F 1F 0F 07 ; Logical OR long $070F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	pea $74DE.w		; F4 DE 74 ; Push absolute address $74DE.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ror $3CBC.w,X		; 7E BC 3C ; Rotate right $3CBC.w,X [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $D0, $F8		; D0 F8 ; Branch if not equal to $D0, $F8 [Flow: branch]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	jsl $FC11FE.l		; 22 FE 11 FC ; Jump to subroutine long $FC11FE.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	adc $083731.l,X		; 7F 31 37 08 ; Add long $083731.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $4B1700.l		; 22 00 17 4B ; Jump to subroutine long $4B1700.l [Writes: Stack Pointer] [Flow: call]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $020307.l,X		; 1F 07 03 02 ; Logical OR long $020307.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $DB.b		; 24 DB ; Test bits $DB.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sbc $18E7E7.l,X		; FF E7 E7 18 ; Subtract with carry (long,X) $18E7E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $BD.b,S		; C3 BD ; Compare accumulator (stack relative) $BD.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc [$3C.b]		; E7 3C ; Subtract with carry (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $3C99.w,X		; 7E 99 3C ; Rotate right $3C99.w,X [Reads: X Index] [Flags: ZNC]
	cmp $E7.b,S		; C3 E7 ; Compare accumulator (stack relative) $E7.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3C7E1C.l,X		; FF 1C 7E 3C ; Subtract with carry (long,X) $3C7E1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$5E.b]		; E7 5E ; Subtract with carry (long) [$5E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $296F.w,Y		; 19 6F 29 ; OR accumulator with memory $296F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and $021D10.l,X		; 3F 10 1D 02 ; AND accumulator with memory (long,X) $021D10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0703.w		; 0C 03 07 ; Test and set bits $0703.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$2B.b],Y		; 57 2B ; Exclusive OR accumulator with memory (long indexed) [$2B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b,S),Y		; 13 1F ; OR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0307.w		; 0C 07 03 ; Test and set bits $0307.w [Reads: Accumulator] [Flags: Z]
	ror $86DB.w,X		; 7E DB 86 ; Rotate right $86DB.w,X [Reads: X Index] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $BC67.w,X		; 3D 67 BC ; AND accumulator with memory $BC67.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $00FC58.l,X		; BF 58 FC 00 ; Load long $00FC58.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $FCBF7F.l		; 0F 7F BF FC ; OR accumulator with memory (long) $FCBF7F.l [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $94.b,X		; F6 94 ; Increment memory $94.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	jsr ($B808.w,X)		; FC 08 B8 ; Jump to subroutine indirect indexed ($B808.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E61F00.l		; 22 00 1F E6 ; Jump to subroutine long $E61F00.l [Writes: Stack Pointer] [Flow: call]
	nop		; EA ; No operation
	pei ($C8.b)		; D4 C8 ; Push effective indirect address ($C8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($6F.b)		; 12 6F ; OR accumulator with memory (indirect) ($6F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $0C2F.w		; 2D 2F 0C ; Logical AND $0C2F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and [$04.b]		; 27 04 ; AND accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $043B01.l,X		; 1F 01 3B 04 ; Logical OR long $043B01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($33.b,S),Y		; 53 33 ; XOR accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1F2627.l,X		; 1F 27 26 1F ; Logical OR long $1F2627.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $3CE7.w,X		; BD E7 3C ; Load $3CE7.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $00FC98.l,X		; 7F 98 FC 00 ; Add long $00FC98.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr ($3444.w,X)		; FC 44 34 ; Jump to subroutine indirect indexed ($3444.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	jsl $3C012C.l		; 22 2C 01 3C ; Jump to subroutine long $3C012C.l [Writes: Stack Pointer] [Flow: call]
	trb $0022.w		; 1C 22 00 ; Test and reset bits $0022.w [Reads: Accumulator] [Flags: Z]
	tsb $1C3F.w		; 0C 3F 1C ; Test and set bits $1C3F.w [Reads: Accumulator] [Flags: Z]
	eor $304C25.l,X		; 5F 25 4C 30 ; Exclusive OR accumulator with memory (long,X) $304C25.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $3F20.w,X		; 7E 20 3F ; Rotate right $3F20.w,X [Reads: X Index] [Flags: ZNC]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $BD.b,S		; 83 BD ; Store accumulator (stack relative) $BD.b,S [Reads: Accumulator, Stack Pointer]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $737F.w,X		; 7E 7F 73 ; Rotate right $737F.w,X [Reads: X Index] [Flags: ZNC]
	and ($1F.b)		; 32 1F ; AND accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	tsb $E6.b		; 04 E6 ; Test and set bits $E6.b [Reads: Accumulator] [Flags: Z]
	jmp.w [$A4FE]		; DC FE A4 ; Jump long indirect [$A4FE] [Flow: jump]
	jsr ($F040.w,X)		; FC 40 F0 ; Jump to subroutine indirect indexed ($F040.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $7E3E.w,X		; FE 3E 7E ; Increment memory $7E3E.w,X [Reads: X Index] [Flags: ZN]
	jsr ($30F0.w,X)		; FC F0 30 ; Jump to subroutine indirect indexed ($30F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$27.b		; E0 27 ; Compare #$27.b with X register [Reads: X Index] [Flags: ZNC]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $01.b		; 64 01 ; Store zero to $01.b
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sta $72.b		; 85 72 ; Store accumulator to $72.b [Reads: Accumulator]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($273C.w,X)		; FC 3C 27 ; Jump to subroutine indirect indexed ($273C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $40.b,S		; 03 40 ; OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $FF		; B0 FF ; Branch if carry set to $B0, $FF [Flow: branch]
	jsr ($0029.w,X)		; FC 29 00 ; Jump to subroutine indirect indexed ($0029.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $70.b		; 05 70 ; Logical OR $70.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $B8		; 30 B8 ; Branch if minus to $30, $B8 [Flow: branch]
	.db $50, $24		; 50 24 ; Branch if overflow clear to $50, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3D.b		; 04 3D ; Test and set bits $3D.b [Reads: Accumulator] [Flags: Z]
	cop $7B.b		; 02 7B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $5F.b		; 24 5F ; Test bits $5F.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $000009.l		; 4F 09 00 00 ; Exclusive OR accumulator with memory (long) $000009.l [Writes: Accumulator] [Flags: ZN]
	tsb $2316.w		; 0C 16 23 ; Test and set bits $2316.w [Reads: Accumulator] [Flags: Z]
	eor $7767.w,X		; 5D 67 77 ; Exclusive OR accumulator with memory $7767.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$7E.b]		; 07 7E ; OR accumulator with memory (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FFFF.w,X		; 7E FF FF ; Rotate right $FFFF.w,X [Reads: X Index] [Flags: ZNC]
	bit $23FF.w,X		; 3C FF 23 ; Test bits $23FF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FF22.w,X		; 7E 22 FF ; Rotate right $FF22.w,X [Reads: X Index] [Flags: ZNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit #$64.b		; 89 64 ; Test bits #$64.b with accumulator [Reads: Accumulator] [Flags: Z]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($03.b)		; 72 03 ; Add with carry (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $7E.b		; 05 7E ; Logical OR $7E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FFFF.w,X		; 7E FF FF ; Rotate right $FFFF.w,X [Reads: X Index] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $7E.b		; 02 7E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0025FF.l,X		; FF FF 25 00 ; Subtract with carry (long,X) $0025FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $40BC.w		; 20 BC 40 ; Jump to subroutine at $40BC.w [Writes: Stack Pointer] [Flow: call]
	dec $FA24.w,X		; DE 24 FA ; Decrement memory $FA24.w,X [Reads: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $301C00.l		; 22 00 1C 30 ; Jump to subroutine long $301C00.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cpy $BA.b		; C4 BA ; Compare $BA.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	inc $38.b		; E6 38 ; Increment $38.b [Reads: Direct Page] [Flags: ZN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $5D.b,X		; 34 5D ; Test bits $5D.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ora ($5B.b)		; 12 5B ; OR accumulator with memory (indirect) ($5B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $4F.b		; 14 4F ; Test and reset bits $4F.b [Reads: Accumulator] [Flags: Z]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$1F.b		; 09 1F ; Logical OR #$1F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $6B4E.w,X		; 3C 4E 6B ; Test bits $6B4E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	adc $377F.w		; 6D 7F 37 ; Add $377F.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	ora $090025.l,X		; 1F 25 00 09 ; Logical OR long $090025.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	stx $BF70.w		; 8E 70 BF ; Store X register to $BF70.w [Reads: X Index]
	ror $FF3F.w,X		; 7E 3F FF ; Rotate right $FF3F.w,X [Reads: X Index] [Flags: ZNC]
	sty $22FF.w		; 8C FF 22 ; Store Y register to $22FF.w [Reads: Y Index]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $FE		; 70 FE ; Branch if overflow set to $70, $FE [Flow: branch]
	jsl $3083FF.l		; 22 FF 83 30 ; Jump to subroutine long $3083FF.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $44		; 10 44 ; Branch if plus to $10, $44 [Flow: branch]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $2C		; 10 2C ; Branch if plus to $10, $2C [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $4400.w		; 1C 00 44 ; Test and reset bits $4400.w [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $6600.w,X		; 3C 00 66 ; Test bits $6600.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $42, $C3		; 42 C3 ; Reserved instruction
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $C3FF.w,X		; BD FF C3 ; Load $C3FF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $30.b,S		; 83 30 ; Store accumulator (stack relative) $30.b,S [Reads: Accumulator, Stack Pointer]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($0110.w)		; 6C 10 01 ; Jump indirect to ($0110.w) [Flow: jump]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	and $54.b		; 25 54 ; Logical AND $54.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $007F00.l,X		; 3F 00 7F 00 ; AND accumulator with memory (long,X) $007F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: ZNC]
	adc $243F00.l,X		; 7F 00 3F 24 ; Add long $243F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $40BF40.l,X		; 3F 40 BF 40 ; AND accumulator with memory (long,X) $40BF40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $02CF8C.l,X		; 3F 8C CF 02 ; AND accumulator with memory (long,X) $02CF8C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E08500.l		; 22 00 85 E0 ; Jump to subroutine long $E08500.l [Writes: Stack Pointer] [Flow: call]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit #$E8.b		; 89 E8 ; Test bits #$E8.b with accumulator [Reads: Accumulator] [Flags: Z]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sty $F870.w		; 8C 70 F8 ; Store Y register to $F870.w [Reads: Y Index]
	sta $F7.b		; 85 F7 ; Store accumulator to $F7.b [Reads: Accumulator]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$E4.b]		; 27 E4 ; AND accumulator with memory (long) [$E4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $E2F8.w		; 8C F8 E2 ; Store Y register to $E2F8.w [Reads: Y Index]
	ora ($EF.b,X)		; 01 EF ; Logical OR ($EF.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $18FF.w		; 0E FF 18 ; Arithmetic shift left $18FF.w [Flags: ZNC]
	ror $7D01.w,X		; 7E 01 7D ; Rotate right $7D01.w,X [Reads: X Index] [Flags: ZNC]
	and ($7B.b,S),Y		; 33 7B ; AND accumulator (stack relative indirect indexed) ($7B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $41.b		; 05 41 ; Logical OR $41.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $003E.w,X		; 3E 3E 00 ; Rotate left $003E.w,X [Reads: X Index] [Flags: ZNC]
	sbc $7FA7B1.l,X		; FF B1 A7 7F ; Subtract with carry (long,X) $7FA7B1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $3E417B.l,X		; 7F 7B 41 3E ; Add long $3E417B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldy #$F4.b		; A0 F4 ; Load #$F4.b into Y register [Writes: Y Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cpx $7E58.w		; EC 58 7E ; Compare $7E58.w with X register [Reads: X Index] [Flags: ZNC]
	ldy $D4EE.w		; AC EE D4 ; Load $D4EE.w into Y register [Writes: Y Index] [Flags: ZN]
	jsr ($8080.w,X)		; FC 80 80 ; Jump to subroutine indirect indexed ($8080.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $F80600.l		; 22 00 06 F8 ; Jump to subroutine long $F80600.l [Writes: Stack Pointer] [Flow: call]
	jsr ($FEFC.w,X)		; FC FC FE ; Jump to subroutine indirect indexed ($FEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $80FC.w		; EE FC 80 ; Increment $80FC.w [Flags: ZN]
	sta $E3.b,S		; 83 E3 ; Store accumulator (stack relative) $E3.b,S [Reads: Accumulator, Stack Pointer]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $19.b,S		; 83 19 ; Store accumulator (stack relative) $19.b,S [Reads: Accumulator, Stack Pointer]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$1F.b],Y		; 37 1F ; AND accumulator with memory (long indexed) [$1F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $020707.l		; 0F 07 07 02 ; OR accumulator with memory (long) $020707.l [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sta $AF.b,S		; 83 AF ; Store accumulator (stack relative) $AF.b,S [Reads: Accumulator, Stack Pointer]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $817E3C.l,X		; FF 3C 7E 81 ; Subtract with carry (long,X) $817E3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $C03C3C.l,X		; FF 3C 3C C0 ; Subtract with carry (long,X) $C03C3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$4F.b		; E0 4F ; Compare #$4F.b with X register [Reads: X Index] [Flags: ZNC]
	ora #$87.b		; 09 87 ; Logical OR #$87.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: ZNC]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $770000.l		; 22 00 00 77 ; Jump to subroutine long $770000.l [Writes: Stack Pointer] [Flow: call]
	sta $F0.b,S		; 83 F0 ; Store accumulator (stack relative) $F0.b,S [Reads: Accumulator, Stack Pointer]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C7FF83.l,X		; FF 83 FF C7 ; Subtract with carry (long,X) $C7FF83.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($3BFF.w,X)		; FC FF 3B ; Jump to subroutine indirect indexed ($3BFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $C6.b		; 84 C6 ; Store Y register to $C6.b [Reads: Y Index]
	lda $1AFD.w,X		; BD FD 1A ; Load $1AFD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $FF2400.l,X		; 3F 00 24 FF ; AND accumulator with memory (long,X) $FF2400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	inc $3FFD.w,X		; FE FD 3F ; Increment memory $3FFD.w,X [Reads: X Index] [Flags: ZN]
	sbc ($90.b)		; F2 90 ; Subtract with carry (indirect) ($90.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	pea $F890.w		; F4 90 F8 ; Push absolute address $F890.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $50, $A0		; 50 A0 ; Branch if overflow clear to $50, $A0 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $E0C0.w		; 20 C0 E0 ; Jump to subroutine at $E0C0.w [Writes: Stack Pointer] [Flow: call]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $F0F8.w		; EC F8 F0 ; Compare $F0F8.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	ora [$87.b]		; 07 87 ; OR accumulator with memory (long) [$87.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $23.b,S		; 83 23 ; Store accumulator (stack relative) $23.b,S [Reads: Accumulator, Stack Pointer]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($FF.b,X)		; C1 FF ; Compare accumulator ($FF.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc ($3F.b,S),Y		; F3 3F ; Subtract with carry (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $B1CE8C.l,X		; 7F 8C CE B1 ; Add long $B1CE8C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($3D.b,S),Y		; F3 3D ; Subtract with carry (stack relative indirect indexed) ($3D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $031C18.l,X		; 7F 18 1C 03 ; Add long $031C18.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $7F.b		; 04 7F ; Test and set bits $7F.b [Reads: Accumulator] [Flags: Z]
	trb $3807.w		; 1C 07 38 ; Test and reset bits $3807.w [Reads: Accumulator] [Flags: Z]
	brk $4D.b		; 00 4D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	rol $28.b		; 26 28 ; Rotate left $28.b [Reads: Direct Page] [Flags: ZNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0027FF.l,X		; 7F FF 27 00 ; Add long $0027FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: ZNC]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $4324.w,X		; BD 24 43 ; Load $4324.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $0418.w,X		; BD 18 04 ; Load $0418.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	jsl $660EC3.l		; 22 C3 0E 66 ; Jump to subroutine long $660EC3.l [Writes: Stack Pointer] [Flow: call]
	bit $0018.w,X		; 3C 18 00 ; Test bits $0018.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	mvp $28,$38		; 44 38 28 ; Move block positive $28,$38 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($05.b)		; D4 05 ; Push effective indirect address ($05.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($387C.w)		; 6C 7C 38 ; Jump indirect to ($387C.w) [Flow: jump]
	jmp ($2844.w,X)		; 7C 44 28 ; Jump indirect indexed to ($2844.w,X) [Reads: X Index] [Flow: jump]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	brk $08.b		; [PATTERN: Memory clearing operation] 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $9A00.w		; EC 00 9A ; Compare $9A00.w with X register [Reads: X Index] [Flags: ZNC]
	stz $C9.b		; 64 C9 ; Store zero to $C9.b
	rol $9A.b,X		; 36 9A ; Rotate left $9A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	stz $EC.b		; 64 EC ; Store zero to $EC.b
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $EC.b		; 05 EC ; Logical OR $EC.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	and $EC7A.w,Y		; 39 7A EC ; AND accumulator with memory $EC7A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: ZNC]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	ora $251F1F.l		; 0F 1F 1F 25 ; OR accumulator with memory (long) $251F1F.l [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpx #$38.b		; E0 38 ; Compare #$38.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($22F0.w,X)		; FC F0 22 ; Jump to subroutine indirect indexed ($22F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($25FC.w,X)		; FC FC 25 ; Jump to subroutine indirect indexed ($25FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3F0F1C.l		; 0F 1C 0F 3F ; OR accumulator with memory (long) $3F0F1C.l [Writes: Accumulator] [Flags: ZN]
	ora $040022.l		; 0F 22 00 04 ; OR accumulator with memory (long) $040022.l [Writes: Accumulator] [Flags: ZN]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	ora $253F1F.l,X		; 1F 1F 3F 25 ; Logical OR long $253F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $60.b,X		; 34 60 ; Test bits $60.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0C3C03.l		; 0F 03 3C 0C ; OR accumulator with memory (long) $0C3C03.l [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($000C.w,X)		; FC 0C 00 ; Jump to subroutine indirect indexed ($000C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($57.b,S),Y		; 33 57 ; AND accumulator (stack relative indirect indexed) ($57.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda [$97.b]		; A7 97 ; Load accumulator (long) [$97.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta ($00.b,S),Y		; 93 00 ; Store accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$7C.b		; C0 7C ; Compare #$7C.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	.db $10, $4F		; 10 4F ; Branch if plus to $10, $4F [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $8C		; 30 8C ; Branch if minus to $30, $8C [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	lda $E9.b,X		; B5 E9 ; Load $E9.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $6083.w,Y		; F9 83 60 ; Subtract with carry $6083.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $073F03.l,X		; 1F 03 3F 07 ; Logical OR long $073F03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($7804.w,X)		; 7C 04 78 ; Jump indirect indexed to ($7804.w,X) [Reads: X Index] [Flow: jump]
	mvp $F8,$08		; 44 08 F8 ; Move block positive $F8,$08 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	eor [$97.b],Y		; 57 97 ; Exclusive OR accumulator with memory (long indexed) [$97.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta [$83.b],Y		; 97 83 ; Store accumulator (long indexed) [$83.b],Y [Reads: Accumulator, Direct Page, Y Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$7C.b		; C0 7C ; Compare #$7C.b with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ror $FE20.w,X		; 7E 20 FE ; Rotate right $FE20.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $5F		; 10 5F ; Branch if plus to $10, $5F [Flow: branch]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cpy #$38.b		; C0 38 ; Compare #$38.b with Y register [Reads: Y Index] [Flags: ZNC]
	sty $92.b,X		; 94 92 ; Store Y register $92.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	lda #$E9.b		; A9 E9 ; Load #$E9.b into accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $103F00.l,X		; 1F 00 3F 10 ; Logical OR long $103F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $609F30.l,X		; 7F 30 9F 60 ; Add long $609F30.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	wai		; CB ; Wait for interrupt
	stz $FF.b,X		; 74 FF ; Store zero to $FF.b,X [Reads: X Index]
	adc ($00.b,X)		; 61 00 ; Add with carry ($00.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $FFFF7F.l,X		; 3F 7F FF FF ; AND accumulator with memory (long,X) $FFFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $83.b,X		; F6 83 ; Increment memory $83.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	trb $E000.w		; 1C 00 E0 ; Test and reset bits $E000.w [Reads: Accumulator] [Flags: Z]
	ror $F8.b,X		; 76 F8 ; Rotate right $F8.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	tsb $0EF1.w		; 0C F1 0E ; Test and set bits $0EF1.w [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $84FF.w		; 0E FF 84 ; Arithmetic shift left $84FF.w [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FFFE.w,X)		; FC FE FF ; Jump to subroutine indirect indexed ($FFFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp $00304F.l,X		; DF 4F 30 00 ; Compare accumulator (long,X) $00304F.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	jmp ($6F30.w,X)		; 7C 30 6F ; Jump indirect indexed to ($6F30.w,X) [Reads: X Index] [Flow: jump]
	.db $30, $CB		; 30 CB ; Branch if minus to $30, $CB [Flow: branch]
	stz $E7.b,X		; 74 E7 ; Store zero to $E7.b,X [Reads: X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($BF38.w,X)		; FC 38 BF ; Jump to subroutine indirect indexed ($BF38.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lsr $5E.b		; 46 5E ; Logical shift right $5E.b [Reads: Direct Page] [Flags: ZNC]
	and #$30.b		; 29 30 ; Logical AND #$30.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jmp ($F97B.w,X)		; 7C 7B F9 ; Jump indirect indexed to ($F97B.w,X) [Reads: X Index] [Flow: jump]
	sbc $5EB9FF.l,X		; FF FF B9 5E ; Subtract with carry (long,X) $5EB9FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $3A00.w		; 0C 00 3A ; Test and set bits $3A00.w [Reads: Accumulator] [Flags: Z]
	tsb $16EB.w		; 0C EB 16 ; Test and set bits $16EB.w [Reads: Accumulator] [Flags: Z]
	sta ($8E.b,S),Y		; 93 8E ; Store accumulator (stack relative indirect indexed) ($8E.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	cmp [$CE.b],Y		; D7 CE ; Compare accumulator (long indexed) [$CE.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sbc $A27D18.l		; EF 18 7D A2 ; Subtract with carry (long) $A27D18.l [Writes: Accumulator] [Flags: ZVNC]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	stz $0C.b,X		; 74 0C ; Store zero to $0C.b,X [Reads: X Index]
	rol $7FEF.w,X		; 3E EF 7F ; Rotate left $7FEF.w,X [Reads: X Index] [Flags: ZNC]
	and $FA7DFF.l,X		; 3F FF 7D FA ; AND accumulator with memory (long,X) $FA7DFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $66		; 10 66 ; Branch if plus to $10, $66 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	adc ($3D.b,S),Y		; 73 3D ; Add with carry (stack relative indirect indexed) ($3D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	trb $65FF.w		; 1C FF 65 ; Test and reset bits $65FF.w [Reads: Accumulator] [Flags: Z]
	lda [$58.b],Y		; B7 58 ; Load accumulator (long indexed) [$58.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	and $7B10.w		; 2D 10 7B ; Logical AND $7B10.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $FF7E.w,X		; 7D 7E FF ; Add $FF7E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $5EBF.w,X		; FE BF 5E ; Increment memory $5EBF.w,X [Reads: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $3C66.w,X		; 3C 66 3C ; Test bits $3C66.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $82BF38.l,X		; FF 38 BF 82 ; Subtract with carry (long,X) $82BF38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $3A.b		; E5 3A ; Subtract $3A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $08.b,X		; 34 08 ; Test bits $08.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ldx $FEFE.w,Y		; BE FE FE ; Load X register $FEFE.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sbc $FAFD7F.l,X		; FF 7F FD FA ; Subtract with carry (long,X) $FAFD7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $C383.w		; 0E 83 C3 ; Arithmetic shift left $C383.w [Flags: ZNC]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $01FF.w		; 0C FF 01 ; Test and set bits $01FF.w [Reads: Accumulator] [Flags: Z]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $DB.b,S		; 83 DB ; Store accumulator (stack relative) $DB.b,S [Reads: Accumulator, Stack Pointer]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FF.b,X		; 16 FF ; Arithmetic shift left $FF.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $70, $88		; 70 88 ; Branch if overflow set to $70, $88 [Flow: branch]
	mvp $06,$2A		; 44 2A 06 ; Move block positive $06,$2A [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $82, $61, $1B		; 82 61 1B ; Branch always long to $82, $61, $1B [Flow: branch]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $070F09.l,X		; 1F 09 0F 07 ; Logical OR long $070F09.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1E1C1B.l,X		; 1F 1B 1C 1E ; Logical OR long $1E1C1B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor $34.b,S		; 43 34 ; Exclusive OR accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $F898.w		; 9C 98 F8 ; Store zero to $F898.w
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	jsl $F80600.l		; 22 00 06 F8 ; Jump to subroutine long $F80600.l [Writes: Stack Pointer] [Flow: call]
	sty $DC.b		; 84 DC ; Store Y register to $DC.b [Reads: Y Index]
	jmp.w [$1864]		; DC 64 18 ; Jump long indirect [$1864] [Flow: jump]
	cpx #$43.b		; E0 43 ; Compare #$43.b with X register [Reads: X Index] [Flags: ZNC]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $10.b,X		; 36 10 ; Rotate left $10.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	asl $1C08.w,X		; 1E 08 1C ; Arithmetic shift left $1C08.w,X [Reads: X Index] [Flags: ZNC]
	tsb $030F.w		; 0C 0F 03 ; Test and set bits $030F.w [Reads: Accumulator] [Flags: Z]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $132B38.l,X		; 3F 38 2B 13 ; AND accumulator with memory (long,X) $132B38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$80.b		; 09 80 ; Logical OR #$80.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jmp ($7808.w)		; 6C 08 78 ; Jump indirect to ($7808.w) [Flow: jump]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $44E000.l		; 22 00 E0 44 ; Jump to subroutine long $44E000.l [Writes: Stack Pointer] [Flow: call]
	jsr ($D41C.w,X)		; FC 1C D4 ; Jump to subroutine indirect indexed ($D41C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3A3577.l,X		; 1F 77 35 3A ; Logical OR long $3A3577.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $3B		; 10 3B ; Branch if plus to $10, $3B [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $011F08.l,X		; 1F 08 1F 01 ; Logical OR long $011F08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000800.l,X		; 1F 00 08 00 ; Logical OR long $000800.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldy #$4A.b		; A0 4A ; Load #$4A.b into Y register [Writes: Y Index] [Flags: ZN]
	and $101024.l		; 2F 24 10 10 ; AND accumulator with memory (long) $101024.l [Writes: Accumulator] [Flags: ZN]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $A4E618.l,X		; 1F 18 E6 A4 ; Logical OR long $A4E618.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	mvn $9C,$00		; 54 00 9C ; Move block negative $9C,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsr ($0864.w,X)		; FC 64 08 ; Jump to subroutine indirect indexed ($0864.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $FC		; 10 FC ; Branch if plus to $10, $FC [Flow: branch]
	tsb $0C7C.w		; 0C 7C 0C ; Test and set bits $0C7C.w [Reads: Accumulator] [Flags: Z]
	ror $3F1E.w,X		; 7E 1E 3F ; Rotate right $3F1E.w,X [Reads: X Index] [Flags: ZNC]
	ora $0F0D1F.l,X		; 1F 1F 0D 0F ; Logical OR long $0F0D1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $931400.l		; 22 00 14 93 ; Jump to subroutine long $931400.l [Writes: Stack Pointer] [Flow: call]
	eor ($61.b,S),Y		; 53 61 ; XOR accumulator (stack relative indirect indexed) ($61.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $0C12.w		; 20 12 0C ; Jump to subroutine at $0C12.w [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $101E10.l,X		; 3F 10 1E 10 ; AND accumulator with memory (long,X) $101E10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $CC08.w		; 0E 08 CC ; Arithmetic shift left $CC08.w [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $54E000.l		; 22 00 E0 54 ; Jump to subroutine long $54E000.l [Writes: Stack Pointer] [Flow: call]
	cmp #$EA.b		; C9 EA ; Compare #$EA.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	inc $34.b,X		; F6 34 ; Increment memory $34.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $65.b		; 00 65 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $10, $BF		; 10 BF ; Branch if plus to $10, $BF [Flow: branch]
	lsr $BF.b		; 46 BF ; Logical shift right $BF.b [Reads: Direct Page] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	bit #$76.b		; 89 76 ; Test bits #$76.b with accumulator [Reads: Accumulator] [Flags: Z]
	adc [$18.b]		; 67 18 ; Add with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $000700.l,X		; 3F 00 07 00 ; AND accumulator with memory (long,X) $000700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $CFD97F.l,X		; 7F 7F D9 CF ; Add long $CFD97F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $3F7F.w,Y		; F9 7F 3F ; Subtract with carry $3F7F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$9E.b]		; 07 9E ; OR accumulator with memory (long) [$9E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $62, $D3, $2C		; 62 D3 2C ; Push effective relative address $62, $D3, $2C [Writes: Stack Pointer]
	sbc $6D02.w,X		; FD 02 6D ; Subtract with carry $6D02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta ($21.b)		; 92 21 ; Store accumulator (indirect) ($21.b) [Reads: Accumulator, Direct Page]
	dec $58A6.w,X		; DE A6 58 ; Decrement memory $58A6.w,X [Reads: X Index] [Flags: ZN]
	jsr ($E000.w,X)		; FC 00 E0 ; Jump to subroutine indirect indexed ($E000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3F33FB.l,X		; FF FB 33 3F ; Subtract with carry (long,X) $3F33FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $E0FC.w,Y		; BE FC E0 ; Load X register $E0FC.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $C5.b,S		; 03 C5 ; OR accumulator with stack relative $C5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $63.b		; 02 63 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	tsb $04DA.w		; 0C DA 04 ; Test and set bits $04DA.w [Reads: Accumulator] [Flags: Z]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	cpx $00.b		; E4 00 ; Compare $00.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $123B.w,X		; 7D 3B 12 ; Add $123B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $10EC.w		; 0C EC 10 ; Test and set bits $10EC.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $2A		; F0 2A ; Branch if equal to $F0, $2A [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($8C.b)		; F2 8C ; Subtract with carry (indirect) ($8C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $3331.w		; 4E 31 33 ; Logical shift right $3331.w [Flags: ZNC]
	tsb $020C.w		; 0C 0C 02 ; Test and set bits $020C.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($0D.b,S),Y		; 33 0D ; AND accumulator (stack relative indirect indexed) ($0D.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $140022.l		; 0F 22 00 14 ; OR accumulator with memory (long) $140022.l [Writes: Accumulator] [Flags: ZN]
	adc ($0C.b)		; 72 0C ; Add with carry (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpy $3030.w		; CC 30 30 ; Compare $3030.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $70F0.w		; CC F0 70 ; Compare $70F0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $F806FE.l		; 2F FE 06 F8 ; AND accumulator with memory (long) $F806FE.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $F808.w,X		; FE 08 F8 ; Increment memory $F808.w,X [Reads: X Index] [Flags: ZN]
	.db $10, $FB		; 10 FB ; Branch if plus to $10, $FB [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $034F0A.l,X		; FF 0A 4F 03 ; Subtract with carry (long,X) $034F0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit #$97.b		; 89 97 ; Test bits #$97.b with accumulator [Reads: Accumulator] [Flags: Z]
	cmp [$AF.b],Y		; D7 AF ; Compare accumulator (long indexed) [$AF.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	ldy $B5.b		; A4 B5 ; Load $B5.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	jmp $7F03.w		; 4C 03 7F ; Jump to $7F03.w [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $107F10.l,X		; 1F 10 7F 10 ; Logical OR long $107F10.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $080F08.l,X		; 1F 08 0F 08 ; Logical OR long $080F08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $80B210.l,X		; BF 10 B2 80 ; Load long $80B210.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	sta $E9ED.w,Y		; 99 ED E9 ; Store accumulator to $E9ED.w,Y [Reads: Accumulator, Y Index]
	sbc $F5.b,X		; F5 F5 ; Subtract $F5.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $C072.w		; ED 72 C0 ; Subtract $C072.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $37		; 30 37 ; Branch if minus to $30, $37 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $100400.l		; 22 00 04 10 ; Jump to subroutine long $100400.l [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	adc [$38.b],Y		; 77 38 ; Add with carry (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $E2.b		; 14 E2 ; Test and reset bits $E2.b [Reads: Accumulator] [Flags: Z]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	bit #$C0.b		; 89 C0 ; Test bits #$C0.b with accumulator [Reads: Accumulator] [Flags: Z]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $609F70.l,X		; DF 70 9F 60 ; Compare accumulator (long,X) $609F70.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sta $D08571.l,X		; 9F 71 85 D0 ; Store accumulator (long,X) $D08571.l,X [Reads: Accumulator, X Index]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sta $1C.b,S		; 83 1C ; Store accumulator (stack relative) $1C.b,S [Reads: Accumulator, Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($8600.w,X)		; FC 00 86 ; Jump to subroutine indirect indexed ($8600.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	.db $82, $00, $E0		; 82 00 E0 ; Branch always long to $82, $00, $E0 [Flow: branch]
	jsr ($FFFE.w,X)		; FC FE FF ; Jump to subroutine indirect indexed ($FFFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $254DDF.l,X		; FF DF 4D 25 ; Subtract with carry (long,X) $254DDF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $014E00.l,X		; 3F 00 4E 01 ; AND accumulator with memory (long,X) $014E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lsr $7F11.w,X		; 5E 11 7F ; Logical shift right $7F11.w,X [Reads: X Index] [Flags: ZNC]
	and ($3F.b),Y		; 31 3F ; AND accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $7B3F.w		; 1C 3F 7B ; Test and reset bits $7B3F.w [Reads: Accumulator] [Flags: Z]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $0A000C.l,X		; 3F 0C 00 0A ; AND accumulator with memory (long,X) $0A000C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc [$3A.b]		; E7 3A ; Subtract with carry (long) [$3A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $DC.b,S		; 63 DC ; Add with carry (stack relative) $DC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($DC.b)		; F2 DC ; Subtract with carry (indirect) ($DC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$98.b],Y		; F7 98 ; Subtract with carry (long indexed) [$98.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0E0C08.l,X		; FF 08 0C 0E ; Subtract with carry (long,X) $0E0C08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FEFFFF.l,X		; 1F FF FF FE ; Logical OR long $FEFFFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $23DD.w,X		; FD DD 23 ; Subtract with carry $23DD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $5700.w,X		; 3C 00 57 ; Test bits $5700.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp ($3D28.w,X)		; 7C 28 3D ; Jump indirect indexed to ($3D28.w,X) [Reads: X Index] [Flow: jump]
	ora #$0F.b		; 09 0F ; Logical OR #$0F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0C3E5F.l,X		; 7F 5F 3E 0C ; Add long $0C3E5F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0F0023.l		; 0F 23 00 0F ; OR accumulator with memory (long) $0F0023.l [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	lda ($4C.b)		; B2 4C ; Load accumulator (indirect) ($4C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stz $DE.b,X		; 74 DE ; Store zero to $DE.b,X [Reads: X Index]
	jmp ($38FC.w,X)		; 7C FC 38 ; Jump indirect indexed to ($38FC.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($FE22.w,X)		; FC 22 FE ; Jump to subroutine indirect indexed ($FE22.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$30.b		; E0 30 ; Compare #$30.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($0008.w,X)		; FC 08 00 ; Jump to subroutine indirect indexed ($0008.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	ora #$1E.b		; 09 1E ; Logical OR #$1E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $0808.w,X		; 3E 08 08 ; Rotate left $0808.w,X [Reads: X Index] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $091A.w		; 4D 1A 09 ; Exclusive OR $091A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $10, $15		; 10 15 ; Branch if plus to $10, $15 [Flow: branch]
	and $F8.b,X		; 35 F8 ; Logical AND $F8.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	jsr ($F47E.w,X)		; FC 7E F4 ; Jump to subroutine indirect indexed ($F47E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pea $F420.w		; F4 20 F4 ; Push absolute address $F420.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $141E.w		; CC 1E 14 ; Compare $141E.w with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $32DC.w,X		; 3C DC 32 ; Test bits $32DC.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	nop		; EA ; No operation
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $77		; 30 77 ; Branch if minus to $30, $77 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	adc [$78.b],Y		; 77 78 ; Add with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $10EE.w		; 0C EE 10 ; Test and set bits $10EE.w [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $EE.b		; 14 EE ; Test and reset bits $EE.b [Reads: Accumulator] [Flags: Z]
	asl $0007.w,X		; 1E 07 00 ; Arithmetic shift left $0007.w,X [Reads: X Index] [Flags: ZNC]
	ora $0C1300.l		; 0F 00 13 0C ; OR accumulator with memory (long) $0C1300.l [Writes: Accumulator] [Flags: ZN]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $2706.w,Y		; 39 06 27 ; AND accumulator with memory $2706.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $3C1D.w		; 0C 1D 3C ; Test and set bits $3C1D.w [Reads: Accumulator] [Flags: Z]
	and $7F3F3E.l,X		; 3F 3E 3F 7F ; AND accumulator with memory (long,X) $7F3F3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$21.b		; E0 21 ; Compare #$21.b with X register [Reads: X Index] [Flags: ZNC]
	ror $E080.w,X		; 7E 80 E0 ; Rotate right $E080.w,X [Reads: X Index] [Flags: ZNC]
	.db $90, $08		; 90 08 ; Branch if carry clear to $90, $08 [Flow: branch]
	trb $E4.b		; 14 E4 ; Test and reset bits $E4.b [Reads: Accumulator] [Flags: Z]
	trb $9EE4.w		; 1C E4 9E ; Test and reset bits $9EE4.w [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $EB		; 10 EB ; Branch if plus to $10, $EB [Flow: branch]
	trb $FD.b		; 14 FD ; Test and reset bits $FD.b [Reads: Accumulator] [Flags: Z]
	adc ($77.b)		; 72 77 ; Add with carry (indirect) ($77.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	bit $2E.b		; 24 2E ; Test bits $2E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $001C.w		; 0C 1C 00 ; Test and set bits $001C.w [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($898A.w,X)		; FC 8A 89 ; Jump to subroutine indirect indexed ($898A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $327B.w,X		; FD 7B 32 ; Subtract with carry $327B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $6883.w		; 1C 83 68 ; Test and reset bits $6883.w [Reads: Accumulator] [Flags: Z]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr ($9E00.w,X)		; FC 00 9E ; Jump to subroutine indirect indexed ($9E00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $BB		; 10 BB ; Branch if plus to $10, $BB [Flow: branch]
	bit $79.b,X		; 34 79 ; Test bits $79.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	asl $12.b		; 06 12 ; Arithmetic shift left $12.b [Reads: Direct Page] [Flags: ZNC]
	tsb $220C.w		; 0C 0C 22 ; Test and set bits $220C.w [Reads: Accumulator] [Flags: Z]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($C9EA.w,X)		; 7C EA C9 ; Jump indirect indexed to ($C9EA.w,X) [Reads: X Index] [Flow: jump]
	adc $0C12.w,Y		; 79 12 0C ; Add $0C12.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	ora #$13.b		; 09 13 ; Logical OR #$13.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0F10.w		; 0E 10 0F ; Arithmetic shift left $0F10.w [Flags: ZNC]
	ora $001F0E.l,X		; 1F 0E 1F 00 ; Logical OR long $001F0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000E0E.l,X		; 1F 0E 0E 00 ; Logical OR long $000E0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $1F24.w		; 1C 24 1F ; Test and reset bits $1F24.w [Reads: Accumulator] [Flags: Z]
	tsb $0E11.w		; 0C 11 0E ; Test and set bits $0E11.w [Reads: Accumulator] [Flags: Z]
	stz $3260.w,X		; 9E 60 32 ; Store zero to $3260.w,X [Reads: X Index]
	.db $D0, $FA		; D0 FA ; Branch if not equal to $D0, $FA [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($FCE0.w,X)		; FC E0 FC ; Jump to subroutine indirect indexed ($FCE0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($7E.b),Y		; 11 7E ; OR accumulator with memory ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $FCE6.w		; EE E6 FC ; Increment $FCE6.w [Flags: ZN]
	cpx $78.b		; E4 78 ; Compare $78.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $F976.w,Y		; 99 76 F9 ; Store accumulator to $F976.w,Y [Reads: Accumulator, Y Index]
	asl $FB.b		; 06 FB ; Arithmetic shift left $FB.b [Reads: Direct Page] [Flags: ZNC]
	stz $CF.b,X		; 74 CF ; Store zero to $CF.b,X [Reads: X Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cmp $8546.w,Y		; D9 46 85 ; Compare accumulator $8546.w,Y [Reads: Y Index] [Flags: ZNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BF8FFF.l,X		; FF FF 8F BF ; Subtract with carry (long,X) $BF8FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $3F7F.w,Y		; B9 7F 3F ; Load $3F7F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$9F.b]		; 07 9F ; OR accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp ($8C.b)		; D2 8C ; Compare accumulator (indirect) ($8C.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $6A85FE.l		; EF FE 85 6A ; Subtract with carry (long) $6A85FE.l [Writes: Accumulator] [Flags: ZVNC]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$03.b]		; 27 03 ; AND accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $FB, $44		; 82 FB 44 ; Branch always long to $82, $FB, $44 [Flow: branch]
	adc $6A.b,X		; 75 6A ; Add $6A.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $20,$DE		; 44 DE 20 ; Move block positive $20,$DE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cmp [$BF.b]		; C7 BF ; Compare accumulator (long) [$BF.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta $DEBB.w,X		; 9D BB DE ; Store accumulator to $DEBB.w,X [Reads: Accumulator, X Index]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	eor $0B.b,S		; 43 0B ; Exclusive OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$2A.b		; E0 2A ; Compare #$2A.b with X register [Reads: X Index] [Flags: ZNC]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0307.w		; 0E 07 03 ; Arithmetic shift left $0307.w [Flags: ZNC]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cpy $E6.b		; C4 E6 ; Compare $E6.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ldy $2040.w,X		; BC 40 20 ; Load Y register $2040.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $663BFF.l,X		; 1F FF 3B 66 ; Logical OR long $663BFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldy $C020.w,X		; BC 20 C0 ; Load Y register $C020.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	lsr $06.b		; 46 06 ; Logical shift right $06.b [Reads: Direct Page] [Flags: ZNC]
	bit $3F1C.w,X		; 3C 1C 3F ; Test bits $3F1C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000703.l		; 0F 03 07 00 ; OR accumulator with memory (long) $000703.l [Writes: Accumulator] [Flags: ZN]
	adc $2323.w,Y		; 79 23 23 ; Add $2323.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0C170F.l,X		; 1F 0F 17 0C ; Logical OR long $0C170F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$7E.b]		; 07 7E ; OR accumulator with memory (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp ($B8FC.w,X)		; 7C FC B8 ; Jump indirect indexed to ($B8FC.w,X) [Reads: X Index] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $D8		; 30 D8 ; Branch if minus to $30, $D8 [Flow: branch]
	.db $50, $98		; 50 98 ; Branch if overflow clear to $50, $98 [Flow: branch]
	.db $90, $85		; 90 85 ; Branch if carry clear to $90, $85 [Flow: branch]
	.db $D0, $01		; D0 01 ; Branch if not equal to $D0, $01 [Flow: branch]
	trb $82.b		; 14 82 ; Test and reset bits $82.b [Reads: Accumulator] [Flags: Z]
	mvp $A8,$C8		; 44 C8 A8 ; Move block positive $A8,$C8 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tsb $5C.b		; 04 5C ; Test and set bits $5C.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	adc ($1C.b,S),Y		; 73 1C ; Add with carry (stack relative indirect indexed) ($1C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $3E023F.l,X		; 1F 3F 02 3E ; Logical OR long $3E023F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $221C.w		; 1C 1C 22 ; Test and reset bits $221C.w [Reads: Accumulator] [Flags: Z]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($7F7F.w,X)		; 7C 7F 7F ; Jump indirect indexed to ($7F7F.w,X) [Reads: X Index] [Flow: jump]
	and $1C223F.l,X		; 3F 3F 22 1C ; AND accumulator with memory (long,X) $1C223F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $D2.b		; 00 D2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C03A.w		; 20 3A C0 ; Jump to subroutine at $C03A.w [Writes: Stack Pointer] [Flow: call]
	inc $FC30.w,X		; FE 30 FC ; Increment memory $FC30.w,X [Reads: X Index] [Flags: ZN]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp ($3838.w,X)		; 7C 38 38 ; Jump indirect indexed to ($3838.w,X) [Reads: X Index] [Flow: jump]
	jsl $37E000.l		; 22 00 E0 37 ; Jump to subroutine long $37E000.l [Writes: Stack Pointer] [Flow: call]
	rol $FEFE.w,X		; 3E FE FE ; Rotate left $FEFE.w,X [Reads: X Index] [Flags: ZNC]
	jsr ($44FC.w,X)		; FC FC 44 ; Jump to subroutine indirect indexed ($44FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cmp [$41.b],Y		; D7 41 ; Compare accumulator (long indexed) [$41.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	inc $7E68.w		; EE 68 7E ; Increment $7E68.w [Flags: ZN]
	.db $10, $39		; 10 39 ; Branch if plus to $10, $39 [Flow: branch]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $6B93.w,Y		; BE 93 6B ; Load X register $6B93.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	and $030D1F.l,X		; 3F 1F 0D 03 ; AND accumulator with memory (long,X) $030D1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $ED10.w,Y		; F9 10 ED ; Subtract with carry $ED10.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $77.b		; 84 77 ; Store Y register to $77.b [Reads: Y Index]
	asl $7E.b,X		; 16 7E ; Arithmetic shift left $7E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $F800.w		; 9C 00 F8 ; Store zero to $F800.w
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $D6C97B.l		; EF 7B C9 D6 ; Subtract with carry (long) $D6C97B.l [Writes: Accumulator] [Flags: ZVNC]
	jsr ($B0F8.w,X)		; FC F8 B0 ; Jump to subroutine indirect indexed ($B0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$83.b		; C0 83 ; Compare #$83.b with Y register [Reads: Y Index] [Flags: ZNC]
	eor ($01.b)		; 52 01 ; Exclusive OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $F1.b		; 06 F1 ; Arithmetic shift left $F1.b [Reads: Direct Page] [Flags: ZNC]
	asl $9FE0.w		; 0E E0 9F ; Arithmetic shift left $9FE0.w [Flags: ZNC]
	cpy $BF.b		; C4 BF ; Compare $BF.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	cmp $7F43.w		; CD 43 7F ; Compare $7F43.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	sbc $0E0005.l,X		; FF 05 00 0E ; Subtract with carry (long,X) $0E0005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($EE.b),Y		; 11 EE ; OR accumulator with memory ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $FF227F.l,X		; 5F 7F 22 FF ; Exclusive OR accumulator with memory (long,X) $FF227F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $42, $00		; 42 00 ; Reserved instruction
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda $1842.w,X		; BD 42 18 ; Load $1842.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$20.b]		; E7 20 ; Subtract with carry (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF2374.l,X		; FF 74 23 FF ; Subtract with carry (long,X) $FF2374.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	.db $42, $A5		; 42 A5 ; Reserved instruction
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc [$23.b]		; E7 23 ; Subtract with carry (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $48E0FF.l,X		; FF FF E0 48 ; Subtract with carry (long,X) $48E0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1803.w		; 0C 03 18 ; Test and set bits $1803.w [Reads: Accumulator] [Flags: Z]
	ora $341F33.l		; 0F 33 1F 34 ; OR accumulator with memory (long) $341F33.l [Writes: Accumulator] [Flags: ZN]
	ora $EF3C63.l,X		; 1F 63 3C EF ; Logical OR long $EF3C63.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $01		; 70 01 ; Branch if overflow set to $70, $01 [Flow: branch]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7F3F3F.l,X		; 1F 3F 3F 7F ; Logical OR long $7F3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $400080.l,X		; FF 80 00 40 ; Subtract with carry (long,X) $400080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $30		; 80 30 ; Branch always to $80, $30 [Flow: branch]
	cpy #$18.b		; C0 18 ; Compare #$18.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $CC		; F0 CC ; Branch if equal to $F0, $CC [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $C6F8.w		; 0C F8 C6 ; Test and set bits $C6F8.w [Reads: Accumulator] [Flags: Z]
	bit $0EFB.w,X		; 3C FB 0E ; Test bits $0EFB.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($FEFC.w,X)		; FC FC FE ; Jump to subroutine indirect indexed ($FEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $1E0000.l,X		; FF 00 00 1E ; Subtract with carry (long,X) $1E0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $19.b		; 02 19 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($04.b)		; 32 04 ; AND accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $12.b		; 05 12 ; Logical OR $12.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp ($8400.w)		; 6C 00 84 ; Jump indirect to ($8400.w) [Flow: jump]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$3C.b],Y		; 17 3C ; OR accumulator with memory (long indexed) [$3C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($32.b,X)		; 01 32 ; Logical OR ($32.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	jsl $037804.l		; 22 04 78 03 ; Jump to subroutine long $037804.l [Writes: Stack Pointer] [Flow: call]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $2F.b		; 45 2F ; Exclusive OR $2F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	eor $304F20.l,X		; 5F 20 4F 30 ; Exclusive OR accumulator with memory (long,X) $304F20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $620730.l		; 22 30 07 62 ; Jump to subroutine long $620730.l [Writes: Stack Pointer] [Flow: call]
	adc ($C0.b,S),Y		; 73 C0 ; Add with carry (stack relative indirect indexed) ($C0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $45		; 10 45 ; Branch if plus to $10, $45 [Flow: branch]
	pea $0608.w		; F4 08 06 ; Push absolute address $0608.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	tsb $F2.b		; 04 F2 ; Test and set bits $F2.b [Reads: Accumulator] [Flags: Z]
	tsb $30C0.w		; 0C C0 30 ; Test and set bits $30C0.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $46090C.l		; 22 0C 09 46 ; Jump to subroutine long $46090C.l [Writes: Stack Pointer] [Flow: call]
	dec $0003.w		; CE 03 00 ; Decrement $0003.w [Flags: ZN]
	ora $0E1E03.l		; 0F 03 1E 0E ; OR accumulator with memory (long) $0E1E03.l [Writes: Accumulator] [Flags: ZN]
	trb $430C.w		; 1C 0C 43 ; Test and reset bits $430C.w [Reads: Accumulator] [Flags: Z]
	rol $E01E.w,X		; 3E 1E E0 ; Rotate left $E01E.w,X [Reads: X Index] [Flags: ZNC]
	eor ($33.b,S),Y		; 53 33 ; XOR accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($7F.b,S),Y		; 13 7F ; OR accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $110C03.l,X		; 3F 03 0C 11 ; AND accumulator with memory (long,X) $110C03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($23.b,S),Y		; 13 23 ; OR accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($2C.b,X)		; 21 2C ; Logical AND ($2C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $42, $C0		; 42 C0 ; Reserved instruction
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$38.b		; C0 38 ; Compare #$38.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	.db $10, $4C		; 10 4C ; Branch if plus to $10, $4C [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $9C08.w		; 0C 08 9C ; Test and set bits $9C08.w [Reads: Accumulator] [Flags: Z]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	inc $C0FC.w,X		; FE FC C0 ; Increment memory $C0FC.w,X [Reads: X Index] [Flags: ZN]
	.db $30, $C8		; 30 C8 ; Branch if minus to $30, $C8 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	pea $64F4.w		; F4 F4 64 ; Push absolute address $64F4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $42, $60		; 42 60 ; Reserved instruction
	brk $B3.b		; 00 B3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $10BF.w		; 20 BF 10 ; Jump to subroutine at $10BF.w [Writes: Stack Pointer] [Flow: call]
	sbc $3D6718.l		; EF 18 67 3D ; Subtract with carry (long) $3D6718.l [Writes: Accumulator] [Flags: ZVNC]
	adc ($3E.b,S),Y		; 73 3E ; Add with carry (stack relative indirect indexed) ($3E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $271D.w,X		; 3E 1D 27 ; Rotate left $271D.w,X [Reads: X Index] [Flags: ZNC]
	trb $D360.w		; 1C 60 D3 ; Test and reset bits $D360.w [Reads: Accumulator] [Flags: Z]
	sbc $7F7EFF.l,X		; FF FF 7E 7F ; Subtract with carry (long,X) $7F7EFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00003E.l,X		; 3F 3E 00 00 ; AND accumulator with memory (long,X) $00003E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $DDB4.w,X		; FE B4 DD ; Increment memory $DDB4.w,X [Reads: X Index] [Flags: ZN]
	ror $5F.b,X		; 76 5F ; Rotate right $5F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	lda ($F3.b)		; B2 F3 ; Load accumulator (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $C000.w		; 20 00 C0 ; Jump to subroutine at $C000.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FF7E.w,X)		; FC 7E FF ; Jump to subroutine indirect indexed ($FF7E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $00237F.l,X		; FF 7F 23 00 ; Subtract with carry (long,X) $00237F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0007.w		; 0D 07 00 ; Logical OR $0007.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $0607.w		; 0D 07 06 ; Logical OR $0607.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $430000.l		; 0F 00 00 43 ; OR accumulator with memory (long) $430000.l [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $0023.w,X		; 1E 23 00 ; Arithmetic shift left $0023.w,X [Reads: X Index] [Flags: ZNC]
	ora ($80.b,S),Y		; 13 80 ; OR accumulator (stack relative indirect indexed) ($80.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $30		; 80 30 ; Branch always to $80, $30 [Flow: branch]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$F0.b		; A0 F0 ; Load #$F0.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $70, $83		; 70 83 ; Branch if overflow set to $70, $83 [Flow: branch]
	sbc ($00.b)		; F2 00 ; Subtract with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $16173C.l		; 0F 3C 17 16 ; OR accumulator with memory (long) $16173C.l [Writes: Accumulator] [Flags: ZN]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F0700.l		; 0F 00 07 0F ; OR accumulator with memory (long) $0F0700.l [Writes: Accumulator] [Flags: ZN]
	ora $0F173F.l,X		; 1F 3F 17 0F ; Logical OR long $0F173F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $830023.l,X		; 1F 23 00 83 ; Logical OR long $830023.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0101.w		; 0C 01 01 ; Test and set bits $0101.w [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$43.b		; C0 43 ; Compare #$43.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $A0		; 70 A0 ; Branch if overflow set to $70, $A0 [Flow: branch]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $F0, $83		; F0 83 ; Branch if equal to $F0, $83 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $E0.b		; 66 E0 ; Rotate right $E0.b [Reads: Direct Page] [Flags: ZNC]
	.db $B0, $B0		; B0 B0 ; Branch if carry set to $B0, $B0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $000D.w		; 20 0D 00 ; Jump to subroutine at $000D.w [Writes: Stack Pointer] [Flow: call]
	and $073F09.l,X		; 3F 09 3F 07 ; AND accumulator with memory (long,X) $073F09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $3F02.w,X		; 3E 02 3F ; Rotate left $3F02.w,X [Reads: X Index] [Flags: ZNC]
	ora #$3F.b		; 09 3F ; Logical OR #$3F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $023E.w		; 0D 3E 02 ; Logical OR $023E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	ora $1012.w		; 0D 12 10 ; Logical OR $1012.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $0418.w,X		; 3D 18 04 ; AND accumulator with memory $0418.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	jsr ($FC90.w,X)		; FC 90 FC ; Jump to subroutine indirect indexed ($FC90.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$7C.b		; E0 7C ; Compare #$7C.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx $DC80.w		; EC 80 DC ; Compare $DC80.w with X register [Reads: X Index] [Flags: ZNC]
	.db $90, $3C		; 90 3C ; Branch if carry clear to $90, $3C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $28		; 90 28 ; Branch if carry clear to $90, $28 [Flow: branch]
	.db $10, $B0		; 10 B0 ; Branch if plus to $10, $B0 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	jsr ($70FF.w,X)		; FC FF 70 ; Jump to subroutine indirect indexed ($70FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $287F60.l,X		; FF 60 7F 28 ; Subtract with carry (long,X) $287F60.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $123A2D.l,X		; 7F 2D 3A 12 ; Add long $123A2D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $3F00.w		; 1C 00 3F ; Test and reset bits $3F00.w [Reads: Accumulator] [Flags: Z]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	ora $FFFF.w,X		; 1D FF FF ; OR accumulator with memory $FFFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $70.b,X		; 75 70 ; Add $70.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $3F1F.w,X		; 3D 1F 3F ; AND accumulator with memory $3F1F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $FF0EFF.l,X		; 3F FF 0E FF ; AND accumulator with memory (long,X) $FF0EFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $FE.b		; 06 FE ; Arithmetic shift left $FE.b [Reads: Direct Page] [Flags: ZNC]
	trb $FE.b		; 14 FE ; Test and reset bits $FE.b [Reads: Accumulator] [Flags: Z]
	ldy $5C.b,X		; B4 5C ; Load Y register $5C.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	bit $F600.w,X		; 3C 00 F6 ; Test bits $F600.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tsb $BC66.w		; 0C 66 BC ; Test and set bits $BC66.w [Reads: Accumulator] [Flags: Z]
	sbc $0EAEFF.l,X		; FF FF AE 0E ; Subtract with carry (long,X) $0EAEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy $FEFC.w,X		; BC FC FE ; Load Y register $FEFC.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: ZN]
	and [$84.b],Y		; 37 84 ; AND accumulator with memory (long indexed) [$84.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1200.w,Y		; 39 00 12 ; AND accumulator with memory $1200.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $007E00.l,X		; 7F 00 7E 00 ; Add long $007E00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $3800.w,X		; 3C 00 38 ; Test bits $3800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $04.b		; 66 04 ; Rotate right $04.b [Reads: Direct Page] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $004B86.l,X		; 1F 86 4B 00 ; Logical OR long $004B86.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $53.b		; 86 53 ; Store X register to $53.b [Reads: X Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($0E.b)		; 72 0E ; Add with carry (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc [$18.b]		; 67 18 ; Add with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($6C03.w,X)		; FC 03 6C ; Jump to subroutine indirect indexed ($6C03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($3C.b,S),Y		; 13 3C ; OR accumulator (stack relative indirect indexed) ($3C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $77.b,S		; 03 77 ; OR accumulator with stack relative $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $001F00.l,X		; 3F 00 1F 00 ; AND accumulator with memory (long,X) $001F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $B87C00.l		; 0F 00 7C B8 ; OR accumulator with memory (long) $B87C00.l [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp $163F.w		; 4C 3F 16 ; Jump to $163F.w [Flow: jump]
	ora $3C18E6.l		; 0F E6 18 3C ; OR accumulator with memory (long) $3C18E6.l [Writes: Accumulator] [Flags: ZN]
	cpy #$36.b		; C0 36 ; Compare #$36.b with Y register [Reads: Y Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpy $FE.b		; C4 FE ; Compare $FE.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1D1A.w		; 1C 1A 1D ; Test and reset bits $1D1A.w [Reads: Accumulator] [Flags: Z]
	rol $78F4.w		; 2E F4 78 ; Rotate left $78F4.w [Flags: ZNC]
	cpx #$7F.b		; E0 7F ; Compare #$7F.b with X register [Reads: X Index] [Flags: ZNC]
	and ($7F.b,S),Y		; 33 7F ; AND accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($3F.b),Y		; 31 3F ; AND accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $1F021E.l,X		; 1F 1E 02 1F ; Logical OR long $1F021E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $07060F.l		; 0F 0F 06 07 ; OR accumulator with memory (long) $07060F.l [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $1D20.w		; 4E 20 1D ; Logical shift right $1D20.w [Flags: ZNC]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	inc $76CC.w,X		; FE CC 76 ; Increment memory $76CC.w,X [Reads: X Index] [Flags: ZN]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $F0		; 90 F0 ; Branch if carry clear to $90, $F0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	and ($FA.b)		; 32 FA ; AND accumulator with memory (indirect) ($FA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pea $68F8.w		; F4 F8 68 ; Push absolute address $68F8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $90, $20		; 90 20 ; Branch if carry clear to $90, $20 [Flow: branch]
	cpy #$6F.b		; C0 6F ; Compare #$6F.b with Y register [Reads: Y Index] [Flags: ZNC]
	bit $1A7D.w,X		; 3C 7D 1A ; Test bits $1A7D.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	eor $066928.l,X		; 5F 28 69 06 ; Exclusive OR accumulator with memory (long,X) $066928.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $3C7320.l,X		; 7F 20 73 3C ; Add long $3C7320.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $0022.w,X		; 3D 22 00 ; AND accumulator with memory $0022.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $7E7E.w		; 0D 7E 7E ; Logical OR $7E7E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $7F7F79.l,X		; 5F 79 7F 7F ; Exclusive OR accumulator with memory (long,X) $7F7F79.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $F700.w,X		; 3D 00 F7 ; AND accumulator with memory $F700.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $7E.b		; 26 7E ; Rotate left $7E.b [Reads: Direct Page] [Flags: ZNC]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $EF.b,S		; 43 EF ; Exclusive OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: ZNC]
	cmp $9E1D06.l		; CF 06 1D 9E ; Compare accumulator (long) $9E1D06.l [Reads: Accumulator] [Flags: ZNC]
	tsb $FA79.w		; 0C 79 FA ; Test and set bits $FA79.w [Reads: Accumulator] [Flags: Z]
	sta ($19.b,S),Y		; 93 19 ; Store accumulator (stack relative indirect indexed) ($19.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	ora $3939.w,Y		; 19 39 39 ; OR accumulator with memory $3939.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($7E.b)		; F2 7E ; Subtract with carry (indirect) ($7E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $EF47CF.l		; 0F CF 47 EF ; OR accumulator with memory (long) $EF47CF.l [Writes: Accumulator] [Flags: ZN]
	adc $FF.b		; 65 FF ; Add $FF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $50, $BD		; 50 BD ; Branch if overflow clear to $50, $BD [Flow: branch]
	ror $FD.b,X		; 76 FD ; Rotate right $FD.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ror $BF7E.w		; 6E 7E BF ; Rotate right $BF7E.w [Flags: ZNC]
	sta $23DD.w,X		; 9D DD 23 ; Store accumulator to $23DD.w,X [Reads: Accumulator, X Index]
	sbc $F07E13.l,X		; FF 13 7E F0 ; Subtract with carry (long,X) $F07E13.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($E2.b,S),Y		; F3 E2 ; Subtract with carry (stack relative indirect indexed) ($E2.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$A6.b],Y		; F7 A6 ; Subtract with carry (long indexed) [$A6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $E0FFA4.l,X		; FF A4 FF E0 ; Subtract with carry (long,X) $E0FFA4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $6EBD0A.l,X		; FF 0A BD 6E ; Subtract with carry (long,X) $6EBD0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $FD7E76.l,X		; BF 76 7E FD ; Load long $FD7E76.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $23BB.w,Y		; B9 BB 23 ; Load $23BB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $0F1C02.l,X		; FF 02 1C 0F ; Subtract with carry (long,X) $0F1C02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $1F43.w,X		; 3E 43 1F ; Rotate left $1F43.w,X [Reads: X Index] [Flags: ZNC]
	and $3F1D13.l,X		; 3F 13 1D 3F ; AND accumulator with memory (long,X) $3F1D13.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $375F.w		; 0D 5F 37 ; Logical OR $375F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	lda $46FD68.l,X		; BF 68 FD 46 ; Load long $46FD68.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $3F3E.w,X		; 1E 3E 3F ; Arithmetic shift left $3F3E.w,X [Reads: X Index] [Flags: ZNC]
	and $7F3D.w,X		; 3D 3D 7F ; AND accumulator with memory $7F3D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F038FF.l,X		; FF FF 38 F0 ; Subtract with carry (long,X) $F038FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($F843.w,X)		; 7C 43 F8 ; Jump indirect indexed to ($F843.w,X) [Reads: X Index] [Flow: jump]
	jsr ($79E0.w,X)		; FC E0 79 ; Jump to subroutine indirect indexed ($79E0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jsr ($FAB0.w,X)		; FC B0 FA ; Jump to subroutine indirect indexed ($FAB0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $16FD.w		; EC FD 16 ; Compare $16FD.w with X register [Reads: X Index] [Flags: ZNC]
	lda $7C7862.l,X		; BF 62 78 7C ; Load long $7C7862.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($BCBC.w,X)		; FC BC BC ; Jump to subroutine indirect indexed ($BCBC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: ZN]
	adc $25BB39.l,X		; 7F 39 BB 25 ; Add long $25BB39.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $3B02.w,X		; 7D 02 3B ; Add $3B02.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $2C.b		; 14 2C ; Test and reset bits $2C.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lsr $3F39.w		; 4E 39 3F ; Logical shift right $3F39.w [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc $342B.w,X		; 7D 2B 34 ; Add $342B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $383F.w,X		; 7E 3F 38 ; Rotate right $383F.w,X [Reads: X Index] [Flags: ZNC]
	adc $245D1C.l,X		; 7F 1C 5D 24 ; Add long $245D1C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $DC40.w,Y		; BE 40 DC ; Load X register $DC40.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $D0.b,X		; 34 D0 ; Test bits $D0.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	adc ($9C.b)		; 72 9C ; Add with carry (indirect) ($9C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($1C10.w,X)		; FC 10 1C ; Jump to subroutine indirect indexed ($1C10.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ldx $2CD4.w,Y		; BE D4 2C ; Load X register $2CD4.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ror $1CFC.w,X		; 7E FC 1C ; Rotate right $1CFC.w,X [Reads: X Index] [Flags: ZNC]
	and [$18.b],Y		; 37 18 ; AND accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($7E18.w,X)		; 7C 18 7E ; Jump indirect indexed to ($7E18.w,X) [Reads: X Index] [Flow: jump]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	adc $1D2E30.l,X		; 7F 30 2E 1D ; Add long $1D2E30.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $1A.b,X		; 35 1A ; Logical AND $1A.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $000F08.l,X		; 1F 08 0F 00 ; Logical OR long $000F08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $7F7D7F.l,X		; 3F 7F 7D 7F ; AND accumulator with memory (long,X) $7F7D7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $1E3C.w,X		; 3E 3C 1E ; Rotate left $1E3C.w,X [Reads: X Index] [Flags: ZNC]
	ora $9F1CF7.l		; 0F F7 1C 9F ; OR accumulator with memory (long) $9F1CF7.l [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	lda $0CFA26.l,X		; BF 26 FA 0C ; Load long $0CFA26.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $BC.b		; 66 BC ; Rotate right $BC.b [Reads: Direct Page] [Flags: ZNC]
	ldy $B858.w,X		; BC 58 B8 ; Load Y register $B858.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	sbc $FEDFFF.l,X		; FF FF DF FE ; Subtract with carry (long,X) $FEDFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $383C.w,X		; 7E 3C 38 ; Rotate right $383C.w,X [Reads: X Index] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	eor ($00.b),Y		; 51 00 ; Exclusive OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	jsl $857804.l		; 22 04 78 85 ; Jump to subroutine long $857804.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc [$00.b]		; 67 00 ; Add with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lsr $1C00.w		; 4E 00 1C ; Logical shift right $1C00.w [Flags: ZNC]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $3F.b,S		; 83 3F ; Store accumulator (stack relative) $3F.b,S [Reads: Accumulator, Stack Pointer]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($42.b,X)		; 21 42 ; Logical AND ($42.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	.db $30, $01		; 30 01 ; Branch if minus to $30, $01 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $2E,$00		; 44 00 2E ; Move block positive $2E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $36.b		; 04 36 ; Test and set bits $36.b [Reads: Accumulator] [Flags: Z]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $00, $0A		; 62 00 0A ; Push effective relative address $62, $00, $0A [Writes: Stack Pointer]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and [$33.b],Y		; 37 33 ; AND accumulator with memory (long indexed) [$33.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $806E.w,Y		; 39 6E 80 ; AND accumulator with memory $806E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F4,$00		; 44 00 F4 ; Move block positive $F4,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: ZNC]
	jmp ($EE00.w)		; 6C 00 EE ; Jump indirect to ($EE00.w) [Flow: jump]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	stz $6C.b		; 64 6C ; Store zero to $6C.b
	jmp $DE9C.w		; 4C 9C DE ; Jump to $DE9C.w [Flow: jump]
	ora ($03.b),Y		; 11 03 ; OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $6EBB2D.l,X		; 7F 2D BB 6E ; Add long $6EBB2D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	eor $04CF.w		; 4D CF 04 ; Exclusive OR $04CF.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc $1F0364.l,X		; FF 64 03 1F ; Subtract with carry (long,X) $1F0364.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FFFF7E.l,X		; 3F 7E FF FF ; AND accumulator with memory (long,X) $FFFF7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $8D9E.w,X		; FE 9E 8D ; Increment memory $8D9E.w,X [Reads: X Index] [Flags: ZN]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$26.b],Y		; F7 26 ; Subtract with carry (long indexed) [$26.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $E9.b		; 86 E9 ; Store X register to $E9.b [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0025.w,Y		; 79 25 00 ; Add $0025.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $5F		; 30 5F ; Branch if minus to $30, $5F [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp [$7E.b]		; C7 7E ; Compare accumulator (long) [$7E.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc $00221E.l		; EF 1E 22 00 ; Subtract with carry (long) $00221E.l [Writes: Accumulator] [Flags: ZVNC]
	tsb $30.b		; 04 30 ; Test and set bits $30.b [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $25FFFF.l,X		; 7F FF FF 25 ; Add long $25FFFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E00.w		; 0C 00 1E ; Test and set bits $1E00.w [Reads: Accumulator] [Flags: Z]
	tsb $1CFA.w		; 0C FA 1C ; Test and set bits $1CFA.w [Reads: Accumulator] [Flags: Z]
	sbc [$78.b]		; E7 78 ; Subtract with carry (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $22B0.w,Y		; 79 B0 22 ; Add $22B0.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FE1E.w		; 0C 1E FE ; Test and set bits $FE1E.w [Reads: Accumulator] [Flags: Z]
	sbc $2E7DFF.l,X		; FF FF 7D 2E ; Subtract with carry (long,X) $2E7DFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $BB2E.w,X		; FD 2E BB ; Subtract with carry $BB2E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp $273D5B.l		; 5C 5B 3D 27 ; Jump long to $273D5B.l [Flow: jump]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	rol $1C16.w		; 2E 16 1C ; Rotate left $1C16.w [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3C7EFF.l,X		; FF FF 7E 3C ; Subtract with carry (long,X) $3C7EFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $031F.w,Y		; 39 1F 03 ; AND accumulator with memory $031F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0E.b		; 09 0E ; Logical OR #$0E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1E27.w		; 0E 27 1E ; Arithmetic shift left $1E27.w [Flags: ZNC]
	rol $2C18.w		; 2E 18 2C ; Rotate left $2C18.w [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $0E1C00.l		; 22 00 1C 0E ; Jump to subroutine long $0E1C00.l [Writes: Stack Pointer] [Flow: call]
	ora ($27.b),Y		; 11 27 ; OR accumulator with memory ($27.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $E52C.w		; 2E 2C E5 ; Rotate left $E52C.w [Flags: ZNC]
	jsl $BD32F5.l		; 22 F5 32 BD ; Jump to subroutine long $BD32F5.l [Writes: Stack Pointer] [Flow: call]
	lsr $BB.b,X		; 56 BB ; Logical shift right $BB.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc $3D5B.w		; 6D 5B 3D ; Add $3D5B.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	jsl $041A1C.l		; 22 1C 1A 04 ; Jump to subroutine long $041A1C.l [Writes: Stack Pointer] [Flow: call]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $FEEFCF.l,X		; DF CF EF FE ; Compare accumulator (long,X) $FEEFCF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	ror $1F3F.w,X		; 7E 3F 1F ; Rotate right $1F3F.w,X [Reads: X Index] [Flags: ZNC]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $8300.w		; 0C 00 83 ; Test and set bits $8300.w [Reads: Accumulator] [Flags: Z]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $040500.l		; 22 00 05 04 ; Jump to subroutine long $040500.l [Writes: Stack Pointer] [Flow: call]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	rol $04.b,X		; 36 04 ; Rotate left $04.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $50.b,S		; 83 50 ; Store accumulator (stack relative) $50.b,S [Reads: Accumulator, Stack Pointer]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $070F09.l,X		; 1F 09 0F 07 ; Logical OR long $070F09.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $3F02.w		; 0E 02 3F ; Arithmetic shift left $3F02.w [Flags: ZNC]
	ora #$FF.b		; 09 FF ; Logical OR #$FF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $8C7E.w		; 0D 7E 8C ; Logical OR $8C7E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $F80A01.l,X		; 5F 01 0A F8 ; Exclusive OR accumulator with memory (long,X) $F80A01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $90, $F0		; 90 F0 ; Branch if carry clear to $90, $F0 [Flow: branch]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx $DF80.w		; EC 80 DF ; Compare $DF80.w with X register [Reads: X Index] [Flags: ZNC]
	.db $90, $3E		; 90 3E ; Branch if carry clear to $90, $3E [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	adc [$01.b],Y		; 77 01 ; Add with carry (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $37.b		; 84 37 ; Store Y register to $37.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$44.b],Y		; 37 44 ; AND accumulator with memory (long indexed) [$44.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $7C.b		; 02 7C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $190200.l		; 22 00 02 19 ; Jump to subroutine long $190200.l [Writes: Stack Pointer] [Flow: call]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta $45.b,S		; 83 45 ; Store accumulator (stack relative) $45.b,S [Reads: Accumulator, Stack Pointer]
	ora $44.b,S		; 03 44 ; OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $1C.b,S		; 43 1C ; Exclusive OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sta $53.b		; 85 53 ; Store accumulator to $53.b [Reads: Accumulator]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $46.b		; 84 46 ; Store Y register to $46.b [Reads: Y Index]
	ora $44.b,S		; 03 44 ; OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $19.b		; 02 19 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jmp $308500.l		; 5C 00 85 30 ; Jump long to $308500.l [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$44.b],Y		; 37 44 ; AND accumulator with memory (long indexed) [$44.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $BC.b		; 86 BC ; Store X register to $BC.b [Reads: X Index]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($04.b)		; 32 04 ; AND accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor $003600.l		; 4F 00 36 00 ; Exclusive OR accumulator with memory (long) $003600.l [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $070F.w,Y		; 39 0F 07 ; AND accumulator with memory $070F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $3907.w,X		; 1E 07 39 ; Arithmetic shift left $3907.w,X [Reads: X Index] [Flags: ZNC]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	trb $E7.b		; 14 E7 ; Test and reset bits $E7.b [Reads: Accumulator] [Flags: Z]
	inc $F8FC.w		; EE FC F8 ; Increment $F8FC.w [Flags: ZN]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx #$65.b		; E0 65 ; Compare #$65.b with X register [Reads: X Index] [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	adc ($0C.b,S),Y		; 73 0C ; Add with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor #$36.b		; 49 36 ; Exclusive OR #$36.b with accumulator [Writes: Accumulator] [Flags: ZN]
	stz $0B.b		; 64 0B ; Store zero to $0B.b
	ror $7321.w,X		; 7E 21 73 ; Rotate right $7321.w,X [Reads: X Index] [Flags: ZNC]
	bit $223C.w,X		; 3C 3C 22 ; Test bits $223C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $4F7F.w,X		; 7E 7F 4F ; Rotate right $4F7F.w,X [Reads: X Index] [Flags: ZNC]
	adc [$7F.b],Y		; 77 7F ; Add with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $83003C.l,X		; 7F 3C 00 83 ; Add long $83003C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $CF4306.l		; EF 06 43 CF ; Subtract with carry (long) $CF4306.l [Writes: Accumulator] [Flags: ZVNC]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: ZNC]
	stz $7C0C.w,X		; 9E 0C 7C ; Store zero to $7C0C.w,X [Reads: X Index]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($19.b,S),Y		; 93 19 ; Store accumulator (stack relative indirect indexed) ($19.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	sta $39B9.w,Y		; 99 B9 39 ; Store accumulator to $39B9.w,Y [Reads: Accumulator, Y Index]
	sbc ($7C.b)		; F2 7C ; Subtract with carry (indirect) ($7C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	stz $BF0D.w,X		; 9E 0D BF ; Store zero to $BF0D.w,X [Reads: X Index]
	bit $12FD.w		; 2C FD 12 ; Test bits $12FD.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	inc $7765.w,X		; FE 65 77 ; Increment memory $7765.w,X [Reads: X Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0022.w		; 0E 22 00 ; Arithmetic shift left $0022.w [Flags: ZNC]
	trb $FF.b		; 14 FF ; Test and reset bits $FF.b [Reads: Accumulator] [Flags: Z]
	dec $FFFE.w,X		; DE FE FF ; Decrement memory $FFFE.w,X [Reads: X Index] [Flags: ZN]
	adc [$31.b],Y		; 77 31 ; Add with carry (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $7D00.w		; 0E 00 7D ; Arithmetic shift left $7D00.w [Flags: ZNC]
	ldy $BF.b,X		; B4 BF ; Load Y register $BF.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	.db $50, $BE		; 50 BE ; Branch if overflow clear to $50, $BE [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ror $CC84.w,X		; 7E 84 CC ; Rotate right $CC84.w,X [Reads: X Index] [Flags: ZNC]
	.db $30, $88		; 30 88 ; Branch if minus to $30, $88 [Flow: branch]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	jsl $FB1400.l		; 22 00 14 FB ; Jump to subroutine long $FB1400.l [Writes: Stack Pointer] [Flow: call]
	adc $CCFE7E.l,X		; 7F 7E FE CC ; Add long $CCFE7E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $24		; 30 24 ; Branch if minus to $30, $24 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($0C.b)		; 12 0C ; OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	bit $0F1E.w,X		; 3C 1E 0F ; Test bits $0F1E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	eor $27182C.l		; 4F 2C 18 27 ; Exclusive OR accumulator with memory (long) $27182C.l [Writes: Accumulator] [Flags: ZN]
	bit $0027.w		; 2C 27 00 ; Test bits $0027.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3E.b,X)		; 01 3E ; Logical OR ($3E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cop $36.b		; 02 36 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $2E		; F0 2E ; Branch if equal to $F0, $2E [Flow: branch]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $002FE0.l,X		; FF E0 2F 00 ; Subtract with carry (long,X) $002FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $F877.w,X		; 1D 77 F8 ; OR accumulator with memory $F877.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $00F01F.l,X		; 7F 1F F0 00 ; Add long $00F01F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($E000.w,X)		; FC 00 E0 ; Jump to subroutine indirect indexed ($E000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	cpx #$FE.b		; E0 FE ; Compare #$FE.b with X register [Reads: X Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F8E0.w,X)		; FC E0 F8 ; Jump to subroutine indirect indexed ($F8E0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FE1F.w		; EE 1F FE ; Increment $FE1F.w [Flags: ZN]
	jsr ($002D.w,X)		; FC 2D 00 ; Jump to subroutine indirect indexed ($002D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($38.b,X)		; 01 38 ; Logical OR ($38.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr ($002D.w,X)		; FC 2D 00 ; Jump to subroutine indirect indexed ($002D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $25		; 30 25 ; Branch if minus to $30, $25 [Flow: branch]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($0001.w,X)		; FC 01 00 ; Jump to subroutine indirect indexed ($0001.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1D07.w		; 0E 07 1D ; Arithmetic shift left $1D07.w [Flags: ZNC]
	asl $0E19.w		; 0E 19 0E ; Arithmetic shift left $0E19.w [Flags: ZNC]
	ora $0E.b,X		; 15 0E ; OR accumulator with memory $0E.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0F.b,X		; 16 0F ; Arithmetic shift left $0F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and #$17.b		; 29 17 ; Logical AND #$17.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $171F1F.l		; 0F 1F 1F 17 ; OR accumulator with memory (long) $171F1F.l [Writes: Accumulator] [Flags: ZN]
	ora [$29.b],Y		; 17 29 ; OR accumulator with memory (long indexed) [$29.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FF0000.l,X		; FF 00 00 FF ; Subtract with carry (long,X) $FF0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	mvp $00,$FF		; 44 FF 00 ; Move block positive $00,$FF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0001FF.l		; 22 FF 01 00 ; Jump to subroutine long $0001FF.l [Writes: Stack Pointer] [Flow: call]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00E703.l,X		; FF 03 E7 00 ; Subtract with carry (long,X) $00E703.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $002BFF.l,X		; FF FF 2B 00 ; Subtract with carry (long,X) $002BFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$3D.b]		; 07 3D ; OR accumulator with memory (long) [$3D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx $CA10.w		; EC 10 CA ; Compare $CA10.w with X register [Reads: X Index] [Flags: ZNC]
	ldy $23.b,X		; B4 23 ; Load Y register $23.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $E4.b		; 14 E4 ; Test and reset bits $E4.b [Reads: Accumulator] [Flags: Z]
.ACCU 16
	rep #$2B		; C2 2B
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $2502.w,X		; 7D 02 25 ; Add $2502.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$7D.b]		; 07 7D ; OR accumulator with memory (long) [$7D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $B4EE.w		; 1C EE B4 ; Test and reset bits $B4EE.w [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$33.b		; E0 33 ; Compare #$33.b with X register [Reads: X Index] [Flags: ZNC]
	tsb $E21E.w		; 0C 1E E2 ; Test and set bits $E21E.w [Reads: Accumulator] [Flags: Z]
.ACCU 16
	rep #$20		; C2 20
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $58.b		; 00 58 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $306F.w		; 20 6F 30 ; Jump to subroutine at $306F.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor [$F7.b],Y		; 57 F7 ; Exclusive OR accumulator with memory (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	dec $09.b,X		; D6 09 ; Decrement memory $09.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	jsr $5C58.w		; 20 58 5C ; Jump to subroutine at $5C58.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	adc [$BF.b],Y		; 77 BF ; Add with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cmp $0000.w,Y		; D9 00 00 ; Compare accumulator $0000.w,Y [Reads: Y Index] [Flags: ZNC]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $3D22.w		; 6D 22 3D ; Add $3D22.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	ora ($1A.b)		; 12 1A ; OR accumulator with memory (indirect) ($1A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $F6.b		; 04 F6 ; Test and set bits $F6.b [Reads: Accumulator] [Flags: Z]
	tsb $B84C.w		; 0C 4C B8 ; Test and set bits $B84C.w [Reads: Accumulator] [Flags: Z]
	trb $00F8.w		; 1C F8 00 ; Test and reset bits $00F8.w [Reads: Accumulator] [Flags: Z]
	and ($5F.b)		; 32 5F ; AND accumulator with memory (indirect) ($5F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	asl $EE.b,X		; 16 EE ; Arithmetic shift left $EE.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldy $E4FC.w,X		; BC FC E4 ; Load Y register $E4FC.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	and $30E000.l		; 2F 00 E0 30 ; AND accumulator with memory (long) $30E000.l [Writes: Accumulator] [Flags: ZN]
	ora $13330C.l,X		; 1F 0C 33 13 ; Logical OR long $13330C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$25.b]		; 67 25 ; Add with carry (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $5F0C.w		; 4E 0C 5F ; Logical shift right $5F0C.w [Flags: ZNC]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7D5A.w		; 2C 5A 7D ; Test bits $7D5A.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	adc ($6F.b,S),Y		; 73 6F ; Add with carry (stack relative indirect indexed) ($6F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $E20F.w,X		; 3C 0F E2 ; Test bits $E20F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	trb $D0EE.w		; 1C EE D0 ; Test and reset bits $D0EE.w [Reads: Accumulator] [Flags: Z]
	ror $7E50.w		; 6E 50 7E ; Rotate right $7E50.w [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr ($6C80.w,X)		; FC 80 6C ; Jump to subroutine indirect indexed ($6C80.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $50, $F8		; 50 F8 ; Branch if overflow clear to $50, $F8 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	inc $B232.w,X		; FE 32 B2 ; Increment memory $B232.w,X [Reads: X Index] [Flags: ZN]
	lda ($54.b)		; B2 54 ; Load accumulator (indirect) ($54.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy $B8.b,X		; B4 B8 ; Load Y register $B8.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	cpy #$3F.b		; C0 3F ; Compare #$3F.b with Y register [Reads: Y Index] [Flags: ZNC]
	mvp $7F,$00		; 44 00 7F ; Move block positive $7F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($0C.b,S),Y		; 73 0C ; Add with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $0302.w		; 4D 02 03 ; Exclusive OR $0302.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FFFF7F.l,X		; 7F 7F FF FF ; Add long $FFFF7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $43034F.l,X		; 7F 4F 03 43 ; Add long $43034F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $0D40.w,Y		; BE 40 0D ; Load X register $0D40.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	lda $42BD40.l,X		; BF 40 BD 42 ; Load long $42BD40.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $DA22.w,X		; DD 22 DA ; Compare accumulator $DA22.w,X [Reads: X Index] [Flags: ZNC]
	bit $FC.b		; 24 FC ; Test bits $FC.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FF22.w,X		; FE 22 FF ; Increment memory $FF22.w,X [Reads: X Index] [Flags: ZN]
	ora $FE.b		; 05 FE ; Logical OR $FE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr ($7FF0.w,X)		; FC F0 7F ; Jump to subroutine indirect indexed ($7FF0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FE,$01		; 44 01 FE ; Move block positive $FE,$01 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $B9.b		; 86 B9 ; Store X register to $B9.b [Reads: X Index]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cmp ($01.b,X)		; C1 01 ; Compare accumulator ($01.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	tsb $7F.b		; 04 7F ; Test and set bits $7F.b [Reads: Accumulator] [Flags: Z]
	eor $807C03.l		; 4F 03 7C 80 ; Exclusive OR accumulator with memory (long) $807C03.l [Writes: Accumulator] [Flags: ZN]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $827D00.l,X		; FF 00 7D 82 ; Subtract with carry (long,X) $827D00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc ($8C.b)		; 72 8C ; Add with carry (indirect) ($8C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($F090.w)		; 6C 90 F0 ; Jump indirect to ($F090.w) [Flow: jump]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $D8.b,S		; 83 D8 ; Store accumulator (stack relative) $D8.b,S [Reads: Accumulator, Stack Pointer]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $F0FC.w,X		; FE FC F0 ; Increment memory $F0FC.w,X [Reads: X Index] [Flags: ZN]
	rol $19.b		; 26 19 ; Rotate left $19.b [Reads: Direct Page] [Flags: ZNC]
	and [$1E.b]		; 27 1E ; AND accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $23.b,S		; 43 23 ; Exclusive OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F1104.l,X		; 1F 04 11 0F ; Logical OR long $0F1104.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsl $261300.l		; 22 00 13 26 ; Jump to subroutine long $261300.l [Writes: Stack Pointer] [Flow: call]
	and [$23.b]		; 27 23 ; AND accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $7E81FF.l,X		; FF FF 81 7E ; Subtract with carry (long,X) $7E81FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FF81FF.l,X		; FF FF 81 FF ; Subtract with carry (long,X) $FF81FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ror $84FF.w,X		; 7E FF 84 ; Rotate right $84FF.w,X [Reads: X Index] [Flags: ZNC]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($22.b,X)		; 81 22 ; Store accumulator ($22.b,X) [Reads: Accumulator, X Index, Direct Page]
	sbc $7E27E0.l,X		; FF E0 27 7E ; Subtract with carry (long,X) $7E27E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $7F.b,X		; 34 7F ; Test bits $7F.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ora ($DF.b),Y		; 11 DF ; OR accumulator with memory ($DF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor ($FF.b,X)		; 41 FF ; Exclusive OR accumulator with memory ($FF.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($FD.b),Y		; 31 FD ; AND accumulator with memory ($FD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $7F.b,X		; 34 7F ; Test bits $7F.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $79.b		; 00 79 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	cmp $0C7CCB.l		; CF CB 7C 0C ; Compare accumulator (long) $0C7CCB.l [Reads: Accumulator] [Flags: ZNC]
	ora [$C6.b]		; 07 C6 ; OR accumulator with memory (long) [$C6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	inc $88.b,X		; F6 88 ; Increment memory $88.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	eor $945E82.l		; 4F 82 5E 94 ; Exclusive OR accumulator with memory (long) $945E82.l [Writes: Accumulator] [Flags: ZN]
	inc $FC8C.w,X		; FE 8C FC ; Increment memory $FC8C.w,X [Reads: X Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $C60700.l		; 22 00 07 C6 ; Jump to subroutine long $C60700.l [Writes: Stack Pointer] [Flow: call]
	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	inc $FCFE.w		; EE FE FC ; Increment $FCFE.w [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	eor $175F01.l,X		; 5F 01 5F 17 ; Exclusive OR accumulator with memory (long,X) $175F01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $037316.l,X		; FF 16 73 03 ; Subtract with carry (long,X) $037316.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $001E0E.l,X		; 1F 0E 1E 00 ; Logical OR long $001E0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $7B7B.w,Y		; 79 7B 7B ; Add $7B7B.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sbc #$117C.w		; E9 7C 11 ; Subtract #$117C.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	asl $B8E6.w,X		; 1E E6 B8 ; Arithmetic shift left $B8E6.w,X [Reads: X Index] [Flags: ZNC]
	inc $B8.b,X		; F6 B8 ; Increment memory $B8.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $E6EFF2.l,X		; FF F2 EF E6 ; Subtract with carry (long,X) $E6EFF2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $B0.b,X		; F6 B0 ; Increment memory $B0.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc $000E0E.l,X		; 7F 0E 0E 00 ; Add long $000E0E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: ZN]
	ora $4E19.w		; 0D 19 4E ; Logical OR $4E19.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ldx $71.b		; A6 71 ; Load $71.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	asl $0F30.w		; 0E 30 0F ; Arithmetic shift left $0F30.w [Flags: ZNC]
	adc ($0C.b,S),Y		; 73 0C ; Add with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($0E.b),Y		; F1 0E ; Subtract with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $DB43.w,Y		; BE 43 DB ; Load X register $DB43.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	and [$E7.b]		; 27 E7 ; AND accumulator with memory (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $31FF.w,X		; 1E FF 31 ; Arithmetic shift left $31FF.w,X [Reads: X Index] [Flags: ZNC]
	ror $2F0F.w,X		; 7E 0F 2F ; Rotate right $2F0F.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($CBBE.w)		; 6C BE CB ; Jump indirect to ($CBBE.w) [Flow: jump]
	sbc [$9F.b]		; E7 9F ; Subtract with carry (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda $F07A7F.l,X		; BF 7F 7A F0 ; Load long $F07A7F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $7BC0.w,X		; 3D C0 7B ; AND accumulator with memory $7BC0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp ($3E.b)		; D2 3E ; Compare accumulator (indirect) ($3E.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	pea $A05F.w		; F4 5F A0 ; Push absolute address $A05F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and $AAD2.w		; 2D D2 AA ; Logical AND $AAD2.w with accumulator [Writes: Accumulator] [Flags: ZN]
	pea $F874.w		; F4 74 F8 ; Push absolute address $F874.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sbc $BDFAFD.l,X		; FF FD FA BD ; Subtract with carry (long,X) $BDFAFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($F6.b,S),Y		; F3 F6 ; Subtract with carry (stack relative indirect indexed) ($F6.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($31E4.w,X)		; FC E4 31 ; Jump to subroutine indirect indexed ($31E4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	bit $0443.w		; 2C 43 04 ; Test bits $0443.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	jmp $0C52E0.l		; 5C E0 52 0C ; Jump long to $0C52E0.l [Flow: jump]
	lsr $000E.w,X		; 5E 0E 00 ; Logical shift right $000E.w,X [Reads: X Index] [Flags: ZNC]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$2B.b]		; 07 2B ; OR accumulator with memory (long) [$2B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc ($71.b,S),Y		; 73 71 ; Add with carry (stack relative indirect indexed) ($71.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	jsr $D400.w		; 20 00 D4 ; Jump to subroutine at $D400.w [Writes: Stack Pointer] [Flow: call]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3A		; 10 3A ; Branch if plus to $10, $3A [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	cpy #$20.b		; C0 20 ; Compare #$20.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$34.b		; E0 34 ; Compare #$34.b with X register [Reads: X Index] [Flags: ZNC]
	rol $CEEE.w,X		; 3E EE CE ; Rotate left $CEEE.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $D0, $60		; D0 60 ; Branch if not equal to $D0, $60 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $30, $74		; 30 74 ; Branch if minus to $30, $74 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($9B60.w,X)		; FC 60 9B ; Jump to subroutine indirect indexed ($9B60.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp ($FEFC.w,X)		; 7C FC FE ; Jump indirect indexed to ($FEFC.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora #$0B06.w		; 09 06 0B ; Logical OR #$0B06.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $17.b		; 06 17 ; Arithmetic shift left $17.b [Reads: Direct Page] [Flags: ZNC]
	tsb $182E.w		; 0C 2E 18 ; Test and set bits $182E.w [Reads: Accumulator] [Flags: Z]
	and $2ED906.l,X		; 3F 06 D9 2E ; AND accumulator with memory (long,X) $2ED906.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3E1F0F.l		; 0F 0F 1F 3E ; OR accumulator with memory (long) $3E1F0F.l [Writes: Accumulator] [Flags: ZN]
	and $00237F.l,X		; 3F 7F 23 00 ; AND accumulator with memory (long,X) $00237F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $32.b,S		; 83 32 ; Store accumulator (stack relative) $32.b,S [Reads: Accumulator, Stack Pointer]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($F430.w,X)		; FC 30 F4 ; Jump to subroutine indirect indexed ($F430.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	inc $0060.w,X		; FE 60 00 ; Increment memory $0060.w,X [Reads: X Index] [Flags: ZN]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($FEFC.w,X)		; FC FC FE ; Jump to subroutine indirect indexed ($FEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $4A.b,S		; 83 4A ; Store accumulator (stack relative) $4A.b,S [Reads: Accumulator, Stack Pointer]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: ZNC]
	tsb $1A2F.w		; 0C 2F 1A ; Test and set bits $1A2F.w [Reads: Accumulator] [Flags: Z]
	adc $000006.l,X		; 7F 06 00 00 ; Add long $000006.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	ora $7F3F3F.l,X		; 1F 3F 3F 7F ; Logical OR long $7F3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($18.b,S),Y		; 13 18 ; OR accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and [$10.b],Y		; 37 10 ; AND accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $081817.l,X		; 3F 17 18 08 ; AND accumulator with memory (long,X) $081817.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $0019.w,Y		; 39 19 00 ; AND accumulator with memory $0019.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $2F.b,X		; 34 2F ; Test bits $2F.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	ora [$26.b],Y		; 17 26 ; OR accumulator with memory (long indexed) [$26.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$001C.w		; 09 1C 00 ; Logical OR #$001C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $04.b		; E6 04 ; Increment $04.b [Reads: Direct Page] [Flags: ZN]
	cmp $B0BE9E.l,X		; DF 9E BE B0 ; Compare accumulator (long,X) $B0BE9E.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	pea $22E8.w		; F4 E8 22 ; Push absolute address $22E8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $61FA.w		; 1C FA 61 ; Test and reset bits $61FA.w [Reads: Accumulator] [Flags: Z]
	lsr $0014.w		; 4E 14 00 ; Logical shift right $0014.w [Flags: ZNC]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $9888.w		; 20 88 98 ; Jump to subroutine at $9888.w [Writes: Stack Pointer] [Flow: call]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr $5870.w		; 20 70 58 ; Jump to subroutine at $5870.w [Writes: Stack Pointer] [Flow: call]
	sta $A4.b,S		; 83 A4 ; Store accumulator (stack relative) $A4.b,S [Reads: Accumulator, Stack Pointer]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $16.b		; 02 16 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	trb $B0BC.w		; 1C BC B0 ; Test and reset bits $B0BC.w [Reads: Accumulator] [Flags: Z]
	pea $00E0.w		; F4 E0 00 ; Push absolute address $00E0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E21A.w		; 0D 1A E2 ; Logical OR $E21A.w with accumulator [Writes: Accumulator] [Flags: ZN]
	jmp $E41C.w		; 4C 1C E4 ; Jump to $E41C.w [Flow: jump]
	and $47E000.l		; 2F 00 E0 47 ; AND accumulator with memory (long) $47E000.l [Writes: Accumulator] [Flags: ZN]
	trb $260F.w		; 1C 0F 26 ; Test and reset bits $260F.w [Reads: Accumulator] [Flags: Z]
	ora $093E.w,X		; 1D 3E 09 ; OR accumulator with memory $093E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $32DD19.l		; 6F 19 DD 32 ; Add with carry (long) $32DD19.l [Writes: Accumulator] [Flags: ZVNC]
	adc $2703.w,X		; 7D 03 27 ; Add $2703.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $001E.w,X		; 1E 1E 00 ; Arithmetic shift left $001E.w,X [Reads: X Index] [Flags: ZNC]
	ora $5D2D3D.l,X		; 1F 3D 2D 5D ; Logical OR long $5D2D3D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	adc ($3F.b,S),Y		; 73 3F ; Add with carry (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $F81C.w,X		; 1E 1C F8 ; Arithmetic shift left $F81C.w,X [Reads: X Index] [Flags: ZNC]
	lsr $6FB0.w		; 4E B0 6F ; Logical shift right $6FB0.w [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $EEC6.w,X		; 7D C6 EE ; Add $EEC6.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $B0, $B6		; B0 B6 ; Branch if carry set to $B0, $B6 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc $0E0E.w,X		; 7D 0E 0E ; Add $0E0E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $CF9D.w,Y		; BE 9D CF ; Load X register $CF9D.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	inc $FA.b,X		; F6 FA ; Increment memory $FA.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	adc $00000E.l,X		; 7F 0E 00 00 ; Add long $00000E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $1100.w		; 0E 00 11 ; Arithmetic shift left $1100.w [Flags: ZNC]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $2F.b		; 02 2F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3E.b		; 06 3E ; Arithmetic shift left $3E.b [Reads: Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $4800.w,X		; 3C 00 48 ; Test bits $4800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	asl $1D1F.w		; 0E 1F 1D ; Arithmetic shift left $1D1F.w [Flags: ZNC]
	and $3C26.w,Y		; 39 26 3C ; AND accumulator with memory $3C26.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $3100.w		; 0E 00 31 ; Arithmetic shift left $3100.w [Flags: ZNC]
	brk $53.b		; 00 53 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $7F.b		; 02 7F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $7E.b,X		; 36 7E ; Rotate left $7E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	sta $5D.b,S		; 83 5D ; Store accumulator (stack relative) $5D.b,S [Reads: Accumulator, Stack Pointer]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7E497D.l,X		; 3F 7D 49 7E ; AND accumulator with memory (long,X) $7E497D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	adc $193F27.l		; 6F 27 3F 19 ; Add with carry (long) $193F27.l [Writes: Accumulator] [Flags: ZVNC]
	ora $041E0D.l,X		; 1F 0D 1E 04 ; Logical OR long $041E0D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0F02.w,X		; 1E 02 0F ; Arithmetic shift left $0F02.w,X [Reads: X Index] [Flags: ZNC]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($58.b,S),Y		; 13 58 ; OR accumulator (stack relative indirect indexed) ($58.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $1312.w		; 20 12 13 ; Jump to subroutine at $1312.w [Writes: Stack Pointer] [Flow: call]
	ora ($08.b),Y		; 11 08 ; OR accumulator with memory ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	inc $E4.b,X		; F6 E4 ; Increment memory $E4.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	jsr ($F898.w,X)		; FC 98 F8 ; Jump to subroutine indirect indexed ($F898.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $B0, $78		; B0 78 ; Branch if carry set to $B0, $78 [Flow: branch]
	jsr $4078.w		; 20 78 40 ; Jump to subroutine at $4078.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $48.b		; 04 48 ; Test and set bits $48.b [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	jsr $0AFD.w		; 20 FD 0A ; Jump to subroutine at $0AFD.w [Writes: Stack Pointer] [Flow: call]
	stz $FE09.w,X		; 9E 09 FE ; Store zero to $FE09.w,X [Reads: X Index]
	adc ($7D.b,X)		; 61 7D ; Add with carry ($7D.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora ($7C.b)		; 12 7C ; OR accumulator with memory (indirect) ($7C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $37.b,S		; 23 37 ; AND accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $140022.l		; 0F 22 00 14 ; OR accumulator with memory (long) $140022.l [Writes: Accumulator] [Flags: ZN]
	sbc $7796FA.l,X		; FF FA 96 77 ; Subtract with carry (long,X) $7796FA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$3F.b],Y		; 77 3F ; Add with carry (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $50BF00.l		; 0F 00 BF 50 ; OR accumulator with memory (long) $50BF00.l [Writes: Accumulator] [Flags: ZN]
	adc $7F90.w,Y		; 79 90 7F ; Add $7F90.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $FE.b		; 86 FE ; Store X register to $FE.b [Reads: X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ror $ECCC.w,X		; 7E CC EC ; Rotate right $ECCC.w,X [Reads: X Index] [Flags: ZNC]
	.db $90, $B0		; 90 B0 ; Branch if carry clear to $90, $B0 [Flow: branch]
	jsl $39E000.l		; 22 00 E0 39 ; Jump to subroutine long $39E000.l [Writes: Stack Pointer] [Flow: call]
	sbc $EE695F.l,X		; FF 5F 69 EE ; Subtract with carry (long,X) $EE695F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $B0FC.w		; EE FC B0 ; Increment $B0FC.w [Flags: ZN]
	brk $BB.b		; 00 BB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $02,$CD		; 44 CD 02 ; Move block positive $02,$CD [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ror $7E31.w,X		; 7E 31 7E ; Rotate right $7E31.w,X [Reads: X Index] [Flags: ZNC]
	ora ($7D.b,X)		; 01 7D ; Logical OR ($7D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($24.b)		; 32 24 ; AND accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $000703.l,X		; 1F 03 07 00 ; Logical OR long $000703.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $4AFF.w,X		; FE FF 4A ; Increment memory $4AFF.w,X [Reads: X Index] [Flags: ZN]
	ror $3F77.w,X		; 7E 77 3F ; Rotate right $3F77.w,X [Reads: X Index] [Flags: ZNC]
	ora $22DD07.l,X		; 1F 07 DD 22 ; Logical OR long $22DD07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda ($40.b,S),Y		; B3 40 ; Load accumulator (stack relative indirect indexed) ($40.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr $7EAC.w,X		; 5E AC 7E ; Logical shift right $7EAC.w,X [Reads: X Index] [Flags: ZNC]
	.db $90, $FE		; 90 FE ; Branch if carry clear to $90, $FE [Flow: branch]
	trb $987C.w		; 1C 7C 98 ; Test and reset bits $987C.w [Reads: Accumulator] [Flags: Z]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ldy #$E0.b		; A0 E0 ; Load #$E0.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DE5E72.l,X		; FF 72 5E DE ; Subtract with carry (long,X) $DE5E72.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp.w [$E0F8]		; DC F8 E0 ; Jump long indirect [$E0F8] [Flow: jump]
	and $3F430F.l,X		; 3F 0F 43 3F ; AND accumulator with memory (long,X) $3F430F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $331E.w		; 0C 1E 33 ; Test and set bits $331E.w [Reads: Accumulator] [Flags: Z]
	ora ($37.b,S),Y		; 13 37 ; OR accumulator (stack relative indirect indexed) ($37.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$6F.b],Y		; 17 6F ; OR accumulator with memory (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $185F.w		; 2E 5F 18 ; Rotate left $185F.w [Flags: ZNC]
	jmp ($2000.w,X)		; 7C 00 20 ; Jump indirect indexed to ($2000.w,X) [Reads: X Index] [Flow: jump]
	jsr $2C32.w		; 20 32 2C ; Jump to subroutine at $2C32.w [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	eor ($67.b),Y		; 51 67 ; Exclusive OR accumulator with memory ($67.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($D0EC.w,X)		; 7C EC D0 ; Jump indirect indexed to ($D0EC.w,X) [Reads: X Index] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $D0, $D8		; D0 D8 ; Branch if not equal to $D0, $D8 [Flow: branch]
	.db $D0, $98		; D0 98 ; Branch if not equal to $D0, $98 [Flow: branch]
	.db $90, $F0		; 90 F0 ; Branch if carry clear to $90, $F0 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	jsl $20E000.l		; 22 00 E0 20 ; Jump to subroutine long $20E000.l [Writes: Stack Pointer] [Flow: call]
	bit $2838.w		; 2C 38 28 ; Test bits $2838.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3E0C2C.l		; 0F 2C 0C 3E ; OR accumulator with memory (long) $3E0C2C.l [Writes: Accumulator] [Flags: ZN]
	tsb $034B.w		; 0C 4B 03 ; Test and set bits $034B.w [Reads: Accumulator] [Flags: Z]
	adc [$27.b]		; 67 27 ; Add with carry (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $30BF1E.l,X		; 9F 1E BF 30 ; Store accumulator (long,X) $30BF1E.l,X [Reads: Accumulator, X Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($33.b,S),Y		; 33 33 ; AND accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($E158.w,X)		; 7C 58 E1 ; Jump indirect indexed to ($E158.w,X) [Reads: X Index] [Flow: jump]
	cmp $43EC78.l		; CF 78 EC 43 ; Compare accumulator (long) $43EC78.l [Reads: Accumulator] [Flags: ZNC]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora [$D0.b]		; 07 D0 ; OR accumulator with memory (long) [$D0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $B8		; F0 B8 ; Branch if equal to $F0, $B8 [Flow: branch]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	jsl $3C0600.l		; 22 00 06 3C ; Jump to subroutine long $3C0600.l [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	cpx $60.b		; E4 60 ; Compare $60.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $90		; 10 90 ; Branch if plus to $10, $90 [Flow: branch]
	jsr $6090.w		; 20 90 60 ; Jump to subroutine at $6090.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	.db $D0, $90		; D0 90 ; Branch if not equal to $D0, $90 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stx $D0.b		; 86 D0 ; Store X register to $D0.b [Reads: X Index]
	ora $28.b		; 05 28 ; Logical OR $28.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$05.b		; E0 05 ; Compare #$05.b with X register [Reads: X Index] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $430100.l,X		; FF 00 01 43 ; Subtract with carry (long,X) $430100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$2C.b		; E0 2C ; Compare #$2C.b with X register [Reads: X Index] [Flags: ZNC]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $E4.b		; 04 E4 ; Test and set bits $E4.b [Reads: Accumulator] [Flags: Z]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cmp #$FB30.w		; C9 30 FB ; Compare #$FB30.w with accumulator [Reads: Accumulator] [Flags: ZNC]
.ACCU 16
.INDEX 16
	rep #$BF		; C2 BF
	jsr $6EF1.w		; 20 F1 6E ; Jump to subroutine at $6EF1.w [Writes: Stack Pointer] [Flow: call]
	sbc ($8E.b),Y		; F1 8E ; Subtract with carry ($8E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx #$FC5C.w		; A2 5C FC ; Load #$FC5C.w into X register [Writes: X Index] [Flags: ZN]
	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	and $91DF.w,X		; 3D DF 91 ; AND accumulator with memory $91DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($62.b),Y		; 11 62 ; OR accumulator with memory ($62.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $020B.w		; 2D 0B 02 ; Logical AND $020B.w with accumulator [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$9F.b]		; 07 9F ; OR accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1F0E.w		; 0D 0E 1F ; Logical OR $1F0E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	cpx #$3000.w		; E0 00 30 ; Compare #$3000.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$F008.w		; C0 08 F0 ; Compare #$F008.w with Y register [Reads: Y Index] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $D0, $A4		; D0 A4 ; Branch if not equal to $D0, $A4 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cpx $98.b		; E4 98 ; Compare $98.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	pea $F808.w		; F4 08 F8 ; Push absolute address $F808.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jsr $F0E0.w		; 20 E0 F0 ; Jump to subroutine at $F0E0.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($3C7C.w,X)		; FC 7C 3C ; Jump to subroutine indirect indexed ($3C7C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $010300.l,X		; 3F 00 03 01 ; AND accumulator with memory (long,X) $010300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $23		; 30 23 ; Branch if minus to $30, $23 [Flow: branch]
	and $008002.l,X		; 3F 02 80 00 ; AND accumulator with memory (long,X) $008002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp $FC00.w		; 4C 00 FC ; Jump to $FC00.w [Flow: jump]
	tsb $80.b		; 04 80 ; Test and set bits $80.b [Reads: Accumulator] [Flags: Z]
	cpy #$C4FC.w		; C0 FC C4 ; Compare #$C4FC.w with Y register [Reads: Y Index] [Flags: ZNC]
	pea $FC22.w		; F4 22 FC ; Push absolute address $FC22.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpx #$71FC.w		; E0 FC 71 ; Compare #$71FC.w with X register [Reads: X Index] [Flags: ZNC]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($BF.b),Y		; 71 BF ; Add with carry ($BF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $2C0E.w		; 4E 0E 2C ; Logical shift right $2C0E.w [Flags: ZNC]
	tsb $0C3E.w		; 0C 3E 0C ; Test and set bits $0C3E.w [Reads: Accumulator] [Flags: Z]
	and $145E0D.l,X		; 3F 0D 5E 14 ; AND accumulator with memory (long,X) $145E0D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($8A.b),Y		; 71 8A ; Add with carry ($8A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy $71.b		; C4 71 ; Compare $71.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	and ($31.b,S),Y		; 33 31 ; AND accumulator (stack relative indirect indexed) ($31.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($6B.b)		; 32 6B ; AND accumulator with memory (indirect) ($6B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stx $DF00.w		; 8E 00 DF ; Store X register to $DF00.w [Reads: X Index]
	stx $DCFD.w		; 8E FD DC ; Store X register to $DCFD.w [Reads: X Index]
	adc ($70.b)		; 72 70 ; Add with carry (indirect) ($70.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	bit $30.b,X		; 34 30 ; Test bits $30.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	jmp ($FC30.w,X)		; 7C 30 FC ; Jump indirect indexed to ($FC30.w,X) [Reads: X Index] [Flow: jump]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $8E		; 30 8E ; Branch if minus to $30, $8E [Flow: branch]
	eor ($23.b),Y		; 51 23 ; Exclusive OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	stx $8CCC.w		; 8E CC 8C ; Store X register to $8CCC.w [Reads: X Index]
	mvp $23,$C8		; 44 C8 23 ; Move block positive $23,$C8 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $57.b		; 00 57 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $DB.b,S		; 03 DB ; OR accumulator with stack relative $DB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor [$CC.b]		; 47 CC ; Exclusive OR accumulator with memory (long) [$CC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$E8.b]		; 47 E8 ; Exclusive OR accumulator with memory (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jmp ($7E38.w,X)		; 7C 38 7E ; Jump indirect indexed to ($7E38.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $230C.w,X		; 3C 0C 23 ; Test bits $230C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	stz $BC.b,X		; 74 BC ; Store zero to $BC.b,X [Reads: X Index]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	lda [$47.b],Y		; B7 47 ; Load accumulator (long indexed) [$47.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor [$33.b]		; 47 33 ; Exclusive OR accumulator with memory (long) [$33.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	nop		; EA ; No operation
	cpy #$E2DB.w		; C0 DB E2 ; Compare #$E2DB.w with Y register [Reads: Y Index] [Flags: ZNC]
	and ($E2.b,S),Y		; 33 E2 ; AND accumulator (stack relative indirect indexed) ($E2.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$12.b],Y		; 17 12 ; OR accumulator with memory (long indexed) [$12.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $7E1C.w,X		; 3E 1C 7E ; Rotate left $7E1C.w,X [Reads: X Index] [Flags: ZNC]
	trb $303C.w		; 1C 3C 30 ; Test and reset bits $303C.w [Reads: Accumulator] [Flags: Z]
	cpy $2E.b		; C4 2E ; Compare $2E.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	and $EDDD.w,X		; 3D DD ED ; AND accumulator with memory $EDDD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
.ACCU 8
	sep #$E2		; E2 E2
	cpy $000E.w		; CC 0E 00 ; Compare $000E.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ror $9F11.w		; 6E 11 9F ; Rotate right $9F11.w [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $1B06.w,Y		; 79 06 1B ; Add $1B06.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $3E.b		; 05 3E ; Logical OR $3E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($5D.b)		; 12 5D ; OR accumulator with memory (indirect) ($5D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $0E.b,X		; 34 0E ; Test bits $0E.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ora ($6E.b),Y		; 11 6E ; OR accumulator with memory ($6E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sta ($77.b),Y		; 91 77 ; Store accumulator ($77.b),Y [Reads: Accumulator, Direct Page, Y Index]
	asl $3D.b,X		; 16 3D ; Arithmetic shift left $3D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $76		; 70 76 ; Branch if overflow set to $70, $76 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sbc $9E06.w,Y		; F9 06 9E ; Subtract with carry $9E06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cld		; D8 ; Clear decimal flag [Flags: D]
	ldy #$487C.w		; A0 7C 48 ; Load #$487C.w into Y register [Writes: Y Index] [Flags: ZN]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	bit $8870.w		; 2C 70 88 ; Test bits $8870.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $89.b,X		; 76 89 ; Rotate right $89.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inc $BC68.w		; EE 68 BC ; Increment $BC68.w [Flags: ZN]
	lsr $0001.w,X		; 5E 01 00 ; Logical shift right $0001.w,X [Reads: X Index] [Flags: ZNC]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora [$DD.b]		; 07 DD ; OR accumulator with memory (long) [$DD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $4ACE.w		; 4D CE 4A ; Exclusive OR $4ACE.w with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $7C68.w		; EE 68 7C ; Increment $7C68.w [Flags: ZN]
	bit $78.b,X		; 34 78 ; Test bits $78.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $97B5B2.l,X		; 7F B2 B5 97 ; Add long $97B5B2.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	adc [$80.b],Y		; 77 80 ; Add with carry (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $1A		; 80 1A ; Branch always to $80, $1A [Flow: branch]
	cpx #$B2BB.w		; E0 BB B2 ; Compare #$B2BB.w with X register [Reads: X Index] [Flags: ZNC]
	adc ($52.b,S),Y		; 73 52 ; Add with carry (stack relative indirect indexed) ($52.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$16.b],Y		; 77 16 ; Add with carry (long indexed) [$16.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $1C2C.w,X		; 3E 2C 1C ; Rotate left $1C2C.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $80		; 10 80 ; Branch if plus to $10, $80 [Flow: branch]
	stz $FE.b		; 64 FE ; Store zero to $FE.b
	eor $E9AD.w		; 4D AD E9 ; Exclusive OR $E9AD.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cmp ($EC.b)		; D2 EC ; Compare accumulator (indirect) ($EC.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0A1400.l		; 0F 00 14 0A ; OR accumulator with memory (long) $0A1400.l [Writes: Accumulator] [Flags: ZN]
	jsl $1E211D.l		; 22 1D 21 1E ; Jump to subroutine long $1E211D.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($44.b,X)		; 21 44 ; Logical AND ($44.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	lsr $00E0.w		; 4E E0 00 ; Logical shift right $00E0.w [Flags: ZNC]
	eor ($00.b)		; 52 00 ; Exclusive OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp ($2800.w,X)		; 7C 00 28 ; Jump indirect indexed to ($2800.w,X) [Reads: X Index] [Flow: jump]
	.db $50, $44		; 50 44 ; Branch if overflow clear to $50, $44 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sty $68.b		; 84 68 ; Store Y register to $68.b [Reads: Y Index]
	jsl $0C7284.l		; 22 84 72 0C ; Jump to subroutine long $0C7284.l [Writes: Stack Pointer] [Flow: call]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $A8		; F0 A8 ; Branch if equal to $F0, $A8 [Flow: branch]
	mvp $5A,$94		; 44 94 5A ; Move block positive $5A,$94 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $82, $0F, $00		; 82 0F 00 ; Branch always long to $82, $0F, $00 [Flow: branch]
	asl $1E01.w		; 0E 01 1E ; Arithmetic shift left $1E01.w [Flags: ZNC]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	jsl $4FE000.l		; 22 00 E0 4F ; Jump to subroutine long $4FE000.l [Writes: Stack Pointer] [Flow: call]
	tsb $190D.w		; 0C 0D 19 ; Test and set bits $190D.w [Reads: Accumulator] [Flags: Z]
	ora $0F1B1B.l,X		; 1F 1B 1B 0F ; Logical OR long $0F1B1B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $A876.w		; 9C 76 A8 ; Store zero to $A876.w
	dec $9D74.w,X		; DE 74 9D ; Decrement memory $9D74.w,X [Reads: X Index] [Flags: ZN]
	inc $FEFB.w,X		; FE FB FE ; Increment memory $FEFB.w,X [Reads: X Index] [Flags: ZN]
	inc $BC0C.w,X		; FE 0C BC ; Increment memory $BC0C.w,X [Reads: X Index] [Flags: ZN]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FE.b,X		; F6 FE ; Increment memory $FE.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $CCFEFF.l,X		; FF FF FE CC ; Subtract with carry (long,X) $CCFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $BF		; F0 BF ; Branch if equal to $F0, $BF [Flow: branch]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$78.b]		; 07 78 ; OR accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$39.b],Y		; 37 39 ; AND accumulator with memory (long indexed) [$39.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $1F.b,X		; 16 1F ; Arithmetic shift left $1F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	.db $D0, $2C		; D0 2C ; Branch if not equal to $D0, $2C [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $F8D4.w,X		; 3C D4 F8 ; Test bits $F8D4.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jsr ($F818.w,X)		; FC 18 F8 ; Jump to subroutine indirect indexed ($F818.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$00F0.w		; E0 F0 00 ; Compare #$00F0.w with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $FCFE.w,X		; 3C FE FC ; Test bits $FCFE.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jsr ($F018.w,X)		; FC 18 F0 ; Jump to subroutine indirect indexed ($F018.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $000224.l,X		; 3F 24 02 00 ; AND accumulator with memory (long,X) $000224.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr ($0100.w,X)		; FC 00 01 ; Jump to subroutine indirect indexed ($0100.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$4780.w		; C0 80 47 ; Compare #$4780.w with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	jsr ($40FC.w,X)		; FC FC 40 ; Jump to subroutine indirect indexed ($40FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $C0.b,S		; 23 C0 ; AND accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$80F1.w		; E0 F1 80 ; Compare #$80F1.w with X register [Reads: X Index] [Flags: ZNC]
	ldy $FE34.w,X		; BC 34 FE ; Load Y register $FE34.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	and ($BE.b)		; 32 BE ; AND accumulator with memory (indirect) ($BE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $65,$9F		; 44 9F 65 ; Move block positive $65,$9F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	adc $2E06.w,X		; 7D 06 2E ; Add $2E06.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and [$04.b]		; 27 04 ; AND accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $CB00.w,X		; 1E 00 CB ; Arithmetic shift left $CB00.w,X [Reads: X Index] [Flags: ZNC]
	cmp $8EBF.w		; CD BF 8E ; Compare $8EBF.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	eor $1E3B37.l,X		; 5F 37 3B 1E ; Exclusive OR accumulator with memory (long,X) $1E3B37.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $7A20.w,X		; 3C 20 7A ; Test bits $7A20.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	adc $FF2C.w,X		; 7D 2C FF ; Add $FF2C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldy $62BD.w		; AC BD 62 ; Load $62BD.w into Y register [Writes: Y Index] [Flags: ZN]
	adc $CEC6.w,Y		; 79 C6 CE ; Add $CEC6.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $F3.b,Y		; B6 F3 ; Load X register $F3.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	adc ($FD.b,S),Y		; 73 FD ; Add with carry (stack relative indirect indexed) ($FD.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($CA.b),Y		; F1 CA ; Subtract with carry ($CA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $5E.b		; 04 5E ; Test and set bits $5E.b [Reads: Accumulator] [Flags: Z]
	bit $BE.b		; 24 BE ; Test bits $BE.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc $D61A.w,X		; FE 1A D6 ; Increment memory $D61A.w,X [Reads: X Index] [Flags: ZN]
	tsb $08BC.w		; 0C BC 08 ; Test and set bits $08BC.w [Reads: Accumulator] [Flags: Z]
	eor $6730.w		; 4D 30 67 ; Exclusive OR $6730.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $003D.w,Y		; 39 3D 00 ; AND accumulator with memory $003D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $BFFD.w,X		; FD FD BF ; Subtract with carry $BFFD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $3D664F.l,X		; FF 4F 66 3D ; Subtract with carry (long,X) $3D664F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	bit $7D.b		; 24 7D ; Test bits $7D.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lsr $7F.b,X		; 56 7F ; Logical shift right $7F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $3D		; 30 3D ; Branch if minus to $30, $3D [Flow: branch]
	.db $10, $B2		; 10 B2 ; Branch if plus to $10, $B2 [Flow: branch]
	tsb $9CE6.w		; 0C E6 9C ; Test and set bits $9CE6.w [Reads: Accumulator] [Flags: Z]
	ldy $DE00.w,X		; BC 00 DE ; Load Y register $DE00.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	lda $FFFDBF.l,X		; BF BF FD FF ; Load long $FFFDBF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($66.b)		; F2 66 ; Subtract with carry (indirect) ($66.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ldy $74BC.w,X		; BC BC 74 ; Load Y register $74BC.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	ldx $766A.w,Y		; BE 6A 76 ; Load X register $766A.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	bit $1D37.w		; 2C 37 1D ; Test bits $1D37.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $175F.w		; 2E 5F 17 ; Rotate left $175F.w [Flags: ZNC]
	eor [$00.b],Y		; 57 00 ; Exclusive OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $FB00.w		; 2C 00 FB ; Test bits $FB00.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sbc $3E7F.w,X		; FD 7F 3E ; Subtract with carry $3E7F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $2C7F6F.l,X		; 5F 6F 7F 2C ; Exclusive OR accumulator with memory (long,X) $2C7F6F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $7D2E.w,X		; 3D 2E 7D ; AND accumulator with memory $7D2E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lsr $6E.b,X		; 56 6E ; Logical shift right $6E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	bit $EC.b,X		; 34 EC ; Test bits $EC.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	dec $FA74.w,X		; DE 74 FA ; Decrement memory $FA74.w,X [Reads: X Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	nop		; EA ; No operation
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $FA7CFE.l,X		; BF FE 7C FA ; Load long $FA7CFE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FE.b,X		; F6 FE ; Increment memory $FE.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	bit $BD.b,X		; 34 BD ; Test bits $BD.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	jmp ($04FE.w)		; 6C FE 04 ; Jump indirect to ($04FE.w) [Flow: jump]
	cmp $B708.w,X		; DD 08 B7 ; Compare accumulator $B708.w,X [Reads: X Index] [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	adc $324F0D.l,X		; 7F 0D 4F 32 ; Add long $324F0D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $38.b		; 66 38 ; Rotate right $38.b [Reads: Direct Page] [Flags: ZNC]
	bit $F300.w,X		; 3C 00 F3 ; Test bits $F300.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $4F7EFD.l,X		; BF FD 7E 4F ; Load long $4F7EFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $3C.b		; 66 3C ; Rotate right $3C.b [Reads: Direct Page] [Flags: ZNC]
	lda $7F36.w,X		; BD 36 7F ; Load $7F36.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr $10BB.w		; 20 BB 10 ; Jump to subroutine at $10BB.w [Writes: Stack Pointer] [Flow: call]
	sbc $FE58.w		; ED 58 FE ; Subtract $FE58.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	.db $B0, $F2		; B0 F2 ; Branch if carry set to $B0, $F2 [Flow: branch]
	jmp $1C66.w		; 4C 66 1C ; Jump to $1C66.w [Flow: jump]
	bit $CF00.w,X		; 3C 00 CF ; Test bits $CF00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp $7EBFFD.l,X		; DF FD BF 7E ; Compare accumulator (long,X) $7EBFFD.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc ($66.b)		; F2 66 ; Subtract with carry (indirect) ($66.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	bit $3840.w,X		; 3C 40 38 ; Test bits $3840.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and [$40.b],Y		; 37 40 ; AND accumulator with memory (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $101C.w		; 20 1C 10 ; Jump to subroutine at $101C.w [Writes: Stack Pointer] [Flow: call]
	ora $03030C.l		; 0F 0C 03 03 ; OR accumulator with memory (long) $03030C.l [Writes: Accumulator] [Flags: ZN]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jmp $2327.w		; 4C 27 23 ; Jump to $2327.w [Flow: jump]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $EC02.w		; 1C 02 EC ; Test and reset bits $EC02.w [Reads: Accumulator] [Flags: Z]
	cop $CC.b		; 02 CC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	tsb $38.b		; 04 38 ; Test and set bits $38.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
.INDEX 16
	rep #$12		; C2 12
	and ($E4.b)		; 32 E4 ; AND accumulator with memory (indirect) ($E4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy $08.b		; C4 08 ; Compare $08.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	ora $44.b,S		; 03 44 ; OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $1F.b		; 45 1F ; Exclusive OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $000700.l		; 0F 00 07 00 ; OR accumulator with memory (long) $000700.l [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1D1E1F.l		; 0F 1F 1E 1D ; OR accumulator with memory (long) $1D1E1F.l [Writes: Accumulator] [Flags: ZN]
	ora $008007.l		; 0F 07 80 00 ; OR accumulator with memory (long) $008007.l [Writes: Accumulator] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $04.b,X		; F6 04 ; Increment memory $04.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	bit $3A.b,X		; 34 3A ; Test bits $3A.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	jsr ($F6EC.w,X)		; FC EC F6 ; Jump to subroutine indirect indexed ($F6EC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	and $007F0B.l,X		; 3F 0B 7F 00 ; AND accumulator with memory (long,X) $007F0B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $0F0000.l,X		; BF 00 00 0F ; Load long $0F0000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $332F3F.l,X		; 1F 3F 2F 33 ; Logical OR long $332F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $0023FF.l,X		; 7F FF 23 00 ; Add long $0023FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	cpy #$FE06.w		; C0 06 FE ; Compare #$FE06.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E1.b		; 00 E1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	cpy #$31E0.w		; C0 E0 31 ; Compare #$31E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	inc $03DF.w,X		; FE DF 03 ; Increment memory $03DF.w,X [Reads: X Index] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0B17.w		; 0C 17 0B ; Test and set bits $0B17.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F1C1F.l		; 0F 1F 1C 0F ; OR accumulator with memory (long) $0F1C1F.l [Writes: Accumulator] [Flags: ZN]
	ora $00C0.w,Y		; 19 C0 00 ; OR accumulator with memory $00C0.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $10C0.w		; 20 C0 10 ; Jump to subroutine at $10C0.w [Writes: Stack Pointer] [Flow: call]
	cpx #$E030.w		; E0 30 E0 ; Compare #$E030.w with X register [Reads: X Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $30, $E8		; 30 E8 ; Branch if minus to $30, $E8 [Flow: branch]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	.db $80, $78		; 80 78 ; Branch always to $80, $78 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$F0E0.w		; C0 E0 F0 ; Compare #$F0E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $70, $98		; 70 98 ; Branch if overflow set to $70, $98 [Flow: branch]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sta $60.b,S		; 83 60 ; Store accumulator (stack relative) $60.b,S [Reads: Accumulator, Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$25.b]		; 07 25 ; OR accumulator with memory (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $663C.w,X		; 7E 3C 66 ; Rotate right $663C.w,X [Reads: X Index] [Flags: ZNC]
	bit $7EC3.w,X		; 3C C3 7E ; Test bits $7EC3.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc [$7E.b]		; E7 7E ; Subtract with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $7E7E.w,X		; 3C 7E 7E ; Test bits $7E7E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $DBDBFF.l,X		; FF FF DB DB ; Subtract with carry (long,X) $DBDBFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3C0000.l		; 0F 00 00 3C ; OR accumulator with memory (long) $3C0000.l [Writes: Accumulator] [Flags: ZN]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $0003.w		; AE 03 00 ; Load $0003.w into X register [Writes: X Index] [Flags: ZN]
	sbc $5AFF44.l,X		; FF 44 FF 5A ; Subtract with carry (long,X) $5AFF44.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $7E.b		; 02 7E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $BB.b		; 84 BB ; Store Y register to $BB.b [Reads: Y Index]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $62, $FF, $03		; 62 FF 03 ; Push effective relative address $62, $FF, $03 [Writes: Stack Pointer]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $641F32.l,X		; 1F 32 1F 64 ; Logical OR long $641F32.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $D43F70.l,X		; 3F 70 3F D4 ; AND accumulator with memory (long,X) $D43F70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $037FF1.l,X		; 7F F1 7F 03 ; Add long $037FF1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $773E3F.l,X		; 1F 3F 3E 77 ; Logical OR long $773E3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $FFFE.w,X		; 7D FE FF ; Add $FFFE.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$F400.w		; C0 00 F4 ; Compare #$F400.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$F43A.w		; C0 3A F4 ; Compare #$F43A.w with Y register [Reads: Y Index] [Flags: ZNC]
	asl $25FC.w		; 0E FC 25 ; Arithmetic shift left $25FC.w [Flags: ZNC]
	inc $FCAA.w,X		; FE AA FC ; Increment memory $FCAA.w,X [Reads: X Index] [Flags: ZN]
	eor ($FE.b,S),Y		; 53 FE ; XOR accumulator (stack relative indirect indexed) ($FE.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $F4C0.w,X		; FE C0 F4 ; Increment memory $F4C0.w,X [Reads: X Index] [Flags: ZN]
	inc $7DEE.w,X		; FE EE 7D ; Increment memory $7DEE.w,X [Reads: X Index] [Flags: ZN]
	inc $EFFB.w,X		; FE FB EF ; Increment memory $EFFB.w,X [Reads: X Index] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1F3807.l,X		; 1F 07 38 1F ; Logical OR long $1F3807.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $3F.b		; 66 3F ; Rotate right $3F.b [Reads: Direct Page] [Flags: ZNC]
	stz $3F.b		; 64 3F ; Store zero to $3F.b
	cpx #$D47F.w		; E0 7F D4 ; Compare #$D47F.w with X register [Reads: X Index] [Flags: ZNC]
	adc $077FE1.l,X		; 7F E1 7F 07 ; Add long $077FE1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $6D7E3F.l,X		; 1F 3F 7E 6D ; Logical OR long $6D7E3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $80FFFD.l,X		; FF FD FF 80 ; Subtract with carry (long,X) $80FFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $78		; 80 78 ; Branch always to $80, $78 [Flow: branch]
	cpx #$F81C.w		; E0 1C F8 ; Compare #$F81C.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $A6F8.w		; 0C F8 A6 ; Test and set bits $A6F8.w [Reads: Accumulator] [Flags: Z]
	jsr ($FC4E.w,X)		; FC 4E FC ; Jump to subroutine indirect indexed ($FC4E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ror $FD.b		; 66 FD ; Rotate right $FD.b [Reads: Direct Page] [Flags: ZNC]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FE5C.w,X)		; FC 5C FE ; Jump to subroutine indirect indexed ($FE5C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $00EE.w,X		; FE EE 00 ; Increment memory $00EE.w,X [Reads: X Index] [Flags: ZN]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	ora $86.b		; 05 86 ; Logical OR $86.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	adc $FE.b		; 65 FE ; Add $FE.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($00.b)		; 72 00 ; Add with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc [$F6.b],Y		; F7 F6 ; Subtract with carry (long indexed) [$F6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0000.w,X		; FD 00 00 ; Subtract with carry $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc ($D9.b,X)		; 61 D9 ; Add with carry ($D9.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ldx $7F.b		; A6 7F ; Load $7F.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	lsr $8300.w		; 4E 00 83 ; Logical shift right $8300.w [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $07BF6F.l		; EF 6F BF 07 ; Subtract with carry (long) $07BF6F.l [Writes: Accumulator] [Flags: ZVNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	rol $14.b,X		; 36 14 ; Rotate left $14.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: ZNC]
	ora #$15.b		; 09 15 ; Logical OR #$15.b with accumulator [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	sbc $387EFE.l,X		; FF FE 7E 38 ; Subtract with carry (long,X) $387EFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsl $FF0200.l		; 22 00 02 FF ; Jump to subroutine long $FF0200.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $3F0046.l,X		; 7F 46 00 3F ; Add long $3F0046.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $AF0A00.l		; 22 00 0A AF ; Jump to subroutine long $AF0A00.l [Writes: Stack Pointer] [Flow: call]
	adc $3F2F2F.l		; 6F 2F 2F 3F ; Add with carry (long) $3F2F2F.l [Writes: Accumulator] [Flags: ZVNC]
	ora $FF000F.l,X		; 1F 0F 00 FF ; Logical OR long $FF000F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $46FE.w,X		; 3E FE 46 ; Rotate left $46FE.w,X [Reads: X Index] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($C1.b,X)		; 01 C1 ; Logical OR ($C1.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $C022.w,X		; FE 22 C0 ; Increment memory $C022.w,X [Reads: X Index] [Flags: ZN]
	cpx #$8032.w		; E0 32 80 ; Compare #$8032.w with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$1B.b]		; 27 1B ; AND accumulator with memory (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$38.b]		; 47 38 ; Exclusive OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $0E5F14.l		; 6F 14 5F 0E ; Add with carry (long) $0E5F14.l [Writes: Accumulator] [Flags: ZVNC]
	and $1E0F.w		; 2D 0F 1E ; Logical AND $1E0F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $000E.w		; 0C 0E 00 ; Test and set bits $000E.w [Reads: Accumulator] [Flags: Z]
	jsr $6C44.w		; 20 44 6C ; Jump to subroutine at $6C44.w [Writes: Stack Pointer] [Flow: call]
	ror $1F3F.w,X		; 7E 3F 1F ; Rotate right $1F3F.w,X [Reads: X Index] [Flags: ZNC]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx $D8.b		; E4 D8 ; Compare $D8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
.INDEX 8
	sep #$1C		; E2 1C
	inc $28.b,X		; F6 28 ; Increment memory $28.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	.db $70, $B4		; 70 B4 ; Branch if overflow set to $70, $B4 [Flow: branch]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FC7E36.l		; 22 36 7E FC ; Jump to subroutine long $FC7E36.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $84		; 70 84 ; Branch if overflow set to $70, $84 [Flow: branch]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	ora $1F0F.w,Y		; 19 0F 1F ; OR accumulator with memory $1F0F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0C83.w		; 0E 83 0C ; Arithmetic shift left $0C83.w [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	jsl $0D041F.l		; 22 1F 04 0D ; Jump to subroutine long $0D041F.l [Writes: Stack Pointer] [Flow: call]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	sbc $FF453C.l,X		; FF 3C 45 FF ; Subtract with carry (long,X) $FF453C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $BD00.w,X		; 3C 00 BD ; Test bits $BD00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta ($44.b,X)		; 81 44 ; Store accumulator ($44.b,X) [Reads: Accumulator, X Index, Direct Page]
	sbc $3C0600.l,X		; FF 00 06 3C ; Subtract with carry (long,X) $3C0600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $FFFF7E.l,X		; FF 7E FF FF ; Subtract with carry (long,X) $FFFF7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $0B.b,S		; 43 0B ; Exclusive OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora DMALEN0H.w		; 0D 06 43 ; Logical OR DMALEN0H.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $070207.l		; 0F 07 02 07 ; OR accumulator with memory (long) $070207.l [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0F2400.l		; 22 00 24 0F ; Jump to subroutine long $0F2400.l [Writes: Stack Pointer] [Flow: call]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $00FF18.l,X		; FF 18 FF 00 ; Subtract with carry (long,X) $00FF18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: ZNC]
	sta ($E0.b,X)		; 81 E0 ; Store accumulator ($E0.b,X) [Reads: Accumulator, X Index, Direct Page]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $BDE7.w,Y		; 99 E7 BD ; Store accumulator to $BDE7.w,Y [Reads: Accumulator, Y Index]
	lda $FF7E.w,X		; BD 7E FF ; Load $FF7E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $7FEA.w,X		; 7E EA 7F ; Rotate right $7FEA.w,X [Reads: X Index] [Flags: ZNC]
	adc $193F3F.l,X		; 7F 3F 3F 19 ; Add long $193F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $113F04.l,X		; 3F 04 3F 11 ; AND accumulator with memory (long,X) $113F04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b],Y		; 17 07 ; OR accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $001D0D.l		; 2F 0D 1D 00 ; AND accumulator with memory (long) $001D0D.l [Writes: Accumulator] [Flags: ZN]
	sbc $393F7F.l,X		; FF 7F 3F 39 ; Subtract with carry (long,X) $393F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $3218.w		; 2C 18 32 ; Test bits $3218.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $FE97.w,X		; 1D 97 FE ; OR accumulator with memory $FE97.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FCFC.w,X		; FE FC FC ; Increment memory $FCFC.w,X [Reads: X Index] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($FC20.w,X)		; FC 20 FC ; Jump to subroutine indirect indexed ($FC20.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx #$F4.b		; E0 F4 ; Compare #$F4.b with X register [Reads: X Index] [Flags: ZNC]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $9CFC.w,X		; FE FC 9C ; Increment memory $9CFC.w,X [Reads: X Index] [Flags: ZN]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	jmp $AAB8.w		; 4C B8 AA ; Jump to $AAB8.w [Flow: jump]
	adc $6F7FD7.l,X		; 7F D7 7F 6F ; Add long $6F7FD7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $983F.w,X		; 3E 3F 98 ; Rotate left $983F.w,X [Reads: X Index] [Flags: ZNC]
	and $471701.l,X		; 3F 01 17 47 ; AND accumulator with memory (long,X) $471701.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sty $7C.b		; 84 7C ; Store Y register to $7C.b [Reads: Y Index]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $3C3F7F.l,X		; FF 7F 3F 3C ; Subtract with carry (long,X) $3C3F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($1D.b)		; 32 1D ; AND accumulator with memory (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stz $F8F8.w		; 9C F8 F8 ; Store zero to $F8F8.w
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	and ($F8.b,X)		; 21 F8 ; Logical AND ($F8.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $50, $FC		; 50 FC ; Branch if overflow clear to $50, $FC [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sta $92.b		; 85 92 ; Store accumulator to $92.b [Reads: Accumulator]
	ora $13.b		; 05 13 ; Logical OR $13.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr ($F8F8.w,X)		; FC F8 F8 ; Jump to subroutine indirect indexed ($F8F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	jmp $7DB8.w		; 4C B8 7D ; Jump to $7DB8.w [Flow: jump]
	bit $3C.b,X		; 34 3C ; Test bits $3C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	tsb $36.b		; 04 36 ; Test and set bits $36.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	rol $1C.b,X		; 36 1C ; Rotate left $1C.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $165F.w		; 2D 5F 16 ; Logical AND $165F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sta $7C.b,S		; 83 7C ; Store accumulator (stack relative) $7C.b,S [Reads: Accumulator, Stack Pointer]
	cop $13.b		; 02 13 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $5E3F.w,X		; 3D 3F 5E ; AND accumulator with memory $5E3F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $BE2C7F.l		; 6F 7F 2C BE ; Add with carry (long) $BE2C7F.l [Writes: Accumulator] [Flags: ZVNC]
	bit $203C.w		; 2C 3C 20 ; Test bits $203C.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	jmp ($6C58.w)		; 6C 58 6C ; Jump indirect to ($6C58.w) [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	dec $FAB4.w,X		; DE B4 FA ; Decrement memory $FAB4.w,X [Reads: X Index] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sta $94.b,S		; 83 94 ; Store accumulator (stack relative) $94.b,S [Reads: Accumulator, Stack Pointer]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $BCDC.w,X		; 5E DC BC ; Logical shift right $BCDC.w,X [Reads: X Index] [Flags: ZNC]
	jsr ($F67A.w,X)		; FC 7A F6 ; Jump to subroutine indirect indexed ($F67A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FF34.w,X		; FE 34 FF ; Increment memory $FF34.w,X [Reads: X Index] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1B.b		; 04 1B ; Test and set bits $1B.b [Reads: Accumulator] [Flags: Z]
	asl $021D.w		; 0E 1D 02 ; Arithmetic shift left $021D.w [Flags: ZNC]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $131F1E.l		; 0F 1E 1F 13 ; OR accumulator with memory (long) $131F1E.l [Writes: Accumulator] [Flags: ZN]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	jmp.w [$2620]		; DC 20 26 ; Jump long indirect [$2620] [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	and [$08.b],Y		; 37 08 ; AND accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	bit $FA.b,X		; 34 FA ; Test bits $FA.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	stz $DC.b,X		; 74 DC ; Store zero to $DC.b,X [Reads: X Index]
	.db $70, $D9		; 70 D9 ; Branch if overflow set to $70, $D9 [Flow: branch]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	cpy $F5E2.w		; CC E2 F5 ; Compare $F5E2.w with Y register [Reads: Y Index] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	jmp ($2979.w,X)		; 7C 79 29 ; Jump indirect indexed to ($2979.w,X) [Reads: X Index] [Flow: jump]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $24		; 90 24 ; Branch if carry clear to $90, $24 [Flow: branch]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ldy $64.b,X		; B4 64 ; Load Y register $64.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	tsb $0E04.w		; 0C 04 0E ; Test and set bits $0E04.w [Reads: Accumulator] [Flags: Z]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $03.b		; 24 03 ; Test bits $03.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $7FAF.w,X		; FD AF 7F ; Subtract with carry $7FAF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $EEFF.w		; 6E FF EE ; Rotate right $EEFF.w [Flags: ZNC]
	sbc $31F9D8.l,X		; FF D8 F9 31 ; Subtract with carry (long,X) $31F9D8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora ($43.b,S),Y		; 13 43 ; OR accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $5F1702.l,X		; FF 02 17 5F ; Subtract with carry (long,X) $5F1702.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $FE3F1F.l,X		; 9F 1F 3F FE ; Store accumulator (long,X) $FE3F1F.l,X [Reads: Accumulator, X Index]
	jsr ($D5B5.w,X)		; FC B5 D5 ; Jump to subroutine indirect indexed ($D5B5.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $ECF0.w		; EC F0 EC ; Compare $ECF0.w with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($F8F8.w,X)		; FC F8 F8 ; Jump to subroutine indirect indexed ($F8F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $50, $F0		; 50 F0 ; Branch if overflow clear to $50, $F0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	jsl $F808FC.l		; 22 FC 08 F8 ; Jump to subroutine long $F808FC.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $07		; 80 07 ; Branch always to $80, $07 [Flow: branch]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	and $001F.w		; 2D 1F 00 ; Logical AND $001F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and ($0D.b)		; 32 0D ; AND accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc ($1E.b,X)		; 61 1E ; Add with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $0732.w		; 4D 32 07 ; Exclusive OR $0732.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $1E1614.l		; 0F 14 16 1E ; OR accumulator with memory (long) $1E1614.l [Writes: Accumulator] [Flags: ZN]
	and $41.b,S		; 23 41 ; AND accumulator with stack relative $41.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $00D0.w		; 4D D0 00 ; Exclusive OR $00D0.w with accumulator [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $D0, $58		; D0 58 ; Branch if not equal to $D0, $58 [Flow: branch]
	cpx #$74.b		; E0 74 ; Compare #$74.b with X register [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$76.b		; C0 76 ; Compare #$76.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$99.b		; E0 99 ; Compare #$99.b with X register [Reads: X Index] [Flags: ZNC]
	inc $D0.b,X		; F6 D0 ; Increment memory $D0.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $F816.w		; 0E 16 F8 ; Arithmetic shift left $F816.w [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$90.b		; C0 90 ; Compare #$90.b with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $E8		; 30 E8 ; Branch if minus to $30, $E8 [Flow: branch]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	sty $78.b		; 84 78 ; Store Y register to $78.b [Reads: Y Index]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $70, $38		; 70 38 ; Branch if overflow set to $70, $38 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $8501.w		; 0E 01 85 ; Arithmetic shift left $8501.w [Flags: ZNC]
	stx $00.b,Y		; 96 00 ; Store X register $00.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ora $037D.w,Y		; 19 7D 03 ; OR accumulator with memory $037D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($F933.w,X)		; 7C 33 F9 ; Jump indirect indexed to ($F933.w,X) [Reads: X Index] [Flow: jump]
	rol $07.b,X		; 36 07 ; Rotate left $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora #$17.b		; 09 17 ; Logical OR #$17.b with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $2D.b		; 14 2D ; Test and reset bits $2D.b [Reads: Accumulator] [Flags: Z]
	eor $73.b,S		; 43 73 ; Exclusive OR accumulator with stack relative $73.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda [$C0.b],Y		; B7 C0 ; Load accumulator (long indexed) [$C0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C6.b		; C0 C6 ; Compare #$C6.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0902.w,X		; FD 02 09 ; Subtract with carry $0902.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	dec $BB.b		; C6 BB ; Decrement $BB.b [Reads: Direct Page] [Flags: ZN]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cop $7D.b		; 02 7D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$08.b		; 89 08 ; Test bits #$08.b with accumulator [Reads: Accumulator] [Flags: Z]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: ZN]
	adc $0082.w,X		; 7D 82 00 ; Add $0082.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $18.b		; 84 18 ; Store Y register to $18.b [Reads: Y Index]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $9B.b		; E6 9B ; Increment $9B.b [Reads: Direct Page] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F1800.l		; 0F 00 18 0F ; OR accumulator with memory (long) $0F1800.l [Writes: Accumulator] [Flags: ZN]
	eor $36.b,S		; 43 36 ; Exclusive OR accumulator with stack relative $36.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3E0D.w,Y		; 19 0D 3E ; OR accumulator with memory $3E0D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3D391F.l		; 0F 1F 39 3D ; OR accumulator with memory (long) $3D391F.l [Writes: Accumulator] [Flags: ZN]
	and $0000.w,X		; 3D 00 00 ; AND accumulator with memory $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	eor $40.b,S		; 43 40 ; Exclusive OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $09		; 80 09 ; Branch always to $80, $09 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	stz $C0.b		; 64 C0 ; Store zero to $C0.b
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	cpy $E2.b		; C4 E2 ; Compare $E2.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	jsr ($8000.w,X)		; FC 00 80 ; Jump to subroutine indirect indexed ($8000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $E40CC0.l		; 22 C0 0C E4 ; Jump to subroutine long $E40CC0.l [Writes: Stack Pointer] [Flow: call]
	inc $21FE.w,X		; FE FE 21 ; Increment memory $21FE.w,X [Reads: X Index] [Flags: ZN]
	asl $314E.w,X		; 1E 4E 31 ; Arithmetic shift left $314E.w,X [Reads: X Index] [Flags: ZNC]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $010300.l		; 0F 00 03 01 ; OR accumulator with memory (long) $010300.l [Writes: Accumulator] [Flags: ZN]
	eor $04.b,S		; 43 04 ; Exclusive OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $08.b,X		; 34 08 ; Test bits $08.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $0F31.w		; 4E 31 0F ; Logical shift right $0F31.w [Flags: ZNC]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $B2F0.w,Y		; 99 F0 B2 ; Store accumulator to $B2F0.w,Y [Reads: Accumulator, Y Index]
	adc ($F7.b,X)		; 61 F7 ; Add with carry ($F7.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	and [$F9.b]		; 27 F9 ; AND accumulator with memory (long) [$F9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $FE5E7B.l		; EF 7B 5E FE ; Subtract with carry (long) $FE5E7B.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $F99FFE.l,X		; DF FE 9F F9 ; Compare accumulator (long,X) $F99FFE.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc ($F7.b,S),Y		; F3 F7 ; Subtract with carry (stack relative indirect indexed) ($F7.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3FBF1F.l,X		; DF 1F BF 3F ; Compare accumulator (long,X) $3FBF1F.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $93B04E.l,X		; 7F 4E B0 93 ; Add long $93B04E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($58A6.w)		; 6C A6 58 ; Jump indirect to ($58A6.w) [Flow: jump]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $90, $98		; 90 98 ; Branch if carry clear to $90, $98 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	.db $F0, $58		; F0 58 ; Branch if equal to $F0, $58 [Flow: branch]
	.db $F0, $CC		; F0 CC ; Branch if equal to $F0, $CC [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	dec $F6F1.w		; CE F1 F6 ; Decrement $F6F1.w [Flags: ZN]
	and $F8.b,S		; 23 F8 ; AND accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $7F		; 30 7F ; Branch if minus to $30, $7F [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and $081E1A.l,X		; 3F 1A 1E 08 ; AND accumulator with memory (long,X) $081E1A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0024.w		; 0C 24 00 ; Test and set bits $0024.w [Reads: Accumulator] [Flags: Z]
	ora $7D.b		; 05 7D ; Logical OR $7D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $162545.l		; CF 45 25 16 ; Compare accumulator (long) $162545.l [Reads: Accumulator] [Flags: ZNC]
	tsb $0039.w		; 0C 39 00 ; Test and set bits $0039.w [Reads: Accumulator] [Flags: Z]
	cpx #$28.b		; E0 28 ; Compare #$28.b with X register [Reads: X Index] [Flags: ZNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	and ($3C.b,X)		; 21 3C ; Logical AND ($3C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and [$04.b]		; 27 04 ; AND accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $000100.l,X		; 1F 00 01 00 ; Logical OR long $000100.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $091133.l,X		; 5F 33 11 09 ; Exclusive OR accumulator with memory (long,X) $091133.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$3B.b],Y		; 17 3B ; OR accumulator with memory (long indexed) [$3B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $FA4701.l,X		; 1F 01 47 FA ; Logical OR long $FA4701.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec $7C.b		; C6 7C ; Decrement $7C.b [Reads: Direct Page] [Flags: ZN]
	ror $7E38.w,X		; 7E 38 7E ; Rotate right $7E38.w,X [Reads: X Index] [Flags: ZNC]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $BC07FE.l		; 22 FE 07 BC ; Jump to subroutine long $BC07FE.l [Writes: Stack Pointer] [Flow: call]
	cld		; D8 ; Clear decimal flag [Flags: D]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	ora [$11.b]		; 07 11 ; OR accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0F43.w		; 0E 43 0F ; Arithmetic shift left $0F43.w [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sta $C0.b,S		; 83 C0 ; Store accumulator (stack relative) $C0.b,S [Reads: Accumulator, Stack Pointer]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$1F.b],Y		; 17 1F ; OR accumulator with memory (long indexed) [$1F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $4304.w		; 0E 04 43 ; Arithmetic shift left $4304.w [Flags: ZNC]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: ZNC]
	pea $C408.w		; F4 08 C4 ; Push absolute address $C408.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $6FE0.w,X		; 1E E0 6F ; Arithmetic shift left $6FE0.w,X [Reads: X Index] [Flags: ZNC]
	.db $90, $83		; 90 83 ; Branch if carry clear to $90, $83 [Flow: branch]
	jmp ($A856.w,X)		; 7C 56 A8 ; Jump indirect indexed to ($A856.w,X) [Reads: X Index] [Flow: jump]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F5F6.w,X		; 3C F6 F5 ; Test bits $F5F6.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $78BE.w,X		; FD BE 78 ; Subtract with carry $78BE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $C7		; F0 C7 ; Branch if equal to $F0, $C7 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	lda $037C40.l,X		; BF 40 7C 03 ; Load long $037C40.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $0026.w,X		; 1E 26 00 ; Arithmetic shift left $0026.w,X [Reads: X Index] [Flags: ZNC]
	tsb $BE.b		; 04 BE ; Test and set bits $BE.b [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $0022.w,X		; 1E 22 00 ; Arithmetic shift left $0022.w,X [Reads: X Index] [Flags: ZNC]
	tsb $00FE.w		; 0C FE 00 ; Test and set bits $00FE.w [Reads: Accumulator] [Flags: Z]
	ldx $1640.w,Y		; BE 40 16 ; Load X register $1640.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	ldx $48.b,Y		; B6 48 ; Load X register $48.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	adc $1C.b,S		; 63 1C ; Add with carry (stack relative) $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $0022.w		; 0E 22 00 ; Arithmetic shift left $0022.w [Flags: ZNC]
	trb $06.b		; 14 06 ; Test and reset bits $06.b [Reads: Accumulator] [Flags: Z]
	.db $42, $EA		; 42 EA ; Reserved instruction
	nop		; EA ; No operation
	adc $000E1D.l,X		; 7F 1D 0E 00 ; Add long $000E1D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	and [$C7.b],Y		; 37 C7 ; AND accumulator with memory (long indexed) [$C7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	stx $7D71.w		; 8E 71 7D ; Store X register to $7D71.w [Reads: X Index]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $B71400.l		; 22 00 14 B7 ; Jump to subroutine long $B71400.l [Writes: Stack Pointer] [Flow: call]
	ldy $7BF9.w,X		; BC F9 7B ; Load Y register $7BF9.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B3.b		; 00 B3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $06F9.w		; 4C F9 06 ; Jump to $06F9.w [Flow: jump]
	cmp #$36.b		; C9 36 ; Compare #$36.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	.db $82, $7C, $4C		; 82 7C 4C ; Branch always long to $82, $7C, $4C [Flow: branch]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	jsl $071400.l		; 22 00 14 07 ; Jump to subroutine long $071400.l [Writes: Stack Pointer] [Flow: call]
	adc $37CF.w,X		; 7D CF 37 ; Add $37CF.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $B8FC.w,X		; FE FC B8 ; Increment memory $B8FC.w,X [Reads: X Index] [Flags: ZN]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ror $1A.b		; 66 1A ; Rotate right $1A.b [Reads: Direct Page] [Flags: ZNC]
	jmp ($5F10.w)		; 6C 10 5F ; Jump indirect to ($5F10.w) [Flow: jump]
	jsr $102F.w		; 20 2F 10 ; Jump to subroutine at $102F.w [Writes: Stack Pointer] [Flow: call]
	ora [$02.b],Y		; 17 02 ; OR accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$47.b]		; 27 47 ; AND accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $152E5C.l		; 4F 5C 2E 15 ; Exclusive OR accumulator with memory (long) $152E5C.l [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cmp $7AC7B6.l,X		; DF B6 C7 7A ; Compare accumulator (long,X) $7AC7B6.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc [$78.b]		; E7 78 ; Subtract with carry (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $3C.b,S		; 63 3C ; Add with carry (stack relative) $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	lda ($1E.b),Y		; B1 1E ; Load accumulator ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $00CE0E.l,X		; 3F 0E CE 00 ; AND accumulator with memory (long,X) $00CE0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $8330FE.l,X		; FF FE 30 83 ; Subtract with carry (long,X) $8330FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$03.b]		; 27 03 ; AND accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $017F00.l,X		; 7F 00 7F 01 ; Add long $017F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $1A7F01.l,X		; FF 01 7F 1A ; Subtract with carry (long,X) $1A7F01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $090B1D.l,X		; 3F 1D 0B 09 ; AND accumulator with memory (long,X) $090B1D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $5B.b		; 24 5B ; Test bits $5B.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $862265.l,X		; BF 65 22 86 ; Load long $862265.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $3FFF.w,Y		; D9 FF 3F ; Compare accumulator $3FFF.w,Y [Reads: Y Index] [Flags: ZNC]
	sbc $28FFD5.l,X		; FF D5 FF 28 ; Subtract with carry (long,X) $28FFD5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $708383.l,X		; FF 83 83 70 ; Subtract with carry (long,X) $708383.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $8A7C00.l,X		; FF 00 7C 8A ; Subtract with carry (long,X) $8A7C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $D8		; 80 D8 ; Branch always to $80, $D8 [Flow: branch]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	jsr ($F804.w,X)		; FC 04 F8 ; Jump to subroutine indirect indexed ($F804.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $70, $68		; 70 68 ; Branch if overflow set to $70, $68 [Flow: branch]
	sta $48.b		; 85 48 ; Store accumulator to $48.b [Reads: Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $01,$03		; 44 03 01 ; Move block positive $01,$03 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: ZNC]
	eor [$00.b],Y		; 57 00 ; Exclusive OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $070003.l		; 22 03 00 07 ; Jump to subroutine long $070003.l [Writes: Stack Pointer] [Flow: call]
	sta ($18.b,S),Y		; 93 18 ; Store accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $032F8C.l,X		; FF 8C 2F 03 ; Subtract with carry (long,X) $032F8C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F806.w,X)		; FC 06 F8 ; Jump to subroutine indirect indexed ($F806.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$03.b		; C0 03 ; Compare #$03.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: ZNC]
	cpx #$29.b		; E0 29 ; Compare #$29.b with X register [Reads: X Index] [Flags: ZNC]
	ora $0E02.w		; 0D 02 0E ; Logical OR $0E02.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $031F0B.l,X		; 1F 0B 1F 03 ; Logical OR long $031F0B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$18.b		; 09 18 ; Logical OR #$18.b with accumulator [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3CCE.w		; 0C CE 3C ; Test and set bits $3CCE.w [Reads: Accumulator] [Flags: Z]
	jmp ($B0B0.w,X)		; 7C B0 B0 ; Jump indirect indexed to ($B0B0.w,X) [Reads: X Index] [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $BCBE.w		; CE BE BC ; Decrement $BCBE.w [Flags: ZN]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$2B.b		; E0 2B ; Compare #$2B.b with X register [Reads: X Index] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $1F07.w		; 0C 07 1F ; Test and set bits $1F07.w [Reads: Accumulator] [Flags: Z]
	ora $3F033F.l		; 0F 3F 03 3F ; OR accumulator with memory (long) $3F033F.l [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc [$37.b],Y		; 77 37 ; Add with carry (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $48273F.l,X		; 1F 3F 27 48 ; Logical OR long $48273F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $C100.w,X		; 7E 00 C1 ; Rotate right $C100.w,X [Reads: X Index] [Flags: ZNC]
	rol $FE3B.w,X		; 3E 3B FE ; Rotate left $FE3B.w,X [Reads: X Index] [Flags: ZNC]
	stx $EEFC.w		; 8E FC EE ; Store X register to $EEFC.w [Reads: X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $FD78.w,X		; FD 78 FD ; Subtract with carry $FD78.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FEFEFF.l,X		; FF FF FE FE ; Subtract with carry (long,X) $FEFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0023FF.l,X		; FF FF 23 00 ; Subtract with carry (long,X) $0023FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($06.b,S),Y		; 13 06 ; OR accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $EE.b		; 46 EE ; Logical shift right $EE.b [Reads: Direct Page] [Flags: ZNC]
	ora ($94.b),Y		; 11 94 ; OR accumulator with memory ($94.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $6F.b		; 06 6F ; Arithmetic shift left $6F.b [Reads: Direct Page] [Flags: ZNC]
	sbc $9CEEB9.l,X		; FF B9 EE 9C ; Subtract with carry (long,X) $9CEEB9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $4C		; 70 4C ; Branch if overflow set to $70, $4C [Flow: branch]
	.db $B0, $0C		; B0 0C ; Branch if carry set to $B0, $0C [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $0C4C.w		; 8C 4C 0C ; Store Y register to $0C4C.w [Reads: Y Index]
	sta $52.b,S		; 83 52 ; Store accumulator (stack relative) $52.b,S [Reads: Accumulator, Stack Pointer]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $1801.w		; 0E 01 18 ; Arithmetic shift left $1801.w [Flags: ZNC]
	ora $193643.l		; 0F 43 36 19 ; OR accumulator with memory (long) $193643.l [Writes: Accumulator] [Flags: ZN]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	stx $61.b		; 86 61 ; Store X register to $61.b [Reads: X Index]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and [$E0.b]		; 27 E0 ; AND accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$FC.b		; A0 FC ; Load #$FC.b into Y register [Writes: Y Index] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	inc $8C.b,X		; F6 8C ; Increment memory $8C.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	ror $DC.b		; 66 DC ; Rotate right $DC.b [Reads: Direct Page] [Flags: ZNC]
	lsr $8EBC.w		; 4E BC 8E ; Logical shift right $8EBC.w [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp $F8E0FA.l,X		; DF FA E0 F8 ; Compare accumulator (long,X) $F8E0FA.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	jsr ($FE23.w,X)		; FC 23 FE ; Jump to subroutine indirect indexed ($FE23.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $90.b		; 84 90 ; Store Y register to $90.b [Reads: Y Index]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1C0F13.l		; 0F 13 0F 1C ; OR accumulator with memory (long) $1C0F13.l [Writes: Accumulator] [Flags: ZN]
	ora $87.b,S		; 03 87 ; OR accumulator with stack relative $87.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $41231F.l,X		; 1F 1F 23 41 ; Logical OR long $41231F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $0008.w		; 4D 08 00 ; Exclusive OR $0008.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0F00.w		; 0E 00 0F ; Arithmetic shift left $0F00.w [Flags: ZNC]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0B0F.w		; 0E 0F 0B ; Arithmetic shift left $0B0F.w [Flags: ZNC]
	ora #$3A.b		; 09 3A ; Logical OR #$3A.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $1F		; 30 1F ; Branch if minus to $30, $1F [Flow: branch]
	ora $040F.w		; 0D 0F 04 ; Logical OR $040F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $2A.b		; 06 2A ; Arithmetic shift left $2A.b [Reads: Direct Page] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0B.b)		; 12 0B ; OR accumulator with memory (indirect) ($0B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $00, $01		; 82 00 01 ; Branch always long to $82, $00, $01 [Flow: branch]
	bit $0100.w		; 2C 00 01 ; Test bits $0100.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sta $01.b,S		; 83 01 ; Store accumulator (stack relative) $01.b,S [Reads: Accumulator, Stack Pointer]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $D8.b,X		; 74 D8 ; Store zero to $D8.b,X [Reads: X Index]
	jsr $0024.w		; 20 24 00 ; Jump to subroutine at $0024.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $3600.w,Y		; 19 00 36 ; OR accumulator with memory $3600.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	and $040A1D.l		; 2F 1D 0A 04 ; AND accumulator with memory (long) $040A1D.l [Writes: Accumulator] [Flags: ZN]
	jsl $20E000.l		; 22 00 E0 20 ; Jump to subroutine long $20E000.l [Writes: Stack Pointer] [Flow: call]
	sbc $41.b,S		; E3 41 ; Subtract stack-relative $41.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	.db $62, $00, $E6		; 62 00 E6 ; Push effective relative address $62, $00, $E6 [Writes: Stack Pointer]
	brk $E9.b		; 00 E9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $56.b		; 00 56 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A7.b,S		; E3 A7 ; Subtract stack-relative $A7.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	lda $152D5B.l		; AF 5B 2D 15 ; Load long $152D5B.l into accumulator [Writes: Accumulator] [Flags: ZN]
	cop $60.b		; 02 60 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$70.b		; A0 70 ; Load #$70.b into Y register [Writes: Y Index] [Flags: ZN]
	jsr $40E0.w		; 20 E0 40 ; Jump to subroutine at $40E0.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	mvp $E0,$00		; 44 00 E0 ; Move block positive $E0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $0040.w		; 0D 40 00 ; Logical OR $0040.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cpx #$50.b		; E0 50 ; Compare #$50.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $A0		; D0 A0 ; Branch if not equal to $D0, $A0 [Flow: branch]
	cpx #$A0.b		; E0 A0 ; Compare #$A0.b with X register [Reads: X Index] [Flags: ZNC]
	ldy #$40.b		; A0 40 ; Load #$40.b into Y register [Writes: Y Index] [Flags: ZN]
	asl $1901.w,X		; 1E 01 19 ; Arithmetic shift left $1901.w,X [Reads: X Index] [Flags: ZNC]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: ZNC]
	ora $0D4300.l,X		; 1F 00 43 0D ; Logical OR long $0D4300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $1E1711.l		; 5C 11 17 1E ; Jump long to $1E1711.l [Flow: jump]
	ora ($0F.b)		; 12 0F ; OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $B8.b		; 46 B8 ; Logical shift right $B8.b [Reads: Direct Page] [Flags: ZNC]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $7C.b,S		; 83 7C ; Store accumulator (stack relative) $7C.b,S [Reads: Accumulator, Stack Pointer]
	adc ($8C.b,S),Y		; 73 8C ; Add with carry (stack relative indirect indexed) ($8C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	mvp $88,$76		; 44 76 88 ; Move block positive $88,$76 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $EF7F.w		; 8D 7F EF ; Store accumulator to $EF7F.w [Reads: Accumulator]
	dec $9CCE.w		; CE CE 9C ; Decrement $9CCE.w [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $3A7F2C.l		; 6F 2C 7F 3A ; Add with carry (long) $3A7F2C.l [Writes: Accumulator] [Flags: ZVNC]
	adc $3914.w,X		; 7D 14 39 ; Add $3914.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	trb $0F0C.w		; 1C 0C 0F ; Test and reset bits $0F0C.w [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $53.b		; 00 53 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $37,$6B		; 44 6B 37 ; Move block positive $37,$6B [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and $030C13.l		; 2F 13 0C 03 ; AND accumulator with memory (long) $030C13.l [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsl $FE26F7.l		; 22 F7 26 FE ; Jump to subroutine long $FE26F7.l [Writes: Stack Pointer] [Flow: call]
	jmp $1C70FC.l		; 5C FC 70 1C ; Jump long to $1C70FC.l [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0C22.w,Y		; 59 22 0C ; Exclusive OR accumulator with memory $0C22.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx $C8.b		; E4 C8 ; Compare $C8.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	eor ($2D.b)		; 52 2D ; Exclusive OR accumulator with memory (indirect) ($2D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $6712.w		; 6D 12 67 ; Add $6712.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	adc $9F.b		; 65 9F ; Add $9F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $223D19.l,X		; FF 19 3D 22 ; Subtract with carry (long,X) $223D19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $7973.w,X		; 5E 73 79 ; Logical shift right $7973.w,X [Reads: X Index] [Flags: ZNC]
	stz $E6E7.w,X		; 9E E7 E6 ; Store zero to $E6E7.w,X [Reads: X Index]
	and $1E00.w,X		; 3D 00 1E ; AND accumulator with memory $1E00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx $1AF5.w		; EC F5 1A ; Compare $1AF5.w with X register [Reads: X Index] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	pea $08F4.w		; F4 F4 08 ; Push absolute address $08F4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tsb $FCF0.w		; 0C F0 FC ; Test and set bits $FCF0.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $34.b,S		; 83 34 ; Store accumulator (stack relative) $34.b,S [Reads: Accumulator, Stack Pointer]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FAFD.w,X		; 1E FD FA ; Arithmetic shift left $FAFD.w,X [Reads: X Index] [Flags: ZNC]
	pea $F40C.w		; F4 0C F4 ; Push absolute address $F40C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $66		; F0 66 ; Branch if equal to $F0, $66 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	adc $D587.w		; 6D 87 D5 ; Add $D587.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$4E.b]		; 47 4E ; Exclusive OR accumulator with memory (long) [$4E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $E3.b		; 84 E3 ; Store Y register to $E3.b [Reads: Y Index]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($3E.b)		; 72 3E ; Add with carry (indirect) ($3E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	bit $DE.b,X		; 34 DE ; Test bits $DE.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	trb $08DC.w		; 1C DC 08 ; Test and reset bits $08DC.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $C8		; 10 C8 ; Branch if plus to $10, $C8 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FF1A00.l		; 22 00 1A FF ; Jump to subroutine long $FF1A00.l [Writes: Stack Pointer] [Flow: call]
	inc $3C3E.w,X		; FE 3E 3C ; Increment memory $3C3E.w,X [Reads: X Index] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	jsr $307C.w		; 20 7C 30 ; Jump to subroutine at $307C.w [Writes: Stack Pointer] [Flow: call]
	adc $387C3C.l,X		; 7F 3C 7C 38 ; Add long $387C3C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($7F18.w,X)		; 7C 18 7F ; Jump indirect indexed to ($7F18.w,X) [Reads: X Index] [Flow: jump]
	and $37.b,S		; 23 37 ; AND accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $7C		; 70 7C ; Branch if overflow set to $70, $7C [Flow: branch]
	jsl $5C017F.l		; 22 7F 01 5C ; Jump to subroutine long $5C017F.l [Writes: Stack Pointer] [Flow: call]
	and [$83.b],Y		; 37 83 ; AND accumulator with memory (long indexed) [$83.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $05		; 70 05 ; Branch if overflow set to $70, $05 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0D7210.l		; 2F 10 72 0D ; AND accumulator with memory (long) $0D7210.l [Writes: Accumulator] [Flags: ZN]
	sbc $199F70.l,X		; FF 70 9F 19 ; Subtract with carry (long,X) $199F70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0022.w,X		; FD 22 00 ; Subtract with carry $0022.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$5E.b]		; 07 5E ; OR accumulator with memory (long) [$5E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc ($31.b,S),Y		; 73 31 ; Add with carry (stack relative indirect indexed) ($31.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $E68F.w,X		; 7E 8F E6 ; Rotate right $E68F.w,X [Reads: X Index] [Flags: ZNC]
	sbc $FF00.w,X		; FD 00 FF ; Subtract with carry $FF00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$5A.b		; E0 5A ; Compare #$5A.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F00.w		; 0E 00 1F ; Arithmetic shift left $1F00.w [Flags: ZNC]
	asl $1F3B.w		; 0E 3B 1F ; Arithmetic shift left $1F3B.w [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $7B3F7C.l,X		; 1F 7C 3F 7B ; Logical OR long $7B3F7C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $001FB7.l,X		; 3F B7 1F 00 ; AND accumulator with memory (long,X) $001FB7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $3F1F.w		; 0E 1F 3F ; Arithmetic shift left $3F1F.w [Flags: ZNC]
	and $FF7F7F.l,X		; 3F 7F 7F FF ; AND accumulator with memory (long,X) $FF7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $8C		; 70 8C ; Branch if overflow set to $70, $8C [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp $EEF8.w		; 4C F8 EE ; Jump to $EEF8.w [Flow: jump]
	ldy $9CFE.w,X		; BC FE 9C ; Load Y register $9CFE.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sbc $0058.w,X		; FD 58 00 ; Subtract with carry $0058.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	jsr ($FEFC.w,X)		; FC FC FE ; Jump to subroutine indirect indexed ($FEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $00BF.w,X		; FE BF 00 ; Increment memory $00BF.w,X [Reads: X Index] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$1D.b]		; 07 1D ; OR accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3E0F1C.l		; 0F 1C 0F 3E ; OR accumulator with memory (long) $3E0F1C.l [Writes: Accumulator] [Flags: ZN]
	ora $001B3F.l,X		; 1F 3F 1B 00 ; Logical OR long $001B3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F1F1F.l		; 0F 1F 1F 3F ; OR accumulator with memory (long) $3F1F1F.l [Writes: Accumulator] [Flags: ZN]
	and $800000.l,X		; 3F 00 00 80 ; AND accumulator with memory (long,X) $800000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	.db $30, $DC		; 30 DC ; Branch if minus to $30, $DC [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $1EF8.w		; 0C F8 1E ; Test and set bits $1EF8.w [Reads: Accumulator] [Flags: Z]
	jsr ($FC6E.w,X)		; FC 6E FC ; Jump to subroutine indirect indexed ($FC6E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $84		; F0 84 ; Branch if equal to $F0, $84 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1F0044.l		; 0F 44 00 1F ; OR accumulator with memory (long) $1F0044.l [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $5F,$00		; 44 00 5F ; Move block positive $5F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $206F.w		; 0C 6F 20 ; Test and set bits $206F.w [Reads: Accumulator] [Flags: Z]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $7F3F.w,X		; 1D 3F 7F ; OR accumulator with memory $7F3F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $00405F.l,X		; 7F 5F 40 00 ; Add long $00405F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $44		; F0 44 ; Branch if equal to $F0, $44 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsr $24F6.w		; 20 F6 24 ; Jump to subroutine at $24F6.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $D8		; F0 D8 ; Branch if equal to $F0, $D8 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jsr ($DEFE.w,X)		; FC FE DE ; Jump to subroutine indirect indexed ($DEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($20.b,S),Y		; 13 20 ; OR accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	.db $10, $9F		; 10 9F ; Branch if plus to $10, $9F [Flow: branch]
	asl $B9.b		; 06 B9 ; Arithmetic shift left $B9.b [Reads: Direct Page] [Flags: ZNC]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $88		; 50 88 ; Branch if overflow clear to $50, $88 [Flow: branch]
	inc $CFFF.w		; EE FF CF ; Increment $CFFF.w [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $EC		; 10 EC ; Branch if plus to $10, $EC [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sty $2278.w		; 8C 78 22 ; Store Y register to $2278.w [Reads: Y Index]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($03FC.w,X)		; FC FC 03 ; Jump to subroutine indirect indexed ($03FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $61.b,S		; 83 61 ; Store accumulator (stack relative) $61.b,S [Reads: Accumulator, Stack Pointer]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $03080B.l,X		; 3F 0B 08 03 ; AND accumulator with memory (long,X) $03080B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3F3C1B.l		; 0F 1B 3C 3F ; OR accumulator with memory (long) $3F3C1B.l [Writes: Accumulator] [Flags: ZN]
	eor $40373F.l,X		; 5F 3F 37 40 ; Exclusive OR accumulator with memory (long,X) $40373F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $FC.b		; 45 FC ; Exclusive OR $FC.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $BFE0FC.l		; 22 FC E0 BF ; Jump to subroutine long $BFE0FC.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $30, $EC		; 30 EC ; Branch if minus to $30, $EC [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	lda $29B72C.l,X		; BF 2C B7 29 ; Load long $29B72C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda [$08.b],Y		; B7 08 ; Load accumulator (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	stz $CB.b		; 64 CB ; Store zero to $CB.b
	mvp $78,$30		; 44 30 78 ; Move block positive $78,$30 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ldy $DADF.w,X		; BC DF DA ; Load Y register $DADF.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sbc $BD9E.w,X		; FD 9E BD ; Subtract with carry $BD9E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $1A00.w		; 0C 00 1A ; Test and set bits $1A00.w [Reads: Accumulator] [Flags: Z]
	tsb $1A37.w		; 0C 37 1A ; Test and set bits $1A37.w [Reads: Accumulator] [Flags: Z]
	sbc $ED34.w,X		; FD 34 ED ; Subtract with carry $ED34.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $ED.b,X		; 94 ED ; Store Y register $ED.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	.db $10, $DF		; 10 DF ; Branch if plus to $10, $DF [Flow: branch]
	rol $D3.b		; 26 D3 ; Rotate left $D3.b [Reads: Direct Page] [Flags: ZNC]
	jsl $3D1E0C.l		; 22 0C 1E 3D ; Jump to subroutine long $3D1E0C.l [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	lda $06BD79.l,X		; BF 79 BD 06 ; Load long $06BD79.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $17.b		; 06 17 ; Arithmetic shift left $17.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $1B.b		; 24 1B ; Test bits $1B.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and #$16.b		; 29 16 ; Logical AND #$16.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor [$3B.b]		; 47 3B ; Exclusive OR accumulator with memory (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp $0634.w		; 4C 34 06 ; Jump to $0634.w [Flow: jump]
	ora #$11.b		; 09 11 ; Logical OR #$11.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jsr $2321.w		; 20 21 23 ; Jump to subroutine at $2321.w [Writes: Stack Pointer] [Flow: call]
	mvp $60,$4B		; 44 4B 60 ; Move block positive $60,$4B [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sty $68.b,X		; 94 68 ; Store Y register $68.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
.INDEX 8
	sep #$DC		; E2 DC
	lda ($2C.b)		; B2 2C ; Load accumulator (indirect) ($2C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $88		; 90 88 ; Branch if carry clear to $90, $88 [Flow: branch]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	cpy $22.b		; C4 22 ; Compare $22.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	eor ($03.b)		; 52 03 ; Exclusive OR accumulator with memory (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: ZNC]
	ora $1D.b		; 05 1D ; Logical OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	rol $15.b,X		; 36 15 ; Rotate left $15.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora ($37.b,X)		; 01 37 ; Logical OR ($37.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $2A.b		; 14 2A ; Test and reset bits $2A.b [Reads: Accumulator] [Flags: Z]
	rol $29.b,X		; 36 29 ; Rotate left $29.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	cpx #$EC.b		; E0 EC ; Compare #$EC.b with X register [Reads: X Index] [Flags: ZNC]
	.db $10, $C4		; 10 C4 ; Branch if plus to $10, $C4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	ora ($EC.b)		; 12 EC ; OR accumulator with memory (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $0404.w		; 0C 04 04 ; Test and set bits $0404.w [Reads: Accumulator] [Flags: Z]
	cop $BF.b		; 02 BF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $51FF.w		; 1C FF 51 ; Test and reset bits $51FF.w [Reads: Accumulator] [Flags: Z]
	sbc $397F69.l,X		; FF 69 7F 39 ; Subtract with carry (long,X) $397F69.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $1C08.w,X		; 3E 08 1C ; Rotate left $1C08.w,X [Reads: X Index] [Flags: ZNC]
	tsb $030F.w		; 0C 0F 03 ; Test and set bits $030F.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $4290BE.l,X		; FF BE 90 42 ; Subtract with carry (long,X) $4290BE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($13.b,S),Y		; 33 13 ; AND accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $FD03.w		; 0C 03 FD ; Test and set bits $FD03.w [Reads: Accumulator] [Flags: Z]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sbc $96FF8A.l,X		; FF 8A FF 96 ; Subtract with carry (long,X) $96FF8A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $7C8C.w		; EE 8C 7C ; Increment $7C8C.w [Flags: ZN]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $5209.w,X		; 7D 09 52 ; Add $5209.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy $30C8.w		; CC C8 30 ; Compare $30C8.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$43.b		; C0 43 ; Compare #$43.b with Y register [Reads: Y Index] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($E0.b),Y		; 11 E0 ; OR accumulator with memory ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ldy $3D.b		; A4 3D ; Load $3D.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	trb $3F.b		; 14 3F ; Test and reset bits $3F.b [Reads: Accumulator] [Flags: Z]
	ora [$1E.b],Y		; 17 1E ; OR accumulator with memory (long indexed) [$1E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl $0706.w		; 0E 06 07 ; Arithmetic shift left $0706.w [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1D383B.l,X		; 3F 3B 38 1D ; AND accumulator with memory (long,X) $1D383B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FCC0.w,X)		; FC C0 FC ; Jump to subroutine indirect indexed ($FCC0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($FC48.w,X)		; FC 48 FC ; Jump to subroutine indirect indexed ($FC48.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($94C4.w,X)		; FC C4 94 ; Jump to subroutine indirect indexed ($94C4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	trb $C8.b		; 14 C8 ; Test and reset bits $C8.b [Reads: Accumulator] [Flags: Z]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	adc $287A3B.l,X		; 7F 3B 7A 28 ; Add long $287A3B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $3F.b,X		; 55 3F ; Exclusive OR accumulator with memory $3F.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	inc $7E3C.w,X		; FE 3C 7E ; Increment memory $7E3C.w,X [Reads: X Index] [Flags: ZN]
	bit $7C.b,X		; 34 7C ; Test bits $7C.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	.db $30, $58		; 30 58 ; Branch if minus to $30, $58 [Flow: branch]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	jsr $E0F0.w		; 20 F0 E0 ; Jump to subroutine at $E0F0.w [Writes: Stack Pointer] [Flow: call]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	rep #$8A		; C2 8A ; Reset processor status bits #$8A [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cpy $D0E8.w		; CC E8 D0 ; Compare $D0E8.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	cpy #$FA.b		; C0 FA ; Compare #$FA.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora $3A7D.w		; 0D 7D 3A ; Logical OR $3A7D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc $206F04.l,X		; 7F 04 6F 20 ; Add long $206F04.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $007F38.l,X		; 7F 38 7F 00 ; Add long $007F38.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($3800.w,X)		; 7C 00 38 ; Jump indirect indexed to ($3800.w,X) [Reads: X Index] [Flow: jump]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($577E.w,X)		; 7C 7E 57 ; Jump indirect indexed to ($577E.w,X) [Reads: X Index] [Flow: jump]
	eor [$7F.b]		; 47 7F ; Exclusive OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp ($4E38.w,X)		; 7C 38 4E ; Jump indirect indexed to ($4E38.w,X) [Reads: X Index] [Flow: jump]
	ldy $5CBE.w,X		; BC BE 5C ; Load Y register $5CBE.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	inc $F600.w,X		; FE 00 F6 ; Increment memory $F600.w,X [Reads: X Index] [Flags: ZN]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	trb $00FE.w		; 1C FE 00 ; Test and reset bits $00FE.w [Reads: Accumulator] [Flags: Z]
	rol $1C00.w,X		; 3E 00 1C ; Rotate left $1C00.w,X [Reads: X Index] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $EA7E.w,X		; 3E 7E EA ; Rotate left $EA7E.w,X [Reads: X Index] [Flags: ZNC]
.ACCU 8
.INDEX 8
	sep #$FE		; E2 FE
	rol $1F1C.w,X		; 3E 1C 1F ; Rotate left $1F1C.w,X [Reads: X Index] [Flags: ZNC]
	tsb $0317.w		; 0C 17 03 ; Test and set bits $0317.w [Reads: Accumulator] [Flags: Z]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0F05.w		; 0D 05 0F ; Logical OR $0F05.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $171F.w,X		; 1E 1F 17 ; Arithmetic shift left $171F.w,X [Reads: X Index] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$FC.b]		; 07 FC ; OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp.w [$1007]		; DC 07 10 ; Jump long indirect [$1007] [Flow: jump]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $44E000.l		; 22 00 E0 44 ; Jump to subroutine long $44E000.l [Writes: Stack Pointer] [Flow: call]
	jsr ($ECFC.w,X)		; FC FC EC ; Jump to subroutine indirect indexed ($ECFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F.b,X		; 16 3F ; Arithmetic shift left $3F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora #$3F.b		; 09 3F ; Logical OR #$3F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $062F.w		; 0E 2F 06 ; Arithmetic shift left $062F.w [Flags: ZNC]
	rol $00.b,X		; 36 00 ; Rotate left $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $2210.w		; 2E 10 22 ; Rotate left $2210.w [Flags: ZNC]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	adc $393136.l		; 6F 36 31 39 ; Add with carry (long) $393136.l [Writes: Accumulator] [Flags: ZVNC]
	rol $222E.w,X		; 3E 2E 22 ; Rotate left $222E.w,X [Reads: X Index] [Flags: ZNC]
	trb $68FA.w		; 1C FA 68 ; Test and reset bits $68FA.w [Reads: Accumulator] [Flags: Z]
	jsr ($FC90.w,X)		; FC 90 FC ; Jump to subroutine indirect indexed ($FC90.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $F4		; 70 F4 ; Branch if overflow set to $70, $F4 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($7400.w)		; 6C 00 74 ; Jump indirect to ($7400.w) [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	mvp $38,$38		; 44 38 38 ; Move block positive $38,$38 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($9C8C.w)		; 6C 8C 9C ; Jump indirect to ($9C8C.w) [Flow: jump]
	jmp ($4474.w,X)		; 7C 74 44 ; Jump indirect indexed to ($4474.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	lsr $5F2E.w,X		; 5E 2E 5F ; Logical shift right $5F2E.w,X [Reads: X Index] [Flags: ZNC]
	and ($3F.b,X)		; 21 3F ; Logical AND ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E1E.w,Y		; 19 1E 0E ; OR accumulator with memory $0E1E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $220303.l		; 0F 03 03 22 ; OR accumulator with memory (long) $220303.l [Writes: Accumulator] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($5E.b),Y		; 51 5E ; Exclusive OR accumulator with memory ($5E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($22.b),Y		; 31 22 ; AND accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	bit $FA.b,X		; 34 FA ; Test bits $FA.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sty $FC.b		; 84 FC ; Store Y register to $FC.b [Reads: Y Index]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $CA0F00.l		; 22 00 0F CA ; Jump to subroutine long $CA0F00.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sty $8844.w		; 8C 44 88 ; Store Y register to $8844.w [Reads: Y Index]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: ZNC]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sty $8A.b		; 84 8A ; Store Y register to $8A.b [Reads: Y Index]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $2427.w,Y		; 39 27 24 ; AND accumulator with memory $2427.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$13.b]		; 27 13 ; AND accumulator with memory (long) [$13.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	ora ($EC.b)		; 12 EC ; OR accumulator with memory (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$F6.b		; 09 F6 ; Logical OR #$F6.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $82, $7C, $C4		; 82 7C C4 ; Branch always long to $82, $7C, $C4 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $37E000.l		; 22 00 E0 37 ; Jump to subroutine long $37E000.l [Writes: Stack Pointer] [Flow: call]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $44, $38		; 82 44 38 ; Branch always long to $82, $44, $38 [Flow: branch]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $37.b,S		; 03 37 ; OR accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	adc [$28.b],Y		; 77 28 ; Add with carry (long indexed) [$28.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($7120.w)		; 6C 20 71 ; Jump indirect to ($7120.w) [Flow: jump]
	and ($77.b,X)		; 21 77 ; Logical AND ($77.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and [$3F.b],Y		; 37 3F ; AND accumulator with memory (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	trb $0C03.w		; 1C 03 0C ; Test and reset bits $0C03.w [Reads: Accumulator] [Flags: Z]
	bit $5F5F.w,X		; 3C 5F 5F ; Test bits $5F5F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lsr $2348.w,X		; 5E 48 23 ; Logical shift right $2348.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $80, $B4		; 80 B4 ; Branch always to $80, $B4 [Flow: branch]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $EE		; 80 EE ; Branch always to $80, $EE [Flow: branch]
	sty $44C6.w		; 8C C6 44 ; Store Y register to $44C6.w [Reads: Y Index]
	jsr ($C0F8.w,X)		; FC F8 C0 ; Jump to subroutine indirect indexed ($C0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $68		; 30 68 ; Branch if minus to $30, $68 [Flow: branch]
	jsr ($727E.w,X)		; FC 7E 72 ; Jump to subroutine indirect indexed ($727E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	ora $030C.w		; 0D 0C 03 ; Logical OR $030C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $1F0F.w,X		; 1E 0F 1F ; Arithmetic shift left $1F0F.w,X [Reads: X Index] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $2F5C.w		; 0C 5C 2F ; Test and set bits $2F5C.w [Reads: Accumulator] [Flags: Z]
	adc $030013.l		; 6F 13 00 03 ; Add with carry (long) $030013.l [Writes: Accumulator] [Flags: ZVNC]
	sta $43.b,S		; 83 43 ; Store accumulator (stack relative) $43.b,S [Reads: Accumulator, Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7F.b,S		; 23 7F ; AND accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $C00000.l,X		; 5F 00 00 C0 ; Exclusive OR accumulator with memory (long,X) $C00000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$78.b		; C0 78 ; Compare #$78.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	.db $D0, $DC		; D0 DC ; Branch if not equal to $D0, $DC [Flow: branch]
	.db $30, $3A		; 30 3A ; Branch if minus to $30, $3A [Flow: branch]
	pea $C8F6.w		; F4 F6 C8 ; Push absolute address $C8F6.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FAFE.w,X)		; FC FE FA ; Jump to subroutine indirect indexed ($FAFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0B1F07.l		; 0F 07 1F 0B ; OR accumulator with memory (long) $0B1F07.l [Writes: Accumulator] [Flags: ZN]
	and $3F431C.l,X		; 3F 1C 43 3F ; AND accumulator with memory (long,X) $3F431C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3B7F05.l,X		; 1F 05 7F 3B ; Logical OR long $3B7F05.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	jsr $4400.w		; 20 00 44 ; Jump to subroutine at $4400.w [Writes: Stack Pointer] [Flow: call]
	sta $18.b		; 85 18 ; Store accumulator to $18.b [Reads: Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($43E8.w,X)		; FC E8 43 ; Jump to subroutine indirect indexed ($43E8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($43D8.w,X)		; FC D8 43 ; Jump to subroutine indirect indexed ($43D8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0EAC.w,X		; FE AC 0E ; Increment memory $0EAC.w,X [Reads: X Index] [Flags: ZN]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	bit $52.b		; 24 52 ; Test bits $52.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	eor ($00.b)		; 52 00 ; Exclusive OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	sta $37.b,S		; 83 37 ; Store accumulator (stack relative) $37.b,S [Reads: Accumulator, Stack Pointer]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $3C		; 10 3C ; Branch if plus to $10, $3C [Flow: branch]
	trb $3F7F.w		; 1C 7F 3F ; Test and reset bits $3F7F.w [Reads: Accumulator] [Flags: Z]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $10, $2C		; 10 2C ; Branch if plus to $10, $2C [Flow: branch]
	and $40.b,S		; 23 40 ; AND accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $D0, $D8		; D0 D8 ; Branch if not equal to $D0, $D8 [Flow: branch]
	.db $90, $BC		; 90 BC ; Branch if carry clear to $90, $BC [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $10E000.l,X		; 1F 00 E0 10 ; Logical OR long $10E000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	mvp $04,$04		; 44 04 04 ; Move block positive $04,$04 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F00.w		; 0D 00 1F ; Logical OR $1F00.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $1B3F.w		; 0D 3F 1B ; Logical OR $1B3F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $7F1E.w,X		; 3E 1E 7F ; Rotate left $7F1E.w,X [Reads: X Index] [Flags: ZNC]
	rol $7F.b,X		; 36 7F ; Rotate left $7F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and [$7F.b]		; 27 7F ; AND accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $2412.w		; 0D 12 24 ; Logical OR $2412.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and ($48.b,X)		; 21 48 ; Logical AND ($48.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	sta $48.b,S		; 83 48 ; Store accumulator (stack relative) $48.b,S [Reads: Accumulator, Stack Pointer]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $7C		; F0 7C ; Branch if equal to $F0, $7C [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsr ($FE78.w,X)		; FC 78 FE ; Jump to subroutine indirect indexed ($FE78.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($7CFE.w,X)		; FC FE 7C ; Jump to subroutine indirect indexed ($7CFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $08		; 30 08 ; Branch if minus to $30, $08 [Flow: branch]
	sty $04.b		; 84 04 ; Store Y register to $04.b [Reads: Y Index]
	cop $82.b		; 02 82 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $7E03.w,X		; 1E 03 7E ; Arithmetic shift left $7E03.w,X [Reads: X Index] [Flags: ZNC]
	ora [$DF.b],Y		; 17 DF ; OR accumulator with memory (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$EF.b],Y		; 77 EF ; Add with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $03017C.l,X		; FF 7C 01 03 ; Subtract with carry (long,X) $03017C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $14FF22.l,X		; 7F 22 FF 14 ; Add long $14FF22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	cpy #$38.b		; C0 38 ; Compare #$38.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$16.b		; C0 16 ; Compare #$16.b with Y register [Reads: Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	and ($EE.b),Y		; 31 EE ; AND accumulator with memory ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc ($DE.b),Y		; F1 DE ; Subtract with carry ($DE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($1E.b,X)		; E1 1E ; Subtract with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	inc $FF22.w,X		; FE 22 FF ; Increment memory $FF22.w,X [Reads: X Index] [Flags: ZN]
	sty $F0.b,X		; 94 F0 ; Store Y register $F0.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $040889.l,X		; FF 89 08 04 ; Subtract with carry (long,X) $040889.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $13.b,S		; 83 13 ; Store accumulator (stack relative) $13.b,S [Reads: Accumulator, Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	rol $1884.w,X		; 3E 84 18 ; Rotate left $1884.w,X [Reads: X Index] [Flags: ZNC]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	sbc $00010F.l,X		; FF 0F 01 00 ; Subtract with carry (long,X) $00010F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	trb $7803.w		; 1C 03 78 ; Test and reset bits $7803.w [Reads: Accumulator] [Flags: Z]
	ora [$98.b],Y		; 17 98 ; OR accumulator with memory (long indexed) [$98.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$8F.b],Y		; 77 8F ; Add with carry (long indexed) [$8F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $008630.l		; 4F 30 86 00 ; Exclusive OR accumulator with memory (long) $008630.l [Writes: Accumulator] [Flags: ZN]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	adc $C00080.l,X		; 7F 80 00 C0 ; Add long $C00080.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	cpy #$78.b		; C0 78 ; Compare #$78.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$7E.b		; C0 7E ; Compare #$7E.b with Y register [Reads: Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sbc $DEF7EE.l,X		; FF EE F7 DE ; Subtract with carry (long,X) $DEF7EE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $044785.l		; EF 85 47 04 ; Subtract with carry (long) $044785.l [Writes: Accumulator] [Flags: ZVNC]
	jsl $1D07FF.l		; 22 FF 07 1D ; Jump to subroutine long $1D07FF.l [Writes: Stack Pointer] [Flow: call]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1E37.w		; 0D 37 1E ; Logical OR $1E37.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $7A840C.l,X		; 3F 0C 84 7A ; AND accumulator with memory (long,X) $7A840C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F1F.w,X		; 1E 1F 3F ; Arithmetic shift left $3F1F.w,X [Reads: X Index] [Flags: ZNC]
	and $1C222E.l,X		; 3F 2E 22 1C ; AND accumulator with memory (long,X) $1C222E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $C4		; B0 C4 ; Branch if carry set to $B0, $C4 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx $8430.w		; EC 30 84 ; Compare $8430.w with X register [Reads: X Index] [Flags: ZNC]
	sta ($02.b)		; 92 02 ; Store accumulator (indirect) ($02.b) [Reads: Accumulator, Direct Page]
	jsl $EB8300.l		; 22 00 83 EB ; Jump to subroutine long $EB8300.l [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $44.b,X		; 74 44 ; Store zero to $44.b,X [Reads: X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $052EE0.l,X		; 3F E0 2E 05 ; AND accumulator with memory (long,X) $052EE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $2C.b		; 05 2C ; Logical OR $2C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($2B.b,X)		; 01 2B ; Logical OR ($2B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($2A.b)		; 32 2A ; AND accumulator with memory (indirect) ($2A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	asl $070F.w,X		; 1E 0F 07 ; Arithmetic shift left $070F.w,X [Reads: X Index] [Flags: ZNC]
	jsr ($FC00.w,X)		; FC 00 FC ; Jump to subroutine indirect indexed ($FC00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldy #$5C.b		; A0 5C ; Load #$5C.b into Y register [Writes: Y Index] [Flags: ZN]
	ldy #$3C.b		; A0 3C ; Load #$3C.b into Y register [Writes: Y Index] [Flags: ZN]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: ZNC]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $90		; 10 90 ; Branch if plus to $10, $90 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $D4		; 80 D4 ; Branch always to $80, $D4 [Flow: branch]
	jmp $0454.w		; 4C 54 04 ; Jump to $0454.w [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	adc $7F4338.l,X		; 7F 38 43 7F ; Add long $7F4338.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($02.b),Y		; 31 02 ; AND accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $1C08.w,X		; 3E 08 1C ; Rotate left $1C08.w,X [Reads: X Index] [Flags: ZNC]
	sta $EB.b,S		; 83 EB ; Store accumulator (stack relative) $EB.b,S [Reads: Accumulator, Stack Pointer]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$48.b]		; 47 48 ; Exclusive OR accumulator with memory (long) [$48.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and ($1B.b,S),Y		; 33 1B ; AND accumulator (stack relative indirect indexed) ($1B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($94FE.w)		; 6C FE 94 ; Jump indirect to ($94FE.w) [Flow: jump]
	ror $7C14.w,X		; 7E 14 7C ; Rotate right $7C14.w,X [Reads: X Index] [Flags: ZNC]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	jsr $C0E0.w		; 20 E0 C0 ; Jump to subroutine at $C0E0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($0A.b)		; 92 0A ; Store accumulator (indirect) ($0A.b) [Reads: Accumulator, Direct Page]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpy $20D0.w		; CC D0 20 ; Compare $20D0.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	mvp $3F,$7F		; 44 7F 3F ; Move block positive $3F,$7F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora [$2F.b]		; 07 2F ; OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $0B1F1F.l,X		; 3F 1F 1F 0B ; AND accumulator with memory (long,X) $0B1F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $220303.l		; 0F 03 03 22 ; OR accumulator with memory (long) $220303.l [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	trb $0C.b		; 14 0C ; Test and reset bits $0C.b [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $43F4.w,X		; FE F4 43 ; Increment memory $43F4.w,X [Reads: X Index] [Flags: ZN]
	inc $01FC.w,X		; FE FC 01 ; Increment memory $01FC.w,X [Reads: X Index] [Flags: ZN]
	jsr ($84E8.w,X)		; FC E8 84 ; Jump to subroutine indirect indexed ($84E8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $83.b		; 14 83 ; Test and reset bits $83.b [Reads: Accumulator] [Flags: Z]
	jmp ($0C02.w)		; 6C 02 0C ; Jump indirect to ($0C02.w) [Flow: jump]
	and $052F18.l,X		; 3F 18 2F 05 ; AND accumulator with memory (long,X) $052F18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $002922.l		; 6F 22 29 00 ; Add with carry (long) $002922.l [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $220707.l,X		; 1F 07 07 22 ; Logical OR long $220707.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$32.b]		; 27 32 ; AND accumulator with memory (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $273F.w,Y		; 59 3F 27 ; Exclusive OR accumulator with memory $273F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $F4.b,X		; F6 F4 ; Increment memory $F4.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $D0, $F0		; D0 F0 ; Branch if not equal to $D0, $F0 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $0A1300.l		; 22 00 13 0A ; Jump to subroutine long $0A1300.l [Writes: Stack Pointer] [Flow: call]
	asl $2804.w		; 0E 04 28 ; Arithmetic shift left $2804.w [Flags: ZNC]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	adc $033F1F.l,X		; 7F 1F 3F 03 ; Add long $033F1F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1F06.w,Y		; 19 06 1F ; OR accumulator with memory $1F06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$0E.b		; 09 0E ; Logical OR #$0E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: ZNC]
	cpx $1301.w		; EC 01 13 ; Compare $1301.w with X register [Reads: X Index] [Flags: ZNC]
	adc $19233F.l,X		; 7F 3F 23 19 ; Add long $19233F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $09.b,X		; 16 09 ; Arithmetic shift left $09.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	inc $88.b,X		; F6 88 ; Increment memory $88.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	inc $FC04.w,X		; FE 04 FC ; Increment memory $FC04.w,X [Reads: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $4888.w		; EC 88 48 ; Compare $4888.w with X register [Reads: X Index] [Flags: ZNC]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	.db $10, $FE		; 10 FE ; Branch if plus to $10, $FE [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sty $54.b		; 84 54 ; Store Y register to $54.b [Reads: Y Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: ZNC]
	ora $3B237F.l,X		; 1F 7F 23 3B ; Logical OR long $3B237F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $3C.b		; 14 3C ; Test and reset bits $3C.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $018B83.l,X		; 1F 83 8B 01 ; Logical OR long $018B83.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $7F0300.l		; 22 00 03 7F ; Jump to subroutine long $7F0300.l [Writes: Stack Pointer] [Flow: call]
	eor $83242B.l,X		; 5F 2B 24 83 ; Exclusive OR accumulator with memory (long,X) $83242B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpx $02.b		; E4 02 ; Compare $02.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $F8C6.w		; 0C C6 F8 ; Test and set bits $F8C6.w [Reads: Accumulator] [Flags: Z]
	inc $DCC4.w,X		; FE C4 DC ; Increment memory $DCC4.w,X [Reads: X Index] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $D0.b,X		; 34 D0 ; Test bits $D0.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jsr $C0F0.w		; 20 F0 C0 ; Jump to subroutine at $C0F0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $D4FA.w,X		; FE FA D4 ; Increment memory $D4FA.w,X [Reads: X Index] [Flags: ZN]
	bit $30D8.w		; 2C D8 30 ; Test bits $30D8.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	rol $3F03.w,X		; 3E 03 3F ; Rotate left $3F03.w,X [Reads: X Index] [Flags: ZNC]
	ora ($2F.b),Y		; 11 2F ; OR accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0705.w,X		; 1D 05 07 ; OR accumulator with memory $0705.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $3F1000.l		; 22 00 10 3F ; Jump to subroutine long $3F1000.l [Writes: Stack Pointer] [Flow: call]
	and $3B.b,S		; 23 3B ; AND accumulator with stack relative $3B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	and [$1A.b]		; 27 1A ; AND accumulator with memory (long) [$1A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $FAF8.w,X		; 7E F8 FA ; Rotate right $FAF8.w,X [Reads: X Index] [Flags: ZNC]
	cpx $E2.b		; E4 E2 ; Compare $E2.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	trb $98E4.w		; 1C E4 98 ; Test and reset bits $98E4.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $C1.b,S		; 83 C1 ; Store accumulator (stack relative) $C1.b,S [Reads: Accumulator, Stack Pointer]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $E2FA.w,X		; FE FA E2 ; Increment memory $E2FA.w,X [Reads: X Index] [Flags: ZN]
	stz $D8.b		; 64 D8 ; Store zero to $D8.b
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: ZNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0C1300.l		; 0F 00 13 0C ; OR accumulator with memory (long) $0C1300.l [Writes: Accumulator] [Flags: ZN]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr $241F.w		; 20 1F 24 ; Jump to subroutine at $241F.w [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	eor $0C0334.l		; 4F 34 03 0C ; Exclusive OR accumulator with memory (long) $0C0334.l [Writes: Accumulator] [Flags: ZN]
	trb $3C18.w		; 1C 18 3C ; Test and reset bits $3C18.w [Reads: Accumulator] [Flags: Z]
	and $C07B3F.l,X		; 3F 3F 7B C0 ; AND accumulator with memory (long,X) $C07B3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp ($DC80.w,X)		; 7C 80 DC ; Jump indirect indexed to ($DC80.w,X) [Reads: X Index] [Flow: jump]
	jsr $906C.w		; 20 6C 90 ; Jump to subroutine at $906C.w [Writes: Stack Pointer] [Flow: call]
	inc $28.b,X		; F6 28 ; Increment memory $28.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cpy #$30.b		; C0 30 ; Compare #$30.b with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cpy $24.b		; C4 24 ; Compare $24.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	ldy $DA.b,X		; B4 DA ; Load Y register $DA.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$60.b]		; 07 60 ; OR accumulator with memory (long) [$60.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	jsr ($7740.w,X)		; FC 40 77 ; Jump to subroutine indirect indexed ($7740.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $70.b,S		; 03 70 ; OR accumulator with stack relative $70.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $58		; F0 58 ; Branch if equal to $F0, $58 [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $3D14.w		; 0E 14 3D ; Arithmetic shift left $3D14.w [Flags: ZNC]
	asl $EF.b		; 06 EF ; Arithmetic shift left $EF.b [Reads: Direct Page] [Flags: ZNC]
	ora ($23.b)		; 12 23 ; OR accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F1E.w		; 0C 1E 0F ; Test and set bits $0F1E.w [Reads: Accumulator] [Flags: Z]
	ora $060000.l,X		; 1F 00 00 06 ; Logical OR long $060000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $3F,$00		; 44 00 3F ; Move block positive $3F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lda $00010D.l,X		; BF 0D 01 00 ; Load long $00010D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $FF7F.w,X		; 3D 7F FF ; AND accumulator with memory $FF7F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: ZN]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	mvp $FC,$00		; 44 00 FC ; Move block positive $FC,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $800D.w,X		; FD 0D 80 ; Subtract with carry $800D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp.w [$FEBC]		; DC BC FE ; Jump long indirect [$FEBC] [Flow: jump]
	sbc $00007F.l,X		; FF 7F 00 00 ; Subtract with carry (long,X) $00007F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3F0044.l,X		; 1F 44 00 3F ; Logical OR long $3F0044.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $BF,$00		; 44 00 BF ; Move block positive $BF,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$84.b]		; 07 84 ; OR accumulator with memory (long) [$84.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc ($00.b)		; 72 00 ; Add with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FC,$00		; 44 00 FC ; Move block positive $FC,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FD,$00		; 44 00 FD ; Move block positive $FD,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sty $8A.b		; 84 8A ; Store Y register to $8A.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $009083.l,X		; FF 83 90 00 ; Subtract with carry (long,X) $009083.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	and $001F09.l,X		; 3F 09 1F 00 ; AND accumulator with memory (long,X) $001F09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F3E19.l		; 0F 19 3E 3F ; OR accumulator with memory (long) $3F3E19.l [Writes: Accumulator] [Flags: ZN]
	and $A8861F.l,X		; 3F 1F 86 A8 ; AND accumulator with memory (long,X) $A8861F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $B8.b,S		; 83 B8 ; Store accumulator (stack relative) $B8.b,S [Reads: Accumulator, Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FE22.w,X		; 7E 22 FE ; Rotate right $FE22.w,X [Reads: X Index] [Flags: ZNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $6F.b		; 04 6F ; Test and set bits $6F.b [Reads: Accumulator] [Flags: Z]
	ora [$DF.b],Y		; 17 DF ; OR accumulator with memory (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $030023.l		; 2F 23 00 03 ; AND accumulator with memory (long) $030023.l [Writes: Accumulator] [Flags: ZN]
	tsb $5F3F.w		; 0C 3F 5F ; Test and set bits $5F3F.w [Reads: Accumulator] [Flags: Z]
	lda $070027.l,X		; BF 27 00 07 ; Load long $070027.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $FE00.w,X		; 3C 00 FE ; Test bits $FE00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jsr $6AF7.w		; 20 F7 6A ; Jump to subroutine at $6AF7.w [Writes: Stack Pointer] [Flow: call]
	sbc $2370.w,X		; FD 70 23 ; Subtract with carry $2370.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FDFA.w,X		; 3C FA FD ; Test bits $FDFA.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $050029.l,X		; FF 29 00 05 ; Subtract with carry (long,X) $050029.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $1F00.w		; 0C 00 1F ; Test and set bits $1F00.w [Reads: Accumulator] [Flags: Z]
	tsb $17.b		; 04 17 ; Test and set bits $17.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $002917.l,X		; 1F 17 29 00 ; Logical OR long $002917.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $38.b		; 05 38 ; Logical OR $38.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $B8		; 10 B8 ; Branch if plus to $10, $B8 [Flow: branch]
	.db $50, $24		; 50 24 ; Branch if overflow clear to $50, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	sta $2A.b		; 85 2A ; Store accumulator to $2A.b [Reads: Accumulator]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $171F.w		; 0C 1F 17 ; Test and set bits $171F.w [Reads: Accumulator] [Flags: Z]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $38.b		; 05 38 ; Logical OR $38.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $E8		; 30 E8 ; Branch if minus to $30, $E8 [Flow: branch]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $4ABE05.l,X		; 7F 05 BE 4A ; Add long $4ABE05.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $5A04.w,X		; 7E 04 5A ; Rotate right $5A04.w,X [Reads: X Index] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $1714.w		; 2C 14 17 ; Test bits $1714.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $5A1400.l		; 22 00 14 5A ; Jump to subroutine long $5A1400.l [Writes: Stack Pointer] [Flow: call]
	cmp $5B.b,X		; D5 5B ; Compare accumulator $5B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc [$3B.b],Y		; 77 3B ; Add with carry (long indexed) [$3B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $03.b		; 14 03 ; Test and reset bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $FF		; 70 FF ; Branch if overflow set to $70, $FF [Flow: branch]
	.db $B0, $7E		; B0 7E ; Branch if carry set to $B0, $7E [Flow: branch]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $34.b		; 14 34 ; Test and reset bits $34.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $74E000.l		; 22 00 E0 74 ; Jump to subroutine long $74E000.l [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $EEFA.w		; 4D FA EE ; Exclusive OR $EEFA.w with accumulator [Writes: Accumulator] [Flags: ZN]
	jmp.w [$C028]		; DC 28 C0 ; Jump long indirect [$C028] [Flow: jump]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	ora $1E2F.w,Y		; 19 2F 1E ; OR accumulator with memory $1E2F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $3D377A.l,X		; 3F 7A 37 3D ; AND accumulator with memory (long,X) $3D377A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0F.b		; 09 0F ; Logical OR #$0F.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7F7F3F.l,X		; 3F 3F 7F 7F ; AND accumulator with memory (long,X) $7F7F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $9F0F17.l,X		; 3F 17 0F 9F ; AND accumulator with memory (long,X) $9F0F17.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	stz $7F.b		; 64 7F ; Store zero to $7F.b
	sta ($F3.b)		; 92 F3 ; Store accumulator (indirect) ($F3.b) [Reads: Accumulator, Direct Page]
	.db $62, $D2, $E0		; 62 D2 E0 ; Push effective relative address $62, $D2, $E0 [Writes: Stack Pointer]
	asl $38E0.w,X		; 1E E0 38 ; Arithmetic shift left $38E0.w,X [Reads: X Index] [Flags: ZNC]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FEFD.w,X		; FD FD FE ; Subtract with carry $FEFD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $F0F8.w,X		; FE F8 F0 ; Increment memory $F0F8.w,X [Reads: X Index] [Flags: ZN]
	cpy #$DE.b		; C0 DE ; Compare #$DE.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	inc $736C.w,X		; FE 6C 73 ; Increment memory $736C.w,X [Reads: X Index] [Flags: ZN]
	and ($79.b),Y		; 31 79 ; AND accumulator with memory ($79.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $193F.w,Y		; 39 3F 19 ; AND accumulator with memory $193F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	lda $464E93.l,X		; BF 93 4E 46 ; Load long $464E93.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $1F.b		; 26 1F ; Rotate left $1F.b [Reads: Direct Page] [Flags: ZNC]
	ora $027B06.l		; 0F 06 7B 02 ; OR accumulator with memory (long) $027B06.l [Writes: Accumulator] [Flags: ZN]
	adc $044636.l,X		; 7F 36 46 04 ; Add long $044636.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $80.b		; E4 80 ; Compare $80.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$FA.b		; C9 FA ; Compare #$FA.b with accumulator [Reads: Accumulator] [Flags: ZNC]
	inc $F87C.w,X		; FE 7C F8 ; Increment memory $F87C.w,X [Reads: X Index] [Flags: ZN]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	cmp $60FF40.l,X		; DF 40 FF 60 ; Compare accumulator (long,X) $60FF40.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc $183B30.l,X		; 7F 30 3B 18 ; Add long $183B30.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	trb $0F0C.w		; 1C 0C 0F ; Test and reset bits $0F0C.w [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $BF1400.l		; 22 00 14 BF ; Jump to subroutine long $BF1400.l [Writes: Stack Pointer] [Flow: call]
	sta $13274F.l,X		; 9F 4F 27 13 ; Store accumulator (long,X) $13274F.l,X [Reads: Accumulator, X Index]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FE.b		; 06 FE ; Arithmetic shift left $FE.b [Reads: Direct Page] [Flags: ZNC]
	tsb $18DC.w		; 0C DC 18 ; Test and set bits $18DC.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $FD1300.l		; 22 00 13 FD ; Jump to subroutine long $FD1300.l [Writes: Stack Pointer] [Flow: call]
	sbc $E4F2.w,Y		; F9 F2 E4 ; Subtract with carry $E4F2.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$02.b],Y		; 17 02 ; OR accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$02.b]		; 27 02 ; AND accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $3E1D.w,X		; 3D 1D 3E ; AND accumulator with memory $3E1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpx $1401.w		; EC 01 14 ; Compare $1401.w with X register [Reads: X Index] [Flags: ZNC]
	ora [$1D.b],Y		; 17 1D ; OR accumulator with memory (long indexed) [$1D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $3922.w,X		; 3D 22 39 ; AND accumulator with memory $3922.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $060F.w,X		; 1E 0F 06 ; Arithmetic shift left $060F.w,X [Reads: X Index] [Flags: ZNC]
	inc $FE00.w,X		; FE 00 FE ; Increment memory $FE00.w,X [Reads: X Index] [Flags: ZN]
	jsr $50DC.w		; 20 DC 50 ; Jump to subroutine at $50DC.w [Writes: Stack Pointer] [Flow: call]
	ldy $7830.w,X		; BC 30 78 ; Load Y register $7830.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $FE0900.l		; 22 00 09 FE ; Jump to subroutine long $FE0900.l [Writes: Stack Pointer] [Flow: call]
	dec $CCAC.w,X		; DE AC CC ; Decrement memory $CCAC.w,X [Reads: X Index] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $CE43.w		; 2E 43 CE ; Rotate left $CE43.w [Flags: ZNC]
	eor $06.b		; 45 06 ; Exclusive OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $1D0D.w,X		; 7E 0D 1D ; Rotate right $1D0D.w,X [Reads: X Index] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	jsl $DF0900.l		; 22 00 09 DF ; Jump to subroutine long $DF0900.l [Writes: Stack Pointer] [Flow: call]
	ldx $7EBE.w,Y		; BE BE 7E ; Load X register $7EBE.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	asl $030C.w,X		; 1E 0C 03 ; Arithmetic shift left $030C.w,X [Reads: X Index] [Flags: ZNC]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor $66.b,S		; 43 66 ; Exclusive OR accumulator with stack relative $66.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldy $4CE0.w,X		; BC E0 4C ; Load Y register $4CE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	jmp ($BCB8.w,X)		; 7C B8 BC ; Jump indirect indexed to ($BCB8.w,X) [Reads: X Index] [Flow: jump]
	.db $50, $3C		; 50 3C ; Branch if overflow clear to $50, $3C [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsr ($7838.w,X)		; FC 38 78 ; Jump to subroutine indirect indexed ($7838.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7C7E.w,X		; 7E 7E 7C ; Rotate right $7C7E.w,X [Reads: X Index] [Flags: ZNC]
	jmp ($C434.w,X)		; 7C 34 C4 ; Jump indirect indexed to ($C434.w,X) [Reads: X Index] [Flow: jump]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $0A.b,X		; 15 0A ; OR accumulator with memory $0A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$0A.b],Y		; 37 0A ; AND accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	tsb $010F.w		; 0C 0F 01 ; Test and set bits $010F.w [Reads: Accumulator] [Flags: Z]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$27.b],Y		; 17 27 ; OR accumulator with memory (long indexed) [$27.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$13.b]		; 27 13 ; AND accumulator with memory (long) [$13.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $0405.w		; 0E 05 04 ; Arithmetic shift left $0405.w [Flags: ZNC]
	ora $AC.b,S		; 03 AC ; OR accumulator with stack relative $AC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cpx $6C90.w		; EC 90 6C ; Compare $6C90.w with X register [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $50, $F0		; 50 F0 ; Branch if overflow clear to $50, $F0 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($B8FC.w,X)		; 7C FC B8 ; Jump indirect indexed to ($B8FC.w,X) [Reads: X Index] [Flow: jump]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	jsr $16C0.w		; 20 C0 16 ; Jump to subroutine at $16C0.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $2901.w,Y		; 39 01 29 ; AND accumulator with memory $2901.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: ZNC]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	asl $17.b,X		; 16 17 ; Arithmetic shift left $17.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $392E.w		; 2E 2E 39 ; Rotate left $392E.w [Flags: ZNC]
	and $00001F.l		; 2F 1F 00 00 ; AND accumulator with memory (long) $00001F.l [Writes: Accumulator] [Flags: ZN]
	ldy $DC58.w,X		; BC 58 DC ; Load Y register $DC58.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $B0, $9C		; B0 9C ; Branch if carry set to $B0, $9C [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	cpy #$FC.b		; C0 FC ; Compare #$FC.b with Y register [Reads: Y Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	sta $C7.b,S		; 83 C7 ; Store accumulator (stack relative) $C7.b,S [Reads: Accumulator, Stack Pointer]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F8.b,X		; 34 F8 ; Test bits $F8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	jsr ($88E4.w,X)		; FC E4 88 ; Jump to subroutine indirect indexed ($88E4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $03		; 70 03 ; Branch if overflow set to $70, $03 [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $210D12.l		; 0F 12 0D 21 ; OR accumulator with memory (long) $210D12.l [Writes: Accumulator] [Flags: ZN]
	asl $1D22.w,X		; 1E 22 1D ; Arithmetic shift left $1D22.w,X [Reads: X Index] [Flags: ZNC]
	eor ($3E.b,X)		; 41 3E ; Exclusive OR accumulator with memory ($3E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $1F0F03.l,X		; 1F 03 0F 1F ; Logical OR long $1F0F03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $7E3D3F.l,X		; 1F 3F 3D 7E ; Logical OR long $7E3D3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $3000C0.l,X		; 7F C0 00 30 ; Add long $3000C0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy #$C8.b		; C0 C8 ; Compare #$C8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $30, $E8		; 30 E8 ; Branch if minus to $30, $E8 [Flow: branch]
	.db $10, $F4		; 10 F4 ; Branch if plus to $10, $F4 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $16.b		; 24 16 ; Test bits $16.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	sty $268C.w		; 8C 8C 26 ; Store Y register to $268C.w [Reads: Y Index]
	inc $0083.w		; EE 83 00 ; Increment $0083.w [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	lsr $7131.w		; 4E 31 71 ; Logical shift right $7131.w [Flags: ZNC]
	asl $307F.w		; 0E 7F 30 ; Arithmetic shift left $307F.w [Flags: ZNC]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	adc ($7E.b),Y		; 71 7E ; Add with carry ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $00C0.w		; 4E C0 00 ; Logical shift right $00C0.w [Flags: ZNC]
	jsr $90C0.w		; 20 C0 90 ; Jump to subroutine at $90C0.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $C8.b,S		; 43 C8 ; Exclusive OR accumulator with stack relative $C8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $0D		; 30 0D ; Branch if minus to $30, $0D [Flow: branch]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	bit $C0D0.w		; 2C D0 C0 ; Test bits $C0D0.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $DC3C.w		; 1C 3C DC ; Test and reset bits $DC3C.w [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: ZNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $E8.b		; 64 E8 ; Store zero to $E8.b
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0025.w		; 0C 25 00 ; Test and set bits $0025.w [Reads: Accumulator] [Flags: Z]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $850027.l		; 2F 27 00 85 ; AND accumulator with memory (long) $850027.l [Writes: Accumulator] [Flags: ZN]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	ora ($78.b,X)		; 01 78 ; Logical OR ($78.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $2503.w		; 8C 03 25 ; Store Y register to $2503.w [Reads: Y Index]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	cpx #$1C.b		; E0 1C ; Compare #$1C.b with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	jsl $400400.l		; 22 00 04 40 ; Jump to subroutine long $400400.l [Writes: Stack Pointer] [Flow: call]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($277F.w,X)		; FC 7F 27 ; Jump to subroutine indirect indexed ($277F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $0F0C.w		; 0E 0C 0F ; Arithmetic shift left $0F0C.w [Flags: ZNC]
	rol $1F.b,X		; 36 1F ; Rotate left $1F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0E04.w		; 0D 04 0E ; Logical OR $0E04.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $001CFF.l,X		; 3F FF 1C 00 ; AND accumulator with memory (long,X) $001CFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $5931.w		; 4E 31 59 ; Logical shift right $5931.w [Flags: ZNC]
	rol $7C.b		; 26 7C ; Rotate left $7C.b [Reads: Direct Page] [Flags: ZNC]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $E001.w,X		; 7E 01 E0 ; Rotate right $E001.w,X [Reads: X Index] [Flags: ZNC]
	and [$5F.b]		; 27 5F ; AND accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	and $4F.b,S		; 23 4F ; AND accumulator with stack relative $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor [$63.b],Y		; 57 63 ; Exclusive OR accumulator with memory (long indexed) [$63.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $75.b		; 45 75 ; Exclusive OR $75.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$7C.b		; C0 7C ; Compare #$7C.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	dec $BA30.w		; CE 30 BA ; Decrement $BA30.w [Flags: ZN]
	mvp $C0,$00		; 44 00 C0 ; Move block positive $C0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx $C4.b		; E4 C4 ; Compare $C4.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	stz $763A.w		; 9C 3A 76 ; Store zero to $763A.w
	trb $2200.w		; 1C 00 22 ; Test and reset bits $2200.w [Reads: Accumulator] [Flags: Z]
	trb $304E.w		; 1C 4E 30 ; Test and reset bits $304E.w [Reads: Accumulator] [Flags: Z]
	sta $F6.b,S		; 83 F6 ; Store accumulator (stack relative) $F6.b,S [Reads: Accumulator, Stack Pointer]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $0401.w,X		; 7E 01 04 ; Rotate right $0401.w,X [Reads: X Index] [Flags: ZNC]
	eor $221C10.l,X		; 5F 10 1C 22 ; Exclusive OR accumulator with memory (long,X) $221C10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lsr $0384.w		; 4E 84 03 ; Logical shift right $0384.w [Flags: ZNC]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpy $E630.w		; CC 30 E6 ; Compare $E630.w with Y register [Reads: Y Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $180400.l		; 22 00 04 18 ; Jump to subroutine long $180400.l [Writes: Stack Pointer] [Flow: call]
	cpx $3C9C.w		; EC 9C 3C ; Compare $3C9C.w with X register [Reads: X Index] [Flags: ZNC]
	asl $0027.w,X		; 1E 27 00 ; Arithmetic shift left $0027.w,X [Reads: X Index] [Flags: ZNC]
	ora [$60.b]		; 07 60 ; OR accumulator with memory (long) [$60.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1A7F.w		; 0C 7F 1A ; Test and set bits $1A7F.w [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $60.b,S		; 03 60 ; OR accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp.w [$7FFF]		; DC FF 7F ; Jump long indirect [$7FFF] [Flow: jump]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $B2FD.w		; 2C FD B2 ; Test bits $B2FD.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $04		; 10 04 ; Branch if plus to $10, $04 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $44FF.w,X		; FD FF 44 ; Subtract with carry $44FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $3C.b,S		; 43 3C ; Exclusive OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $181629.l,X		; 3F 29 16 18 ; AND accumulator with memory (long,X) $181629.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $7F2200.l		; 22 00 22 7F ; Jump to subroutine long $7F2200.l [Writes: Stack Pointer] [Flow: call]
	ora ($3E.b),Y		; 11 3E ; OR accumulator with memory ($3E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $00030F.l,X		; 1F 0F 03 00 ; Logical OR long $00030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pei ($DE.b)		; D4 DE ; Push effective indirect address ($DE.b) [Reads: Direct Page] [Writes: Stack Pointer]
	jsr $C43A.w		; 20 3A C4 ; Jump to subroutine at $C43A.w [Writes: Stack Pointer] [Flow: call]
	pea $1808.w		; F4 08 18 ; Push absolute address $1808.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpx #$30.b		; E0 30 ; Compare #$30.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $F61400.l		; 22 00 14 F6 ; Jump to subroutine long $F61400.l [Writes: Stack Pointer] [Flow: call]
	sep #$C6		; E2 C6 ; Set processor status bits #$C6 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	tsb $F0F8.w		; 0C F8 F0 ; Test and set bits $F0F8.w [Reads: Accumulator] [Flags: Z]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	rol $7F0D.w,X		; 3E 0D 7F ; Rotate left $7F0D.w,X [Reads: X Index] [Flags: ZNC]
	rol $76.b		; 26 76 ; Rotate left $76.b [Reads: Direct Page] [Flags: ZNC]
	and ($63.b,X)		; 21 63 ; Logical AND ($63.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsr $183B.w		; 20 3B 18 ; Jump to subroutine at $183B.w [Writes: Stack Pointer] [Flow: call]
	asl $0705.w,X		; 1E 05 07 ; Arithmetic shift left $0705.w,X [Reads: X Index] [Flags: ZNC]
	jsl $331400.l		; 22 00 14 33 ; Jump to subroutine long $331400.l [Writes: Stack Pointer] [Flow: call]
	eor $5F5F.w,Y		; 59 5F 5F ; Exclusive OR accumulator with memory $5F5F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $1B.b		; 26 1B ; Rotate left $1B.b [Reads: Direct Page] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldy $5C50.w		; AC 50 5C ; Load $5C50.w into Y register [Writes: Y Index] [Flags: ZN]
	ldy #$E4.b		; A0 E4 ; Load #$E4.b into Y register [Writes: Y Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $70, $10		; 70 10 ; Branch if overflow set to $70, $10 [Flow: branch]
	cpx #$60.b		; E0 60 ; Compare #$60.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $DC1100.l		; 22 00 11 DC ; Jump to subroutine long $DC1100.l [Writes: Stack Pointer] [Flow: call]
	ldy $78BC.w,X		; BC BC 78 ; Load Y register $78BC.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rol $1211.w		; 2E 11 12 ; Rotate left $1211.w [Flags: ZNC]
	ora $001F.w		; 0D 1F 00 ; Logical OR $001F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $1C.b		; 26 1C ; Rotate left $1C.b [Reads: Direct Page] [Flags: ZNC]
	and $78851D.l		; 2F 1D 85 78 ; AND accumulator with memory (long) $78851D.l [Writes: Accumulator] [Flags: ZN]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($1F.b,S),Y		; 33 1F ; AND accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $93833F.l,X		; 1F 3F 83 93 ; Logical OR long $93833F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	rol $A0F8.w,X		; 3E F8 A0 ; Rotate left $A0F8.w,X [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $B0, $CC		; B0 CC ; Branch if carry set to $B0, $CC [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx $FCB8.w		; EC B8 FC ; Compare $FCB8.w with X register [Reads: X Index] [Flags: ZNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr $C070.w		; 20 70 C0 ; Jump to subroutine at $C070.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($7C7C.w,X)		; FC 7C 7C ; Jump to subroutine indirect indexed ($7C7C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	and $1F13.w		; 2D 13 1F ; Logical AND $1F13.w with accumulator [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$04.b],Y		; 17 04 ; OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $132E0D.l,X		; 3F 0D 2E 13 ; AND accumulator with memory (long,X) $132E0D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $1F0D.w,X		; 3E 0D 1F ; Rotate left $1F0D.w,X [Reads: X Index] [Flags: ZNC]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1B.b],Y		; 17 1B ; OR accumulator with memory (long indexed) [$1B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($3F.b,S),Y		; 33 3F ; AND accumulator (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $F8011F.l,X		; 3F 1F 01 F8 ; AND accumulator with memory (long,X) $F8011F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $70, $CC		; 70 CC ; Branch if overflow set to $70, $CC [Flow: branch]
	.db $F0, $74		; F0 74 ; Branch if equal to $F0, $74 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ror $7CDC.w,X		; 7E DC 7C ; Rotate right $7CDC.w,X [Reads: X Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	sta $07.b,S		; 83 07 ; Store accumulator (stack relative) $07.b,S [Reads: Accumulator, Stack Pointer]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr ($FCFE.w,X)		; FC FE FC ; Jump to subroutine indirect indexed ($FCFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$3D.b		; E0 3D ; Compare #$3D.b with X register [Reads: X Index] [Flags: ZNC]
	ora ($3E.b)		; 12 3E ; OR accumulator with memory (indirect) ($3E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3E77.w,X		; 1D 77 3E ; OR accumulator with memory $3E77.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $3F.b		; 65 3F ; Add $3F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $1F17.w		; 2D 17 1F ; Logical AND $1F17.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $C283.w,X		; 3E 83 C2 ; Rotate left $C283.w,X [Reads: X Index] [Flags: ZNC]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and [$1F.b]		; 27 1F ; AND accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $06FF0F.l,X		; 1F 0F FF 06 ; Logical OR long $06FF0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $DAA8.w,Y		; 79 A8 DA ; Add $DAA8.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cpy $1CF0.w		; CC F0 1C ; Compare $1CF0.w with Y register [Reads: Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$B0.b		; E0 B0 ; Compare #$B0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $39.b		; 00 39 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$F6.b],Y		; F7 F6 ; Subtract with carry (long indexed) [$F6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	sta [$08.b],Y		; 97 08 ; Store accumulator (long indexed) [$08.b],Y [Reads: Accumulator, Direct Page, Y Index]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $4B.b		; 14 4B ; Test and reset bits $4B.b [Reads: Accumulator] [Flags: Z]
	bit $31.b,X		; 34 31 ; Test bits $31.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	asl $0E11.w		; 0E 11 0E ; Arithmetic shift left $0E11.w [Flags: ZNC]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	jsl $F81F00.l		; 22 00 1F F8 ; Jump to subroutine long $F81F00.l [Writes: Stack Pointer] [Flow: call]
	jmp ($3E4C.w)		; 6C 4C 3E ; Jump indirect to ($3E4C.w) [Flow: jump]
	asl $030F.w,X		; 1E 0F 03 ; Arithmetic shift left $030F.w,X [Reads: X Index] [Flags: ZNC]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $B6.b		; 84 B6 ; Store Y register to $B6.b [Reads: Y Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	nop		; EA ; No operation
	trb $C4.b		; 14 C4 ; Test and reset bits $C4.b [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	pea $B848.w		; F4 48 B8 ; Push absolute address $B848.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	jsr $00F0.w		; 20 F0 00 ; Jump to subroutine at $00F0.w [Writes: Stack Pointer] [Flow: call]
	stx $CE.b		; 86 CE ; Store X register to $CE.b [Reads: X Index]
	lsr $BC7C.w,X		; 5E 7C BC ; Logical shift right $BC7C.w,X [Reads: X Index] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $F0, $85		; F0 85 ; Branch if equal to $F0, $85 [Flow: branch]
	.db $70, $05		; 70 05 ; Branch if overflow set to $70, $05 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and ($0C.b,S),Y		; 33 0C ; AND accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp $3F03.w		; 4C 03 3F ; Jump to $3F03.w [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $7F83.w		; 1C 83 7F ; Test and reset bits $7F83.w [Reads: Accumulator] [Flags: Z]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $7F3E.w,X		; 3C 3E 7F ; Test bits $7F3E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	and [$1C.b],Y		; 37 1C ; AND accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $BF86.w,Y		; 79 86 BF ; Add $BF86.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor $A3B2.w		; 4D B2 A3 ; Exclusive OR $A3B2.w with accumulator [Writes: Accumulator] [Flags: ZN]
	jmp $1E40BE.l		; 5C BE 40 1E ; Jump long to $1E40BE.l [Flow: jump]
	cpx $E4.b		; E4 E4 ; Compare $E4.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	jsl $9F1700.l		; 22 00 17 9F ; Jump to subroutine long $9F1700.l [Writes: Stack Pointer] [Flow: call]
	cmp [$F3.b]		; C7 F3 ; Compare accumulator (long) [$F3.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	adc $E4FA7E.l,X		; 7F 7E FA E4 ; Add long $E4FA7E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3E73.w		; 1C 73 3E ; Test and reset bits $3E73.w [Reads: Accumulator] [Flags: Z]
	adc $3A.b,X		; 75 3A ; Add $3A.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $0A3F.w		; 1C 3F 0A ; Test and reset bits $0A3F.w [Reads: Accumulator] [Flags: Z]
	and $1C3F12.l,X		; 3F 12 3F 1C ; AND accumulator with memory (long,X) $1C3F12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $8300.w,X		; 1E 00 83 ; Arithmetic shift left $8300.w,X [Reads: X Index] [Flags: ZNC]
	rep #$01		; C2 01 ; Reset processor status bits #$01 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	and $DF1E23.l		; 2F 23 1E DF ; AND accumulator with memory (long) $DF1E23.l [Writes: Accumulator] [Flags: ZN]
	stz $9D.b,X		; 74 9D ; Store zero to $9D.b,X [Reads: X Index]
	cpx $B059.w		; EC 59 B0 ; Compare $B059.w with X register [Reads: X Index] [Flags: ZNC]
	ldx $FC70.w,Y		; BE 70 FC ; Load X register $FC70.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsl $FB0700.l		; 22 00 07 FB ; Jump to subroutine long $FB0700.l [Writes: Stack Pointer] [Flow: call]
	sbc ($FF.b,S),Y		; F3 FF ; Subtract with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $F0FC.w,X		; FE FC F0 ; Increment memory $F0FC.w,X [Reads: X Index] [Flags: ZN]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $00A7E0.l,X		; FF E0 A7 00 ; Subtract with carry (long,X) $00A7E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: ZNC]
	ora $711E33.l		; 0F 33 1E 71 ; OR accumulator with memory (long) $711E33.l [Writes: Accumulator] [Flags: ZN]
	and $BF3E75.l,X		; 3F 75 3E BF ; AND accumulator with memory (long,X) $BF3E75.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0600.w,X		; 1D 00 06 ; OR accumulator with memory $0600.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $7F3F1F.l		; 0F 1F 3F 7F ; OR accumulator with memory (long) $7F3F1F.l [Writes: Accumulator] [Flags: ZN]
	adc $0000FE.l,X		; 7F FE 00 00 ; Add long $0000FE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $CC		; F0 CC ; Branch if equal to $F0, $CC [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stx $AEFC.w		; 8E FC AE ; Store X register to $AEFC.w [Reads: X Index]
	jmp ($B8FD.w,X)		; 7C FD B8 ; Jump indirect indexed to ($B8FD.w,X) [Reads: X Index] [Flow: jump]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $020000.l,X		; 7F 00 00 02 ; Add long $020000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $281F31.l		; 0F 31 1F 28 ; OR accumulator with memory (long) $281F31.l [Writes: Accumulator] [Flags: ZN]
	ora $3F2F5F.l,X		; 1F 5F 2F 3F ; Logical OR long $3F2F5F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7F3F3F.l,X		; 1F 3F 3F 7F ; Logical OR long $7F3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $400000.l		; 2F 00 00 40 ; AND accumulator with memory (long) $400000.l [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	dec $00BC.w,X		; DE BC 00 ; Decrement memory $00BC.w,X [Reads: X Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($00FE.w,X)		; FC FE 00 ; Jump to subroutine indirect indexed ($00FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $6EBB2D.l,X		; 7F 2D BB 6E ; Add long $6EBB2D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	eor $04CF.w		; 4D CF 04 ; Exclusive OR $04CF.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF7E3F.l,X		; 1F 3F 7E FF ; Logical OR long $FF7E3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $0000FE.l,X		; FF FE 00 00 ; Subtract with carry (long,X) $0000FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy $FE00.w		; CC 00 FE ; Compare $FE00.w with Y register [Reads: Y Index] [Flags: ZNC]
	tsb $1EFB.w		; 0C FB 1E ; Test and set bits $1EFB.w [Reads: Accumulator] [Flags: Z]
	sbc $EFBE.w,X		; FD BE EF ; Subtract with carry $EFBE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	ror $F6B8.w		; 6E B8 F6 ; Rotate right $F6B8.w [Flags: ZNC]
	bit $CC00.w,X		; 3C 00 CC ; Test bits $CC00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	inc $7FFF.w,X		; FE FF 7F ; Increment memory $7FFF.w,X [Reads: X Index] [Flags: ZN]
	sbc $007EFE.l,X		; FF FE 7E 00 ; Subtract with carry (long,X) $007EFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $BF		; 30 BF ; Branch if minus to $30, $BF [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda $46FB6D.l,X		; BF 6D FB 46 ; Load long $46FB6D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	and ($7F.b,S),Y		; 33 7F ; AND accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FFFFFE.l,X		; FF FE FF FF ; Subtract with carry (long,X) $FFFFFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stx $7885.w		; 8E 85 78 ; Store X register to $7885.w [Reads: X Index]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FD1E.w,X		; FD 1E FD ; Subtract with carry $FD1E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $DF.b,Y		; B6 DF ; Load X register $DF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	.db $62, $53, $A0		; 62 53 A0 ; Push effective relative address $62, $53, $A0 [Writes: Stack Pointer]
	sbc $88852E.l,X		; FF 2E 85 88 ; Subtract with carry (long,X) $88852E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $008771.l,X		; FF 71 87 00 ; Subtract with carry (long,X) $008771.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($1E.b,S),Y		; 33 1E ; AND accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $71.b,S		; 03 71 ; OR accumulator with stack relative $71.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $843F7C.l,X		; 3F 7C 3F 84 ; AND accumulator with memory (long,X) $843F7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $18877F.l,X		; 7F 7F 87 18 ; Add long $18877F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $0378.w		; CC 78 03 ; Compare $0378.w with Y register [Reads: Y Index] [Flags: ZNC]
	stx $3EFC.w		; 8E FC 3E ; Store X register to $3EFC.w [Reads: X Index]
	jsr ($2884.w,X)		; FC 84 28 ; Jump to subroutine indirect indexed ($2884.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $283B24.l,X		; 1F 24 3B 28 ; Logical OR long $283B24.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and [$40.b],Y		; 37 40 ; AND accumulator with memory (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $427E41.l,X		; 7F 41 7E 42 ; Add long $427E41.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $0700.w,X		; 7D 00 07 ; Add $0700.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $7F373B.l,X		; 1F 3B 37 7F ; Logical OR long $7F373B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $007D.w,X		; 7E 7D 00 ; Rotate right $007D.w,X [Reads: X Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$44.b]		; 07 44 ; OR accumulator with memory (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $B80700.l,X		; FF 00 07 B8 ; Subtract with carry (long,X) $B80700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor [$7D.b]		; 47 7D ; Exclusive OR accumulator with memory (long) [$7D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $82, $FF, $00		; 82 FF 00 ; Branch always long to $82, $FF, $00 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $4701FF.l		; 22 FF 01 47 ; Jump to subroutine long $4701FF.l [Writes: Stack Pointer] [Flow: call]
	.db $82, $2C, $00		; 82 2C 00 ; Branch always long to $82, $2C, $00 [Flow: branch]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $010025.l,X		; 1F 25 00 01 ; Logical OR long $010025.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: ZNC]
	ora $0025FF.l,X		; 1F FF 25 00 ; Logical OR long $0025FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	sbc $070000.l,X		; FF 00 00 07 ; Subtract with carry (long,X) $070000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $63.b,S		; 83 63 ; Store accumulator (stack relative) $63.b,S [Reads: Accumulator, Stack Pointer]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $BF.b		; 05 BF ; Logical OR $BF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $007F22.l,X		; 3F 22 7F 00 ; AND accumulator with memory (long,X) $007F22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $83.b,X		; F6 83 ; Increment memory $83.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	mvp $FC,$00		; 44 00 FC ; Move block positive $FC,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$76.b		; E0 76 ; Compare #$76.b with X register [Reads: X Index] [Flags: ZNC]
	inc $FE00.w,X		; FE 00 FE ; Increment memory $FE00.w,X [Reads: X Index] [Flags: ZN]
	.db $80, $FD		; 80 FD ; Branch always to $80, $FD [Flow: branch]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cld		; D8 ; Clear decimal flag [Flags: D]
	cpx $FEFC.w		; EC FC FE ; Compare $FEFC.w with X register [Reads: X Index] [Flags: ZNC]
	ror $BF6F.w,X		; 7E 6F BF ; Rotate right $BF6F.w,X [Reads: X Index] [Flags: ZNC]
	ora $23BF.w,X		; 1D BF 23 ; OR accumulator with memory $23BF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $10726D.l,X		; FF 6D 72 10 ; Subtract with carry (long,X) $10726D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $003F18.l,X		; 3F 18 3F 00 ; AND accumulator with memory (long,X) $003F18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $0D00.w,X		; 1E 00 0D ; Arithmetic shift left $0D00.w,X [Reads: X Index] [Flags: ZNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$6F92]		; DC 92 6F ; Jump long indirect [$6F92] [Flow: jump]
	and [$3F.b]		; 27 3F ; AND accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $B8FD0D.l,X		; 1F 0D FD B8 ; Logical OR long $B8FD0D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FFC4.w,X		; FD C4 FF ; Subtract with carry $FFC4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $4E.b,Y		; B6 4E ; Load X register $4E.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($FC18.w,X)		; FC 18 FC ; Jump to subroutine indirect indexed ($FC18.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor #$F6.b		; 49 F6 ; Exclusive OR #$F6.b with accumulator [Writes: Accumulator] [Flags: ZN]
	cpx $FC.b		; E4 FC ; Compare $FC.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $3F		; B0 3F ; Branch if carry set to $B0, $3F [Flow: branch]
	ora [$3F.b],Y		; 17 3F ; OR accumulator with memory (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $024B04.l		; 2F 04 4B 02 ; AND accumulator with memory (long) $024B04.l [Writes: Accumulator] [Flags: ZN]
	adc [$31.b],Y		; 77 31 ; Add with carry (long indexed) [$31.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $013F00.l,X		; 3F 00 3F 01 ; AND accumulator with memory (long,X) $013F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $272F00.l,X		; 1F 00 2F 27 ; Logical OR long $272F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $3F4E.w,X		; 7D 4E 3F ; Add $3F4E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $A61F.w,X		; 3E 1F A6 ; Rotate left $A61F.w,X [Reads: X Index] [Flags: ZNC]
	trb $18A4.w		; 1C A4 18 ; Test and reset bits $18A4.w [Reads: Accumulator] [Flags: Z]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ror $FC5C.w,X		; 7E 5C FC ; Rotate right $FC5C.w,X [Reads: X Index] [Flags: ZNC]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($BEFC.w,X)		; FC FC BE ; Jump to subroutine indirect indexed ($BEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp ($3018.w,X)		; 7C 18 30 ; Jump indirect indexed to ($3018.w,X) [Reads: X Index] [Flow: jump]
	cpy #$ED.b		; C0 ED ; Compare #$ED.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $62, $7E, $31		; 62 7E 31 ; Push effective relative address $62, $7E, $31 [Writes: Stack Pointer]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1E16.w,Y		; 39 16 1E ; AND accumulator with memory $1E16.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $9E.b		; 04 9E ; Test and set bits $9E.b [Reads: Accumulator] [Flags: Z]
	eor $1E2931.l		; 4F 31 29 1E ; Exclusive OR accumulator with memory (long) $1E2931.l [Writes: Accumulator] [Flags: ZN]
	jsl $22E000.l		; 22 00 E0 22 ; Jump to subroutine long $22E000.l [Writes: Stack Pointer] [Flow: call]
	rol $7AD8.w,X		; 3E D8 7A ; Rotate left $7AD8.w,X [Reads: X Index] [Flags: ZNC]
	sty $B2.b,X		; 94 B2 ; Store Y register $B2.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	jmp $7C82.w		; 4C 82 7C ; Jump to $7C82.w [Flow: jump]
	stx $78.b		; 86 78 ; Store X register to $78.b [Reads: X Index]
	ror $5E04.w,X		; 7E 04 5E ; Rotate right $5E04.w,X [Reads: X Index] [Flags: ZNC]
	trb $003C.w		; 1C 3C 00 ; Test and reset bits $003C.w [Reads: Accumulator] [Flags: Z]
	inc $B2FA.w,X		; FE FA B2 ; Increment memory $B2FA.w,X [Reads: X Index] [Flags: ZN]
	.db $82, $86, $7A		; 82 86 7A ; Branch always long to $82, $86, $7A [Flow: branch]
	.db $62, $3C, $7F		; 62 3C 7F ; Push effective relative address $62, $3C, $7F [Writes: Stack Pointer]
	tsb $6C.b		; 04 6C ; Test and set bits $6C.b [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	ror $7F3D.w,X		; 7E 3D 7F ; Rotate right $7F3D.w,X [Reads: X Index] [Flags: ZNC]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($7F.b)		; 12 7F ; OR accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvn $7B,$42		; 54 42 7B ; Move block negative $7B,$42 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	bit $003C.w,X		; 3C 3C 00 ; Test bits $003C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $D436.w		; 20 36 D4 ; Jump to subroutine at $D436.w [Writes: Stack Pointer] [Flow: call]
	ror $FEBC.w,X		; 7E BC FE ; Rotate right $FEBC.w,X [Reads: X Index] [Flags: ZNC]
	jsr $003C.w		; 20 3C 00 ; Jump to subroutine at $003C.w [Writes: Stack Pointer] [Flow: call]
	bit $0024.w,X		; 3C 24 00 ; Test bits $0024.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $42, $DE		; 42 DE ; Reserved instruction
	sta $24.b,S		; 83 24 ; Store accumulator (stack relative) $24.b,S [Reads: Accumulator, Stack Pointer]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$BF.b],Y		; 37 BF ; AND accumulator with memory (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl $1DBF.w,X		; 1E BF 1D ; Arithmetic shift left $1DBF.w,X [Reads: X Index] [Flags: ZNC]
	sbc $257D79.l,X		; FF 79 7D 25 ; Subtract with carry (long,X) $257D79.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and ($10.b,S),Y		; 33 10 ; AND accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $001F10.l,X		; 3F 10 1F 00 ; AND accumulator with memory (long,X) $001F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $7ABEFE.l,X		; FF FE BE 7A ; Subtract with carry (long,X) $7ABEFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $061F2F.l		; 2F 2F 1F 06 ; AND accumulator with memory (long) $061F2F.l [Writes: Accumulator] [Flags: ZN]
	sbc $FD78.w,X		; FD 78 FD ; Subtract with carry $FD78.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sbc $A4BE9E.l,X		; FF 9E BE A4 ; Subtract with carry (long,X) $A4BE9E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpy $FC08.w		; CC 08 FC ; Compare $FC08.w with Y register [Reads: Y Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	adc $F45E7D.l,X		; 7F 7D 5E F4 ; Add long $F45E7D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	pea $60F8.w		; F4 F8 60 ; Push absolute address $60F8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	adc ($7E.b,X)		; 61 7E ; Add with carry ($7E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor ($7D.b)		; 52 7D ; Exclusive OR accumulator with memory (indirect) ($7D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($3E.b,X)		; 21 3E ; Logical AND ($3E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jsl $74833D.l		; 22 3D 83 74 ; Jump to subroutine long $74833D.l [Writes: Stack Pointer] [Flow: call]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1416.w,Y		; 19 16 14 ; OR accumulator with memory $1416.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ror $437D.w,X		; 7E 7D 43 ; Rotate right $437D.w,X [Reads: X Index] [Flags: ZNC]
	rol $1D3D.w,X		; 3E 3D 1D ; Rotate left $1D3D.w,X [Reads: X Index] [Flags: ZNC]
	asl $1B.b,X		; 16 1B ; Arithmetic shift left $1B.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	adc $00FF80.l,X		; 7F 80 FF 00 ; Add long $00FF80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $30CF40.l,X		; BF 40 CF 30 ; Load long $30CF40.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$FF.b]		; 87 FF ; Store accumulator (long) [$FF.b] [Reads: Accumulator, Direct Page]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $BF		; 80 BF ; Branch always to $80, $BF [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $30, $87		; 30 87 ; Branch if minus to $30, $87 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $3C.b,S		; 23 3C ; AND accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $5F4370.l		; 4F 70 43 5F ; Exclusive OR accumulator with memory (long) $5F4370.l [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $302F.w		; 1C 2F 30 ; Test and reset bits $302F.w [Reads: Accumulator] [Flags: Z]
	.db $30, $3F		; 30 3F ; Branch if minus to $30, $3F [Flow: branch]
	rol $133F.w		; 2E 3F 13 ; Rotate left $133F.w [Flags: ZNC]
	ora $703C.w,X		; 1D 3C 70 ; OR accumulator with memory $703C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $3F		; 30 3F ; Branch if minus to $30, $3F [Flow: branch]
	and $7F801D.l,X		; 3F 1D 80 7F ; AND accumulator with memory (long,X) $7F801D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp ($FB83.w,X)		; 7C 83 FB ; Jump indirect indexed to ($FB83.w,X) [Reads: X Index] [Flow: jump]
	tsb $F7.b		; 04 F7 ; Test and set bits $F7.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $43BC00.l,X		; FF 00 BC 43 ; Subtract with carry (long,X) $43BC00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $36E07F.l,X		; FF 7F E0 36 ; Subtract with carry (long,X) $36E07F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $04.b,S		; 83 04 ; Store accumulator (stack relative) $04.b,S [Reads: Accumulator, Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $40DEFF.l,X		; FF FF DE 40 ; Subtract with carry (long,X) $40DEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $7E70.w,X		; FE 70 7E ; Increment memory $7E70.w,X [Reads: X Index] [Flags: ZN]
	.db $10, $7C		; 10 7C ; Branch if plus to $10, $7C [Flow: branch]
	tsb $67EF.w		; 0C EF 67 ; Test and set bits $67EF.w [Reads: Accumulator] [Flags: Z]
	cmp [$40.b]		; C7 40 ; Compare accumulator (long) [$40.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	jsr $0030.w		; 20 30 00 ; Jump to subroutine at $0030.w [Writes: Stack Pointer] [Flow: call]
	lda $6B8B.w,Y		; B9 8B 6B ; Load $6B8B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($98.b,S),Y		; 73 98 ; Add with carry (stack relative indirect indexed) ($98.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $7B3058.l,X		; BF 58 30 7B ; Load long $7B3058.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $7F.b		; 02 7F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $087E.w		; 0E 7E 08 ; Arithmetic shift left $087E.w [Flags: ZNC]
	rol $F730.w,X		; 3E 30 F7 ; Rotate left $F730.w,X [Reads: X Index] [Flags: ZNC]
	inc $E3.b		; E6 E3 ; Increment $E3.b [Reads: Direct Page] [Flags: ZN]
	cop $16.b		; 02 16 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	brk $9D.b		; 00 9D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($D6.b),Y		; D1 D6 ; Compare accumulator ($D6.b),Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	dec $FD19.w		; CE 19 FD ; Decrement $FD19.w [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $0025.w		; 0C 25 00 ; Test and set bits $0025.w [Reads: Accumulator] [Flags: Z]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $9083.w,X		; 1D 83 90 ; OR accumulator with memory $9083.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F8FF30.l,X		; FF 30 FF F8 ; Subtract with carry (long,X) $F8FF30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$FD.b],Y		; 37 FD ; AND accumulator with memory (long indexed) [$FD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($FE.b,S),Y		; 73 FE ; Add with carry (stack relative indirect indexed) ($FE.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cmp $B0FF.w		; CD FF B0 ; Compare $B0FF.w with accumulator [Reads: Accumulator] [Flags: ZNC]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00A383.l,X		; FF 83 A3 00 ; Subtract with carry (long,X) $00A383.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$44.b]		; 07 44 ; OR accumulator with memory (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $071E.w		; 0D 1E 07 ; Logical OR $071E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $0D.b,X		; 16 0D ; Arithmetic shift left $0D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	bit $0B.b,X		; 34 0B ; Test bits $0B.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $2F1F1F.l		; 0F 1F 1F 2F ; OR accumulator with memory (long) $2F1F1F.l [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($C0.b,S),Y		; 13 C0 ; OR accumulator (stack relative indirect indexed) ($C0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $60F0.w		; 20 F0 60 ; Jump to subroutine at $60F0.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $D8		; B0 D8 ; Branch if carry set to $B0, $D8 [Flow: branch]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $0F,$00		; 44 00 0F ; Move block positive $0F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $14.b		; 05 14 ; Logical OR $14.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $5A8400.l		; 22 00 84 5A ; Jump to subroutine long $5A8400.l [Writes: Stack Pointer] [Flow: call]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $03.b		; 64 03 ; Store zero to $03.b
	ora ($D8.b,X)		; 01 D8 ; Logical OR ($D8.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $B0, $22		; B0 22 ; Branch if carry set to $B0, $22 [Flow: branch]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($03.b)		; 72 03 ; Add with carry (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $66,$E7		; 44 E7 66 ; Move block positive $66,$E7 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $99.b		; 02 99 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $25FF.w,Y		; 99 FF 25 ; Store accumulator to $25FF.w,Y [Reads: Accumulator, Y Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	jsr $60BC.w		; 20 BC 60 ; Jump to subroutine at $60BC.w [Writes: Stack Pointer] [Flow: call]
	sta [$6E.b],Y		; 97 6E ; Store accumulator (long indexed) [$6E.b],Y [Reads: Accumulator, Direct Page, Y Index]
	inc $0D.b,X		; F6 0D ; Increment memory $0D.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sta $00000C.l,X		; 9F 0C 00 00 ; Store accumulator (long,X) $00000C.l,X [Reads: Accumulator, X Index]
	jsr $FC70.w		; 20 70 FC ; Jump to subroutine at $FC70.w [Writes: Stack Pointer] [Flow: call]
	sbc $07FEFF.l,X		; FF FF FE 07 ; Subtract with carry (long,X) $07FEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $7CE2.w,X		; 1E E2 7C ; Arithmetic shift left $7CE2.w,X [Reads: X Index] [Flags: ZNC]
	ror $FCBC.w		; 6E BC FC ; Rotate right $FCBC.w [Flags: ZNC]
	.db $30, $07		; 30 07 ; Branch if minus to $30, $07 [Flow: branch]
	ora $3F1F09.l		; 0F 09 1F 3F ; OR accumulator with memory (long) $3F1F09.l [Writes: Accumulator] [Flags: ZN]
	inc $7CFE.w,X		; FE FE 7C ; Increment memory $7CFE.w,X [Reads: X Index] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F30.w		; 0E 30 1F ; Arithmetic shift left $1F30.w [Flags: ZNC]
	and [$1A.b],Y		; 37 1A ; AND accumulator with memory (long indexed) [$1A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $13BF3D.l,X		; 7F 3D BF 13 ; Add long $13BF3D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F1F.w		; 0E 1F 3F ; Arithmetic shift left $3F1F.w [Flags: ZNC]
	and $23FC7E.l,X		; 3F 7E FC 23 ; AND accumulator with memory (long,X) $23FC7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $0C		; 70 0C ; Branch if overflow set to $70, $0C [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx $FE58.w		; EC 58 FE ; Compare $FE58.w with X register [Reads: X Index] [Flags: ZNC]
	ldy $C8FD.w,X		; BC FD C8 ; Load Y register $C8FD.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	jsr ($7EFC.w,X)		; FC FC 7E ; Jump to subroutine indirect indexed ($7EFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $830023.l,X		; 3F 23 00 83 ; AND accumulator with memory (long,X) $830023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy $03.b		; C4 03 ; Compare $03.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	asl $FC.b		; 06 FC ; Arithmetic shift left $FC.b [Reads: Direct Page] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda [$6E.b],Y		; B7 6E ; Load accumulator (long indexed) [$6E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	stx $6D.b,Y		; 96 6D ; Store X register $6D.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sbc $03CF88.l,X		; FF 88 CF 03 ; Subtract with carry (long,X) $03CF88.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($04.b,S),Y		; 13 04 ; OR accumulator (stack relative indirect indexed) ($04.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	asl $ED.b		; 06 ED ; Arithmetic shift left $ED.b [Reads: Direct Page] [Flags: ZNC]
	ror $69.b,X		; 76 69 ; Rotate right $69.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldx $FF.b,Y		; B6 FF ; Load X register $FF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FF3F.w		; 0E 3F FF ; Arithmetic shift left $FF3F.w [Flags: ZNC]
	sbc $04837F.l,X		; FF 7F 83 04 ; Subtract with carry (long,X) $04837F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1F0046.l		; 0F 46 00 1F ; OR accumulator with memory (long) $1F0046.l [Writes: Accumulator] [Flags: ZN]
	ora $3E.b		; 05 3E ; Logical OR $3E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $031F22.l		; 0F 22 1F 03 ; OR accumulator with memory (long) $031F22.l [Writes: Accumulator] [Flags: ZN]
	and $A00000.l,X		; 3F 00 00 A0 ; AND accumulator with memory (long,X) $A00000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $6B.b,S		; 83 6B ; Store accumulator (stack relative) $6B.b,S [Reads: Accumulator, Stack Pointer]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	jsr $A000.w		; 20 00 A0 ; Jump to subroutine at $A000.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx $FEF6.w		; EC F6 FE ; Compare $FEF6.w with X register [Reads: X Index] [Flags: ZNC]
	sbc $0213DD.l		; EF DD 13 02 ; Subtract with carry (long) $0213DD.l [Writes: Accumulator] [Flags: ZVNC]
	ora $450E0E.l,X		; 1F 0E 0E 45 ; Logical OR long $450E0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $1D.b		; 02 1D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $000B01.l		; 22 01 0B 00 ; Jump to subroutine long $000B01.l [Writes: Stack Pointer] [Flow: call]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3FC0.w		; 0C C0 3F ; Test and set bits $3FC0.w [Reads: Accumulator] [Flags: Z]
	pea $7B0B.w		; F4 0B 7B ; Push absolute address $7B0B.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	stz $FB.b		; 64 FB ; Store zero to $FB.b
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sbc $F00910.l,X		; FF 10 09 F0 ; Subtract with carry (long,X) $F00910.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F4.b		; C0 F4 ; Compare #$F4.b with Y register [Reads: Y Index] [Flags: ZNC]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	wai		; CB ; Wait for interrupt
	sbc $45F0EF.l		; EF EF F0 45 ; Subtract with carry (long) $45F0EF.l [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7E00.w,X		; 3C 00 7E ; Test bits $7E00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $3C43.w,X		; 3C 43 3C ; Test bits $3C43.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $B8.b,S		; 83 B8 ; Store accumulator (stack relative) $B8.b,S [Reads: Accumulator, Stack Pointer]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	jsr $0B37.w		; 20 37 0B ; Jump to subroutine at $0B37.w [Writes: Stack Pointer] [Flow: call]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	ora $09.b,X		; 15 09 ; OR accumulator with memory $09.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0C1F00.l		; 0F 00 1F 0C ; OR accumulator with memory (long) $0C1F00.l [Writes: Accumulator] [Flags: ZN]
	ora $000F0F.l,X		; 1F 0F 0F 00 ; Logical OR long $000F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $16173F.l		; 2F 3F 17 16 ; AND accumulator with memory (long) $16173F.l [Writes: Accumulator] [Flags: ZN]
	ora $0F1013.l		; 0F 13 10 0F ; OR accumulator with memory (long) $0F1013.l [Writes: Accumulator] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $B0, $D8		; B0 D8 ; Branch if carry set to $B0, $D8 [Flow: branch]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	ldy #$F0.b		; A0 F0 ; Load #$F0.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $80, $A0		; 80 A0 ; Branch always to $80, $A0 [Flow: branch]
	eor $40.b,S		; 43 40 ; Exclusive OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$17.b		; E0 17 ; Compare #$17.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	ldy #$A0.b		; A0 A0 ; Load #$A0.b into Y register [Writes: Y Index] [Flags: ZN]
	jsr $39C0.w		; 20 C0 39 ; Jump to subroutine at $39C0.w [Writes: Stack Pointer] [Flow: call]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $6E.b		; 04 6E ; Test and set bits $6E.b [Reads: Accumulator] [Flags: Z]
	ora $237C.w		; 0D 7C 23 ; Logical OR $237C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	rol $0101.w,X		; 3E 01 01 ; Rotate left $0101.w,X [Reads: X Index] [Flags: ZNC]
	jsl $2F1F00.l		; 22 00 1F 2F ; Jump to subroutine long $2F1F00.l [Writes: Stack Pointer] [Flow: call]
	and $5C723B.l,X		; 3F 3B 72 5C ; AND accumulator with memory (long,X) $5C723B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $0001.w,X		; 3E 01 00 ; Rotate left $0001.w,X [Reads: X Index] [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $B0, $CC		; B0 CC ; Branch if carry set to $B0, $CC [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jmp ($F898.w,X)		; 7C 98 F8 ; Jump indirect indexed to ($F898.w,X) [Reads: X Index] [Flow: jump]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F8F8.w,X)		; FC F8 F8 ; Jump to subroutine indirect indexed ($F8F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $64.b		; 24 64 ; Test bits $64.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0800.w,X		; 3C 00 08 ; Test bits $0800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0C00.w		; 2C 00 0C ; Test bits $0C00.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sbc $7E6A.w,X		; FD 6A 7E ; Subtract with carry $7E6A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $225D.w,Y		; 19 5D 22 ; OR accumulator with memory $225D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $1C.b,S		; 63 1C ; Add with carry (stack relative) $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	ror $5C20.w,X		; 7E 20 5C ; Rotate right $5C20.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $9E1400.l		; 22 00 14 9E ; Jump to subroutine long $9E1400.l [Writes: Stack Pointer] [Flow: call]
	adc $5E635D.l,X		; 7F 5D 63 5E ; Add long $5E635D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	stz $38.b		; 64 38 ; Store zero to $38.b
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jmp ($BA98.w,X)		; 7C 98 BA ; Jump indirect indexed to ($BA98.w,X) [Reads: X Index] [Flow: jump]
	mvp $38,$C6		; 44 C6 38 ; Move block positive $38,$C6 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ror $3A04.w,X		; 7E 04 3A ; Rotate right $3A04.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $0022.w		; 1C 22 00 ; Test and reset bits $0022.w [Reads: Accumulator] [Flags: Z]
	cpx #$44.b		; E0 44 ; Compare #$44.b with X register [Reads: X Index] [Flags: ZNC]
	jmp ($BAFC.w,X)		; 7C FC BA ; Jump indirect indexed to ($BAFC.w,X) [Reads: X Index] [Flow: jump]
	dec $7A.b		; C6 7A ; Decrement $7A.b [Reads: Direct Page] [Flags: ZN]
	rol $1C.b		; 26 1C ; Rotate left $1C.b [Reads: Direct Page] [Flags: ZNC]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $58FA.w		; 0D FA 58 ; Logical OR $58FA.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc [$40.b],Y		; F7 40 ; Subtract with carry (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $003F00.l,X		; 7F 00 3F 00 ; Add long $003F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $0F02.w,X		; 3E 02 0F ; Rotate left $0F02.w,X [Reads: X Index] [Flags: ZNC]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$BF.b]		; A7 BF ; Load accumulator (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $0E3D3F.l,X		; 7F 3F 3D 0E ; Add long $0E3D3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $5F		; B0 5F ; Branch if carry set to $B0, $5F [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $00FE02.l		; EF 02 FE 00 ; Subtract with carry (long) $00FE02.l [Writes: Accumulator] [Flags: ZVNC]
	jsr ($7C00.w,X)		; FC 00 7C ; Jump to subroutine indirect indexed ($7C00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	eor $FEFDE5.l		; 4F E5 FD FE ; Exclusive OR accumulator with memory (long) $FEFDE5.l [Writes: Accumulator] [Flags: ZN]
	jsr ($70BC.w,X)		; FC BC 70 ; Jump to subroutine indirect indexed ($70BC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$9D.b		; C0 9D ; Compare #$9D.b with Y register [Reads: Y Index] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc $6D69.w,X		; FE 69 6D ; Increment memory $6D69.w,X [Reads: X Index] [Flags: ZN]
	ora ($31.b)		; 12 31 ; OR accumulator with memory (indirect) ($31.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $103F.w		; 0E 3F 10 ; Arithmetic shift left $103F.w [Flags: ZNC]
	rol $1C0C.w		; 2E 0C 1C ; Rotate left $1C0C.w [Flags: ZNC]
	jsl $FE1400.l		; 22 00 14 FE ; Jump to subroutine long $FE1400.l [Writes: Stack Pointer] [Flow: call]
	sta $2F316D.l,X		; 9F 6D 31 2F ; Store accumulator (long,X) $2F316D.l,X [Reads: Accumulator, X Index]
	and ($1C.b)		; 32 1C ; AND accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $7F		; 50 7F ; Branch if overflow clear to $50, $7F [Flow: branch]
	stx $B6.b,Y		; 96 B6 ; Store X register $B6.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sty $FC70.w		; 8C 70 FC ; Store Y register to $FC70.w [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $30.b,X		; 74 30 ; Store zero to $30.b,X [Reads: X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $7F0700.l		; 22 00 07 7F ; Jump to subroutine long $7F0700.l [Writes: Stack Pointer] [Flow: call]
	sbc $8CB6.w,Y		; F9 B6 8C ; Subtract with carry $8CB6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	pea $384C.w		; F4 4C 38 ; Push absolute address $384C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $1B02.w,X		; 3E 02 1B ; Rotate left $1B02.w,X [Reads: X Index] [Flags: ZNC]
	asl $3F02.w,X		; 1E 02 3F ; Arithmetic shift left $3F02.w,X [Reads: X Index] [Flags: ZNC]
	ora $77.b,S		; 03 77 ; OR accumulator with stack relative $77.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($63.b),Y		; 31 63 ; AND accumulator with memory ($63.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $1034.w		; 20 34 10 ; Jump to subroutine at $1034.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3C1D.w,X		; 3D 1D 3C ; AND accumulator with memory $3C1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lsr $2C5F.w		; 4E 5F 2C ; Logical shift right $2C5F.w [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $FA44.w,X		; FE 44 FA ; Increment memory $FA44.w,X [Reads: X Index] [Flags: ZN]
	cpy #$3A.b		; C0 3A ; Compare #$3A.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $101E.w		; 20 1E 10 ; Jump to subroutine at $101E.w [Writes: Stack Pointer] [Flow: call]
	sta [$F0.b]		; 87 F0 ; Store accumulator (long) [$F0.b] [Reads: Accumulator, Direct Page]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$2E.b		; A2 2E ; Load #$2E.b into X register [Writes: X Index] [Flags: ZN]
	dec $19EE.w		; CE EE 19 ; Decrement $19EE.w [Flags: ZN]
	sbc $0C1A.w,X		; FD 1A 0C ; Subtract with carry $0C1A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $6DD707.l,X		; FF 07 D7 6D ; Subtract with carry (long,X) $6DD707.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $5DA261.l,X		; 9F 61 A2 5D ; Store accumulator (long,X) $5DA261.l,X [Reads: Accumulator, X Index]
	cmp $3E.b,X		; D5 3E ; Compare accumulator $3E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $B6.b,S		; 43 B6 ; Exclusive OR accumulator with stack relative $B6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $7FD507.l,X		; 7F 07 D5 7F ; Add long $7FD507.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $5D.b,S		; E3 5D ; Subtract stack-relative $5D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	adc $41.b		; 65 41 ; Add $41.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	trb $223E.w		; 1C 3E 22 ; Test and reset bits $223E.w [Reads: Accumulator] [Flags: Z]
	adc $5D30E0.l,X		; 7F E0 30 5D ; Add long $5D30E0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ldx $F5.b,Y		; B6 F5 ; Load X register $F5.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	ldx $966B.w		; AE 6B 96 ; Load $966B.w into X register [Writes: X Index] [Flags: ZN]
	sta [$78.b],Y		; 97 78 ; Store accumulator (long indexed) [$78.b],Y [Reads: Accumulator, Direct Page, Y Index]
	ora [$FA.b],Y		; 17 FA ; OR accumulator with memory (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc #$F6.b		; 69 F6 ; Add #$F6.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	wai		; CB ; Wait for interrupt
	rol $FD.b,X		; 36 FD ; Rotate left $FD.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	lsr $A6.b,X		; 56 A6 ; Logical shift right $A6.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldx $02.b		; A6 02 ; Load $02.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	.db $10, $72		; 10 72 ; Branch if plus to $10, $72 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $54.b		; 06 54 ; Arithmetic shift left $54.b [Reads: Direct Page] [Flags: ZNC]
	sta ($60.b,S),Y		; 93 60 ; Store accumulator (stack relative indirect indexed) ($60.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	stx $E673.w		; 8E 73 E6 ; Store X register to $E673.w [Reads: X Index]
	eor $E26FD6.l,X		; 5F D6 6F E2 ; Exclusive OR accumulator with memory (long,X) $E26FD6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $3E1B65.l,X		; 3F 65 1B 3E ; AND accumulator with memory (long,X) $3E1B65.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora #$77.b		; 09 77 ; Logical OR #$77.b with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $3360.w		; 2C 60 33 ; Test bits $3360.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	eor [$4F.b],Y		; 57 4F ; Exclusive OR accumulator with memory (long indexed) [$4F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$03.b]		; 27 03 ; AND accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$24.b		; 09 24 ; Logical OR #$24.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3D051F.l,X		; 3F 1F 05 3D ; AND accumulator with memory (long,X) $3D051F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3F1F3B.l,X		; 1F 3B 1F 3F ; Logical OR long $3F1F3B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $240022.l,X		; 1F 22 00 24 ; Logical OR long $240022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $402CE0.l,X		; 1F E0 2C 40 ; Logical OR long $402CE0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$58.b		; A0 58 ; Load #$58.b into Y register [Writes: Y Index] [Flags: ZN]
	rol $23.b		; 26 23 ; Rotate left $23.b [Reads: Direct Page] [Flags: ZNC]
	ora ($1B.b),Y		; 11 1B ; OR accumulator with memory ($1B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $020000.l		; 0F 00 00 02 ; OR accumulator with memory (long) $020000.l [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $FD		; 30 FD ; Branch if minus to $30, $FD [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $FBEF79.l		; EF 79 EF FB ; Subtract with carry (long) $FBEF79.l [Writes: Accumulator] [Flags: ZVNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F5.b		; 05 F5 ; Logical OR $F5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $FF22.w,X		; FD 22 FF ; Subtract with carry $FF22.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $010F3F.l,X		; 7F 3F 0F 01 ; Add long $010F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $F76606.l,X		; FF 06 66 F7 ; Subtract with carry (long,X) $F76606.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $42, $FF		; 42 FF ; Reserved instruction
	ror $FF.b		; 66 FF ; Rotate right $FF.b [Reads: Direct Page] [Flags: ZNC]
	bit $FF45.w,X		; 3C 45 FF ; Test bits $FF45.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ror $BD.b		; 66 BD ; Rotate right $BD.b [Reads: Direct Page] [Flags: ZNC]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	mvp $10,$00		; 44 00 10 ; Move block positive $10,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $28.b,S		; 43 28 ; Exclusive OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsl $100100.l		; 22 00 01 10 ; Jump to subroutine long $100100.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	.db $30, $07		; 30 07 ; Branch if minus to $30, $07 [Flow: branch]
	.db $70, $08		; 70 08 ; Branch if overflow set to $70, $08 [Flow: branch]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7A,$00		; 44 00 7A ; Move block positive $7A,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $FD007D.l		; 0F 7D 00 FD ; OR accumulator with memory (long) $FD007D.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $3C3C.w		; 1C 3C 3C ; Test and reset bits $3C3C.w [Reads: Accumulator] [Flags: Z]
	rol $007E.w,X		; 3E 7E 00 ; Rotate left $007E.w,X [Reads: X Index] [Flags: ZNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $00013F.l		; 0F 3F 01 00 ; OR accumulator with memory (long) $00013F.l [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	and $3F.b		; 25 3F ; Logical AND $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpx #$27.b		; E0 27 ; Compare #$27.b with X register [Reads: X Index] [Flags: ZNC]
	jsr ($0022.w,X)		; FC 22 00 ; Jump to subroutine indirect indexed ($0022.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FC.b,S		; 23 FC ; AND accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $01.b		; 45 01 ; Exclusive OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2B.b,S		; 03 2B ; OR accumulator with stack relative $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $25		; 80 25 ; Branch always to $80, $25 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	eor [$31.b]		; 47 31 ; Exclusive OR accumulator with memory (long) [$31.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $1D2F1E.l		; 2F 1E 2F 1D ; AND accumulator with memory (long) $1D2F1E.l [Writes: Accumulator] [Flags: ZN]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $4C4700.l		; 22 00 47 4C ; Jump to subroutine long $4C4700.l [Writes: Stack Pointer] [Flow: call]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	sty $F8.b		; 84 F8 ; Store Y register to $F8.b [Reads: Y Index]
	pea $7478.w		; F4 78 74 ; Push absolute address $7478.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $F8.b		; 24 F8 ; Test bits $F8.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$31.b		; E0 31 ; Compare #$31.b with X register [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F7		; 80 F7 ; Branch always to $80, $F7 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	eor #$FE.b		; 49 FE ; Exclusive OR #$FE.b with accumulator [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	sbc $DC5E.w,X		; FD 5E DC ; Subtract with carry $DC5E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $BF.b,S		; 63 BF ; Add with carry (stack relative) $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc $FF7FC0.l,X		; 7F C0 7F FF ; Add long $FF7FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor #$2A.b		; 49 2A ; Exclusive OR #$2A.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jmp $7F7F40.l		; 5C 40 7F 7F ; Jump long to $7F7F40.l [Flow: jump]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor $1AEFE2.l,X		; 5F E2 EF 1A ; Exclusive OR accumulator with memory (long,X) $1AEFE2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$1A.b],Y		; F7 1A ; Subtract with carry (long indexed) [$1A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FEFDC2.l,X		; 3F C2 FD FE ; AND accumulator with memory (long,X) $FEFDC2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $425000.l,X		; FF 00 50 42 ; Subtract with carry (long,X) $425000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0024.w,X		; FE 24 00 ; Increment memory $0024.w,X [Reads: X Index] [Flags: ZN]
	jsl $0001FF.l		; 22 FF 01 00 ; Jump to subroutine long $0001FF.l [Writes: Stack Pointer] [Flow: call]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $010025.l,X		; FF 25 00 01 ; Subtract with carry (long,X) $010025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $B58300.l,X		; FF 00 83 B5 ; Subtract with carry (long,X) $B58300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $7F1F3F.l		; 0F 3F 1F 7F ; OR accumulator with memory (long) $7F1F3F.l [Writes: Accumulator] [Flags: ZN]
	and $007FF7.l,X		; 3F F7 7F 00 ; AND accumulator with memory (long,X) $007FF7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1F7F3F.l,X		; 1F 3F 7F 1F ; Logical OR long $1F7F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F0F1C.l		; 0F 1C 0F 0F ; OR accumulator with memory (long) $0F0F1C.l [Writes: Accumulator] [Flags: ZN]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F.b		; 05 3F ; Logical OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F0F13.l,X		; 1F 13 0F 3F ; Logical OR long $3F0F13.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor [$3F.b]		; 47 3F ; Exclusive OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $9DFB.w		; CE FB 9D ; Decrement $9DFB.w [Flags: ZN]
	sbc [$3F.b],Y		; F7 3F ; Subtract with carry (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	pea $EB7F.w		; F4 7F EB ; Push absolute address $EB7F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $6FFC97.l,X		; FF 97 FC 6F ; Subtract with carry (long,X) $6FFC97.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cmp $26DE79.l,X		; DF 79 DE 26 ; Compare accumulator (long,X) $26DE79.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $25FE00.l,X		; FF 00 FE 25 ; Subtract with carry (long,X) $25FE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00C000.l,X		; 3F 00 C0 00 ; AND accumulator with memory (long,X) $00C000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $9B83.w,X		; 3E 83 9B ; Rotate left $9B83.w,X [Reads: X Index] [Flags: ZNC]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $26010F.l,X		; 3F 0F 01 26 ; AND accumulator with memory (long,X) $26010F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3C7E00.l,X		; FF 00 7E 3C ; Subtract with carry (long,X) $3C7E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $C300.w,X		; 3D 00 C3 ; AND accumulator with memory $C300.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta $BC.b,S		; 83 BC ; Store accumulator (stack relative) $BC.b,S [Reads: Accumulator, Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $50.b,S		; 23 50 ; AND accumulator with stack relative $50.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7060.w,Y		; 19 60 70 ; OR accumulator with memory $7060.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $0EFF00.l,X		; FF 00 FF 0E ; Subtract with carry (long,X) $0EFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $10FF1A.l,X		; FF 1A FF 10 ; Subtract with carry (long,X) $10FF1A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $00FF0E.l,X		; FF 0E FF 00 ; Subtract with carry (long,X) $00FF0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $6E		; 70 6E ; Branch if overflow set to $70, $6E [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $50, $54		; 50 54 ; Branch if overflow clear to $50, $54 [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ror $4870.w		; 6E 70 48 ; Rotate right $4870.w [Flags: ZNC]
	ora $31013F.l		; 0F 3F 01 31 ; OR accumulator with memory (long) $31013F.l [Writes: Accumulator] [Flags: ZN]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $223100.l,X		; 3F 00 31 22 ; AND accumulator with memory (long,X) $223100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($3C04.w,X)		; FC 04 3C ; Jump to subroutine indirect indexed ($3C04.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($1C04.w,X)		; FC 04 1C ; Jump to subroutine indirect indexed ($1C04.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($3C02.w,X)		; FC 02 3C ; Jump to subroutine indirect indexed ($3C02.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	.db $80, $24		; 80 24 ; Branch always to $80, $24 [Flow: branch]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $011F1D.l		; 2F 1D 1F 01 ; AND accumulator with memory (long) $011F1D.l [Writes: Accumulator] [Flags: ZN]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $5FDF01.l,X		; 7F 01 DF 5F ; Add long $5FDF01.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $40DF00.l,X		; BF 00 DF 40 ; Load long $40DF00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $130024.l,X		; 7F 24 00 13 ; Add long $130024.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr $3F7F.w		; 20 7F 3F ; Jump to subroutine at $3F7F.w [Writes: Stack Pointer] [Flow: call]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sbc $FB00.w,X		; FD 00 FB ; Subtract with carry $FB00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	and ($04.b)		; 32 04 ; AND accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	inc $00FC.w,X		; FE FC 00 ; Increment memory $00FC.w,X [Reads: X Index] [Flags: ZN]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: ZN]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3C7FBF.l,X		; DF BF 7F 3C ; Compare accumulator (long,X) $3C7FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	bit $7E42.w,X		; 3C 42 7E ; Test bits $7E42.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lda $BDC3.w,X		; BD C3 BD ; Load $BDC3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$BD.b]		; E7 BD ; Subtract with carry (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $5B.b,S		; C3 5B ; Compare accumulator (stack relative) $5B.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	adc [$7E.b]		; 67 7E ; Add with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $C37E.w,X		; 3C 7E C3 ; Test bits $C37E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc [$5A.b]		; 67 5A ; Add with carry (long) [$5A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $50, $24		; 50 24 ; Branch if overflow clear to $50, $24 [Flow: branch]
	sbc $E05A27.l,X		; FF 27 5A E0 ; Subtract with carry (long,X) $E05A27.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $762C.w		; 2C 2C 76 ; Test bits $762C.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	lsr $A3.b		; 46 A3 ; Logical shift right $A3.b [Reads: Direct Page] [Flags: ZNC]
	sta $C7.b,S		; 83 C7 ; Store accumulator (stack relative) $C7.b,S [Reads: Accumulator, Stack Pointer]
	cmp [$6E.b]		; C7 6E ; Compare accumulator (long) [$6E.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	ror $3C3C.w		; 6E 3C 3C ; Rotate right $3C3C.w [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp $001038.l		; 5C 38 10 00 ; Jump long to $001038.l [Flow: jump]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $081F.w		; 0C 1F 08 ; Test and set bits $081F.w [Reads: Accumulator] [Flags: Z]
	and ($10.b)		; 32 10 ; AND accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sta $C6.b,S		; 83 C6 ; Store accumulator (stack relative) $C6.b,S [Reads: Accumulator, Stack Pointer]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0B0F.w		; 0D 0F 0B ; Logical OR $0B0F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $C0.b		; 45 C0 ; Exclusive OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$38.b		; C0 38 ; Compare #$38.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $1018.w		; 20 18 10 ; Jump to subroutine at $1018.w [Writes: Stack Pointer] [Flow: call]
	trb $3C10.w		; 1C 10 3C ; Test and reset bits $3C10.w [Reads: Accumulator] [Flags: Z]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	jsr $B0BE.w		; 20 BE B0 ; Jump to subroutine at $B0BE.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$42.b		; C0 42 ; Compare #$42.b with Y register [Reads: Y Index] [Flags: ZNC]
	cmp [$82.b]		; C7 82 ; Compare accumulator (long) [$82.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	lda $4342.w,X		; BD 42 43 ; Load $4342.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $3FC013.l,X		; 3F 13 C0 3F ; AND accumulator with memory (long,X) $3FC013.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	sbc $1F.b,S		; E3 1F ; Subtract stack-relative $1F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp $3F.b,S		; C3 3F ; Compare accumulator (stack relative) $3F.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	.db $82, $42, $22		; 82 42 22 ; Branch always long to $82, $42, $22 [Flow: branch]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc [$07.b],Y		; F7 07 ; Subtract with carry (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$E3.b]		; 07 E3 ; OR accumulator with memory (long) [$E3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($BD.b,X)		; 41 BD ; Exclusive OR accumulator with memory ($BD.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $42, $43		; 42 43 ; Reserved instruction
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jsr ($FF01.w,X)		; FC 01 FF ; Jump to subroutine indirect indexed ($FF01.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp [$F8.b]		; C7 F8 ; Compare accumulator (long) [$F8.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	cmp $FC.b,S		; C3 FC ; Compare accumulator (stack relative) $FC.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	eor ($42.b,X)		; 41 42 ; Exclusive OR accumulator with memory ($42.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $00,$48		; 44 48 00 ; Move block positive $00,$48 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sbc $0FE0E0.l		; EF E0 E0 0F ; Subtract with carry (long) $0FE0E0.l [Writes: Accumulator] [Flags: ZVNC]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F1F38.l		; 0F 38 1F 3F ; OR accumulator with memory (long) $3F1F38.l [Writes: Accumulator] [Flags: ZN]
	sta $C3.b,S		; 83 C3 ; Store accumulator (stack relative) $C3.b,S [Reads: Accumulator, Stack Pointer]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F1E3F.l		; 0F 3F 1E 3F ; OR accumulator with memory (long) $3F1E3F.l [Writes: Accumulator] [Flags: ZN]
	tsb $1F0F.w		; 0C 0F 1F ; Test and set bits $1F0F.w [Reads: Accumulator] [Flags: Z]
	and $3F.b		; 25 3F ; Logical AND $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$F0.b],Y		; 17 F0 ; OR accumulator with memory (long indexed) [$F0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $1C		; F0 1C ; Branch if equal to $F0, $1C [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	jsr ($3CF8.w,X)		; FC F8 3C ; Jump to subroutine indirect indexed ($3CF8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jmp.w [$ECE8]		; DC E8 EC ; Jump long indirect [$ECE8] [Flow: jump]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx $F038.w		; EC 38 F0 ; Compare $F038.w with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx $CCFC.w		; EC FC CC ; Compare $CCFC.w with X register [Reads: X Index] [Flags: ZNC]
	cpx $FCFC.w		; EC FC FC ; Compare $FCFC.w with X register [Reads: X Index] [Flags: ZNC]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$03.b]		; 47 03 ; Exclusive OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $000022.l		; 0F 22 00 00 ; OR accumulator with memory (long) $000022.l [Writes: Accumulator] [Flags: ZN]
	tsb $0F23.w		; 0C 23 0F ; Test and set bits $0F23.w [Reads: Accumulator] [Flags: Z]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $C0.b		; 05 C0 ; Logical OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $25		; F0 25 ; Branch if equal to $F0, $25 [Flow: branch]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00220F.l,X		; 1F 0F 22 00 ; Logical OR long $00220F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $83		; 10 83 ; Branch if plus to $10, $83 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F3F43B.l,X		; FF 3B F4 F3 ; Subtract with carry (long,X) $F3F43B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$F0.b],Y		; F7 F0 ; Subtract with carry (long indexed) [$F0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $43.b		; E4 43 ; Compare $43.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $E7.b,S		; E3 E7 ; Subtract stack-relative $E7.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	ora $E0.b		; 05 E0 ; Logical OR $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$0F.b]		; C7 0F ; Compare accumulator (long) [$0F.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tsb $1F22.w		; 0C 22 1F ; Test and set bits $1F22.w [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc $803F44.l,X		; FF 44 3F 80 ; Subtract with carry (long,X) $803F44.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($BF.b)		; 12 BF ; OR accumulator with memory (indirect) ($BF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $21A1A7.l,X		; 3F A7 A1 21 ; AND accumulator with memory (long,X) $21A1A7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lsr $E1C0.w,X		; 5E C0 E1 ; Logical shift right $E1C0.w,X [Reads: X Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	adc $48407F.l,X		; 7F 7F 40 48 ; Add long $48407F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lsr $0021.w,X		; 5E 21 00 ; Logical shift right $0021.w,X [Reads: X Index] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $00,$FD		; 44 FD 00 ; Move block positive $00,$FD [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $E4FDFC.l		; 0F FC FD E4 ; OR accumulator with memory (long) $E4FDFC.l [Writes: Accumulator] [Flags: ZN]
	sta $84.b		; 85 84 ; Store accumulator to $84.b [Reads: Accumulator]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $87.b		; 02 87 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $02FE.w,X		; FE FE 02 ; Increment memory $02FE.w,X [Reads: X Index] [Flags: ZN]
	ora ($7A.b)		; 12 7A ; OR accumulator with memory (indirect) ($7A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $98.b		; 84 98 ; Store Y register to $98.b [Reads: Y Index]
	sbc $FF4802.l,X		; FF 02 48 FF ; Subtract with carry (long,X) $FF4802.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $18FF.w,X		; 3C FF 18 ; Test bits $18FF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ror $3C00.w,X		; 7E 00 3C ; Rotate right $3C00.w,X [Reads: X Index] [Flags: ZNC]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $42, $66		; 42 66 ; Reserved instruction
	bit $3800.w,X		; 3C 00 38 ; Test bits $3800.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $82, $7C, $E6		; 82 7C E6 ; Branch always long to $82, $7C, $E6 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $2C7E66.l,X		; FF 66 7E 2C ; Subtract with carry (long,X) $2C7E66.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $1808.w,X		; 3C 08 18 ; Test bits $1808.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($6618.w,X)		; 7C 18 66 ; Jump indirect indexed to ($6618.w,X) [Reads: X Index] [Flow: jump]
	bit $0008.w		; 2C 08 00 ; Test bits $0008.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	lsr $2C34.w		; 4E 34 2C ; Logical shift right $2C34.w [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $33E0.w		; 2C E0 33 ; Test bits $33E0.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sbc $4CBF0F.l,X		; FF 0F BF 4C ; Subtract with carry (long,X) $4CBF0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $007F30.l		; 6F 30 7F 00 ; Add with carry (long) $007F30.l [Writes: Accumulator] [Flags: ZVNC]
	ror $3F0D.w,X		; 7E 0D 3F ; Rotate right $3F0D.w,X [Reads: X Index] [Flags: ZNC]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $A0000F.l		; 0F 0F 00 A0 ; OR accumulator with memory (long) $A0000F.l [Writes: Accumulator] [Flags: ZN]
	cmp ($7B.b),Y		; D1 7B ; Compare accumulator ($7B.b),Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	ror $2F53.w,X		; 7E 53 2F ; Rotate right $2F53.w,X [Reads: X Index] [Flags: ZNC]
	ora $E0FF0F.l,X		; 1F 0F FF E0 ; Logical OR long $E0FF0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F602.w,X		; FD 02 F6 ; Subtract with carry $F602.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $00FE.w		; 0C FE 00 ; Test and set bits $00FE.w [Reads: Accumulator] [Flags: Z]
	ror $FCB0.w,X		; 7E B0 FC ; Rotate right $FCB0.w,X [Reads: X Index] [Flags: ZNC]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	dec $CA7E.w,X		; DE 7E CA ; Decrement memory $CA7E.w,X [Reads: X Index] [Flags: ZN]
	pea $F0C8.w		; F4 C8 F0 ; Push absolute address $F0C8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sta $FF.b,S		; 83 FF ; Store accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	eor $40.b		; 45 40 ; Exclusive OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $5FA011.l,X		; 3F 11 A0 5F ; AND accumulator with memory (long,X) $5FA011.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $8782.w,X		; FD 82 87 ; Subtract with carry $8782.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $F7.b		; 02 F7 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	.db $42, $82		; 42 82 ; Reserved instruction
	cop $C1.b		; 02 C1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $45F807.l,X		; FF 07 F8 45 ; Subtract with carry (long,X) $45F807.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FA05.w,X		; 1D 05 FA ; OR accumulator with memory $FA05.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $40E141.l,X		; BF 41 E1 40 ; Load long $40E141.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $0800E0.l		; EF E0 00 08 ; Subtract with carry (long) $0800E0.l [Writes: Accumulator] [Flags: ZVNC]
	mvp $41,$42		; 44 42 41 ; Move block positive $41,$42 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $0E3D1C.l,X		; 3F 1C 3D 0E ; AND accumulator with memory (long,X) $0E3D1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $0E3F1E.l,X		; 3F 1E 3F 0E ; AND accumulator with memory (long,X) $0E3F1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $0F3E1E.l,X		; 3F 1E 3E 0F ; AND accumulator with memory (long,X) $0F3E1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000F0F.l,X		; 1F 0F 0F 00 ; Logical OR long $000F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $3F.b		; 25 3F ; Logical AND $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	ora $AC38EC.l		; 0F EC 38 AC ; OR accumulator with memory (long) $AC38EC.l [Writes: Accumulator] [Flags: ZN]
	lsr $78.b		; 46 78 ; Logical shift right $78.b [Reads: Direct Page] [Flags: ZNC]
	cpx $6C05.w		; EC 05 6C ; Compare $6C05.w with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F801.w,X)		; FC 01 F8 ; Jump to subroutine indirect indexed ($F801.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $46		; F0 46 ; Branch if equal to $F0, $46 [Flow: branch]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $230D00.l		; 0F 00 0D 23 ; OR accumulator with memory (long) $230D00.l [Writes: Accumulator] [Flags: ZN]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	jsl $F02400.l		; 22 00 24 F0 ; Jump to subroutine long $F02400.l [Writes: Stack Pointer] [Flow: call]
	cop $30.b		; 02 30 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F7F07.l,X		; 1F 07 7F 3F ; Logical OR long $3F7F07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sec		; 38 ; Set carry flag [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $007F.w		; 20 7F 00 ; Jump to subroutine at $007F.w [Writes: Stack Pointer] [Flow: call]
	eor $6B.b,S		; 43 6B ; Exclusive OR accumulator with stack relative $6B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol $07.b,X		; 36 07 ; Rotate left $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jsr $4020.w		; 20 20 40 ; Jump to subroutine at $4020.w [Writes: Stack Pointer] [Flow: call]
	eor [$5F.b]		; 47 5F ; Exclusive OR accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $457777.l,X		; 7F 77 77 45 ; Add long $457777.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $E0.b		; E4 E0 ; Compare $E0.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	ora #$16.b		; 09 16 ; Logical OR #$16.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $1A03.w,X		; FD 03 1A ; Subtract with carry $1A03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $060D.w		; 0D 0D 06 ; Logical OR $060D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	jsl $EE041C.l		; 22 1C 04 EE ; Jump to subroutine long $EE041C.l [Writes: Stack Pointer] [Flow: call]
	sbc [$FB.b],Y		; F7 FB ; Subtract with carry (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $440E.w,X		; 1D 0E 44 ; OR accumulator with memory $440E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $6DD707.l,X		; FF 07 D7 6D ; Subtract with carry (long,X) $6DD707.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $5DA261.l,X		; 9F 61 A2 5D ; Store accumulator (long,X) $5DA261.l,X [Reads: Accumulator, X Index]
	cmp $3E.b,X		; D5 3E ; Compare accumulator $3E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $B6.b,S		; 43 B6 ; Exclusive OR accumulator with stack relative $B6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $7FD507.l,X		; 7F 07 D5 7F ; Add long $7FD507.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $5D.b,S		; E3 5D ; Subtract stack-relative $5D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	adc $41.b		; 65 41 ; Add $41.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	trb $223E.w		; 1C 3E 22 ; Test and reset bits $223E.w [Reads: Accumulator] [Flags: Z]
	adc $5D30E0.l,X		; 7F E0 30 5D ; Add long $5D30E0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ldx $F5.b,Y		; B6 F5 ; Load X register $F5.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	ldx $966B.w		; AE 6B 96 ; Load $966B.w into X register [Writes: X Index] [Flags: ZN]
	sta [$78.b],Y		; 97 78 ; Store accumulator (long indexed) [$78.b],Y [Reads: Accumulator, Direct Page, Y Index]
	ora [$FA.b],Y		; 17 FA ; OR accumulator with memory (long indexed) [$FA.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc #$F6.b		; 69 F6 ; Add #$F6.b to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	wai		; CB ; Wait for interrupt
	rol $FD.b,X		; 36 FD ; Rotate left $FD.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	lsr $A6.b,X		; 56 A6 ; Logical shift right $A6.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ldx $02.b		; A6 02 ; Load $02.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	.db $10, $72		; 10 72 ; Branch if plus to $10, $72 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $54.b		; 06 54 ; Arithmetic shift left $54.b [Reads: Direct Page] [Flags: ZNC]
	sta ($60.b,S),Y		; 93 60 ; Store accumulator (stack relative indirect indexed) ($60.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	stx $E673.w		; 8E 73 E6 ; Store X register to $E673.w [Reads: X Index]
	eor $E26FD6.l,X		; 5F D6 6F E2 ; Exclusive OR accumulator with memory (long,X) $E26FD6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $3E1B65.l,X		; 3F 65 1B 3E ; AND accumulator with memory (long,X) $3E1B65.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora #$77.b		; 09 77 ; Logical OR #$77.b with accumulator [Writes: Accumulator] [Flags: ZN]
	bit $3360.w		; 2C 60 33 ; Test bits $3360.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	eor [$4F.b],Y		; 57 4F ; Exclusive OR accumulator with memory (long indexed) [$4F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$03.b]		; 27 03 ; AND accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$24.b		; 09 24 ; Logical OR #$24.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3D051F.l,X		; 3F 1F 05 3D ; AND accumulator with memory (long,X) $3D051F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $3F1F3B.l,X		; 1F 3B 1F 3F ; Logical OR long $3F1F3B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $240022.l,X		; 1F 22 00 24 ; Logical OR long $240022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $402CE0.l,X		; 1F E0 2C 40 ; Logical OR long $402CE0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$58.b		; A0 58 ; Load #$58.b into Y register [Writes: Y Index] [Flags: ZN]
	rol $23.b		; 26 23 ; Rotate left $23.b [Reads: Direct Page] [Flags: ZNC]
	ora ($1B.b),Y		; 11 1B ; OR accumulator with memory ($1B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $020000.l		; 0F 00 00 02 ; OR accumulator with memory (long) $020000.l [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $FD		; 30 FD ; Branch if minus to $30, $FD [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $FBEF79.l		; EF 79 EF FB ; Subtract with carry (long) $FBEF79.l [Writes: Accumulator] [Flags: ZVNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F5.b		; 05 F5 ; Logical OR $F5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $FF22.w,X		; FD 22 FF ; Subtract with carry $FF22.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $010F3F.l,X		; 7F 3F 0F 01 ; Add long $010F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $F76606.l,X		; FF 06 66 F7 ; Subtract with carry (long,X) $F76606.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $42, $FF		; 42 FF ; Reserved instruction
	ror $FF.b		; 66 FF ; Rotate right $FF.b [Reads: Direct Page] [Flags: ZNC]
	bit $FF45.w,X		; 3C 45 FF ; Test bits $FF45.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ror $BD.b		; 66 BD ; Rotate right $BD.b [Reads: Direct Page] [Flags: ZNC]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	mvp $10,$00		; 44 00 10 ; Move block positive $10,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $28.b,S		; 43 28 ; Exclusive OR accumulator with stack relative $28.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	jsl $100100.l		; 22 00 01 10 ; Jump to subroutine long $100100.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	.db $30, $07		; 30 07 ; Branch if minus to $30, $07 [Flow: branch]
	.db $70, $08		; 70 08 ; Branch if overflow set to $70, $08 [Flow: branch]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7A,$00		; 44 00 7A ; Move block positive $7A,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $7D.b,X		; 15 7D ; OR accumulator with memory $7D.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $3C3C.w		; 1C 3C 3C ; Test and reset bits $3C3C.w [Reads: Accumulator] [Flags: Z]
	rol $7F7E.w,X		; 3E 7E 7F ; Rotate left $7F7E.w,X [Reads: X Index] [Flags: ZNC]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $70, $D7		; 70 D7 ; Branch if overflow set to $70, $D7 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $08,$EF		; 44 EF 08 ; Move block positive $08,$EF [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $49.b		; 05 49 ; Logical OR $49.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22270F.l,X		; 1F 0F 27 22 ; Logical OR long $22270F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $06.b		; 14 06 ; Test and reset bits $06.b [Reads: Accumulator] [Flags: Z]
	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: ZN]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc ($03.b),Y		; F1 03 ; Subtract with carry ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $71		; 80 71 ; Branch always to $80, $71 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $1E02.w,X		; FE 02 1E ; Increment memory $1E02.w,X [Reads: X Index] [Flags: ZN]
	asl $839E.w,X		; 1E 9E 83 ; Arithmetic shift left $839E.w,X [Reads: X Index] [Flags: ZNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $DF2F.w		; 6E 2F DF ; Rotate right $DF2F.w [Flags: ZNC]
	eor ($D0.b,X)		; 41 D0 ; Exclusive OR accumulator with memory ($D0.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($7E.b,X)		; 41 7E ; Exclusive OR accumulator with memory ($7E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00243F.l,X		; 3F 3F 24 00 ; AND accumulator with memory (long,X) $00243F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $243E.w,X		; 3E 3E 24 ; Rotate left $243E.w,X [Reads: X Index] [Flags: ZNC]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0600.w,X)		; FC 00 06 ; Jump to subroutine indirect indexed ($0600.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $86.b		; 04 86 ; Test and set bits $86.b [Reads: Accumulator] [Flags: Z]
	sty $F2.b		; 84 F2 ; Store Y register to $F2.b [Reads: Y Index]
	jsr ($24FC.w,X)		; FC FC 24 ; Jump to subroutine indirect indexed ($24FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $0B0500.l		; 22 00 05 0B ; Jump to subroutine long $0B0500.l [Writes: Stack Pointer] [Flow: call]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$85.b]		; 07 85 ; OR accumulator with memory (long) [$85.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $50, $01		; 50 01 ; Branch if overflow clear to $50, $01 [Flow: branch]
	sta $50.b,S		; 83 50 ; Store accumulator (stack relative) $50.b,S [Reads: Accumulator, Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $62.b,S		; 03 62 ; OR accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($62.b,X)		; 01 62 ; Logical OR ($62.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($D0.b,X)		; 01 D0 ; Logical OR ($D0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cpx #$90.b		; E0 90 ; Compare #$90.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$50.b		; E0 50 ; Compare #$50.b with X register [Reads: X Index] [Flags: ZNC]
	cpx #$85.b		; E0 85 ; Compare #$85.b with X register [Reads: X Index] [Flags: ZNC]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rol $C0.b,X		; 36 C0 ; Rotate left $C0.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: ZNC]
	sbc [$49.b],Y		; F7 49 ; Subtract with carry (long indexed) [$49.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $2BFE49.l,X		; FF 49 FE 2B ; Subtract with carry (long,X) $2BFE49.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $DC5E.w,X		; FD 5E DC ; Subtract with carry $DC5E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $BF.b,S		; 63 BF ; Add with carry (stack relative) $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc $FF7FC0.l,X		; 7F C0 7F FF ; Add long $FF7FC0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor #$2A.b		; 49 2A ; Exclusive OR #$2A.b with accumulator [Writes: Accumulator] [Flags: ZN]
	jmp $7F7F40.l		; 5C 40 7F 7F ; Jump long to $7F7F40.l [Flow: jump]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	eor $1AEFE2.l,X		; 5F E2 EF 1A ; Exclusive OR accumulator with memory (long,X) $1AEFE2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$1A.b],Y		; F7 1A ; Subtract with carry (long indexed) [$1A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FEFDC2.l,X		; 3F C2 FD FE ; AND accumulator with memory (long,X) $FEFDC2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc $425000.l,X		; FF 00 50 42 ; Subtract with carry (long,X) $425000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0024.w,X		; FE 24 00 ; Increment memory $0024.w,X [Reads: X Index] [Flags: ZN]
	jsl $0001FF.l		; 22 FF 01 00 ; Jump to subroutine long $0001FF.l [Writes: Stack Pointer] [Flow: call]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $010025.l,X		; FF 25 00 01 ; Subtract with carry (long,X) $010025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $B58300.l,X		; FF 00 83 B5 ; Subtract with carry (long,X) $B58300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $7F1F3F.l		; 0F 3F 1F 7F ; OR accumulator with memory (long) $7F1F3F.l [Writes: Accumulator] [Flags: ZN]
	and $007FF7.l,X		; 3F F7 7F 00 ; AND accumulator with memory (long,X) $007FF7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1F7F3F.l,X		; 1F 3F 7F 1F ; Logical OR long $1F7F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F0F1C.l		; 0F 1C 0F 0F ; OR accumulator with memory (long) $0F0F1C.l [Writes: Accumulator] [Flags: ZN]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F.b		; 05 3F ; Logical OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3F0F13.l,X		; 1F 13 0F 3F ; Logical OR long $3F0F13.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor [$3F.b]		; 47 3F ; Exclusive OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $9DFB.w		; CE FB 9D ; Decrement $9DFB.w [Flags: ZN]
	sbc [$3F.b],Y		; F7 3F ; Subtract with carry (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	pea $EB7F.w		; F4 7F EB ; Push absolute address $EB7F.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $6FFC97.l,X		; FF 97 FC 6F ; Subtract with carry (long,X) $6FFC97.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cmp $26DE79.l,X		; DF 79 DE 26 ; Compare accumulator (long,X) $26DE79.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc $25FE00.l,X		; FF 00 FE 25 ; Subtract with carry (long,X) $25FE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00C000.l,X		; 3F 00 C0 00 ; AND accumulator with memory (long,X) $00C000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $9B83.w,X		; 3E 83 9B ; Rotate left $9B83.w,X [Reads: X Index] [Flags: ZNC]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $26010F.l,X		; 3F 0F 01 26 ; AND accumulator with memory (long,X) $26010F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3C7E00.l,X		; FF 00 7E 3C ; Subtract with carry (long,X) $3C7E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $C300.w,X		; 3D 00 C3 ; AND accumulator with memory $C300.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta $BC.b,S		; 83 BC ; Store accumulator (stack relative) $BC.b,S [Reads: Accumulator, Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $50.b,S		; 23 50 ; AND accumulator with stack relative $50.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7060.w,Y		; 19 60 70 ; OR accumulator with memory $7060.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $0EFF00.l,X		; FF 00 FF 0E ; Subtract with carry (long,X) $0EFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $10FF1A.l,X		; FF 1A FF 10 ; Subtract with carry (long,X) $10FF1A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc $00FF0E.l,X		; FF 0E FF 00 ; Subtract with carry (long,X) $00FF0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $6E		; 70 6E ; Branch if overflow set to $70, $6E [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $50, $54		; 50 54 ; Branch if overflow clear to $50, $54 [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ror DMAP7.w		; 6E 70 43 ; Rotate right DMAP7.w [Flags: ZNC]
	sbc $971648.l		; EF 48 16 97 ; Subtract with carry (long) $971648.l [Writes: Accumulator] [Flags: ZVNC]
	bit $AB.b		; 24 AB ; Test bits $AB.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and ($54.b,S),Y		; 33 54 ; AND accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	tsb $0313.w		; 0C 13 03 ; Test and set bits $0313.w [Reads: Accumulator] [Flags: Z]
	ora $121400.l		; 0F 00 14 12 ; OR accumulator with memory (long) $121400.l [Writes: Accumulator] [Flags: ZN]
	eor #$44.b		; 49 44 ; Exclusive OR #$44.b with accumulator [Writes: Accumulator] [Flags: ZN]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $F100.w		; 0C 00 F1 ; Test and set bits $F100.w [Reads: Accumulator] [Flags: Z]
	.db $80, $F1		; 80 F1 ; Branch always to $80, $F1 [Flow: branch]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc ($12.b,X)		; E1 12 ; Subtract with carry ($12.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $31		; F0 31 ; Branch if equal to $F0, $31 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp $ED1C.w,Y		; D9 1C ED ; Compare accumulator $ED1C.w,Y [Reads: Y Index] [Flags: ZNC]
	stx $00FE.w		; 8E FE 00 ; Store X register to $00FE.w [Reads: X Index]
	asl $FE1E.w,X		; 1E 1E FE ; Arithmetic shift left $FE1E.w,X [Reads: X Index] [Flags: ZNC]
	asl $22C6.w		; 0E C6 22 ; Arithmetic shift left $22C6.w [Flags: ZNC]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	eor ($3C.b)		; 52 3C ; Exclusive OR accumulator with memory (indirect) ($3C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $76.b		; 45 76 ; Exclusive OR $76.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $08.b		; 24 08 ; Test bits $08.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	lsr $6604.w,X		; 5E 04 66 ; Logical shift right $6604.w,X [Reads: X Index] [Flags: ZNC]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $380118.l		; 22 18 01 38 ; Jump to subroutine long $380118.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $3C.b		; 04 3C ; Test and set bits $3C.b [Reads: Accumulator] [Flags: Z]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $4652.w		; 1C 52 46 ; Test and reset bits $4652.w [Reads: Accumulator] [Flags: Z]
	tsb $56.b		; 04 56 ; Test and set bits $56.b [Reads: Accumulator] [Flags: Z]
	ora ($5E.b,X)		; 01 5E ; Logical OR ($5E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $0022.w		; 0C 22 00 ; Test and set bits $0022.w [Reads: Accumulator] [Flags: Z]
	and $38.b,S		; 23 38 ; AND accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$54.b		; 89 54 ; Test bits #$54.b with accumulator [Reads: Accumulator] [Flags: Z]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $62.b,S		; 03 62 ; OR accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($0501.w)		; 6C 01 05 ; Jump indirect to ($0501.w) [Flow: jump]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	jsr $C0C0.w		; 20 C0 C0 ; Jump to subroutine at $C0C0.w [Writes: Stack Pointer] [Flow: call]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FBBFFD.l,X		; 7F FD BF FB ; Add long $FBBFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: ZN]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $3C7FBF.l,X		; DF BF 7F 3C ; Compare accumulator (long,X) $3C7FBF.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	bit $7E42.w,X		; 3C 42 7E ; Test bits $7E42.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	lda $BDC3.w,X		; BD C3 BD ; Load $BDC3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$BD.b]		; E7 BD ; Subtract with carry (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp $5B.b,S		; C3 5B ; Compare accumulator (stack relative) $5B.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	adc [$7E.b]		; 67 7E ; Add with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $C37E.w,X		; 3C 7E C3 ; Test bits $C37E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc [$5A.b]		; 67 5A ; Add with carry (long) [$5A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	bit $25.b		; 24 25 ; Test bits $25.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1408.w		; 1C 08 14 ; Test and reset bits $1408.w [Reads: Accumulator] [Flags: Z]
	trb $1C.b		; 14 1C ; Test and reset bits $1C.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $180C00.l		; 22 00 0C 18 ; Jump to subroutine long $180C00.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $762C.w		; 2C 2C 76 ; Test bits $762C.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	lsr $A3.b		; 46 A3 ; Logical shift right $A3.b [Reads: Direct Page] [Flags: ZNC]
	sta $C7.b,S		; 83 C7 ; Store accumulator (stack relative) $C7.b,S [Reads: Accumulator, Stack Pointer]
	cmp [$6E.b]		; C7 6E ; Compare accumulator (long) [$6E.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	ror $833C.w		; 6E 3C 83 ; Rotate right $833C.w [Flags: ZNC]
	ldy $1602.w		; AC 02 16 ; Load $1602.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	jmp $001038.l		; 5C 38 10 00 ; Jump long to $001038.l [Flow: jump]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $081F.w		; 0C 1F 08 ; Test and set bits $081F.w [Reads: Accumulator] [Flags: Z]
	and ($10.b)		; 32 10 ; AND accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sta $C6.b,S		; 83 C6 ; Store accumulator (stack relative) $C6.b,S [Reads: Accumulator, Stack Pointer]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $0B0F.w		; 0D 0F 0B ; Logical OR $0B0F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $C0.b		; 45 C0 ; Exclusive OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$38.b		; C0 38 ; Compare #$38.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $1018.w		; 20 18 10 ; Jump to subroutine at $1018.w [Writes: Stack Pointer] [Flow: call]
	trb $3C10.w		; 1C 10 3C ; Test and reset bits $3C10.w [Reads: Accumulator] [Flags: Z]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	jsr $B0BE.w		; 20 BE B0 ; Jump to subroutine at $B0BE.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	cpy #$42.b		; C0 42 ; Compare #$42.b with Y register [Reads: Y Index] [Flags: ZNC]
	cmp [$82.b]		; C7 82 ; Compare accumulator (long) [$82.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	lda $4342.w,X		; BD 42 43 ; Load $4342.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $3FC013.l,X		; 3F 13 C0 3F ; AND accumulator with memory (long,X) $3FC013.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	sbc $1F.b,S		; E3 1F ; Subtract stack-relative $1F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	cmp $3F.b,S		; C3 3F ; Compare accumulator (stack relative) $3F.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	.db $82, $42, $22		; 82 42 22 ; Branch always long to $82, $42, $22 [Flow: branch]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc [$07.b],Y		; F7 07 ; Subtract with carry (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$E3.b]		; 07 E3 ; OR accumulator with memory (long) [$E3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor ($BD.b,X)		; 41 BD ; Exclusive OR accumulator with memory ($BD.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $42, $43		; 42 43 ; Reserved instruction
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01FC03.l		; 0F 03 FC 01 ; OR accumulator with memory (long) $01FC03.l [Writes: Accumulator] [Flags: ZN]
	sbc $C3F8C7.l,X		; FF C7 F8 C3 ; Subtract with carry (long,X) $C3F8C7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($4241.w,X)		; FC 41 42 ; Jump to subroutine indirect indexed ($4241.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	mvp $00,$48		; 44 48 00 ; Move block positive $00,$48 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sbc $E4E0E0.l		; EF E0 E0 E4 ; Subtract with carry (long) $E4E0E0.l [Writes: Accumulator] [Flags: ZVNC]
	and $0500.w,Y		; 39 00 05 ; AND accumulator with memory $0500.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$70.b		; 09 70 ; Logical OR #$70.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$4C.b		; A0 4C ; Load #$4C.b into Y register [Writes: Y Index] [Flags: ZN]
	.db $10, $A8		; 10 A8 ; Branch if plus to $10, $A8 [Flow: branch]
	.db $30, $24		; 30 24 ; Branch if minus to $30, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: ZNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta [$C8.b]		; 87 C8 ; Store accumulator (long) [$C8.b] [Reads: Accumulator, Direct Page]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $00220F.l,X		; 1F 0F 22 00 ; Logical OR long $00220F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $83		; 10 83 ; Branch if plus to $10, $83 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F3F43B.l,X		; FF 3B F4 F3 ; Subtract with carry (long,X) $F3F43B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc [$F0.b],Y		; F7 F0 ; Subtract with carry (long indexed) [$F0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $43.b		; E4 43 ; Compare $43.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sbc $E7.b,S		; E3 E7 ; Subtract stack-relative $E7.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	ora $E0.b		; 05 E0 ; Logical OR $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$0F.b]		; C7 0F ; Compare accumulator (long) [$0F.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	tsb $1F22.w		; 0C 22 1F ; Test and set bits $1F22.w [Reads: Accumulator] [Flags: Z]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: ZNC]
	inc $5F3D.w,X		; FE 3D 5F ; Increment memory $5F3D.w,X [Reads: X Index] [Flags: ZN]
	lda $C3BE.w,X		; BD BE C3 ; Load $C3BE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $BF507C.l		; CF 7C 50 BF ; Compare accumulator (long) $BF507C.l [Reads: Accumulator] [Flags: ZNC]
	lda $60F8C0.l,X		; BF C0 F8 60 ; Load long $60F8C0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $B0, $3D		; B0 3D ; Branch if carry set to $B0, $3D [Flow: branch]
	sta $7CC3.w,X		; 9D C3 7C ; Store accumulator to $7CC3.w,X [Reads: Accumulator, X Index]
	ora $106080.l,X		; 1F 80 60 10 ; Logical OR long $106080.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $BDFABC.l,X		; 7F BC FA BD ; Add long $BDFABC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $D3C3.w,X		; 7D C3 D3 ; Add $D3C3.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $FD0A.w,X		; 3E 0A FD ; Rotate left $FD0A.w,X [Reads: X Index] [Flags: ZNC]
	sbc $1F03.w,X		; FD 03 1F ; Subtract with carry $1F03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $1A.b		; 06 1A ; Arithmetic shift left $1A.b [Reads: Direct Page] [Flags: ZNC]
	ora $B9BC.w		; 0D BC B9 ; Logical OR $B9BC.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cmp $1E.b,S		; C3 1E ; Compare accumulator (stack relative) $1E.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Accumulator, Direct Page, Y Index]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($3E.b,X)		; 01 3E ; Logical OR ($3E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rol $23.b,X		; 36 23 ; Rotate left $23.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	eor $14.b,S		; 43 14 ; Exclusive OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $82, $7C, $E6		; 82 7C E6 ; Branch always long to $82, $7C, $E6 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $2C7E66.l,X		; FF 66 7E 2C ; Subtract with carry (long,X) $2C7E66.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $1808.w,X		; 3C 08 18 ; Test bits $1808.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($6618.w,X)		; 7C 18 66 ; Jump indirect indexed to ($6618.w,X) [Reads: X Index] [Flow: jump]
	bit $0008.w		; 2C 08 00 ; Test bits $0008.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	lsr $2C34.w		; 4E 34 2C ; Logical shift right $2C34.w [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	bit $33E0.w		; 2C E0 33 ; Test bits $33E0.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sbc $4CBF0F.l,X		; FF 0F BF 4C ; Subtract with carry (long,X) $4CBF0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $007F30.l		; 6F 30 7F 00 ; Add with carry (long) $007F30.l [Writes: Accumulator] [Flags: ZVNC]
	ror $3F0D.w,X		; 7E 0D 3F ; Rotate right $3F0D.w,X [Reads: X Index] [Flags: ZNC]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $A0000F.l		; 0F 0F 00 A0 ; OR accumulator with memory (long) $A0000F.l [Writes: Accumulator] [Flags: ZN]
	cmp ($7B.b),Y		; D1 7B ; Compare accumulator ($7B.b),Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	ror $2F53.w,X		; 7E 53 2F ; Rotate right $2F53.w,X [Reads: X Index] [Flags: ZNC]
	ora $E0FF0F.l,X		; 1F 0F FF E0 ; Logical OR long $E0FF0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $F602.w,X		; FD 02 F6 ; Subtract with carry $F602.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $00FE.w		; 0C FE 00 ; Test and set bits $00FE.w [Reads: Accumulator] [Flags: Z]
	ror $FCB0.w,X		; 7E B0 FC ; Rotate right $FCB0.w,X [Reads: X Index] [Flags: ZNC]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	dec $CA7E.w,X		; DE 7E CA ; Decrement memory $CA7E.w,X [Reads: X Index] [Flags: ZN]
	pea $F0C8.w		; F4 C8 F0 ; Push absolute address $F0C8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sta $FF.b,S		; 83 FF ; Store accumulator (stack relative) $FF.b,S [Reads: Accumulator, Stack Pointer]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: ZNC]
	eor $40.b		; 45 40 ; Exclusive OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $5FA011.l,X		; 3F 11 A0 5F ; AND accumulator with memory (long,X) $5FA011.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $8782.w,X		; FD 82 87 ; Subtract with carry $8782.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $F7.b		; 02 F7 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	.db $42, $82		; 42 82 ; Reserved instruction
	cop $C1.b		; 02 C1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $45F807.l,X		; FF 07 F8 45 ; Subtract with carry (long,X) $45F807.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FA05.w		; 0D 05 FA ; Logical OR $FA05.w with accumulator [Writes: Accumulator] [Flags: ZN]
	lda $40E141.l,X		; BF 41 E1 40 ; Load long $40E141.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $0800E0.l		; EF E0 00 08 ; Subtract with carry (long) $0800E0.l [Writes: Accumulator] [Flags: ZVNC]
	mvp $41,$42		; 44 42 41 ; Move block positive $41,$42 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1A00.w		; 0D 00 1A ; Logical OR $1A00.w with accumulator [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $5A0675.l		; 22 75 06 5A ; Jump to subroutine long $5A0675.l [Writes: Stack Pointer] [Flow: call]
	tsb $3874.w		; 0C 74 38 ; Test and set bits $3874.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $3038.w		; 1C 38 30 ; Test and reset bits $3038.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $60		; 50 60 ; Branch if overflow clear to $50, $60 [Flow: branch]
	ldy #$C0.b		; A0 C0 ; Load #$C0.b into Y register [Writes: Y Index] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $26		; 80 26 ; Branch always to $80, $26 [Flow: branch]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7F071F.l,X		; 3F 1F 07 7F ; AND accumulator with memory (long,X) $7F071F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $603878.l,X		; 3F 78 38 60 ; AND accumulator with memory (long,X) $603878.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr $007F.w		; 20 7F 00 ; Jump to subroutine at $007F.w [Writes: Stack Pointer] [Flow: call]
	eor $6B.b,S		; 43 6B ; Exclusive OR accumulator with stack relative $6B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol $07.b,X		; 36 07 ; Rotate left $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jsr $4020.w		; 20 20 40 ; Jump to subroutine at $4020.w [Writes: Stack Pointer] [Flow: call]
	eor [$5F.b]		; 47 5F ; Exclusive OR accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $457777.l,X		; 7F 77 77 45 ; Add long $457777.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $E0.b		; E4 E0 ; Compare $E0.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	ora #$16.b		; 09 16 ; Logical OR #$16.b with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sbc $1A03.w,X		; FD 03 1A ; Subtract with carry $1A03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $060D.w		; 0D 0D 06 ; Logical OR $060D.w with accumulator [Writes: Accumulator] [Flags: ZN]
	jsl $EE071C.l		; 22 1C 07 EE ; Jump to subroutine long $EE071C.l [Writes: Stack Pointer] [Flow: call]
	sbc [$FB.b],Y		; F7 FB ; Subtract with carry (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $E80E.w,X		; 1D 0E E8 ; OR accumulator with memory $E80E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	bit $0000.w		; 2C 00 00 ; Test bits $0000.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cpy #$26.b		; C0 26 ; Compare #$26.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $0000.w		; 2C 00 00 ; Test bits $0000.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $7F.b		; 26 7F ; Rotate left $7F.b [Reads: Direct Page] [Flags: ZNC]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $F7.b		; 02 F7 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $47.b		; 06 47 ; Arithmetic shift left $47.b [Reads: Direct Page] [Flags: ZNC]
	sbc $00030E.l,X		; FF 0E 03 00 ; Subtract with carry (long,X) $00030E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $F8FC.w,X		; FE FC F8 ; Increment memory $F8FC.w,X [Reads: X Index] [Flags: ZN]
	and $F0.b,S		; 23 F0 ; AND accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $204808.l		; 2F 08 48 20 ; AND accumulator with memory (long) $204808.l [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	ora $030023.l,X		; 1F 23 00 03 ; Logical OR long $030023.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr ($1CF0.w,X)		; FC F0 1C ; Jump to subroutine indirect indexed ($1CF0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor [$FC.b]		; 47 FC ; Exclusive OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	jsl $080000.l		; 22 00 00 08 ; Jump to subroutine long $080000.l [Writes: Stack Pointer] [Flow: call]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $E8.b,S		; 03 E8 ; OR accumulator with stack relative $E8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$08.b		; E0 08 ; Compare #$08.b with X register [Reads: X Index] [Flags: ZNC]
	.db $10, $45		; 10 45 ; Branch if plus to $10, $45 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $22		; 30 22 ; Branch if minus to $30, $22 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	jsl $002AC0.l		; 22 C0 2A 00 ; Jump to subroutine long $002AC0.l [Writes: Stack Pointer] [Flow: call]
	mvp $01,$04		; 44 04 01 ; Move block positive $01,$04 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	jsl $002903.l		; 22 03 29 00 ; Jump to subroutine long $002903.l [Writes: Stack Pointer] [Flow: call]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $A0,$40		; 44 40 A0 ; Move block positive $A0,$40 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	jsl $000280.l		; 22 80 02 00 ; Jump to subroutine long $000280.l [Writes: Stack Pointer] [Flow: call]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $0200.w		; 4C 00 02 ; Jump to $0200.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $03.b		; 26 03 ; Rotate left $03.b [Reads: Direct Page] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	mvp $C0,$80		; 44 80 C0 ; Move block positive $C0,$80 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $40.b		; 04 40 ; Test and set bits $40.b [Reads: Accumulator] [Flags: Z]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $C0.b		; 24 C0 ; Test bits $C0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $E1.b		; 00 E1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($58.b,X)		; A1 58 ; Load accumulator ($58.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $23.b		; 26 23 ; Rotate left $23.b [Reads: Direct Page] [Flags: ZNC]
	ora ($18.b),Y		; 11 18 ; OR accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $0087.w		; 4D 87 00 ; Exclusive OR $0087.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cmp [$00.b]		; C7 00 ; Compare accumulator (long) [$00.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda [$40.b],Y		; B7 40 ; Load accumulator (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $FF22.w,X		; 5D 22 FF ; Exclusive OR accumulator with memory $FF22.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	adc $7BCF39.l,X		; 7F 39 CF 7B ; Add long $7BCF39.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sta $45.b		; 85 45 ; Store accumulator to $45.b [Reads: Accumulator]
	lda $D5.b		; A5 D5 ; Load $D5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $FCFEFF.l,X		; 7F FF FE FC ; Add long $FCFEFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $5F.b		; E4 5F ; Compare $5F.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $970900.l		; 8F 00 09 97 ; Store accumulator (long) $970900.l [Reads: Accumulator]
	ora [$AF.b]		; 07 AF ; OR accumulator with memory (long) [$AF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $801FDF.l		; 0F DF 1F 80 ; OR accumulator with memory (long) $801FDF.l [Writes: Accumulator] [Flags: ZN]
	adc $2200FF.l,X		; 7F FF 00 22 ; Add long $2200FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $707804.l,X		; 7F 04 78 70 ; Add long $707804.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $F709.w		; 0E 09 F7 ; Arithmetic shift left $F709.w [Flags: ZNC]
	inc $FB.b,X		; F6 FB ; Increment memory $FB.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sbc $01FC.w,X		; FD FC 01 ; Subtract with carry $01FC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $00FF.w,X		; FE FF 00 ; Increment memory $00FF.w,X [Reads: X Index] [Flags: ZN]
	jsl $0806F0.l		; 22 F0 06 08 ; Jump to subroutine long $0806F0.l [Writes: Stack Pointer] [Flow: call]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and [$04.b]		; 27 04 ; AND accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $3F002F.l		; 0F 2F 00 3F ; OR accumulator with memory (long) $3F002F.l [Writes: Accumulator] [Flags: ZN]
	and $030024.l,X		; 3F 24 00 03 ; AND accumulator with memory (long,X) $030024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $101818.l,X		; 1F 18 18 10 ; Logical OR long $101818.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $EC.b,S		; 43 EC ; Exclusive OR accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	tsb $F4.b		; 04 F4 ; Test and set bits $F4.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0024.w,X)		; FC 24 00 ; Jump to subroutine indirect indexed ($0024.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $261F1F.l		; 0F 1F 1F 26 ; OR accumulator with memory (long) $261F1F.l [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $24080C.l		; 0F 0C 08 24 ; OR accumulator with memory (long) $24080C.l [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $43		; 30 43 ; Branch if minus to $30, $43 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$2A.b]		; 07 2A ; OR accumulator with memory (long) [$2A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpx #$32.b		; E0 32 ; Compare #$32.b with X register [Reads: X Index] [Flags: ZNC]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $032600.l		; 22 00 26 03 ; Jump to subroutine long $032600.l [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lsr $80.b		; 46 80 ; Logical shift right $80.b [Reads: Direct Page] [Flags: ZNC]
	cpy #$02.b		; C0 02 ; Compare #$02.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $C0.b		; 24 C0 ; Test bits $C0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cpx #$2D.b		; E0 2D ; Compare #$2D.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $F5.b		; 00 F5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($36.b),Y		; 11 36 ; OR accumulator with memory ($36.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $0F07.w,X		; 1E 07 0F ; Arithmetic shift left $0F07.w,X [Reads: X Index] [Flags: ZNC]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03FF.w		; 0D FF 03 ; Logical OR $03FF.w with accumulator [Writes: Accumulator] [Flags: ZN]
	lda [$5F.b],Y		; B7 5F ; Load accumulator (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $FF0F1F.l		; 2F 1F 0F FF ; AND accumulator with memory (long) $FF0F1F.l [Writes: Accumulator] [Flags: ZN]
	asl $AFFC.w		; 0E FC AF ; Arithmetic shift left $AFFC.w [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	eor $6CBBB7.l,X		; 5F B7 BB 6C ; Exclusive OR accumulator with memory (long,X) $6CBBB7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$DB.b],Y		; 77 DB ; Add with carry (long indexed) [$DB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $6FDCB7.l		; EF B7 DC 6F ; Subtract with carry (long) $6FDCB7.l [Writes: Accumulator] [Flags: ZVNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $DF5EF9.l,X		; 5F F9 5E DF ; Exclusive OR accumulator with memory (long,X) $DF5EF9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $FF237F.l,X		; BF 7F 23 FF ; Load long $FF237F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$5F.b]		; E7 5F ; Subtract with carry (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: ZNC]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $1D3F04.l,X		; 1F 04 3F 1D ; Logical OR long $1D3F04.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $DF22.w		; 6E 22 DF ; Rotate right $DF22.w [Flags: ZNC]
	eor $3AFE.w,X		; 5D FE 3A ; Exclusive OR accumulator with memory $3AFE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $75F77B.l,X		; FF 7B F7 75 ; Subtract with carry (long,X) $75F77B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: ZNC]
	jsl $C5A25D.l		; 22 5D A2 C5 ; Jump to subroutine long $C5A25D.l [Writes: Stack Pointer] [Flow: call]
	sty $8A.b		; 84 8A ; Store Y register to $8A.b [Reads: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $0B9710.l		; EF 10 97 0B ; Subtract with carry (long) $0B9710.l [Writes: Accumulator] [Flags: ZVNC]
	ora $048B01.l		; 0F 01 8B 04 ; OR accumulator with memory (long) $048B01.l [Writes: Accumulator] [Flags: ZN]
	sta ($0C.b,S),Y		; 93 0C ; Store accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	sbc ($EE.b),Y		; F1 EE ; Subtract with carry ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $FF		; 90 FF ; Branch if carry clear to $90, $FF [Flow: branch]
	sbc $FDFDFB.l,X		; FF FB FD FD ; Subtract with carry (long,X) $FDFDFB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $130023.l,X		; 1F 23 00 13 ; Logical OR long $130023.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $98		; F0 98 ; Branch if equal to $F0, $98 [Flow: branch]
	cpx #$8C.b		; E0 8C ; Compare #$8C.b with X register [Reads: X Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0097.w,X)		; FC 97 00 ; Jump to subroutine indirect indexed ($0097.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	adc $EF30.w,Y		; 79 30 EF ; Add $EF30.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($9F.b),Y		; 11 9F ; OR accumulator with memory ($9F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $85.b		; 04 85 ; Test and set bits $85.b [Reads: Accumulator] [Flags: Z]
	jsl $300300.l		; 22 00 03 30 ; Jump to subroutine long $300300.l [Writes: Stack Pointer] [Flow: call]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: ZN]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsl $1F18FD.l		; 22 FD 18 1F ; Jump to subroutine long $1F18FD.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $7E		; F0 7E ; Branch if equal to $F0, $7E [Flow: branch]
	cpx #$CD.b		; E0 CD ; Compare #$CD.b with X register [Reads: X Index] [Flags: ZNC]
	pea $FA87.w		; F4 87 FA ; Push absolute address $FA87.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sta $F8FDF8.l,X		; 9F F8 FD F8 ; Store accumulator (long,X) $F8FDF8.l,X [Reads: Accumulator, X Index]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $FDFB.w,X		; FE FB FD ; Increment memory $FDFB.w,X [Reads: X Index] [Flags: ZN]
	sbc $0025FF.l,X		; FF FF 25 00 ; Subtract with carry (long,X) $0025FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$0E.b		; 09 0E ; Logical OR #$0E.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1B3B.w		; 0E 3B 1B ; Arithmetic shift left $1B3B.w [Flags: ZNC]
	bit $3F1C.w,X		; 3C 1C 3F ; Test bits $3F1C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $040022.l,X		; 1F 22 00 04 ; Logical OR long $040022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $2411.w		; 0E 11 24 ; Arithmetic shift left $2411.w [Flags: ZNC]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$E0.b		; 09 E0 ; Logical OR #$E0.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$B8.b		; E0 B8 ; Compare #$B8.b with X register [Reads: X Index] [Flags: ZNC]
	.db $B0, $78		; B0 78 ; Branch if carry set to $B0, $78 [Flow: branch]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $B6.b		; 00 B6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	lda ($2C.b,S),Y		; B3 2C ; Load accumulator (stack relative indirect indexed) ($2C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$0A.b],Y		; 77 0A ; Add with carry (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $220700.l		; 0F 00 07 22 ; OR accumulator with memory (long) $220700.l [Writes: Accumulator] [Flags: ZN]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	dec $D3.b,X		; D6 D3 ; Decrement memory $D3.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	adc [$0E.b],Y		; 77 0E ; Add with carry (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $27.b		; 04 27 ; Test and set bits $27.b [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $10, $DC		; 10 DC ; Branch if plus to $10, $DC [Flow: branch]
	jsr $708E.w		; 20 8E 70 ; Jump to subroutine at $708E.w [Writes: Stack Pointer] [Flow: call]
	ldx $2350.w		; AE 50 23 ; Load $2350.w into X register [Writes: X Index] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldy $72.b		; A4 72 ; Load $72.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	ror $23.b,X		; 76 23 ; Rotate right $23.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	.db $10, $E4		; 10 E4 ; Branch if plus to $10, $E4 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	adc $041F10.l		; 6F 10 1F 04 ; Add with carry (long) $041F10.l [Writes: Accumulator] [Flags: ZVNC]
	ora $050022.l		; 0F 22 00 05 ; OR accumulator with memory (long) $050022.l [Writes: Accumulator] [Flags: ZN]
	.db $70, $E8		; 70 E8 ; Branch if overflow set to $70, $E8 [Flow: branch]
	ldy $6F.b		; A4 6F ; Load $6F.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: ZN]
	ora $00270C.l,X		; 1F 0C 27 00 ; Logical OR long $00270C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $42BF.w		; 20 BF 42 ; Jump to subroutine at $42BF.w [Writes: Stack Pointer] [Flow: call]
	and $0023D2.l		; 2F D2 23 00 ; AND accumulator with memory (long) $0023D2.l [Writes: Accumulator] [Flags: ZN]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sbc [$45.b]		; E7 45 ; Subtract with carry (long) [$45.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $3B.b,X		; F5 3B ; Subtract $3B.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F2000.l,X		; 1F 00 20 1F ; Logical OR long $1F2000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jmp $5E33.w		; 4C 33 5E ; Jump to $5E33.w [Flow: jump]
	and ($9C.b,X)		; 21 9C ; Logical AND ($9C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc $84.b,S		; 63 84 ; Add with carry (stack relative) $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $61733F.l,X		; 1F 3F 73 61 ; Logical OR long $61733F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $FB.b,S		; E3 FB ; Subtract stack-relative $FB.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$80.b		; 09 80 ; Logical OR #$80.b with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $70		; 80 70 ; Branch always to $80, $70 [Flow: branch]
	cpy #$68.b		; C0 68 ; Compare #$68.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$E4.b		; C0 E4 ; Compare #$E4.b with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($0037.w,X)		; FC 37 00 ; Jump to subroutine indirect indexed ($0037.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$3F.b		; E0 3F ; Compare #$3F.b with X register [Reads: X Index] [Flags: ZNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	and $0B1F1B.l,X		; 3F 1B 1F 0B ; AND accumulator with memory (long,X) $0B1F1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0C1F0A.l,X		; 1F 0A 1F 0C ; Logical OR long $0C1F0A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000404.l		; 0F 04 04 00 ; OR accumulator with memory (long) $000404.l [Writes: Accumulator] [Flags: ZN]
	eor $2445.w		; 4D 45 24 ; Exclusive OR $2445.w with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $15.b		; 14 15 ; Test and reset bits $15.b [Reads: Accumulator] [Flags: Z]
	ora ($0B.b,S),Y		; 13 0B ; OR accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $EB.b		; 04 EB ; Test and set bits $EB.b [Reads: Accumulator] [Flags: Z]
	sta $E7.b,X		; 95 E7 ; Store accumulator to $E7.b,X [Reads: Accumulator, X Index]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	dec $AB.b,X		; D6 AB ; Decrement memory $AB.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc [$99.b]		; E7 99 ; Subtract with carry (long) [$99.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $83FF92.l		; EF 92 FF 83 ; Subtract with carry (long) $83FF92.l [Writes: Accumulator] [Flags: ZVNC]
	cmp $00B191.l,X		; DF 91 B1 00 ; Compare accumulator (long,X) $00B191.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	adc [$BF.b],Y		; 77 BF ; Add with carry (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $7F5F5F.l		; 6F 5F 5F 7F ; Add with carry (long) $7F5F5F.l [Writes: Accumulator] [Flags: ZVNC]
	adc $F8CCB1.l		; 6F B1 CC F8 ; Add with carry (long) $F8CCB1.l [Writes: Accumulator] [Flags: ZVNC]
	ldy $3C78.w,X		; BC 78 3C ; Load Y register $3C78.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $FCE8.w		; 9C E8 FC ; Store zero to $FCE8.w
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	ldy #$E4.b		; A0 E4 ; Load #$E4.b into Y register [Writes: Y Index] [Flags: ZN]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($7800.w,X)		; FC 00 78 ; Jump to subroutine indirect indexed ($7800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stx $80.b		; 86 80 ; Store X register to $80.b [Reads: X Index]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: ZNC]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	tsb $4D.b		; 04 4D ; Test and set bits $4D.b [Reads: Accumulator] [Flags: Z]
	eor $24.b		; 45 24 ; Exclusive OR $24.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $2207.w,Y		; 19 07 22 ; OR accumulator with memory $2207.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E792.w		; ED 92 E7 ; Subtract $E792.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	eor $8BF7.w,Y		; 59 F7 8B ; Exclusive OR accumulator with memory $8BF7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc $08EDC1.l,X		; FF C1 ED 08 ; Subtract with carry (long,X) $08EDC1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	jsl $771200.l		; 22 00 12 77 ; Jump to subroutine long $771200.l [Writes: Stack Pointer] [Flow: call]
	lda $F53F6F.l,X		; BF 6F 3F F5 ; Load long $F53F6F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sta $F8FEE2.l,X		; 9F E2 FE F8 ; Store accumulator (long,X) $F8FEE2.l,X [Reads: Accumulator, X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora $FEFDFF.l,X		; 1F FF FD FE ; Logical OR long $FEFDFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($7F.b,S),Y		; 33 7F ; AND accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	adc $003B24.l,X		; 7F 24 3B 00 ; Add long $003B24.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000707.l		; 0F 07 07 00 ; OR accumulator with memory (long) $000707.l [Writes: Accumulator] [Flags: ZN]
	jmp $5354.w		; 4C 54 53 ; Jump to $5354.w [Flow: jump]
	rol $171E.w,X		; 3E 1E 17 ; Rotate left $171E.w,X [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr ($1DF8.w,X)		; FC F8 1D ; Jump to subroutine indirect indexed ($1DF8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FE34.w,X		; FE 34 FE ; Increment memory $FE34.w,X [Reads: X Index] [Flags: ZN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ror $7C58.w,X		; 7E 58 7C ; Rotate right $7C58.w,X [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$80.b		; E0 80 ; Compare #$80.b with X register [Reads: X Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
.ACCU 16
	rep #$22		; C2 22
	ldx $BC.b		; A6 BC ; Load $BC.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $07		; 80 07 ; Branch always to $80, $07 [Flow: branch]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	ora $051E.w		; 0D 1E 05 ; Logical OR $051E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $CC8300.l,X		; 1F 00 83 CC ; Logical OR long $CC8300.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	jsl $2CE01F.l		; 22 1F E0 2C ; Jump to subroutine long $2CE01F.l [Writes: Stack Pointer] [Flow: call]
	ora $1E0107.l		; 0F 07 01 1E ; OR accumulator with memory (long) $1E0107.l [Writes: Accumulator] [Flags: ZN]
	cpx $FA.b		; E4 FA ; Compare $FA.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $3FE2.w,X		; 7D E2 3F ; Add $3FE2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx $F87E.w		; EC 7E F8 ; Compare $F87E.w with X register [Reads: X Index] [Flags: ZNC]
	jsr ($F800.w,X)		; FC 00 F8 ; Jump to subroutine indirect indexed ($F800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sbc $F8FCFE.l,X		; FF FE FC F8 ; Subtract with carry (long,X) $F8FCFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cpx #$0F.b		; E0 0F ; Compare #$0F.b with X register [Reads: X Index] [Flags: ZNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $1B3E.w		; 0C 3E 1B ; Test and set bits $1B3E.w [Reads: Accumulator] [Flags: Z]
	bit $1E0B.w,X		; 3C 0B 1E ; Test bits $1E0B.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F22.w,X		; 1D 22 3F ; OR accumulator with memory $3F22.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $E01E03.l		; 0F 03 1E E0 ; OR accumulator with memory (long) $E01E03.l [Writes: Accumulator] [Flags: ZN]
	asl $FEF0.w		; 0E F0 FE ; Arithmetic shift left $FEF0.w [Flags: ZNC]
	tsb $DCF6.w		; 0C F6 DC ; Test and set bits $DCF6.w [Reads: Accumulator] [Flags: Z]
	ror $FCD8.w,X		; 7E D8 FC ; Rotate right $FCD8.w,X [Reads: X Index] [Flags: ZNC]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FC03.w,X		; FE 03 FC ; Increment memory $FC03.w,X [Reads: X Index] [Flags: ZN]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	jsl $030601.l		; 22 01 06 03 ; Jump to subroutine long $030601.l [Writes: Stack Pointer] [Flow: call]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$1FE3.w		; 09 E3 1F ; Logical OR #$1FE3.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cmp $015484.l,X		; DF 84 54 01 ; Compare accumulator (long,X) $015484.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	cpx #$27.b		; E0 27 ; Compare #$27.b with X register [Reads: X Index] [Flags: ZNC]
	lda $FF00.w,Y		; B9 00 FF ; Load $FF00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$FD.b]		; 87 FD ; Store accumulator (long) [$FD.b] [Reads: Accumulator, Direct Page]
	.db $82, $FF, $3F		; 82 FF 3F ; Branch always long to $82, $FF, $3F [Flow: branch]
	adc $CFFF3F.l,X		; 7F 3F FF CF ; Add long $CFFF3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $00CCFE.l		; CF FE CC 00 ; Compare accumulator (long) $00CCFE.l [Reads: Accumulator] [Flags: ZNC]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $CE.b		; 04 CE ; Test and set bits $CE.b [Reads: Accumulator] [Flags: Z]
	bit $83.b,X		; 34 83 ; Test bits $83.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ror $B64B.w,X		; 7E 4B B6 ; Rotate right $B64B.w,X [Reads: X Index] [Flags: ZNC]
	adc ($8E.b,S),Y		; 73 8E ; Add with carry (stack relative indirect indexed) ($8E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx $5D.b		; A6 5D ; Load $5D.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	jsr ($FEFC.w,X)		; FC FC FE ; Jump to subroutine indirect indexed ($FEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $F7FF.w,X		; FE FF F7 ; Increment memory $F7FF.w,X [Reads: X Index] [Flags: ZN]
	cmp $002D5F.l		; CF 5F 2D 00 ; Compare accumulator (long) $002D5F.l [Reads: Accumulator] [Flags: ZNC]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $08,$00		; 44 00 08 ; Move block positive $08,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	asl $20.b		; 06 20 ; Arithmetic shift left $20.b [Reads: Direct Page] [Flags: ZNC]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ora ($04.b)		; 12 04 ; OR accumulator with memory (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $37.b		; 04 37 ; Test and set bits $37.b [Reads: Accumulator] [Flags: Z]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $88.b		; 02 88 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: ZNC]
	sec		; 38 ; Set carry flag [Flags: C]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010000.l		; 22 00 00 01 ; Jump to subroutine long $010000.l [Writes: Stack Pointer] [Flow: call]
	jsl $420000.l		; 22 00 00 42 ; Jump to subroutine long $420000.l [Writes: Stack Pointer] [Flow: call]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl $2201.w		; 0E 01 22 ; Arithmetic shift left $2201.w [Flags: ZNC]
	ora $050025.l,X		; 1F 25 00 05 ; Logical OR long $050025.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0F0C.w		; 0C 0C 0F ; Test and set bits $0F0C.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $34.b,S		; 83 34 ; Store accumulator (stack relative) $34.b,S [Reads: Accumulator, Stack Pointer]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($73.b),Y		; 51 73 ; Exclusive OR accumulator with memory ($73.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $80		; 30 80 ; Branch if minus to $30, $80 [Flow: branch]
	asl $2C1C.w		; 0E 1C 2C ; Arithmetic shift left $2C1C.w [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $0025.w,X		; FE 25 00 ; Increment memory $0025.w,X [Reads: X Index] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $002A.w,X		; FE 2A 00 ; Increment memory $002A.w,X [Reads: X Index] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $25FFF0.l		; 0F F0 FF 25 ; OR accumulator with memory (long) $25FFF0.l [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0400F0.l		; 0F F0 00 04 ; OR accumulator with memory (long) $0400F0.l [Writes: Accumulator] [Flags: ZN]
	jsl $102700.l		; 22 00 27 10 ; Jump to subroutine long $102700.l [Writes: Stack Pointer] [Flow: call]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	and $00F400.l		; 2F 00 F4 00 ; AND accumulator with memory (long) $00F400.l [Writes: Accumulator] [Flags: ZN]
	ora $030025.l		; 0F 25 00 03 ; OR accumulator with memory (long) $030025.l [Writes: Accumulator] [Flags: ZN]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	sbc $00260F.l,X		; FF 0F 26 00 ; Subtract with carry (long,X) $00260F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora #$0007.w		; 09 07 00 ; Logical OR #$0007.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $1F05.w		; 0D 05 1F ; Logical OR $1F05.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0022.w		; 09 22 00 ; Logical OR #$0022.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora ($18.b),Y		; 11 18 ; OR accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $25.b,X		; 35 25 ; Logical AND $25.b,X with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $40F8.w		; 20 F8 40 ; Jump to subroutine at $40F8.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $22		; 90 22 ; Branch if carry clear to $90, $22 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $D0, $88		; D0 88 ; Branch if not equal to $D0, $88 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldy $0023.w		; AC 23 00 ; Load $0023.w into Y register [Writes: Y Index] [Flags: ZN]
	ora ($60.b,S),Y		; 13 60 ; OR accumulator (stack relative indirect indexed) ($60.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $227D.w		; 0C 7D 22 ; Test and set bits $227D.w [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora $59.b,X		; 15 59 ; OR accumulator with memory $59.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $57AE.w		; 9C AE 57 ; Store zero to $57AE.w
	adc $236A.w		; 6D 6A 23 ; Add $236A.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	and $304F00.l,X		; 3F 00 4F 30 ; AND accumulator with memory (long,X) $304F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ldx $5A44.w,Y		; BE 44 5A ; Load X register $5A44.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $39.b		; 06 39 ; Arithmetic shift left $39.b [Reads: Direct Page] [Flags: ZNC]
	adc $EA.b,X		; 75 EA ; Add $EA.b,X to accumulator with carry [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ldx $56.b,Y		; B6 56 ; Load X register $56.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: ZN]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $44.b,S		; 03 44 ; OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$33.b		; E0 33 ; Compare #$33.b with X register [Reads: X Index] [Flags: ZNC]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	inc $FE31.w,X		; FE 31 FE ; Increment memory $FE31.w,X [Reads: X Index] [Flags: ZN]
	ora $5EEF.w		; 0D EF 5E ; Logical OR $5EEF.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc [$6F.b],Y		; 77 6F ; Add with carry (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($2F.b,S),Y		; F3 2F ; Subtract with carry (stack relative indirect indexed) ($2F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $2F		; 30 2F ; Branch if minus to $30, $2F [Flow: branch]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	sbc ($CF.b),Y		; F1 CF ; Subtract with carry ($CF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	cmp $97AFFF.l		; CF FF AF 97 ; Compare accumulator (long) $97AFFF.l [Reads: Accumulator] [Flags: ZNC]
	cmp [$D7.b],Y		; D7 D7 ; Compare accumulator (long indexed) [$D7.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sbc [$37.b],Y		; F7 37 ; Subtract with carry (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $CF19.w		; EE 19 CF ; Increment $CF19.w [Flags: ZN]
	.db $30, $3D		; 30 3D ; Branch if minus to $30, $3D [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	sbc $1A.b,X		; F5 1A ; Subtract $1A.b,X from accumulator with borrow [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $FB.b		; E4 FB ; Compare $FB.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	rol $DD.b		; 26 DD ; Rotate left $DD.b [Reads: Direct Page] [Flags: ZNC]
.INDEX 8
	sep #$DD		; E2 DD
	cmp $BE.b,S		; C3 BE ; Compare accumulator (stack relative) $BE.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ora $FEFE3C.l,X		; 1F 3C FE FE ; Logical OR long $FEFE3C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $80.b		; 04 80 ; Test and set bits $80.b [Reads: Accumulator] [Flags: Z]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	mvp $E0,$00		; 44 00 E0 ; Move block positive $E0,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $A0.b		; 45 A0 ; Exclusive OR $A0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	tsb $80.b		; 04 80 ; Test and set bits $80.b [Reads: Accumulator] [Flags: Z]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldy #$A0.b		; A0 A0 ; Load #$A0.b into Y register [Writes: Y Index] [Flags: ZN]
	jsl $3043E0.l		; 22 E0 43 30 ; Jump to subroutine long $3043E0.l [Writes: Stack Pointer] [Flow: call]
	jsr $2001.w		; 20 01 20 ; Jump to subroutine at $2001.w [Writes: Stack Pointer] [Flow: call]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor $40.b		; 45 40 ; Exclusive OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $44.b		; C4 44 ; Compare $44.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	lsr $0F.b		; 46 0F ; Logical shift right $0F.b [Reads: Direct Page] [Flags: ZNC]
	tsb $0808.w		; 0C 08 08 ; Test and set bits $0808.w [Reads: Accumulator] [Flags: Z]
	sty $37.b		; 84 37 ; Store Y register to $37.b [Reads: Y Index]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $04.b		; 26 04 ; Rotate left $04.b [Reads: Direct Page] [Flags: ZNC]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $0C43.w		; 0C 43 0C ; Test and set bits $0C43.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $1058.w		; 0D 58 10 ; Logical OR $1058.w with accumulator [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $30.b		; 14 30 ; Test and reset bits $30.b [Reads: Accumulator] [Flags: Z]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($2F.b),Y		; 31 2F ; AND accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2D.b,X)		; 01 2D ; Logical OR ($2D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F00F0.l		; 0F F0 00 0F ; OR accumulator with memory (long) $0F00F0.l [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $04.b,S		; 23 04 ; AND accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $110A0A.l		; 0F 0A 0A 11 ; OR accumulator with memory (long) $110A0A.l [Writes: Accumulator] [Flags: ZN]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	jsr $0A0A.w		; 20 0A 0A ; Jump to subroutine at $0A0A.w [Writes: Stack Pointer] [Flow: call]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($20.b),Y		; 11 20 ; OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsr $3740.w		; 20 40 37 ; Jump to subroutine at $3740.w [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0C5F.w,Y		; 39 5F 0C ; AND accumulator with memory $0C5F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	eor $216F08.l,X		; 5F 08 6F 21 ; Exclusive OR accumulator with memory (long,X) $216F08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ror $7A10.w,X		; 7E 10 7A ; Rotate right $7A10.w,X [Reads: X Index] [Flags: ZNC]
	jsr $347C.w		; 20 7C 34 ; Jump to subroutine at $347C.w [Writes: Stack Pointer] [Flow: call]
	and [$01.b],Y		; 37 01 ; AND accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	adc ($77.b)		; 72 77 ; Add with carry (indirect) ($77.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $01364B.l,X		; 5F 4B 36 01 ; Exclusive OR accumulator with memory (long,X) $01364B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	.db $30, $FA		; 30 FA ; Branch if minus to $30, $FA [Flow: branch]
	.db $10, $F6		; 10 F6 ; Branch if plus to $10, $F6 [Flow: branch]
	sty $7E.b		; 84 7E ; Store Y register to $7E.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr $3E04.w,X		; 5E 04 3E ; Logical shift right $3E04.w,X [Reads: X Index] [Flags: ZNC]
	bit $80EC.w		; 2C EC 80 ; Test bits $80EC.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	lsr $1AEE.w		; 4E EE 1A ; Logical shift right $1AEE.w [Flags: ZNC]
	dec $FA.b,X		; D6 FA ; Decrement memory $FA.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	cmp ($6C.b)		; D2 6C ; Compare accumulator (indirect) ($6C.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
	.db $80, $CC		; 80 CC ; Branch always to $80, $CC [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc $5301.w		; EE 01 53 ; Increment $5301.w [Flags: ZN]
	bit $043B.w		; 2C 3B 04 ; Test bits $043B.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	bit $8303.w,X		; 3C 03 83 ; Test bits $8303.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $7B.b,X		; 74 7B ; Store zero to $7B.b,X [Reads: X Index]
	adc $833C.w,X		; 7D 3C 83 ; Add $833C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $02.b		; 84 02 ; Store Y register to $02.b [Reads: Y Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and ($D0.b,S),Y		; 33 D0 ; AND accumulator (stack relative indirect indexed) ($D0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc [$80.b],Y		; 77 80 ; Add with carry (long indexed) [$80.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($8C00.w,X)		; FC 00 8C ; Jump to subroutine indirect indexed ($8C00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $3C		; 70 3C ; Branch if overflow set to $70, $3C [Flow: branch]
	cpy #$F8.b		; C0 F8 ; Compare #$F8.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $02.b,X		; 94 02 ; Store Y register $02.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	ora [$2E.b]		; 07 2E ; OR accumulator with memory (long) [$2E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $7C8C.w,X		; DE 8C 7C ; Decrement memory $7C8C.w,X [Reads: X Index] [Flags: ZN]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$83.b		; C0 83 ; Compare #$83.b with Y register [Reads: Y Index] [Flags: ZNC]
	ldx $02.b		; A6 02 ; Load $02.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($2F.b,S),Y		; D3 2F ; Compare accumulator (stack relative indirect indexed) ($2F.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	eor ($2F.b),Y		; 51 2F ; Exclusive OR accumulator with memory ($2F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cmp [$FB.b],Y		; D7 FB ; Compare accumulator (long indexed) [$FB.b],Y [Reads: Accumulator, Direct Page, Y Index] [Flags: ZNC]
	sbc [$FB.b]		; E7 FB ; Subtract with carry (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	rol $3A.b,X		; 36 3A ; Rotate left $3A.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	jsl $D71400.l		; 22 00 14 D7 ; Jump to subroutine long $D71400.l [Writes: Stack Pointer] [Flow: call]
	cmp ($2B.b,S),Y		; D3 2B ; Compare accumulator (stack relative indirect indexed) ($2B.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	wai		; CB ; Wait for interrupt
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sbc [$BF.b]		; E7 BF ; Subtract with carry (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $5FFF7F.l,X		; FF 7F FF 5F ; Subtract with carry (long,X) $5FFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $B51F.w		; EE 1F B5 ; Increment $B51F.w [Flags: ZN]
	asl $0C12.w		; 0E 12 0C ; Arithmetic shift left $0C12.w [Flags: ZNC]
	tsb $0022.w		; 0C 22 00 ; Test and set bits $0022.w [Reads: Accumulator] [Flags: Z]
	jsl $EE06FF.l		; 22 FF 06 EE ; Jump to subroutine long $EE06FF.l [Writes: Stack Pointer] [Flow: call]
	lda $12.b,X		; B5 12 ; Load $12.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $C000.w		; 0C 00 C0 ; Test and set bits $C000.w [Reads: Accumulator] [Flags: Z]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $80, $28		; 80 28 ; Branch always to $80, $28 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F8,$00		; 44 00 F8 ; Move block positive $F8,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: ZNC]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $28.b		; E6 28 ; Increment $28.b [Reads: Direct Page] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$00.b]		; 67 00 ; Add with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $79,$00		; 44 00 79 ; Move block positive $79,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $4500.w		; 2C 00 45 ; Test bits $4500.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ora $7F4400.l,X		; 1F 00 44 7F ; Logical OR long $7F4400.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($67.b,X)		; 01 67 ; Logical OR ($67.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor #$007F.w		; 49 7F 00 ; Exclusive OR #$007F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($0C.b)		; 72 0C ; Add with carry (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	inc $2300.w,X		; FE 00 23 ; Increment memory $2300.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $25		; 80 25 ; Branch always to $80, $25 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $7E,$00		; 44 00 7E ; Move block positive $7E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $7F.b,S		; 43 7F ; Exclusive OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $7E02.w,X		; 3C 02 7E ; Test bits $7E02.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $4300.w		; 2C 00 43 ; Test bits $4300.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $0200.w,X		; 7E 00 02 ; Rotate right $0200.w,X [Reads: X Index] [Flags: ZNC]
	inc $18.b		; E6 18 ; Increment $18.b [Reads: Direct Page] [Flags: ZN]
	inc $0043.w,X		; FE 43 00 ; Increment memory $0043.w,X [Reads: X Index] [Flags: ZN]
	ror $002D.w,X		; 7E 2D 00 ; Rotate right $002D.w,X [Reads: X Index] [Flags: ZNC]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ror $0044.w,X		; 7E 44 00 ; Rotate right $0044.w,X [Reads: X Index] [Flags: ZNC]
	inc $7E43.w,X		; FE 43 7E ; Increment memory $7E43.w,X [Reads: X Index] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $25.b		; 66 25 ; Rotate right $25.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($66.b,X)		; 01 66 ; Logical OR ($66.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ror $2A00.w,X		; 7E 00 2A ; Rotate right $2A00.w,X [Reads: X Index] [Flags: ZNC]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $730600.l,X		; 7F 00 06 73 ; Add long $730600.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp $7E00.w		; 4C 00 7E ; Jump to $7E00.w [Flow: jump]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ror $2800.w,X		; 7E 00 28 ; Rotate right $2800.w,X [Reads: X Index] [Flags: ZNC]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0200.w,X		; 7E 00 02 ; Rotate right $0200.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $7F00.w		; 4D 00 7F ; Exclusive OR $7F00.w with accumulator [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $FE,$00		; 44 00 FE ; Move block positive $FE,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $2A00.w,X		; FE 00 2A ; Increment memory $2A00.w,X [Reads: X Index] [Flags: ZN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($0C.b)		; F2 0C ; Subtract with carry (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc $2800.w,X		; FE 00 28 ; Increment memory $2800.w,X [Reads: X Index] [Flags: ZN]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $2800.w,X		; 7E 00 28 ; Rotate right $2800.w,X [Reads: X Index] [Flags: ZNC]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $3300.w,X		; 7E 00 33 ; Rotate right $3300.w,X [Reads: X Index] [Flags: ZNC]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	.db $42, $3C		; 42 3C ; Reserved instruction
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	mvp $00,$7E		; 44 7E 00 ; Move block positive $00,$7E [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $78.b		; 02 78 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $2978.w,X		; 7E 78 29 ; Rotate right $2978.w,X [Reads: X Index] [Flags: ZNC]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $063C.w,X		; 7E 3C 06 ; Rotate right $063C.w,X [Reads: X Index] [Flags: ZNC]
	adc $006700.l,X		; 7F 00 67 00 ; Add long $006700.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $42, $00		; 42 00 ; Reserved instruction
	ror $26.b		; 66 26 ; Rotate right $26.b [Reads: Direct Page] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $1F.b,S		; 43 1F ; Exclusive OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2A00.w,X		; 1E 00 2A ; Arithmetic shift left $2A00.w,X [Reads: X Index] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.INDEX 8
	sep #$10		; E2 10
	inc $0044.w,X		; FE 44 00 ; Increment memory $0044.w,X [Reads: X Index] [Flags: ZN]
	sbc $00FE45.l,X		; FF 45 FE 00 ; Subtract with carry (long,X) $00FE45.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $0025.w		; 0C 25 00 ; Test and set bits $0025.w [Reads: Accumulator] [Flags: Z]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7E,$00		; 44 00 7E ; Move block positive $7E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $7F.b,S		; 43 7F ; Exclusive OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7E00.w,X		; 7E 00 7E ; Rotate right $7E00.w,X [Reads: X Index] [Flags: ZNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $7E,$00		; 44 00 7E ; Move block positive $7E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $7F.b,S		; 43 7F ; Exclusive OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7E00.w,X		; 7E 00 7E ; Rotate right $7E00.w,X [Reads: X Index] [Flags: ZNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $4300.w,X		; 7E 00 43 ; Rotate right $4300.w,X [Reads: X Index] [Flags: ZNC]
	inc $0200.w,X		; FE 00 02 ; Increment memory $0200.w,X [Reads: X Index] [Flags: ZN]
	ror $7E00.w,X		; 7E 00 7E ; Rotate right $7E00.w,X [Reads: X Index] [Flags: ZNC]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	eor [$3C.b]		; 47 3C ; Exclusive OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $7E,$00		; 44 00 7E ; Move block positive $7E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $7F.b,S		; 43 7F ; Exclusive OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $2E00.w,X		; 7E 00 2E ; Rotate right $2E00.w,X [Reads: X Index] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $30FF00.l,X		; FF 00 FF 30 ; Subtract with carry (long,X) $30FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $4300.w,X		; FE 00 43 ; Increment memory $4300.w,X [Reads: X Index] [Flags: ZN]
	sbc $FE4300.l,X		; FF 00 43 FE ; Subtract with carry (long,X) $FE4300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000028.l,X		; FF 28 00 00 ; Subtract with carry (long,X) $000028.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $FE0044.l,X		; FF 44 00 FE ; Subtract with carry (long,X) $FE0044.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0900.w,X		; FE 00 09 ; Increment memory $0900.w,X [Reads: X Index] [Flags: ZN]
	sbc $807F00.l,X		; FF 00 7F 80 ; Subtract with carry (long,X) $807F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $7EC0.w,X		; 3E C0 7E ; Rotate left $7EC0.w,X [Reads: X Index] [Flags: ZNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $80, $27		; 80 27 ; Branch always to $80, $27 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $7E,$00		; 44 00 7E ; Move block positive $7E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0000.w,X		; 7E 00 00 ; Rotate right $0000.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $7F,$00		; 44 00 7F ; Move block positive $7F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FF0000.l,X		; 7F 00 00 FF ; Add long $FF0000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $7E,$00		; 44 00 7E ; Move block positive $7E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $7E,$00		; 44 00 7E ; Move block positive $7E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $2800.w,X		; 7E 00 28 ; Rotate right $2800.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $FE,$00		; 44 00 FE ; Move block positive $FE,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FE00.w,X		; FE 00 FE ; Increment memory $FE00.w,X [Reads: X Index] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	.db $30, $49		; 30 49 ; Branch if minus to $30, $49 [Flow: branch]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($28.b),Y		; 31 28 ; AND accumulator with memory ($28.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($46.b),Y		; 31 46 ; AND accumulator with memory ($46.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $7B.b		; 00 7B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$7E.b]		; 07 7E ; OR accumulator with memory (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($7C.b,X)		; 01 7C ; Logical OR ($7C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $7E.b,S		; 03 7E ; OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $034500.l,X		; 7F 00 45 03 ; Add long $034500.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $7F00.w		; 4C 00 7F ; Jump to $7F00.w [Flow: jump]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FE004C.l,X		; FF 4C 00 FE ; Subtract with carry (long,X) $FE004C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0044.w,X		; FE 44 00 ; Increment memory $0044.w,X [Reads: X Index] [Flags: ZN]
	ror $7F43.w,X		; 7E 43 7F ; Rotate right $7F43.w,X [Reads: X Index] [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3C4300.l,X		; 3F 00 43 3C ; AND accumulator with memory (long,X) $3C4300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $4300.w,Y		; 19 00 43 ; OR accumulator with memory $4300.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $180000.l,X		; 7F 00 00 18 ; Add long $180000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F200.w,X		; FE 00 F2 ; Increment memory $F200.w,X [Reads: X Index] [Flags: ZN]
	tsb $FE43.w		; 0C 43 FE ; Test and set bits $FE43.w [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $80, $2C		; 80 2C ; Branch always to $80, $2C [Flow: branch]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $4300.w,X		; 7E 00 43 ; Rotate right $4300.w,X [Reads: X Index] [Flags: ZNC]
	sbc $7E4400.l,X		; FF 00 44 7E ; Subtract with carry (long,X) $7E4400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2E1F00.l,X		; 1F 00 1F 2E ; Logical OR long $2E1F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp $7E00.w		; 4C 00 7E ; Jump to $7E00.w [Flow: jump]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $4300.w,X		; FE 00 43 ; Increment memory $4300.w,X [Reads: X Index] [Flags: ZN]
	sbc $FE4400.l,X		; FF 00 44 FE ; Subtract with carry (long,X) $FE4400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $600000.l,X		; 1F 00 00 60 ; Logical OR long $600000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lsr $7F.b		; 46 7F ; Logical shift right $7F.b [Reads: Direct Page] [Flags: ZNC]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7E		; 80 7E ; Branch always to $80, $7E [Flow: branch]
	sty $39.b		; 84 39 ; Store Y register to $39.b [Reads: Y Index]
	ora $46.b,S		; 03 46 ; OR accumulator with stack relative $46.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $2A00.w,X		; FE 00 2A ; Increment memory $2A00.w,X [Reads: X Index] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0200.w,X		; 7E 00 02 ; Rotate right $0200.w,X [Reads: X Index] [Flags: ZNC]
	inc $E600.w,X		; FE 00 E6 ; Increment memory $E600.w,X [Reads: X Index] [Flags: ZN]
	sty $E3.b		; 84 E3 ; Store Y register to $E3.b [Reads: Y Index]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0200.w		; 29 00 02 ; Logical AND #$0200.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: ZNC]
	ror $4983.w,X		; 7E 83 49 ; Rotate right $4983.w,X [Reads: X Index] [Flags: ZNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $60.b		; 02 60 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $66.b		; 06 66 ; Arithmetic shift left $66.b [Reads: Direct Page] [Flags: ZNC]
	mvp $7F,$00		; 44 00 7F ; Move block positive $7F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $66.b		; 02 66 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0300.w		; 2C 00 03 ; Test bits $0300.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $43FC.w		; 0C FC 43 ; Test and set bits $43FC.w [Reads: Accumulator] [Flags: Z]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $4700.w		; 2C 00 47 ; Test bits $4700.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $0200.w,X		; 7E 00 02 ; Rotate right $0200.w,X [Reads: X Index] [Flags: ZNC]
	lsr $7E30.w		; 4E 30 7E ; Logical shift right $7E30.w [Flags: ZNC]
	bit $4300.w		; 2C 00 43 ; Test bits $4300.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $4300.w,X		; 7E 00 43 ; Rotate right $4300.w,X [Reads: X Index] [Flags: ZNC]
	adc $7E4400.l,X		; 7F 00 44 7E ; Add long $7E4400.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ror $2B00.w,X		; 7E 00 2B ; Rotate right $2B00.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $18.b,S		; 43 18 ; Exclusive OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $180000.l,X		; 1F 00 00 18 ; Logical OR long $180000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $18.b		; 45 18 ; Exclusive OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $184400.l,X		; FF 00 44 18 ; Subtract with carry (long,X) $184400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $4300.w,X		; 7E 00 43 ; Rotate right $4300.w,X [Reads: X Index] [Flags: ZNC]
	sbc $7E0200.l,X		; FF 00 02 7E ; Subtract with carry (long,X) $7E0200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0300.w		; 2C 00 03 ; Test bits $0300.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $F8.b,S		; 43 F8 ; Exclusive OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $4300.w		; 2C 00 43 ; Test bits $4300.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $4300.w,X		; 7E 00 43 ; Rotate right $4300.w,X [Reads: X Index] [Flags: ZNC]
	adc $4E0200.l,X		; 7F 00 02 4E ; Add long $4E0200.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($30.b,X)		; 01 30 ; Logical OR ($30.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: ZNC]
	mvp $E6,$00		; 44 00 E6 ; Move block positive $E6,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $7E.b		; 02 7E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0200.w		; 2C 00 02 ; Test bits $0200.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $7E00.w,X		; 7E 00 7E ; Rotate right $7E00.w,X [Reads: X Index] [Flags: ZNC]
	mvp $7F,$30		; 44 30 7F ; Move block positive $7F,$30 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $7E.b		; 02 7E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $7E		; 30 7E ; Branch if minus to $30, $7E [Flow: branch]
	bit $0200.w		; 2C 00 02 ; Test bits $0200.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	ror $0044.w,X		; 7E 44 00 ; Rotate right $0044.w,X [Reads: X Index] [Flags: ZNC]
	adc $007E02.l,X		; 7F 02 7E 00 ; Add long $007E02.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $002D.w,X		; 7E 2D 00 ; Rotate right $002D.w,X [Reads: X Index] [Flags: ZNC]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	tsb $0044.w		; 0C 44 00 ; Test and set bits $0044.w [Reads: Accumulator] [Flags: Z]
	jsr ($0C02.w,X)		; FC 02 0C ; Jump to subroutine indirect indexed ($0C02.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	ror $6607.w,X		; 7E 07 66 ; Rotate right $6607.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $42, $3C		; 42 3C ; Reserved instruction
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ror $19.b		; 66 19 ; Rotate right $19.b [Reads: Direct Page] [Flags: ZNC]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	adc $002800.l,X		; 7F 00 28 00 ; Add long $002800.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor [$7F.b]		; 47 7F ; Exclusive OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7C01.w,X		; 7E 01 7C ; Rotate right $7C01.w,X [Reads: X Index] [Flags: ZNC]
	ora $7E.b,S		; 03 7E ; OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0000.w,X		; 7E 00 00 ; Rotate right $0000.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ror $0044.w,X		; 7E 44 00 ; Rotate right $0044.w,X [Reads: X Index] [Flags: ZNC]
	adc $007E02.l,X		; 7F 02 7E 00 ; Add long $007E02.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $002A.w,X		; 7E 2A 00 ; Rotate right $002A.w,X [Reads: X Index] [Flags: ZNC]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $7E,$00		; 44 00 7E ; Move block positive $7E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7E00.w,X		; 7E 00 7E ; Rotate right $7E00.w,X [Reads: X Index] [Flags: ZNC]
	bit $4300.w		; 2C 00 43 ; Test bits $4300.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $4300.w,X		; 7E 00 43 ; Rotate right $4300.w,X [Reads: X Index] [Flags: ZNC]
	adc $7E0200.l,X		; 7F 00 02 7E ; Add long $7E0200.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $4A00.w		; 2C 00 4A ; Test bits $4A00.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $2C00.w,X		; 7E 00 2C ; Rotate right $2C00.w,X [Reads: X Index] [Flags: ZNC]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $002C00.l,X		; 7F 00 2C 00 ; Add long $002C00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FE0200.l,X		; FF 00 02 FE ; Subtract with carry (long,X) $FE0200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $4300.w		; 2C 00 43 ; Test bits $4300.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $4300.w,X		; 7E 00 43 ; Rotate right $4300.w,X [Reads: X Index] [Flags: ZNC]
	inc $4400.w,X		; FE 00 44 ; Increment memory $4400.w,X [Reads: X Index] [Flags: ZN]
	ror $2A00.w,X		; 7E 00 2A ; Rotate right $2A00.w,X [Reads: X Index] [Flags: ZNC]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $180000.l,X		; 7F 00 00 18 ; Add long $180000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $2A00.w,X		; FE 00 2A ; Increment memory $2A00.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $7E,$00		; 44 00 7E ; Move block positive $7E,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7E00.w,X		; 7E 00 7E ; Rotate right $7E00.w,X [Reads: X Index] [Flags: ZNC]
	bit $0200.w		; 2C 00 02 ; Test bits $0200.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	ror $0044.w,X		; 7E 44 00 ; Rotate right $0044.w,X [Reads: X Index] [Flags: ZNC]
	sbc $007E43.l,X		; FF 43 7E 00 ; Subtract with carry (long,X) $007E43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	ror $0044.w,X		; 7E 44 00 ; Rotate right $0044.w,X [Reads: X Index] [Flags: ZNC]
	sbc $007E02.l,X		; FF 02 7E 00 ; Subtract with carry (long,X) $007E02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $002C.w,X		; 7E 2C 00 ; Rotate right $002C.w,X [Reads: X Index] [Flags: ZNC]
	eor $7E.b,S		; 43 7E ; Exclusive OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7E0200.l,X		; FF 00 02 7E ; Subtract with carry (long,X) $7E0200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $3C43.w,X		; 7E 43 3C ; Rotate right $3C43.w,X [Reads: X Index] [Flags: ZNC]
	ror $2B85.w,X		; 7E 85 2B ; Rotate right $2B85.w,X [Reads: X Index] [Flags: ZNC]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $7F00.w		; 4D 00 7F ; Exclusive OR $7F00.w with accumulator [Writes: Accumulator] [Flags: ZN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FF4300.l,X		; 7F 00 43 FF ; Add long $FF4300.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $2C7F00.l,X		; 7F 00 7F 2C ; Add long $2C7F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FF4300.l,X		; 7F 00 43 FF ; Add long $FF4300.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $180000.l,X		; 7F 00 00 18 ; Add long $180000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $18.b		; E6 18 ; Increment $18.b [Reads: Direct Page] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	inc $2C00.w,X		; FE 00 2C ; Increment memory $2C00.w,X [Reads: X Index] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0600.w,X		; 7E 00 06 ; Rotate right $0600.w,X [Reads: X Index] [Flags: ZNC]
	inc $E600.w,X		; FE 00 E6 ; Increment memory $E600.w,X [Reads: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $7E00.w,X		; 7E 00 7E ; Rotate right $7E00.w,X [Reads: X Index] [Flags: ZNC]
	bit $0100.w		; 2C 00 01 ; Test bits $0100.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	ror $4A01.w,X		; 7E 01 4A ; Rotate right $4A01.w,X [Reads: X Index] [Flags: ZNC]
	adc $002800.l,X		; 7F 00 28 00 ; Add long $002800.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $4A		; 80 4A ; Branch always to $80, $4A [Flow: branch]
	inc $2800.w,X		; FE 00 28 ; Increment memory $2800.w,X [Reads: X Index] [Flags: ZN]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $002C00.l,X		; 7F 00 2C 00 ; Add long $002C00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	cop $66.b		; 02 66 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $0044.w,X		; 7E 44 00 ; Rotate right $0044.w,X [Reads: X Index] [Flags: ZNC]
	adc $007E02.l,X		; 7F 02 7E 00 ; Add long $007E02.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $002A.w,X		; 7E 2A 00 ; Rotate right $002A.w,X [Reads: X Index] [Flags: ZNC]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $7E00.w		; 4C 00 7E ; Jump to $7E00.w [Flow: jump]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $002A00.l,X		; 7F 00 2A 00 ; Add long $002A00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($E6.b,X)		; 01 E6 ; Logical OR ($E6.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc $2A00.w,X		; FE 00 2A ; Increment memory $2A00.w,X [Reads: X Index] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: ZNC]
	rol $0049.w,X		; 3E 49 00 ; Rotate left $0049.w,X [Reads: X Index] [Flags: ZNC]
	asl $28.b		; 06 28 ; Arithmetic shift left $28.b [Reads: Direct Page] [Flags: ZNC]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	asl $2A.b		; 06 2A ; Arithmetic shift left $2A.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	ror $AA83.w,X		; 7E 83 AA ; Rotate right $AA83.w,X [Reads: X Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $28.b		; 66 28 ; Rotate right $28.b [Reads: Direct Page] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $7E4300.l		; 22 00 43 7E ; Jump to subroutine long $7E4300.l [Writes: Stack Pointer] [Flow: call]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $4E0200.l,X		; 7F 00 02 4E ; Add long $4E0200.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $7E		; 30 7E ; Branch if minus to $30, $7E [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $4300.w,X		; 7E 00 43 ; Rotate right $4300.w,X [Reads: X Index] [Flags: ZNC]
	inc $0400.w,X		; FE 00 04 ; Increment memory $0400.w,X [Reads: X Index] [Flags: ZN]
	ror $1800.w,X		; 7E 00 18 ; Rotate right $1800.w,X [Reads: X Index] [Flags: ZNC]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FE0044.l,X		; FF 44 00 FE ; Subtract with carry (long,X) $FE0044.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0044.w,X		; FE 44 00 ; Increment memory $0044.w,X [Reads: X Index] [Flags: ZN]
	ror $FF43.w,X		; 7E 43 FF ; Rotate right $FF43.w,X [Reads: X Index] [Flags: ZNC]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $2900.w,X		; DE 00 29 ; Decrement memory $2900.w,X [Reads: X Index] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $4578.w,X		; FE 78 45 ; Increment memory $4578.w,X [Reads: X Index] [Flags: ZN]
	ror $8500.w,X		; 7E 00 85 ; Rotate right $8500.w,X [Reads: X Index] [Flags: ZNC]
	sep #$00		; E2 00 ; Set processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $E500.w,X		; FE 00 E5 ; Increment memory $E500.w,X [Reads: X Index] [Flags: ZN]
	adc ($00.b)		; 72 00 ; Add with carry (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $0020E0.l,X		; FF E0 20 00 ; Subtract with carry (long,X) $0020E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	and $001700.l		; 2F 00 17 00 ; AND accumulator with memory (long) $001700.l [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $317A.w,X		; 3C 7A 31 ; Test bits $317A.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	ora $2C1C.w,Y		; 19 1C 2C ; OR accumulator with memory $2C1C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rol $001C.w,X		; 3E 1C 00 ; Rotate left $001C.w,X [Reads: X Index] [Flags: ZNC]
	and ($0C.b)		; 32 0C ; AND accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp ($BC00.w)		; 6C 00 BC ; Jump indirect to ($BC00.w) [Flow: jump]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $FE,$00		; 44 00 FE ; Move block positive $FE,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora #$00BE.w		; 09 BE 00 ; Logical OR #$00BE.w with accumulator [Writes: Accumulator] [Flags: ZN]
	trb $542E.w		; 1C 2E 54 ; Test and reset bits $542E.w [Reads: Accumulator] [Flags: Z]
	jsr ($A2C4.w,X)		; FC C4 A2 ; Jump to subroutine indirect indexed ($A2C4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldx #$5E.b		; A2 5E ; Load #$5E.b into X register [Writes: X Index] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($40.b,X)		; 01 40 ; Logical OR ($40.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $5F0240.l,X		; BF 40 02 5F ; Load long $5F0240.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr $233B.w		; 20 3B 23 ; Jump to subroutine at $233B.w [Writes: Stack Pointer] [Flow: call]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sbc $2461CE.l,X		; FF CE 61 24 ; Subtract with carry (long,X) $2461CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	inc $BE00.w,X		; FE 00 BE ; Increment memory $BE00.w,X [Reads: X Index] [Flags: ZN]
	jsl $0E0500.l		; 22 00 05 0E ; Jump to subroutine long $0E0500.l [Writes: Stack Pointer] [Flow: call]
	adc $A2C6.w,Y		; 79 C6 A2 ; Add $A2C6.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ldx #$5E.b		; A2 5E ; Load #$5E.b into X register [Writes: X Index] [Flags: ZN]
	and #$0400.w		; 29 00 04 ; Logical AND #$0400.w with accumulator [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$28.b],Y		; 17 28 ; OR accumulator with memory (long indexed) [$28.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $1F.b		; 84 1F ; Store Y register to $1F.b [Reads: Y Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $080024.l,X		; FF 24 00 08 ; Subtract with carry (long,X) $080024.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy $A2.b		; C4 A2 ; Compare $A2.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	lda $00.b,S		; A3 00 ; Load accumulator (stack relative) $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $54,$2B		; 44 2B 54 ; Move block positive $54,$2B [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $55.b,S		; 23 55 ; AND accumulator with stack relative $55.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $540777.l		; 22 77 07 54 ; Jump to subroutine long $540777.l [Writes: Stack Pointer] [Flow: call]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $EE00.w,X		; FE 00 EE ; Increment memory $EE00.w,X [Reads: X Index] [Flags: ZN]
	mvp $2A,$D4		; 44 D4 2A ; Move block positive $2A,$D4 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $6A.b		; C4 6A ; Compare $6A.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	pei ($00.b)		; D4 00 ; Push effective indirect address ($00.b) [Reads: Direct Page] [Writes: Stack Pointer]
	inc $EE22.w,X		; FE 22 EE ; Increment memory $EE22.w,X [Reads: X Index] [Flags: ZN]
	cop $2A.b		; 02 2A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $84EE.w		; EE EE 84 ; Increment $84EE.w [Flags: ZN]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	mvp $54,$2B		; 44 2B 54 ; Move block positive $54,$2B [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sta [$9A.b]		; 87 9A ; Store accumulator (long) [$9A.b] [Reads: Accumulator, Direct Page]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$87.b],Y		; 77 87 ; Add with carry (long indexed) [$87.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $2A,$D4		; 44 D4 2A ; Move block positive $2A,$D4 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sta [$B2.b]		; 87 B2 ; Store accumulator (long) [$B2.b] [Reads: Accumulator, Direct Page]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $32E0.w		; EE E0 32 ; Increment $32E0.w [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	inc $03EE.w		; EE EE 03 ; Increment $03EE.w [Flags: ZN]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $13.b		; 02 13 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $123D.w		; 0C 3D 12 ; Test and set bits $123D.w [Reads: Accumulator] [Flags: Z]
	and ($0C.b,S),Y		; 33 0C ; AND accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $3112.w,X		; 3D 12 31 ; AND accumulator with memory $3112.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	asl $1C33.w		; 0E 33 1C ; Arithmetic shift left $1C33.w [Flags: ZNC]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $3E3F3E.l,X		; 1F 3E 3F 3E ; Logical OR long $3E3F3E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $C03F.w,X		; 3E 3F C0 ; Rotate left $C03F.w,X [Reads: X Index] [Flags: ZNC]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $BC		; 30 BC ; Branch if minus to $30, $BC [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cpy $BC30.w		; CC 30 BC ; Compare $BC30.w with Y register [Reads: Y Index] [Flags: ZNC]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sty $CC70.w		; 8C 70 CC ; Store Y register to $CC70.w [Reads: Y Index]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$70.b		; C0 70 ; Compare #$70.b with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp ($7CFC.w,X)		; 7C FC 7C ; Jump indirect indexed to ($7CFC.w,X) [Reads: X Index] [Flow: jump]
	jmp ($F0FC.w,X)		; 7C FC F0 ; Jump indirect indexed to ($F0FC.w,X) [Reads: X Index] [Flow: jump]
	and $0E00F0.l		; 2F F0 00 0E ; AND accumulator with memory (long) $0E00F0.l [Writes: Accumulator] [Flags: ZN]
	mvp $22,$00		; 44 00 22 ; Move block positive $22,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $59.b		; 00 59 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $106F.w		; 20 6F 10 ; Jump to subroutine at $106F.w [Writes: Stack Pointer] [Flow: call]
	adc $00DF00.l,X		; 7F 00 DF 00 ; Add long $00DF00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $E00022.l		; 6F 22 00 E0 ; Add with carry (long) $E00022.l [Writes: Accumulator] [Flags: ZVNC]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	jsr $5A71.w		; 20 71 5A ; Jump to subroutine at $5A71.w [Writes: Stack Pointer] [Flow: call]
	lsr $62.b		; 46 62 ; Logical shift right $62.b [Reads: Direct Page] [Flags: ZNC]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $F6.b		; 04 F6 ; Test and set bits $F6.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $E200.w,X		; FE 00 E2 ; Increment memory $E200.w,X [Reads: X Index] [Flags: ZN]
	bit $3EF1.w,X		; 3C F1 3E ; Test bits $3EF1.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $001E.w,X		; FD 1E 00 ; Subtract with carry $001E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ldx $7FFE.w,Y		; BE FE 7F ; Load X register $7FFE.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	and $0B0013.l,X		; 3F 13 00 0B ; AND accumulator with memory (long,X) $0B0013.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0C.b)		; 12 0C ; OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $0022.w		; 0C 22 00 ; Test and set bits $0022.w [Reads: Accumulator] [Flags: Z]
	ora ($1C.b)		; 12 1C ; OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $170E.w		; 0C 0E 17 ; Test and set bits $170E.w [Reads: Accumulator] [Flags: Z]
	ora ($1E.b,S),Y		; 13 1E ; OR accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $E200.w		; 0C 00 E2 ; Test and set bits $E200.w [Reads: Accumulator] [Flags: Z]
	trb $1CFA.w		; 1C FA 1C ; Test and reset bits $1CFA.w [Reads: Accumulator] [Flags: Z]
	sta $3D0E.w,X		; 9D 0E 3D ; Store accumulator to $3D0E.w,X [Reads: Accumulator, X Index]
	asl $26DF.w		; 0E DF 26 ; Arithmetic shift left $26DF.w [Flags: ZNC]
	ror $0024.w		; 6E 24 00 ; Rotate right $0024.w [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ror $7F3E.w,X		; 7E 3E 7F ; Rotate right $7F3E.w,X [Reads: X Index] [Flags: ZNC]
	sbc $006EDF.l,X		; FF DF 6E 00 ; Subtract with carry (long,X) $006EDF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$0183.w		; 89 83 01 ; Test bits #$0183.w with accumulator [Reads: Accumulator] [Flags: Z]
	jsl $1E0100.l		; 22 00 01 1E ; Jump to subroutine long $1E0100.l [Writes: Stack Pointer] [Flow: call]
	ora $019290.l		; 0F 90 92 01 ; OR accumulator with memory (long) $019290.l [Writes: Accumulator] [Flags: ZN]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta [$A8.b]		; 87 A8 ; Store accumulator (long) [$A8.b] [Reads: Accumulator, Direct Page]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $007E00.l		; 2F 00 7E 00 ; AND accumulator with memory (long) $007E00.l [Writes: Accumulator] [Flags: ZN]
	lda $B340.w,Y		; B9 40 B3 ; Load $B340.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jmp $843320.l		; 5C 20 33 84 ; Jump long to $843320.l [Flow: jump]
	bit #$0801.w		; 89 01 08 ; Test bits #$0801.w with accumulator [Reads: Accumulator] [Flags: Z]
	bit $E671.w,X		; 3C 71 E6 ; Test bits $E671.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	dec $336F.w		; CE 6F 33 ; Decrement $336F.w [Flags: ZN]
	asl $BF0C.w,X		; 1E 0C BF ; Arithmetic shift left $BF0C.w,X [Reads: X Index] [Flags: ZNC]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta [$01.b],Y		; 97 01 ; Store accumulator (long indexed) [$01.b],Y [Reads: Accumulator, Direct Page, Y Index]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $5F0000.l		; 22 00 00 5F ; Jump to subroutine long $5F0000.l [Writes: Stack Pointer] [Flow: call]
	sty $A8.b		; 84 A8 ; Store Y register to $A8.b [Reads: Y Index]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($7E.b),Y		; 31 7E ; AND accumulator with memory ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	adc [$2A.b],Y		; 77 2A ; Add with carry (long indexed) [$2A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor ($3E.b,X)		; 41 3E ; Exclusive OR accumulator with memory ($3E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $2A7700.l,X		; 7F 00 77 2A ; Add long $2A7700.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$2B.b],Y		; 77 2B ; Add with carry (long indexed) [$2B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and $77007F.l,X		; 3F 7F 00 77 ; AND accumulator with memory (long,X) $77007F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc [$40.b],Y		; 77 40 ; Add with carry (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $7777.w,X		; 7E 77 77 ; Rotate right $7777.w,X [Reads: X Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $EED4EE.l,X		; 7F EE D4 EE ; Add long $EED4EE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	mvn $7C,$82		; 54 82 7C ; Move block negative $7C,$82 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	inc $EE00.w,X		; FE 00 EE ; Increment memory $EE00.w,X [Reads: X Index] [Flags: ZN]
	mvn $D4,$EE		; 54 EE D4 ; Move block negative $D4,$EE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $EE00.w,X		; FE 00 EE ; Increment memory $EE00.w,X [Reads: X Index] [Flags: ZN]
	inc $7E02.w		; EE 02 7E ; Increment $7E02.w [Flags: ZN]
	inc $02EE.w		; EE EE 02 ; Increment $02EE.w [Flags: ZN]
	inc $2FF0.w,X		; FE F0 2F ; Increment memory $2FF0.w,X [Reads: X Index] [Flags: ZN]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $0F3C13.l,X		; 3F 13 3C 0F ; AND accumulator with memory (long,X) $0F3C13.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $3F1F20.l,X		; 1F 20 1F 3F ; Logical OR long $3F1F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $75.b		; 84 75 ; Store Y register to $75.b [Reads: Y Index]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3F200F.l,X		; 3F 0F 20 3F ; AND accumulator with memory (long,X) $3F200F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $FC3F20.l,X		; 3F 20 3F FC ; AND accumulator with memory (long,X) $FC3F20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	bit $1CF0.w,X		; 3C F0 1C ; Test bits $1CF0.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	jsr ($FC00.w,X)		; FC 00 FC ; Jump to subroutine indirect indexed ($FC00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sty $8D.b		; 84 8D ; Store Y register to $8D.b [Reads: Y Index]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($0404.w,X)		; FC 04 04 ; Jump to subroutine indirect indexed ($0404.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($04FC.w,X)		; FC FC 04 ; Jump to subroutine indirect indexed ($04FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($708F.w,X)		; FC 8F 70 ; Jump to subroutine indirect indexed ($708F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $028394.l,X		; 3F 94 83 02 ; AND accumulator with memory (long,X) $028394.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $9B84FC.l		; 22 FC 84 9B ; Jump to subroutine long $9B84FC.l [Writes: Stack Pointer] [Flow: call]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $120027.l		; 2F 27 00 12 ; AND accumulator with memory (long) $120027.l [Writes: Accumulator] [Flags: ZN]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $5F2F.w,X		; 1D 2F 5F ; OR accumulator with memory $5F2F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $051C.w,X		; 3E 1C 05 ; Rotate left $051C.w,X [Reads: X Index] [Flags: ZNC]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $6E.b		; 06 6E ; Arithmetic shift left $6E.b [Reads: Direct Page] [Flags: ZNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $906E.w		; 0C 6E 90 ; Test and set bits $906E.w [Reads: Accumulator] [Flags: Z]
	jmp.w [$F820]		; DC 20 F8 ; Jump long indirect [$F820] [Flow: jump]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $F6FC.w,X		; 9E FC F6 ; Store zero to $F6FC.w,X [Reads: X Index]
	inc $F8DC.w		; EE DC F8 ; Increment $F8DC.w [Flags: ZN]
	.db $80, $E4		; 80 E4 ; Branch always to $80, $E4 [Flow: branch]
	sta ($00.b),Y		; 91 00 ; Store accumulator ($00.b),Y [Reads: Accumulator, Direct Page, Y Index]
	cpx #$2D.b		; E0 2D ; Compare #$2D.b with X register [Reads: X Index] [Flags: ZNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0A1400.l		; 0F 00 14 0A ; OR accumulator with memory (long) $0A1400.l [Writes: Accumulator] [Flags: ZN]
	jsl $1E211D.l		; 22 1D 21 1E ; Jump to subroutine long $1E211D.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($44.b,X)		; 21 44 ; Logical AND ($44.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	lsr $00E0.w		; 4E E0 00 ; Logical shift right $00E0.w [Flags: ZNC]
	eor ($00.b)		; 52 00 ; Exclusive OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jmp ($2800.w,X)		; 7C 00 28 ; Jump indirect indexed to ($2800.w,X) [Reads: X Index] [Flow: jump]
	.db $50, $44		; 50 44 ; Branch if overflow clear to $50, $44 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sty $68.b		; 84 68 ; Store Y register to $68.b [Reads: Y Index]
	jsl $0C7284.l		; 22 84 72 0C ; Jump to subroutine long $0C7284.l [Writes: Stack Pointer] [Flow: call]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $A8		; F0 A8 ; Branch if equal to $F0, $A8 [Flow: branch]
	mvp $5A,$94		; 44 94 5A ; Move block positive $5A,$94 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $82, $90, $90		; 82 90 90 ; Branch always long to $82, $90, $90 [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $85.b,S		; 03 85 ; OR accumulator with stack relative $85.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ldx #$03.b		; A2 03 ; Load #$03.b into X register [Writes: X Index] [Flags: ZN]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$03AF.w		; 89 AF 03 ; Test bits #$03AF.w with accumulator [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$A0.b		; E0 A0 ; Compare #$A0.b with X register [Reads: X Index] [Flags: ZNC]
	sta ($BC.b),Y		; 91 BC ; Store accumulator ($BC.b),Y [Reads: Accumulator, Direct Page, Y Index]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor ($30.b,X)		; 41 30 ; Exclusive OR accumulator with memory ($30.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta ($A0.b,S),Y		; 93 A0 ; Store accumulator (stack relative indirect indexed) ($A0.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $8C.b		; 02 8C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $86, $B7		; 82 86 B7 ; Branch always long to $82, $86, $B7 [Flow: branch]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc ($72.b)		; 72 72 ; Add with carry (indirect) ($72.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $95.b		; 85 95 ; Store accumulator to $95.b [Reads: Accumulator]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $40.b,X		; 16 40 ; Arithmetic shift left $40.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and ($41.b),Y		; 31 41 ; AND accumulator with memory ($41.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	and #$4E4E.w		; 29 4E 4E ; Logical AND #$4E4E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $85		; F0 85 ; Branch if equal to $F0, $85 [Flow: branch]
	lda $0C03.w		; AD 03 0C ; Load $0C03.w into accumulator [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cop $DC.b		; 02 DC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $0C, $00		; 82 0C 00 ; Branch always long to $82, $0C, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $70, $A8		; 70 A8 ; Branch if overflow set to $70, $A8 [Flow: branch]
	mvp $22,$84		; 44 84 22 ; Move block positive $22,$84 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	adc ($E4.b)		; 72 E4 ; Add with carry (indirect) ($E4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	lda $2FE000.l,X		; BF 00 E0 2F ; Load long $2FE000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	and [$40.b],Y		; 37 40 ; AND accumulator with memory (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($20.b,S),Y		; 33 20 ; AND accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $101C.w		; 20 1C 10 ; Jump to subroutine at $101C.w [Writes: Stack Pointer] [Flow: call]
	ora $03030C.l		; 0F 0C 03 03 ; OR accumulator with memory (long) $03030C.l [Writes: Accumulator] [Flags: ZN]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jmp $2327.w		; 4C 27 23 ; Jump to $2327.w [Flow: jump]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $EC02.w		; 1C 02 EC ; Test and reset bits $EC02.w [Reads: Accumulator] [Flags: Z]
	cop $CC.b		; 02 CC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	tsb $38.b		; 04 38 ; Test and set bits $38.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: ZNC]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($32.b)		; 12 32 ; OR accumulator with memory (indirect) ($32.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpx $C4.b		; E4 C4 ; Compare $C4.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	.db $F0, $2F		; F0 2F ; Branch if equal to $F0, $2F [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	eor ($36.b,X)		; 41 36 ; Exclusive OR accumulator with memory ($36.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	trb $05.b		; 14 05 ; Test and reset bits $05.b [Reads: Accumulator] [Flags: Z]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $21.b		; 86 21 ; Store X register to $21.b [Reads: X Index]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
.INDEX 16
	rep #$1C		; C2 1C
	.db $82, $6C, $8B		; 82 6C 8B ; Branch always long to $82, $6C, $8B [Flow: branch]
	bit $0005.w		; 2C 05 00 ; Test bits $0005.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	jsl $692FF0.l		; 22 F0 2F 69 ; Jump to subroutine long $692FF0.l [Writes: Stack Pointer] [Flow: call]
	ora $86.b		; 05 86 ; Logical OR $86.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $E405.w,Y		; 39 05 E4 ; AND accumulator with memory $E405.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and $04FF00.l		; 2F 00 FF 04 ; AND accumulator with memory (long) $04FF00.l [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F00.w		; 0E 00 1F ; Arithmetic shift left $1F00.w [Flags: ZNC]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	and $007F10.l,X		; 3F 10 7F 00 ; AND accumulator with memory (long,X) $007F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda $0E0000.l,X		; BF 00 00 0E ; Load long $0E0000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	bit $3F3F.w,X		; 3C 3F 3F ; Test bits $3F3F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	adc $0000FF.l,X		; 7F FF 00 00 ; Add long $0000FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: ZNC]
	jsr ($FE0E.w,X)		; FC 0E FE ; Jump to subroutine indirect indexed ($FE0E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $00A0.w,X		; BD A0 00 ; Load $00A0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $70, $D8		; 70 D8 ; Branch if overflow set to $70, $D8 [Flow: branch]
	ldy $FCFC.w,X		; BC FC FC ; Load Y register $FCFC.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	ldx $005F.w,Y		; BE 5F 00 ; Load X register $005F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $1F,$00		; 44 00 1F ; Move block positive $1F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0200.w		; 0C 00 02 ; Test and set bits $0200.w [Reads: Accumulator] [Flags: Z]
	ora $853D1B.l,X		; 1F 1B 3D 85 ; Logical OR long $853D1B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,X		; 15 00 ; OR accumulator with memory $00.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	mvp $F8,$00		; 44 00 F8 ; Move block positive $F8,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FD00.w,X		; FE 00 FD ; Increment memory $FD00.w,X [Reads: X Index] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ldy $FEFC.w,X		; BC FC FE ; Load Y register $FEFC.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	sbc $070000.l,X		; FF 00 00 07 ; Subtract with carry (long,X) $070000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $3F,$00		; 44 00 3F ; Move block positive $3F,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $7F.b,S		; 43 7F ; Exclusive OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $070004.l,X		; 3F 04 00 07 ; AND accumulator with memory (long,X) $070004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $7E3D3B.l,X		; 1F 3B 3D 7E ; Logical OR long $7E3D3B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $00003B.l,X		; 7F 3B 00 00 ; Add long $00003B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	mvp $F8,$00		; 44 00 F8 ; Move block positive $F8,$00 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0700.w,X		; FE 00 07 ; Increment memory $0700.w,X [Reads: X Index] [Flags: ZN]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp.w [$FE7C]		; DC 7C FE ; Jump long indirect [$FE7C] [Flow: jump]
	inc $0029.w,X		; FE 29 00 ; Increment memory $0029.w,X [Reads: X Index] [Flags: ZN]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	asl $1A.b		; 06 1A ; Arithmetic shift left $1A.b [Reads: Direct Page] [Flags: ZNC]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($14.b)		; 12 14 ; OR accumulator with memory (indirect) ($14.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $88		; 10 88 ; Branch if plus to $10, $88 [Flow: branch]
	.db $70, $54		; 70 54 ; Branch if overflow set to $70, $54 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	eor ($AC.b)		; 52 AC ; Exclusive OR accumulator with memory (indirect) ($AC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	mvp $29,$42		; 44 42 29 ; Move block positive $29,$42 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: ZNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $C4		; 10 C4 ; Branch if plus to $10, $C4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $C8.b,X		; 34 C8 ; Test bits $C8.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	ldx $58.b		; A6 58 ; Load $58.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpy $24.b		; C4 24 ; Compare $24.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	rol $25.b		; 26 25 ; Rotate left $25.b [Reads: Direct Page] [Flags: ZNC]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $5000.w		; 20 00 50 ; Jump to subroutine at $5000.w [Writes: Stack Pointer] [Flow: call]
	jsr $2858.w		; 20 58 28 ; Jump to subroutine at $2858.w [Writes: Stack Pointer] [Flow: call]
	dec $BF35.w		; CE 35 BF ; Decrement $BF35.w [Flags: ZN]
	mvp $00,$22		; 44 22 00 ; Move block positive $00,$22 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $20.b		; 04 20 ; Test and set bits $20.b [Reads: Accumulator] [Flags: Z]
	.db $50, $58		; 50 58 ; Branch if overflow clear to $50, $58 [Flow: branch]
	stx $23BE.w		; 8E BE 23 ; Store X register to $23BE.w [Reads: X Index]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $0B00.w		; 0E 00 0B ; Arithmetic shift left $0B00.w [Flags: ZNC]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	asl $76.b,X		; 16 76 ; Arithmetic shift left $76.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	pea $0028.w		; F4 28 00 ; Push absolute address $0028.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora #$7609.w		; 09 09 76 ; Logical OR #$7609.w with accumulator [Writes: Accumulator] [Flags: ZN]
	stz $23.b,X		; 74 23 ; Store zero to $23.b,X [Reads: X Index]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$30.b]		; 07 30 ; OR accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $683748.l		; 0F 48 37 68 ; OR accumulator with memory (long) $683748.l [Writes: Accumulator] [Flags: ZN]
	ora [$8B.b],Y		; 17 8B ; OR accumulator with memory (long indexed) [$8B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	stz $00.b,X		; 74 00 ; Store zero to $00.b,X [Reads: X Index]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $30, $48		; 30 48 ; Branch if minus to $30, $48 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($E0.b,S),Y		; 13 E0 ; OR accumulator (stack relative indirect indexed) ($E0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F40A.w		; E0 0A F4 ; Compare #$F40A.w with X register [Reads: X Index] [Flags: ZNC]
	ora #$29F6.w		; 09 F6 29 ; Logical OR #$29F6.w with accumulator [Writes: Accumulator] [Flags: ZN]
	dec $C6.b,X		; D6 C6 ; Decrement memory $C6.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$0A1C.w		; E0 1C 0A ; Compare #$0A1C.w with X register [Reads: X Index] [Flags: ZNC]
	ora #$0609.w		; 09 09 06 ; Logical OR #$0609.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $10BF.w,X		; 3C BF 10 ; Test bits $10BF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $59FB57.l,X		; FF 57 FB 59 ; Subtract with carry (long,X) $59FB57.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $003F10.l,X		; 3F 10 3F 00 ; AND accumulator with memory (long,X) $003F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $000701.l,X		; 1F 01 07 00 ; Logical OR long $000701.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $77A6A8.l		; EF A8 A6 77 ; Subtract with carry (long) $77A6A8.l [Writes: Accumulator] [Flags: ZVNC]
	and $071E3F.l		; 2F 3F 1E 07 ; AND accumulator with memory (long) $071E3F.l [Writes: Accumulator] [Flags: ZN]
	lda $3F90.w,X		; BD 90 3F ; Load $3F90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	cmp $10569A.l,X		; DF 9A 56 10 ; Compare accumulator (long,X) $10569A.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	jsr ($FC08.w,X)		; FC 08 FC ; Jump to subroutine indirect indexed ($FC08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	brk $6F.b		; 00 6F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $65.b,X		; D5 65 ; Compare accumulator $65.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	inc $FCF4.w		; EE F4 FC ; Increment $FCF4.w [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpx #$40DF.w		; E0 DF 40 ; Compare #$40DF.w with X register [Reads: X Index] [Flags: ZNC]
	sbc $107F70.l,X		; FF 70 7F 10 ; Subtract with carry (long,X) $107F70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $0F0C.w		; 1C 0C 0F ; Test and reset bits $0F0C.w [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $BF1400.l		; 22 00 14 BF ; Jump to subroutine long $BF1400.l [Writes: Stack Pointer] [Flow: call]
	sta $13176F.l		; 8F 6F 17 13 ; Store accumulator (long) $13176F.l [Reads: Accumulator]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $08FE.w		; 0E FE 08 ; Arithmetic shift left $08FE.w [Flags: ZNC]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$22C0.w		; C0 C0 22 ; Compare #$22C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F1FD.w		; 2C FD F1 ; Test bits $F1FD.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	inc $E8.b,X		; F6 E8 ; Increment memory $E8.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2B.b)		; 12 2B ; OR accumulator with memory (indirect) ($2B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($4B.b,X)		; 01 4B ; Logical OR ($4B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($78.b,X)		; 01 78 ; Logical OR ($78.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $002F00.l,X		; 7F 00 2F 00 ; Add long $002F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $000E00.l,X		; 1F 00 0E 00 ; Logical OR long $000E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $7E3E.w		; 2D 3E 7E ; Logical AND $7E3E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	adc [$7F.b],Y		; 77 7F ; Add with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $FE0E1F.l,X		; 3F 1F 0E FE ; AND accumulator with memory (long,X) $FE0E1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$607C.w		; A0 7C 60 ; Load #$607C.w into Y register [Writes: Y Index] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	cpy #$22C0.w		; C0 C0 22 ; Compare #$22C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $5CFE.w,X		; FE FE 5C ; Increment memory $5CFE.w,X [Reads: X Index] [Flags: ZN]
	stz $3088.w		; 9C 88 30 ; Store zero to $3088.w
	cpy #$1C00.w		; C0 00 1C ; Compare #$1C00.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora $35.b,S		; 03 35 ; OR accumulator with stack relative $35.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($1E.b)		; 12 1E ; OR accumulator with memory (indirect) ($1E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $123F.w		; 0D 3F 12 ; Logical OR $123F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $241F19.l,X		; 3F 19 1F 24 ; AND accumulator with memory (long,X) $241F19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $2F12.w		; 2D 12 2F ; Logical AND $2F12.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and [$1F.b]		; 27 1F ; AND accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	bit $B4.b,X		; 34 B4 ; Test bits $B4.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	trb $EEE0.w		; 1C E0 EE ; Test and reset bits $EEE0.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	dec $FE74.w,X		; DE 74 FE ; Decrement memory $FE74.w,X [Reads: X Index] [Flags: ZN]
	tsb $387C.w		; 0C 7C 38 ; Test and set bits $387C.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $1C.b		; 84 1C ; Store Y register to $1C.b [Reads: Y Index]
	inc $F2FA.w,X		; FE FA F2 ; Increment memory $F2FA.w,X [Reads: X Index] [Flags: ZN]
	mvp $1F,$38		; 44 38 1F ; Move block positive $1F,$38 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	tsb $040F.w		; 0C 0F 04 ; Test and set bits $040F.w [Reads: Accumulator] [Flags: Z]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $1F.b,X		; 16 1F ; Arithmetic shift left $1F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora $05070F.l,X		; 1F 0F 07 05 ; Logical OR long $05070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pei ($F4.b)		; D4 F4 ; Push effective indirect address ($F4.b) [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $D0, $F0		; D0 F0 ; Branch if not equal to $D0, $F0 [Flow: branch]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00F0.w		; E0 F0 00 ; Compare #$00F0.w with X register [Reads: X Index] [Flags: ZNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	jsl $2228E4.l		; 22 E4 28 22 ; Jump to subroutine long $2228E4.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	adc $7E26.w		; 6D 26 7E ; Add $7E26.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	and [$3F.b],Y		; 37 3F ; AND accumulator with memory (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $3E103F.l		; 0F 3F 10 3E ; OR accumulator with memory (long) $3E103F.l [Writes: Accumulator] [Flags: ZN]
	trb $241E.w		; 1C 1E 24 ; Test and reset bits $241E.w [Reads: Accumulator] [Flags: Z]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $2F3F4F.l,X		; 5F 4F 3F 2F ; Exclusive OR accumulator with memory (long,X) $2F3F4F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $00001E.l		; 22 1E 00 00 ; Jump to subroutine long $00001E.l [Writes: Stack Pointer] [Flow: call]
	lda ($6C.b)		; B2 6C ; Load accumulator (indirect) ($6C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	cpx $9C.b		; E4 9C ; Compare $9C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $F0, $CC		; F0 CC ; Branch if equal to $F0, $CC [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx $FC70.w		; EC 70 FC ; Compare $FC70.w with X register [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp ($7838.w,X)		; 7C 38 78 ; Jump indirect indexed to ($7838.w,X) [Reads: X Index] [Flow: jump]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	jsl $F40BFC.l		; 22 FC 0B F4 ; Jump to subroutine long $F40BFC.l [Writes: Stack Pointer] [Flow: call]
	mvp $FA,$78		; 44 78 FA ; Move block positive $FA,$78 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $49.b		; 05 49 ; Logical OR $49.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $69.b		; 06 69 ; Arithmetic shift left $69.b [Reads: Direct Page] [Flags: ZNC]
	rol $3F.b		; 26 3F ; Rotate left $3F.b [Reads: Direct Page] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0026.w,X		; 1E 26 00 ; Arithmetic shift left $0026.w,X [Reads: X Index] [Flags: ZNC]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	adc $3759.w,Y		; 79 59 37 ; Add $3759.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	asl $0022.w,X		; 1E 22 00 ; Arithmetic shift left $0022.w,X [Reads: X Index] [Flags: ZNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	mvp $84,$B8		; 44 B8 84 ; Move block positive $84,$B8 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stz $EC60.w		; 9C 60 EC ; Store zero to $EC60.w
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp.w [$9184]		; DC 84 91 ; Jump long indirect [$9184] [Flow: jump]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $9C.b		; 84 9C ; Store Y register to $9C.b [Reads: Y Index]
	sta $9B.b,S		; 83 9B ; Store accumulator (stack relative) $9B.b,S [Reads: Accumulator, Stack Pointer]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx $33.b		; E4 33 ; Compare $33.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0F1F03.l		; 0F 03 1F 0F ; OR accumulator with memory (long) $0F1F03.l [Writes: Accumulator] [Flags: ZN]
	asl $3F0F.w,X		; 1E 0F 3F ; Arithmetic shift left $3F0F.w,X [Reads: X Index] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor $000005.l,X		; 5F 05 00 00 ; Exclusive OR accumulator with memory (long,X) $000005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $7B3F1F.l,X		; 1F 1F 3F 7B ; Logical OR long $7B3F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($C0.b,S),Y		; 13 C0 ; OR accumulator (stack relative indirect indexed) ($C0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F038.w		; C0 38 F0 ; Compare #$F038.w with Y register [Reads: Y Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $F0, $3C		; F0 3C ; Branch if equal to $F0, $3C [Flow: branch]
	.db $D0, $FA		; D0 FA ; Branch if not equal to $D0, $FA [Flow: branch]
	ldy #$0000.w		; A0 00 00 ; Load #$0000.w into Y register [Writes: Y Index] [Flags: ZN]
	cpy #$F8F0.w		; C0 F0 F8 ; Compare #$F8F0.w with Y register [Reads: Y Index] [Flags: ZNC]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($23DE.w,X)		; FC DE 23 ; Jump to subroutine indirect indexed ($23DE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $10861F.l,X		; 5F 1F 86 10 ; Exclusive OR accumulator with memory (long,X) $10861F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $880023.l		; 6F 23 00 88 ; Add with carry (long) $880023.l [Writes: Accumulator] [Flags: ZVNC]
	trb $0203.w		; 1C 03 02 ; Test and reset bits $0203.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $FA		; F0 FA ; Branch if equal to $F0, $FA [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	stx $28.b		; 86 28 ; Store X register to $28.b [Reads: X Index]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $23.b,X		; F6 23 ; Increment memory $23.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F1107.l		; 0F 07 11 0F ; OR accumulator with memory (long) $0F1107.l [Writes: Accumulator] [Flags: ZN]
	and ($0F.b),Y		; 31 0F ; AND accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($2F.b,S),Y		; 73 2F ; Add with carry (stack relative indirect indexed) ($2F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $000036.l,X		; 7F 36 00 00 ; Add long $000036.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $4F5F3F.l,X		; 1F 3F 5F 4F ; Logical OR long $4F5F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$00C0.w		; 09 C0 00 ; Logical OR #$00C0.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cpx #$F0C0.w		; E0 C0 F0 ; Compare #$F0C0.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$E030.w		; E0 30 E0 ; Compare #$E030.w with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	jsl $C00100.l		; 22 00 01 C0 ; Jump to subroutine long $C00100.l [Writes: Stack Pointer] [Flow: call]
	cpx #$F022.w		; E0 22 F0 ; Compare #$F022.w with X register [Reads: X Index] [Flags: ZNC]
	and $0000.w		; 2D 00 00 ; Logical AND $0000.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and ($27.b,X)		; 21 27 ; Logical AND ($27.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($2B.b,X)		; 21 2B ; Logical AND ($2B.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $F000.w		; 20 00 F0 ; Jump to subroutine at $F000.w [Writes: Stack Pointer] [Flow: call]
	jsr $0025.w		; 20 25 00 ; Jump to subroutine at $0025.w [Writes: Stack Pointer] [Flow: call]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $F0, $2D		; F0 2D ; Branch if equal to $F0, $2D [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($29.b,X)		; 01 29 ; Logical OR ($29.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	jsr $60F0.w		; 20 F0 60 ; Jump to subroutine at $60F0.w [Writes: Stack Pointer] [Flow: call]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $5C		; 10 5C ; Branch if plus to $10, $5C [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	stz $2378.w		; 9C 78 23 ; Store zero to $2378.w
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	jmp ($25FC.w,X)		; 7C FC 25 ; Jump indirect indexed to ($25FC.w,X) [Reads: X Index] [Flow: jump]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $1A04.w		; 0E 04 1A ; Arithmetic shift left $1A04.w [Flags: ZNC]
	tsb $1C32.w		; 0C 32 1C ; Test and set bits $1C32.w [Reads: Accumulator] [Flags: Z]
	rol $220C.w,X		; 3E 0C 22 ; Rotate left $220C.w,X [Reads: X Index] [Flags: ZNC]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	asl $3E3E.w,X		; 1E 3E 3E ; Arithmetic shift left $3E3E.w,X [Reads: X Index] [Flags: ZNC]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$2F.b]		; 07 2F ; OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $7C.b,S		; 03 7C ; OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $FD6FB8.l		; 2F B8 6F FD ; AND accumulator with memory (long) $FD6FB8.l [Writes: Accumulator] [Flags: ZN]
	adc $030023.l		; 6F 23 00 03 ; Add with carry (long) $030023.l [Writes: Accumulator] [Flags: ZVNC]
	and $FFFF7F.l		; 2F 7F FF FF ; AND accumulator with memory (long) $FFFF7F.l [Writes: Accumulator] [Flags: ZN]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0002.w		; 09 02 00 ; Logical OR #$0002.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sbc [$C2.b],Y		; F7 C2 ; Subtract with carry (long indexed) [$C2.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	and $1DF6.w,X		; 3D F6 1D ; AND accumulator with memory $1DF6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $BE.b,X		; F6 BE ; Increment memory $BE.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $020400.l		; 22 00 04 02 ; Jump to subroutine long $020400.l [Writes: Stack Pointer] [Flow: call]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $2FE4FE.l,X		; FF FE E4 2F ; Subtract with carry (long,X) $2FE4FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $286C0E.l,X		; 5F 0E 6C 28 ; Exclusive OR accumulator with memory (long,X) $286C0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0C05.w		; 0D 05 0C ; Logical OR $0C05.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsl $711400.l		; 22 00 14 71 ; Jump to subroutine long $711400.l [Writes: Stack Pointer] [Flow: call]
	eor [$77.b],Y		; 57 77 ; Exclusive OR accumulator with memory (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $36		; 70 36 ; Branch if overflow set to $70, $36 [Flow: branch]
	trb $5E.b		; 14 5E ; Test and reset bits $5E.b [Reads: Accumulator] [Flags: Z]
	.db $10, $B0		; 10 B0 ; Branch if plus to $10, $B0 [Flow: branch]
	ldy #$2030.w		; A0 30 20 ; Load #$2030.w into Y register [Writes: Y Index] [Flags: ZN]
	cpx #$C0C0.w		; E0 C0 C0 ; Compare #$C0C0.w with X register [Reads: X Index] [Flags: ZNC]
	jsl $8E0E00.l		; 22 00 0E 8E ; Jump to subroutine long $8E0E00.l [Writes: Stack Pointer] [Flow: call]
	nop		; EA ; No operation
	inc $D050.w		; EE 50 D0 ; Increment $D050.w [Flags: ZN]
	jsr $00C0.w		; 20 C0 00 ; Jump to subroutine at $00C0.w [Writes: Stack Pointer] [Flow: call]
	eor $3F7F1E.l,X		; 5F 1E 7F 3F ; Exclusive OR accumulator with memory (long,X) $3F7F1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $281013.l,X		; 7F 13 10 28 ; Add long $281013.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $107F4F.l		; 6F 4F 7F 10 ; Add with carry (long) $107F4F.l [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $FA.b		; 06 FA ; Arithmetic shift left $FA.b [Reads: Direct Page] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $FCFC.w,X		; FE FC FC ; Increment memory $FCFC.w,X [Reads: X Index] [Flags: ZN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $F2.b,X		; F6 F2 ; Increment memory $F2.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	jsr ($2308.w,X)		; FC 08 23 ; Jump to subroutine indirect indexed ($2308.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $5414.w,X		; 5E 14 54 ; Logical shift right $5414.w,X [Reads: X Index] [Flags: ZNC]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $C3.b		; 05 C3 ; Logical OR $C3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $42, $E7		; 42 E7 ; Reserved instruction
	adc [$7F.b]		; 67 7F ; Add with carry (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	asl $221E.w,X		; 1E 1E 22 ; Arithmetic shift left $221E.w,X [Reads: X Index] [Flags: ZNC]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $BDFA7F.l		; 6F 7F FA BD ; Add with carry (long) $BDFA7F.l [Writes: Accumulator] [Flags: ZVNC]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	adc ($1E.b,X)		; 61 1E ; Add with carry ($1E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	jsl $E011F0.l		; 22 F0 11 E0 ; Jump to subroutine long $E011F0.l [Writes: Stack Pointer] [Flow: call]
	cpx #$00C0.w		; E0 C0 00 ; Compare #$00C0.w with X register [Reads: X Index] [Flags: ZNC]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($5F.b,X)		; 21 5F ; Logical AND ($5F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and $BD71D9.l,X		; 3F D9 71 BD ; AND accumulator with memory (long,X) $BD71D9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($9D.b,X)		; 01 9D ; Logical OR ($9D.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora ($E3.b,X)		; 01 E3 ; Logical OR ($E3.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsl $7F1400.l		; 22 00 14 7F ; Jump to subroutine long $7F1400.l [Writes: Stack Pointer] [Flow: call]
	adc $FFFBFF.l,X		; 7F FF FB FF ; Add long $FFFBFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda $40.b,S		; A3 40 ; Load accumulator (stack relative) $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0D8.w		; E0 D8 F0 ; Compare #$F0D8.w with X register [Reads: X Index] [Flags: ZNC]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ldx $7828.w,Y		; BE 28 78 ; Load X register $7828.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	jsl $F01400.l		; 22 00 14 F0 ; Jump to subroutine long $F01400.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	sbc $F088DE.l,X		; FF DE 88 F0 ; Subtract with carry (long,X) $F088DE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($17.b,X)		; 01 17 ; Logical OR ($17.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $2F0D1F.l		; 0F 1F 0D 2F ; OR accumulator with memory (long) $2F0D1F.l [Writes: Accumulator] [Flags: ZN]
	ora $2D.b		; 05 2D ; Logical OR $2D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($1F.b,S),Y		; 13 1F ; OR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $0F0900.l		; 22 00 09 0F ; Jump to subroutine long $0F0900.l [Writes: Stack Pointer] [Flow: call]
	ora $373E1E.l,X		; 1F 1E 3E 37 ; Logical OR long $373E1E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $001F.w		; 2C 1F 00 ; Test bits $001F.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $83		; F0 83 ; Branch if equal to $F0, $83 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cmp $ACDEF2.l		; CF F2 DE AC ; Compare accumulator (long) $ACDEF2.l [Reads: Accumulator] [Flags: ZNC]
	jsr ($C0C0.w,X)		; FC C0 C0 ; Jump to subroutine indirect indexed ($C0C0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $F81000.l		; 22 00 10 F8 ; Jump to subroutine long $F81000.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cmp $C03CDE.l		; CF DE 3C C0 ; Compare accumulator (long) $C03CDE.l [Reads: Accumulator] [Flags: ZNC]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $FC.b		; 64 FC ; Store zero to $FC.b
	trb $CD.b		; 14 CD ; Test and reset bits $CD.b [Reads: Accumulator] [Flags: Z]
	mvp $60,$EE		; 44 EE 60 ; Move block positive $60,$EE [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	adc $040026.l,X		; 7F 26 00 04 ; Add long $040026.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc $9FBEEF.l,X		; FF EF BE 9F ; Subtract with carry (long,X) $9FBEEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $0C0022.l,X		; 7F 22 00 0C ; Add long $0C0022.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	inc $3C34.w,X		; FE 34 3C ; Increment memory $3C34.w,X [Reads: X Index] [Flags: ZN]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	.db $30, $7C		; 30 7C ; Branch if minus to $30, $7C [Flow: branch]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pea $7870.w		; F4 70 78 ; Push absolute address $7870.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jsl $FE0E00.l		; 22 00 0E FE ; Jump to subroutine long $FE0E00.l [Writes: Stack Pointer] [Flow: call]
	jsr ($FCF8.w,X)		; FC F8 FC ; Jump to subroutine indirect indexed ($FCF8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $8C.b		; E4 8C ; Compare $8C.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $7B5EF9.l		; 6F F9 5E 7B ; Add with carry (long) $7B5EF9.l [Writes: Accumulator] [Flags: ZVNC]
	ora $441E.w		; 0D 1E 44 ; Logical OR $441E.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $9C1400.l		; 22 00 14 9C ; Jump to subroutine long $9C1400.l [Writes: Stack Pointer] [Flow: call]
	lda $1F7B.w,Y		; B9 7B 1F ; Load $1F7B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	bit $1CF8.w,X		; 3C F8 1C ; Test bits $1CF8.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp.w [$7CA8]		; DC A8 7C ; Jump long indirect [$7CA8] [Flow: jump]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	pea $F8B0.w		; F4 B0 F8 ; Push absolute address $F8B0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $3C0600.l		; 22 00 06 3C ; Jump to subroutine long $3C0600.l [Writes: Stack Pointer] [Flow: call]
	trb $E4DC.w		; 1C DC E4 ; Test and reset bits $E4DC.w [Reads: Accumulator] [Flags: Z]
	cpy $80F8.w		; CC F8 80 ; Compare $80F8.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpx $30.b		; E4 30 ; Compare $30.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0837.w		; 09 37 08 ; Logical OR #$0837.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $7B.b,S		; 43 7B ; Exclusive OR accumulator with stack relative $7B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $E0.b		; 24 E0 ; Test bits $E0.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	jsr $2A7D.w		; 20 7D 2A ; Jump to subroutine at $2A7D.w [Writes: Stack Pointer] [Flow: call]
	adc $58FF24.l,X		; 7F 24 FF 58 ; Add long $58FF24.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $5D3B1A.l		; 0F 1A 3B 5D ; OR accumulator with memory (long) $5D3B1A.l [Writes: Accumulator] [Flags: ZN]
	eor $5B56.w,X		; 5D 56 5B ; Exclusive OR accumulator with memory $5B56.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	lda [$E0.b]		; A7 E0 ; Load accumulator (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$18FC.w		; E0 FC 18 ; Compare #$18FC.w with X register [Reads: X Index] [Flags: ZNC]
	inc $3E04.w,X		; FE 04 3E ; Increment memory $3E04.w,X [Reads: X Index] [Flags: ZN]
	tsb $8E.b		; 04 8E ; Test and set bits $8E.b [Reads: Accumulator] [Flags: Z]
	tsb $BA.b		; 04 BA ; Test and set bits $BA.b [Reads: Accumulator] [Flags: Z]
	ldy #$02E7.w		; A0 E7 02 ; Load #$02E7.w into Y register [Writes: Y Index] [Flags: ZN]
	cpx #$E418.w		; E0 18 E4 ; Compare #$E418.w with X register [Reads: X Index] [Flags: ZNC]
	jsl $5E01FA.l		; 22 FA 01 5E ; Jump to subroutine long $5E01FA.l [Writes: Stack Pointer] [Flow: call]
	sbc $0023.w,X		; FD 23 00 ; Subtract with carry $0023.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tsb $0001.w		; 0C 01 00 ; Test and set bits $0001.w [Reads: Accumulator] [Flags: Z]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $3F02.w,X		; 1E 02 3F ; Arithmetic shift left $3F02.w,X [Reads: X Index] [Flags: ZNC]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0021.w		; 6D 21 00 ; Add $0021.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	.db $62, $00, $E0		; 62 00 E0 ; Push effective relative address $62, $00, $E0 [Writes: Stack Pointer]
	and ($05.b,X)		; 21 05 ; Logical AND ($05.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $5E.b,S		; 23 5E ; AND accumulator with stack relative $5E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $9C		; 10 9C ; Branch if plus to $10, $9C [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $FE20.w,X		; 3E 20 FE ; Rotate left $FE20.w,X [Reads: X Index] [Flags: ZNC]
	cpy #$08FE.w		; C0 FE 08 ; Compare #$08FE.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $E8		; B0 E8 ; Branch if carry set to $B0, $E8 [Flow: branch]
	stz $C4.b		; 64 C4 ; Store zero to $C4.b
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	dec $08.b,X		; D6 08 ; Decrement memory $08.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor #$0814.w		; 49 14 08 ; Exclusive OR #$0814.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3A.b		; 14 3A ; Test and reset bits $3A.b [Reads: Accumulator] [Flags: Z]
	bit $1C.b		; 24 1C ; Test bits $1C.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	and $0900.w,X		; 3D 00 09 ; AND accumulator with memory $0900.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $2200.w		; 1C 00 22 ; Test and reset bits $2200.w [Reads: Accumulator] [Flags: Z]
	brk $59.b		; 00 59 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp $1E5E1C.l		; 5C 1C 5E 1E ; Jump long to $1E5E1C.l [Flow: jump]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rol $23.b		; 26 23 ; Rotate left $23.b [Reads: Direct Page] [Flags: ZNC]
	and ($25.b,X)		; 21 25 ; Logical AND ($25.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc ($F0.b)		; F2 F0 ; Subtract with carry (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp ($0C9C.w,X)		; 7C 9C 0C ; Jump indirect indexed to ($0C9C.w,X) [Reads: X Index] [Flow: jump]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,S),Y		; 13 03 ; OR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $7F.b		; 04 7F ; Test and set bits $7F.b [Reads: Accumulator] [Flags: Z]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cmp $6AEB4D.l		; CF 4D EB 6A ; Compare accumulator (long) $6AEB4D.l [Reads: Accumulator] [Flags: ZNC]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor ($B0.b,X)		; 41 B0 ; Exclusive OR accumulator with memory ($B0.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $23.b,X		; 94 23 ; Store Y register $23.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E000.w		; C0 00 E0 ; Compare #$E000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$20FC.w		; C0 FC 20 ; Compare #$20FC.w with Y register [Reads: Y Index] [Flags: ZNC]
	inc $F15C.w,X		; FE 5C F1 ; Increment memory $F15C.w,X [Reads: X Index] [Flags: ZN]
	.db $B0, $DD		; B0 DD ; Branch if carry set to $B0, $DD [Flow: branch]
	jmp $C00000.l		; 5C 00 00 C0 ; Jump long to $C00000.l [Flow: jump]
	jsr $82DC.w		; 20 DC 82 ; Jump to subroutine at $82DC.w [Writes: Stack Pointer] [Flow: call]
	ora $002723.l		; 0F 23 27 00 ; OR accumulator with memory (long) $002723.l [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00271F.l		; 0F 1F 27 00 ; OR accumulator with memory (long) $00271F.l [Writes: Accumulator] [Flags: ZN]
	ora [$F0.b]		; 07 F0 ; OR accumulator with memory (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $F0E8.w		; 20 E8 F0 ; Jump to subroutine at $F0E8.w [Writes: Stack Pointer] [Flow: call]
	pea $23F8.w		; F4 F8 23 ; Push absolute address $23F8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0027.w,X)		; FC 27 00 ; Jump to subroutine indirect indexed ($0027.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $030023.l		; 0F 23 00 03 ; OR accumulator with memory (long) $030023.l [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $2718.w		; 0C 18 27 ; Test and set bits $2718.w [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx #$F018.w		; E0 18 F0 ; Compare #$F018.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $23F8.w		; 0C F8 23 ; Test and set bits $23F8.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $002B.w		; 0C 2B 00 ; Test and set bits $002B.w [Reads: Accumulator] [Flags: Z]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $F000.w		; 20 00 F0 ; Jump to subroutine at $F000.w [Writes: Stack Pointer] [Flow: call]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: ZNC]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $D0, $FF		; D0 FF ; Branch if not equal to $D0, $FF [Flow: branch]
	adc [$FF.b]		; 67 FF ; Add with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $7E437F.l,X		; FF 7F 43 7E ; Subtract with carry (long,X) $7E437F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rol $3F13.w,X		; 3E 13 3F ; Rotate left $3F13.w,X [Reads: X Index] [Flags: ZNC]
	ora $07071F.l,X		; 1F 1F 07 07 ; Logical OR long $07071F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$80.b]		; 87 80 ; Store accumulator (long) [$80.b] [Reads: Accumulator, Direct Page]
	eor ($41.b,X)		; 41 41 ; Exclusive OR accumulator with memory ($41.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $0718.w		; 20 18 07 ; Jump to subroutine at $0718.w [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cop $E3.b		; 02 E3 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: ZNC]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: ZNC]
	jsl $FA11FD.l		; 22 FD 11 FA ; Jump to subroutine long $FA11FD.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	cpx #$42D3.w		; E0 D3 42 ; Compare #$42D3.w with X register [Reads: X Index] [Flags: ZNC]
	cmp [$45.b]		; C7 45 ; Compare accumulator (long) [$45.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sbc [$65.b]		; E7 65 ; Subtract with carry (long) [$65.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $31737D.l,X		; FF 7D 73 31 ; Subtract with carry (long,X) $31737D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $221E1E.l,X		; 3F 1E 1E 22 ; AND accumulator with memory (long,X) $221E1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $BAAD.w		; 2C AD BA ; Test bits $BAAD.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	.db $82, $4E, $21		; 82 4E 21 ; Branch always long to $82, $4E, $21 [Flow: branch]
	asl $B600.w,X		; 1E 00 B6 ; Arithmetic shift left $B600.w,X [Reads: X Index] [Flags: ZNC]
	sty $47.b		; 84 47 ; Store Y register to $47.b [Reads: Y Index]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	asl $9E9F.w		; 0E 9F 9E ; Arithmetic shift left $9E9F.w [Flags: ZNC]
	sbc [$F6.b],Y		; F7 F6 ; Subtract with carry (long indexed) [$F6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	dec $FCCC.w		; CE CC FC ; Decrement $FCCC.w [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $61F1.w,Y		; B9 F1 61 ; Load $61F1.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$8432.w		; 09 32 84 ; Logical OR #$8432.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	rol $08.b,X		; 36 08 ; Rotate left $08.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $08.b,X		; 55 08 ; Exclusive OR accumulator with memory $08.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc [$28.b],Y		; 77 28 ; Add with carry (long indexed) [$28.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$2A.b],Y		; 77 2A ; Add with carry (long indexed) [$2A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc [$08.b],Y		; 77 08 ; Add with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	eor #$0022.w		; 49 22 00 ; Exclusive OR #$0022.w with accumulator [Writes: Accumulator] [Flags: ZN]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: ZNC]
	rol $5E7F.w,X		; 3E 7F 5E ; Rotate left $5E7F.w,X [Reads: X Index] [Flags: ZNC]
	eor $497F.w,X		; 5D 7F 49 ; Exclusive OR accumulator with memory $497F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsl $9C0000.l		; 22 00 00 9C ; Jump to subroutine long $9C0000.l [Writes: Stack Pointer] [Flow: call]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $9C.b		; 04 9C ; Test and set bits $9C.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; [PATTERN: Memory clearing operation] 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $2262.w		; 9C 62 22 ; Store zero to $2262.w
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	ora $62.b,S		; 03 62 ; OR accumulator with stack relative $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stz $1F5F.w		; 9C 5F 1F ; Store zero to $1F5F.w
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1761E0.l		; 0F E0 61 17 ; OR accumulator with memory (long) $1761E0.l [Writes: Accumulator] [Flags: ZN]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	sbc ($F0.b)		; F2 F0 ; Subtract with carry (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cpx $E0.b		; E4 E0 ; Compare $E0.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	pea $E8F0.w		; F4 F0 E8 ; Push absolute address $E8F0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpx #$C0D0.w		; E0 D0 C0 ; Compare #$C0D0.w with X register [Reads: X Index] [Flags: ZNC]
	ldy #$4080.w		; A0 80 40 ; Load #$4080.w into Y register [Writes: Y Index] [Flags: ZN]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc ($71.b),Y		; F1 71 ; Subtract with carry ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($1F0C.w,X)		; 7C 0C 1F ; Jump indirect indexed to ($1F0C.w,X) [Reads: X Index] [Flow: jump]
	ora $77072F.l		; 0F 2F 07 77 ; OR accumulator with memory (long) $77072F.l [Writes: Accumulator] [Flags: ZN]
	.db $30, $3E		; 30 3E ; Branch if minus to $30, $3E [Flow: branch]
	asl $031F.w,X		; 1E 1F 03 ; Arithmetic shift left $031F.w,X [Reads: X Index] [Flags: ZNC]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stx $1873.w		; 8E 73 18 ; Store X register to $1873.w [Reads: X Index]
	and $1C214F.l,X		; 3F 4F 21 1C ; AND accumulator with memory (long,X) $1C214F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $8F.b,S		; 03 8F ; OR accumulator with stack relative $8F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	stx $707E.w		; 8E 7E 70 ; Store X register to $707E.w [Reads: X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$987C.w		; E0 7C 98 ; Compare #$987C.w with X register [Reads: X Index] [Flags: ZNC]
	sty $7408.w		; 8C 08 74 ; Store Y register to $7408.w [Reads: Y Index]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $F478.w		; 8E 78 F4 ; Store X register to $F478.w [Reads: X Index]
	pea $78FC.w		; F4 FC 78 ; Push absolute address $78FC.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpx #$0717.w		; E0 17 07 ; Compare #$0717.w with X register [Reads: X Index] [Flags: ZNC]
	ora $0D.b,X		; 15 0D ; OR accumulator with memory $0D.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $06.b,X		; 16 06 ; Arithmetic shift left $06.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	eor $0B.b,S		; 43 0B ; Exclusive OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and $1F.b,S		; 23 1F ; AND accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $F40307.l		; 0F 07 03 F4 ; OR accumulator with memory (long) $F40307.l [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	pei ($D0.b)		; D4 D0 ; Push effective indirect address ($D0.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ldy $B0.b,X		; B4 B0 ; Load Y register $B0.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	bit $70.b,X		; 34 70 ; Test bits $70.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	cpx #$E0E8.w		; E0 E8 E0 ; Compare #$E0E8.w with X register [Reads: X Index] [Flags: ZNC]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cpx #$2300.w		; E0 00 23 ; Compare #$2300.w with X register [Reads: X Index] [Flags: ZNC]
	jsr ($F80B.w,X)		; FC 0B F8 ; Jump to subroutine indirect indexed ($F80B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $110F10.l		; 0F 10 0F 11 ; OR accumulator with memory (long) $110F10.l [Writes: Accumulator] [Flags: ZN]
	ora $070843.l		; 0F 43 08 07 ; OR accumulator with memory (long) $070843.l [Writes: Accumulator] [Flags: ZN]
	tsb $0304.w		; 0C 04 03 ; Test and set bits $0304.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	ora $0C19.w,Y		; 19 19 0C ; OR accumulator with memory $0C19.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0307.w		; 0C 07 03 ; Test and set bits $0307.w [Reads: Accumulator] [Flags: Z]
	tsb $F844.w		; 0C 44 F8 ; Test and set bits $F844.w [Reads: Accumulator] [Flags: Z]
	tsb $15.b		; 04 15 ; Test and set bits $15.b [Reads: Accumulator] [Flags: Z]
	mvp $88,$F8		; 44 F8 88 ; Move block positive $88,$F8 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $4C2C.w		; 0C 2C 4C ; Test and set bits $4C2C.w [Reads: Accumulator] [Flags: Z]
	cpy $1898.w		; CC 98 18 ; Compare $1898.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	ora $030F00.l		; 0F 00 0F 03 ; OR accumulator with memory (long) $030F00.l [Writes: Accumulator] [Flags: ZN]
	eor $0E.b		; 45 0E ; Exclusive OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $040609.l		; 22 09 06 04 ; Jump to subroutine long $040609.l [Writes: Stack Pointer] [Flow: call]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	eor $70.b		; 45 70 ; Exclusive OR $70.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora [$E0.b]		; 07 E0 ; OR accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	.db $90, $08		; 90 08 ; Branch if carry clear to $90, $08 [Flow: branch]
	jsr $8040.w		; 20 40 80 ; Jump to subroutine at $8040.w [Writes: Stack Pointer] [Flow: call]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $64		; 30 64 ; Branch if minus to $30, $64 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $52.b,S		; 43 52 ; Exclusive OR accumulator with stack relative $52.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $4945.w		; 0C 45 49 ; Test and set bits $4945.w [Reads: Accumulator] [Flags: Z]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: ZNC]
	.db $30, $48		; 30 48 ; Branch if minus to $30, $48 [Flow: branch]
	bit $12.b		; 24 12 ; Test bits $12.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0025.w		; 09 25 00 ; Logical OR #$0025.w with accumulator [Writes: Accumulator] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $1E00.w		; AE 00 1E ; Load $1E00.w into X register [Writes: X Index] [Flags: ZN]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $FD64.w,X		; FD 64 FD ; Subtract with carry $FD64.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp ($66FF.w)		; 6C FF 66 ; Jump indirect to ($66FF.w) [Flow: jump]
	ror $6820.w		; 6E 20 68 ; Rotate right $6820.w [Flags: ZNC]
	jsr $7C38.w		; 20 38 7C ; Jump to subroutine at $7C38.w [Writes: Stack Pointer] [Flow: call]
	dec $9B.b		; C6 9B ; Decrement $9B.b [Reads: Direct Page] [Flags: ZN]
	sta ($99.b,S),Y		; 93 99 ; Store accumulator (stack relative indirect indexed) ($99.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	lsr $1058.w,X		; 5E 58 10 ; Logical shift right $1058.w,X [Reads: X Index] [Flags: ZNC]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F2		; 30 F2 ; Branch if minus to $30, $F2 [Flow: branch]
	jmp ($007C.w)		; 6C 7C 00 ; Jump indirect to ($007C.w) [Flow: jump]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	mvp $38,$10		; 44 10 38 ; Move block positive $38,$10 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	stz $FE.b,X		; 74 FE ; Store zero to $FE.b,X [Reads: X Index]
	jmp ($3822.w,X)		; 7C 22 38 ; Jump indirect indexed to ($3822.w,X) [Reads: X Index] [Flow: jump]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7E.b		; 24 7E ; Test bits $7E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $7E		; 42 7E ; Reserved instruction
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $5A.b,X		; 34 5A ; Test bits $5A.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $E7.b		; A5 E7 ; Load $E7.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $833C.w,X		; 7E 3C 83 ; Rotate right $833C.w,X [Reads: X Index] [Flags: ZNC]
	trb $0503.w		; 1C 03 05 ; Test and reset bits $0503.w [Reads: Accumulator] [Flags: Z]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sbc $04FB00.l,X		; FF 00 FB 04 ; Subtract with carry (long,X) $04FB00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $81.b		; 45 81 ; Exclusive OR $81.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ror $0003.w,X		; 7E 03 00 ; Rotate right $0003.w,X [Reads: X Index] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $23FF.w,X		; 3C FF 23 ; Test bits $23FF.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta ($E0.b,X)		; 81 E0 ; Store accumulator ($E0.b,X) [Reads: Accumulator, X Index, Direct Page]
	and $470000.l		; 2F 00 00 47 ; AND accumulator with memory (long) $470000.l [Writes: Accumulator] [Flags: ZN]
	brk $AB.b		; 00 AB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $AD.b		; 45 AD ; Exclusive OR $AD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lsr $57.b		; 46 57 ; Logical shift right $57.b [Reads: Direct Page] [Flags: ZNC]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: ZN] [SNES: Stack operation: pulls DP register]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor $2A.b,X		; 55 2A ; Exclusive OR accumulator with memory $2A.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	ldx $0045.w		; AE 45 00 ; Load $0045.w into X register [Writes: X Index] [Flags: ZN]
	eor [$AF.b]		; 47 AF ; Exclusive OR accumulator with memory (long) [$AF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $552357.l		; AF 57 23 55 ; Load long $552357.l into accumulator [Writes: Accumulator] [Flags: ZN]
	ldx $0000.w		; AE 00 00 ; Load $0000.w into X register [Writes: X Index] [Flags: ZN]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	nop		; EA ; No operation
	sty $D7.b		; 84 D7 ; Store Y register to $D7.b [Reads: Y Index]
	ror $6CB6.w		; 6E B6 6C ; Rotate right $6CB6.w [Flags: ZNC]
	jsr ($E8E8.w,X)		; FC E8 E8 ; Jump to subroutine indirect indexed ($E8E8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FEFF.w		; EE FF FE ; Increment $FEFF.w [Flags: ZN]
	jsr ($1CE8.w,X)		; FC E8 1C ; Jump to subroutine indirect indexed ($1CE8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A1B.w		; 0D 1B 0A ; Logical OR $0A1B.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1512.w		; 0D 12 15 ; Logical OR $1512.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $B0, $48		; B0 48 ; Branch if carry set to $B0, $48 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	ora #$1700.w		; 09 00 17 ; Logical OR #$1700.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora #$0E11.w		; 09 11 0E ; Logical OR #$0E11.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $070C08.l,X		; 1F 08 0C 07 ; Logical OR long $070C08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $4F07.w,X		; 3E 07 4F ; Rotate left $4F07.w,X [Reads: X Index] [Flags: ZNC]
	bit $64.b,X		; 34 64 ; Test bits $64.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$1F22.w		; 09 22 1F ; Logical OR #$1F22.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cpx #$0F21.w		; E0 21 0F ; Compare #$0F21.w with X register [Reads: X Index] [Flags: ZNC]
	and $807C7F.l,X		; 3F 7F 7C 80 ; AND accumulator with memory (long,X) $807C7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	cpy #$90F8.w		; C0 F8 90 ; Compare #$90F8.w with Y register [Reads: Y Index] [Flags: ZNC]
	pei ($68.b)		; D4 68 ; Push effective indirect address ($68.b) [Reads: Direct Page] [Writes: Stack Pointer]
	jsr ($7E08.w,X)		; FC 08 7E ; Jump to subroutine indirect indexed ($7E08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sty $F6.b		; 84 F6 ; Store Y register to $F6.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($0EFC.w,X)		; FC FC 0E ; Jump to subroutine indirect indexed ($0EFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $7F47.w,X		; 1E 47 7F ; Arithmetic shift left $7F47.w,X [Reads: X Index] [Flags: ZNC]
	and $2C7C04.l		; 2F 04 7C 2C ; AND accumulator with memory (long) $2C7C04.l [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	eor [$0A.b],Y		; 57 0A ; Exclusive OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $50, $53		; 50 53 ; Branch if overflow clear to $50, $53 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	mvp $F4,$F0		; 44 F0 F4 ; Move block positive $F4,$F0 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $FC.b,S		; 23 FC ; AND accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora #$FC0C.w		; 09 0C FC ; Logical OR #$FC0C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: ZNC]
	sta $E166.w,Y		; 99 66 E1 ; Store accumulator to $E166.w,Y [Reads: Accumulator, Y Index]
	ror $F943.w,X		; 7E 43 F9 ; Rotate right $F943.w,X [Reads: X Index] [Flags: ZNC]
	ror $05.b		; 66 05 ; Rotate right $05.b [Reads: Direct Page] [Flags: ZNC]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc ($3C.b)		; 72 3C ; Add with carry (indirect) ($3C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0060.w		; 09 60 00 ; Logical OR #$0060.w with accumulator [Writes: Accumulator] [Flags: ZN]
	.db $D0, $40		; D0 40 ; Branch if not equal to $D0, $40 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pea $7A70.w		; F4 70 7A ; Push absolute address $7A70.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $600400.l		; 22 00 04 60 ; Jump to subroutine long $600400.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $98		; B0 98 ; Branch if carry set to $B0, $98 [Flow: branch]
	sty $4546.w		; 8C 46 45 ; Store Y register to $4546.w [Reads: Y Index]
	eor #$4306.w		; 49 06 43 ; Exclusive OR #$4306.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor ($0C.b)		; 52 0C ; Exclusive OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $64.b		; 05 64 ; Logical OR $64.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$1204.w		; 09 04 12 ; Logical OR #$1204.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $45		; 30 45 ; Branch if minus to $30, $45 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7E00.w,X		; 3C 00 7E ; Test bits $7E00.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $3C43.w,X		; 3C 43 3C ; Test bits $3C43.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	.db $42, $24		; 42 24 ; Reserved instruction
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	sta $A4.b,S		; 83 A4 ; Store accumulator (stack relative) $A4.b,S [Reads: Accumulator, Stack Pointer]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	bit $2404.w		; 2C 04 24 ; Test bits $2404.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $10.b,S		; 43 10 ; Exclusive OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp ($2802.w,X)		; 7C 02 28 ; Jump indirect indexed to ($2802.w,X) [Reads: X Index] [Flow: jump]
	stz $20.b		; 64 20 ; Store zero to $20.b
	eor $74.b,S		; 43 74 ; Exclusive OR accumulator with stack relative $74.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $30, $09		; 30 09 ; Branch if minus to $30, $09 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($5C54.w,X)		; 7C 54 5C ; Jump indirect indexed to ($5C54.w,X) [Reads: X Index] [Flow: jump]
	jmp $384C.w		; 4C 4C 38 ; Jump to $384C.w [Flow: jump]
	eor $3C.b		; 45 3C ; Exclusive OR $3C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0110.w		; 2C 10 01 ; Test bits $0110.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $23.b		; 24 23 ; Test bits $23.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	bit $02.b,X		; 34 02 ; Test bits $02.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $3C4B00.l,X		; FF 00 4B 3C ; Subtract with carry (long,X) $3C4B00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3C.b		; 25 3C ; Logical AND $3C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda $1F7F4E.l,X		; BF 4E 7F 1F ; Load long $1F7F4E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $1F44.w,X		; 3D 44 1F ; AND accumulator with memory $1F44.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rol $1F07.w,X		; 3E 07 1F ; Rotate left $1F07.w,X [Reads: X Index] [Flags: ZNC]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $133F22.l,X		; 7F 22 3F 13 ; Add long $133F22.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $FE030F.l,X		; 1F 0F 03 FE ; Logical OR long $FE030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	trb $FEF7.w		; 1C F7 FE ; Test and reset bits $FEF7.w [Reads: Accumulator] [Flags: Z]
	cmp $FE.b,S		; C3 FE ; Compare accumulator (stack relative) $FE.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $FCFC.w		; 0E FC FC ; Arithmetic shift left $FCFC.w [Flags: ZNC]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $FCFE.w		; 0C FE FC ; Test and set bits $FCFE.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $39		; F0 39 ; Branch if equal to $F0, $39 [Flow: branch]
	ora $1C3C.w,Y		; 19 3C 1C ; OR accumulator with memory $1C3C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $1C18.w,Y		; 39 18 1C ; AND accumulator with memory $1C18.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $1A85.w		; 0C 85 1A ; Test and set bits $1A85.w [Reads: Accumulator] [Flags: Z]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rol $23.b		; 26 23 ; Rotate left $23.b [Reads: Direct Page] [Flags: ZNC]
	bit $27.b		; 24 27 ; Test bits $27.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $7C03.w		; 0C 03 7C ; Test and set bits $7C03.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ror $004A.w		; 6E 4A 00 ; Rotate right $004A.w [Flags: ZNC]
	sbc $00CE19.l,X		; FF 19 CE 00 ; Subtract with carry (long,X) $00CE19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sty $DE.b		; 84 DE ; Store Y register to $DE.b [Reads: Y Index]
	lda ($35.b),Y		; B1 35 ; Load accumulator ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $B5.b,X		; B5 B5 ; Load $B5.b,X into accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	lda ($CE.b),Y		; B1 CE ; Load accumulator ($CE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and [$1C.b],Y		; 37 1C ; AND accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1E0D3F.l,X		; 1F 3F 0D 1E ; Logical OR long $1E0D3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $028383.l,X		; 3F 83 83 02 ; AND accumulator with memory (long,X) $028383.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	pea $C8F4.w		; F4 F4 C8 ; Push absolute address $C8F4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jmp ($BC80.w,X)		; 7C 80 BC ; Jump indirect indexed to ($BC80.w,X) [Reads: X Index] [Flow: jump]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	stz $9460.w		; 9C 60 94 ; Store zero to $9460.w
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Accumulator, Stack Pointer] [Flags: ZN]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: ZNC]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	jsr ($22CC.w,X)		; FC CC 22 ; Jump to subroutine indirect indexed ($22CC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sty $03.b,X		; 94 03 ; Store Y register $03.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	cpx #$2B7F.w		; E0 7F 2B ; Compare #$2B7F.w with X register [Reads: X Index] [Flags: ZNC]
	mvp $2F,$7F		; 44 7F 2F ; Move block positive $2F,$7F [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$3028.w		; E0 28 30 ; Compare #$3028.w with X register [Reads: X Index] [Flags: ZNC]
	.db $70, $2F		; 70 2F ; Branch if overflow set to $70, $2F [Flow: branch]
	adc $1F3F20.l,X		; 7F 20 3F 1F ; Add long $1F3F20.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $505400.l,X		; 1F 00 54 50 ; Logical OR long $505400.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $50, $4F		; 50 4F ; Branch if overflow clear to $50, $4F [Flow: branch]
	eor $1F2050.l,X		; 5F 50 20 1F ; Exclusive OR accumulator with memory (long,X) $1F2050.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sty $00.b,X		; 94 00 ; Store Y register $00.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	pei ($D0.b)		; D4 D0 ; Push effective indirect address ($D0.b) [Reads: Direct Page] [Writes: Stack Pointer]
	jsr ($FCF8.w,X)		; FC F8 FC ; Jump to subroutine indirect indexed ($FCF8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FC00.w,X)		; FC 00 FC ; Jump to subroutine indirect indexed ($FC00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $FC04.w		; 2C 04 FC ; Test bits $FC04.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	jsr ($0404.w,X)		; FC 04 04 ; Jump to subroutine indirect indexed ($0404.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $34.b,S		; 43 34 ; Exclusive OR accumulator with stack relative $34.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $32		; 10 32 ; Branch if plus to $10, $32 [Flow: branch]
	trb $D483.w		; 1C 83 D4 ; Test and reset bits $D483.w [Reads: Accumulator] [Flags: Z]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $1010.w,X		; 3C 10 10 ; Test bits $1010.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $3E43.w,X		; 3C 43 3E ; Test bits $3E43.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	bit $1000.w,X		; 3C 00 10 ; Test bits $1000.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	eor $39.b,S		; 43 39 ; Exclusive OR accumulator with stack relative $39.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	pea $E870.w		; F4 70 E8 ; Push absolute address $E870.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $D0, $40		; D0 40 ; Branch if not equal to $D0, $40 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $270700.l		; 22 00 07 27 ; Jump to subroutine long $270700.l [Writes: Stack Pointer] [Flow: call]
	and [$46.b]		; 27 46 ; AND accumulator with memory (long) [$46.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sty $B098.w		; 8C 98 B0 ; Store Y register to $B098.w [Reads: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	mvp $0B,$02		; 44 02 0B ; Move block positive $0B,$02 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	cpx #$1455.w		; E0 55 14 ; Compare #$1455.w with X register [Reads: X Index] [Flags: ZNC]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	asl $051F.w		; 0E 1F 05 ; Arithmetic shift left $051F.w [Flags: ZNC]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	ora $0C0C.w		; 0D 0C 0C ; Logical OR $0C0C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($1A.b),Y		; 11 1A ; OR accumulator with memory ($1A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$6200.w		; C0 00 62 ; Compare #$6200.w with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	adc $40.b		; 65 40 ; Add $40.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	eor $9340.w,Y		; 59 40 93 ; Exclusive OR accumulator with memory $9340.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $82, $B7, $86		; 82 B7 86 ; Branch always long to $82, $B7, $86 [Flow: branch]
	lda [$86.b]		; A7 86 ; Load accumulator (long) [$86.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	dec $C0CC.w		; CE CC C0 ; Decrement $C0CC.w [Flags: ZN]
	ldx #$BFA7.w		; A2 A7 BF ; Load #$BFA7.w into X register [Writes: X Index] [Flags: ZN]
	adc $5949.w		; 6D 49 59 ; Add $5949.w to accumulator with carry [Writes: Accumulator] [Flags: ZVNC]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	trb $1A3D.w		; 1C 3D 1A ; Test and reset bits $1A3D.w [Reads: Accumulator] [Flags: Z]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $7E.b,X		; 34 7E ; Test bits $7E.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	and ($7D.b),Y		; 31 7D ; AND accumulator with memory ($7D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr $4422.w		; 20 22 44 ; Jump to subroutine at $4422.w [Writes: Stack Pointer] [Flow: call]
	eor ($43.b,X)		; 41 43 ; Exclusive OR accumulator with memory ($43.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F800.w		; E0 00 F8 ; Compare #$F800.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$38FC.w		; E0 FC 38 ; Compare #$38FC.w with X register [Reads: X Index] [Flags: ZNC]
	ldy $7E58.w,X		; BC 58 7E ; Load Y register $7E58.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	cpy $8CFE.w		; CC FE 8C ; Compare $8CFE.w with Y register [Reads: Y Index] [Flags: ZNC]
	dec $002C.w,X		; DE 2C 00 ; Decrement memory $002C.w,X [Reads: X Index] [Flags: ZN]
	cpx #$0418.w		; E0 18 04 ; Compare #$0418.w with X register [Reads: X Index] [Flags: ZNC]
	mvp $82,$C2		; 44 C2 82 ; Move block positive $82,$C2 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	jsl $070027.l		; 22 27 00 07 ; Jump to subroutine long $070027.l [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $0D1F02.l		; 0F 02 1F 0D ; OR accumulator with memory (long) $0D1F02.l [Writes: Accumulator] [Flags: ZN]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $1512.w		; 0D 12 15 ; Logical OR $1512.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $B8		; B0 B8 ; Branch if carry set to $B0, $B8 [Flow: branch]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $40.b,S		; 63 40 ; Add with carry (stack relative) $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	.db $B0, $48		; B0 48 ; Branch if carry set to $B0, $48 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $0F1F00.l		; 0F 00 1F 0F ; OR accumulator with memory (long) $0F1F00.l [Writes: Accumulator] [Flags: ZN]
	and $001F1F.l,X		; 3F 1F 1F 00 ; AND accumulator with memory (long,X) $001F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	ora $00801F.l,X		; 1F 1F 80 00 ; Logical OR long $00801F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $8C		; 10 8C ; Branch if plus to $10, $8C [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $80		; 90 80 ; Branch if carry clear to $90, $80 [Flow: branch]
	cpy #$F0E0.w		; C0 E0 F0 ; Compare #$F0E0.w with Y register [Reads: Y Index] [Flags: ZNC]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	stz $F8.b,X		; 74 F8 ; Store zero to $F8.b,X [Reads: X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	sbc $307060.l		; EF 60 70 30 ; Subtract with carry (long) $307060.l [Writes: Accumulator] [Flags: ZVNC]
	jmp ($7F0C.w,X)		; 7C 0C 7F ; Jump indirect indexed to ($7F0C.w,X) [Reads: X Index] [Flow: jump]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora #$0E37.w		; 09 37 0E ; Logical OR #$0E37.w with accumulator [Writes: Accumulator] [Flags: ZN]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $58734F.l,X		; 9F 4F 73 58 ; Store accumulator (long,X) $58734F.l,X [Reads: Accumulator, X Index]
	rol $21.b		; 26 21 ; Rotate left $21.b [Reads: Direct Page] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	.db $90, $80		; 90 80 ; Branch if carry clear to $90, $80 [Flow: branch]
	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	.db $F0, $A0		; F0 A0 ; Branch if equal to $F0, $A0 [Flow: branch]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ldy #$D070.w		; A0 70 D0 ; Load #$D070.w into Y register [Writes: Y Index] [Flags: ZN]
	.db $90, $30		; 90 30 ; Branch if carry clear to $90, $30 [Flow: branch]
	.db $50, $90		; 50 90 ; Branch if overflow clear to $50, $90 [Flow: branch]
	sta $30.b,S		; 83 30 ; Store accumulator (stack relative) $30.b,S [Reads: Accumulator, Stack Pointer]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2E02.w,X		; 1D 02 2E ; OR accumulator with memory $2E02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($36.b),Y		; 11 36 ; OR accumulator with memory ($36.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora #$334C.w		; 09 4C 33 ; Logical OR #$334C.w with accumulator [Writes: Accumulator] [Flags: ZN]
	eor $3A.b		; 45 3A ; Exclusive OR $3A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor [$38.b]		; 47 38 ; Exclusive OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and ($2A.b)		; 32 2A ; AND accumulator with memory (indirect) ($2A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stz $7D.b,X		; 74 7D ; Store zero to $7D.b,X [Reads: X Index]
	jmp ($4883.w,X)		; 7C 83 48 ; Jump indirect indexed to ($4883.w,X) [Reads: X Index] [Flow: jump]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $98.b		; 64 98 ; Store zero to $98.b
	mvn $2A,$A8		; 54 A8 2A ; Move block negative $2A,$A8 [Reads: Accumulator, X Index, Y Index] [Writes: Accumulator, X Index, Y Index]
	pei ($A2.b)		; D4 A2 ; Push effective indirect address ($A2.b) [Reads: Direct Page] [Writes: Stack Pointer]
	jmp $001CE2.l		; 5C E2 1C 00 ; Jump long to $001CE2.l [Flow: jump]
	cpx #$5CF8.w		; E0 F8 5C ; Compare #$5CF8.w with X register [Reads: X Index] [Flags: ZNC]
	jmp ($BE36.w)		; 6C 36 BE ; Jump indirect to ($BE36.w) [Flow: jump]
	rol $0025.w,X		; 3E 25 00 ; Rotate left $0025.w,X [Reads: X Index] [Flags: ZNC]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($38.b,X)		; 01 38 ; Logical OR ($38.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $002507.l		; 22 07 25 00 ; Jump to subroutine long $002507.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy #$3000.w		; C0 00 30 ; Compare #$3000.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora [$C0.b]		; 07 C0 ; OR accumulator with memory (long) [$C0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $90		; F0 90 ; Branch if equal to $F0, $90 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora ($18.b)		; 12 18 ; OR accumulator with memory (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($3C.b)		; 72 3C ; Add with carry (indirect) ($3C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($7E.b),Y		; F1 7E ; Subtract with carry ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	cmp ($7E.b,X)		; C1 7E ; Compare accumulator ($7E.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	sbc $FD7E.w,Y		; F9 7E FD ; Subtract with carry $FD7E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZVNC]
	ror $18.b		; 66 18 ; Rotate right $18.b [Reads: Direct Page] [Flags: ZNC]
	bit $247E.w,X		; 3C 7E 24 ; Test bits $247E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sbc $1A3B03.l,X		; FF 03 3B 1A ; Subtract with carry (long,X) $1A3B03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $4320.w,X		; 7D 20 43 ; Add $4320.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $1521.w,X		; 7D 21 15 ; Add $1521.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and ($3F.b,S),Y		; 33 3F ; AND accumulator (stack relative indirect indexed) ($3F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $07071F.l,X		; 1F 1F 07 07 ; Logical OR long $07071F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $4C5E5E.l,X		; 5F 5E 5E 4C ; Exclusive OR accumulator with memory (long,X) $4C5E5E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	jsr $0718.w		; 20 18 07 ; Jump to subroutine at $0718.w [Writes: Stack Pointer] [Flow: call]
	jmp ($3878.w,X)		; 7C 78 38 ; Jump indirect indexed to ($3878.w,X) [Reads: X Index] [Flow: jump]
	jsr $A0B0.w		; 20 B0 A0 ; Jump to subroutine at $A0B0.w [Writes: Stack Pointer] [Flow: call]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpy #$6015.w		; C0 15 60 ; Compare #$6015.w with Y register [Reads: Y Index] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpy #$8080.w		; C0 80 80 ; Compare #$8080.w with Y register [Reads: Y Index] [Flags: ZNC]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	jsr $40A0.w		; 20 A0 40 ; Jump to subroutine at $40A0.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $7B		; 80 7B ; Branch always to $80, $7B [Flow: branch]
	rol $3F.b,X		; 36 3F ; Rotate left $3F.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $061E1C.l,X		; 3F 1C 1E 06 ; AND accumulator with memory (long,X) $061E1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cop $13.b		; 02 13 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	lsr $20.b		; 46 20 ; Logical shift right $20.b [Reads: Direct Page] [Flags: ZNC]
	jsr $0519.w		; 20 19 05 ; Jump to subroutine at $0519.w [Writes: Stack Pointer] [Flow: call]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $BE.b,S		; 03 BE ; OR accumulator with stack relative $BE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jmp $987C.w		; 4C 7C 98 ; Jump to $987C.w [Flow: jump]
	jsr ($7838.w,X)		; FC 38 78 ; Jump to subroutine indirect indexed ($7838.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $60.b,S		; 43 60 ; Exclusive OR accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	cpx #$E03D.w		; E0 3D E0 ; Compare #$E03D.w with X register [Reads: X Index] [Flags: ZNC]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $42, $84		; 42 84 ; Reserved instruction
	tsb $98.b		; 04 98 ; Test and set bits $98.b [Reads: Accumulator] [Flags: Z]
	ldy #$20A0.w		; A0 A0 20 ; Load #$20A0.w into Y register [Writes: Y Index] [Flags: ZN]
	cpy #$1939.w		; C0 39 19 ; Compare #$1939.w with Y register [Reads: Y Index] [Flags: ZNC]
	bit $3B1C.w,X		; 3C 1C 3B ; Test bits $3B1C.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $1F0C.w		; 1C 0C 1F ; Test and reset bits $1F0C.w [Reads: Accumulator] [Flags: Z]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: ZN]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $24.b,S		; 23 24 ; AND accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and [$13.b]		; 27 13 ; AND accumulator with memory (long) [$13.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	ora $7C.b,S		; 03 7C ; OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $DC08.w		; 2C 08 DC ; Test bits $DC08.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	cld		; D8 ; Clear decimal flag [Flags: D]
	trb $3818.w		; 1C 18 38 ; Test and reset bits $3818.w [Reads: Accumulator] [Flags: Z]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	sty $D4.b		; 84 D4 ; Store Y register to $D4.b [Reads: Y Index]
	bit $E4.b		; 24 E4 ; Test bits $E4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	ora $1F4501.l,X		; 1F 01 45 1F ; Logical OR long $1F4501.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	bit $1E.b		; 24 1E ; Test bits $1E.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: ZNC]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	trb $15.b		; 14 15 ; Test and reset bits $15.b [Reads: Accumulator] [Flags: Z]
	ora $E80F09.l		; 0F 09 0F E8 ; OR accumulator with memory (long) $E80F09.l [Writes: Accumulator] [Flags: ZN]
	.db $90, $E8		; 90 E8 ; Branch if carry clear to $90, $E8 [Flow: branch]
	.db $10, $E8		; 10 E8 ; Branch if plus to $10, $E8 [Flow: branch]
	.db $90, $68		; 90 68 ; Branch if carry clear to $90, $68 [Flow: branch]
	.db $50, $68		; 50 68 ; Branch if overflow clear to $50, $68 [Flow: branch]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	clv		; B8 ; Clear overflow flag [Flags: V]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jsl $3105F0.l		; 22 F0 05 31 ; Jump to subroutine long $3105F0.l [Writes: Stack Pointer] [Flow: call]
	ora #$0838.w		; 09 38 08 ; Logical OR #$0838.w with accumulator [Writes: Accumulator] [Flags: ZN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $7C.b,S		; 43 7C ; Exclusive OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $3F1A.w		; 1C 1A 3F ; Test and reset bits $3F1A.w [Reads: Accumulator] [Flags: Z]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$47.b]		; 27 47 ; AND accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr $0718.w		; 20 18 07 ; Jump to subroutine at $0718.w [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	cpx #$E0E6.w		; E0 E6 E0 ; Compare #$E0E6.w with X register [Reads: X Index] [Flags: ZNC]
	sbc ($B2.b,S),Y		; F3 B2 ; Subtract with carry (stack relative indirect indexed) ($B2.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	adc $00FE1C.l,X		; 7F 1C FE 00 ; Add long $00FE1C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jmp.w [$8000]		; DC 00 80 ; Jump long indirect [$8000] [Flow: jump]
	jsl $180700.l		; 22 00 07 18 ; Jump to subroutine long $180700.l [Writes: Stack Pointer] [Flow: call]
	asl $A14D.w,X		; 1E 4D A1 ; Arithmetic shift left $A14D.w,X [Reads: X Index] [Flags: ZNC]
	adc ($5C.b)		; 72 5C ; Add with carry (indirect) ($5C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	eor $63.b,S		; 43 63 ; Exclusive OR accumulator with stack relative $63.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $791B.w		; 1C 1B 79 ; Test and reset bits $791B.w [Reads: Accumulator] [Flags: Z]
	rol $77.b		; 26 77 ; Rotate left $77.b [Reads: Direct Page] [Flags: ZNC]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	trb $1E3E.w		; 1C 3E 1E ; Test and reset bits $1E3E.w [Reads: Accumulator] [Flags: Z]
	asl $0706.w,X		; 1E 06 07 ; Arithmetic shift left $0706.w,X [Reads: X Index] [Flags: ZNC]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $4F5F.w,X		; 7E 5F 4F ; Rotate right $4F5F.w,X [Reads: X Index] [Flags: ZNC]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $F607.w,Y		; 19 07 F6 ; OR accumulator with memory $F607.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $DE00.w,X		; FE 00 DE ; Increment memory $DE00.w,X [Reads: X Index] [Flags: ZN]
	bit $EE.b		; 24 EE ; Test bits $EE.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	tsb $2C43.w		; 0C 43 2C ; Test and set bits $2C43.w [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr $00E0.w		; 20 E0 00 ; Jump to subroutine at $00E0.w [Writes: Stack Pointer] [Flow: call]
	lsr $BA46.w		; 4E 46 BA ; Logical shift right $BA46.w [Flags: ZNC]
	sbc ($D4.b)		; F2 D4 ; Subtract with carry (indirect) ($D4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	pei ($D8.b)		; D4 D8 ; Push effective indirect address ($D8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cpx #$0C3C.w		; E0 3C 0C ; Compare #$0C3C.w with X register [Reads: X Index] [Flags: ZNC]
	rol $3F0A.w,X		; 3E 0A 3F ; Rotate left $3F0A.w,X [Reads: X Index] [Flags: ZNC]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $131400.l		; 22 00 14 13 ; Jump to subroutine long $131400.l [Writes: Stack Pointer] [Flow: call]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $020D.w		; 0C 0D 02 ; Test and set bits $020D.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $00.b		; 64 00 ; Store zero to $00.b
	tsb $BC08.w		; 0C 08 BC ; Test and set bits $BC08.w [Reads: Accumulator] [Flags: Z]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$80F8.w		; C0 F8 80 ; Compare #$80F8.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpy #$0022.w		; C0 22 00 ; Compare #$0022.w with Y register [Reads: Y Index] [Flags: ZNC]
	ora [$98.b]		; 07 98 ; OR accumulator with memory (long) [$98.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: ZNC]
	eor [$14.b]		; 47 14 ; Exclusive OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $3E3E01.l,X		; 7F 01 3E 3E ; Add long $3E3E01.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	eor ($3E.b,X)		; 41 3E ; Exclusive OR accumulator with memory ($3E.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc [$4A.b]		; E7 4A ; Subtract with carry (long) [$4A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $04.b		; 24 04 ; Test bits $04.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	.db $42, $3C		; 42 3C ; Reserved instruction
	ror $E700.w,X		; 7E 00 E7 ; Rotate right $E700.w,X [Reads: X Index] [Flags: ZNC]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	ora #$7E42.w		; 09 42 7E ; Logical OR #$7E42.w with accumulator [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tsb $1203.w		; 0C 03 12 ; Test and set bits $1203.w [Reads: Accumulator] [Flags: Z]
	ora $431F2E.l		; 0F 2E 1F 43 ; OR accumulator with memory (long) $431F2E.l [Writes: Accumulator] [Flags: ZN]
	jmp $B8433F.l		; 5C 3F 43 B8 ; Jump long to $B8433F.l [Flow: jump]
	adc $0F030F.l,X		; 7F 0F 03 0F ; Add long $0F030F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $7F7F3F.l,X		; 1F 3F 7F 7F ; Logical OR long $7F7F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sbc $00C0FF.l,X		; FF FF C0 00 ; Subtract with carry (long,X) $00C0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $FA.b,S		; 43 FA ; Exclusive OR accumulator with stack relative $FA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	jsr ($FD0B.w,X)		; FC 0B FD ; Jump to subroutine indirect indexed ($FD0B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FE0D.w,X		; FE 0D FE ; Increment memory $FE0D.w,X [Reads: X Index] [Flags: ZN]
	cpy #$F8F0.w		; C0 F0 F8 ; Compare #$F8F0.w with Y register [Reads: Y Index] [Flags: ZNC]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $0083FF.l,X		; FF FF 83 00 ; Subtract with carry (long,X) $0083FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	and #$591F.w		; 29 1F 59 ; Logical AND #$591F.w with accumulator [Writes: Accumulator] [Flags: ZN]
	and $BA3F5B.l,X		; 3F 5B 3F BA ; AND accumulator with memory (long,X) $BA3F5B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $0F92BC.l,X		; 7F BC 92 0F ; Add long $0F92BC.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $82, $FC, $61		; 82 FC 61 ; Branch always long to $82, $FC, $61 [Flow: branch]
	inc $8C39.w,X		; FE 39 8C ; Increment memory $8C39.w,X [Reads: X Index] [Flags: ZN]
	and [$03.b]		; 27 03 ; AND accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $431F2F.l		; 0F 2F 1F 43 ; OR accumulator with memory (long) $431F2F.l [Writes: Accumulator] [Flags: ZN]
	eor $B9023F.l,X		; 5F 3F 02 B9 ; Exclusive OR accumulator with memory (long,X) $B9023F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc $0F9090.l,X		; 7F 90 90 0F ; Add long $0F9090.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	jsr ($ED02.w,X)		; FC 02 ED ; Jump to subroutine indirect indexed ($ED02.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $88C5.w,X		; FE C5 88 ; Increment memory $88C5.w,X [Reads: X Index] [Flags: ZN]
	and [$03.b]		; 27 03 ; AND accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: ZN]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1F.b		; 25 1F ; Logical AND $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $17.b		; 14 17 ; Test and reset bits $17.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$28.b],Y		; 17 28 ; OR accumulator with memory (long indexed) [$28.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $50, $E0		; 50 E0 ; Branch if overflow clear to $50, $E0 [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	.db $50, $E8		; 50 E8 ; Branch if overflow clear to $50, $E8 [Flow: branch]
	trb $0A.b		; 14 0A ; Test and reset bits $0A.b [Reads: Accumulator] [Flags: Z]
	sta $0390.w		; 8D 90 03 ; Store accumulator to $0390.w [Reads: Accumulator]
	ora ($78.b,X)		; 01 78 ; Logical OR ($78.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $A0.b,X		; 95 A0 ; Store accumulator to $A0.b,X [Reads: Accumulator, X Index]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	inc $8710.w,X		; FE 10 87 ; Increment memory $8710.w,X [Reads: X Index] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	and ($03.b,S),Y		; 33 03 ; AND accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora [$39.b]		; 07 39 ; OR accumulator with memory (long) [$39.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$49.b]		; 07 49 ; OR accumulator with memory (long) [$49.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	and [$91.b],Y		; 37 91 ; AND accumulator with memory (long indexed) [$91.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	adc $B87F80.l		; 6F 80 7F B8 ; Add with carry (long) $B87F80.l [Writes: Accumulator] [Flags: ZVNC]
	eor [$03.b]		; 47 03 ; Exclusive OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	and $9149.w,Y		; 39 49 91 ; AND accumulator with memory $9149.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $80, $B8		; 80 B8 ; Branch always to $80, $B8 [Flow: branch]
	cpy #$2000.w		; C0 00 20 ; Compare #$2000.w with Y register [Reads: Y Index] [Flags: ZNC]
	cpy #$E090.w		; C0 90 E0 ; Compare #$E090.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	cpx $EAF0.w		; EC F0 EA ; Compare $EAF0.w with X register [Reads: X Index] [Flags: ZNC]
	pea $FEC1.w		; F4 C1 FE ; Push absolute address $FEC1.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $FE.b		; 05 FE ; Logical OR $FE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	cpy #$9020.w		; C0 20 90 ; Compare #$9020.w with Y register [Reads: Y Index] [Flags: ZNC]
	.db $D0, $EC		; D0 EC ; Branch if not equal to $D0, $EC [Flow: branch]
	nop		; EA ; No operation
	cmp ($05.b,X)		; C1 05 ; Compare accumulator ($05.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	tsb DMALEN0B.w		; 0C 07 43 ; Test and set bits DMALEN0B.w [Reads: Accumulator] [Flags: Z]
	ora $0F0E.w,Y		; 19 0E 0F ; OR accumulator with memory $0F0E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $311C33.l		; 0F 33 1C 31 ; OR accumulator with memory (long) $311C33.l [Writes: Accumulator] [Flags: ZN]
	asl $1837.w,X		; 1E 37 18 ; Arithmetic shift left $1837.w,X [Reads: X Index] [Flags: ZNC]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	asl $1F1E.w,X		; 1E 1E 1F ; Arithmetic shift left $1F1E.w,X [Reads: X Index] [Flags: ZNC]
	bit $383E.w,X		; 3C 3E 38 ; Test bits $383E.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sta $A8.b,S		; 83 A8 ; Store accumulator (stack relative) $A8.b,S [Reads: Accumulator, Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$AC.b]		; 47 AC ; Exclusive OR accumulator with memory (long) [$AC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: X Index, Stack Pointer] [Flags: ZN]
	tsb $FD.b		; 04 FD ; Test and set bits $FD.b [Reads: Accumulator] [Flags: Z]
	cop $ED.b		; 02 ED ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	cmp $6E.b,X		; D5 6E ; Compare accumulator $6E.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	cmp $8066.w,Y		; D9 66 80 ; Compare accumulator $8066.w,Y [Reads: Y Index] [Flags: ZNC]
	cpy #$366C.w		; C0 6C 36 ; Compare #$366C.w with Y register [Reads: Y Index] [Flags: ZNC]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $10E7EF.l,X		; 7F EF E7 10 ; Add long $10E7EF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $6F		; 10 6F ; Branch if plus to $10, $6F [Flow: branch]
	and ($6C.b,S),Y		; 33 6C ; AND accumulator (stack relative indirect indexed) ($6C.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $1C1F30.l,X		; 3F 30 1F 1C ; AND accumulator with memory (long,X) $1C1F30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $19.b,X		; 36 19 ; Rotate left $19.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	and ($1D.b)		; 32 1D ; AND accumulator with memory (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	.db $10, $3B		; 10 3B ; Branch if plus to $10, $3B [Flow: branch]
	adc $1F3F7F.l,X		; 7F 7F 3F 1F ; Add long $1F3F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	and $00083F.l,X		; 3F 3F 08 00 ; AND accumulator with memory (long,X) $00083F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	pei ($08.b)		; D4 08 ; Push effective indirect address ($08.b) [Reads: Direct Page] [Writes: Stack Pointer]
	inc $CC.b,X		; F6 CC ; Increment memory $CC.b,X [Reads: X Index, Direct Page] [Flags: ZN]
	rol $FC.b,X		; 36 FC ; Rotate left $FC.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	jmp $28B8.w		; 4C B8 28 ; Jump to $28B8.w [Flow: jump]
	.db $D0, $6C		; D0 6C ; Branch if not equal to $D0, $6C [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	jmp $08B8.w		; 4C B8 08 ; Jump to $08B8.w [Flow: jump]
	jmp.w [$FEFE]		; DC FE FE ; Jump long indirect [$FEFE] [Flow: jump]
	ldy $FCF8.w,X		; BC F8 FC ; Load Y register $FCF8.w,X [Reads: X Index] [Writes: Y Index] [Flags: ZN]
	jsr ($7FB0.w,X)		; FC B0 7F ; Jump to subroutine indirect indexed ($7FB0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lda $5F437F.l,X		; BF 7F 43 5F ; Load long $5F437F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $1F2F09.l,X		; 3F 09 2F 1F ; AND accumulator with memory (long,X) $1F2F09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $046283.l,X		; FF 83 62 04 ; Subtract with carry (long,X) $046283.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $43FE.w,X		; 1D FE 43 ; OR accumulator with memory $43FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	jsr ($7414.w,X)		; FC 14 74 ; Jump to subroutine indirect indexed ($7414.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: ZNC]
	sbc $FEFEFF.l,X		; FF FF FE FE ; Subtract with carry (long,X) $FEFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$7F9C.w		; C0 9C 7F ; Compare #$7F9C.w with Y register [Reads: Y Index] [Flags: ZNC]
	stx $7F.b		; 86 7F ; Store X register to $7F.b [Reads: X Index]
	eor ($92.b,X)		; 41 92 ; Exclusive OR accumulator with memory ($92.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	and $5DFE.w,X		; 3D FE 5D ; AND accumulator with memory $5DFE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	inc $FCDA.w,X		; FE DA FC ; Increment memory $FCDA.w,X [Reads: X Index] [Flags: ZN]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	jsr ($F894.w,X)		; FC 94 F8 ; Jump to subroutine indirect indexed ($F894.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $04A3.w		; 8C A3 04 ; Store Y register to $04A3.w [Reads: Y Index]
	ora $A3.b,S		; 03 A3 ; OR accumulator with stack relative $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	adc $437FB7.l,X		; 7F B7 7F 43 ; Add long $437FB7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	eor $888F3F.l,X		; 5F 3F 8F 88 ; Exclusive OR accumulator with memory (long,X) $888F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora #$9DFE.w		; 09 FE 9D ; Logical OR #$9DFE.w with accumulator [Writes: Accumulator] [Flags: ZN]
	inc $FA43.w,X		; FE 43 FA ; Increment memory $FA43.w,X [Reads: X Index] [Flags: ZN]
	jsr ($F402.w,X)		; FC 02 F4 ; Jump to subroutine indirect indexed ($F402.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	sty $04A3.w		; 8C A3 04 ; Store Y register to $04A3.w [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $95.b		; 84 95 ; Store Y register to $95.b [Reads: Y Index]
	ora $12.b,S		; 03 12 ; OR accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	.db $50, $58		; 50 58 ; Branch if overflow clear to $50, $58 [Flow: branch]
	eor [$5F.b],Y		; 57 5F ; Exclusive OR accumulator with memory (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	and $030C13.l		; 2F 13 0C 03 ; AND accumulator with memory (long) $030C13.l [Writes: Accumulator] [Flags: ZN]
	lsr $0E00.w		; 4E 00 0E ; Logical shift right $0E00.w [Flags: ZNC]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $AD.b		; 84 AD ; Store Y register to $AD.b [Reads: Y Index]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	cpy #$0A00.w		; C0 00 0A ; Compare #$0A00.w with Y register [Reads: Y Index] [Flags: ZNC]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: ZN]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	pea $30C8.w		; F4 C8 30 ; Push absolute address $30C8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpy #$1F7F.w		; C0 7F 1F ; Compare #$1F7F.w with Y register [Reads: Y Index] [Flags: ZNC]
	eor $7E.b,S		; 43 7E ; Exclusive OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	asl $7F05.w,X		; 1E 05 7F ; Arithmetic shift left $7F05.w,X [Reads: X Index] [Flags: ZNC]
	ora $1F0F3F.l,X		; 1F 3F 0F 1F ; Logical OR long $1F0F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: ZN]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	eor ($41.b,X)		; 41 41 ; Exclusive OR accumulator with memory ($41.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	jsr $0C10.w		; 20 10 0C ; Jump to subroutine at $0C10.w [Writes: Stack Pointer] [Flow: call]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lsr $4358.w,X		; 5E 58 43 ; Logical shift right $4358.w,X [Reads: X Index] [Flags: ZNC]
	rol $0318.w,X		; 3E 18 03 ; Rotate left $0318.w,X [Reads: X Index] [Flags: ZNC]
	bit $F830.w,X		; 3C 30 F8 ; Test bits $F830.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cpy #$C283.w		; C0 83 C2 ; Compare #$C283.w with Y register [Reads: Y Index] [Flags: ZNC]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $A2.b		; 02 A2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rep #$C2		; C2 C2 ; Reset processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	cpy $08.b		; C4 08 ; Compare $08.b with Y register [Reads: Direct Page, Y Index] [Flags: ZNC]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	jmp $192623.l		; 5C 23 26 19 ; Jump long to $192623.l [Flow: jump]
	ora $1F3F02.l,X		; 1F 02 3F 1F ; Logical OR long $1F3F02.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	bit $1E1F.w,X		; 3C 1F 1E ; Test bits $1E1F.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	sty $EB.b		; 84 EB ; Store Y register to $EB.b [Reads: Y Index]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	jmp $3F1F26.l		; 5C 26 1F 3F ; Jump long to $3F1F26.l [Flow: jump]
	sta $94.b,S		; 83 94 ; Store accumulator (stack relative) $94.b,S [Reads: Accumulator, Stack Pointer]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	eor [$1B.b]		; 47 1B ; Exclusive OR accumulator with memory (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	jsr ($F806.w,X)		; FC 06 F8 ; Jump to subroutine indirect indexed ($F806.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: ZNC]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $98.b		; 06 98 ; Arithmetic shift left $98.b [Reads: Direct Page] [Flags: ZNC]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	adc $3C.b,S		; 63 3C ; Add with carry (stack relative) $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC]
	adc $71CF30.l		; 6F 30 CF 71 ; Add with carry (long) $71CF30.l [Writes: Accumulator] [Flags: ZVNC]
	lda [$49.b],Y		; B7 49 ; Load accumulator (long indexed) [$49.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ldx $D943.w,Y		; BE 43 D9 ; Load X register $D943.w,Y [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	ror $60.b		; 66 60 ; Rotate right $60.b [Reads: Direct Page] [Flags: ZNC]
	and $7D003F.l,X		; 3F 3F 00 7D ; AND accumulator with memory (long,X) $7D003F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	adc ($F3.b),Y		; 71 F3 ; Add with carry ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc [$FE.b]		; E7 FE ; Subtract with carry (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	adc $D4BA3F.l,X		; 7F 3F BA D4 ; Add long $D4BA3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	lda ($EC.b)		; B2 EC ; Load accumulator (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	cpx $98.b		; E4 98 ; Compare $98.b with X register [Reads: X Index, Direct Page] [Flags: ZNC]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $30, $90		; 30 90 ; Branch if minus to $30, $90 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $9C8C.w		; EE 8C 9C ; Increment $9C8C.w [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	.db $80, $83		; 80 83 ; Branch always to $80, $83 [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Stack Pointer, Y Index] [Flags: ZN]
	ora $49.b		; 05 49 ; Logical OR $49.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C0324.l		; 0F 24 03 0C ; OR accumulator with memory (long) $0C0324.l [Writes: Accumulator] [Flags: ZN]
	ora ($38.b,X)		; 01 38 ; Logical OR ($38.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$8040.w		; C0 40 80 ; Compare #$8040.w with Y register [Reads: Y Index] [Flags: ZNC]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $50		; 80 50 ; Branch always to $80, $50 [Flow: branch]
	ldy #$E070.w		; A0 70 E0 ; Load #$E070.w into Y register [Writes: Y Index] [Flags: ZN]
	sta $C4.b,S		; 83 C4 ; Store accumulator (stack relative) $C4.b,S [Reads: Accumulator, Stack Pointer]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	cpx #$F0B0.w		; E0 B0 F0 ; Compare #$F0B0.w with X register [Reads: X Index] [Flags: ZNC]
	cpx #$FF80.w		; E0 80 FF ; Compare #$FF80.w with X register [Reads: X Index] [Flags: ZNC]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C9F.w		; 0C 9F 1C ; Test and set bits $1C9F.w [Reads: Accumulator] [Flags: Z]
	lda $1C9D3E.l,X		; BF 3E 9D 1C ; Load long $1C9D3E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	sta $14.b,X		; 95 14 ; Store accumulator to $14.b,X [Reads: Accumulator, X Index]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E372.w,X		; 3C 72 E3 ; Test bits $E372.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	cmp ($E3.b,X)		; C1 E3 ; Compare accumulator ($E3.b,X) [Reads: Accumulator, X Index, Direct Page] [Flags: ZNC]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7E08.w,X		; 3C 08 7E ; Test bits $7E08.w,X [Reads: X Index] [Flags: ZVN] [Flow: branch]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $BD4306.l,X		; DF 06 43 BD ; Compare accumulator (long,X) $BD4306.l,X [Reads: Accumulator, X Index] [Flags: ZNC]
	bit $07.b		; 24 07 ; Test bits $07.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $42.b		; 24 42 ; Test bits $42.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZVN]
	sta ($A1.b,S),Y		; 93 A1 ; Store accumulator (stack relative indirect indexed) ($A1.b,S),Y [Reads: Accumulator, Stack Pointer, Y Index]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Accumulator, Stack Pointer]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $5A08.w		; 2C 08 5A ; Test bits $5A08.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: ZN]
	sec		; 38 ; Set carry flag [Flags: C]
	lda [$34.b],Y		; B7 34 ; Load accumulator (long indexed) [$34.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	sbc [$64.b]		; E7 64 ; Subtract with carry (long) [$64.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	sbc $18006C.l		; EF 6C 00 18 ; Subtract with carry (long) $18006C.l [Writes: Accumulator] [Flags: ZVNC]
	bit $66.b,X		; 34 66 ; Test bits $66.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	cmp [$C9.b]		; C7 C9 ; Compare accumulator (long) [$C9.b] [Reads: Accumulator, Direct Page] [Flags: ZNC]
	sta $2291.w,Y		; 99 91 22 ; Store accumulator to $2291.w,Y [Reads: Accumulator, Y Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$07.b]		; 27 07 ; AND accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	bit $17.b,X		; 34 17 ; Test bits $17.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: XVNMZIDC]
	rol $5455.w		; 2E 55 54 ; Rotate left $5455.w [Flags: ZNC]
	adc $007F43.l		; 6F 43 7F 00 ; Add with carry (long) $007F43.l [Writes: Accumulator] [Flags: ZVNC]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	bit $28.b,X		; 34 28 ; Test bits $28.b,X [Reads: X Index, Direct Page] [Flags: ZVN] [Flow: branch]
	eor $6F.b,X		; 55 6F ; Exclusive OR accumulator with memory $6F.b,X [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN]
	adc $F8F000.l,X		; 7F 00 F0 F8 ; Add long $F8F000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($7C04.w,X)		; FC 04 7C ; Jump to subroutine indirect indexed ($7C04.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sty $7C.b		; 84 7C ; Store Y register to $7C.b [Reads: Y Index]
	sty $FC.b,X		; 94 FC ; Store Y register $FC.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	ldy $FC.b,X		; B4 FC ; Load Y register $FC.b,X [Reads: X Index, Direct Page] [Writes: Y Index] [Flags: ZN]
	sty $F0.b,X		; 94 F0 ; Store Y register $F0.b,X [Reads: X Index, Direct Page] [Writes: Y Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: ZN]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	jmp ($FC23.w,X)		; 7C 23 FC ; Jump indirect indexed to ($FC23.w,X) [Reads: X Index] [Flow: jump]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	.db $00		; Opcode 00 overrunning bank boundry at 0BFFFF. Skipping. ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ENDS
