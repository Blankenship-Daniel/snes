
; Intro Module Disassembly (from snes2asm)
; ROM Range: $CC120 - $CC200 (Bank 25, offset $4120+)
; Extracted from bank25.asm lines 5570-5650

.lorom
.bank 25 slot 0

; === INTRO MODULE SECTION ===
	sbc ($0F.b,X)		; E1 0F ; Subtract with carry ($0F.b,X) [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZVNC]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZN]
	sbc ($D0.b,S),Y		; F3 D0 ; Subtract with carry (stack relative indirect indexed) ($D0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZVNC]
	.db $F0, $DA		; F0 DA ; Branch if equal to $F0, $DA [Flow: branch]
	lsr $D1.b		; 46 D1 ; Logical shift right $D1.b [Reads: Direct Page] [Flags: ZNC]
	cpy #$4E.b		; C0 4E ; Compare #$4E.b with Y register [Reads: Y Index] [Flags: ZNC]
	and $E0FFE2.l,X		; 3F E2 FF E0 ; AND accumulator with memory (long,X) $E0FFE2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cpy #$21.b		; C0 21 ; Compare #$21.b with Y register [Reads: Y Index] [Flags: ZNC]
	jsr $3DB4.w		; 20 B4 3D ; Jump to subroutine at $3DB4.w [Writes: Stack Pointer] [Flow: call]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: ZN] [SNES: Sets DP register from accumulator]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	trb $CB.b		; 14 CB ; Test and reset bits $CB.b [Reads: Accumulator] [Flags: Z]
	ora ($B7.b,S),Y		; 13 B7 ; OR accumulator (stack relative indirect indexed) ($B7.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	cmp $C4.b		; C5 C4 ; Compare $C4.b with accumulator [Reads: Accumulator, Direct Page] [Flags: ZNC]
	.db $10, $F4		; 10 F4 ; Branch if plus to $10, $F4 [Flow: branch]
	sbc $FD20.w		; ED 20 FD ; Subtract $FD20.w from accumulator with borrow [Writes: Accumulator] [Flags: ZVNC]
	and $C0D401.l		; 2F 01 D4 C0 ; AND accumulator with memory (long) $C0D401.l [Writes: Accumulator] [Flags: ZN]
	cmp ($03.b)		; D2 03 ; Compare accumulator (indirect) ($03.b) [Reads: Accumulator, Direct Page] [Flags: ZNC]
.ACCU 8
	sep #$21		; E2 21
	ora $E21B0D.l,X		; 1F 0D 1B E2 ; Logical OR long $E21B0D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $AD		; B0 AD ; Branch if carry set to $B0, $AD [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: ZNC]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: ZNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	lda $FF.b,S		; A3 FF ; Load accumulator (stack relative) $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZN]
	ror $0FC0.w		; 6E C0 0F ; Rotate right $0FC0.w [Flags: ZNC]
	asl $1E02.w,X		; 1E 02 1E ; Arithmetic shift left $1E02.w,X [Reads: X Index] [Flags: ZNC]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 16
	rep #$EF		; C2 EF
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: ZNC]
	eor $2E30.w		; 4D 30 2E ; Exclusive OR $2E30.w with accumulator [Writes: Accumulator] [Flags: ZN]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $B0, $4C		; B0 4C ; Branch if carry set to $B0, $4C [Flow: branch]
	and ($20.b),Y		; 31 20 ; AND accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	ora $CEDF.w,Y		; 19 DF CE ; OR accumulator with memory $CEDF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: ZN]
	and $FFB0F4.l,X		; 3F F4 B0 FF ; AND accumulator with memory (long,X) $FFB0F4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	and $4DBFE7.l,X		; 3F E7 BF 4D ; AND accumulator with memory (long,X) $4DBFE7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	cmp $FF.b,X		; D5 FF ; Compare accumulator $FF.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	ora ($B0.b,X)		; 01 B0 ; Logical OR ($B0.b,X) with accumulator [Reads: X Index, Direct Page] [Writes: Accumulator] [Flags: ZN] [SNES: Indexed indirect addressing]
	and ($F4.b),Y		; 31 F4 ; AND accumulator with memory ($F4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: ZN]
	lda $E2.b		; A5 E2 ; Load $E2.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: ZN]
	sbc $FEF1.w,X		; FD F1 FE ; Subtract with carry $FEF1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	sep #$C0		; E2 C0 ; Set processor status bits #$C0 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	asl $E110.w		; 0E 10 E1 ; Arithmetic shift left $E110.w [Flags: ZNC]
	and $02F3D3.l,X		; 3F D3 F3 02 ; AND accumulator with memory (long,X) $02F3D3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZN]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	cmp $0F.b,S		; C3 0F ; Compare accumulator (stack relative) $0F.b,S [Reads: Accumulator, Stack Pointer] [Flags: ZNC]
	sbc $1F.b,S		; E3 1F ; Subtract stack-relative $1F.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: ZVNC] [SNES: Stack-relative addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0F.b		; C0 0F ; Compare #$0F.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $10, $F1		; 10 F1 ; Branch if plus to $10, $F1 [Flow: branch]
	jsr $1341.w		; 20 41 13 ; Jump to subroutine at $1341.w [Writes: Stack Pointer] [Flow: call]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$1D.b		; C0 1D ; Compare #$1D.b with Y register [Reads: Y Index] [Flags: ZNC]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	.db $B0, $FD		; B0 FD ; Branch if carry set to $B0, $FD [Flow: branch]
	jsr $132F.w		; 20 2F 13 ; Jump to subroutine at $132F.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $43		; B0 43 ; Branch if carry set to $B0, $43 [Flow: branch]
	cmp $4D.b,X		; D5 4D ; Compare accumulator $4D.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	sbc $C03D4B.l,X		; FF 4B 3D C0 ; Subtract with carry (long,X) $C03D4B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	bit $C0F1.w		; 2C F1 C0 ; Test bits $C0F1.w with accumulator [Reads: Accumulator] [Flags: ZVN]
	sbc $1F00.w,X		; FD 00 1F ; Subtract with carry $1F00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: XVNMZIDC] [Flow: return]

	ora ($C0.b,S),Y		; 13 C0 ; OR accumulator (stack relative indirect indexed) ($C0.b,S),Y [Reads: Stack Pointer, Y Index] [Writes: Accumulator] [Flags: ZN]
	.db $10, $49		; 10 49 ; Branch if plus to $10, $49 [Flow: branch]
	jsr $020D.w		; 20 0D 02 ; Jump to subroutine at $020D.w [Writes: Stack Pointer] [Flow: call]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	sbc $F6B0.w,X		; FD B0 F6 ; Subtract with carry $F6B0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: ZVNC]
	jsr ($2AF3.w,X)		; FC F3 2A ; Jump to subroutine indirect indexed ($2AF3.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $42, $A7		; 42 A7 ; Reserved instruction
	cmp $D3.b,X		; D5 D3 ; Compare accumulator $D3.b,X [Reads: X Index, Direct Page] [Flags: ZNC]
	.db $B0, $EF		; B0 EF ; Branch if carry set to $B0, $EF [Flow: branch]
