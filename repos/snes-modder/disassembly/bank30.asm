.BANK 30 SLOT 0
.ORG $0000

.SECTION "Bank30" FORCE

	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B2F.w		; [PATTERN: Memory clearing operation] 8D 2F 0B ; Store accumulator to $0B2F.w [Reads: Accumulator]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B2D.w		; 8D 2D 0B ; Store accumulator to $0B2D.w [Reads: Accumulator]
	stz $0B2E.w		; 9C 2E 0B ; Store zero to $0B2E.w
	stz $0B30.w		; 9C 30 0B ; Store zero to $0B30.w
	stz $0B33.w		; [PATTERN: Memory clearing operation] 9C 33 0B ; Store zero to $0B33.w
	stz $0B31.w		; 9C 31 0B ; Store zero to $0B31.w
	stz $0B32.w		; 9C 32 0B ; Store zero to $0B32.w
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	ldy #$03.b		; A0 03 ; Load #$03.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $829C.w,Y		; 79 9C 82 ; Add $829C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $827C.w,X		; BD 7C 82 ; Load $827C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0B08.w,Y		; 99 08 0B ; Store accumulator to $0B08.w,Y [Reads: Y Index, Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $44		; 10 44 ; Branch if plus to $10, $44 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0E00.w,X		; 1D 00 0E ; OR accumulator with memory $0E00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$40.b		; 49 40 ; Exclusive OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $12		; 10 12 ; Branch if plus to $10, $12 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	lda $0B89.w,X		; BD 89 0B ; Load $0B89.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$F1.b		; 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B6B.w,X		; 9D 6B 0B ; Store accumulator to $0B6B.w,X [Reads: Accumulator, X Index]
	.db $80, $0A		; 80 0A ; Branch always to $80, $0A [Flow: branch]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B6B.w,X		; 9D 6B 0B ; Store accumulator to $0B6B.w,X [Reads: Accumulator, X Index]
	jsr $853B.w		; 20 3B 85 ; Jump to subroutine at $853B.w [Writes: Stack Pointer] [Flow: call]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $6E		; D0 6E ; Branch if not equal to $D0, $6E [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,X		; 9D D0 0D ; Store accumulator to $0DD0.w,X [Reads: Accumulator, X Index]
	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	lda #$E0.b		; A9 E0 ; Load #$E0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora #$F0.b		; 09 F0 ; Logical OR #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EF0.w,X		; 9D F0 0E ; Store accumulator to $0EF0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $42		; B0 42 ; Branch if carry set to $B0, $42 [Flow: branch]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $3E		; D0 3E ; Branch if not equal to $D0, $3E [Flow: branch]
	ldy $0B33.w		; AC 33 0B ; Load $0B33.w into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$10.b		; C0 10 ; Compare #$10.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $37		; F0 37 ; Branch if equal to $F0, $37 [Flow: branch]
	inc $0B33.w		; EE 33 0B ; Increment $0B33.w [Flags: NZ]
	stz $00.b		; 64 00 ; Store zero to $00.b
	lda $0B0D.w,Y		; B9 0D 0B ; Load $0B0D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D10.w,X		; 7D 10 0D ; Add $0D10.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0FD8.w		; 8D D8 0F ; Store accumulator to $0FD8.w [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0FD9.w		; 8D D9 0F ; Store accumulator to $0FD9.w [Reads: Accumulator]
	stz $00.b		; 64 00 ; Store zero to $00.b
	lda $0B1D.w,Y		; B9 1D 0B ; Load $0B1D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D00.w,X		; 7D 00 0D ; Add $0D00.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0FDA.w		; 8D DA 0F ; Store accumulator to $0FDA.w [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0FDB.w		; 8D DB 0F ; Store accumulator to $0FDB.w [Reads: Accumulator]
	jsl $1DDC2A.l		; 22 2A DC 1D ; Jump to subroutine long $1DDC2A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $50BD.w,X		; FE BD 50 ; Increment memory $50BD.w,X [Reads: X Index] [Flags: NZ]
	asl $4A4A.w		; 0E 4A 4A ; Arithmetic shift left $4A4A.w [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $810A.w,Y		; B9 0A 81 ; Load $810A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	cmp $0E90.w,X		; DD 90 0E ; Compare accumulator $0E90.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	stz $0EF0.w,X		; 9E F0 0E ; Store zero to $0EF0.w,X [Reads: X Index]
	jsr $848C.w		; 20 8C 84 ; Jump to subroutine at $848C.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	cmp $0E90.w,X		; DD 90 0E ; Compare accumulator $0E90.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jsr $847E.w		; 20 7E 84 ; Jump to subroutine at $847E.w [Writes: Stack Pointer] [Flow: call]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0E90.w,X		; 9D 90 0E ; Store accumulator to $0E90.w,X [Reads: Accumulator, X Index]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	jsr $82A0.w		; 20 A0 82 ; Jump to subroutine at $82A0.w [Writes: Stack Pointer] [Flow: call]
	jsr $83EB.w		; 20 EB 83 ; Jump to subroutine at $83EB.w [Writes: Stack Pointer] [Flow: call]
	jsr $8385.w		; 20 85 83 ; Jump to subroutine at $8385.w [Writes: Stack Pointer] [Flow: call]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	cmp #$60.b		; C9 60 ; Compare #$60.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1C		; F0 1C ; Branch if equal to $F0, $1C [Flow: branch]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $17		; D0 17 ; Branch if not equal to $D0, $17 [Flow: branch]
	jsr $8517.w		; 20 17 85 ; Jump to subroutine at $8517.w [Writes: Stack Pointer] [Flow: call]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	lda $0EC0.w,X		; BD C0 0E ; Load $0EC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0EC0.w,X		; FE C0 0E ; Increment memory $0EC0.w,X [Reads: X Index] [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EE0.w,X		; 9D E0 0E ; Store accumulator to $0EE0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	stz $D581.w		; 9C 81 D5 ; Store zero to $D581.w
	sta ($10.b,X)		; 81 10 ; Store accumulator ($10.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $82, $42, $82		; 82 42 82 ; Branch always long to $82, $42, $82 [Flow: branch]
	pea $FCF4.w		; F4 F4 FC ; Push absolute address $FCF4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $000C.w		; 0C 0C 00 ; Test and set bits $000C.w [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0C0C.w		; 0C 0C 0C ; Test and set bits $0C0C.w [Reads: Accumulator] [Flags: Z]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $F0BD.w		; 0C BD F0 ; Test and set bits $F0BD.w [Reads: Accumulator] [Flags: Z]
	asl $05D0.w		; 0E D0 05 ; Arithmetic shift left $05D0.w [Flags: NCZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2E		; D0 2E ; Branch if not equal to $D0, $2E [Flow: branch]
	jsr $8253.w		; 20 53 82 ; Jump to subroutine at $8253.w [Writes: Stack Pointer] [Flow: call]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $818C.w,Y		; B9 8C 81 ; Load $818C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $8194.w,Y		; B9 94 81 ; Load $8194.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	asl $0D50.w,X		; 1E 50 0D ; Arithmetic shift left $0D50.w,X [Reads: X Index] [Flags: NCZ]
	asl $0D40.w,X		; 1E 40 0D ; Arithmetic shift left $0D40.w,X [Reads: X Index] [Flags: NCZ]
	lsr $0DF0.w,X		; 5E F0 0D ; Logical shift right $0DF0.w,X [Reads: X Index] [Flags: NCZ]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $81E6.w		; 20 E6 81 ; Jump to subroutine at $81E6.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $8200.w		; 20 00 82 ; Jump to subroutine at $8200.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $8200.w		; 20 00 82 ; Jump to subroutine at $8200.w [Writes: Stack Pointer] [Flow: call]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	jsr $8200.w		; 20 00 82 ; Jump to subroutine at $8200.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0EF0.w,X		; BD F0 0E ; Load $0EF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $27		; D0 27 ; Branch if not equal to $D0, $27 [Flow: branch]
	jsr $8253.w		; 20 53 82 ; Jump to subroutine at $8253.w [Writes: Stack Pointer] [Flow: call]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	lsr $0DF0.w,X		; 5E F0 0D ; Logical shift right $0DF0.w,X [Reads: X Index] [Flags: NCZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $81E6.w		; 20 E6 81 ; Jump to subroutine at $81E6.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0E30.w,X		; FE 30 0E ; Increment memory $0E30.w,X [Reads: X Index] [Flags: NZ]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1E		; D0 1E ; Branch if not equal to $D0, $1E [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	stz $0E30.w,X		; 9E 30 0E ; Store zero to $0E30.w,X [Reads: X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E10.w,X		; 9D 10 0E ; Store accumulator to $0E10.w,X [Reads: Accumulator, X Index]
	lda #$2A.b		; A9 2A ; Load #$2A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$A0.b		; A9 A0 ; Load #$A0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	inc $0B0C.w		; EE 0C 0B ; Increment $0B0C.w [Flags: NZ]
	jsl $1E8019.l		; 22 19 80 1E ; Jump to subroutine long $1E8019.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0EC0.w,X		; BC C0 0E ; Load Y register $0EC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and $1A.b		; 25 1A ; Logical AND $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $30		; D0 30 ; Branch if not equal to $D0, $30 [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0B30.w		; AD 30 0B ; Load $0B30.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8383.w,Y		; 79 83 83 ; Add $8383.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0B30.w		; 8D 30 0B ; Store accumulator to $0B30.w [Reads: Accumulator]
	cmp $8BD8.w,Y		; D9 D8 8B ; Compare accumulator $8BD8.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0DE0.w,X		; FE E0 0D ; Increment memory $0DE0.w,X [Reads: X Index] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $0B30.w		; AD 30 0B ; Load $0B30.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B2D.w		; 6D 2D 0B ; Add $0B2D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0B2D.w		; 8D 2D 0B ; Store accumulator to $0B2D.w [Reads: Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $0B2E.w		; 6D 2E 0B ; Add $0B2E.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and #$FF.b		; 29 FF ; Logical AND #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B2E.w		; 8D 2E 0B ; Store accumulator to $0B2E.w [Reads: Accumulator]
	lda $0EC0.w,X		; BD C0 0E ; Load $0EC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $3D		; F0 3D ; Branch if equal to $F0, $3D [Flow: branch]
	lda $0B30.w		; AD 30 0B ; Load $0B30.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda $0EC0.w,X		; BD C0 0E ; Load $0EC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $32		; F0 32 ; Branch if equal to $F0, $32 [Flow: branch]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $58		; F0 58 ; Branch if equal to $F0, $58 [Flow: branch]
	lda $0B30.w		; AD 30 0B ; Load $0B30.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0EE0.w,X		; 1D E0 0E ; OR accumulator with memory $0EE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $7B		; D0 7B ; Branch if not equal to $D0, $7B [Flow: branch]
	lda $0B2E.w		; AD 2E 0B ; Load $0B2E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	jsr $FE6E.w		; 20 6E FE ; Jump to subroutine at $FE6E.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $0EB0.w,X		; DD B0 0E ; Compare accumulator $0EB0.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	inc $0EC0.w,X		; FE C0 0E ; Increment memory $0EC0.w,X [Reads: X Index] [Flags: NZ]
	jsl $0DBBA1.l		; 22 A1 BB 0D ; Jump to subroutine long $0DBBA1.l [Writes: Stack Pointer] [Flow: call]
	ora #$26.b		; 09 26 ; Logical OR #$26.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($BC84.w,X)		; 7C 84 BC ; Jump indirect indexed to ($BC84.w,X) [Reads: X Index] [Flow: jump]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	lda $0B31.w		; AD 31 0B ; Load $0B31.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8327.w,Y		; 79 27 83 ; Add $8327.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0B31.w		; 8D 31 0B ; Store accumulator to $0B31.w [Reads: Accumulator]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0B32.w		; AD 32 0B ; Load $0B32.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $8329.w,Y		; 79 29 83 ; Add $8329.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0B32.w		; 8D 32 0B ; Store accumulator to $0B32.w [Reads: Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp $832B.w,Y		; D9 2B 83 ; Compare accumulator $832B.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0EC0.w,X		; FE C0 0E ; Increment memory $0EC0.w,X [Reads: X Index] [Flags: NZ]
	lda $0B2F.w		; AD 2F 0B ; Load $0B2F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0B2F.w		; 8D 2F 0B ; Store accumulator to $0B2F.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0B31.w		; AD 31 0B ; Load $0B31.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8327.w,Y		; 79 27 83 ; Add $8327.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0B31.w		; 8D 31 0B ; Store accumulator to $0B31.w [Reads: Accumulator]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0B32.w		; AD 32 0B ; Load $0B32.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $8329.w,Y		; 79 29 83 ; Add $8329.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0B32.w		; 8D 32 0B ; Store accumulator to $0B32.w [Reads: Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0EC0.w,X		; 9E C0 0E ; Store zero to $0EC0.w,X [Reads: X Index]
	lda $0B2F.w		; AD 2F 0B ; Load $0B2F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$03.b		; E9 03 ; Subtract #$03.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0B2F.w		; 8D 2F 0B ; Store accumulator to $0B2F.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $5E		; B0 5E ; Branch if carry set to $B0, $5E [Flow: branch]
	lda $0301.w		; AD 01 03 ; Load $0301.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$0A.b		; 29 0A ; Logical AND #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $57		; F0 57 ; Branch if equal to $F0, $57 [Flow: branch]
	lda $44.b		; A5 44 ; Load $44.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $51		; F0 51 ; Branch if equal to $F0, $51 [Flow: branch]
	jsl $06F57E.l		; 22 7E F5 06 ; Jump to subroutine long $06F57E.l [Writes: Stack Pointer] [Flow: call]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	jsl $0683EA.l		; 22 EA 83 06 ; Jump to subroutine long $0683EA.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	jsl $0683E6.l		; 22 E6 83 06 ; Jump to subroutine long $0683E6.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $35		; 90 35 ; Branch if carry clear to $90, $35 [Flow: branch]
	dec $0E50.w,X		; DE 50 0E ; Decrement memory $0E50.w,X [Reads: X Index] [Flags: NZ]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA1A.l		; 22 1A EA 06 ; Jump to subroutine long $06EA1A.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $27.b		; 85 27 ; Store accumulator to $27.b [Reads: Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0046.w		; 8D 46 00 ; Store accumulator to $0046.w [Reads: Accumulator]
	lda $0FAC.w		; AD AC 0F ; Load $0FAC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0FAD.w		; 8D AD 0F ; Store accumulator to $0FAD.w [Reads: Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0FAE.w		; 8D AE 0F ; Store accumulator to $0FAE.w [Reads: Accumulator]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FAC.w		; 8D AC 0F ; Store accumulator to $0FAC.w [Reads: Accumulator]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $26		; D0 26 ; Branch if not equal to $D0, $26 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FD8.w		; ED D8 0F ; Subtract $0FD8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0024.w		; 69 24 00 ; Add #$0024.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0048.w		; C9 48 00 ; Compare #$0048.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $15		; B0 15 ; Branch if carry set to $B0, $15 [Flow: branch]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FDA.w		; ED DA 0F ; Subtract $0FDA.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0028.w		; 69 28 00 ; Add #$0028.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0040.w		; C9 40 00 ; Compare #$0040.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	jsl $06F41F.l		; 22 1F F4 06 ; Jump to subroutine long $06F41F.l [Writes: Stack Pointer] [Flow: call]
.ACCU 8
	sep #$20		; E2 20
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	sbc $FF0000.l,X		; FF 00 00 FF ; Subtract with carry (long,X) $FF0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00FF00.l,X		; FF 00 FF 00 ; Subtract with carry (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1D20.w,X		; 1D 20 1D ; OR accumulator with memory $1D20.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0D10.w		; 0D 10 0D ; Logical OR $0D10.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F00D.w		; 0D 0D F0 ; Logical OR $F00D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr ($F40E.w,X)		; FC 0E F4 ; Jump to subroutine indirect indexed ($F40E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $12.b		; 04 12 ; Test and set bits $12.b [Reads: Accumulator] [Flags: Z]
	inc $F402.w,X		; FE 02 F4 ; Increment memory $F402.w,X [Reads: X Index] [Flags: NZ]
	ora ($F8.b)		; 12 F8 ; OR accumulator with memory (indirect) ($F8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($04FA.w,X)		; FC FA 04 ; Jump to subroutine indirect indexed ($04FA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	jsr $2428.w		; 20 28 24 ; Jump to subroutine at $2428.w [Writes: Stack Pointer] [Flow: call]
	and $27.b		; 25 27 ; Logical AND $27.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $25211E.l		; 22 1E 21 25 ; Jump to subroutine long $25211E.l [Writes: Stack Pointer] [Flow: call]
	jsl $400000.l		; 22 00 00 40 ; Jump to subroutine long $400000.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$07.b		; 69 07 ; Add #$07.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0FB5.w		; 8D B5 0F ; Store accumulator to $0FB5.w [Reads: Accumulator]
	jsr $84AA.w		; 20 AA 84 ; Jump to subroutine at $84AA.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $17		; 80 17 ; Branch always to $80, $17 [Flow: branch]
	ldy #$0F.b		; A0 0F ; Load #$0F.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,Y		; 99 D0 0D ; Store accumulator to $0DD0.w,Y [Reads: Y Index, Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $D0, $FA		; D0 FA ; Branch if not equal to $D0, $FA [Flow: branch]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FB5.w		; 8D B5 0F ; Store accumulator to $0FB5.w [Reads: Accumulator]
	jsr $84AA.w		; 20 AA 84 ; Jump to subroutine at $84AA.w [Writes: Stack Pointer] [Flow: call]
	dec $0FB5.w		; CE B5 0F ; Decrement $0FB5.w [Flags: NZ]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$92.b		; A9 92 ; Load #$92.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $64		; 30 64 ; Branch if minus to $30, $64 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $0FB5.w		; AE B5 0F ; Load $0FB5.w into X register [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $842E.w,X		; 7D 2E 84 ; Add $842E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $8438.w,X		; 7D 38 84 ; Add $8438.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $841A.w,X		; 7D 1A 84 ; Add $841A.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $8424.w,X		; 7D 24 84 ; Add $8424.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $8442.w,X		; BD 42 84 ; Load $8442.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,Y		; 99 70 0F ; Store accumulator to $0F70.w,Y [Reads: Y Index, Accumulator]
	lda $844C.w,X		; BD 4C 84 ; Load $844C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $8456.w,X		; BD 56 84 ; Load $8456.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $8460.w,X		; BD 60 84 ; Load $8460.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	lda $846A.w,X		; BD 6A 84 ; Load $846A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$0D.b		; 09 0D ; Logical OR #$0D.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda $8474.w,X		; BD 74 84 ; Load $8474.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,Y		; 99 00 0E ; Store accumulator to $0E00.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	lda $0FB5.w		; AD B5 0F ; Load $0FB5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E30.w,Y		; 99 30 0E ; Store accumulator to $0E30.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$70.b		; A9 70 ; Load #$70.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $1B		; 30 1B ; Branch if minus to $30, $1B [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$1C.b		; 69 1C ; Add #$1C.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 16
	rep #$20		; C2 20
	lda #$089C.w		; A9 9C 08 ; Load #$089C.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	lda #$0A47.w		; A9 47 0A ; Load #$0A47.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $92.b		; 85 92 ; Store accumulator to $92.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	jsr $FF84.w		; 20 84 FF ; Jump to subroutine at $FF84.w [Writes: Stack Pointer] [Flow: call]
	jsr $8920.w		; 20 20 89 ; Jump to subroutine at $8920.w [Writes: Stack Pointer] [Flow: call]
	jsr $856B.w		; 20 6B 85 ; Jump to subroutine at $856B.w [Writes: Stack Pointer] [Flow: call]
	jsr $8686.w		; 20 86 86 ; Jump to subroutine at $8686.w [Writes: Stack Pointer] [Flow: call]
	jsr $87E5.w		; 20 E5 87 ; Jump to subroutine at $87E5.w [Writes: Stack Pointer] [Flow: call]
	jsr $8805.w		; 20 05 88 ; Jump to subroutine at $8805.w [Writes: Stack Pointer] [Flow: call]
	jsr $88BC.w		; 20 BC 88 ; Jump to subroutine at $88BC.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $CE0B.w,X		; FD 0B CE ; Subtract with carry $CE0B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $DEDEDE.l		; CF DE DE DE ; Compare accumulator (long) $DEDEDE.l [Reads: Accumulator] [Flags: NCZ]
	dec $CECF.w,X		; DE CF CE ; Decrement memory $CECF.w,X [Reads: X Index] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0040.w		; 69 40 00 ; Add #$0040.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	lda $92.b		; A5 92 ; Load $92.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $92.b		; 85 92 ; Store accumulator to $92.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	ldx #$01.b		; A2 01 ; Load #$01.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $855F.w,X		; 7D 5F 85 ; Add $855F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$14.b		; 69 14 ; Add #$14.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $0B0C.w		; AD 0C 0B ; Load $0B0C.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $8561.w,X		; BD 61 85 ; Load $8561.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $8569.w,X		; BD 69 85 ; Load $8569.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $CC		; 10 CC ; Branch if plus to $10, $CC [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $000DAE.l,X		; FF AE 0D 00 ; Subtract with carry (long,X) $000DAE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000DC0.l,X		; FF C0 0D 00 ; Subtract with carry (long,X) $000DC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004DAE.l,X		; FF AE 4D 00 ; Subtract with carry (long,X) $004DAE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C2000B.l,X		; FF 0B 00 C2 ; Subtract with carry (long,X) $C2000B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0200.w		; 0D 00 02 ; Logical OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0200.w		; 0D 00 02 ; Logical OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0200.w		; 4D 00 02 ; Exclusive OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $C6001B.l,X		; FF 1B 00 C6 ; Subtract with carry (long,X) $C6001B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0200.w		; 0D 00 02 ; Logical OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0200.w		; 4D 00 02 ; Exclusive OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $000DAE.l,X		; FF AE 0D 00 ; Subtract with carry (long,X) $000DAE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000DC0.l,X		; FF C0 0D 00 ; Subtract with carry (long,X) $000DC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004DAE.l,X		; FF AE 4D 00 ; Subtract with carry (long,X) $004DAE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C8000B.l,X		; FF 0B 00 C8 ; Subtract with carry (long,X) $C8000B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0200.w		; 0D 00 02 ; Logical OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0200.w		; 0D 00 02 ; Logical OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0200.w		; 4D 00 02 ; Exclusive OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $C6001B.l,X		; FF 1B 00 C6 ; Subtract with carry (long,X) $C6001B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0200.w		; 0D 00 02 ; Logical OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0200.w		; 4D 00 02 ; Exclusive OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $000DAE.l,X		; FF AE 0D 00 ; Subtract with carry (long,X) $000DAE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000DC0.l,X		; FF C0 0D 00 ; Subtract with carry (long,X) $000DC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004DAE.l,X		; FF AE 4D 00 ; Subtract with carry (long,X) $004DAE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C8000B.l,X		; FF 0B 00 C8 ; Subtract with carry (long,X) $C8000B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0200.w		; 0D 00 02 ; Logical OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0200.w		; 0D 00 02 ; Logical OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0200.w		; 4D 00 02 ; Exclusive OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $C6001B.l,X		; FF 1B 00 C6 ; Subtract with carry (long,X) $C6001B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0200.w		; 0D 00 02 ; Logical OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0200.w		; 4D 00 02 ; Exclusive OR $0200.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$85C6.w		; 69 C6 85 ; Add #$85C6.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0008.w		; 69 08 00 ; Add #$0008.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	inc $92.b		; E6 92 ; Increment $92.b [Reads: Direct Page] [Flags: NZ]
	inc $92.b		; E6 92 ; Increment $92.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $1E		; B0 1E ; Branch if carry set to $B0, $1E [Flow: branch]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0020.w		; 69 20 00 ; Add #$0020.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	lda $92.b		; A5 92 ; Load $92.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0008.w		; 69 08 00 ; Add #$0008.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $92.b		; 85 92 ; Store accumulator to $92.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $0F10.w,X		; BD 10 0F ; Load $0F10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $0C4A.w,Y		; B9 4A 0C ; Load $0C4A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda $0C2C.w,Y		; B9 2C 0C ; Load $0C2C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0C22.w,Y		; 19 22 0C ; OR accumulator with memory $0C22.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jsr $86E5.w		; 20 E5 86 ; Jump to subroutine at $86E5.w [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $EB		; 10 EB ; Branch if plus to $10, $EB [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0683EA.l		; 22 EA 83 06 ; Jump to subroutine long $0683EA.l [Writes: Stack Pointer] [Flow: call]
	lda $0C04.w,Y		; B9 04 0C ; Load $0C04.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$06.b		; 69 06 ; Add #$06.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0C18.w,Y		; B9 18 0C ; Load $0C18.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda $0BFA.w,Y		; B9 FA 0B ; Load $0BFA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $029E.w,Y		; F9 9E 02 ; Subtract with carry $029E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0C0E.w,Y		; B9 0E 0C ; Load $0C0E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	jsl $0683E6.l		; 22 E6 83 06 ; Jump to subroutine long $0683E6.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $36		; 90 36 ; Branch if carry clear to $90, $36 [Flow: branch]
	lda $0C2C.w,Y		; B9 2C 0C ; Load $0C2C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0C2C.w,Y		; 99 2C 0C ; Store accumulator to $0C2C.w,Y [Reads: Y Index, Accumulator]
	lda $0C22.w,Y		; B9 22 0C ; Load $0C22.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0C22.w,Y		; 99 22 0C ; Store accumulator to $0C22.w,Y [Reads: Y Index, Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FAC.w		; 8D AC 0F ; Store accumulator to $0FAC.w [Reads: Accumulator]
	lda $0C04.w,Y		; B9 04 0C ; Load $0C04.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0FAD.w		; 8D AD 0F ; Store accumulator to $0FAD.w [Reads: Accumulator]
	lda $0BFA.w,Y		; B9 FA 0B ; Load $0BFA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $029E.w,Y		; F9 9E 02 ; Subtract with carry $029E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0FAE.w		; 8D AE 0F ; Store accumulator to $0FAE.w [Reads: Accumulator]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $80FFE0.l,X		; FF E0 FF 80 ; Subtract with carry (long,X) $80FFE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $82FFE0.l,X		; FF E0 FF 82 ; Subtract with carry (long,X) $82FFE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004B82.l,X		; FF 82 4B 00 ; Subtract with carry (long,X) $004B82.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004B80.l,X		; FF 80 4B 00 ; Subtract with carry (long,X) $004B80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $E8.b		; 02 E8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $84FFF0.l,X		; FF F0 FF 84 ; Subtract with carry (long,X) $84FFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $86FFF0.l,X		; FF F0 FF 86 ; Subtract with carry (long,X) $86FFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004B86.l,X		; FF 86 4B 00 ; Subtract with carry (long,X) $004B86.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004B84.l,X		; FF 84 4B 00 ; Subtract with carry (long,X) $004B84.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $E8.b		; 02 E8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $880000.l,X		; FF 00 00 88 ; Subtract with carry (long,X) $880000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $8A0000.l,X		; FF 00 00 8A ; Subtract with carry (long,X) $8A0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $8C0010.l,X		; FF 10 00 8C ; Subtract with carry (long,X) $8C0010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $8E0010.l,X		; FF 10 00 8E ; Subtract with carry (long,X) $8E0010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $A00020.l,X		; FF 20 00 A0 ; Subtract with carry (long,X) $A00020.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sbc $000BAC.l,X		; FF AC 0B 00 ; Subtract with carry (long,X) $000BAC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $C2.b		; 02 C2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $4DA9.w		; 20 A9 4D ; Jump to subroutine at $4DA9.w [Writes: Stack Pointer] [Flow: call]
	sta [$85.b]		; 87 85 ; Store accumulator (long) [$85.b] [Reads: Direct Page, Accumulator]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
.ACCU 8
	sep #$20		; E2 20
	lda #$13.b		; A9 13 ; Load #$13.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $05DF6C.l		; 22 6C DF 05 ; Jump to subroutine long $05DF6C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx $E4.b		; E4 E4 ; Compare $E4.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $E41C.w		; 1C 1C E4 ; Test and reset bits $E41C.w [Reads: Accumulator] [Flags: Z]
	tsb $E4.b		; 04 E4 ; Test and set bits $E4.b [Reads: Accumulator] [Flags: Z]
	tsb $A2.b		; 04 A2 ; Test and set bits $A2.b [Reads: Accumulator] [Flags: Z]
	ldx $A2.b		; A6 A2 ; Load $A2.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldx $0B.b		; A6 0B ; Load $0B.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
.ACCU 16
	rep #$20		; C2 20
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$004C.w		; 69 4C 00 ; Add #$004C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	lda $92.b		; A5 92 ; Load $92.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0013.w		; 69 13 00 ; Add #$0013.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $92.b		; 85 92 ; Store accumulator to $92.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FB5.w		; 8D B5 0F ; Store accumulator to $0FB5.w [Reads: Accumulator]
	ldx $0FB5.w		; AE B5 0F ; Load $0FB5.w into X register [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $87F5.w,X		; 7D F5 87 ; Add $87F5.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $87F9.w,X		; 7D F9 87 ; Add $87F9.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B08.w,X		; 7D 08 0B ; Add $0B08.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $87FD.w,X		; BD FD 87 ; Load $87FD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $8801.w,X		; BD 01 88 ; Load $8801.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $05.b		; 45 05 ; Exclusive OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $87F5.w,X		; 7D F5 87 ; Add $87F5.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $87F9.w,X		; 7D F9 87 ; Add $87F9.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B08.w,X		; 7D 08 0B ; Add $0B08.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $87FD.w,X		; BD FD 87 ; Load $87FD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $8801.w,X		; BD 01 88 ; Load $8801.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $05.b		; 45 05 ; Exclusive OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $0FB5.w		; CE B5 0F ; Decrement $0FB5.w [Flags: NZ]
	.db $10, $96		; 10 96 ; Branch if plus to $10, $96 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	jsr $FF84.w		; 20 84 FF ; Jump to subroutine at $FF84.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($BD.b,X)		; 01 BD ; Logical OR ($BD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	.db $F0, $2E		; F0 2E ; Branch if equal to $F0, $2E [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $889C.w,Y		; B9 9C 88 ; Load $889C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$13.b		; 69 13 ; Add #$13.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$AA.b		; A9 AA ; Load #$AA.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$0B.b		; 49 0B ; Exclusive OR #$0B.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b)		; 92 92 ; Store accumulator (indirect) ($92.b) [Reads: Direct Page, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $D0E0F0.l,X		; FF F0 E0 D0 ; Subtract with carry (long,X) $D0E0F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$B0.b		; C0 B0 ; Compare #$B0.b with Y register [Reads: Y Index] [Flags: NCZ]
	ldy #$90.b		; A0 90 ; Load #$90.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $70		; 80 70 ; Branch always to $80, $70 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $50, $40		; 50 40 ; Branch if overflow clear to $50, $40 [Flow: branch]
	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	cpx #$D8.b		; E0 D8 ; Compare #$D8.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $C8		; D0 C8 ; Branch if not equal to $D0, $C8 [Flow: branch]
	ldy $A0B0.w,X		; BC B0 A0 ; Load Y register $A0B0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $90, $70		; 90 70 ; Branch if carry clear to $90, $70 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $FF10.w		; 20 10 FF ; Jump to subroutine at $FF10.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	.db $D0, $C0		; D0 C0 ; Branch if not equal to $D0, $C0 [Flow: branch]
	.db $B0, $A0		; B0 A0 ; Branch if carry set to $B0, $A0 [Flow: branch]
	.db $90, $80		; 90 80 ; Branch if carry clear to $90, $80 [Flow: branch]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	.db $50, $40		; 50 40 ; Branch if overflow clear to $50, $40 [Flow: branch]
	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	.db $10, $9C		; 10 9C ; Branch if plus to $10, $9C [Flow: branch]
	lda $0F.b,X		; B5 0F ; Load $0F.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $0FB5.w		; AC B5 0F ; Load $0FB5.w into Y register [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $0EC0.w,X		; BD C0 0E ; Load $0EC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $0B2D.w		; AD 2D 0B ; Load $0B2D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B31.w		; 6D 31 0B ; Add $0B31.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda $0D.b		; A5 0D ; Load $0D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $88F0.w,Y		; B9 F0 88 ; Load $88F0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $8A85.w		; 20 85 8A ; Jump to subroutine at $8A85.w [Writes: Stack Pointer] [Flow: call]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lda $0B2F.w		; AD 2F 0B ; Load $0B2F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $8910.w,Y		; B9 10 89 ; Load $8910.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $8A85.w		; 20 85 8A ; Jump to subroutine at $8A85.w [Writes: Stack Pointer] [Flow: call]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $04E800.l,X		; BF 00 E8 04 ; Load long $04E800.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0A.b		; 85 0A ; Store accumulator to $0A.b [Reads: Accumulator]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0080.w		; 69 80 00 ; Add #$0080.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $04E800.l,X		; BF 00 E8 04 ; Load long $04E800.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0C.b		; 85 0C ; Store accumulator to $0C.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0A.b		; A5 0A ; Load $0A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $0B.b		; A4 0B ; Load $0B.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $8A85.w		; 20 85 8A ; Jump to subroutine at $8A85.w [Writes: Stack Pointer] [Flow: call]
	asl $4216.w		; 0E 16 42 ; Arithmetic shift left $4216.w [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lsr $07.b		; 46 07 ; Logical shift right $07.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldy $0FB5.w		; AC B5 0F ; Load $0FB5.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $0B0D.w,Y		; 99 0D 0B ; Store accumulator to $0B0D.w,Y [Reads: Y Index, Accumulator]
	lda $0C.b		; A5 0C ; Load $0C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $0D.b		; A4 0D ; Load $0D.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $8A85.w		; 20 85 8A ; Jump to subroutine at $8A85.w [Writes: Stack Pointer] [Flow: call]
	asl $4216.w		; 0E 16 42 ; Arithmetic shift left $4216.w [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lsr $09.b		; 46 09 ; Logical shift right $09.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldy $0FB5.w		; AC B5 0F ; Load $0FB5.w into Y register [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$28.b		; E9 28 ; Subtract #$28.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0B1D.w,Y		; 99 1D 0B ; Store accumulator to $0B1D.w,Y [Reads: Y Index, Accumulator]
	inc $0FB5.w		; EE B5 0F ; Increment $0FB5.w [Flags: NZ]
	lda $0FB5.w		; AD B5 0F ; Load $0FB5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $8923.w		; 4C 23 89 ; Jump to $8923.w [Flow: jump]
	lda $0EC0.w,X		; BD C0 0E ; Load $0EC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0A.b		; 85 0A ; Store accumulator to $0A.b [Reads: Accumulator]
	stz $0F.b		; 64 0F ; Store zero to $0F.b
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $0B33.w		; AE 33 0B ; Load $0B33.w into X register [Writes: X Index] [Flags: NZ]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $5F		; F0 5F ; Branch if equal to $F0, $5F [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B0D.w,X		; 7D 0D 0B ; Add $0B0D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B1D.w,X		; 7D 1D 0B ; Add $0B1D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	lda #$AC.b		; A9 AC ; Load #$AC.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$01.b		; C0 01 ; Compare #$01.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	lda #$E4.b		; A9 E4 ; Load #$E4.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$1B.b		; 49 1B ; Exclusive OR #$1B.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $031F.w		; 0D 1F 03 ; Logical OR $031F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $26		; D0 26 ; Branch if not equal to $D0, $26 [Flow: branch]
	lda $0A.b		; A5 0A ; Load $0A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E2.b		; E5 E2 ; Subtract $E2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $08.b		; E5 08 ; Subtract $08.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc #$0C.b		; 69 0C ; Add #$0C.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$18.b		; C9 18 ; Compare #$18.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $16		; B0 16 ; Branch if carry set to $B0, $16 [Flow: branch]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E8.b		; E5 E8 ; Subtract $E8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sbc $09.b		; E5 09 ; Subtract $09.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $08		; B0 08 ; Branch if carry set to $B0, $08 [Flow: branch]
	inc $0F.b		; E6 0F ; Increment $0F.b [Reads: Direct Page] [Flags: NZ]
	stz $28.b		; 64 28 ; Store zero to $28.b
	lda #$38.b		; A9 38 ; Load #$38.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $27.b		; 85 27 ; Store accumulator to $27.b [Reads: Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$10.b		; E0 10 ; Compare #$10.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $A3		; D0 A3 ; Branch if not equal to $D0, $A3 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	lda $0FFC.w		; AD FC 0F ; Load $0FFC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $06F41F.l		; 22 1F F4 06 ; Jump to subroutine long $06F41F.l [Writes: Stack Pointer] [Flow: call]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	jsr $FF84.w		; 20 84 FF ; Jump to subroutine at $FF84.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	nop		; EA ; No operation
	nop		; EA ; No operation
	nop		; EA ; No operation
	nop		; EA ; No operation
	nop		; EA ; No operation
	nop		; EA ; No operation
	nop		; EA ; No operation
	nop		; EA ; No operation
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $8A96.w		; 20 96 8A ; Jump to subroutine at $8A96.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$10.b		; 29 10 ; Logical AND #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DBF8.l		; 22 F8 DB 06 ; Jump to subroutine long $06DBF8.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1C		; D0 1C ; Branch if not equal to $D0, $1C [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $040C.w		; 0C 0C 04 ; Test and set bits $040C.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	tsb $040C.w		; 0C 0C 04 ; Test and set bits $040C.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8ABB.w,Y		; 79 BB 8A ; Add $8ABB.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8AC3.w,Y		; 79 C3 8A ; Add $8AC3.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $8B19.w		; 20 19 8B ; Jump to subroutine at $8B19.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$79.b		; E9 79 ; Subtract #$79.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8B33.w,Y		; B9 33 8B ; Load $8B33.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06E496.l		; 22 96 E4 06 ; Jump to subroutine long $06E496.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp.w [$D330]		; DC 30 D3 ; Jump long indirect [$D330] [Flow: jump]
	.db $42, $DA		; 42 DA ; Reserved instruction
	sta $47D2.w,Y		; 99 D2 47 ; Store accumulator to $47D2.w,Y [Reads: Y Index, Accumulator]
	cmp $1AD01A.l		; CF 1A D0 1A ; Compare accumulator (long) $1AD01A.l [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $D1		; D0 D1 ; Branch if not equal to $D0, $D1 [Flow: branch]
	cmp ($02.b),Y		; D1 02 ; Compare accumulator ($02.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpy $CB97.w		; CC 97 CB ; Compare $CB97.w with Y register [Reads: Y Index] [Flags: NCZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cmp [$9B.b]		; C7 9B ; Compare accumulator (long) [$9B.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$7F.b]		; C7 7F ; Compare accumulator (long) [$7F.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $03.b,S		; C3 03 ; Compare accumulator (stack relative) $03.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($74.b,X)		; C1 74 ; Compare accumulator ($74.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
.ACCU 16
.INDEX 16
	rep #$7E		; C2 7E
	ldx $BB42.w,Y		; BE 42 BB ; Load X register $BB42.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ldy $B9A9.w,X		; BC A9 B9 ; Load Y register $B9A9.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and ($B4.b,S),Y		; 33 B4 ; AND accumulator (stack relative indirect indexed) ($B4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $B8.b		; C4 B8 ; Compare $B8.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	adc $B002B2.l		; 6F B2 02 B0 ; Add with carry (long) $B002B2.l [Writes: Accumulator] [Flags: NCVZ]
	ldy $AE.b		; A4 AE ; Load $AE.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda [$AA.b]		; A7 AA ; Load accumulator (long) [$AA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $8280.w,Y		; 39 80 82 ; AND accumulator with memory $8280.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$A742.w		; A9 42 A7 ; Load #$A742.w into accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($A5.b,X)		; 41 A5 ; Exclusive OR accumulator with memory ($A5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($A5.b,X)		; 41 A5 ; Exclusive OR accumulator with memory ($A5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($A5.b,X)		; 41 A5 ; Exclusive OR accumulator with memory ($A5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($A5.b,X)		; 41 A5 ; Exclusive OR accumulator with memory ($A5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stx $A1.b,Y		; 96 A1 ; Store X register $A1.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $9D1B.w,X		; 9E 1B 9D ; Store zero to $9D1B.w,X [Reads: X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sta $9A6D.w,Y		; 99 6D 9A ; Store accumulator to $9A6D.w,Y [Reads: Y Index, Accumulator]
	cpx $1D9A.w		; EC 9A 1D ; Compare $1D9A.w with X register [Reads: X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $60.b,X		; 95 60 ; Store accumulator to $60.b,X [Reads: Accumulator, X Index]
	sty $10.b,X		; 94 10 ; Store Y register $10.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sta [$9F.b],Y		; 97 9F ; Store accumulator (long indexed) [$9F.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sta ($9F.b),Y		; 91 9F ; Store accumulator ($9F.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sta ($6C.b),Y		; 91 6C ; Store accumulator ($6C.b),Y [Reads: Direct Page, Y Index, Accumulator]
	.db $90, $D2		; 90 D2 ; Branch if carry clear to $90, $D2 [Flow: branch]
	sta $8DD2.w		; 8D D2 8D ; Store accumulator to $8DD2.w [Reads: Accumulator]
	lda $CE038B.l,X		; BF 8B 03 CE ; Load long $CE038B.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $F5.b,X		; 15 F5 ; OR accumulator with memory $F5.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($E9.b)		; 92 E9 ; Store accumulator (indirect) ($E9.b) [Reads: Direct Page, Accumulator]
	ror $7EFB.w,X		; 7E FB 7E ; Rotate right $7EFB.w,X [Reads: X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ror $7EFB.w,X		; 7E FB 7E ; Rotate right $7EFB.w,X [Reads: X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $DE.b,S		; 63 DE ; Add with carry (stack relative) $DE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	mvp $DD,$E0		; 44 E0 DD ; Move block positive $DD,$E0 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpx #$E111.w		; E0 11 E1 ; Compare #$E111.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $E8B6E2.l		; EF E2 B6 E8 ; Subtract with carry (long) $E8B6E2.l [Writes: Accumulator] [Flags: NCVZ]
	sbc [$EA.b]		; E7 EA ; Subtract with carry (long) [$EA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($EB.b,S),Y		; 33 EB ; AND accumulator (stack relative indirect indexed) ($EB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	inc $EEEF.w		; EE EF EE ; Increment $EEEF.w [Flags: NZ]
	ora $F6.b,S		; 03 F6 ; OR accumulator with stack relative $F6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8DCA.w		; 20 CA 8D ; Jump to subroutine at $8DCA.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	dec $258B.w,X		; DE 8B 25 ; Decrement memory $258B.w,X [Reads: X Index] [Flags: NZ]
	sty $8CE2.w		; 8C E2 8C ; Store Y register to $8CE2.w [Reads: Y Index]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $33		; D0 33 ; Branch if not equal to $D0, $33 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	inc $0DB0.w,X		; FE B0 0D ; Increment memory $0DB0.w,X [Reads: X Index] [Flags: NZ]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$D004.w		; C9 04 D0 ; Compare #$D004.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $0DB0.w,X		; 9E B0 0D ; Store zero to $0DB0.w,X [Reads: X Index]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $07		; 80 07 ; Branch always to $80, $07 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$A803.w		; 29 03 A8 ; Logical AND #$A803.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $8BD8.w,Y		; B9 D8 8B ; Load $8BD8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $8BDA.w,Y		; B9 DA 8B ; Load $8BDA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$6907.w		; 29 07 69 ; Logical AND #$6907.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($9D.b,S),Y		; 13 9D ; OR accumulator (stack relative indirect indexed) ($9D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $0F		; 80 0F ; Branch always to $80, $0F [Flow: branch]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$9D01.w		; 29 01 9D ; Logical AND #$9D01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$600D.w		; C0 0D 60 ; Compare #$600D.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	dec $0F80.w,X		; [PATTERN: Memory clearing operation] DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $3A		; 10 3A ; Branch if plus to $10, $3A [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$C930.w		; 69 30 C9 ; Add #$C930.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $B0, $20		; B0 20 ; Branch if carry set to $B0, $20 [Flow: branch]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$C930.w		; 69 30 C9 ; Add #$C930.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $B0, $17		; B0 17 ; Branch if carry set to $B0, $17 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$221F.w		; A9 1F 22 ; Load #$221F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	trb $F6.b		; 14 F6 ; Test and reset bits $F6.b [Reads: Accumulator] [Flags: Z]
	ora $9D4A.w,X		; 1D 4A 9D ; OR accumulator with memory $9D4A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$A90D.w		; E0 0D A9 ; Compare #$A90D.w with X register [Reads: X Index] [Flags: NCZ]
	eor $0DF09D.l,X		; 5F 9D F0 0D ; Exclusive OR accumulator with memory (long,X) $0DF09D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$9D10.w		; A9 10 9D ; Load #$9D10.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $80, $A4		; 80 A4 ; Branch always to $80, $A4 [Flow: branch]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1810.w		; 0C 10 18 ; Test and set bits $1810.w [Reads: Accumulator] [Flags: Z]
	jsr $1820.w		; 20 20 18 ; Jump to subroutine at $1820.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $E8F0.w		; F4 F0 E8 ; Push absolute address $E8F0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpx #$E8E0.w		; E0 E0 E8 ; Compare #$E8E0.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $12		; [PATTERN: Memory clearing operation] D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$9D10.w		; A9 10 9D ; Load #$9D10.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	stz $0DA0.w,X		; [PATTERN: Memory clearing operation] 9E A0 0D ; Store zero to $0DA0.w,X [Reads: X Index]
	stz $0ED0.w,X		; 9E D0 0E ; Store zero to $0ED0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8C72.w,Y		; B9 72 8C ; Load $8C72.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8CD2.w,Y		; 79 D2 8C ; Add $8CD2.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8C8A.w,Y		; B9 8A 8C ; Load $8C8A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	stz $05.b		; 64 05 ; Store zero to $05.b
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	dec $05.b		; C6 05 ; Decrement $05.b [Reads: Direct Page] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8CDA.w,Y		; 79 DA 8C ; Add $8CDA.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8C8A.w,Y		; [PATTERN: Memory clearing operation] B9 8A 8C ; Load $8C8A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	stz $07.b		; 64 07 ; Store zero to $07.b
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	dec $07.b		; C6 07 ; Decrement $07.b [Reads: Direct Page] [Flags: NZ]
	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $7C		; D0 7C ; Branch if not equal to $D0, $7C [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $04.b		; 65 04 ; Add $04.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $22.b		; E5 22 ; Subtract $22.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$000C.w		; 69 0C 00 ; Add #$000C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0018.w		; C9 18 00 ; Compare #$0018.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $68		; B0 68 ; Branch if carry set to $B0, $68 [Flow: branch]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $20.b		; E5 20 ; Subtract $20.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$000C.w		; 69 0C 00 ; Add #$000C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0020.w		; C9 20 00 ; Compare #$0020.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $56		; B0 56 ; Branch if carry set to $B0, $56 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$2E.b		; C9 2E ; Compare #$2E.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $4D		; B0 4D ; Branch if carry set to $B0, $4D [Flow: branch]
	jsl $0DBB67.l		; 22 67 BB 0D ; Jump to subroutine long $0DBB67.l [Writes: Stack Pointer] [Flow: call]
	ora #$26.b		; 09 26 ; Logical OR #$26.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0ED0.w,X		; 9D D0 0E ; Store accumulator to $0ED0.w,X [Reads: Accumulator, X Index]
	sta $0E90.w,X		; 9D 90 0E ; Store accumulator to $0E90.w,X [Reads: Accumulator, X Index]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	lda $7EF343.l		; AF 43 F3 7E ; Load long $7EF343.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $7EF343.l		; 8F 43 F3 7E ; Store accumulator (long) $7EF343.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 8
	sep #$20		; E2 20
	stz $0ED0.w,X		; 9E D0 0E ; Store zero to $0ED0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda $7EF377.l		; AF 77 F3 7E ; Load long $7EF377.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $7EF377.l		; 8F 77 F3 7E ; Store accumulator (long) $7EF377.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $DE		; F0 DE ; Branch if equal to $F0, $DE [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $7EF360.l		; 8F 60 F3 7E ; Store accumulator (long) $7EF360.l [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7EF35A.l		; AF 5A F3 7E ; Load long $7EF35A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E30.w,X		; 9D 30 0E ; Store accumulator to $0E30.w,X [Reads: Accumulator, X Index]
	.db $F0, $CD		; F0 CD ; Branch if equal to $F0, $CD [Flow: branch]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $C9		; F0 C9 ; Branch if equal to $F0, $C9 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF35A.l		; 8F 5A F3 7E ; Store accumulator (long) $7EF35A.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FF84.w		; 20 84 FF ; Jump to subroutine at $FF84.w [Writes: Stack Pointer] [Flow: call]
	jsl $0DD6E6.l		; 22 E6 D6 0D ; Jump to subroutine long $0DD6E6.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $55		; F0 55 ; Branch if equal to $F0, $55 [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	sbc [$8D.b]		; E7 8D ; Subtract with carry (long) [$8D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	trb $8E.b		; 14 8E ; Test and reset bits $8E.b [Reads: Accumulator] [Flags: Z]
	jsl $06DBF8.l		; 22 F8 DB 06 ; Jump to subroutine long $06DBF8.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $14		; 10 14 ; Branch if plus to $10, $14 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$13.b		; A9 13 ; Load #$13.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0E40.w,X		; FE 40 0E ; Increment memory $0E40.w,X [Reads: X Index] [Flags: NZ]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DD606.l		; 22 06 D6 0D ; Jump to subroutine long $0DD606.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0DF0.w,X		; FE F0 0D ; Increment memory $0DF0.w,X [Reads: X Index] [Flags: NZ]
	jsl $06F121.l		; 22 21 F1 06 ; Jump to subroutine long $06F121.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$BD.b]		; 07 BD ; OR accumulator with memory (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $8E2D.w,Y		; B9 2D 8E ; Load $8E2D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0B89.w,X		; BD 89 0B ; Load $0B89.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsl $0DD56C.l		; 22 6C D5 0D ; Jump to subroutine long $0DD56C.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$08.b		; C9 08 ; Compare #$08.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $8F81.w		; 20 81 8F ; Jump to subroutine at $8F81.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $18		; D0 18 ; Branch if not equal to $D0, $18 [Flow: branch]
	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8E29.w,Y		; 79 29 8E ; Add $8E29.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	cmp $8E2B.w,Y		; D9 2B 8E ; Compare accumulator $8E2B.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0ED0.w,X		; FE D0 0E ; Increment memory $0ED0.w,X [Reads: X Index] [Flags: NZ]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$28.b		; 69 28 ; Add #$28.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$50.b		; C9 50 ; Compare #$50.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $3A		; B0 3A ; Branch if carry set to $B0, $3A [Flow: branch]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$28.b		; 69 28 ; Add #$28.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$50.b		; C9 50 ; Compare #$50.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $31		; B0 31 ; Branch if carry set to $B0, $31 [Flow: branch]
	lda $44.b		; A5 44 ; Load $44.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $2B		; F0 2B ; Branch if equal to $F0, $2B [Flow: branch]
	lda $0372.w		; AD 72 03 ; Load $0372.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda $3C.b		; A5 3C ; Load $3C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA1A.l		; 22 1A EA 06 ; Jump to subroutine long $06EA1A.l [Writes: Stack Pointer] [Flow: call]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	stx $8F36.w		; 8E 36 8F ; Store X register to $8F36.w [Reads: X Index]
	cmp ($8E.b)		; D2 8E ; Compare accumulator (indirect) ($8E.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	jsr $8F50.w		; 20 50 8F ; Jump to subroutine at $8F50.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $37		; D0 37 ; Branch if not equal to $D0, $37 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	inc $0DA0.w,X		; FE A0 0D ; Increment memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	stz $0DA0.w,X		; 9E A0 0D ; Store zero to $0DA0.w,X [Reads: X Index]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	lda $8EF4.w,Y		; B9 F4 8E ; Load $8EF4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$20.b		; 09 20 ; Logical OR #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8EE4.w,Y		; B9 E4 8E ; Load $8EE4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $8EEC.w,Y		; B9 EC 8E ; Load $8EEC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	.db $80, $1D		; 80 1D ; Branch always to $80, $1D [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	ldy $0E20.w,X		; BC 20 0E ; Load Y register $0E20.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$D0A8.w		; C0 A8 D0 ; Compare #$D0A8.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $A9.b		; 05 A9 ; Logical OR $A9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $9D		; 10 9D ; Branch if plus to $10, $9D [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $04FA.w		; 0E FA 04 ; Arithmetic shift left $04FA.w [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sbc $070000.l,X		; FF 00 00 07 ; Subtract with carry (long,X) $070000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($0000.w,X)		; FC 00 00 ; Jump to subroutine indirect indexed ($0000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$A8.b		; A9 A8 ; Load #$A8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $55		; 30 55 ; Branch if minus to $30, $55 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,Y		; 99 70 0F ; Store accumulator to $0F70.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $0DE0.w,Y		; BE E0 0D ; Load X register $0DE0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8F71.w,X		; 7D 71 8F ; Add $8F71.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $8F75.w,X		; 7D 75 8F ; Add $8F75.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $8F79.w,X		; 7D 79 8F ; Add $8F79.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $8F7D.w,X		; 7D 7D 8F ; Add $8F7D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $8BD8.w,X		; BD D8 8B ; Load $8BD8.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $8BDA.w,X		; BD DA 8B ; Load $8BDA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,Y		; 99 60 0F ; Store accumulator to $0F60.w,Y [Reads: Y Index, Accumulator]
	lda #$33.b		; A9 33 ; Load #$33.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,Y		; 99 60 0E ; Store accumulator to $0E60.w,Y [Reads: Y Index, Accumulator]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $9040.w		; 20 40 90 ; Jump to subroutine at $9040.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jsl $06F6CA.l		; 22 CA F6 06 ; Jump to subroutine long $06F6CA.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($FEFF.w,X)		; FC FF FE ; Jump to subroutine indirect indexed ($FEFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $00802F.l,X		; FF 2F 80 00 ; Subtract with carry (long,X) $00802F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($02FF.w,X)		; FC FF 02 ; Jump to subroutine indirect indexed ($02FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00C02F.l,X		; FF 2F C0 00 ; Subtract with carry (long,X) $00C02F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00403F.l,X		; FF 3F 40 00 ; Subtract with carry (long,X) $00403F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3F0004.l,X		; FF 04 00 3F ; Subtract with carry (long,X) $3F0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3FFFFC.l,X		; FF FC FF 3F ; Subtract with carry (long,X) $3FFFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$9000.w		; 69 00 90 ; Add #$9000.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $87F0.w		; 4C F0 87 ; Jump to $87F0.w [Flow: jump]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $0406.w		; 20 06 04 ; Jump to subroutine at $0406.w [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $8FDF.w		; 4C DF 8F ; Jump to $8FDF.w [Flow: jump]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $3C		; F0 3C ; Branch if equal to $F0, $3C [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2E		; D0 2E ; Branch if not equal to $D0, $2E [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $8B2E.w		; [PATTERN: Memory clearing operation] 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0E90.w,X		; 9E 90 0E ; Store zero to $0E90.w,X [Reads: X Index]
	lda #$15.b		; A9 15 ; Load #$15.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	jsl $05AB9C.l		; 22 9C AB 05 ; Jump to subroutine long $05AB9C.l [Writes: Stack Pointer] [Flow: call]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E10.w,X		; [PATTERN: Memory clearing operation] 9D 10 0E ; Store accumulator to $0E10.w,X [Reads: Accumulator, X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $7F		; D0 7F ; Branch if not equal to $D0, $7F [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FD8.w		; ED D8 0F ; Subtract $0FD8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0028.w		; 69 28 00 ; Add #$0028.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0050.w		; C9 50 00 ; Compare #$0050.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $6E		; B0 6E ; Branch if carry set to $B0, $6E [Flow: branch]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FDA.w		; ED DA 0F ; Subtract $0FDA.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0030.w		; 69 30 00 ; Add #$0030.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0050.w		; C9 50 00 ; Compare #$0050.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $5F		; B0 5F ; Branch if carry set to $B0, $5F [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	lda $44.b		; A5 44 ; Load $44.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $57		; F0 57 ; Branch if equal to $F0, $57 [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F00.w,X		; 1D 00 0F ; OR accumulator with memory $0F00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $4F		; D0 4F ; Branch if not equal to $D0, $4F [Flow: branch]
	lda $EE.b		; A5 EE ; Load $EE.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $0F20.w,X		; DD 20 0F ; Compare accumulator $0F20.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $48		; D0 48 ; Branch if not equal to $D0, $48 [Flow: branch]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	lda $0372.w		; AD 72 03 ; Load $0372.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $3C.b		; A5 3C ; Load $3C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$90.b		; C9 90 ; Compare #$90.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $34		; 10 34 ; Branch if plus to $10, $34 [Flow: branch]
	lda $2F.b		; A5 2F ; Load $2F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $90B1.w,Y		; D9 B1 90 ; Compare accumulator $90B1.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $F0, $29		; F0 29 ; Branch if equal to $F0, $29 [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA1A.l		; 22 1A EA 06 ; Jump to subroutine long $06EA1A.l [Writes: Stack Pointer] [Flow: call]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$13.b		; A9 13 ; Load #$13.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	inc $0F70.w,X		; FE 70 0F ; Increment memory $0F70.w,X [Reads: X Index] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $5D		; F0 5D ; Branch if equal to $F0, $5D [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $9068.w,Y		; B9 68 90 ; Load $9068.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsl $0DC21C.l		; 22 1C C2 0D ; Jump to subroutine long $0DC21C.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0EA0.w,X		; BD A0 0E ; Load $0EA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0D50.w,X		; [PATTERN: Memory clearing operation] 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and #$0C.b		; 29 0C ; Logical AND #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $19		; 10 19 ; Branch if plus to $10, $19 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	jsr $92BD.w		; 20 BD 92 ; Jump to subroutine at $92BD.w [Writes: Stack Pointer] [Flow: call]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EE0.w,X		; 9D E0 0E ; Store accumulator to $0EE0.w,X [Reads: Accumulator, X Index]
	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $21		; F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	jsr $9443.w		; 20 43 94 ; Jump to subroutine at $9443.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jsl $06F6D5.l		; 22 D5 F6 06 ; Jump to subroutine long $06F6D5.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0EE0.w,X		; BD E0 0E ; Load $0EE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $92BD.w		; 20 BD 92 ; Jump to subroutine at $92BD.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	jsr $9379.w		; 20 79 93 ; Jump to subroutine at $9379.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DE0.w,X		; 7D E0 0D ; Add $0DE0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9060.w,Y		; B9 60 90 ; Load $9060.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$A7.b		; C9 A7 ; Compare #$A7.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	jsl $0DC21C.l		; 22 1C C2 0D ; Jump to subroutine long $0DC21C.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $07		; 80 07 ; Branch always to $80, $07 [Flow: branch]
	jsl $0DC0A6.l		; 22 A6 C0 0D ; Jump to subroutine long $0DC0A6.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sta ($5C.b)		; 92 5C ; Store accumulator (indirect) ($5C.b) [Reads: Direct Page, Accumulator]
	sta ($D2.b)		; 92 D2 ; Store accumulator (indirect) ($D2.b) [Reads: Direct Page, Accumulator]
	sta ($BD.b)		; 92 BD ; Store accumulator (indirect) ($BD.b) [Reads: Direct Page, Accumulator]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $23		; D0 23 ; Branch if not equal to $D0, $23 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $905C.w,Y		; B9 5C 90 ; Load $905C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8BD8.w,Y		; B9 D8 8B ; Load $8BD8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $8BDA.w,Y		; B9 DA 8B ; Load $8BDA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0E70.w,X		; BC 70 0E ; Load Y register $0E70.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $D0, $2B		; D0 2B ; Branch if not equal to $D0, $2B [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $5C		; D0 5C ; Branch if not equal to $D0, $5C [Flow: branch]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$A6.b		; C9 A6 ; Compare #$A6.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0DE0.w,X		; DD E0 0D ; Compare accumulator $0DE0.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $14		; D0 14 ; Branch if not equal to $D0, $14 [Flow: branch]
	lda $EE.b		; A5 EE ; Load $EE.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $0F20.w,X		; DD 20 0F ; Compare accumulator $0F20.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	.db $80, $31		; 80 31 ; Branch always to $80, $31 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9254.w,Y		; B9 54 92 ; Load $9254.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	inc $0DB0.w,X		; FE B0 0D ; Increment memory $0DB0.w,X [Reads: X Index] [Flags: NZ]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	stz $0DB0.w,X		; 9E B0 0D ; Store zero to $0DB0.w,X [Reads: X Index]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; [PATTERN: Memory clearing operation] 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $0ED0.w,X		; DE D0 0E ; Decrement memory $0ED0.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	lda #$0B.b		; A9 0B ; Load #$0B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0ED0.w,X		; 9D D0 0E ; Store accumulator to $0ED0.w,X [Reads: Accumulator, X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$18.b		; C9 18 ; Compare #$18.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $1E92E4.l		; 22 E4 92 1E ; Jump to subroutine long $1E92E4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$A5.b		; A9 A5 ; Load #$A5.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $72		; 30 72 ; Branch if minus to $30, $72 [Flow: branch]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9369.w,X		; 7D 69 93 ; Add $9369.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $936D.w,X		; 7D 6D 93 ; Add $936D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9371.w,X		; 7D 71 93 ; Add $9371.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $9375.w,X		; 7D 75 93 ; Add $9375.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $9363.w,X		; BD 63 93 ; Load $9363.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $9365.w,X		; BD 65 93 ; Load $9365.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $0E60.w,Y		; B9 60 0E ; Load $0E60.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,Y		; 99 60 0E ; Store accumulator to $0E60.w,Y [Reads: Y Index, Accumulator]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,Y		; 99 AA 0C ; Store accumulator to $0CAA.w,Y [Reads: Y Index, Accumulator]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	sta $0DA0.w,Y		; 99 A0 0D ; Store accumulator to $0DA0.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,Y		; 99 60 0F ; Store accumulator to $0F60.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	lda #$25.b		; A9 25 ; Load #$25.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CD2.w,Y		; 99 D2 0C ; Store accumulator to $0CD2.w,Y [Reads: Y Index, Accumulator]
	lda $7EF35A.l		; AF 5A F3 7E ; Load long $7EF35A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BE0.w,Y		; 99 E0 0B ; Store accumulator to $0BE0.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $D0		; 30 D0 ; Branch if minus to $30, $D0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $D0		; 30 D0 ; Branch if minus to $30, $D0 [Flow: branch]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $08FE.w,X		; FE FE 08 ; Increment memory $08FE.w,X [Reads: X Index] [Flags: NZ]
	cpx $FFFF.w		; EC FF FF ; Compare $FFFF.w with X register [Reads: X Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$A7.b		; A9 A7 ; Load #$A7.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $41		; 30 41 ; Branch if minus to $30, $41 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	lda #$48.b		; A9 48 ; Load #$48.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,X		; 9D AA 0C ; Store accumulator to $0CAA.w,X [Reads: Accumulator, X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CD2.w,X		; 9D D2 0C ; Store accumulator to $0CD2.w,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $00.b,S		; C3 00 ; Compare accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $C20000.l,X		; FF 00 00 C2 ; Subtract with carry (long,X) $C20000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C20000.l,X		; FF 00 00 C2 ; Subtract with carry (long,X) $C20000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $C0.b,S		; C3 C0 ; Compare accumulator (stack relative) $C0.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pei ($00.b)		; D4 00 ; Push effective indirect address ($00.b) [Reads: Direct Page] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $0000D3.l,X		; FF D3 00 00 ; Subtract with carry (long,X) $0000D3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $0040D3.l,X		; FF D3 40 00 ; Subtract with carry (long,X) $0040D3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$93C3.w		; 69 C3 93 ; Add #$93C3.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $87F0.w		; 4C F0 87 ; Jump to $87F0.w [Flow: jump]
	jsr $FE7F.w		; 20 7F FE ; Jump to subroutine at $FE7F.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $11		; B0 11 ; Branch if carry set to $B0, $11 [Flow: branch]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $08		; B0 08 ; Branch if carry set to $B0, $08 [Flow: branch]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	jsl $079291.l		; 22 91 92 07 ; Jump to subroutine long $079291.l [Writes: Stack Pointer] [Flow: call]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $38		; D0 38 ; Branch if not equal to $D0, $38 [Flow: branch]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	lda #$C0.b		; A9 C0 ; Load #$C0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,X		; 9D D0 0D ; Store accumulator to $0DD0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0EF0.w,X		; BD F0 0E ; Load $0EF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $16		; F0 16 ; Branch if equal to $F0, $16 [Flow: branch]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $949E.w,Y		; B9 9E 94 ; Load $949E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0422.w		; 8D 22 04 ; Store accumulator to $0422.w [Reads: Accumulator]
	lda $94A0.w,Y		; B9 A0 94 ; Load $94A0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0423.w		; 8D 23 04 ; Store accumulator to $0423.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0428.w		; 8D 28 04 ; Store accumulator to $0428.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0428.w		; 9C 28 04 ; Store zero to $0428.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	cmp #$12.b		; C9 12 ; Compare #$12.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00EC79.l		; 22 79 EC 00 ; Jump to subroutine long $00EC79.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D82.w		; 8D 82 0D ; Store accumulator to $0D82.w [Reads: Accumulator]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF2.w		; 8D F2 0D ; Store accumulator to $0DF2.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0E00.w,X		; 1D 00 0E ; OR accumulator with memory $0E00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2D		; D0 2D ; Branch if not equal to $D0, $2D [Flow: branch]
	lda #$A4.b		; A9 A4 ; Load #$A4.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $25		; 30 25 ; Branch if minus to $30, $25 [Flow: branch]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$E0.b		; A9 E0 ; Load #$E0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,Y		; 99 70 0F ; Store accumulator to $0F70.w,Y [Reads: Y Index, Accumulator]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DD98F.l		; 22 8F D9 0D ; Jump to subroutine long $0DD98F.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	jsr $96A5.w		; 20 A5 96 ; Jump to subroutine at $96A5.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	dec $0E80.w,X		; DE 80 0E ; Decrement memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA1A.l		; 22 1A EA 06 ; Jump to subroutine long $06EA1A.l [Writes: Stack Pointer] [Flow: call]
	jsl $1DF614.l		; 22 14 F6 1D ; Jump to subroutine long $1DF614.l [Writes: Stack Pointer] [Flow: call]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	adc $95E595.l		; 6F 95 E5 95 ; Add with carry (long) $95E595.l [Writes: Accumulator] [Flags: NCVZ]
	jmp $9496.w		; 4C 96 94 ; Jump to $9496.w [Flow: jump]
	stx $20.b,Y		; 96 20 ; Store X register $20.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	adc [$C2.b]		; 67 C2 ; Add with carry (long) [$C2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0F80.w,X		; DD 80 0F ; Compare accumulator $0F80.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	inc $0D50.w,X		; FE 50 0D ; Increment memory $0D50.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	dec $0D50.w,X		; DE 50 0D ; Decrement memory $0D50.w,X [Reads: X Index] [Flags: NZ]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0F90.w,X		; DD 90 0F ; Compare accumulator $0F90.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	inc $0D40.w,X		; FE 40 0D ; Increment memory $0D40.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	dec $0D40.w,X		; DE 40 0D ; Decrement memory $0D40.w,X [Reads: X Index] [Flags: NZ]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0C.b		; 29 0C ; Logical AND #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0F90.w,X		; BD 90 0F ; Load $0F90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0F90.w,X		; 9D 90 0F ; Store accumulator to $0F90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $38		; D0 38 ; Branch if not equal to $D0, $38 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$60.b		; 69 60 ; Add #$60.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $95DD.w,Y		; B9 DD 95 ; Load $95DD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $95E1.w,Y		; B9 E1 95 ; Load $95E1.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F90.w,X		; 9D 90 0F ; Store accumulator to $0F90.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and #$1C.b		; 29 1C ; Logical AND #$1C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA1A.l		; 22 1A EA 06 ; Jump to subroutine long $06EA1A.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F90.w,X		; 9D 90 0F ; Store accumulator to $0F90.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	inc $0D50.w,X		; FE 50 0D ; Increment memory $0D50.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	dec $0D50.w,X		; DE 50 0D ; Decrement memory $0D50.w,X [Reads: X Index] [Flags: NZ]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	inc $0D40.w,X		; FE 40 0D ; Increment memory $0D40.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	dec $0D40.w,X		; DE 40 0D ; Decrement memory $0D40.w,X [Reads: X Index] [Flags: NZ]
	jmp $95AA.w		; 4C AA 95 ; Jump to $95AA.w [Flow: jump]
	jsr $00E0.w		; 20 E0 00 ; Jump to subroutine at $00E0.w [Writes: Stack Pointer] [Flow: call]
	cpx #$30E0.w		; E0 E0 30 ; Compare #$30E0.w with X register [Reads: X Index] [Flags: NCZ]
	lda $0DF0.w,X		; [PATTERN: Memory clearing operation] BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $38		; D0 38 ; Branch if not equal to $D0, $38 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	stz $0DD1.w,X		; 9E D1 0D ; Store zero to $0DD1.w,X [Reads: X Index]
	stz $0DD2.w,X		; 9E D2 0D ; Store zero to $0DD2.w,X [Reads: X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FB5.w		; 8D B5 0F ; Store accumulator to $0FB5.w [Reads: Accumulator]
	lda #$A2.b		; A9 A2 ; Load #$A2.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$2204.w		; A0 04 22 ; Load #$2204.w into Y register [Writes: Y Index] [Flags: NZ]
	eor $301DF6.l,X		; 5F F6 1D 30 ; Exclusive OR accumulator with memory (long,X) $301DF6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $6422.w		; 20 22 64 ; Jump to subroutine at $6422.w [Writes: Stack Pointer] [Flow: call]
	ldx $DA09.w		; AE 09 DA ; Load $DA09.w into X register [Writes: X Index] [Flags: NZ]
	ldx $0FB5.w		; AE B5 0F ; Load $0FB5.w into X register [Writes: X Index] [Flags: NZ]
	lda $9646.w,X		; BD 46 96 ; Load $9646.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	lda $9649.w,X		; BD 49 96 ; Load $9649.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F90.w,Y		; 99 90 0F ; Store accumulator to $0F90.w,Y [Reads: Y Index, Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dec $0FB5.w		; CE B5 0F ; Decrement $0FB5.w [Flags: NZ]
	.db $10, $D7		; 10 D7 ; Branch if plus to $10, $D7 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0EF0.w,X		; BD F0 0E ; Load $0EF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$E0.b		; 09 E0 ; Logical OR #$E0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EF0.w,X		; 9D F0 0E ; Store accumulator to $0EF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr ($00FE.w,X)		; FC FE 00 ; Jump to subroutine indirect indexed ($00FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	sbc $00FFFF.l,X		; FF FF FF 00 ; Subtract with carry (long,X) $00FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $63		; D0 63 ; Branch if not equal to $D0, $63 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$BF0E.w		; A2 0E BF ; Load #$BF0E.w into X register [Writes: X Index] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $CA05F0.l,X		; 7F F0 05 CA ; Add long $CA05F0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF800.l,X		; 9F 00 F8 7F ; Store accumulator (long,X) $7FF800.l,X [Reads: Accumulator, X Index]
	sta $0FB4.w		; 8D B4 0F ; Store accumulator to $0FB4.w [Reads: Accumulator]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF90E.l,X		; 9F 0E F9 7F ; Store accumulator (long,X) $7FF90E.l,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9695.w,Y		; 79 95 96 ; Add $9695.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF83C.l,X		; 9F 3C F8 7F ; Store accumulator (long,X) $7FF83C.l,X [Reads: Accumulator, X Index]
	lda $0FD9.w		; AD D9 0F ; Load $0FD9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $969D.w,Y		; 79 9D 96 ; Add $969D.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF878.l,X		; 9F 78 F8 7F ; Store accumulator (long,X) $7FF878.l,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9695.w,Y		; 79 95 96 ; Add $9695.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	lda $0FDB.w		; AD DB 0F ; Load $0FDB.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	adc $969D.w,Y		; 79 9D 96 ; Add $969D.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF85A.l,X		; 9F 5A F8 7F ; Store accumulator (long,X) $7FF85A.l,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF968.l,X		; 9F 68 F9 7F ; Store accumulator (long,X) $7FF968.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1E		; D0 1E ; Branch if not equal to $D0, $1E [Flow: branch]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0DD2.w		; AD D2 0D ; Load $0DD2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $11		; B0 11 ; Branch if carry set to $B0, $11 [Flow: branch]
	lda $0DD3.w		; AD D3 0D ; Load $0DD3.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0A		; B0 0A ; Branch if carry set to $B0, $0A [Flow: branch]
	lda $0DD4.w		; AD D4 0D ; Load $0DD4.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jmp $94DD.w		; 4C DD 94 ; Jump to $94DD.w [Flow: jump]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$10.b		; 49 10 ; Exclusive OR #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $D0, $2E		; D0 2E ; Branch if not equal to $D0, $2E [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $06		; 30 06 ; Branch if minus to $30, $06 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$03.b		; E9 03 ; Subtract #$03.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $0F70.w,X		; 5D 70 0F ; Exclusive OR accumulator with memory $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $29		; [PATTERN: Memory clearing operation] 10 29 ; Branch if plus to $10, $29 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jsr $97CF.w		; 20 CF 97 ; Jump to subroutine at $97CF.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $012E.w		; AD 2E 01 ; Load $012E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$1E.b		; A9 1E ; Load #$1E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$2000.w		; E0 00 20 ; Compare #$2000.w with X register [Reads: X Index] [Flags: NCZ]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FB5.w		; 8D B5 0F ; Store accumulator to $0FB5.w [Reads: Accumulator]
	lda #$A4.b		; A9 A4 ; Load #$A4.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $2D		; 30 2D ; Branch if minus to $30, $2D [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,Y		; 99 80 0D ; Store accumulator to $0D80.w,Y [Reads: Y Index, Accumulator]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0FB5.w		; AD B5 0F ; Load $0FB5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $97BF.w,X		; BD BF 97 ; Load $97BF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $97C7.w,X		; BD C7 97 ; Load $97C7.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$1C.b		; A9 1C ; Load #$1C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,Y		; 99 60 0F ; Store accumulator to $0F60.w,Y [Reads: Y Index, Accumulator]
	dec $0FB5.w		; CE B5 0F ; Decrement $0FB5.w [Flags: NZ]
	.db $10, $C6		; 10 C6 ; Branch if plus to $10, $C6 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DBFA6.l		; 22 A6 BF 0D ; Jump to subroutine long $0DBFA6.l [Writes: Stack Pointer] [Flow: call]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $15		; F0 15 ; Branch if equal to $F0, $15 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,X		; 9D D0 0D ; Store accumulator to $0DD0.w,X [Reads: Accumulator, X Index]
	stz $0EF0.w,X		; 9E F0 0E ; Store zero to $0EF0.w,X [Reads: X Index]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	eor $7198.w,Y		; 59 98 71 ; Exclusive OR accumulator with memory $7198.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($98.b)		; D2 98 ; Compare accumulator (indirect) ($98.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $42, $99		; 42 99 ; Reserved instruction
	inc $0BA0.w,X		; FE A0 0B ; Increment memory $0BA0.w,X [Reads: X Index] [Flags: NZ]
	jsr $FE6E.w		; 20 6E FE ; Jump to subroutine at $FE6E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $08		; B0 08 ; Branch if carry set to $B0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	.db $D0, $32		; D0 32 ; Branch if not equal to $D0, $32 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$05.b		; E9 05 ; Subtract #$05.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	ldy #$2208.w		; A0 08 22 ; Load #$2208.w into Y register [Writes: Y Index] [Flags: NZ]
	lda #$E7.b		; A9 E7 ; Load #$E7.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($A9.b,X)		; 01 A9 ; Logical OR ($A9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda #$50.b		; A9 50 ; Load #$50.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8BD8.w,Y		; B9 D8 8B ; Load $8BD8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsr $FF28.w		; 20 28 FF ; Jump to subroutine at $FF28.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($EE.b)		; 12 EE ; OR accumulator with memory (indirect) ($EE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr ($00FE.w,X)		; FC FE 00 ; Jump to subroutine indirect indexed ($00FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $0000FF.l,X		; FF FF 00 00 ; Subtract with carry (long,X) $0000FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	stz $0EF0.w,X		; 9E F0 0E ; Store zero to $0EF0.w,X [Reads: X Index]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $98C2.w,Y		; B9 C2 98 ; Load $98C2.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $98CA.w,Y		; B9 CA 98 ; Load $98CA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda #$FC.b		; A9 FC ; Load #$FC.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	jsl $1EA007.l		; 22 07 A0 1E ; Jump to subroutine long $1EA007.l [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $98B8.w,Y		; B9 B8 98 ; Load $98B8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $98BA.w,Y		; B9 BA 98 ; Load $98BA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $98BE.w,Y		; B9 BE 98 ; Load $98BE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $09C2F5.l		; 22 F5 C2 09 ; Jump to subroutine long $09C2F5.l [Writes: Stack Pointer] [Flow: call]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $993E.w,Y		; B9 3E 99 ; Load $993E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $9A4B.w		; 20 4B 9A ; Jump to subroutine at $9A4B.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	jmp ($9199.w)		; 6C 99 91 ; Jump indirect to ($9199.w) [Flow: jump]
	sta $00A0.w,Y		; 99 A0 00 ; Store accumulator to $00A0.w,Y [Reads: Y Index, Accumulator]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$18.b		; 29 18 ; Logical AND #$18.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	ldy #$9803.w		; A0 03 98 ; Load #$9803.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0FDD.w		; AD DD 0F ; Load $0FDD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$F8.b		; A9 F8 ; Load #$F8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0E		; [PATTERN: Memory clearing operation] 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	ldy $0D90.w,X		; BC 90 0D ; Load Y register $0D90.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $998D.w,Y		; B9 8D 99 ; Load $998D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($F8FF.w,X)		; FC FF F8 ; Jump to subroutine indirect indexed ($F8FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $000080.l,X		; FF 80 00 00 ; Subtract with carry (long,X) $000080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000081.l,X		; FF 81 00 00 ; Subtract with carry (long,X) $000081.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A30008.l,X		; FF 08 00 A3 ; Subtract with carry (long,X) $A30008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $80FFF8.l,X		; FF F8 FF 80 ; Subtract with carry (long,X) $80FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000081.l,X		; FF 81 00 00 ; Subtract with carry (long,X) $000081.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A00008.l,X		; FF 08 00 A0 ; Subtract with carry (long,X) $A00008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A1.b		; 00 A1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $80FFF8.l,X		; FF F8 FF 80 ; Subtract with carry (long,X) $80FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000081.l,X		; FF 81 00 00 ; Subtract with carry (long,X) $000081.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $830008.l,X		; FF 08 00 83 ; Subtract with carry (long,X) $830008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $80FFF9.l,X		; FF F9 FF 80 ; Subtract with carry (long,X) $80FFF9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000081.l,X		; FF 81 00 00 ; Subtract with carry (long,X) $000081.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A30009.l,X		; FF 09 00 A3 ; Subtract with carry (long,X) $A30009.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$99CB.w		; 69 CB 99 ; Add #$99CB.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
	lda #$12.b		; A9 12 ; Load #$12.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06DC5C.l		; 22 5C DC 06 ; Jump to subroutine long $06DC5C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$BD0D.w		; E0 0D BD ; Compare #$BD0D.w with X register [Reads: X Index] [Flags: NCZ]
	.db $50, $0F		; 50 0F ; Branch if overflow clear to $50, $0F [Flow: branch]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $9A6B.w,Y		; 19 6B 9A ; OR accumulator with memory $9A6B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	lda $03A99A.l		; AF 9A A9 03 ; Load long $03A99A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0FDD.w		; AD DD 0F ; Load $0FDD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $17		; F0 17 ; Branch if equal to $F0, $17 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8BD8.w,Y		; B9 D8 8B ; Load $8BD8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda #$F8.b		; A9 F8 ; Load #$F8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $DEFF.w,X		; 1E FF DE ; Arithmetic shift left $DEFF.w,X [Reads: X Index] [Flags: NCZ]
	.db $80, $0F		; 80 0F ; Branch always to $80, $0F [Flow: branch]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0E		; [PATTERN: Memory clearing operation] 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	ldy $0D90.w,X		; BC 90 0D ; Load Y register $0D90.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $9AAC.w,Y		; B9 AC 9A ; Load $9AAC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $9B9C.w		; 20 9C 9B ; Jump to subroutine at $9B9C.w [Writes: Stack Pointer] [Flow: call]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $9A6B.w,Y		; 19 6B 9A ; OR accumulator with memory $9A6B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
.ACCU 16
	rep #$20		; C2 20
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0004.w		; 69 04 00 ; Add #$0004.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	inc $92.b		; E6 92 ; Increment $92.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	dec $0E40.w,X		; DE 40 0E ; Decrement memory $0E40.w,X [Reads: X Index] [Flags: NZ]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	inc $0E40.w,X		; FE 40 0E ; Increment memory $0E40.w,X [Reads: X Index] [Flags: NZ]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	bit $619B.w		; 2C 9B 61 ; Test bits $619B.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sty $9B.b		; 84 9B ; Store Y register to $9B.b [Reads: Y Index]
	ldy #$A500.w		; A0 00 A5 ; Load #$A500.w into Y register [Writes: Y Index] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and #$18.b		; 29 18 ; Logical AND #$18.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	ldy #$9803.w		; A0 03 98 ; Load #$9803.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0FDD.w		; AD DD 0F ; Load $0FDD.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $21		; F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8BD8.w,Y		; B9 D8 8B ; Load $8BD8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$F8.b		; A9 F8 ; Load #$F8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$01.b		; E9 01 ; Subtract #$01.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	cmp #$F1.b		; C9 F1 ; Compare #$F1.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	dec $0D80.w,X		; DE 80 0D ; Decrement memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $FF.b		; 84 FF ; Store Y register to $FF.b [Reads: Y Index]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9B9A.w,X		; 7D 9A 9B ; Add $9B9A.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$AE.b		; A9 AE ; Load #$AE.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $9A6B.w,X		; 1D 6B 9A ; OR accumulator with memory $9A6B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy #$A900.w		; A0 00 A9 ; Load #$A900.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $FE.b,X		; B4 FE ; Load Y register $FE.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	asl $60.b		; 06 60 ; Arithmetic shift left $60.b [Reads: Direct Page] [Flags: NCZ]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $9C6B.w		; 4C 6B 9C ; Jump to $9C6B.w [Flow: jump]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	inc $0DB0.w,X		; FE B0 0D ; Increment memory $0DB0.w,X [Reads: X Index] [Flags: NZ]
	jsr $FE73.w		; 20 73 FE ; Jump to subroutine at $FE73.w [Writes: Stack Pointer] [Flow: call]
	cpy #$F000.w		; C0 00 F0 ; Compare #$F000.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $9E.b		; 04 9E ; Test and set bits $9E.b [Reads: Accumulator] [Flags: Z]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06DBF8.l		; 22 F8 DB 06 ; Jump to subroutine long $06DBF8.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $8BD8.w,Y		; B9 D8 8B ; Load $8BD8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx #$BF1D.w		; A2 1D BF ; Load #$BF1D.w into X register [Writes: X Index] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $CA05F0.l,X		; 7F F0 05 CA ; Add long $CA05F0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF800.l,X		; 9F 00 F8 7F ; Store accumulator (long,X) $7FF800.l,X [Reads: Accumulator, X Index]
	sta $0FB4.w		; 8D B4 0F ; Store accumulator to $0FB4.w [Reads: Accumulator]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF83C.l,X		; 9F 3C F8 7F ; Store accumulator (long,X) $7FF83C.l,X [Reads: Accumulator, X Index]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF878.l,X		; 9F 78 F8 7F ; Store accumulator (long,X) $7FF878.l,X [Reads: Accumulator, X Index]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF85A.l,X		; 9F 5A F8 7F ; Store accumulator (long,X) $7FF85A.l,X [Reads: Accumulator, X Index]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF90E.l,X		; 9F 0E F9 7F ; Store accumulator (long,X) $7FF90E.l,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF92C.l,X		; 9F 2C F9 7F ; Store accumulator (long,X) $7FF92C.l,X [Reads: Accumulator, X Index]
	lda $0F20.w,Y		; B9 20 0F ; Load $0F20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF968.l,X		; 9F 68 F9 7F ; Store accumulator (long,X) $7FF968.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DBD20.l		; 22 20 BD 0D ; Jump to subroutine long $0DBD20.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	sta ($9C.b,X)		; 81 9C ; Store accumulator ($9C.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta $9CAD9C.l		; 8F 9C AD 9C ; Store accumulator (long) $9CAD9C.l [Reads: Accumulator]
	cpx $FE9C.w		; EC 9C FE ; Compare $FE9C.w with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$37.b		; A9 37 ; Load #$37.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $00E0.w		; 20 E0 00 ; Jump to subroutine at $00E0.w [Writes: Stack Pointer] [Flow: call]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0BD.w		; E0 BD F0 ; Compare #$F0BD.w with X register [Reads: X Index] [Flags: NCZ]
	ora $19D0.w		; 0D D0 19 ; Logical OR $19D0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $9CA7.w,Y		; B9 A7 9C ; Load $9CA7.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $9CA9.w,Y		; B9 A9 9C ; Load $9CA9.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $13		; 90 13 ; Branch if carry clear to $90, $13 [Flow: branch]
	sbc #$20.b		; E9 20 ; Subtract #$20.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9C9D.w,Y		; B9 9D 9C ; Load $9C9D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9CA3.w,Y		; 79 A3 9C ; Add $9CA3.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($0E.b)		; 12 0E ; OR accumulator with memory (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $2010.w		; 0C 10 20 ; Test and set bits $2010.w [Reads: Accumulator] [Flags: Z]
	adc [$C2.b]		; 67 C2 ; Add with carry (long) [$C2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9CE8.w,Y		; 79 E8 9C ; Add $9CE8.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $83.b,S		; C3 83 ; Compare accumulator (stack relative) $83.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $26		; F0 26 ; Branch if equal to $F0, $26 [Flow: branch]
	jsl $0DBE68.l		; 22 68 BE 0D ; Jump to subroutine long $0DBE68.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$06.b		; 49 06 ; Exclusive OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	jsl $0DBE06.l		; 22 06 BE 0D ; Jump to subroutine long $0DBE06.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	ror $AA9D.w,X		; 7E 9D AA ; Rotate right $AA9D.w,X [Reads: X Index] [Flags: NCZ]
	sta $9DC4.w,X		; 9D C4 9D ; Store accumulator to $9DC4.w,X [Reads: Accumulator, X Index]
	sbc ($9D.b,S),Y		; F3 9D ; Subtract with carry (stack relative indirect indexed) ($9D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $26		; D0 26 ; Branch if not equal to $D0, $26 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $D0, $16		; D0 16 ; Branch if not equal to $D0, $16 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $9D7A.w,Y		; B9 7A 9D ; Load $9D7A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $9E15.w		; 20 15 9E ; Jump to subroutine at $9E15.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9DB8.w,Y		; B9 B8 9D ; Load $9DB8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $9DC0.w,Y		; 79 C0 9D ; Add $9DC0.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $16		; [PATTERN: Memory clearing operation] D0 16 ; Branch if not equal to $D0, $16 [Flow: branch]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $00E0.w		; 20 E0 00 ; Jump to subroutine at $00E0.w [Writes: Stack Pointer] [Flow: call]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$9BA9.w		; E0 A9 9B ; Compare #$9BA9.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $5D		; 30 5D ; Branch if minus to $30, $5D [Flow: branch]
	lda #$36.b		; A9 36 ; Load #$36.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $9E0F.w,X		; BD 0F 9E ; Load $9E0F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $9E11.w,X		; BD 11 9E ; Load $9E11.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda #$48.b		; A9 48 ; Load #$48.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,Y		; 99 AA 0C ; Store accumulator to $0CAA.w,Y [Reads: Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda $7EF35A.l		; AF 5A F3 7E ; Load long $7EF35A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$D003.w		; E0 03 D0 ; Compare #$D003.w with X register [Reads: X Index] [Flags: NCZ]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $E099.w		; 20 99 E0 ; Jump to subroutine at $E099.w [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,Y		; 99 60 0F ; Store accumulator to $0F60.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $A158.w		; 20 58 A1 ; Jump to subroutine at $A158.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	lda $9E.b		; A5 9E ; Load $9E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stz $9F11.w,X		; 9E 11 9F ; Store zero to $9F11.w,X [Reads: X Index]
	eor $E39F.w,Y		; 59 9F E3 ; Exclusive OR accumulator with memory $E39F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0BD.l,X		; 9F BD F0 0D ; Store accumulator (long,X) $0DF0BD.l,X [Reads: Accumulator, X Index]
	.db $D0, $30		; D0 30 ; Branch if not equal to $D0, $30 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$60.b		; 69 60 ; Add #$60.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	dec $0E80.w,X		; DE 80 0E ; Decrement memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	asl $0C0D.w		; 0E 0D 0C ; Arithmetic shift left $0C0D.w [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $20.b		; 05 20 ; Logical OR $20.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$E020.w		; E0 20 E0 ; Compare #$E020.w with X register [Reads: X Index] [Flags: NCZ]
	jsr $E020.w		; 20 20 E0 ; Jump to subroutine at $E020.w [Writes: Stack Pointer] [Flow: call]
	cpx #$F0BD.w		; E0 BD F0 ; Compare #$F0BD.w with X register [Reads: X Index] [Flags: NCZ]
	ora $1ED0.w		; 0D D0 1E ; Logical OR $1ED0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsr $FE73.w		; 20 73 FE ; Jump to subroutine at $FE73.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	jsr $FE6E.w		; 20 6E FE ; Jump to subroutine at $FE6E.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9F09.w,Y		; B9 09 9F ; Load $9F09.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $9F0D.w,Y		; B9 0D 9F ; Load $9F0D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$1D.b		; E9 1D ; Subtract #$1D.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9F01.w,Y		; B9 01 9F ; Load $9F01.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $32		; B0 32 ; Branch if carry set to $B0, $32 [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	inc $0EC0.w,X		; FE C0 0E ; Increment memory $0EC0.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0C.b		; 29 0C ; Logical AND #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	inc $0EC0.w,X		; FE C0 0E ; Increment memory $0EC0.w,X [Reads: X Index] [Flags: NZ]
	lda $0EC0.w,X		; BD C0 0E ; Load $0EC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$28.b		; A9 28 ; Load #$28.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9F55.w,Y		; B9 55 9F ; Load $9F55.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $26		; D0 26 ; Branch if not equal to $D0, $26 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	and #$000F.w		; 29 0F 00 ; Logical AND #$000F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0004.w		; E9 04 00 ; Subtract #$0004.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	and #$000F.w		; 29 0F 00 ; Logical AND #$000F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0004.w		; E9 04 00 ; Subtract #$0004.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	jsl $1EA007.l		; 22 07 A0 1E ; Jump to subroutine long $1EA007.l [Writes: Stack Pointer] [Flow: call]
	rts		; [PATTERN: Memory clearing operation] 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	stz $0EC0.w,X		; 9E C0 0E ; Store zero to $0EC0.w,X [Reads: X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0F.b		; 69 0F ; Add #$0F.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx #$800E.w		; A2 0E 80 ; Load #$800E.w into X register [Writes: X Index] [Flags: NZ]
	tsb $DA.b		; 04 DA ; Test and set bits $DA.b [Reads: Accumulator] [Flags: Z]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx #$BF1D.w		; A2 1D BF ; Load #$BF1D.w into X register [Writes: X Index] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $CA07F0.l,X		; 7F F0 07 CA ; Add long $CA07F0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	stx $0F.b		; 86 0F ; Store X register to $0F.b [Reads: X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stx $0F.b		; 86 0F ; Store X register to $0F.b [Reads: X Index]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF800.l,X		; 9F 00 F8 7F ; Store accumulator (long,X) $7FF800.l,X [Reads: Accumulator, X Index]
	sta $0FB4.w		; 8D B4 0F ; Store accumulator to $0FB4.w [Reads: Accumulator]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF83C.l,X		; 9F 3C F8 7F ; Store accumulator (long,X) $7FF83C.l,X [Reads: Accumulator, X Index]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $01.b		; 65 01 ; Add $01.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF878.l,X		; 9F 78 F8 7F ; Store accumulator (long,X) $7FF878.l,X [Reads: Accumulator, X Index]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0F70.w,Y		; F9 70 0F ; Subtract with carry $0F70.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $03.b		; 65 03 ; Add $03.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF85A.l,X		; 9F 5A F8 7F ; Store accumulator (long,X) $7FF85A.l,X [Reads: Accumulator, X Index]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF90E.l,X		; 9F 0E F9 7F ; Store accumulator (long,X) $7FF90E.l,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF92C.l,X		; 9F 2C F9 7F ; Store accumulator (long,X) $7FF92C.l,X [Reads: Accumulator, X Index]
	lda $0F20.w,Y		; B9 20 0F ; Load $0F20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF968.l,X		; 9F 68 F9 7F ; Store accumulator (long,X) $7FF968.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B5.b		; 00 B5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000086.l,X		; FF 86 00 00 ; Subtract with carry (long,X) $000086.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0080A2.l,X		; FF A2 80 00 ; Subtract with carry (long,X) $0080A2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B5.b		; 00 B5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000096.l,X		; FF 96 00 00 ; Subtract with carry (long,X) $000096.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000A2.l,X		; FF A2 00 00 ; Subtract with carry (long,X) $0000A2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000096.l,X		; FF 96 00 00 ; Subtract with carry (long,X) $000096.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000A2.l,X		; FF A2 00 00 ; Subtract with carry (long,X) $0000A2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000A2.l,X		; FF A2 00 00 ; Subtract with carry (long,X) $0000A2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000A2.l,X		; FF A2 00 00 ; Subtract with carry (long,X) $0000A2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DFFFFA.l,X		; FF FA FF DF ; Subtract with carry (long,X) $DFFFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0041DF.l,X		; FF DF 41 00 ; Subtract with carry (long,X) $0041DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DF000E.l,X		; FF 0E 00 DF ; Subtract with carry (long,X) $DF000E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($00.b,X)		; C1 00 ; Compare accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $96FFFA.l,X		; FF FA FF 96 ; Subtract with carry (long,X) $96FFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004096.l,X		; FF 96 40 00 ; Subtract with carry (long,X) $004096.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $96000E.l,X		; FF 0E 00 96 ; Subtract with carry (long,X) $96000E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $96.b		; 00 96 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($FCFF.w,X)		; FC FF FC ; Jump to subroutine indirect indexed ($FCFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $00018D.l,X		; FF 8D 01 00 ; Subtract with carry (long,X) $00018D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00418D.l,X		; FF 8D 41 00 ; Subtract with carry (long,X) $00418D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $8D000C.l,X		; FF 0C 00 8D ; Subtract with carry (long,X) $8D000C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($00.b,X)		; C1 00 ; Compare accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($00.b,X)		; C1 00 ; Compare accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$BD80.w		; C0 80 BD ; Compare #$BD80.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$C90D.w		; C0 0D C9 ; Compare #$C90D.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $18B0.w		; 0C B0 18 ; Test and set bits $18B0.w [Reads: Accumulator] [Flags: Z]
	ldy $0DC0.w,X		; BC C0 0D ; Load Y register $0DC0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $A14C.w,Y		; 19 4C A1 ; OR accumulator with memory $A14C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0C.b		; E9 0C ; Subtract #$0C.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$A06C.w		; 69 6C A0 ; Add #$A06C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $87F0.w		; 4C F0 87 ; Jump to $87F0.w [Flow: jump]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0DE0BC.l		; 0F BC E0 0D ; OR accumulator with memory (long) $0DE0BC.l [Writes: Accumulator] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A192.w,Y		; 79 92 A1 ; Add $A192.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $A415.w		; 20 15 A4 ; Jump to subroutine at $A415.w [Writes: Stack Pointer] [Flow: call]
	lda $0EA0.w,X		; BD A0 0E ; Load $0EA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	lda $0E70.w,X		; [PATTERN: Memory clearing operation] BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	dec $0F80.w,X		; [PATTERN: Memory clearing operation] DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	nop		; EA ; No operation
	lda ($FB.b,X)		; A1 FB ; Load accumulator ($FB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($44.b,X)		; A1 44 ; Load accumulator ($44.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$A271.w		; A2 71 A2 ; Load #$A271.w into X register [Writes: X Index] [Flags: NZ]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $33		; D0 33 ; Branch if not equal to $D0, $33 [Flow: branch]
	stz $00.b		; 64 00 ; Store zero to $00.b
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $8BD8.w,Y		; D9 D8 8B ; Compare accumulator $8BD8.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A1F5.w,Y		; 79 F5 A1 ; Add $A1F5.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: NZ]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $8BDA.w,Y		; D9 DA 8B ; Compare accumulator $8BDA.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A1F7.w,Y		; 79 F7 A1 ; Add $A1F7.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A240.w,Y		; B9 40 A2 ; Load $A240.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $0C0E.w		; 0C 0E 0C ; Test and set bits $0C0E.w [Reads: Accumulator] [Flags: Z]
	tsb $0C0C.w		; 0C 0C 0C ; Test and set bits $0C0C.w [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $458A.w		; 0C 8A 45 ; Test and set bits $458A.w [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F70.w,X		; 1D 70 0F ; OR accumulator with memory $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $39		; D0 39 ; Branch if not equal to $D0, $39 [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $A269.w,Y		; B9 69 A2 ; Load $A269.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	stz $01.b		; 64 01 ; Store zero to $01.b
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $A261.w,Y		; B9 61 A2 ; Load $A261.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	stz $03.b		; 64 03 ; Store zero to $03.b
	jsl $1EA001.l		; 22 01 A0 1E ; Jump to subroutine long $1EA001.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $FFF8FF.l,X		; FF FF F8 FF ; Subtract with carry (long,X) $FFF8FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $00, $00		; 82 00 00 ; Branch always long to $82, $00, $00 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $82FFF9.l,X		; FF F9 FF 82 ; Subtract with carry (long,X) $82FFF9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $82FFFA.l,X		; FF FA FF 82 ; Subtract with carry (long,X) $82FFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $82FFFC.l,X		; FF FC FF 82 ; Subtract with carry (long,X) $82FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A20000.l,X		; FF 00 00 A2 ; Subtract with carry (long,X) $A20000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A3.b		; 00 A3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004082.l,X		; FF 82 40 00 ; Subtract with carry (long,X) $004082.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $82FF.w,Y		; F9 FF 82 ; Subtract with carry $82FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $004082.l,X		; FF 82 40 00 ; Subtract with carry (long,X) $004082.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	jsr ($82FF.w,X)		; FC FF 82 ; Jump to subroutine indirect indexed ($82FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$0040.w		; A2 40 00 ; Load #$0040.w into X register [Writes: X Index] [Flags: NZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A30000.l,X		; FF 00 00 A3 ; Subtract with carry (long,X) $A30000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $80FF.w,Y		; F9 FF 80 ; Subtract with carry $80FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004080.l,X		; FF 80 40 00 ; Subtract with carry (long,X) $004080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($80FF.w,X)		; FC FF 80 ; Jump to subroutine indirect indexed ($80FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000080.l,X		; FF 80 00 00 ; Subtract with carry (long,X) $000080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $8E0000.l,X		; FF 00 00 8E ; Subtract with carry (long,X) $8E0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $000084.l,X		; FF 84 00 00 ; Subtract with carry (long,X) $000084.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004084.l,X		; FF 84 40 00 ; Subtract with carry (long,X) $004084.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $84FF.w,Y		; F9 FF 84 ; Subtract with carry $84FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $004084.l,X		; FF 84 40 00 ; Subtract with carry (long,X) $004084.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A00000.l,X		; FF 00 00 A0 ; Subtract with carry (long,X) $A00000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	lda $00.b,X		; B5 00 ; Load $00.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B5.b		; 00 B5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $0000A5.l,X		; FF A5 00 00 ; Subtract with carry (long,X) $0000A5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0040A5.l,X		; FF A5 40 00 ; Subtract with carry (long,X) $0040A5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $A9.b		; 00 A9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$A2B5.w		; 69 B5 A2 ; Add #$A2B5.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
	ldy #$A900.w		; A0 00 A9 ; Load #$A900.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0E.b		; C9 0E ; Compare #$0E.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$13.b		; C9 13 ; Compare #$13.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1F		; D0 1F ; Branch if not equal to $D0, $1F [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$A3F5.w		; 69 F5 A3 ; Add #$A3F5.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0008.w		; 69 08 00 ; Add #$0008.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	inc $92.b		; E6 92 ; Increment $92.b [Reads: Direct Page] [Flags: NZ]
	inc $92.b		; E6 92 ; Increment $92.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06DBF8.l		; 22 F8 DB 06 ; Jump to subroutine long $06DBF8.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $A488.w		; 20 88 A4 ; Jump to subroutine at $A488.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda #$26.b		; A9 26 ; Load #$26.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx #$BF1D.w		; A2 1D BF ; Load #$BF1D.w into X register [Writes: X Index] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $CA10F0.l,X		; 7F F0 10 CA ; Add long $CA10F0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	dec $0FF8.w		; CE F8 0F ; Decrement $0FF8.w [Flags: NZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	lda #$1D.b		; A9 1D ; Load #$1D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FF8.w		; 8D F8 0F ; Store accumulator to $0FF8.w [Reads: Accumulator]
	ldx $0FF8.w		; AE F8 0F ; Load $0FF8.w into X register [Writes: X Index] [Flags: NZ]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF800.l,X		; 9F 00 F8 7F ; Store accumulator (long,X) $7FF800.l,X [Reads: Accumulator, X Index]
	sta $0FB4.w		; 8D B4 0F ; Store accumulator to $0FB4.w [Reads: Accumulator]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF83C.l,X		; 9F 3C F8 7F ; Store accumulator (long,X) $7FF83C.l,X [Reads: Accumulator, X Index]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF878.l,X		; 9F 78 F8 7F ; Store accumulator (long,X) $7FF878.l,X [Reads: Accumulator, X Index]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF85A.l,X		; 9F 5A F8 7F ; Store accumulator (long,X) $7FF85A.l,X [Reads: Accumulator, X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF90E.l,X		; 9F 0E F9 7F ; Store accumulator (long,X) $7FF90E.l,X [Reads: Accumulator, X Index]
	lda $0DC0.w,Y		; B9 C0 0D ; Load $0DC0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF9FE.l,X		; 9F FE F9 7F ; Store accumulator (long,X) $7FF9FE.l,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF92C.l,X		; 9F 2C F9 7F ; Store accumulator (long,X) $7FF92C.l,X [Reads: Accumulator, X Index]
	lda $0F20.w,Y		; B9 20 0F ; Load $0F20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF968.l,X		; 9F 68 F9 7F ; Store accumulator (long,X) $7FF968.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $A4F1.w		; 20 F1 A4 ; Jump to subroutine at $A4F1.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$97.b		; C9 97 ; Compare #$97.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $2A		; 90 2A ; Branch if carry clear to $90, $2A [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$95.b		; E9 95 ; Subtract #$95.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$10.b		; 29 10 ; Logical AND #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$10.b		; 49 10 ; Exclusive OR #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A4ED.w,Y		; 79 ED A4 ; Add $A4ED.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$95.b		; E9 95 ; Subtract #$95.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$10.b		; 29 10 ; Logical AND #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A4EF.w,Y		; 79 EF A4 ; Add $A4EF.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $A462.w		; 4C 62 A4 ; Jump to $A462.w [Flow: jump]
	jsr $A708.w		; 20 08 A7 ; Jump to subroutine at $A708.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	lsr $C2A5.w,X		; 5E A5 C2 ; Logical shift right $C2A5.w,X [Reads: X Index] [Flags: NCZ]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($C2.b,X)		; 01 C2 ; Logical OR ($C2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $20A5.w		; 20 A5 20 ; Jump to subroutine at $20A5.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FDA.w		; ED DA 0F ; Subtract $0FDA.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0C.b		; 85 0C ; Store accumulator to $0C.b [Reads: Accumulator]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0FD8.w		; ED D8 0F ; Subtract $0FD8.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $2F.b		; A5 2F ; Load $2F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy $0EB0.w,X		; BC B0 0E ; Load Y register $0EB0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$A801.w		; C0 01 A8 ; Compare #$A801.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
	cmp $A55A.w,Y		; D9 5A A5 ; Compare accumulator $A55A.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $D0, $27		; D0 27 ; Branch if not equal to $D0, $27 [Flow: branch]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 16
	rep #$20		; C2 20
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	lda $0C.b		; A5 0C ; Load $0C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0020.w		; C9 20 00 ; Compare #$0020.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $B0, $10		; B0 10 ; Branch if carry set to $B0, $10 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0EB0.w,X		; BC B0 0E ; Load Y register $0EB0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $04FC.w		; 0C FC 04 ; Test and set bits $04FC.w [Reads: Accumulator] [Flags: Z]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	jsr ($FF00.w,X)		; FC 00 FF ; Jump to subroutine indirect indexed ($FF00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $90		; 70 90 ; Branch if overflow set to $70, $90 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $90		; 70 90 ; Branch if overflow set to $70, $90 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	jsr $A5D8.w		; 20 D8 A5 ; Jump to subroutine at $A5D8.w [Writes: Stack Pointer] [Flow: call]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$95.b		; A9 95 ; Load #$95.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $67		; 30 67 ; Branch if minus to $30, $67 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0DC0.w,Y		; 99 C0 0D ; Store accumulator to $0DC0.w,Y [Reads: Y Index, Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A5B0.w,X		; 7D B0 A5 ; Add $A5B0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $A5B6.w,X		; 7D B6 A5 ; Add $A5B6.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A5B2.w,X		; 7D B2 A5 ; Add $A5B2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $A5B8.w,X		; 7D B8 A5 ; Add $A5B8.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $A5BC.w,X		; BD BC A5 ; Load $A5BC.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $A5BE.w,X		; BD BE A5 ; Load $A5BE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda #$48.b		; A9 48 ; Load #$48.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,Y		; 99 AA 0C ; Store accumulator to $0CAA.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	lda $7EF35A.l		; AF 5A F3 7E ; Load long $7EF35A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BE0.w,Y		; 99 E0 0B ; Store accumulator to $0BE0.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$19.b		; A9 19 ; Load #$19.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0040C8.l,X		; FF C8 40 00 ; Subtract with carry (long,X) $0040C8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0040C9.l,X		; FF C9 40 00 ; Subtract with carry (long,X) $0040C9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($C8FF.w,X)		; FC FF C8 ; Jump to subroutine indirect indexed ($C8FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000C9.l,X		; FF C9 00 00 ; Subtract with carry (long,X) $0000C9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C9.b		; 00 C9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $D60008.l,X		; FF 08 00 D6 ; Subtract with carry (long,X) $D60008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D7.b		; 00 D7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($08FF.w,X)		; FC FF 08 ; Jump to subroutine indirect indexed ($08FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($00FF.w,X)		; FC FF 00 ; Jump to subroutine indirect indexed ($00FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D7.b		; 00 D7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($00FF.w,X)		; FC FF 00 ; Jump to subroutine indirect indexed ($00FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C7.b		; 00 C7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0F10.w,X		; BD 10 0F ; Load $0F10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc #$A648.w		; 69 48 A6 ; Add #$A648.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $87F0.w		; 4C F0 87 ; Jump to $87F0.w [Flow: jump]
	jmp $BBB9.w		; 4C B9 BB ; Jump to $BBB9.w [Flow: jump]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $F8		; D0 F8 ; Branch if not equal to $D0, $F8 [Flow: branch]
	lda $0B89.w,X		; BD 89 0B ; Load $0B89.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsr $A93B.w		; 20 3B A9 ; Jump to subroutine at $A93B.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lda [$90.b]		; A7 90 ; Load accumulator (long) [$90.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda [$DC.b]		; A7 DC ; Load accumulator (long) [$DC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda [$52.b]		; A7 52 ; Load accumulator (long) [$52.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $A764.w,Y		; B9 64 A7 ; Load $A764.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora #$0B.b		; 09 0B ; Logical OR #$0B.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	jsr $92BD.w		; 20 BD 92 ; Jump to subroutine at $92BD.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A782.w,Y		; B9 82 A7 ; Load $A782.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $A78C.w,Y		; B9 8C A7 ; Load $A78C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $A78A.w,Y		; B9 8A A7 ; Load $A78A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora ($13.b)		; 12 13 ; OR accumulator with memory (indirect) ($13.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0E0D.w		; 0C 0D 0E ; Test and set bits $0E0D.w [Reads: Accumulator] [Flags: Z]
	ora $00FE02.l		; 0F 02 FE 00 ; OR accumulator with memory (long) $00FE02.l [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $6720.w,X		; FE 20 67 ; Increment memory $6720.w,X [Reads: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	and ($FF.b,X)		; 21 FF ; Logical AND ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A7D6.w,Y		; 79 D6 A7 ; Add $A7D6.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A7D8.w,Y		; 79 D8 A7 ; Add $A7D8.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	jsl $1EA820.l		; 22 20 A8 1E ; Jump to subroutine long $1EA820.l [Writes: Stack Pointer] [Flow: call]
	lda #$9D10.w		; A9 10 9D ; Load #$9D10.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$4A04.w		; 29 04 4A ; Logical AND #$4A04.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A7CE.w,Y		; B9 CE A7 ; Load $A7CE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$A0EC.w		; A9 EC A0 ; Load #$A0EC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	asl $5F22.w		; 0E 22 5F ; Arithmetic shift left $5F22.w [Flags: NCZ]
	inc $1D.b,X		; F6 1D ; Increment memory $1D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $30, $21		; 30 21 ; Branch if minus to $30, $21 [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	stz $012E.w		; 9C 2E 01 ; Store zero to $012E.w
	lda #$2228.w		; A9 28 22 ; Load #$2228.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp ($0DBB.w,X)		; 7C BB 0D ; Jump indirect indexed to ($0DBB.w,X) [Reads: X Index] [Flow: jump]
	lda #$9903.w		; A9 03 99 ; Load #$9903.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	lda #$990F.w		; A9 0F 99 ; Load #$990F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	lda #$9900.w		; A9 00 99 ; Load #$9900.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	lda #$9903.w		; A9 03 99 ; Load #$9903.w into accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	asl $186B.w		; 0E 6B 18 ; Arithmetic shift left $186B.w [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	jsr $A80A.w		; 20 0A A8 ; Jump to subroutine at $A80A.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$9D08.w		; 69 08 9D ; Add #$9D08.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2C		; D0 2C ; Branch if not equal to $D0, $2C [Flow: branch]
	jsr $A897.w		; 20 97 A8 ; Jump to subroutine at $A897.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	and #$F00F.w		; 29 0F F0 ; Logical AND #$F00F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	adc ($BA.b),Y		; 71 BA ; Add with carry ($BA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $BD4A.w		; 0D 4A BD ; Logical OR $BD4A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$2A0D.w		; E0 0D 2A ; Compare #$2A0D.w with X register [Reads: X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9254.w,Y		; B9 54 92 ; Load $9254.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $A84C.w,Y		; B9 4C A8 ; Load $A84C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $A84E.w,Y		; B9 4E A8 ; Load $A84E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$D003.w		; 29 03 D0 ; Logical AND #$D003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $22.b		; 26 22 ; Rotate left $22.b [Reads: Direct Page] [Flags: NCZ]
	adc ($BA.b),Y		; 71 BA ; Add with carry ($BA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0329.w		; 0D 29 03 ; Logical OR $0329.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $A893.w,Y		; B9 93 A8 ; Load $A893.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$A803.w		; 29 03 A8 ; Logical AND #$A803.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $A893.w,Y		; B9 93 A8 ; Load $A893.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx #$BF0E.w		; A2 0E BF ; Load #$BF0E.w into X register [Writes: X Index] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $CA05F0.l,X		; 7F F0 05 CA ; Add long $CA05F0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$9F0B.w		; A9 0B 9F ; Load #$9F0B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0FB48D.l,X		; 7F 8D B4 0F ; Add long $0FB48D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF83C.l,X		; 9F 3C F8 7F ; Store accumulator (long,X) $7FF83C.l,X [Reads: Accumulator, X Index]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$9F00.w		; 69 00 9F ; Add #$9F00.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $0D00B9.l,X		; 7F B9 00 0D ; Add long $0D00B9.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0810.w		; 69 10 08 ; Add #$0810.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $01.b		; 65 01 ; Add $01.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$2800.w		; 69 00 28 ; Add #$2800.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc #$9F00.w		; 69 00 9F ; Add #$9F00.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $9F0FA9.l,X		; 7F A9 0F 9F ; Add long $9F0FA9.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $7FF9.w		; 0E F9 7F ; Arithmetic shift left $7FF9.w [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$4040.w		; C0 40 40 ; Compare #$4040.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$8000.w		; C0 00 80 ; Compare #$8000.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$8000.w		; C0 00 80 ; Compare #$8000.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldy $0D90.w,X		; BC 90 0D ; Load Y register $0D90.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$193F.w		; 29 3F 19 ; Logical AND #$193F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $A9.b,S		; 03 A9 ; OR accumulator with stack relative $A9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $A91F.w,Y		; B9 1F A9 ; Load $A91F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	cpy #$B004.w		; C0 04 B0 ; Compare #$B004.w with Y register [Reads: Y Index] [Flags: NCZ]
	and [$AD.b]		; 27 AD ; AND accumulator with memory (long) [$AD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora $046918.l		; 0F 18 69 04 ; OR accumulator with memory (long) $046918.l [Writes: Accumulator] [Flags: NZ]
	sta $0FD8.w		; 8D D8 0F ; Store accumulator to $0FD8.w [Reads: Accumulator]
	lda $0FD9.w		; AD D9 0F ; Load $0FD9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$8D00.w		; 69 00 8D ; Add #$8D00.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $AD0F.w,Y		; D9 0F AD ; Compare accumulator $AD0F.w,Y [Reads: Y Index] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora $046918.l		; 0F 18 69 04 ; OR accumulator with memory (long) $046918.l [Writes: Accumulator] [Flags: NZ]
	sta $0FDA.w		; 8D DA 0F ; Store accumulator to $0FDA.w [Reads: Accumulator]
	lda $0FDB.w		; AD DB 0F ; Load $0FDB.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$8D00.w		; 69 00 8D ; Add #$8D00.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora $DBF822.l		; 0F 22 F8 DB ; OR accumulator with memory (long) $DBF822.l [Writes: Accumulator] [Flags: NZ]
	asl $60.b		; 06 60 ; Arithmetic shift left $60.b [Reads: Direct Page] [Flags: NCZ]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $8B20.w,X		; FE 20 8B ; Increment memory $8B20.w,X [Reads: X Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	lda $55.b		; A5 55 ; Load $55.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $41		; D0 41 ; Branch if not equal to $D0, $41 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $3B		; 90 3B ; Branch if carry clear to $90, $3B [Flow: branch]
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	lda #$9D20.w		; A9 20 9D ; Load #$9D20.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	lda #$2230.w		; A9 30 22 ; Load #$2230.w into accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	asl $A5.b		; 06 A5 ; Arithmetic shift left $A5.b [Reads: Direct Page] [Flags: NCZ]
	.db $F0, $4A		; F0 4A ; Branch if equal to $F0, $4A [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$A803.w		; 29 03 A8 ; Logical AND #$A803.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A97F.w,Y		; 79 7F A9 ; Add $A97F.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $27.b		; 85 27 ; Store accumulator to $27.b [Reads: Accumulator]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$A803.w		; 29 03 A8 ; Logical AND #$A803.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A97F.w,Y		; 79 7F A9 ; Add $A97F.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda #$8514.w		; A9 14 85 ; Load #$8514.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	jsl $07983A.l		; 22 3A 98 07 ; Jump to subroutine long $07983A.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$2232.w		; A9 32 22 ; Load #$2232.w into accumulator [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $0FA0.w		; 0D A0 0F ; Logical OR $0FA0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$1903.w		; 29 03 19 ; Logical AND #$1903.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $70, $0F		; 70 0F ; Branch if overflow set to $70, $0F [Flow: branch]
	.db $D0, $69		; D0 69 ; Branch if not equal to $D0, $69 [Flow: branch]
	lda $0DD0.w,Y		; B9 D0 0D ; Load $0DD0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$9009.w		; C9 09 90 ; Compare #$9009.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $62, $B9, $60		; 62 B9 60 ; Push effective relative address $62, $B9, $60 [Writes: Stack Pointer]
	asl $6019.w		; 0E 19 60 ; Arithmetic shift left $6019.w [Flags: NCZ]
	ora $D04029.l		; 0F 29 40 D0 ; OR accumulator with memory (long) $D04029.l [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $04.b		; E5 04 ; Subtract $04.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0020.w		; C9 20 00 ; Compare #$0020.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $33		; B0 33 ; Branch if carry set to $B0, $33 [Flow: branch]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $06.b		; E5 06 ; Subtract $06.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0020.w		; C9 20 00 ; Compare #$0020.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $24		; B0 24 ; Branch if carry set to $B0, $24 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EA0.w,Y		; 99 A0 0E ; Store accumulator to $0EA0.w,Y [Reads: Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F30.w,Y		; 99 30 0F ; Store accumulator to $0F30.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F40.w,Y		; 99 40 0F ; Store accumulator to $0F40.w,Y [Reads: Y Index, Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$32.b		; A9 32 ; Load #$32.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
.ACCU 8
	sep #$20		; E2 20
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $88		; 10 88 ; Branch if plus to $10, $88 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $ECFFF8.l,X		; FF F8 FF EC ; Subtract with carry (long,X) $ECFFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0040EC.l,X		; FF EC 40 00 ; Subtract with carry (long,X) $0040EC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $EC0008.l,X		; FF 08 00 EC ; Subtract with carry (long,X) $EC0008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0200.w		; C0 00 02 ; Compare #$0200.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $F9FF.w,Y		; F9 FF F9 ; Subtract with carry $F9FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0000EC.l,X		; FF EC 00 00 ; Subtract with carry (long,X) $0000EC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0040EC.l,X		; FF EC 40 00 ; Subtract with carry (long,X) $0040EC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $F9.b		; 02 F9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $EC0007.l,X		; FF 07 00 EC ; Subtract with carry (long,X) $EC0007.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0200.w		; C0 00 02 ; Compare #$0200.w with Y register [Reads: Y Index] [Flags: NCZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$AA4B.w		; 69 4B AA ; Add #$AA4B.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $87F0.w		; 4C F0 87 ; Jump to $87F0.w [Flow: jump]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $AE04.w		; 20 04 AE ; Jump to subroutine at $AE04.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0EF0.w,X		; BD F0 0E ; Load $0EF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $19		; D0 19 ; Branch if not equal to $D0, $19 [Flow: branch]
	stz $0EF0.w,X		; 9E F0 0E ; Store zero to $0EF0.w,X [Reads: X Index]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; [PATTERN: Memory clearing operation] 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7F6918.l		; 8F 18 69 7F ; Store accumulator (long) $7F6918.l [Reads: Accumulator]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	pea $27AA.w		; F4 AA 27 ; Push absolute address $27AA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jmp $ABA6AB.l		; 5C AB A6 AB ; Jump long to $ABA6AB.l [Flow: jump]
	dec $AB.b,X		; D6 AB ; Decrement memory $AB.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $AB.b,X		; F6 AB ; Increment memory $AB.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc [$AC.b],Y		; 77 AC ; Add with carry (long indexed) [$AC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ldy $09A9.w		; AC A9 09 ; Load $09A9.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda $0E40.w,X		; BD 40 0E ; Load $0E40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora #$80.b		; 09 80 ; Logical OR #$80.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	.db $90, $18		; 90 18 ; Branch if carry clear to $90, $18 [Flow: branch]
	lda #$90.b		; A9 90 ; Load #$90.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,X		; 9D 70 0F ; Store accumulator to $0F70.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $06		; 30 06 ; Branch if minus to $30, $06 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$03.b		; E9 03 ; Subtract #$03.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $0F70.w,X		; 5D 70 0F ; Exclusive OR accumulator with memory $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $13		; [PATTERN: Memory clearing operation] 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7F6918.l		; 8F 18 69 7F ; Store accumulator (long) $7F6918.l [Reads: Accumulator]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $14		; D0 14 ; Branch if not equal to $D0, $14 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $AB5A.w,Y		; B9 5A AB ; Load $AB5A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $AB5A.w,Y		; B9 5A AB ; Load $AB5A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0DA0.w,X		; DD A0 0D ; Compare accumulator $0DA0.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	jsr $FE6E.w		; 20 6E FE ; Jump to subroutine at $FE6E.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $AB96.w,Y		; B9 96 AB ; Load $AB96.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1D		; F0 1D ; Branch if equal to $F0, $1D [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $18		; D0 18 ; Branch if not equal to $D0, $18 [Flow: branch]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE6E.w		; 20 6E FE ; Jump to subroutine at $FE6E.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda #$13.b		; A9 13 ; Load #$13.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $D0		; 80 D0 ; Branch always to $80, $D0 [Flow: branch]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $06		; 30 06 ; Branch if minus to $30, $06 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; [PATTERN: Memory clearing operation] BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $AB46.w		; 4C 46 AB ; Jump to $AB46.w [Flow: jump]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	ldy #$BD02.w		; A0 02 BD ; Load #$BD02.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $0F		; 80 0F ; Branch always to $80, $0F [Flow: branch]
	cmp #$18.b		; C9 18 ; Compare #$18.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	ldy #$9800.w		; A0 00 98 ; Load #$9800.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $0E0E.w		; 0C 0E 0E ; Test and set bits $0E0E.w [Reads: Accumulator] [Flags: Z]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: NCZ]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: NCZ]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: NCZ]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: NCZ]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: NCZ]
	asl $0E0E.w		; 0E 0E 0E ; Arithmetic shift left $0E0E.w [Flags: NCZ]
	asl $0F0E.w		; 0E 0E 0F ; Arithmetic shift left $0F0E.w [Flags: NCZ]
	asl $080C.w		; 0E 0C 08 ; Arithmetic shift left $080C.w [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $06		; 30 06 ; Branch if minus to $30, $06 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; [PATTERN: Memory clearing operation] BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $16		; D0 16 ; Branch if not equal to $D0, $16 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$50.b		; A9 50 ; Load #$50.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp $AB46.w		; 4C 46 AB ; Jump to $AB46.w [Flow: jump]
	cmp #$E0.b		; C9 E0 ; Compare #$E0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $AC57.w,Y		; B9 57 AC ; Load $AC57.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $AB46.w		; 4C 46 AB ; Jump to $AB46.w [Flow: jump]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $ACD6.w,Y		; B9 D6 AC ; Load $ACD6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($F8FF.w,X)		; FC FF F8 ; Jump to subroutine indirect indexed ($F8FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $000064.l,X		; FF 64 00 00 ; Subtract with carry (long,X) $000064.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $610000.l,X		; FF 00 00 61 ; Subtract with carry (long,X) $610000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $740010.l,X		; FF 10 00 74 ; Subtract with carry (long,X) $740010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F9FF.w,X)		; FC FF F9 ; Jump to subroutine indirect indexed ($F9FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $000064.l,X		; FF 64 00 00 ; Subtract with carry (long,X) $000064.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $610001.l,X		; FF 01 00 61 ; Subtract with carry (long,X) $610001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $650010.l,X		; FF 10 00 65 ; Subtract with carry (long,X) $650010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $65.b		; 00 65 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F8FF.w,X)		; FC FF F8 ; Jump to subroutine indirect indexed ($F8FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $000048.l,X		; FF 48 00 00 ; Subtract with carry (long,X) $000048.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000049.l,X		; FF 49 00 00 ; Subtract with carry (long,X) $000049.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $4B0008.l,X		; FF 08 00 4B ; Subtract with carry (long,X) $4B0008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $680008.l,X		; FF 08 00 68 ; Subtract with carry (long,X) $680008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $69.b		; 00 69 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004064.l,X		; FF 64 40 00 ; Subtract with carry (long,X) $004064.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $620001.l,X		; FF 01 00 62 ; Subtract with carry (long,X) $620001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc ($40.b,X)		; 61 40 ; Add with carry ($40.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $10FF.w,X		; FD FF 10 ; Subtract with carry $10FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $65.b		; 00 65 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $65.b		; 00 65 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $F800.w		; 0C 00 F8 ; Test and set bits $F800.w [Reads: Accumulator] [Flags: Z]
	sbc $004064.l,X		; FF 64 40 00 ; Subtract with carry (long,X) $004064.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $620000.l,X		; FF 00 00 62 ; Subtract with carry (long,X) $620000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($40.b,X)		; 61 40 ; Add with carry ($40.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $10FF.w,X		; FD FF 10 ; Subtract with carry $10FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F8FF.w,X)		; FC FF F8 ; Jump to subroutine indirect indexed ($F8FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $004049.l,X		; FF 49 40 00 ; Subtract with carry (long,X) $004049.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004048.l,X		; FF 48 40 00 ; Subtract with carry (long,X) $004048.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $4C0008.l,X		; FF 08 00 4C ; Subtract with carry (long,X) $4C0008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FF84.w		; 20 84 FF ; Jump to subroutine at $FF84.w [Writes: Stack Pointer] [Flow: call]
	jsr $AE4E.w		; 20 4E AE ; Jump to subroutine at $AE4E.w [Writes: Stack Pointer] [Flow: call]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc #$ACEC.w		; 69 EC AC ; Add #$ACEC.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0004.w		; 69 04 00 ; Add #$0004.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	inc $92.b		; E6 92 ; Increment $92.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0004.w		; E9 04 00 ; Subtract #$0004.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	dec $92.b		; C6 92 ; Decrement $92.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	lda #$12.b		; A9 12 ; Load #$12.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06DC5C.l		; 22 5C DC 06 ; Jump to subroutine long $06DC5C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: NCZ]
	lsr $46.b		; 46 46 ; Logical shift right $46.b [Reads: Direct Page] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C90D.w		; C0 0D C9 ; Compare #$C90D.w with Y register [Reads: Y Index] [Flags: NCZ]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $B0BD.w		; 4E BD B0 ; Logical shift right $B0BD.w [Flags: NCZ]
	ora $0685.w		; 0D 85 06 ; Logical OR $0685.w with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $07.b		; 64 07 ; Store zero to $07.b
	ldy #$DA00.w		; A0 00 DA ; Load #$DA00.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$000C.w		; E9 0C 00 ; Subtract #$000C.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $AE46.w,X		; BD 46 AE ; Load $AE46.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $AE4A.w,X		; BD 4A AE ; Load $AE4A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0B89.w,X		; BD 89 0B ; Load $0B89.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsr $AFE4.w		; 20 E4 AF ; Jump to subroutine at $AFE4.w [Writes: Stack Pointer] [Flow: call]
	lda $0DD0.w,X		; [PATTERN: Memory clearing operation] BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	stz $037B.w		; 9C 7B 03 ; Store zero to $037B.w
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $56		; F0 56 ; Branch if equal to $F0, $56 [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $23.b		; 85 23 ; Store accumulator to $23.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0F70.w,X		; FD 70 0F ; Subtract with carry $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $21.b		; 85 21 ; Store accumulator to $21.b [Reads: Accumulator]
	lda #$01.b		; [PATTERN: Memory clearing operation] A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	sta $037B.w		; 8D 7B 03 ; Store accumulator to $037B.w [Reads: Accumulator]
	stz $46.b		; 64 46 ; Store zero to $46.b
	stz $28.b		; 64 28 ; Store zero to $28.b
	stz $27.b		; [PATTERN: Memory clearing operation] 64 27 ; Store zero to $27.b
	stz $30.b		; 64 30 ; Store zero to $30.b
	stz $31.b		; 64 31 ; Store zero to $31.b
.ACCU 16
	rep #$20		; C2 20
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E8.b		; E5 E8 ; Subtract $E8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0010.w		; [PATTERN: Memory clearing operation] E9 10 00 ; Subtract #$0010.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $90, $15		; 90 15 ; Branch if carry clear to $90, $15 [Flow: branch]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	stz $037B.w		; 9C 7B 03 ; Store zero to $037B.w
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0BFFA8.l		; 22 A8 FF 0B ; Jump to subroutine long $0BFFA8.l [Writes: Stack Pointer] [Flow: call]
	jsl $07F13C.l		; 22 3C F1 07 ; Jump to subroutine long $07F13C.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	lda $82AF59.l		; AF 59 AF 82 ; Load long $82AF59.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $0F70BD.l		; AF BD 70 0F ; Load long $0F70BD.l into accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $06		; 30 06 ; Branch if minus to $30, $06 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$03.b		; E9 03 ; Subtract #$03.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $0F70.w,X		; 5D 70 0F ; Exclusive OR accumulator with memory $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	lda $0F70.w,X		; [PATTERN: Memory clearing operation] BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	ldy #$2900.w		; A0 00 29 ; Load #$2900.w into Y register [Writes: Y Index] [Flags: NZ]
	jsr $01D0.w		; 20 D0 01 ; Jump to subroutine at $01D0.w [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	lda #$2A.b		; A9 2A ; Load #$2A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $0F70.w,X		; 5D 70 0F ; Exclusive OR accumulator with memory $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($00FF.w,X)		; FC FF 00 ; Jump to subroutine indirect indexed ($00FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $A6.b		; 00 A6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BA0010.l,X		; FF 10 00 BA ; Subtract with carry (long,X) $BA0010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $AB0000.l,X		; FF 00 00 AB ; Subtract with carry (long,X) $AB0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AF.b		; 00 AF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BF0010.l,X		; FF 10 00 BF ; Subtract with carry (long,X) $BF0010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AD.b		; 00 AD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$AFA4.w		; 69 A4 AF ; Add #$AFA4.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
	jsl $1DD1AF.l		; 22 AF D1 1D ; Jump to subroutine long $1DD1AF.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1F		; D0 1F ; Branch if not equal to $D0, $1F [Flow: branch]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1A		; F0 1A ; Branch if equal to $F0, $1A [Flow: branch]
	stz $0E90.w,X		; [PATTERN: Memory clearing operation] 9E 90 0E ; Store zero to $0E90.w,X [Reads: X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsr $B1C5.w		; 20 C5 B1 ; Jump to subroutine at $B1C5.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	eor $B0.b,X		; 55 B0 ; Exclusive OR accumulator with memory $B0.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $B0D6B0.l		; AF B0 D6 B0 ; Load long $B0D6B0.l into accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $BD,$B1		; 44 B1 BD ; Move block positive $BD,$B1 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $090948.l		; 0F 48 09 09 ; OR accumulator with memory (long) $090948.l [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	lda $0E40.w,X		; BD 40 0E ; Load $0E40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$80.b		; 09 80 ; Logical OR #$80.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,X		; 9D 40 0E ; Store accumulator to $0E40.w,X [Reads: Accumulator, X Index]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	.db $90, $2F		; 90 2F ; Branch if carry clear to $90, $2F [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	asl $0E40.w,X		; 1E 40 0E ; Arithmetic shift left $0E40.w,X [Reads: X Index] [Flags: NCZ]
	lsr $0E40.w,X		; 5E 40 0E ; Logical shift right $0E40.w,X [Reads: X Index] [Flags: NCZ]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B09F.w,Y		; B9 9F B0 ; Load $B09F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $2A		; F0 2A ; Branch if equal to $F0, $2A [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B0D4.w,Y		; B9 D4 B0 ; Load $B0D4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B142.w,Y		; B9 42 B1 ; Load $B142.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsr $FF28.w		; 20 28 FF ; Jump to subroutine at $FF28.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $06		; 30 06 ; Branch if minus to $30, $06 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $0F70.w,X		; 5D 70 0F ; Exclusive OR accumulator with memory $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; [PATTERN: Memory clearing operation] 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0DB0.w,X		; 9E B0 0D ; Store zero to $0DB0.w,X [Reads: X Index]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $21		; D0 21 ; Branch if not equal to $D0, $21 [Flow: branch]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$60.b		; 09 60 ; Logical OR #$60.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	asl $0F50.w,X		; 1E 50 0F ; Arithmetic shift left $0F50.w,X [Reads: X Index] [Flags: NCZ]
	asl $0F50.w,X		; 1E 50 0F ; Arithmetic shift left $0F50.w,X [Reads: X Index] [Flags: NCZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $0F50.w,X		; 7E 50 0F ; Rotate right $0F50.w,X [Reads: X Index] [Flags: NCZ]
	lsr $0F50.w,X		; 5E 50 0F ; Logical shift right $0F50.w,X [Reads: X Index] [Flags: NCZ]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $43		; D0 43 ; Branch if not equal to $D0, $43 [Flow: branch]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0E.b		; 29 0E ; Logical AND #$0E.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0E70.w,X		; 1D 70 0E ; OR accumulator with memory $0E70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $27		; D0 27 ; Branch if not equal to $D0, $27 [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	inc $0ED0.w,X		; FE D0 0E ; Increment memory $0ED0.w,X [Reads: X Index] [Flags: NZ]
	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0EB0.w,X		; DD B0 0E ; Compare accumulator $0EB0.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $19		; D0 19 ; Branch if not equal to $D0, $19 [Flow: branch]
	stz $0ED0.w,X		; 9E D0 0E ; Store zero to $0ED0.w,X [Reads: X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$40.b		; 69 40 ; Add #$40.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0E10.w,X		; 9D 10 0E ; Store accumulator to $0E10.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$2900.w		; A0 00 29 ; Load #$2900.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	ora ($C8.b,X)		; 01 C8 ; Logical OR ($C8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $B0, $07		; B0 07 ; Branch if carry set to $B0, $07 [Flow: branch]
	lda $0FC6.w		; AD C6 0F ; Load $0FC6.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $41		; B0 41 ; Branch if carry set to $B0, $41 [Flow: branch]
	lda $0F10.w,X		; BD 10 0F ; Load $0F10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $2D		; F0 2D ; Branch if equal to $F0, $2D [Flow: branch]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $6B		; B0 6B ; Branch if carry set to $B0, $6B [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor $B1C1.w,Y		; 59 C1 B1 ; Exclusive OR accumulator with memory $B1C1.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6D.b		; 00 6D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$04.b		; E9 04 ; Subtract #$04.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$B214.w		; 69 14 B2 ; Add #$B214.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $87F0.w		; 4C F0 87 ; Jump to $87F0.w [Flow: jump]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda $0E10.w,X		; BD 10 0E ; Load $0E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	jsr $B3A3.w		; 20 A3 B3 ; Jump to subroutine at $B3A3.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	lda [$B2.b]		; A7 B2 ; Load accumulator (long) [$B2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $60B3.w		; 0E B3 60 ; Arithmetic shift left $60B3.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00F4.w		; 0C F4 00 ; Test and set bits $00F4.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $BDF4.w		; 0C F4 BD ; Test and set bits $BDF4.w [Reads: Accumulator] [Flags: Z]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	and #$30.b		; 29 30 ; Logical AND #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0ED0.w,X		; 7D D0 0E ; Add $0ED0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B297.w,Y		; B9 97 B2 ; Load $B297.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $B29F.w,Y		; B9 9F B2 ; Load $B29F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; [PATTERN: Memory clearing operation] 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $0ED0.w,X		; BC D0 0E ; Load Y register $0ED0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $D0, $01		; D0 01 ; Branch if not equal to $D0, $01 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,X		; 9D AA 0C ; Store accumulator to $0CAA.w,X [Reads: Accumulator, X Index]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; [PATTERN: Memory clearing operation] 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	stz $0CAA.w,X		; 9E AA 0C ; Store zero to $0CAA.w,X [Reads: X Index]
	lda $0F10.w,X		; BD 10 0F ; Load $0F10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	stz $0DA0.w,X		; 9E A0 0D ; Store zero to $0DA0.w,X [Reads: X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $35		; 10 35 ; Branch if plus to $10, $35 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $0D50.w,X		; 7E 50 0D ; Rotate right $0D50.w,X [Reads: X Index] [Flags: NCZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$FF.b		; C9 FF ; Compare #$FF.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $0D40.w,X		; 7E 40 0D ; Rotate right $0D40.w,X [Reads: X Index] [Flags: NCZ]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$FF.b		; C9 FF ; Compare #$FF.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	lda $0F10.w,X		; BD 10 0F ; Load $0F10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0D		; B0 0D ; Branch if carry set to $B0, $0D [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B3A1.w,Y		; B9 A1 B3 ; Load $B3A1.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $B39F.w,Y		; 19 9F B3 ; OR accumulator with memory $B39F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0E10.w,X		; 1D 10 0E ; OR accumulator with memory $0E10.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $56		; D0 56 ; Branch if not equal to $D0, $56 [Flow: branch]
	lda $EE.b		; A5 EE ; Load $EE.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $0F20.w,X		; DD 20 0F ; Compare accumulator $0F20.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $4F		; D0 4F ; Branch if not equal to $D0, $4F [Flow: branch]
	lda $0044.w		; AD 44 00 ; Load $0044.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $48		; F0 48 ; Branch if equal to $F0, $48 [Flow: branch]
	lda $0301.w		; AD 01 03 ; Load $0301.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$0A.b		; 29 0A ; Logical AND #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $41		; F0 41 ; Branch if equal to $F0, $41 [Flow: branch]
	jsl $06F57E.l		; 22 7E F5 06 ; Jump to subroutine long $06F57E.l [Writes: Stack Pointer] [Flow: call]
	jsr $B405.w		; 20 05 B4 ; Jump to subroutine at $B405.w [Writes: Stack Pointer] [Flow: call]
	jsl $0683E6.l		; 22 E6 83 06 ; Jump to subroutine long $0683E6.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $34		; 90 34 ; Branch if carry clear to $90, $34 [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E10.w,X		; 9D 10 0E ; Store accumulator to $0E10.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0ED0.w,X		; 9D D0 0E ; Store accumulator to $0ED0.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
	stz $0EB0.w,X		; 9E B0 0E ; Store zero to $0EB0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$10.b		; E9 10 ; Subtract #$10.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0A.b		; 85 0A ; Store accumulator to $0A.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$10.b		; E9 10 ; Subtract #$10.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0B.b		; 85 0B ; Store accumulator to $0B.b [Reads: Accumulator]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$0B.b		; 89 0B ; Test bits #$0B.b with accumulator [Reads: Accumulator] [Flags: Z]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsr $B840.w		; 20 40 B8 ; Jump to subroutine at $B840.w [Writes: Stack Pointer] [Flow: call]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$60.b		; C9 60 ; Compare #$60.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $B6E9.w		; 20 E9 B6 ; Jump to subroutine at $B6E9.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B0C.w		; 8D 0C 0B ; Store accumulator to $0B0C.w [Reads: Accumulator]
	lda $0EF0.w,X		; BD F0 0E ; Load $0EF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	jsr $B5EE.w		; 20 EE B5 ; Jump to subroutine at $B5EE.w [Writes: Stack Pointer] [Flow: call]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $16		; D0 16 ; Branch if not equal to $D0, $16 [Flow: branch]
	inc $0ED0.w,X		; FE D0 0E ; Increment memory $0ED0.w,X [Reads: X Index] [Flags: NZ]
	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0ED0.w,X		; 9E D0 0E ; Store zero to $0ED0.w,X [Reads: X Index]
	ldy $0ED0.w,X		; BC D0 0E ; Load Y register $0ED0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $B42A.w,Y		; B9 2A B4 ; Load $B42A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	ldy $0D80.w,X		; BC 80 0D ; Load Y register $0D80.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$D005.w		; C0 05 D0 ; Compare #$D005.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	.db $80, $0E		; 80 0E ; Branch always to $80, $0E [Flow: branch]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $92BD.w		; 20 BD 92 ; Jump to subroutine at $92BD.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	sta ($B5.b,S),Y		; 93 B5 ; Store accumulator (stack relative indirect indexed) ($B5.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $3D.b,X		; B5 3D ; Load $3D.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $CA.b,Y		; B6 CA ; Load X register $CA.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ldy $EF.b,X		; B4 EF ; Load Y register $EF.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ldy $32.b,X		; B4 32 ; Load Y register $32.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	lda $A9.b,X		; B5 A9 ; Load $A9.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$E0.b		; C9 E0 ; Compare #$E0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $15		; 90 15 ; Branch if carry clear to $90, $15 [Flow: branch]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $34		; D0 34 ; Branch if not equal to $D0, $34 [Flow: branch]
	lda #$90.b		; A9 90 ; Load #$90.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $0F70.w,X		; 5D 70 0F ; Exclusive OR accumulator with memory $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1D		; 10 1D ; Branch if plus to $10, $1D [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	jsl $059B38.l		; 22 38 9B 05 ; Jump to subroutine long $059B38.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $5B		; D0 5B ; Branch if not equal to $D0, $5B [Flow: branch]
	stz $0E60.w,X		; 9E 60 0E ; Store zero to $0E60.w,X [Reads: X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $4B		; D0 4B ; Branch if not equal to $D0, $4B [Flow: branch]
	lda #$28.b		; A9 28 ; Load #$28.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx #$B91D.w		; A2 1D B9 ; Load #$B91D.w into X register [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora $0230.w		; 0D 30 02 ; Logical OR $0230.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx #$BF0E.w		; A2 0E BF ; Load #$BF0E.w into X register [Writes: X Index] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $A930D0.l,X		; 7F D0 30 A9 ; Add long $A930D0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $9F.b,X		; 15 9F ; OR accumulator with memory $9F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $0FB48D.l,X		; 7F 8D B4 0F ; Add long $0FB48D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF83C.l,X		; 9F 3C F8 7F ; Store accumulator (long,X) $7FF83C.l,X [Reads: Accumulator, X Index]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF878.l,X		; 9F 78 F8 7F ; Store accumulator (long,X) $7FF878.l,X [Reads: Accumulator, X Index]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$18.b		; 69 18 ; Add #$18.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF85A.l,X		; 9F 5A F8 7F ; Store accumulator (long,X) $7FF85A.l,X [Reads: Accumulator, X Index]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF90E.l,X		; 9F 0E F9 7F ; Store accumulator (long,X) $7FF90E.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $C7		; 10 C7 ; Branch if plus to $10, $C7 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0EB0.w,X		; DD B0 0E ; Compare accumulator $0EB0.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	inc $0D50.w,X		; FE 50 0D ; Increment memory $0D50.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	dec $0D50.w,X		; DE 50 0D ; Decrement memory $0D50.w,X [Reads: X Index] [Flags: NZ]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0DE0.w,X		; DD E0 0D ; Compare accumulator $0DE0.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	inc $0D40.w,X		; FE 40 0D ; Increment memory $0D40.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	dec $0D40.w,X		; DE 40 0D ; Decrement memory $0D40.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $4E		; D0 4E ; Branch if not equal to $D0, $4E [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	jsl $09AF32.l		; 22 32 AF 09 ; Jump to subroutine long $09AF32.l [Writes: Stack Pointer] [Flow: call]
	.db $B0, $18		; B0 18 ; Branch if carry set to $B0, $18 [Flow: branch]
	inc $0B0B.w		; EE 0B 0B ; Increment $0B0B.w [Flags: NZ]
	lda $0B0B.w		; AD 0B 0B ; Load $0B0B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	stz $0B0B.w		; 9C 0B 0B ; Store zero to $0B0B.w
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$B0.b		; A9 B0 ; Load #$B0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$32.b		; A9 32 ; Load #$32.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$30.b		; 69 30 ; Add #$30.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	jsl $06EA1A.l		; 22 1A EA 06 ; Jump to subroutine long $06EA1A.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	inc $0D50.w,X		; FE 50 0D ; Increment memory $0D50.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	dec $0D50.w,X		; DE 50 0D ; Decrement memory $0D50.w,X [Reads: X Index] [Flags: NZ]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	inc $0D40.w,X		; FE 40 0D ; Increment memory $0D40.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	dec $0D40.w,X		; DE 40 0D ; Decrement memory $0D40.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B0C.w		; 8D 0C 0B ; Store accumulator to $0B0C.w [Reads: Accumulator]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $08		; 90 08 ; Branch if carry clear to $90, $08 [Flow: branch]
	cmp #$60.b		; C9 60 ; Compare #$60.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0A		; B0 0A ; Branch if carry set to $B0, $0A [Flow: branch]
	inc $0B0A.w		; EE 0A 0B ; Increment $0B0A.w [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $0B0A.w		; CE 0A 0B ; Decrement $0B0A.w [Flags: NZ]
	.db $30, $12		; 30 12 ; Branch if minus to $30, $12 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	lda #$26.b		; A9 26 ; Load #$26.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $06		; 80 06 ; Branch always to $80, $06 [Flow: branch]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0B0A.w		; 9C 0A 0B ; Store zero to $0B0A.w
	dec $0D80.w,X		; DE 80 0D ; Decrement memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$70.b		; A9 70 ; Load #$70.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($40.b,X)		; 01 40 ; Logical OR ($40.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($C0.b,X)		; 01 C0 ; Logical OR ($C0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($98.b,X)		; 01 98 ; Logical OR ($98.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($14.b,X)		; 01 14 ; Logical OR ($14.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	trb $0C.b		; 14 0C ; Test and reset bits $0C.b [Reads: Accumulator] [Flags: Z]
	tsb $0C0C.w		; 0C 0C 0C ; Test and set bits $0C0C.w [Reads: Accumulator] [Flags: Z]
	tsb $FF00.w		; 0C 00 FF ; Test and set bits $FF00.w [Reads: Accumulator] [Flags: Z]
	inc $FCFD.w,X		; FE FD FC ; Increment memory $FCFD.w,X [Reads: X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($FEFD.w,X)		; FC FD FE ; Jump to subroutine indirect indexed ($FEFD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FEFF00.l,X		; FF 00 FF FE ; Subtract with carry (long,X) $FEFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FBFC.w,X		; FD FC FB ; Subtract with carry $FBFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($FEFD.w,X)		; FC FD FE ; Jump to subroutine indirect indexed ($FEFD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FEFF00.l,X		; FF 00 FF FE ; Subtract with carry (long,X) $FEFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FBFC.w,X		; FD FC FB ; Subtract with carry $FBFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($FEFD.w,X)		; FC FD FE ; Jump to subroutine indirect indexed ($FEFD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FEFF00.l,X		; FF 00 FF FE ; Subtract with carry (long,X) $FEFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FBFC.w,X		; FD FC FB ; Subtract with carry $FBFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($FEFD.w,X)		; FC FD FE ; Jump to subroutine indirect indexed ($FEFD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $0B08AD.l,X		; FF AD 08 0B ; Subtract with carry (long,X) $0B08AD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B0C.w		; 6D 0C 0B ; Add $0B0C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0B08.w		; 8D 08 0B ; Store accumulator to $0B08.w [Reads: Accumulator]
	lda $0B09.w		; AD 09 0B ; Load $0B09.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0B09.w		; 8D 09 0B ; Store accumulator to $0B09.w [Reads: Accumulator]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0D.b		; C9 0D ; Compare #$0D.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	inc $0DA0.w,X		; FE A0 0D ; Increment memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	lda $0DA0.w,X		; [PATTERN: Memory clearing operation] BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0D.b		; C9 0D ; Compare #$0D.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DA0.w,X		; 9E A0 0D ; Store zero to $0DA0.w,X [Reads: X Index]
	stz $0FB5.w		; 9C B5 0F ; Store zero to $0FB5.w
	lda $0FB5.w		; AD B5 0F ; Load $0FB5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $0B08.w		; AD 08 0B ; Load $0B08.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $B674.w,Y		; 79 74 B6 ; Add $B674.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $B68E.w,Y		; 59 8E B6 ; Exclusive OR accumulator with memory $B68E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lda $0B0A.w		; AD 0A 0B ; Load $0B0A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $B6A8.w,Y		; 79 A8 B6 ; Add $B6A8.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	lda $0FB5.w		; AD B5 0F ; Load $0FB5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $B6B5.w,Y		; 79 B5 B6 ; Add $B6B5.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $B6B5.w,Y		; 79 B5 B6 ; Add $B6B5.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $04E800.l,X		; BF 00 E8 04 ; Load long $04E800.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0080.w		; 69 80 00 ; Add #$0080.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $04E800.l,X		; BF 00 E8 04 ; Load long $04E800.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $05.b		; A4 05 ; Load $05.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $8A85.w		; 20 85 8A ; Jump to subroutine at $8A85.w [Writes: Stack Pointer] [Flow: call]
	asl $4216.w		; 0E 16 42 ; Arithmetic shift left $4216.w [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lsr $01.b		; 46 01 ; Logical shift right $01.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	stz $0A.b		; 64 0A ; Store zero to $0A.b
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	dec $0A.b		; C6 0A ; Decrement $0A.b [Reads: Direct Page] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D10.w,X		; 7D 10 0D ; Add $0D10.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $0FB5.w		; AC B5 0F ; Load $0FB5.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $0B10.w,Y		; 99 10 0B ; Store accumulator to $0B10.w,Y [Reads: Y Index, Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $0A.b		; 65 0A ; Add $0A.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0B20.w,Y		; 99 20 0B ; Store accumulator to $0B20.w,Y [Reads: Y Index, Accumulator]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $07.b		; A4 07 ; Load $07.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $8A85.w		; 20 85 8A ; Jump to subroutine at $8A85.w [Writes: Stack Pointer] [Flow: call]
	asl $4216.w		; 0E 16 42 ; Arithmetic shift left $4216.w [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lsr $03.b		; 46 03 ; Logical shift right $03.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	stz $0A.b		; 64 0A ; Store zero to $0A.b
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	dec $0A.b		; C6 0A ; Decrement $0A.b [Reads: Direct Page] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D00.w,X		; 7D 00 0D ; Add $0D00.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$10.b		; E9 10 ; Subtract #$10.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ldy $0FB5.w		; AC B5 0F ; Load $0FB5.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $0B30.w,Y		; 99 30 0B ; Store accumulator to $0B30.w,Y [Reads: Y Index, Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	adc $0A.b		; 65 0A ; Add $0A.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0B40.w,Y		; 99 40 0B ; Store accumulator to $0B40.w,Y [Reads: Y Index, Accumulator]
	inc $0FB5.w		; EE B5 0F ; Increment $0FB5.w [Flags: NZ]
	lda $0FB5.w		; AD B5 0F ; Load $0FB5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0D.b		; C9 0D ; Compare #$0D.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $B724.w		; 4C 24 B7 ; Jump to $B724.w [Flow: jump]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $80FFFC.l,X		; FF FC FF 80 ; Subtract with carry (long,X) $80FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004080.l,X		; FF 80 40 00 ; Subtract with carry (long,X) $004080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A0000C.l,X		; FF 0C 00 A0 ; Subtract with carry (long,X) $A0000C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $C2.b		; 02 C2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $18A9.w		; 20 A9 18 ; Jump to subroutine at $18A9.w [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	lda ($90.b),Y		; B1 90 ; Load accumulator ($90.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy #$12.b		; C0 12 ; Compare #$12.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $90, $F1		; 90 F1 ; Branch if carry clear to $90, $F1 [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	ldy #$11.b		; A0 11 ; Load #$11.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	ldy #$13.b		; A0 13 ; Load #$13.b into Y register [Writes: Y Index] [Flags: NZ]
	lda ($90.b),Y		; B1 90 ; Load accumulator ($90.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $27		; F0 27 ; Branch if equal to $F0, $27 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0004.w		; 69 04 00 ; Add #$0004.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	inc $92.b		; E6 92 ; Increment $92.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$A0.b		; C9 A0 ; Compare #$A0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $11		; B0 11 ; Branch if carry set to $B0, $11 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and #$FE.b		; 29 FE ; Logical AND #$FE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $1DD1A8.l		; 22 A8 D1 1D ; Jump to subroutine long $1DD1A8.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $04EBE5.l		; 22 E5 EB 04 ; Jump to subroutine long $04EBE5.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $B6E9.w		; 20 E9 B6 ; Jump to subroutine at $B6E9.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0B89.w,X		; BD 89 0B ; Load $0B89.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $B8BC.w,Y		; B9 BC B8 ; Load $B8BC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $3A		; F0 3A ; Branch if equal to $F0, $3A [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $0C4A.w,Y		; B9 4A 0C ; Load $0C4A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $26		; F0 26 ; Branch if equal to $F0, $26 [Flow: branch]
	lda $0C04.w,Y		; B9 04 0C ; Load $0C04.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0C18.w,Y		; B9 18 0C ; Load $0C18.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $0BFA.w,Y		; B9 FA 0B ; Load $0BFA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0C0E.w,Y		; B9 0E 0C ; Load $0C0E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	stz $0DA0.w,X		; 9E A0 0D ; Store zero to $0DA0.w,X [Reads: X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $19		; D0 19 ; Branch if not equal to $D0, $19 [Flow: branch]
	lda $0B0F.w,X		; BD 0F 0B ; Load $0B0F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0B1F.w,X		; BD 1F 0B ; Load $0B1F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $0B2F.w,X		; BD 2F 0B ; Load $0B2F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0B3F.w,X		; BD 3F 0B ; Load $0B3F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $50		; D0 50 ; Branch if not equal to $D0, $50 [Flow: branch]
	lda $0B0F.w,X		; BD 0F 0B ; Load $0B0F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0B1F.w,X		; BD 1F 0B ; Load $0B1F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0B2F.w,X		; BD 2F 0B ; Load $0B2F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0B3F.w,X		; BD 3F 0B ; Load $0B3F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0B0F.w,X		; FD 0F 0B ; Subtract with carry $0B0F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $1E		; B0 1E ; Branch if carry set to $B0, $1E [Flow: branch]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0B2F.w,X		; FD 2F 0B ; Subtract with carry $0B2F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $10		; B0 10 ; Branch if carry set to $B0, $10 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$0D.b		; A9 0D ; Load #$0D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $BB20.w		; 20 20 BB ; Jump to subroutine at $BB20.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	cpy $12B9.w		; CC B9 12 ; Compare $12B9.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $B9C4.w,Y		; B9 C4 B9 ; Load $B9C4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	ldy $0D90.w,X		; BC 90 0D ; Load Y register $0D90.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $B9C0.w,Y		; D9 C0 B9 ; Compare accumulator $B9C0.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	inc $0DE0.w,X		; FE E0 0D ; Increment memory $0DE0.w,X [Reads: X Index] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	dec $0DE0.w,X		; DE E0 0D ; Decrement memory $0DE0.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$30.b		; 69 30 ; Add #$30.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	ora #$02.b		; 09 02 ; Logical OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $BC.b		; 05 BC ; Logical OR $BC.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$0D.b		; E0 0D ; Compare #$0D.b with X register [Reads: X Index] [Flags: NCZ]
	lda $BA02.w,Y		; B9 02 BA ; Load $BA02.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $BA00.w,Y		; B9 00 BA ; Load $BA00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0D90.w,X		; DD 90 0D ; Compare accumulator $0D90.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $0DA0.w,X		; DE A0 0D ; Decrement memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	lda #$0E.b		; A9 0E ; Load #$0E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0D90.w,X		; 1D 90 0D ; OR accumulator with memory $0D90.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $BA0A.w,Y		; B9 0A BA ; Load $BA0A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000080.l,X		; FF 80 00 00 ; Subtract with carry (long,X) $000080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $00, $00		; 82 00 00 ; Branch always long to $82, $00, $00 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000082.l,X		; FF 82 00 00 ; Subtract with carry (long,X) $000082.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000084.l,X		; FF 84 00 00 ; Subtract with carry (long,X) $000084.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000084.l,X		; FF 84 00 00 ; Subtract with carry (long,X) $000084.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004088.l,X		; FF 88 40 00 ; Subtract with carry (long,X) $004088.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $40, $00		; 82 40 00 ; Branch always long to $82, $40, $00 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $40.b		; 86 40 ; Store X register to $40.b [Reads: X Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$40.b		; A2 40 ; Load #$40.b into X register [Writes: X Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $004082.l,X		; FF 82 40 00 ; Subtract with carry (long,X) $004082.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$BA60.w		; 69 60 BA ; Add #$BA60.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
	lda $0F00.w,X		; BD 00 0F ; Load $0F00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$80.b		; 49 80 ; Exclusive OR #$80.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx #$0E.b		; A2 0E ; Load #$0E.b into X register [Writes: X Index] [Flags: NZ]
	lda $7FF800.l,X		; BF 00 F8 7F ; Load long $7FF800.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF800.l,X		; 9F 00 F8 7F ; Store accumulator (long,X) $7FF800.l,X [Reads: Accumulator, X Index]
	sta $0FB4.w		; 8D B4 0F ; Store accumulator to $0FB4.w [Reads: Accumulator]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF83C.l,X		; 9F 3C F8 7F ; Store accumulator (long,X) $7FF83C.l,X [Reads: Accumulator, X Index]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF878.l,X		; 9F 78 F8 7F ; Store accumulator (long,X) $7FF878.l,X [Reads: Accumulator, X Index]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF85A.l,X		; 9F 5A F8 7F ; Store accumulator (long,X) $7FF85A.l,X [Reads: Accumulator, X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF90E.l,X		; 9F 0E F9 7F ; Store accumulator (long,X) $7FF90E.l,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF92C.l,X		; 9F 2C F9 7F ; Store accumulator (long,X) $7FF92C.l,X [Reads: Accumulator, X Index]
	lda $0F20.w,Y		; B9 20 0F ; Load $0F20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF968.l,X		; 9F 68 F9 7F ; Store accumulator (long,X) $7FF968.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsr $BCCA.w		; 20 CA BC ; Jump to subroutine at $BCCA.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE7F.w		; 20 7F FE ; Jump to subroutine at $FE7F.w [Writes: Stack Pointer] [Flow: call]
	lda $0EF0.w,X		; BD F0 0E ; Load $0EF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $66		; D0 66 ; Branch if not equal to $D0, $66 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor $BC01BC.l		; 4F BC 01 BC ; Exclusive OR accumulator with memory (long) $BC01BC.l [Writes: Accumulator] [Flags: NZ]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	ldy #$06.b		; A0 06 ; Load #$06.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $01E7A9.l		; 22 A9 E7 01 ; Jump to subroutine long $01E7A9.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $BC5C.w		; 20 5C BC ; Jump to subroutine at $BC5C.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $1A		; B0 1A ; Branch if carry set to $B0, $1A [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0F70.w,X		; FD 70 0F ; Subtract with carry $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0FDA.w		; 8D DA 0F ; Store accumulator to $0FDA.w [Reads: Accumulator]
	lda $0FDB.w		; AD DB 0F ; Load $0FDB.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FDB.w		; 8D DB 0F ; Store accumulator to $0FDB.w [Reads: Accumulator]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,X		; 9D D0 0D ; Store accumulator to $0DD0.w,X [Reads: Accumulator, X Index]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$EC.b		; A9 EC ; Load #$EC.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E20.w,X		; 9D 20 0E ; Store accumulator to $0E20.w,X [Reads: Accumulator, X Index]
	stz $0EF0.w,X		; 9E F0 0E ; Store zero to $0EF0.w,X [Reads: X Index]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $08		; 90 08 ; Branch if carry clear to $90, $08 [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($00.b,S),Y		; D3 00 ; Compare accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D3.b		; 00 D3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $A9.b		; 00 A9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$BC8A.w		; 69 8A BC ; Add #$BC8A.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $36		; D0 36 ; Branch if not equal to $D0, $36 [Flow: branch]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	jsr $BE19.w		; 20 19 BE ; Jump to subroutine at $BE19.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $07		; 90 07 ; Branch if carry clear to $90, $07 [Flow: branch]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $BE00.w		; 20 00 BE ; Jump to subroutine at $BE00.w [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$69.b		; A9 69 ; Load #$69.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $2E		; F0 2E ; Branch if equal to $F0, $2E [Flow: branch]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $BD4B.w,Y		; B9 4B BD ; Load $BD4B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsr $FF28.w		; 20 28 FF ; Jump to subroutine at $FF28.w [Writes: Stack Pointer] [Flow: call]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $00E0.w		; 20 E0 00 ; Jump to subroutine at $00E0.w [Writes: Stack Pointer] [Flow: call]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$01.b		; E0 01 ; Compare #$01.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $010000.l,X		; FF 00 00 01 ; Subtract with carry (long,X) $010000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0D80BD.l,X		; FF BD 80 0D ; Subtract with carry (long,X) $0D80BD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $49		; D0 49 ; Branch if not equal to $D0, $49 [Flow: branch]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $21		; D0 21 ; Branch if not equal to $D0, $21 [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $BD74.w,Y		; D9 74 BD ; Compare accumulator $BD74.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $BD7A.w,Y		; 79 7A BD ; Add $BD7A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $BD76.w,Y		; D9 76 BD ; Compare accumulator $BD76.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $BD7C.w,Y		; 79 7C BD ; Add $BD7C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	jsl $0684BD.l		; 22 BD 84 06 ; Jump to subroutine long $0684BD.l [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2A		; D0 2A ; Branch if not equal to $D0, $2A [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $BDC8.w,Y		; B9 C8 BD ; Load $BDC8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $BDCC.w,Y		; B9 CC BD ; Load $BDCC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0D90.w,X		; DD 90 0D ; Compare accumulator $0D90.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0DA0.w,X		; DD A0 0D ; Compare accumulator $0DA0.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $BE00.w		; 20 00 BE ; Jump to subroutine at $BE00.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	jsl $01E7A9.l		; 22 A9 E7 01 ; Jump to subroutine long $01E7A9.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$0F.b		; A0 0F ; Load #$0F.b into Y register [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $57		; D0 57 ; Branch if not equal to $D0, $57 [Flow: branch]
	lda $0DD0.w,Y		; B9 D0 0D ; Load $0DD0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $52		; F0 52 ; Branch if equal to $F0, $52 [Flow: branch]
	lda $0E20.w,Y		; B9 20 0E ; Load $0E20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$1C.b		; C9 1C ; Compare #$1C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $4B		; D0 4B ; Branch if not equal to $D0, $4B [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $04.b		; E5 04 ; Subtract $04.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0020.w		; C9 20 00 ; Compare #$0020.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $11		; B0 11 ; Branch if carry set to $B0, $11 [Flow: branch]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $06.b		; E5 06 ; Subtract $06.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0008.w		; 69 08 00 ; Add #$0008.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0010.w		; C9 10 00 ; Compare #$0010.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 8
	sep #$20		; E2 20
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $9F		; 10 9F ; Branch if plus to $10, $9F [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $BE88.w		; 20 88 BE ; Jump to subroutine at $BE88.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $C088.w		; 20 88 C0 ; Jump to subroutine at $C088.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $1AFDAD.l		; 22 AD FD 1A ; Jump to subroutine long $1AFDAD.l [Writes: Stack Pointer] [Flow: call]
	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0B.b		; [PATTERN: Memory clearing operation] C9 0B ; Compare #$0B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	stz $0E60.w,X		; 9E 60 0E ; Store zero to $0E60.w,X [Reads: X Index]
	lda $0EE0.w,X		; BD E0 0E ; Load $0EE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	lda $0EA0.w,X		; BD A0 0E ; Load $0EA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1B		; F0 1B ; Branch if equal to $F0, $1B [Flow: branch]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	stz $0EA0.w,X		; 9E A0 0E ; Store zero to $0EA0.w,X [Reads: X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EE0.w,X		; 9D E0 0E ; Store accumulator to $0EE0.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	stz $0DF0.w,X		; 9E F0 0D ; Store zero to $0DF0.w,X [Reads: X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0ED0.w,X		; 9D D0 0E ; Store accumulator to $0ED0.w,X [Reads: Accumulator, X Index]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ldx $BEE1.w,Y		; BE E1 BE ; Load X register $BEE1.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora ($BF.b,S),Y		; 13 BF ; OR accumulator (stack relative indirect indexed) ($BF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $BDBF.w,Y		; B9 BF BD ; Load $BDBF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$18.b		; C9 18 ; Compare #$18.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0ED0.w,X		; 9D D0 0E ; Store accumulator to $0ED0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $BF9F.w		; 20 9F BF ; Jump to subroutine at $BF9F.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $0ED0.w,X		; DE D0 0E ; Decrement memory $0ED0.w,X [Reads: X Index] [Flags: NZ]
	jsr $BF9F.w		; 20 9F BF ; Jump to subroutine at $BF9F.w [Writes: Stack Pointer] [Flow: call]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $BF07.w,Y		; 79 07 BF ; Add $BF07.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	cmp $8BD8.w,Y		; D9 D8 8B ; Compare accumulator $8BD8.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $3A		; D0 3A ; Branch if not equal to $D0, $3A [Flow: branch]
	inc $0DB0.w,X		; FE B0 0D ; Increment memory $0DB0.w,X [Reads: X Index] [Flags: NZ]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	stz $0DB0.w,X		; 9E B0 0D ; Store zero to $0DB0.w,X [Reads: X Index]
	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $BF0B.w,Y		; B9 0B BF ; Load $BF0B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $BF09.w,Y		; B9 09 BF ; Load $BF09.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$40.b		; 69 40 ; Add #$40.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	.db $80, $0B		; 80 0B ; Branch always to $80, $0B [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0DF0.w,X		; 9E F0 0D ; Store zero to $0DF0.w,X [Reads: X Index]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda $BF9B.w,Y		; B9 9B BF ; Load $BF9B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	dec $0D80.w,X		; DE 80 0D ; Decrement memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0ED0.w,X		; 9D D0 0E ; Store accumulator to $0ED0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $BFDF.w		; 20 DF BF ; Jump to subroutine at $BFDF.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $C6		; 80 C6 ; Branch always to $80, $C6 [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	jsr $A918.w		; 20 18 A9 ; Jump to subroutine at $A918.w [Writes: Stack Pointer] [Flow: call]
	rol $22.b,X		; 36 22 ; Rotate left $22.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $02A9.w		; 0D A9 02 ; Logical OR $02A9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FB5.w		; 8D B5 0F ; Store accumulator to $0FB5.w [Reads: Accumulator]
	lda #$89.b		; A9 89 ; Load #$89.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $36		; 30 36 ; Branch if minus to $30, $36 [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $04.b		; E5 04 ; Subtract $04.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $0FB5.w		; AE B5 0F ; Load $0FB5.w into X register [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $BFD9.w,X		; 7D D9 BF ; Add $BFD9.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $BFD9.w,X		; BD D9 BF ; Load $BFD9.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $BFDC.w,X		; BD DC BF ; Load $BFDC.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,Y		; 99 70 0F ; Store accumulator to $0F70.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dec $0FB5.w		; CE B5 0F ; Decrement $0FB5.w [Flags: NZ]
	.db $10, $BD		; 10 BD ; Branch if plus to $10, $BD [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $0EB0.w,X		; DE B0 0E ; Decrement memory $0EB0.w,X [Reads: X Index] [Flags: NZ]
	.db $D0, $75		; D0 75 ; Branch if not equal to $D0, $75 [Flow: branch]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda #$8A.b		; A9 8A ; Load #$8A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $68		; 30 68 ; Branch if minus to $30, $68 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$1E.b		; C9 1E ; Compare #$1E.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	sbc #$1E.b		; E9 1E ; Subtract #$1E.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $C02E.w,X		; BD 2E C0 ; Load $C02E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda $C04C.w,X		; BD 4C C0 ; Load $C04C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	sta $0DA0.w,Y		; 99 A0 0D ; Store accumulator to $0DA0.w,Y [Reads: Y Index, Accumulator]
	lda $C06A.w,X		; BD 6A C0 ; Load $C06A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,Y		; 99 E0 0D ; Store accumulator to $0DE0.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E90.w,Y		; 99 90 0E ; Store accumulator to $0E90.w,Y [Reads: Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FB0.w		; 6D B0 0F ; Add $0FB0.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FB1.w		; 6D B1 0F ; Add $0FB1.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsl $0684BD.l		; 22 BD 84 06 ; Jump to subroutine long $0684BD.l [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	stz $0B6B.w,X		; 9E 6B 0B ; Store zero to $0B6B.w,X [Reads: X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cmp ($78.b,X)		; C1 78 ; Compare accumulator ($78.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp ($D6.b,X)		; C1 D6 ; Compare accumulator ($D6.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp ($01.b,X)		; C1 01 ; Compare accumulator ($01.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc $000000.l,X		; FF 00 00 00 ; Subtract with carry (long,X) $000000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0D80FE.l,X		; FF FE 80 0D ; Subtract with carry (long,X) $0D80FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda #$B0.b		; A9 B0 ; Load #$B0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B6B.w,X		; 9D 6B 0B ; Store accumulator to $0B6B.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $C120.w,Y		; B9 20 C1 ; Load $C120.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $C124.w,Y		; B9 24 C1 ; Load $C124.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	.db $80, $E1		; 80 E1 ; Branch always to $80, $E1 [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $8BD8.w,Y		; B9 D8 8B ; Load $8BD8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $8BDA.w,Y		; B9 DA 8B ; Load $8BDA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsr $C158.w		; 20 58 C1 ; Jump to subroutine at $C158.w [Writes: Stack Pointer] [Flow: call]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1C		; D0 1C ; Branch if not equal to $D0, $1C [Flow: branch]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$1B.b		; C9 1B ; Compare #$1B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$6F.b		; A9 6F ; Load #$6F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0DE0.w,X		; 1D E0 0D ; OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C168.w,Y		; B9 68 C1 ; Load $C168.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $C170.w,Y		; 19 70 C1 ; OR accumulator with memory $C170.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$20.b		; E9 20 ; Subtract #$20.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp #$30.b		; C9 30 ; Compare #$30.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	ldy #$04.b		; A0 04 ; Load #$04.b into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$04.b		; C0 04 ; Compare #$04.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsr $C223.w		; 20 23 C2 ; Jump to subroutine at $C223.w [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0DE0.w,X		; 1D E0 0D ; OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C1CE.w,Y		; B9 CE C1 ; Load $C1CE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $28		; 30 28 ; Branch if minus to $30, $28 [Flow: branch]
	jsr $A918.w		; 20 18 A9 ; Jump to subroutine at $A918.w [Writes: Stack Pointer] [Flow: call]
	sta [$A0.b]		; 87 A0 ; Store accumulator (long) [$A0.b] [Reads: Direct Page, Accumulator]
	ora $5F22.w		; 0D 22 5F ; Logical OR $5F22.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $1D.b,X		; F6 1D ; Increment memory $1D.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $30, $39		; 30 39 ; Branch if minus to $30, $39 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $C205.w,X		; 7D 05 C2 ; Add $C205.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $C209.w,X		; 7D 09 C2 ; Add $C209.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $C20D.w,X		; 7D 0D C2 ; Add $C20D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $C211.w,X		; 7D 11 C2 ; Add $C211.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $C215.w,X		; BD 15 C2 ; Load $C215.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $C219.w,X		; BD 19 C2 ; Load $C219.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	jsl $06F121.l		; 22 21 F1 06 ; Jump to subroutine long $06F121.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $5B		; D0 5B ; Branch if not equal to $D0, $5B [Flow: branch]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $C270.w,Y		; 19 70 C2 ; OR accumulator with memory $C270.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $09		; B0 09 ; Branch if carry set to $B0, $09 [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $D0, $01		; D0 01 ; Branch if not equal to $D0, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda #$2A.b		; A9 2A ; Load #$2A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	dec $0DF0.w,X		; DE F0 0D ; Decrement memory $0DF0.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C2B4.w,Y		; B9 B4 C2 ; Load $C2B4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsl $1EC35C.l		; 22 5C C3 1E ; Jump to subroutine long $1EC35C.l [Writes: Stack Pointer] [Flow: call]
	jmp $C26B.w		; 4C 6B C2 ; Jump to $C26B.w [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $0001.w		; 8E 01 00 ; Store X register to $0001.w [Reads: X Index]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0001A4.l,X		; FF A4 01 00 ; Subtract with carry (long,X) $0001A4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0001A5.l,X		; FF A5 01 00 ; Subtract with carry (long,X) $0001A5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$C2FC.w		; 69 FC C2 ; Add #$C2FC.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $27		; D0 27 ; Branch if not equal to $D0, $27 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	ldy $0D80.w,X		; BC 80 0D ; Load Y register $0D80.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0B89.w,X		; BD 89 0B ; Load $0B89.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $C379.w,Y		; 19 79 C3 ; OR accumulator with memory $C379.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsr $C655.w		; 20 55 C6 ; Jump to subroutine at $C655.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $7EF359.l		; AF 59 F3 7E ; Load long $7EF359.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $19		; 80 19 ; Branch always to $80, $19 [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	lda $0EF0.w,X		; BD F0 0E ; Load $0EF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	stz $0EF0.w,X		; 9E F0 0E ; Store zero to $0EF0.w,X [Reads: X Index]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp $31.b,S		; C3 31 ; Compare accumulator (stack relative) $31.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cpy $B7.b		; C4 B7 ; Compare $B7.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $FB.b		; C4 FB ; Compare $FB.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $15.b		; C4 15 ; Compare $15.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cmp $5F.b		; C5 5F ; Compare $5F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $A9.b		; C5 A9 ; Compare $A9.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cop $9D.b		; 02 9D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $30, $06		; 30 06 ; Branch if minus to $30, $06 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$03.b		; E9 03 ; Subtract #$03.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $0F70.w,X		; 5D 70 0F ; Exclusive OR accumulator with memory $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $16		; 10 16 ; Branch if plus to $10, $16 [Flow: branch]
	lda $0F70.w,X		; [PATTERN: Memory clearing operation] BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $C509.w		; 20 09 C5 ; Jump to subroutine at $C509.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cop $80.b		; 02 80 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D0D.w		; 0D 0D 0D ; Logical OR $0D0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0D0D.w		; 0D 0D 0D ; Logical OR $0D0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0D0D.w		; 0D 0D 0D ; Logical OR $0D0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0D0D.w		; 0D 0D 0D ; Logical OR $0D0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0D0D.w		; 0D 0D 0D ; Logical OR $0D0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0B0C.w		; 0D 0C 0B ; Logical OR $0B0C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$30.b		; C9 30 ; Compare #$30.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $C580.w		; 20 80 C5 ; Jump to subroutine at $C580.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$FC.b		; 29 FC ; Logical AND #$FC.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0DE0.w,X		; 1D E0 0D ; OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C457.w,Y		; B9 57 C4 ; Load $C457.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C477.w,Y		; B9 77 C4 ; Load $C477.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	lda $C497.w,Y		; B9 97 C4 ; Load $C497.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	jmp $C44E.w		; 4C 4E C4 ; Jump to $C44E.w [Flow: jump]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $C4F7.w,Y		; B9 F7 C4 ; Load $C4F7.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jmp $C44E.w		; 4C 4E C4 ; Jump to $C44E.w [Flow: jump]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $0F70.w,X		; 5D 70 0F ; Exclusive OR accumulator with memory $0F70.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$9E.b]		; 07 9E ; OR accumulator with memory (long) [$9E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$0B.b		; A0 0B ; Load #$0B.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	dec $0D80.w,X		; DE 80 0D ; Decrement memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C53F.w,Y		; B9 3F C5 ; Load $C53F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $C54F.w,Y		; B9 4F C5 ; Load $C54F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $1C		; 30 1C ; Branch if minus to $30, $1C [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$0D.b		; A9 0D ; Load #$0D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,Y		; 99 70 0F ; Store accumulator to $0F70.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,Y		; 99 00 0E ; Store accumulator to $0E00.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $40.b		; 24 40 ; Test bits $40.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $0040.w,X		; 3E 40 00 ; Rotate left $0040.w,X [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0040.w		; 0E 40 00 ; Arithmetic shift left $0040.w [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2A.b		; 00 2A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$C5A5.w		; 69 A5 C5 ; Add #$C5A5.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0004.w		; 69 04 00 ; Add #$0004.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	inc $92.b		; E6 92 ; Increment $92.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda $90.b		; A5 90 ; Load $90.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0004.w		; E9 04 00 ; Subtract #$0004.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	dec $92.b		; C6 92 ; Decrement $92.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	lda $0F00.w,X		; BD 00 0F ; Load $0F00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	jsr $C69A.w		; 20 9A C6 ; Jump to subroutine at $C69A.w [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0D.b		; C0 0D ; Compare #$0D.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp #$0A.b		; C9 0A ; Compare #$0A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $5E		; F0 5E ; Branch if equal to $F0, $5E [Flow: branch]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $0D.b		; 64 0D ; Store zero to $0D.b
	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $55		; F0 55 ; Branch if equal to $F0, $55 [Flow: branch]
	sta $0C.b		; 85 0C ; Store accumulator to $0C.b [Reads: Accumulator]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	dec $0D.b		; C6 0D ; Decrement $0D.b [Reads: Direct Page] [Flags: NZ]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0A.b		; 85 0A ; Store accumulator to $0A.b [Reads: Accumulator]
	stz $0B.b		; 64 0B ; Store zero to $0B.b
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0C.b		; 65 0C ; Add $0C.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0A.b		; E5 0A ; Subtract $0A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda $C692.w,X		; BD 92 C6 ; Load $C692.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $C696.w,X		; BD 96 C6 ; Load $C696.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $048E.w		; AD 8E 04 ; Load $048E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0C.b		; C9 0C ; Compare #$0C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	cmp #$1B.b		; C9 1B ; Compare #$1B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	cmp #$4B.b		; C9 4B ; Compare #$4B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cmp #$6B.b		; C9 6B ; Compare #$6B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	inc $0DA0.w,X		; FE A0 0D ; Increment memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$83.b		; C9 83 ; Compare #$83.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0CAA.w,X		; 9E AA 0C ; Store zero to $0CAA.w,X [Reads: X Index]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $000D.w		; 0D 0D 00 ; Logical OR $000D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $9E.b		; 05 9E ; Logical OR $9E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $C839.w		; 4C 39 C8 ; Jump to $C839.w [Flow: jump]
	jsl $1DF589.l		; 22 89 F5 1D ; Jump to subroutine long $1DF589.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	cmp #$08.b		; C9 08 ; Compare #$08.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $1E92E4.l		; 22 E4 92 1E ; Jump to subroutine long $1E92E4.l [Writes: Stack Pointer] [Flow: call]
	lda $0048.w		; AD 48 00 ; Load $0048.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	ldy $0E20.w,X		; BC 20 0E ; Load Y register $0E20.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $C7		; F0 C7 ; Branch if equal to $F0, $C7 [Flow: branch]
	cpy #$84.b		; C0 84 ; Compare #$84.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C761.w,Y		; B9 61 C7 ; Load $C761.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $C721.w,Y		; B9 21 C7 ; Load $C721.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $C741.w,Y		; B9 41 C7 ; Load $C741.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0C.b		; 29 0C ; Logical AND #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0DE0.w,X		; 1D E0 0D ; OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C781.w,Y		; B9 81 C7 ; Load $C781.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$84.b		; C9 84 ; Compare #$84.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $2B		; D0 2B ; Branch if not equal to $D0, $2B [Flow: branch]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $16		; B0 16 ; Branch if carry set to $B0, $16 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0DE0.w,X		; DD E0 0D ; Compare accumulator $0DE0.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $CACF.w		; 20 CF CA ; Jump to subroutine at $CACF.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	lda $0CAA.w,X		; BD AA 0C ; Load $0CAA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,X		; 9D AA 0C ; Store accumulator to $0CAA.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($C8.b,S),Y		; 93 C8 ; Store accumulator (stack relative indirect indexed) ($C8.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	wai		; CB ; Wait for interrupt
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	rol $C9.b,X		; 36 C9 ; Rotate left $C9.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $A0		; 80 A0 ; Branch always to $80, $A0 [Flow: branch]
	.db $80, $BD		; 80 BD ; Branch always to $80, $BD [Flow: branch]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$30.b		; 69 30 ; Add #$30.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$60.b		; C9 60 ; Compare #$60.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $11		; B0 11 ; Branch if carry set to $B0, $11 [Flow: branch]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$30.b		; 69 30 ; Add #$30.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$60.b		; C9 60 ; Compare #$60.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $08		; B0 08 ; Branch if carry set to $B0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $18		; D0 18 ; Branch if not equal to $D0, $18 [Flow: branch]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C864.w,Y		; B9 64 C8 ; Load $C864.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C88B.w,Y		; B9 8B C8 ; Load $C88B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,X		; 9D 60 0E ; Store accumulator to $0E60.w,X [Reads: Accumulator, X Index]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$84.b		; C9 84 ; Compare #$84.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda $0CAA.w,X		; BD AA 0C ; Load $0CAA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$FB.b		; 29 FB ; Logical AND #$FB.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,X		; 9D AA 0C ; Store accumulator to $0CAA.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $8BD8.w,Y		; B9 D8 8B ; Load $8BD8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $8BDA.w,Y		; B9 DA 8B ; Load $8BDA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0C.b		; 29 0C ; Logical AND #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0DE0.w,X		; 1D E0 0D ; OR accumulator with memory $0DE0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C8BB.w,Y		; B9 BB C8 ; Load $C8BB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C92E.w,Y		; B9 2E C9 ; Load $C92E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($FCFF.w,X)		; FC FF FC ; Jump to subroutine indirect indexed ($FCFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $0000A2.l,X		; FF A2 00 00 ; Subtract with carry (long,X) $0000A2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0040A2.l,X		; FF A2 40 00 ; Subtract with carry (long,X) $0040A2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $9C0004.l,X		; FF 04 00 9C ; Subtract with carry (long,X) $9C0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FCFF.w,X)		; FC FF FC ; Jump to subroutine indirect indexed ($FCFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $0000A4.l,X		; FF A4 00 00 ; Subtract with carry (long,X) $0000A4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0040A4.l,X		; FF A4 40 00 ; Subtract with carry (long,X) $0040A4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $9C0004.l,X		; FF 04 00 9C ; Subtract with carry (long,X) $9C0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FCFF.w,X)		; FC FF FC ; Jump to subroutine indirect indexed ($FCFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $00008C.l,X		; FF 8C 00 00 ; Subtract with carry (long,X) $00008C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00408C.l,X		; FF 8C 40 00 ; Subtract with carry (long,X) $00408C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $9C0004.l,X		; FF 04 00 9C ; Subtract with carry (long,X) $9C0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FDFF.w,X)		; FC FF FD ; Jump to subroutine indirect indexed ($FDFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $00008C.l,X		; FF 8C 00 00 ; Subtract with carry (long,X) $00008C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00408C.l,X		; FF 8C 40 00 ; Subtract with carry (long,X) $00408C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BC000D.l,X		; FF 0D 00 BC ; Subtract with carry (long,X) $BC000D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FDFF.w,X)		; FC FF FD ; Jump to subroutine indirect indexed ($FDFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $00008C.l,X		; FF 8C 00 00 ; Subtract with carry (long,X) $00008C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00408C.l,X		; FF 8C 40 00 ; Subtract with carry (long,X) $00408C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $8A0005.l,X		; FF 05 00 8A ; Subtract with carry (long,X) $8A0005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($AAFF.w,X)		; FC FF AA ; Jump to subroutine indirect indexed ($AAFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A6.b		; 00 A6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000AA.l,X		; FF AA 00 00 ; Subtract with carry (long,X) $0000AA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A6.b		; 00 A6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000AA.l,X		; FF AA 00 00 ; Subtract with carry (long,X) $0000AA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000AA.l,X		; FF AA 00 00 ; Subtract with carry (long,X) $0000AA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0040AA.l,X		; FF AA 40 00 ; Subtract with carry (long,X) $0040AA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A6.b		; 00 A6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($AAFF.w,X)		; FC FF AA ; Jump to subroutine indirect indexed ($AAFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ldx $40.b		; A6 40 ; Load $40.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $AAFF.w,X		; FD FF AA ; Subtract with carry $AAFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $AAFF.w,X		; FD FF AA ; Subtract with carry $AAFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FCFF.w,X)		; FC FF FC ; Jump to subroutine indirect indexed ($FCFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $00008E.l,X		; FF 8E 00 00 ; Subtract with carry (long,X) $00008E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00408E.l,X		; FF 8E 40 00 ; Subtract with carry (long,X) $00408E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $9E0004.l,X		; FF 04 00 9E ; Subtract with carry (long,X) $9E0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FDFF.w,X)		; FC FF FD ; Jump to subroutine indirect indexed ($FDFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $00008E.l,X		; FF 8E 00 00 ; Subtract with carry (long,X) $00008E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00408E.l,X		; FF 8E 40 00 ; Subtract with carry (long,X) $00408E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BD000D.l,X		; FF 0D 00 BD ; Subtract with carry (long,X) $BD000D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FDFF.w,X)		; FC FF FD ; Jump to subroutine indirect indexed ($FDFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $00008E.l,X		; FF 8E 00 00 ; Subtract with carry (long,X) $00008E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $00408E.l,X		; FF 8E 40 00 ; Subtract with carry (long,X) $00408E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A00005.l,X		; FF 05 00 A0 ; Subtract with carry (long,X) $A00005.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$C94F.w		; 69 4F C9 ; Add #$C94F.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
	lda $0F00.w,X		; BD 00 0F ; Load $0F00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$0E.b		; A9 0E ; Load #$0E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06DC5C.l		; 22 5C DC 06 ; Jump to subroutine long $06DC5C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	trb $0A.b		; 14 0A ; Test and reset bits $0A.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $120000.l,X		; FF 00 00 12 ; Subtract with carry (long,X) $120000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($BD.b,X)		; 01 BD ; Logical OR ($BD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0A.b		; E9 0A ; Subtract #$0A.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda #$EE.b		; A9 EE ; Load #$EE.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FB5.w		; 8D B5 0F ; Store accumulator to $0FB5.w [Reads: Accumulator]
	lda #$82.b		; A9 82 ; Load #$82.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $47		; 30 47 ; Branch if minus to $30, $47 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $0FB5.w		; AE B5 0F ; Load $0FB5.w into X register [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1ECAF4.l,X		; 7F F4 CA 1E ; Add long $1ECAF4.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $1ECAF7.l,X		; 7F F7 CA 1E ; Add long $1ECAF7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1ECAFA.l,X		; 7F FA CA 1E ; Add long $1ECAFA.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $1ECAFD.l,X		; 7F FD CA 1E ; Add long $1ECAFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $1ECB00.l,X		; BF 00 CB 1E ; Load long $1ECB00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $1ECB06.l,X		; BF 06 CB 1E ; Load long $1ECB06.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $1ECB03.l,X		; BF 03 CB 1E ; Load long $1ECB03.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda $1ECB09.l,X		; BF 09 CB 1E ; Load long $1ECB09.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,Y		; 99 A0 0D ; Store accumulator to $0DA0.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dec $0FB5.w		; CE B5 0F ; Decrement $0FB5.w [Flags: NZ]
	.db $10, $AC		; 10 AC ; Branch if plus to $10, $AC [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($EE.b)		; 12 EE ; OR accumulator with memory (indirect) ($EE.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $1DF395.l		; 22 95 F3 1D ; Jump to subroutine long $1DF395.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $CB93.w,Y		; 79 93 CB ; Add $CB93.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	cmp $CB95.w,Y		; D9 95 CB ; Compare accumulator $CB95.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $CB93.w,Y		; 79 93 CB ; Add $CB93.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	cmp $CB95.w,Y		; D9 95 CB ; Compare accumulator $CB95.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0DA0.w,X		; FE A0 0D ; Increment memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	jsl $09AF61.l		; 22 61 AF 09 ; Jump to subroutine long $09AF61.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $1D		; 90 1D ; Branch if carry clear to $90, $1D [Flow: branch]
	lda #$15.b		; A9 15 ; Load #$15.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E20.w,X		; 9D 20 0E ; Store accumulator to $0E20.w,X [Reads: Accumulator, X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0D50.w,X		; BC 50 0D ; Load Y register $0D50.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0D40.w,X		; BC 40 0D ; Load Y register $0D40.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0B89.w,X		; BD 89 0B ; Load $0B89.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$30.b		; 09 30 ; Logical OR #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B89.w,X		; 9D 89 0B ; Store accumulator to $0B89.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0EA0.w,X		; BD A0 0E ; Load $0EA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	eor [$CC.b]		; 47 CC ; Exclusive OR accumulator with memory (long) [$CC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit #$CC.b		; 89 CC ; Test bits #$CC.b with accumulator [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	.db $D0, $2C		; D0 2C ; Branch if not equal to $D0, $2C [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsr $FE6E.w		; 20 6E FE ; Jump to subroutine at $FE6E.w [Writes: Stack Pointer] [Flow: call]
	sty $0C.b		; 84 0C ; Store Y register to $0C.b [Reads: Y Index]
	jsr $FE73.w		; 20 73 FE ; Jump to subroutine at $FE73.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $CC43.w,Y		; 19 43 CC ; OR accumulator with memory $CC43.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$0C.b		; 69 0C ; Add #$0C.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $92BD.w		; 20 BD 92 ; Jump to subroutine at $92BD.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $01FFFF.l,X		; FF FF FF 01 ; Subtract with carry (long,X) $01FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFF01.l,X		; FF 01 FF FF ; Subtract with carry (long,X) $FFFF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $CC79.w,Y		; 79 79 CC ; Add $CC79.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $CC7D.w,Y		; 79 7D CC ; Add $CC7D.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $CC81.w,Y		; 79 81 CC ; Add $CC81.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $CC85.w,Y		; 79 85 CC ; Add $CC85.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($38.b,X)		; 21 38 ; Logical AND ($38.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $44.b,S		; 63 44 ; Add with carry (stack relative) $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda $54.b		; A5 54 ; Load $54.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$5C.b]		; E7 5C ; Subtract with carry (long) [$5C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and #$6D.b		; 29 6D ; Logical AND #$6D.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $1079.w		; AD 79 10 ; Load $1079.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ror $33A9.w,X		; 7E A9 33 ; Rotate right $33A9.w,X [Reads: X Index] [Flags: NCZ]
	sta $9A.b		; 85 9A ; Store accumulator to $9A.b [Reads: Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC007.l		; 8F 07 C0 7E ; Store accumulator (long) $7EC007.l [Reads: Accumulator]
	sta $7EC009.l		; 8F 09 C0 7E ; Store accumulator (long) $7EC009.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0ED657.l		; 22 57 D6 0E ; Jump to subroutine long $0ED657.l [Writes: Stack Pointer] [Flow: call]
	jsl $00EBCF.l		; 22 CF EB 00 ; Jump to subroutine long $00EBCF.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $1ECCD3.l		; AF D3 CC 1E ; Load long $1ECCD3.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC5E0.l		; 8F E0 C5 7E ; Store accumulator (long) $7EC5E0.l [Reads: Accumulator]
	lda $1ECCD5.l		; AF D5 CC 1E ; Load long $1ECCD5.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC5E2.l		; 8F E2 C5 7E ; Store accumulator (long) $7EC5E2.l [Reads: Accumulator]
	lda $1ECCD7.l		; AF D7 CC 1E ; Load long $1ECCD7.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC5E4.l		; 8F E4 C5 7E ; Store accumulator (long) $7EC5E4.l [Reads: Accumulator]
	lda $1ECCD9.l		; AF D9 CC 1E ; Load long $1ECCD9.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC5E6.l		; 8F E6 C5 7E ; Store accumulator (long) $7EC5E6.l [Reads: Accumulator]
	lda $1ECCDB.l		; AF DB CC 1E ; Load long $1ECCDB.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC5E8.l		; 8F E8 C5 7E ; Store accumulator (long) $7EC5E8.l [Reads: Accumulator]
	lda $1ECCDD.l		; AF DD CC 1E ; Load long $1ECCDD.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC5EA.l		; 8F EA C5 7E ; Store accumulator (long) $7EC5EA.l [Reads: Accumulator]
	lda $1ECCDF.l		; AF DF CC 1E ; Load long $1ECCDF.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC5EC.l		; 8F EC C5 7E ; Store accumulator (long) $7EC5EC.l [Reads: Accumulator]
	lda $1ECCE1.l		; AF E1 CC 1E ; Load long $1ECCE1.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC5EE.l		; 8F EE C5 7E ; Store accumulator (long) $7EC5EE.l [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	inc $15.b		; E6 15 ; Increment $15.b [Reads: Direct Page] [Flags: NZ]
	jsr $CD48.w		; 20 48 CD ; Jump to subroutine at $CD48.w [Writes: Stack Pointer] [Flow: call]
	jsr $CDD9.w		; 20 D9 CD ; Jump to subroutine at $CDD9.w [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$0F.b		; A0 0F ; Load #$0F.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DD0.w,Y		; 99 D0 0D ; Store accumulator to $0DD0.w,Y [Reads: Y Index, Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $FA		; 10 FA ; Branch if plus to $10, $FA [Flow: branch]
	lda #$AB.b		; A9 AB ; Load #$AB.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$78.b		; A9 78 ; Load #$78.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda #$7C.b		; A9 7C ; Load #$7C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,Y		; 99 E0 0D ; Store accumulator to $0DE0.w,Y [Reads: Y Index, Accumulator]
	lda #$0B.b		; A9 0B ; Load #$0B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	sta $0F20.w,Y		; 99 20 0F ; Store accumulator to $0F20.w,Y [Reads: Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsl $09AC6B.l		; 22 6B AC 09 ; Jump to subroutine long $09AC6B.l [Writes: Stack Pointer] [Flow: call]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda $040C.w		; AD 0C 04 ; Load $040C.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$18.b		; C9 18 ; Compare #$18.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00D423.l		; 22 23 D4 00 ; Jump to subroutine long $00D423.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	stz $0428.w		; 9C 28 04 ; Store zero to $0428.w
.ACCU 16
	rep #$20		; C2 20
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $E2.b		; E5 E2 ; Subtract $E2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor #$FFFF.w		; 49 FF FF ; Exclusive OR #$FFFF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	adc #$0079.w		; 69 79 00 ; Add #$0079.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0422.w		; 8D 22 04 ; Store accumulator to $0422.w [Reads: Accumulator]
	lda $E6.b		; A5 E6 ; Load $E6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda #$0030.w		; A9 30 00 ; Load #$0030.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $00.b		; E5 00 ; Subtract $00.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0424.w		; 8D 24 04 ; Store accumulator to $0424.w [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0428.w		; 8D 28 04 ; Store accumulator to $0428.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$9C.b		; A9 9C ; Load #$9C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F02.w		; 8D 02 1F ; Store accumulator to $1F02.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F01.w		; 8D 01 1F ; Store accumulator to $1F01.w [Reads: Accumulator]
	sta $012A.w		; 8D 2A 01 ; Store accumulator to $012A.w [Reads: Accumulator]
	sta $1F00.w		; 8D 00 1F ; Store accumulator to $1F00.w [Reads: Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F06.w		; 8D 06 1F ; Store accumulator to $1F06.w [Reads: Accumulator]
	sta $1F07.w		; 8D 07 1F ; Store accumulator to $1F07.w [Reads: Accumulator]
	sta $1F08.w		; [PATTERN: Memory clearing operation] 8D 08 1F ; Store accumulator to $1F08.w [Reads: Accumulator]
	stz $1F03.w		; 9C 03 1F ; Store zero to $1F03.w
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F04.w		; 8D 04 1F ; Store accumulator to $1F04.w [Reads: Accumulator]
	stz $1D.b		; 64 1D ; Store zero to $1D.b
	lda #$16.b		; A9 16 ; Load #$16.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1C.b		; 85 1C ; Store accumulator to $1C.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 16
	rep #$20		; C2 20
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0422.w		; ED 22 04 ; Subtract $0422.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FD8.w		; 8D D8 0F ; Store accumulator to $0FD8.w [Reads: Accumulator]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0424.w		; ED 24 04 ; Subtract $0424.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FDA.w		; 8D DA 0F ; Store accumulator to $0FDA.w [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	jsl $0DCE5F.l		; 22 5F CE 0D ; Jump to subroutine long $0DCE5F.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012A.w		; 8D 2A 01 ; Store accumulator to $012A.w [Reads: Accumulator]
	lda $1F00.w		; AD 00 1F ; Load $1F00.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	jsr $CE39.w		; 20 39 CE ; Jump to subroutine at $CE39.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F00.w		; 8D 00 1F ; Store accumulator to $1F00.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0E90.w,X		; FE 90 0E ; Increment memory $0E90.w,X [Reads: X Index] [Flags: NZ]
	lda $1F05.w		; AD 05 1F ; Load $1F05.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$06.b		; 69 06 ; Add #$06.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F05.w		; 8D 05 1F ; Store accumulator to $1F05.w [Reads: Accumulator]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	adc $CE.b,S		; 63 CE ; Add with carry (stack relative) $CE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc #$CE.b		; 69 CE ; Add #$CE.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc ($CE.b),Y		; 71 CE ; Add with carry ($CE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($CE.b,S),Y		; 93 CE ; Store accumulator (stack relative indirect indexed) ($CE.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	stx $CE.b,Y		; 96 CE ; Store X register $CE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	dec $18CE.w		; CE CE 18 ; Decrement $18CE.w [Flags: NZ]
	cmp $3BCF24.l		; CF 24 CF 3B ; Compare accumulator (long) $3BCF24.l [Reads: Accumulator] [Flags: NCZ]
	cmp $FE1D64.l		; CF 64 1D FE ; Compare accumulator (long) $FE1D64.l [Reads: Accumulator] [Flags: NCZ]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1D.b		; 85 1D ; Store accumulator to $1D.b [Reads: Accumulator]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1F02.w		; AD 02 1F ; Load $1F02.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $07		; B0 07 ; Branch if carry set to $B0, $07 [Flow: branch]
	stz $1F02.w		; 9C 02 1F ; Store zero to $1F02.w
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc #$03.b		; E9 03 ; Subtract #$03.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $1F02.w		; 8D 02 1F ; Store accumulator to $1F02.w [Reads: Accumulator]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0A		; 90 0A ; Branch if carry clear to $90, $0A [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsl $0FFDC4.l		; 22 C4 FD 0F ; Jump to subroutine long $0FFDC4.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1E		; D0 1E ; Branch if not equal to $D0, $1E [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00EC0D.l		; 22 0D EC 00 ; Jump to subroutine long $00EC0D.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $7EC007.l		; AF 07 C0 7E ; Load long $7EC007.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	inc $0D80.w,X		; [PATTERN: Memory clearing operation] FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	stz $02D8.w		; 9C D8 02 ; Store zero to $02D8.w
	stz $02DA.w		; 9C DA 02 ; Store zero to $02DA.w
	stz $2E.b		; [PATTERN: Memory clearing operation] 64 2E ; Store zero to $2E.b
	stz $2F.b		; 64 2F ; Store zero to $2F.b
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and ($01.b,S),Y		; 33 01 ; AND accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$01.b],Y		; 37 01 ; AND accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $01.b,X		; 36 01 ; Rotate left $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $01.b,X		; 35 01 ; Logical AND $01.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora ($3C.b,X)		; 01 3C ; Logical OR ($3C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($AD.b,X)		; 01 AD ; Logical OR ($AD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $3804.w		; 0C 04 38 ; Test and set bits $3804.w [Reads: Accumulator] [Flags: Z]
	sbc #$0A.b		; E9 0A ; Subtract #$0A.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cpy #$02.b		; C0 02 ; Compare #$02.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	lda $7EF3C7.l		; AF C7 F3 7E ; Load long $7EF3C7.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C7.l		; 8F C7 F3 7E ; Store accumulator (long) $7EF3C7.l [Reads: Accumulator]
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda $7EF37A.l		; AF 7A F3 7E ; Load long $7EF37A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$7F.b		; C9 7F ; Compare #$7F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	ldy #$10.b		; A0 10 ; Load #$10.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $CEBC.w,Y		; B9 BC CE ; Load $CEBC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $CEBD.w,Y		; B9 BD CE ; Load $CEBD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $7EF37A.l		; AF 7A F3 7E ; Load long $7EF37A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$7F.b		; C9 7F ; Compare #$7F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C7.l		; 8F C7 F3 7E ; Store accumulator (long) $7EF3C7.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$3A.b		; A9 3A ; Load #$3A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$39.b		; A9 39 ; Load #$39.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $1D.b		; [PATTERN: Memory clearing operation] 64 1D ; Store zero to $1D.b
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00F945.l		; 22 45 F9 00 ; Jump to subroutine long $00F945.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $CFFF.w		; 20 FF CF ; Jump to subroutine at $CFFF.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $45		; D0 45 ; Branch if not equal to $D0, $45 [Flow: branch]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	.db $80, $09		; 80 09 ; Branch always to $80, $09 [Flow: branch]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$20.b		; C9 20 ; Compare #$20.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $15		; B0 15 ; Branch if carry set to $B0, $15 [Flow: branch]
	lda $CF96.w,Y		; B9 96 CF ; Load $CF96.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $CF86.w,Y		; B9 86 CF ; Load $CF86.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $CF8E.w,Y		; B9 8E CF ; Load $CF8E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $00E0.w		; 20 E0 00 ; Jump to subroutine at $00E0.w [Writes: Stack Pointer] [Flow: call]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $40		; 10 40 ; Branch if plus to $10, $40 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $16		; D0 16 ; Branch if not equal to $D0, $16 [Flow: branch]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $25		; D0 25 ; Branch if not equal to $D0, $25 [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $CF8A.w,Y		; B9 8A CF ; Load $CF8A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $CF92.w,Y		; B9 92 CF ; Load $CF92.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0D90.w,X		; DD 90 0D ; Compare accumulator $0D90.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0DB0.w,X		; DD B0 0D ; Compare accumulator $0DB0.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $C4FFF8.l,X		; FF F8 FF C4 ; Subtract with carry (long,X) $C4FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0040C4.l,X		; FF C4 40 00 ; Subtract with carry (long,X) $0040C4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $C40008.l,X		; FF 08 00 C4 ; Subtract with carry (long,X) $C40008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	cop $C2.b		; 02 C2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $DFA9.w		; 20 A9 DF ; Jump to subroutine at $DFA9.w [Writes: Stack Pointer] [Flow: call]
	cmp $A90885.l		; CF 85 08 A9 ; Compare accumulator (long) $A90885.l [Reads: Accumulator] [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	jsl $05DF70.l		; 22 70 DF 05 ; Jump to subroutine long $05DF70.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $FF02.w,X		; FE 02 FF ; Increment memory $FF02.w,X [Reads: X Index] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor #$D0.b		; 49 D0 ; Exclusive OR #$D0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$7E.b		; E9 7E ; Subtract #$7E.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $040C.w		; AD 0C 04 ; Load $040C.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$12.b		; C9 12 ; Compare #$12.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D012.w,Y		; 79 12 D0 ; Add $D012.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $D016.w,Y		; 79 16 D0 ; Add $D016.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FF84.w		; 20 84 FF ; Jump to subroutine at $FF84.w [Writes: Stack Pointer] [Flow: call]
	lda $05.b		; A5 05 ; Load $05.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0FB6.w		; 8D B6 0F ; Store accumulator to $0FB6.w [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0FA8.w		; 8D A8 0F ; Store accumulator to $0FA8.w [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0FA9.w		; 8D A9 0F ; Store accumulator to $0FA9.w [Reads: Accumulator]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01FF.w		; 29 FF 01 ; Logical AND #$01FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0A.b		; 85 0A ; Store accumulator to $0A.b [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0080.w		; 69 80 00 ; Add #$0080.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and #$01FF.w		; 29 FF 01 ; Logical AND #$01FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $04E800.l,X		; BF 00 E8 04 ; Load long $04E800.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $04E800.l,X		; BF 00 E8 04 ; Load long $04E800.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $05.b		; A4 05 ; Load $05.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $8A85.w		; 20 85 8A ; Jump to subroutine at $8A85.w [Writes: Stack Pointer] [Flow: call]
	asl $4216.w		; 0E 16 42 ; Arithmetic shift left $4216.w [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
	lsr $01.b		; 46 01 ; Logical shift right $01.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy $07.b		; A4 07 ; Load $07.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $8A85.w		; 20 85 8A ; Jump to subroutine at $8A85.w [Writes: Stack Pointer] [Flow: call]
	asl $4216.w		; 0E 16 42 ; Arithmetic shift left $4216.w [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0F.b		; 85 0F ; Store accumulator to $0F.b [Reads: Accumulator]
	lsr $03.b		; 46 03 ; Logical shift right $03.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$C0.b		; 29 C0 ; Logical AND #$C0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0FB6.w		; 0D B6 0F ; Logical OR $0FB6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA8.w		; 6D A8 0F ; Add $0FA8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA9.w		; 6D A9 0F ; Add $0FA9.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$28.b		; A9 28 ; Load #$28.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $0D.b		; A5 0D ; Load $0D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b)		; 92 92 ; Store accumulator (indirect) ($92.b) [Reads: Direct Page, Accumulator]
	ldy #$04.b		; A0 04 ; Load #$04.b into Y register [Writes: Y Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$02.b		; A2 02 ; Load #$02.b into X register [Writes: X Index] [Flags: NZ]
	lda $0E.b		; A5 0E ; Load $0E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $D1CA.w,X		; BD CA D1 ; Load $D1CA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $8A85.w		; 20 85 8A ; Jump to subroutine at $8A85.w [Writes: Stack Pointer] [Flow: call]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA8.w		; 6D A8 0F ; Add $0FA8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $0F.b		; A5 0F ; Load $0F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	lda $D1CA.w,X		; BD CA D1 ; Load $D1CA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	jsr $8A85.w		; 20 85 8A ; Jump to subroutine at $8A85.w [Writes: Stack Pointer] [Flow: call]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0FA9.w		; 6D A9 0F ; Add $0FA9.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$28.b		; A9 28 ; Load #$28.b into accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $0D.b		; A5 0D ; Load $0D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $A9		; 10 A9 ; Branch if plus to $10, $A9 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy #$FF.b		; A0 FF ; Load #$FF.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0FC1.w		; 0D C1 0F ; Logical OR $0FC1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $40		; D0 40 ; Branch if not equal to $D0, $40 [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($92.b),Y		; B1 92 ; Load accumulator ($92.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2A		; D0 2A ; Branch if not equal to $D0, $2A [Flow: branch]
	lda ($90.b),Y		; B1 90 ; Load accumulator ($90.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $E2.b		; 65 E2 ; Add $E2.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $22.b		; E5 22 ; Subtract $22.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0C.b		; 69 0C ; Add #$0C.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$18.b		; C9 18 ; Compare #$18.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $1B		; B0 1B ; Branch if carry set to $B0, $1B [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda ($90.b),Y		; B1 90 ; Load accumulator ($90.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$F0.b		; C9 F0 ; Compare #$F0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $13		; B0 13 ; Branch if carry set to $B0, $13 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $E8.b		; 65 E8 ; Add $E8.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $20.b		; E5 20 ; Subtract $20.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsl $06F41F.l		; 22 1F F4 06 ; Jump to subroutine long $06F41F.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy #$10.b		; C0 10 ; Compare #$10.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $90, $C2		; 90 C2 ; Branch if carry clear to $90, $C2 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $D1CD.w,Y		; 19 CD D1 ; OR accumulator with memory $D1CD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	jsr $D239.w		; 20 39 D2 ; Jump to subroutine at $D239.w [Writes: Stack Pointer] [Flow: call]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $9254.w,Y		; B9 54 92 ; Load $9254.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D1FE.w,Y		; B9 FE D1 ; Load $D1FE.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $D202.w,Y		; B9 02 D2 ; Load $D202.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $4C		; D0 4C ; Branch if not equal to $D0, $4C [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx #$1D.b		; A2 1D ; Load #$1D.b into X register [Writes: X Index] [Flags: NZ]
	lda $7FF800.l,X		; BF 00 F8 7F ; Load long $7FF800.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF800.l,X		; 9F 00 F8 7F ; Store accumulator (long,X) $7FF800.l,X [Reads: Accumulator, X Index]
	sta $0FB4.w		; 8D B4 0F ; Store accumulator to $0FB4.w [Reads: Accumulator]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF83C.l,X		; 9F 3C F8 7F ; Store accumulator (long,X) $7FF83C.l,X [Reads: Accumulator, X Index]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF878.l,X		; 9F 78 F8 7F ; Store accumulator (long,X) $7FF878.l,X [Reads: Accumulator, X Index]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF81E.l,X		; 9F 1E F8 7F ; Store accumulator (long,X) $7FF81E.l,X [Reads: Accumulator, X Index]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7FF85A.l,X		; 9F 5A F8 7F ; Store accumulator (long,X) $7FF85A.l,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7FF90E.l,X		; 9F 0E F9 7F ; Store accumulator (long,X) $7FF90E.l,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF92C.l,X		; 9F 2C F9 7F ; Store accumulator (long,X) $7FF92C.l,X [Reads: Accumulator, X Index]
	lda $0F20.w,Y		; B9 20 0F ; Load $0F20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7FF968.l,X		; 9F 68 F9 7F ; Store accumulator (long,X) $7FF968.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $BC.b		; 02 BC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$0D.b		; E0 0D ; Compare #$0D.b with X register [Reads: X Index] [Flags: NCZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $D291.w,Y		; 19 91 D2 ; OR accumulator with memory $D291.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $D295.w,Y		; B9 95 D2 ; Load $D295.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	lda $D28D.w,Y		; B9 8D D2 ; Load $D28D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $002F.w		; CD 2F 00 ; Compare $002F.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $27		; F0 27 ; Branch if equal to $F0, $27 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1C		; D0 1C ; Branch if not equal to $D0, $1C [Flow: branch]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	inc $0DA0.w,X		; FE A0 0D ; Increment memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE6E.w		; 20 6E FE ; Jump to subroutine at $FE6E.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	dec $0DA0.w,X		; DE A0 0D ; Decrement memory $0DA0.w,X [Reads: X Index] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE6E.w		; 20 6E FE ; Jump to subroutine at $FE6E.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $FA.b		; 06 FA ; Arithmetic shift left $FA.b [Reads: Direct Page] [Flags: NCZ]
	jsr $D978.w		; 20 78 D9 ; Jump to subroutine at $D978.w [Writes: Stack Pointer] [Flow: call]
	lda $0F00.w,X		; BD 00 0F ; Load $0F00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	cpx $F6D4.w		; EC D4 F6 ; Compare $F6D4.w with X register [Reads: X Index] [Flags: NCZ]
	pei ($24.b)		; D4 24 ; Push effective indirect address ($24.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cmp $66.b,X		; D5 66 ; Compare accumulator $66.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $30.b,X		; D5 30 ; Compare accumulator $30.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $08.b,X		; D6 08 ; Decrement memory $08.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp [$5E.b],Y		; D7 5E ; Compare accumulator (long indexed) [$5E.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	pei ($7C.b)		; D4 7C ; Push effective indirect address ($7C.b) [Reads: Direct Page] [Writes: Stack Pointer]
	pei ($DA.b)		; D4 DA ; Push effective indirect address ($DA.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cmp ($08.b,S),Y		; D3 08 ; Compare accumulator (stack relative indirect indexed) ($08.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	pei ($76.b)		; D4 76 ; Push effective indirect address ($76.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cmp ($00.b,S),Y		; D3 00 ; Compare accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jsl $00F945.l		; 22 45 F9 00 ; Jump to subroutine long $00F945.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $12		; B0 12 ; Branch if carry set to $B0, $12 [Flow: branch]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9A.b		; 85 9A ; Store accumulator to $9A.b [Reads: Accumulator]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1C.b		; 85 1C ; Store accumulator to $1C.b [Reads: Accumulator]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1D.b		; 85 1D ; Store accumulator to $1D.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00EC0D.l		; 22 0D EC 00 ; Jump to subroutine long $00EC0D.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$FF.b		; C9 FF ; Compare #$FF.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$01.b		; 69 01 ; Add #$01.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F90.w,X		; BD 90 0F ; Load $0F90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0F80.w,X		; 7D 80 0F ; Add $0F80.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0F90.w,X		; 9D 90 0F ; Store accumulator to $0F90.w,X [Reads: Accumulator, X Index]
	.db $90, $13		; 90 13 ; Branch if carry clear to $90, $13 [Flow: branch]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$07.b		; C9 07 ; Compare #$07.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	stz $0E80.w,X		; 9E 80 0E ; Store zero to $0E80.w,X [Reads: X Index]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	ldy $0E80.w,X		; BC 80 0E ; Load Y register $0E80.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D36F.w,Y		; B9 6F D3 ; Load $D36F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FFC.w		; 8D FC 0F ; Store accumulator to $0FFC.w [Reads: Accumulator]
	stz $0EB0.w,X		; 9E B0 0E ; Store zero to $0EB0.w,X [Reads: X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	lda $0EF0.w,X		; BD F0 0E ; Load $0EF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$E0.b		; 09 E0 ; Logical OR #$E0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EF0.w,X		; 9D F0 0E ; Store accumulator to $0EF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	jsl $1D88A1.l		; 22 A1 88 1D ; Jump to subroutine long $1D88A1.l [Writes: Stack Pointer] [Flow: call]
	lda #$1D.b		; A9 1D ; Load #$1D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	stz $0EF0.w,X		; [PATTERN: Memory clearing operation] 9E F0 0E ; Store zero to $0EF0.w,X [Reads: X Index]
	lda #$11.b		; A9 11 ; Load #$11.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0EB0.w,X		; 9E B0 0E ; Store zero to $0EB0.w,X [Reads: X Index]
	lda $0D10.w		; AD 10 0D ; Load $0D10.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0D30.w		; AD 30 0D ; Load $0D30.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0D00.w		; AD 00 0D ; Load $0D00.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0D20.w		; AD 20 0D ; Load $0D20.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $04.b		; E5 04 ; Subtract $04.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0004.w		; 69 04 00 ; Add #$0004.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0008.w		; C9 08 00 ; Compare #$0008.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $14		; B0 14 ; Branch if carry set to $B0, $14 [Flow: branch]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $06.b		; E5 06 ; Subtract $06.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0004.w		; 69 04 00 ; Add #$0004.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0008.w		; C9 08 00 ; Compare #$0008.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
.ACCU 8
	sep #$20		; E2 20
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsl $1DD392.l		; 22 92 D3 1D ; Jump to subroutine long $1DD392.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $16		; D0 16 ; Branch if not equal to $D0, $16 [Flow: branch]
	lda #$41.b		; A9 41 ; Load #$41.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF0.w		; 8D F0 1C ; Store accumulator to $1CF0.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF1.w		; 8D F1 1C ; Store accumulator to $1CF1.w [Reads: Accumulator]
	jsl $05FA8E.l		; 22 8E FA 05 ; Jump to subroutine long $05FA8E.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$50.b		; A9 50 ; Load #$50.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $BDE0.w		; 20 E0 BD ; Jump to subroutine at $BDE0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $D509.w		; 4C 09 D5 ; Jump to $D509.w [Flow: jump]
	lda $D479.w,X		; BD 79 D4 ; Load $D479.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsl $1DD392.l		; 22 92 D3 1D ; Jump to subroutine long $1DD392.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $05		; 30 05 ; Branch if minus to $30, $05 [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora #$0B.b		; 09 0B ; Logical OR #$0B.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $D509.w		; 4C 09 D5 ; Jump to $D509.w [Flow: jump]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $34		; D0 34 ; Branch if not equal to $D0, $34 [Flow: branch]
	lda #$28.b		; A9 28 ; Load #$28.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FB5.w		; 8D B5 0F ; Store accumulator to $0FB5.w [Reads: Accumulator]
	lda #$7A.b		; A9 7A ; Load #$7A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $1DF65F.l		; 22 5F F6 1D ; Jump to subroutine long $1DF65F.l [Writes: Stack Pointer] [Flow: call]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda $D4A6.w,Y		; B9 A6 D4 ; Load $D4A6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,Y		; 99 60 0E ; Store accumulator to $0E60.w,Y [Reads: Y Index, Accumulator]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	sta $0EC0.w,Y		; 99 C0 0E ; Store accumulator to $0EC0.w,Y [Reads: Y Index, Accumulator]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,Y		; 99 80 0D ; Store accumulator to $0D80.w,Y [Reads: Y Index, Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	dec $0FB5.w		; CE B5 0F ; Decrement $0FB5.w [Flags: NZ]
	.db $10, $D6		; 10 D6 ; Branch if plus to $10, $D6 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy $0FFF.w		; AC FF 0F ; Load $0FFF.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $D4EA.w,Y		; B9 EA D4 ; Load $D4EA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $23		; D0 23 ; Branch if not equal to $D0, $23 [Flow: branch]
	lda #$3F.b		; A9 3F ; Load #$3F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF0.w		; 8D F0 1C ; Store accumulator to $1CF0.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF1.w		; 8D F1 1C ; Store accumulator to $1CF1.w [Reads: Accumulator]
	jsl $05FA8E.l		; 22 8E FA 05 ; Jump to subroutine long $05FA8E.l [Writes: Stack Pointer] [Flow: call]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda #$27.b		; A9 27 ; Load #$27.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $0E0D.w		; 0C 0D 0E ; Test and set bits $0E0D.w [Reads: Accumulator] [Flags: Z]
	ora $F89C10.l		; 0F 10 9C F8 ; OR accumulator with memory (long) $F89C10.l [Writes: Accumulator] [Flags: NZ]
	ora $0DF0BD.l		; 0F BD F0 0D ; OR accumulator with memory (long) $0DF0BD.l [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D51F.w,Y		; B9 1F D5 ; Load $D51F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0C18.w,X		; 1E 18 0C ; Arithmetic shift left $0C18.w,X [Reads: X Index] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($BD.b)		; 12 BD ; OR accumulator with memory (indirect) ($BD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$27.b		; A9 27 ; Load #$27.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp #$EF.b		; C9 EF ; Compare #$EF.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0FFF.w		; AD FF 0F ; Load $0FFF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	ldx #$02.b		; A2 02 ; Load #$02.b into X register [Writes: X Index] [Flags: NZ]
	jsl $00ECCA.l		; 22 CA EC 00 ; Jump to subroutine long $00ECCA.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $80, $09		; 80 09 ; Branch always to $80, $09 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	jsr $C267.w		; 20 67 C2 ; Jump to subroutine at $C267.w [Writes: Stack Pointer] [Flow: call]
	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$27.b		; A9 27 ; Load #$27.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $33		; 90 33 ; Branch if carry clear to $90, $33 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	ldy $01.b		; A4 01 ; Load $01.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $01.b		; 65 01 ; Add $01.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D310.w,Y		; B9 10 D3 ; Load $D310.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp #$70.b		; C9 70 ; Compare #$70.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $D67A.w		; 20 7A D6 ; Jump to subroutine at $D67A.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D540.w,Y		; B9 40 D5 ; Load $D540.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $D550.w,Y		; B9 50 D5 ; Load $D550.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc $D560.w,Y		; 79 60 D5 ; Add $D560.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $D329.w,Y		; B9 29 D3 ; Load $D329.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D90.w,X		; 7D 90 0D ; Add $0D90.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	asl $0C0D.w		; 0E 0D 0C ; Arithmetic shift left $0C0D.w [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clv		; B8 ; Clear overflow flag [Flags: V]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $98		; 90 98 ; Branch if carry clear to $90, $98 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $90, $70		; 90 70 ; Branch if carry clear to $90, $70 [Flow: branch]
	.db $70, $90		; 70 90 ; Branch if overflow set to $70, $90 [Flow: branch]
	ldy #$BD.b		; A0 BD ; Load #$BD.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	.db $D0, $25		; D0 25 ; Branch if not equal to $D0, $25 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	ldy #$04.b		; A0 04 ; Load #$04.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D610.w,Y		; B9 10 D6 ; Load $D610.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	lda $D620.w,Y		; B9 20 D6 ; Load $D620.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0E90.w,X		; 9D 90 0E ; Store accumulator to $0E90.w,X [Reads: Accumulator, X Index]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0ED0.w,X		; 9D D0 0E ; Store accumulator to $0ED0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D60B.w,Y		; B9 0B D6 ; Load $D60B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $00.b,X		; F6 00 ; Increment memory $00.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FEFEF7.l,X		; FF F7 FE FE ; Subtract with carry (long,X) $FEFEF7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FE.b],Y		; F7 FE ; Subtract with carry (long indexed) [$FE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $00E0.w,X		; FE E0 00 ; Increment memory $00E0.w,X [Reads: X Index] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	inc $0E30.w,X		; FE 30 0E ; Increment memory $0E30.w,X [Reads: X Index] [Flags: NZ]
	lda $0FFF.w		; AD FF 0F ; Load $0FFF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E30.w,X		; 9D 30 0E ; Store accumulator to $0E30.w,X [Reads: Accumulator, X Index]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	stz $0E30.w,X		; 9E 30 0E ; Store zero to $0E30.w,X [Reads: X Index]
	lda #$26.b		; A9 26 ; Load #$26.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	jsr $D6A1.w		; 20 A1 D6 ; Jump to subroutine at $D6A1.w [Writes: Stack Pointer] [Flow: call]
	jsl $1DE612.l		; 22 12 E6 1D ; Jump to subroutine long $1DE612.l [Writes: Stack Pointer] [Flow: call]
	jsl $1DE612.l		; 22 12 E6 1D ; Jump to subroutine long $1DE612.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$7B.b		; A9 7B ; Load #$7B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $55		; 30 55 ; Branch if minus to $30, $55 [Flow: branch]
	lda #$29.b		; A9 29 ; Load #$29.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D668.w,X		; 7D 68 D6 ; Add $D668.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $D66E.w,X		; 7D 6E D6 ; Add $D66E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D674.w,X		; 7D 74 D6 ; Add $D674.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$FF.b		; 69 FF ; Add #$FF.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $0E30.w,X		; BD 30 0E ; Load $0E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $12		; 90 12 ; Branch if carry clear to $90, $12 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,Y		; 99 A0 0D ; Store accumulator to $0DA0.w,Y [Reads: Y Index, Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $04.b		; E5 04 ; Subtract $04.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0007.w		; 69 07 00 ; Add #$0007.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$000E.w		; C9 0E 00 ; Compare #$000E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $1F		; B0 1F ; Branch if carry set to $B0, $1F [Flow: branch]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $06.b		; E5 06 ; Subtract $06.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0007.w		; 69 07 00 ; Add #$0007.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$000E.w		; C9 0E 00 ; Compare #$000E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $11		; B0 11 ; Branch if carry set to $B0, $11 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	jmp $D514.w		; 4C 14 D5 ; Jump to $D514.w [Flow: jump]
.ACCU 8
	sep #$20		; E2 20
	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0ED0.w,X		; BD D0 0E ; Load $0ED0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	inc $0ED0.w,X		; FE D0 0E ; Increment memory $0ED0.w,X [Reads: X Index] [Flags: NZ]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $FA.b		; 06 FA ; Arithmetic shift left $FA.b [Reads: Direct Page] [Flags: NCZ]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $FA.b		; 06 FA ; Arithmetic shift left $FA.b [Reads: Direct Page] [Flags: NCZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $82, $82, $A2		; 82 82 A2 ; Branch always long to $82, $82, $A2 [Flow: branch]
	ldx #$80.b		; A2 80 ; Load #$80.b into X register [Writes: X Index] [Flags: NZ]
	.db $80, $A0		; 80 A0 ; Branch always to $80, $A0 [Flow: branch]
	ldy #$84.b		; A0 84 ; Load #$84.b into Y register [Writes: Y Index] [Flags: NZ]
	sty $A4.b		; 84 A4 ; Store Y register to $A4.b [Reads: Y Index]
	ldy $86.b		; A4 86 ; Load $86.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	stx $A6.b		; 86 A6 ; Store X register to $A6.b [Reads: X Index]
	ldx $88.b		; A6 88 ; Load $88.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sty $AC8E.w		; 8C 8E AC ; Store Y register to $AC8E.w [Reads: Y Index]
	ldx $C2C4.w		; AE C4 C2 ; Load $C2C4.w into X register [Writes: X Index] [Flags: NZ]
	cpx $E6.b		; E4 E6 ; Compare $E6.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpy #$C2.b		; C0 C2 ; Compare #$C2.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$E2.b		; E0 E2 ; Compare #$E2.b with X register [Reads: X Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	stx $AE8C.w		; 8E 8C AE ; Store X register to $AE8C.w [Reads: X Index]
	ldy $C4C2.w		; AC C2 C4 ; Load $C4C2.w into Y register [Writes: Y Index] [Flags: NZ]
	inc $E4.b		; E6 E4 ; Increment $E4.b [Reads: Direct Page] [Flags: NZ]
	rep #$C0		; C2 C0 ; Reset processor status bits #$C0 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
.ACCU 8
	sep #$E0		; E2 E0
	cpx $ECEC.w		; EC EC EC ; Compare $ECEC.w with X register [Reads: X Index] [Flags: NCZ]
	cpx $ECEC.w		; EC EC EC ; Compare $ECEC.w with X register [Reads: X Index] [Flags: NCZ]
	cpx $EEEC.w		; EC EC EE ; Compare $EEEC.w with X register [Reads: X Index] [Flags: NCZ]
	inc $EEEE.w		; EE EE EE ; Increment $EEEE.w [Flags: NZ]
	inc $EEEE.w		; EE EE EE ; Increment $EEEE.w [Flags: NZ]
	inc $DFDF.w		; EE DF DF ; Increment $DFDF.w [Flags: NZ]
	cmp $4240DF.l,X		; DF DF 40 42 ; Compare accumulator (long,X) $4240DF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $42, $00		; 42 00 ; Reserved instruction
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F50F.w,Y		; F9 0F F5 ; Subtract with carry $F50F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $0B.b,X		; F5 0B ; Subtract $0B.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($0004.w,X)		; FC 04 00 ; Jump to subroutine indirect indexed ($0004.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F2FBF2.l,X		; FF F2 FB F2 ; Subtract with carry (long,X) $F2FBF2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	pea $F6F9.w		; F4 F9 F6 ; Push absolute address $F6F9.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $F6F6.w,Y		; F9 F6 F6 ; Subtract with carry $F6F6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	tsb $0C04.w		; 0C 04 0C ; Test and set bits $0C04.w [Reads: Accumulator] [Flags: Z]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $F6.b,X		; F6 F6 ; Increment memory $F6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	asl $0A0E.w		; 0E 0E 0A ; Arithmetic shift left $0A0E.w [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $F50F.w,Y		; F9 0F F5 ; Subtract with carry $F50F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $0B.b,X		; F5 0B ; Subtract $0B.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($0004.w,X)		; FC 04 00 ; Jump to subroutine indirect indexed ($0004.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F909.w,X		; FD 09 F9 ; Subtract with carry $F909.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F9.b		; 05 F9 ; Logical OR $F9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FB.b		; 05 FB ; Logical OR $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $09FD.w,X		; FE FD 09 ; Increment memory $09FD.w,X [Reads: X Index] [Flags: NZ]
	sbc $F905.w,Y		; F9 05 F9 ; Subtract with carry $F905.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FB.b		; 05 FB ; Logical OR $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $09FD.w,X		; FE FD 09 ; Increment memory $09FD.w,X [Reads: X Index] [Flags: NZ]
	sbc $F905.w,Y		; F9 05 F9 ; Subtract with carry $F905.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FB.b		; 05 FB ; Logical OR $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $09FD.w,X		; FE FD 09 ; Increment memory $09FD.w,X [Reads: X Index] [Flags: NZ]
	sbc $F905.w,Y		; F9 05 F9 ; Subtract with carry $F905.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FB.b		; 05 FB ; Logical OR $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FD.b,S		; 03 FD ; OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $FBFB.w,X		; FE FB FB ; Increment memory $FBFB.w,X [Reads: X Index] [Flags: NZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $C6CC.w		; CE CC C6 ; Decrement $C6CC.w [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $CE.b		; C6 CE ; Decrement $CE.b [Reads: Direct Page] [Flags: NZ]
	cpy $C6C6.w		; CC C6 C6 ; Compare $C6C6.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $C6CC.w		; CE CC C6 ; Decrement $C6CC.w [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $CE.b		; C6 CE ; Decrement $CE.b [Reads: Direct Page] [Flags: NZ]
	cpy $C6C6.w		; CC C6 C6 ; Compare $C6C6.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $C6CC.w		; CE CC C6 ; Decrement $C6CC.w [Flags: NZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	dec $CE.b		; C6 CE ; Decrement $CE.b [Reads: Direct Page] [Flags: NZ]
	cpy $C6C6.w		; CC C6 C6 ; Compare $C6C6.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $C6.b		; C6 C6 ; Decrement $C6.b [Reads: Direct Page] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FF84.w		; 20 84 FF ; Jump to subroutine at $FF84.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$03.b		; A2 03 ; Load #$03.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D77F.w,X		; 7D 7F D7 ; Add $D77F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D7C7.w,X		; 7D C7 D7 ; Add $D7C7.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $D80F.w,X		; BD 0F D8 ; Load $D80F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $D857.w,X		; BD 57 D8 ; Load $D857.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$44.b		; E0 44 ; Compare #$44.b with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	cpx #$40.b		; E0 40 ; Compare #$40.b with X register [Reads: X Index] [Flags: NCZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $C2		; 10 C2 ; Branch if plus to $10, $C2 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$0C.b		; C9 0C ; Compare #$0C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	lda #$12.b		; A9 12 ; Load #$12.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06DC5C.l		; 22 5C DC 06 ; Jump to subroutine long $06DC5C.l [Writes: Stack Pointer] [Flow: call]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	ldy #$FF.b		; A0 FF ; Load #$FF.b into Y register [Writes: Y Index] [Flags: NZ]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06FEB4.l		; 22 B4 FE 06 ; Jump to subroutine long $06FEB4.l [Writes: Stack Pointer] [Flow: call]
	jsr $FF84.w		; 20 84 FF ; Jump to subroutine at $FF84.w [Writes: Stack Pointer] [Flow: call]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	jsl $0DBA88.l		; 22 88 BA 0D ; Jump to subroutine long $0DBA88.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $49		; F0 49 ; Branch if equal to $F0, $49 [Flow: branch]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0C.b		; 85 0C ; Store accumulator to $0C.b [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora #$31.b		; 09 31 ; Logical OR #$31.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D.b		; 85 0D ; Store accumulator to $0D.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$01.b		; A2 01 ; Load #$01.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $06.b		; 65 06 ; Add $06.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D89F.w,X		; 7D 9F D8 ; Add $D89F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D8E7.w,X		; 7D E7 D8 ; Add $D8E7.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ldx $0C.b		; A6 0C ; Load $0C.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $D92F.w,X		; BD 2F D9 ; Load $D92F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $0D.b		; A5 0D ; Load $0D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($90.b),Y		; 91 90 ; Store accumulator ($90.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D953.w,X		; BD 53 D9 ; Load $D953.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $CC		; 10 CC ; Branch if plus to $10, $CC [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $09		; 80 09 ; Branch always to $80, $09 [Flow: branch]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $DB54.w		; 4C 54 DB ; Jump to $DB54.w [Flow: jump]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	jsr $DC3E.w		; 20 3E DC ; Jump to subroutine at $DC3E.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	inc $0E80.w,X		; FE 80 0E ; Increment memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $62		; D0 62 ; Branch if not equal to $D0, $62 [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $4C		; F0 4C ; Branch if equal to $F0, $4C [Flow: branch]
	lda $0BA0.w		; AD A0 0B ; Load $0BA0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $47		; D0 47 ; Branch if not equal to $D0, $47 [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	jsl $0683EA.l		; 22 EA 83 06 ; Jump to subroutine long $0683EA.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsl $0683E6.l		; 22 E6 83 06 ; Jump to subroutine long $0683E6.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $1D		; 90 1D ; Branch if carry clear to $90, $1D [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda #$A0.b		; A9 A0 ; Load #$A0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	jsl $06EDC5.l		; 22 C5 ED 06 ; Jump to subroutine long $06EDC5.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F40.w		; 8D 40 0F ; Store accumulator to $0F40.w [Reads: Accumulator]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F30.w		; 8D 30 0F ; Store accumulator to $0F30.w [Reads: Accumulator]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $37		; 90 37 ; Branch if carry clear to $90, $37 [Flow: branch]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0D		; F0 0D ; Branch if equal to $F0, $0D [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda #$36.b		; A9 36 ; Load #$36.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	jsr $DB96.w		; 20 96 DB ; Jump to subroutine at $DB96.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	lda #$29.b		; A9 29 ; Load #$29.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA12.l		; 22 12 EA 06 ; Jump to subroutine long $06EA12.l [Writes: Stack Pointer] [Flow: call]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0DA0.w,X		; 1D A0 0D ; OR accumulator with memory $0DA0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1A		; D0 1A ; Branch if not equal to $D0, $1A [Flow: branch]
	lda #$7B.b		; A9 7B ; Load #$7B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $12		; 30 12 ; Branch if minus to $30, $12 [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	sta $0D80.w,Y		; 99 80 0D ; Store accumulator to $0D80.w,Y [Reads: Y Index, Accumulator]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,Y		; 99 A0 0D ; Store accumulator to $0DA0.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	jsl $06DBF8.l		; 22 F8 DB 06 ; Jump to subroutine long $06DBF8.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,X		; 9D A0 0B ; Store accumulator to $0BA0.w,X [Reads: Accumulator, X Index]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $DB44.w,Y		; B9 44 DB ; Load $DB44.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	lda #$36.b		; A9 36 ; Load #$36.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0FB5.w		; 8D B5 0F ; Store accumulator to $0FB5.w [Reads: Accumulator]
	jsr $DBA9.w		; 20 A9 DB ; Jump to subroutine at $DBA9.w [Writes: Stack Pointer] [Flow: call]
	dec $0FB5.w		; CE B5 0F ; Decrement $0FB5.w [Flags: NZ]
	.db $D0, $F8		; D0 F8 ; Branch if not equal to $D0, $F8 [Flow: branch]
	lda #$55.b		; A9 55 ; Load #$55.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $4C		; 30 4C ; Branch if minus to $30, $4C [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $0E60.w,Y		; B9 60 0E ; Load $0E60.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$FE.b		; 29 FE ; Logical AND #$FE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,Y		; 99 60 0E ; Store accumulator to $0E60.w,Y [Reads: Y Index, Accumulator]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,Y		; 99 50 0F ; Store accumulator to $0F50.w,Y [Reads: Y Index, Accumulator]
	sta $0E00.w,Y		; 99 00 0E ; Store accumulator to $0E00.w,Y [Reads: Y Index, Accumulator]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,Y		; 99 60 0F ; Store accumulator to $0F60.w,Y [Reads: Y Index, Accumulator]
	sta $0DB0.w,Y		; 99 B0 0D ; Store accumulator to $0DB0.w,Y [Reads: Y Index, Accumulator]
	sta $0E90.w,Y		; 99 90 0E ; Store accumulator to $0E90.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $0FB5.w		; AE B5 0F ; Load $0FB5.w into X register [Writes: X Index] [Flags: NZ]
	lda $DB8A.w,X		; BD 8A DB ; Load $DB8A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $DB90.w,X		; BD 90 DB ; Load $DB90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	sbc $CEFF.w,X		; FD FF CE ; Subtract with carry $CEFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $CE0004.l,X		; FF 04 00 CE ; Subtract with carry (long,X) $CE0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $CEFFFF.l,X		; FF FF FF CE ; Subtract with carry (long,X) $CEFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000CE.l,X		; FF CE 00 00 ; Subtract with carry (long,X) $0000CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $CE0009.l,X		; FF 09 00 CE ; Subtract with carry (long,X) $CE0009.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A9.b		; 00 A9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$DBFE.w		; 69 FE DB ; Add #$DBFE.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $87F0.w		; 4C F0 87 ; Jump to $87F0.w [Flow: jump]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	jmp.w [$DD45]		; DC 45 DD ; Jump long indirect [$DD45] [Flow: jump]
	sbc ($DD.b),Y		; F1 DD ; Subtract with carry ($DD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	ldy #$0B.b		; A0 0B ; Load #$0B.b into Y register [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsr $DC8F.w		; 20 8F DC ; Jump to subroutine at $DC8F.w [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $F1FB05.l		; 0F 05 FB F1 ; OR accumulator with memory (long) $F1FB05.l [Writes: Accumulator] [Flags: NZ]
	trb $0A.b		; 14 0A ; Test and reset bits $0A.b [Reads: Accumulator] [Flags: Z]
	inc $EC.b,X		; F6 EC ; Increment memory $EC.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $FB.b		; 05 FB ; Logical OR $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $40.b,X		; F6 40 ; Increment memory $40.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $79A9FF.l,X		; FF FF A9 79 ; Subtract with carry (long,X) $79A9FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $37		; 30 37 ; Branch if minus to $30, $37 [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,Y		; 99 80 0D ; Store accumulator to $0D80.w,Y [Reads: Y Index, Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $DC8B.w,X		; BD 8B DC ; Load $DC8B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,Y		; 99 10 0F ; Store accumulator to $0F10.w,Y [Reads: Y Index, Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $DC7B.w,X		; BD 7B DC ; Load $DC7B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $DC7B.w,X		; BD 7B DC ; Load $DC7B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$B2.b		; A9 B2 ; Load #$B2.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $63		; 30 63 ; Branch if minus to $30, $63 [Flow: branch]
	lda $EE.b		; A5 EE ; Load $EE.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F20.w,Y		; 99 20 0F ; Store accumulator to $0F20.w,Y [Reads: Y Index, Accumulator]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $0202.w		; AE 02 02 ; Load $0202.w into X register [Writes: X Index] [Flags: NZ]
	lda $7EF33F.l,X		; BF 3F F3 7E ; Load long $7EF33F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $7EF35B.l,X		; BF 5B F3 7E ; Load long $7EF35B.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$08.b		; C9 08 ; Compare #$08.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,Y		; 99 B0 0E ; Store accumulator to $0EB0.w,Y [Reads: Y Index, Accumulator]
	jsr $DC9B.w		; 20 9B DC ; Jump to subroutine at $DC9B.w [Writes: Stack Pointer] [Flow: call]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $DC83.w,X		; BD 83 DC ; Load $DC83.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $DC83.w,X		; BD 83 DC ; Load $DC83.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $DF8A20.l		; 0F 20 8A DF ; OR accumulator with memory (long) $DF8A20.l [Writes: Accumulator] [Flags: NZ]
	jsl $06DBF8.l		; 22 F8 DB 06 ; Jump to subroutine long $06DBF8.l [Writes: Stack Pointer] [Flow: call]
	jsr $DE44.w		; 20 44 DE ; Jump to subroutine at $DE44.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE9B.w		; 20 9B FE ; Jump to subroutine at $FE9B.w [Writes: Stack Pointer] [Flow: call]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	jsl $058008.l		; 22 08 80 05 ; Jump to subroutine long $058008.l [Writes: Stack Pointer] [Flow: call]
	jsr $E02E.w		; 20 2E E0 ; Jump to subroutine at $E02E.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0F10.w,X		; BD 10 0F ; Load $0F10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	lda #$C8.b		; A9 C8 ; Load #$C8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0D		; D0 0D ; Branch if not equal to $D0, $0D [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$08.b		; E9 08 ; Subtract #$08.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $53		; D0 53 ; Branch if not equal to $D0, $53 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $DD41.w,Y		; 79 41 DD ; Add $DD41.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $DD41.w,Y		; 79 41 DD ; Add $DD41.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D90.w,X		; 7D 90 0D ; Add $0D90.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $DE44.w		; 20 44 DE ; Jump to subroutine at $DE44.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $27		; D0 27 ; Branch if not equal to $D0, $27 [Flow: branch]
	jsl $1EDE2E.l		; 22 2E DE 1E ; Jump to subroutine long $1EDE2E.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $19		; 30 19 ; Branch if minus to $30, $19 [Flow: branch]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7EF35C.l,X		; 9F 5C F3 7E ; Store accumulator (long,X) $7EF35C.l,X [Reads: Accumulator, X Index]
	jsl $0DDB7F.l		; 22 7F DB 0D ; Jump to subroutine long $0DDB7F.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$CA.b		; A9 CA ; Load #$CA.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	lda $7EF35C.l,X		; BF 5C F3 7E ; Load long $7EF35C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: NCZ]
	.db $90, $F3		; 90 F3 ; Branch if carry clear to $90, $F3 [Flow: branch]
	ldx #$FF.b		; A2 FF ; Load #$FF.b into X register [Writes: X Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $16		; D0 16 ; Branch if not equal to $D0, $16 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $1CF0.w		; AD F0 1C ; Load $1CF0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$00C8.w		; C9 C8 00 ; Compare #$00C8.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	cmp #$00CA.w		; C9 CA 00 ; Compare #$00CA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda #$28.b		; A9 28 ; Load #$28.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $DE		; 70 DE ; Branch if overflow set to $70, $DE [Flow: branch]
	cmp ($DE.b)		; D2 DE ; Compare accumulator (indirect) ($DE.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc ($DD.b),Y		; F1 DD ; Subtract with carry ($DD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1A		; D0 1A ; Branch if not equal to $D0, $1A [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda $7EF35C.l		; AF 5C F3 7E ; Load long $7EF35C.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $7EF35D.l		; 0F 5D F3 7E ; OR accumulator with memory (long) $7EF35D.l [Writes: Accumulator] [Flags: NZ]
	ora $7EF35E.l		; 0F 5E F3 7E ; OR accumulator with memory (long) $7EF35E.l [Writes: Accumulator] [Flags: NZ]
	ora $7EF35F.l		; 0F 5F F3 7E ; OR accumulator with memory (long) $7EF35F.l [Writes: Accumulator] [Flags: NZ]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $DE90.w		; 20 90 DE ; Jump to subroutine at $DE90.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$79.b		; A9 79 ; Load #$79.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $37		; 30 37 ; Branch if minus to $30, $37 [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,Y		; 99 80 0D ; Store accumulator to $0D80.w,Y [Reads: Y Index, Accumulator]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,Y		; 99 10 0F ; Store accumulator to $0F10.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,Y		; 99 B0 0E ; Store accumulator to $0EB0.w,Y [Reads: Y Index, Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $DC7B.w,X		; BD 7B DC ; Load $DC7B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $DC7B.w,X		; BD 7B DC ; Load $DC7B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	trb $A9.b		; 14 A9 ; Test and reset bits $A9.b [Reads: Accumulator] [Flags: Z]
	ora ($9D.b,X)		; 01 9D ; Logical OR ($9D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldy #$0B.b		; A0 0B ; Load #$0B.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $DF8A.w		; 20 8A DF ; Jump to subroutine at $DF8A.w [Writes: Stack Pointer] [Flow: call]
	jsl $06DBF8.l		; 22 F8 DB 06 ; Jump to subroutine long $06DBF8.l [Writes: Stack Pointer] [Flow: call]
	jsr $DE44.w		; 20 44 DE ; Jump to subroutine at $DE44.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $E02E.w		; 20 2E E0 ; Jump to subroutine at $E02E.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	jsl $058008.l		; 22 08 80 05 ; Jump to subroutine long $058008.l [Writes: Stack Pointer] [Flow: call]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $0EB0.w,X		; BC B0 0E ; Load Y register $0EB0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cmp $DED0.w,Y		; D9 D0 DE ; Compare accumulator $DED0.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $90, $06		; 90 06 ; Branch if carry clear to $90, $06 [Flow: branch]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,X		; 9D AA 0C ; Store accumulator to $0CAA.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F10.w,X		; BD 10 0F ; Load $0F10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $77		; D0 77 ; Branch if not equal to $D0, $77 [Flow: branch]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	lda #$C8.b		; A9 C8 ; Load #$C8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $5E		; D0 5E ; Branch if not equal to $D0, $5E [Flow: branch]
	jsr $DFAB.w		; 20 AB DF ; Jump to subroutine at $DFAB.w [Writes: Stack Pointer] [Flow: call]
	.db $B0, $31		; B0 31 ; Branch if carry set to $B0, $31 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $52		; D0 52 ; Branch if not equal to $D0, $52 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $DD41.w,Y		; 79 41 DD ; Add $DD41.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $DD41.w,Y		; 79 41 DD ; Add $DD41.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $21		; D0 21 ; Branch if not equal to $D0, $21 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,X		; 9D 70 0F ; Store accumulator to $0F70.w,X [Reads: Accumulator, X Index]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $16		; F0 16 ; Branch if equal to $F0, $16 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$F1.b		; 29 F1 ; Logical AND #$F1.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cpy $0FA0.w		; CC A0 0F ; Compare $0FA0.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $33		; F0 33 ; Branch if equal to $F0, $33 [Flow: branch]
	lda $0DD0.w,Y		; B9 D0 0D ; Load $0DD0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $2C		; 90 2C ; Branch if carry clear to $90, $2C [Flow: branch]
	lda $0F00.w,Y		; B9 00 0F ; Load $0F00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $27		; D0 27 ; Branch if not equal to $D0, $27 [Flow: branch]
	lda $0E40.w,Y		; B9 40 0E ; Load $0E40.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $16		; 30 16 ; Branch if minus to $30, $16 [Flow: branch]
	lda $0F20.w,Y		; B9 20 0F ; Load $0F20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $0F20.w,X		; DD 20 0F ; Compare accumulator $0F20.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $1A		; D0 1A ; Branch if not equal to $D0, $1A [Flow: branch]
	lda $0F60.w,Y		; B9 60 0F ; Load $0F60.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	lda $0BA0.w,Y		; B9 A0 0B ; Load $0BA0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $19		; F0 19 ; Branch if equal to $F0, $19 [Flow: branch]
	.db $80, $0C		; 80 0C ; Branch always to $80, $0C [Flow: branch]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	lda $0CD2.w,Y		; B9 D2 0C ; Load $0CD2.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $BF		; 10 BF ; Branch if plus to $10, $BF [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DD631.l		; 22 31 D6 0D ; Jump to subroutine long $0DD631.l [Writes: Stack Pointer] [Flow: call]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $DD41.w,X		; 7D 41 DD ; Add $DD41.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $DD41.w,X		; 7D 41 DD ; Add $DD41.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$2C.b		; A9 2C ; Load #$2C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx $B7.b,Y		; B6 B7 ; Load X register $B7.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $00BD.w,X		; BC BD 00 ; Load Y register $00BD.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $E4.b,X		; 16 E4 ; Arithmetic shift left $E4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $20.b		; 06 20 ; Arithmetic shift left $20.b [Reads: Direct Page] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $E4AD.w,X		; FE AD E4 ; Increment memory $E4AD.w,X [Reads: X Index] [Flags: NZ]
	cop $D0.b		; 02 D0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	.db $D0, $F4		; D0 F4 ; Branch if not equal to $D0, $F4 [Flow: branch]
	ora [$90.b]		; 07 90 ; OR accumulator with memory (long) [$90.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($60.b,X)		; 01 60 ; Logical OR ($60.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $037A.w		; AD 7A 03 ; Load $037A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$DF.b		; 29 DF ; Logical AND #$DF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $037A.w		; 8D 7A 03 ; Store accumulator to $037A.w [Reads: Accumulator]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$30.b		; C9 30 ; Compare #$30.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $3A		; F0 3A ; Branch if equal to $F0, $3A [Flow: branch]
	lda $2F.b		; A5 2F ; Load $2F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $35		; D0 35 ; Branch if not equal to $D0, $35 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $2F		; 90 2F ; Branch if carry clear to $90, $2F [Flow: branch]
	lda $0202.w		; AD 02 02 ; Load $0202.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	bit $F4.b		; 24 F4 ; Test bits $F4.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $70, $06		; 70 06 ; Branch if overflow set to $70, $06 [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$01.b		; C0 01 ; Compare #$01.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $0B		; [PATTERN: Memory clearing operation] D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	stz $0300.w		; 9C 00 03 ; Store zero to $0300.w
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $037A.w		; 8D 7A 03 ; Store accumulator to $037A.w [Reads: Accumulator]
	stz $012E.w		; 9C 2E 01 ; Store zero to $012E.w
	lda $E03C.w,Y		; B9 3C E0 ; Load $E03C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $E03E.w,Y		; B9 3E E0 ; Load $E03E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $2F.b		; A5 2F ; Load $2F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $39		; D0 39 ; Branch if not equal to $D0, $39 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $33		; 90 33 ; Branch if carry clear to $90, $33 [Flow: branch]
	lda $0202.w		; AD 02 02 ; Load $0202.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	bit $F4.b		; 24 F4 ; Test bits $F4.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $70, $06		; 70 06 ; Branch if overflow set to $70, $06 [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$01.b		; C0 01 ; Compare #$01.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $0F		; [PATTERN: Memory clearing operation] D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	stz $0300.w		; 9C 00 03 ; Store zero to $0300.w
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $037A.w		; 8D 7A 03 ; Store accumulator to $037A.w [Reads: Accumulator]
	stz $012E.w		; 9C 2E 01 ; Store zero to $012E.w
	jsl $07866D.l		; 22 6D 86 07 ; Jump to subroutine long $07866D.l [Writes: Stack Pointer] [Flow: call]
	lda $E040.w,Y		; B9 40 E0 ; Load $E040.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $E042.w,Y		; B9 42 E0 ; Load $E042.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $14		; D0 14 ; Branch if not equal to $D0, $14 [Flow: branch]
	lda #$16.b		; A9 16 ; Load #$16.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1F0.l		; 22 F0 E1 05 ; Jump to subroutine long $05E1F0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	lda $7EF3CC.l		; AF CC F3 7E ; Load long $7EF3CC.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00D423.l		; 22 23 D4 00 ; Jump to subroutine long $00D423.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsl $099F39.l		; 22 39 9F 09 ; Jump to subroutine long $099F39.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	bit $E1.b,X		; 34 E1 ; Test bits $E1.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $90, $E1		; 90 E1 ; Branch if carry clear to $90, $E1 [Flow: branch]
	cmp $E21AE1.l,X		; DF E1 1A E2 ; Compare accumulator (long,X) $E21AE1.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $18FF20.l,X		; FF 20 FF 18 ; Subtract with carry (long,X) $18FF20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0FFF18.l		; 0F 18 FF 0F ; OR accumulator with memory (long) $0FFF18.l [Writes: Accumulator] [Flags: NZ]
	jsr $E2C6.w		; 20 C6 E2 ; Jump to subroutine at $E2C6.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $29		; D0 29 ; Branch if not equal to $D0, $29 [Flow: branch]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E90.w,X		; 9D 90 0E ; Store accumulator to $0E90.w,X [Reads: Accumulator, X Index]
	lda $E12C.w,Y		; B9 2C E1 ; Load $E12C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda $E124.w,Y		; B9 24 E1 ; Load $E124.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda #$11.b		; A9 11 ; Load #$11.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	jsr $E256.w		; 20 56 E2 ; Jump to subroutine at $E256.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $06		; 80 06 ; Branch always to $80, $06 [Flow: branch]
	lda #$12.b		; A9 12 ; Load #$12.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $7EF37A.l		; AF 7A F3 7E ; Load long $7EF37A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$05.b		; 29 05 ; Logical AND #$05.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $7EF3C9.l		; AF C9 F3 7E ; Load long $7EF3C9.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$20.b		; 29 20 ; Logical AND #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $E120.w,Y		; B9 20 E1 ; Load $E120.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $E122.w,Y		; B9 22 E1 ; Load $E122.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $E2C6.w		; 20 C6 E2 ; Jump to subroutine at $E2C6.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsr $F391.w		; 20 91 F3 ; Jump to subroutine at $F391.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $30		; 90 30 ; Branch if carry clear to $90, $30 [Flow: branch]
	lda $7EF370.l		; AF 70 F3 7E ; Load long $7EF370.l into accumulator [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0DDB48.l,X		; BF 48 DB 0D ; Load long $0DDB48.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp $7EF343.l		; CF 43 F3 7E ; Compare accumulator (long) $7EF343.l [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	lda #$64.b		; A9 64 ; Load #$64.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $23		; 90 23 ; Branch if carry clear to $90, $23 [Flow: branch]
	lda #$1B.b		; A9 1B ; Load #$1B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF375.l		; 8F 75 F3 7E ; Store accumulator (long) $7EF375.l [Reads: Accumulator]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda #$19.b		; A9 19 ; Load #$19.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	ldy #$28.b		; A0 28 ; Load #$28.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F366.w		; 20 66 F3 ; Jump to subroutine at $F366.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$6E.b		; A9 6E ; Load #$6E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	jsr $F38A.w		; 20 8A F3 ; Jump to subroutine at $F38A.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp $F1A1.w		; 4C A1 F1 ; Jump to $F1A1.w [Flow: jump]
	jsr $E2C6.w		; 20 C6 E2 ; Jump to subroutine at $E2C6.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsr $F391.w		; 20 91 F3 ; Jump to subroutine at $F391.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $24		; 90 24 ; Branch if carry clear to $90, $24 [Flow: branch]
	lda #$64.b		; A9 64 ; Load #$64.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $1C		; 90 1C ; Branch if carry clear to $90, $1C [Flow: branch]
	lda #$0D.b		; A9 0D ; Load #$0D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00D423.l		; 22 23 D4 00 ; Jump to subroutine long $00D423.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsl $099F39.l		; 22 39 9F 09 ; Jump to subroutine long $099F39.l [Writes: Stack Pointer] [Flow: call]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda #$1A.b		; A9 1A ; Load #$1A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp $F1A1.w		; 4C A1 F1 ; Jump to $F1A1.w [Flow: jump]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	cpy $84.b		; C4 84 ; Compare $84.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA88.l		; 22 88 BA 0D ; Jump to subroutine long $0DBA88.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DBF8.l		; 22 F8 DB 06 ; Jump to subroutine long $06DBF8.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$30.b		; 29 30 ; Logical AND #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $E216.w,Y		; 19 16 E2 ; OR accumulator with memory $E216.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	inc $0F80.w,X		; FE 80 0F ; Increment memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$B5.b		; A9 B5 ; Load #$B5.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,Y		; 99 70 0F ; Store accumulator to $0F70.w,Y [Reads: Y Index, Accumulator]
	lda #$F4.b		; A9 F4 ; Load #$F4.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	lda #$17.b		; A9 17 ; Load #$17.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,Y		; 99 F0 0D ; Store accumulator to $0DF0.w,Y [Reads: Y Index, Accumulator]
	lda $0E60.w,Y		; B9 60 0E ; Load $0E60.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$EE.b		; 29 EE ; Logical AND #$EE.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E60.w,Y		; 99 60 0E ; Store accumulator to $0E60.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $000A.w		; 4C 0A 00 ; Jump to $000A.w [Flow: jump]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4E.b		; 00 4E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $0008.w		; 4E 08 00 ; Logical shift right $0008.w [Flags: NCZ]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($85.b,X)		; 01 85 ; Logical OR ($85.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $64.b		; 06 64 ; Arithmetic shift left $64.b [Reads: Direct Page] [Flags: NCZ]
	ora [$BD.b]		; 07 BD ; OR accumulator with memory (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $0E		; 80 0E ; Branch always to $80, $0E [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$96.b		; 69 96 ; Add #$96.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$E2.b		; A9 E2 ; Load #$E2.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	sta [$E4.b]		; 87 E4 ; Store accumulator (long) [$E4.b] [Reads: Direct Page, Accumulator]
	cmp #$E4.b		; C9 E4 ; Compare #$E4.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $E2FEE3.l		; AF E3 FE E2 ; Load long $E2FEE3.l into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $E859.w		; 20 59 E8 ; Jump to subroutine at $E859.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1F		; D0 1F ; Branch if not equal to $D0, $1F [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0C98.w		; E9 98 0C ; Subtract #$0C98.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp #$00D0.w		; C9 D0 00 ; Compare #$00D0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $11		; B0 11 ; Branch if carry set to $B0, $11 [Flow: branch]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$06A5.w		; E9 A5 06 ; Subtract #$06A5.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp #$00D0.w		; C9 D0 00 ; Compare #$00D0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
	lda #$FFFF.w		; A9 FF FF ; Load #$FFFF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$10.b		; 09 10 ; Logical OR #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$F5.b		; A9 F5 ; Load #$F5.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda #$FE.b		; A9 FE ; Load #$FE.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $02F2.w		; AD F2 02 ; Load $02F2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$FC.b		; 29 FC ; Logical AND #$FC.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02F2.w		; 8D F2 02 ; Store accumulator to $02F2.w [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $00.b		; C5 00 ; Compare $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $90, $0B		; 90 0B ; Branch if carry clear to $90, $0B [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $09		; 80 09 ; Branch always to $80, $09 [Flow: branch]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	jsr $E859.w		; 20 59 E8 ; Jump to subroutine at $E859.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; [PATTERN: Memory clearing operation] DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $F4.b,S		; E3 F4 ; Subtract stack-relative $F4.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $33.b,S		; E3 33 ; Subtract stack-relative $33.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cpx $65.b		; E4 65 ; Compare $65.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $76.b		; E4 76 ; Compare $76.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $A9.b		; E4 A9 ; Compare $A9.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $01A0.w,X		; 1E A0 01 ; Arithmetic shift left $01A0.w,X [Reads: X Index] [Flags: NCZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1D		; D0 1D ; Branch if not equal to $D0, $1D [Flow: branch]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $14		; 90 14 ; Branch if carry clear to $90, $14 [Flow: branch]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	lda $02F2.w		; AD F2 02 ; Load $02F2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$03.b		; 09 03 ; Logical OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02F2.w		; 8D F2 02 ; Store accumulator to $02F2.w [Reads: Accumulator]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	lda $02F2.w		; AD F2 02 ; Load $02F2.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$FC.b		; 29 FC ; Logical AND #$FC.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02F2.w		; 8D F2 02 ; Store accumulator to $02F2.w [Reads: Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	inc $02E4.w		; EE E4 02 ; Increment $02E4.w [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$F5.b		; A9 F5 ; Load #$F5.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda #$FE.b		; A9 FE ; Load #$FE.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; [PATTERN: Memory clearing operation] D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $02E0.w		; AD E0 02 ; Load $02E0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $35		; D0 35 ; Branch if not equal to $D0, $35 [Flow: branch]
	lda $037B.w		; AD 7B 03 ; Load $037B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $031F.w		; 0D 1F 03 ; Logical OR $031F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2D		; D0 2D ; Branch if not equal to $D0, $2D [Flow: branch]
	lda $7EF3CC.l		; AF CC F3 7E ; Load long $7EF3CC.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0A.b		; C9 0A ; Compare #$0A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $25		; F0 25 ; Branch if equal to $F0, $25 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $8A.b		; A6 8A ; Load $8A.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $7EF280.l,X		; BF 80 F2 7E ; Load long $7EF280.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	and #$20.b		; 29 20 ; Logical AND #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $19		; D0 19 ; Branch if not equal to $D0, $19 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $13		; 90 13 ; Branch if carry clear to $90, $13 [Flow: branch]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stz $02F9.w		; 9C F9 02 ; Store zero to $02F9.w
	jsl $00D423.l		; 22 23 D4 00 ; Jump to subroutine long $00D423.l [Writes: Stack Pointer] [Flow: call]
	jsl $099EFC.l		; 22 FC 9E 09 ; Jump to subroutine long $099EFC.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $E859.w		; 20 59 E8 ; Jump to subroutine at $E859.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; [PATTERN: Memory clearing operation] DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	stz $0F80.w,X		; 9E 80 0F ; Store zero to $0F80.w,X [Reads: X Index]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	sbc $09E4.w,X		; FD E4 09 ; Subtract with carry $09E4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $82.b		; E5 82 ; Subtract $82.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $39.b		; E5 39 ; Subtract $39.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $82.b		; E5 82 ; Subtract $82.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $39.b		; E5 39 ; Subtract $39.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $82.b		; E5 82 ; Subtract $82.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EE.b		; E5 EE ; Subtract $EE.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $40.b		; E5 40 ; Subtract $40.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $57.b		; E6 57 ; Increment $57.b [Reads: Direct Page] [Flags: NZ]
	inc $6A.b		; E6 6A ; Increment $6A.b [Reads: Direct Page] [Flags: NZ]
	inc $A9.b		; E6 A9 ; Increment $A9.b [Reads: Direct Page] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	lda #$1C.b		; A9 1C ; Load #$1C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$64.b		; A9 64 ; Load #$64.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $E9		; 90 E9 ; Branch if carry clear to $90, $E9 [Flow: branch]
	lda #$1D.b		; A9 1D ; Load #$1D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $02E4.w		; EE E4 02 ; Increment $02E4.w [Flags: NZ]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0DE0.w,X		; 9E E0 0D ; Store zero to $0DE0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $BD1C.w		; 20 1C BD ; Jump to subroutine at $BD1C.w [Writes: Stack Pointer] [Flow: call]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $22		; D0 22 ; Branch if not equal to $D0, $22 [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $E537.w,Y		; B9 37 E5 ; Load $E537.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($06.b,X)		; 61 06 ; Add with carry ($06.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $2406.w		; 4C 06 24 ; Jump to $2406.w [Flow: jump]
	asl $4F.b		; 06 4F ; Arithmetic shift left $4F.b [Reads: Direct Page] [Flags: NCZ]
	ora $5D0F70.l		; 0F 70 0F 5D ; OR accumulator with memory (long) $5D0F70.l [Writes: Accumulator] [Flags: NZ]
	ora $4A1AA5.l		; 0F A5 1A 4A ; OR accumulator with memory (long) $4A1AA5.l [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $E57C.w,Y		; B9 7C E5 ; Load $E57C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0D10.w,X		; FD 10 0D ; Subtract with carry $0D10.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $23		; B0 23 ; Branch if carry set to $B0, $23 [Flow: branch]
	lda $E576.w,Y		; B9 76 E5 ; Load $E576.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0D00.w,X		; FD 00 0D ; Subtract with carry $0D00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$04.b		; [PATTERN: Memory clearing operation] C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $15		; B0 15 ; Branch if carry set to $B0, $15 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $E57C.w,Y		; B9 7C E5 ; Load $E57C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $E57D.w,Y		; B9 7D E5 ; Load $E57D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $E576.w,Y		; B9 76 E5 ; Load $E576.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $E577.w,Y		; B9 77 E5 ; Load $E577.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $A50052.l,X		; FF 52 00 A5 ; Subtract with carry (long,X) $A50052.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $29		; D0 29 ; Branch if not equal to $D0, $29 [Flow: branch]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $24		; D0 24 ; Branch if not equal to $D0, $24 [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $E5E9.w,Y		; B9 E9 E5 ; Load $E5E9.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $19		; 30 19 ; Branch if minus to $30, $19 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $E5EC.w,Y		; B9 EC E5 ; Load $E5EC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $E2E9.w,Y		; B9 E9 E2 ; Load $E2E9.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $E2EB.w,Y		; B9 EB E2 ; Load $E2EB.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; [PATTERN: Memory clearing operation] 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	lda #$01.b		; [PATTERN: Memory clearing operation] A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04C6.w		; 8D C6 04 ; Store accumulator to $04C6.w [Reads: Accumulator]
	stz $B0.b		; 64 B0 ; Store zero to $B0.b
	stz $C8.b		; 64 C8 ; Store zero to $C8.b
	stz $0DE0.w,X		; 9E E0 0D ; Store zero to $0DE0.w,X [Reads: X Index]
	stz $02E4.w		; [PATTERN: Memory clearing operation] 9C E4 02 ; Store zero to $02E4.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda #$25.b		; A9 25 ; Load #$25.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $E67A.w		; 20 7A E6 ; Jump to subroutine at $E67A.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$B6.b		; A9 B6 ; Load #$B6.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $42		; 30 42 ; Branch if minus to $30, $42 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $1A64.w,X		; BD 64 1A ; Load $1A64.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,Y		; 99 B0 0E ; Store accumulator to $0EB0.w,Y [Reads: Y Index, Accumulator]
	sta $0DE0.w,Y		; 99 E0 0D ; Store accumulator to $0DE0.w,Y [Reads: Y Index, Accumulator]
	lda $1A00.w,X		; BD 00 1A ; Load $1A00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $1A14.w,X		; BD 14 1A ; Load $1A14.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $1A28.w,X		; BD 28 1A ; Load $1A28.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $1A3C.w,X		; BD 3C 1A ; Load $1A3C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $EE.b		; A5 EE ; Load $EE.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F20.w,Y		; 99 20 0F ; Store accumulator to $0F20.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0F20.w,Y		; 99 20 0F ; Store accumulator to $0F20.w,Y [Reads: Y Index, Accumulator]
	stz $5E.b		; 64 5E ; Store zero to $5E.b
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $E67A.w		; 20 7A E6 ; Jump to subroutine at $E67A.w [Writes: Stack Pointer] [Flow: call]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $E67A.w		; 20 7A E6 ; Jump to subroutine at $E67A.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,Y		; 99 70 0F ; Store accumulator to $0F70.w,Y [Reads: Y Index, Accumulator]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $20C0.w		; 20 C0 20 ; Jump to subroutine at $20C0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$40.b		; A0 40 ; Load #$40.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $000020.l,X		; FF 20 00 00 ; Subtract with carry (long,X) $000020.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000020.l,X		; FF 20 00 00 ; Subtract with carry (long,X) $000020.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $000020.l,X		; FF 20 00 00 ; Subtract with carry (long,X) $000020.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000020.l,X		; FF 20 00 00 ; Subtract with carry (long,X) $000020.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FFFAFF.l,X		; FF FF FA FF ; Subtract with carry (long,X) $FFFAFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $20FFFA.l,X		; FF FA FF 20 ; Subtract with carry (long,X) $20FFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $004020.l,X		; FF 20 40 00 ; Subtract with carry (long,X) $004020.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $004020.l,X		; FF 20 40 00 ; Subtract with carry (long,X) $004020.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $0001CE.l,X		; FF CE 01 00 ; Subtract with carry (long,X) $0001CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0001CE.l,X		; FF CE 01 00 ; Subtract with carry (long,X) $0001CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0041CE.l,X		; FF CE 41 00 ; Subtract with carry (long,X) $0041CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0041CE.l,X		; FF CE 41 00 ; Subtract with carry (long,X) $0041CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $CEFFFA.l,X		; FF FA FF CE ; Subtract with carry (long,X) $CEFFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $CEFFFA.l,X		; FF FA FF CE ; Subtract with carry (long,X) $CEFFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0041CE.l,X		; FF CE 41 00 ; Subtract with carry (long,X) $0041CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0001CE.l,X		; FF CE 01 00 ; Subtract with carry (long,X) $0001CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0001CA.l,X		; FF CA 01 00 ; Subtract with carry (long,X) $0001CA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0041CA.l,X		; FF CA 41 00 ; Subtract with carry (long,X) $0041CA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CB.b		; 00 CB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CB.b		; 00 CB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0001DB.l,X		; FF DB 01 00 ; Subtract with carry (long,X) $0001DB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0041DB.l,X		; FF DB 41 00 ; Subtract with carry (long,X) $0041DB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$0D.b		; E0 0D ; Compare #$0D.b with X register [Reads: X Index] [Flags: NCZ]
	cmp #$08.b		; C9 08 ; Compare #$08.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $32		; B0 32 ; Branch if carry set to $B0, $32 [Flow: branch]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $E6E9.w,Y		; B9 E9 E6 ; Load $E6E9.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0AE8.w		; 8D E8 0A ; Store accumulator to $0AE8.w [Reads: Accumulator]
	lda $E6EA.w,Y		; B9 EA E6 ; Load $E6EA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0AEA.w		; 8D EA 0A ; Store accumulator to $0AEA.w [Reads: Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$F9.b		; 69 F9 ; Add #$F9.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$E6.b		; A9 E6 ; Load #$E6.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
	lda $0F00.w,X		; BD 00 0F ; Load $0F00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$F9.b		; 69 F9 ; Add #$F9.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$E7.b		; A9 E7 ; Load #$E7.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $87F0.w		; 20 F0 87 ; Jump to subroutine at $87F0.w [Writes: Stack Pointer] [Flow: call]
	lda $0F00.w,X		; BD 00 0F ; Load $0F00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DCE5F.l		; 22 5F CE 0D ; Jump to subroutine long $0DCE5F.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $05DCA2.l		; 22 A2 DC 05 ; Jump to subroutine long $05DCA2.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	lda #$22.b		; A9 22 ; Load #$22.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1F0.l		; 22 F0 E1 05 ; Jump to subroutine long $05E1F0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00D423.l		; 22 23 D4 00 ; Jump to subroutine long $00D423.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsl $099F39.l		; 22 39 9F 09 ; Jump to subroutine long $099F39.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $E8F9.w		; 20 F9 E8 ; Jump to subroutine at $E8F9.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0BA0.w,X		; FE A0 0B ; Increment memory $0BA0.w,X [Reads: X Index] [Flags: NZ]
	lda $A0.b		; A5 A0 ; Load $A0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$E4.b		; C9 E4 ; Compare #$E4.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7EF3CC.l		; AF CC F3 7E ; Load long $7EF3CC.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1E		; D0 1E ; Branch if not equal to $D0, $1E [Flow: branch]
	lda $7EF353.l		; AF 53 F3 7E ; Load long $7EF353.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00D423.l		; 22 23 D4 00 ; Jump to subroutine long $00D423.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $00D423.l		; 22 23 D4 00 ; Jump to subroutine long $00D423.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda #$AD.b		; A9 AD ; Load #$AD.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $1A64.w,X		; BD 64 1A ; Load $1A64.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,Y		; 99 B0 0E ; Store accumulator to $0EB0.w,Y [Reads: Y Index, Accumulator]
	sta $0DE0.w,Y		; 99 E0 0D ; Store accumulator to $0DE0.w,Y [Reads: Y Index, Accumulator]
	lda $1A00.w,X		; BD 00 1A ; Load $1A00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $1A14.w,X		; BD 14 1A ; Load $1A14.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $1A28.w,X		; BD 28 1A ; Load $1A28.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $1A3C.w,X		; BD 3C 1A ; Load $1A3C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $EE.b		; A5 EE ; Load $EE.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F20.w,Y		; 99 20 0F ; Store accumulator to $0F20.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	jsr $E989.w		; 20 89 E9 ; Jump to subroutine at $E989.w [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	stz $5E.b		; 64 5E ; Store zero to $5E.b
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	sta $037B.w		; 8D 7B 03 ; Store accumulator to $037B.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $1DFF0E.l		; 22 0E FF 1D ; Jump to subroutine long $1DFF0E.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	ldx $E9.b		; A6 E9 ; Load $E9.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	nop		; EA ; No operation
	sbc #$B3.b		; E9 B3 ; Subtract #$B3.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	lda ($E9.b),Y		; B1 E9 ; Load accumulator ($E9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($E9.b)		; D2 E9 ; Compare accumulator (indirect) ($E9.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	jsl $05DCA2.l		; 22 A2 DC 05 ; Jump to subroutine long $05DCA2.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	lda #$9C.b		; A9 9C ; Load #$9C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1F0.l		; 22 F0 E1 05 ; Jump to subroutine long $05E1F0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3CC.l		; 8F CC F3 7E ; Store accumulator (long) $7EF3CC.l [Reads: Accumulator]
	jsl $099F39.l		; 22 39 9F 09 ; Jump to subroutine long $099F39.l [Writes: Stack Pointer] [Flow: call]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C8.l		; 8F C8 F3 7E ; Store accumulator (long) $7EF3C8.l [Reads: Accumulator]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jsl $0283B5.l		; 22 B5 83 02 ; Jump to subroutine long $0283B5.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	jsr ($28E9.w,X)		; FC E9 28 ; Jump to subroutine indirect indexed ($28E9.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	nop		; EA ; No operation
	and $EAA3EA.l,X		; 3F EA A3 EA ; AND accumulator with memory (long,X) $EAA3EA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	ldy #$1A.b		; A0 1A ; Load #$1A.b into Y register [Writes: Y Index] [Flags: NZ]
	stz $02E9.w		; 9C E9 02 ; Store zero to $02E9.w
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF3C8.l		; 8F C8 F3 7E ; Store accumulator (long) $7EF3C8.l [Reads: Accumulator]
	jsr $E989.w		; 20 89 E9 ; Jump to subroutine at $E989.w [Writes: Stack Pointer] [Flow: call]
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $E989.w		; 20 89 E9 ; Jump to subroutine at $E989.w [Writes: Stack Pointer] [Flow: call]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; [PATTERN: Memory clearing operation] 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0EB0.w,X		; 9E B0 0E ; Store zero to $0EB0.w,X [Reads: X Index]
	stz $0DE0.w,X		; 9E E0 0D ; Store zero to $0DE0.w,X [Reads: X Index]
	ldy $0FDE.w		; AC DE 0F ; Load $0FDE.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $0B18.w,Y		; B9 18 0B ; Load $0B18.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0B20.w,Y		; B9 20 0B ; Load $0B20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $02.b		; [PATTERN: Memory clearing operation] C5 02 ; Compare $02.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	.db $90, $0A		; 90 0A ; Branch if carry clear to $90, $0A [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0B08.w,Y		; B9 08 0B ; Load $0B08.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0B10.w,Y		; B9 10 0B ; Load $0B10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0B18.w,Y		; B9 18 0B ; Load $0B18.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0B20.w,Y		; B9 20 0B ; Load $0B20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; [PATTERN: Memory clearing operation] 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $E989.w		; 20 89 E9 ; Jump to subroutine at $E989.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	stz $037B.w		; [PATTERN: Memory clearing operation] 9C 7B 03 ; Store zero to $037B.w
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $A09F.w,X		; 9E 9F A0 ; Store zero to $A09F.w,X [Reads: X Index]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($F4.b,S),Y		; F3 F4 ; Subtract with carry (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $80BD.w,X		; 1E BD 80 ; Arithmetic shift left $80BD.w,X [Reads: X Index] [Flags: NCZ]
	ora $09F0.w		; 0D F0 09 ; Logical OR $09F0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$A0.b		; A9 A0 ; Load #$A0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EF372.l		; 8F 72 F3 7E ; Store accumulator (long) $7EF372.l [Reads: Accumulator]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $7EF3C5.l		; AF C5 F3 7E ; Load long $7EF3C5.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $05		; B0 05 ; Branch if carry set to $B0, $05 [Flow: branch]
	lda $7EF357.l		; AF 57 F3 7E ; Load long $7EF357.l into accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $EAAD.w,Y		; B9 AD EA ; Load $EAAD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $EAB0.w,Y		; B9 B0 EA ; Load $EAB0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0DCF31.l		; 22 31 CF 0D ; Jump to subroutine long $0DCF31.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	ora $EB.b,S		; [PATTERN: Memory clearing operation] 03 EB ; OR accumulator with stack relative $EB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $1CEB.w		; 0C EB 1C ; Test and set bits $1CEB.w [Reads: Accumulator] [Flags: Z]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	stz $0DA0.w,X		; 9E A0 0D ; Store zero to $0DA0.w,X [Reads: X Index]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $0DA0.w,X		; BC A0 0D ; Load Y register $0DA0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jsl $05E1F0.l		; 22 F0 E1 05 ; Jump to subroutine long $05E1F0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$01.b		; 69 01 ; Add #$01.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	rti		; [PATTERN: Memory clearing operation] 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	stz $EC.b,X		; 74 EC ; Store zero to $EC.b,X [Reads: X Index]
	jmp ($22EC.w,X)		; 7C EC 22 ; Jump indirect indexed to ($22EC.w,X) [Reads: X Index] [Flow: jump]
	stz $F8.b		; 64 F8 ; Store zero to $F8.b
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	.db $F0, $DB		; F0 DB ; Branch if equal to $F0, $DB [Flow: branch]
	asl $20.b		; 06 20 ; Arithmetic shift left $20.b [Reads: Direct Page] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	inc $E820.w,X		; FE 20 E8 ; Increment memory $E820.w,X [Reads: X Index] [Flags: NZ]
	sbc $50BD.w		; ED BD 50 ; Subtract $50BD.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $1D7F29.l		; 0F 29 7F 1D ; OR accumulator with memory (long) $1D7F29.l [Writes: Accumulator] [Flags: NZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	jsr $EDC2.w		; 20 C2 ED ; Jump to subroutine at $EDC2.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $11		; 80 11 ; Branch always to $80, $11 [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jsr $EDC2.w		; 20 C2 ED ; Jump to subroutine at $EDC2.w [Writes: Stack Pointer] [Flow: call]
	dec $0F80.w,X		; DE 80 0F ; Decrement memory $0F80.w,X [Reads: X Index] [Flags: NZ]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	and #$FC.b		; 29 FC ; Logical AND #$FC.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jsr $EDC2.w		; 20 C2 ED ; Jump to subroutine at $EDC2.w [Writes: Stack Pointer] [Flow: call]
	jsr $EC4D.w		; 20 4D EC ; Jump to subroutine at $EC4D.w [Writes: Stack Pointer] [Flow: call]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $63		; D0 63 ; Branch if not equal to $D0, $63 [Flow: branch]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $EC31.w		; 4C 31 EC ; Jump to $EC31.w [Flow: jump]
	jsr $EC74.w		; 20 74 EC ; Jump to subroutine at $EC74.w [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $3A		; D0 3A ; Branch if not equal to $D0, $3A [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0DA0.w,X		; 9D A0 0D ; Store accumulator to $0DA0.w,X [Reads: Accumulator, X Index]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $0F50.w,X		; 5D 50 0F ; Exclusive OR accumulator with memory $0F50.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $0DA0.w,X		; BD A0 0D ; Load $0DA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0D40.w,X		; 1D 40 0D ; OR accumulator with memory $0D40.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	stz $0E90.w,X		; 9E 90 0E ; Store zero to $0E90.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$80.b		; 29 80 ; Logical AND #$80.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $EC74.w		; 20 74 EC ; Jump to subroutine at $EC74.w [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; [PATTERN: Memory clearing operation] 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0EB0.w,X		; 9E B0 0E ; Store zero to $0EB0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $BD02.w,X		; FE 02 BD ; Increment memory $BD02.w,X [Reads: X Index] [Flags: NZ]
	.db $50, $0D		; 50 0D ; Branch if overflow clear to $50, $0D [Flow: branch]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $EC4B.w,Y		; 79 4B EC ; Add $EC4B.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $EC4B.w,Y		; 79 4B EC ; Add $EC4B.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FF84.w		; 20 84 FF ; Jump to subroutine at $FF84.w [Writes: Stack Pointer] [Flow: call]
	jsl $06A72F.l		; 22 2F A7 06 ; Jump to subroutine long $06A72F.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $ED9E.w		; 20 9E ED ; Jump to subroutine at $ED9E.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsr $EE25.w		; 20 25 EE ; Jump to subroutine at $EE25.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	.db $80, $09		; 80 09 ; Branch always to $80, $09 [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	lda ($EC.b)		; B2 EC ; Load accumulator (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $ED.b,S		; 23 ED ; AND accumulator with stack relative $ED.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $ED.b,X		; 55 ED ; Exclusive OR accumulator with memory $ED.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b		; 45 1A ; Exclusive OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $34		; D0 34 ; Branch if not equal to $D0, $34 [Flow: branch]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$0E.b		; A9 0E ; Load #$0E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0F70.w,Y		; B9 70 0F ; Load $0F70.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $22		; D0 22 ; Branch if not equal to $D0, $22 [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0D10.w,Y		; F9 10 0D ; Subtract with carry $0D10.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $14		; B0 14 ; Branch if carry set to $B0, $14 [Flow: branch]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0D00.w,Y		; F9 00 0D ; Subtract with carry $0D00.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	jsr $EDC2.w		; 20 C2 ED ; Jump to subroutine at $EDC2.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	lda $0EB0.w,X		; BD B0 0E ; Load $0EB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	lda $0D40.w,X		; [PATTERN: Memory clearing operation] BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	sta $0E90.w,Y		; 99 90 0E ; Store accumulator to $0E90.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E0FF.w,Y		; F9 FF E0 ; Subtract with carry $E0FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0046E0.l,X		; FF E0 46 00 ; Subtract with carry (long,X) $0046E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0006E0.l,X		; FF E0 06 00 ; Subtract with carry (long,X) $0006E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0006E0.l,X		; FF E0 06 00 ; Subtract with carry (long,X) $0006E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $85.b		; 02 85 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $64.b		; 06 64 ; Arithmetic shift left $64.b [Reads: Direct Page] [Flags: NCZ]
	ora [$BD.b]		; 07 BD ; OR accumulator with memory (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$0D.b		; E0 0D ; Compare #$0D.b with X register [Reads: X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $0DC0.w,X		; 7D C0 0D ; Add $0DC0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$5E.b		; 69 5E ; Add #$5E.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$ED.b		; A9 ED ; Load #$ED.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DC54.l		; 22 54 DC 06 ; Jump to subroutine long $06DC54.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$32.b		; A9 32 ; Load #$32.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$B9.b		; A9 B9 ; Load #$B9.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $12		; 30 12 ; Branch if minus to $30, $12 [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,Y		; 99 B0 0E ; Store accumulator to $0EB0.w,Y [Reads: Y Index, Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp $BD0101.l		; 5C 01 01 BD ; Jump long to $BD0101.l [Flow: jump]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	.db $D0, $33		; D0 33 ; Branch if not equal to $D0, $33 [Flow: branch]
	lda $7EF357.l		; AF 57 F3 7E ; Load long $7EF357.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $EDE4.w,Y		; B9 E4 ED ; Load $EDE4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $EDE6.w,Y		; B9 E6 ED ; Load $EDE6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E1F0.l		; 22 F0 E1 05 ; Jump to subroutine long $05E1F0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $1D		; 90 1D ; Branch if carry clear to $90, $1D [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jsr $EDC2.w		; 20 C2 ED ; Jump to subroutine at $EDC2.w [Writes: Stack Pointer] [Flow: call]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $015E.w,X		; 5D 5E 01 ; Exclusive OR accumulator with memory $015E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($BD.b,X)		; 01 BD ; Logical OR ($BD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	.db $D0, $2B		; D0 2B ; Branch if not equal to $D0, $2B [Flow: branch]
	lda $7EF357.l		; AF 57 F3 7E ; Load long $7EF357.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $EE21.w,Y		; B9 21 EE ; Load $EE21.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $EE23.w,Y		; B9 23 EE ; Load $EE23.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E1F0.l		; 22 F0 E1 05 ; Jump to subroutine long $05E1F0.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $15		; 90 15 ; Branch if carry clear to $90, $15 [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$1B.b		; C9 1B ; Compare #$1B.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $45		; D0 45 ; Branch if not equal to $D0, $45 [Flow: branch]
	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $22.b		; E5 22 ; Subtract $22.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0040.w		; 69 40 00 ; Add #$0040.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0051.w		; C9 51 00 ; Compare #$0051.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $2A		; B0 2A ; Branch if carry set to $B0, $2A [Flow: branch]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $20.b		; E5 20 ; Subtract $20.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$000F.w		; 69 0F 00 ; Add #$000F.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0012.w		; C9 12 00 ; Compare #$0012.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $1B		; B0 1B ; Branch if carry set to $B0, $1B [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda #$23.b		; A9 23 ; Load #$23.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $11.b		; [PATTERN: Memory clearing operation] 85 11 ; Store accumulator to $11.b [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02DB.w		; 8D DB 02 ; Store accumulator to $02DB.w [Reads: Accumulator]
	stz $B0.b		; 64 B0 ; Store zero to $B0.b
	stz $27.b		; 64 27 ; Store zero to $27.b
	stz $28.b		; 64 28 ; Store zero to $28.b
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $5D.b		; 85 5D ; Store accumulator to $5D.b [Reads: Accumulator]
	lda $8A.b		; A5 8A ; Load $8A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7B.b		; 85 7B ; Store accumulator to $7B.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $EE56.w,Y		; B9 56 EE ; Load $EE56.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F50.w,X		; 1D 50 0F ; OR accumulator with memory $0F50.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBA84.l		; 22 84 BA 0D ; Jump to subroutine long $0DBA84.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0005.w		; E9 05 00 ; Subtract #$0005.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FD8.w		; 8D D8 0F ; Store accumulator to $0FD8.w [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$2E.b		; [PATTERN: Memory clearing operation] A9 2E ; Load #$2E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $11.b		; 85 11 ; Store accumulator to $11.b [Reads: Accumulator]
	stz $B0.b		; 64 B0 ; Store zero to $B0.b
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0D90.w,X		; 9E 90 0D ; Store zero to $0D90.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	ora ($EF.b)		; 12 EF ; OR accumulator with memory (indirect) ($EF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $EF		; 90 EF ; Branch if carry clear to $90, $EF [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	.db $F0, $F3		; F0 F3 ; Branch if equal to $F0, $F3 [Flow: branch]
	.db $F0, $4F		; F0 4F ; Branch if equal to $F0, $4F [Flow: branch]
	sbc ($4F.b),Y		; F1 4F ; Subtract with carry ($4F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($6E.b),Y		; F1 6E ; Subtract with carry ($6E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F2.b),Y		; F1 F2 ; Subtract with carry ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($30.b),Y		; F1 30 ; Subtract with carry ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($7D.b)		; F2 7D ; Subtract with carry (indirect) ($7D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($AF.b)		; F2 AF ; Subtract with carry (indirect) ($AF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F0.b)		; F2 F0 ; Subtract with carry (indirect) ($F0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($22.b)		; F2 22 ; Subtract with carry (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($AD.b,S),Y		; F3 AD ; Subtract with carry (stack relative indirect indexed) ($AD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $39F00F.l,X		; FF 0F F0 39 ; Subtract with carry (long,X) $39F00F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $06F864.l		; 22 64 F8 06 ; Jump to subroutine long $06F864.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	ldy $0FFF.w		; AC FF 0F ; Load $0FFF.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $EF69.w,Y		; B9 69 EF ; Load $EF69.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $EF6B.w,Y		; B9 6B EF ; Load $EF6B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	.db $80, $3F		; 80 3F ; Branch always to $80, $3F [Flow: branch]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsl $05F91B.l		; 22 1B F9 05 ; Jump to subroutine long $05F91B.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	.db $80, $CC		; 80 CC ; Branch always to $80, $CC [Flow: branch]
	adc $5F.b		; 65 5F ; Add $5F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
.ACCU 16
	rep #$20		; C2 20
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0060.w		; 69 60 00 ; Add #$0060.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp $20.b		; C5 20 ; Compare $20.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	.db $90, $13		; 90 13 ; Branch if carry clear to $90, $13 [Flow: branch]
	ldy $0FFF.w		; AC FF 0F ; Load $0FFF.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $EF69.w,Y		; B9 69 EF ; Load $EF69.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $EF6B.w,Y		; B9 6B EF ; Load $EF6B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06F864.l		; 22 64 F8 06 ; Jump to subroutine long $06F864.l [Writes: Stack Pointer] [Flow: call]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	lda $EFD5EF.l,X		; BF EF D5 EF ; Load long $EFD5EF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $04C4.w		; AD C4 04 ; Load $04C4.w into accumulator [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1A		; D0 1A ; Branch if not equal to $D0, $1A [Flow: branch]
	lda #$1E.b		; A9 1E ; Load #$1E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $11		; 90 11 ; Branch if carry clear to $90, $11 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04C4.w		; 8D C4 04 ; Store accumulator to $04C4.w [Reads: Accumulator]
	lda #$64.b		; A9 64 ; Load #$64.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$61.b		; A9 61 ; Load #$61.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $04C4.w		; AD C4 04 ; Load $04C4.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda #$63.b		; A9 63 ; Load #$63.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	cpy #$03.b		; C0 03 ; Compare #$03.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	jsl $06F864.l		; 22 64 F8 06 ; Jump to subroutine long $06F864.l [Writes: Stack Pointer] [Flow: call]
	jsl $1DCC9E.l		; 22 9E CC 1D ; Jump to subroutine long $1DCC9E.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F017.w		; 20 17 F0 ; Jump to subroutine at $F017.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	eor $F05DF0.l		; 4F F0 5D F0 ; Exclusive OR accumulator with memory (long) $F05DF0.l [Writes: Accumulator] [Flags: NZ]
	stz $F0.b,X		; 74 F0 ; Store zero to $F0.b,X [Reads: X Index]
	lda #$76.b		; A9 76 ; Load #$76.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0403.w		; AD 03 04 ; Load $0403.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	lda $0403.w		; AD 03 04 ; Load $0403.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0403.w		; 8D 03 04 ; Store accumulator to $0403.w [Reads: Accumulator]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	ldy #$46.b		; A0 46 ; Load #$46.b into Y register [Writes: Y Index] [Flags: NZ]
	jmp $F366.w		; 4C 66 F3 ; Jump to $F366.w [Flow: jump]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FE69.w		; 20 69 FE ; Jump to subroutine at $FE69.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	jsl $0DCDA7.l		; 22 A7 CD 0D ; Jump to subroutine long $0DCDA7.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	stz $B2F0.w		; 9C F0 B2 ; Store zero to $B2F0.w
	.db $F0, $E1		; F0 E1 ; Branch if equal to $F0, $E1 [Flow: branch]
	.db $F0, $AD		; F0 AD ; Branch if equal to $F0, $AD [Flow: branch]
	cpy $04.b		; C4 04 ; Compare $04.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	lda #$7E.b		; A9 7E ; Load #$7E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1A		; D0 1A ; Branch if not equal to $D0, $1A [Flow: branch]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $11		; 90 11 ; Branch if carry clear to $90, $11 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04C4.w		; 8D C4 04 ; Store accumulator to $04C4.w [Reads: Accumulator]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $7F.b,S		; 63 7F ; Add with carry (stack relative) $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $04C4.w		; AD C4 04 ; Load $04C4.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $F0DD.w,Y		; B9 DD F0 ; Load $F0DD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $F0DF.w,Y		; B9 DF F0 ; Load $F0DF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F017.w		; 20 17 F0 ; Jump to subroutine at $F017.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc ($20.b),Y		; F1 20 ; Subtract with carry ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($E1.b),Y		; F1 E1 ; Subtract with carry ($E1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $AD		; F0 AD ; Branch if equal to $F0, $AD [Flow: branch]
	cpy $04.b		; C4 04 ; Compare $04.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $9F		; 90 9F ; Branch if carry clear to $90, $9F [Flow: branch]
	lda #$81.b		; A9 81 ; Load #$81.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1CE8.w		; AD E8 1C ; Load $1CE8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1A		; D0 1A ; Branch if not equal to $D0, $1A [Flow: branch]
	lda #$64.b		; A9 64 ; Load #$64.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $11		; 90 11 ; Branch if carry clear to $90, $11 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04C4.w		; 8D C4 04 ; Store accumulator to $04C4.w [Reads: Accumulator]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	inc $0D80.w,X		; FE 80 0D ; Increment memory $0D80.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc [$78.b],Y		; 77 78 ; Add with carry (long indexed) [$78.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $F017.w		; 20 17 F0 ; Jump to subroutine at $F017.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$05.b		; E9 05 ; Subtract #$05.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $F14B.w,Y		; B9 4B F1 ; Load $F14B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $F14D.w,Y		; B9 4D F1 ; Load $F14D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F4CE.w		; 20 CE F4 ; Jump to subroutine at $F4CE.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsr $F391.w		; 20 91 F3 ; Jump to subroutine at $F391.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $17		; 90 17 ; Branch if carry clear to $90, $17 [Flow: branch]
	jsl $1EDE2E.l		; 22 2E DE 1E ; Jump to subroutine long $1EDE2E.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $12		; 30 12 ; Branch if minus to $30, $12 [Flow: branch]
	lda #$96.b		; A9 96 ; Load #$96.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $15		; 90 15 ; Branch if carry clear to $90, $15 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	ldy #$2E.b		; A0 2E ; Load #$2E.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F366.w		; 20 66 F3 ; Jump to subroutine at $F366.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$6D.b		; A9 6D ; Load #$6D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	jsr $F38A.w		; 20 8A F3 ; Jump to subroutine at $F38A.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$7C.b		; A9 7C ; Load #$7C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	jsr $F38A.w		; 20 8A F3 ; Jump to subroutine at $F38A.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pei ($FF.b)		; D4 FF ; Push effective indirect address ($FF.b) [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda #$BB.b		; A9 BB ; Load #$BB.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$0C.b		; A0 0C ; Load #$0C.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $1DF65F.l		; 22 5F F6 1D ; Jump to subroutine long $1DF65F.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0E80.w,Y		; 99 80 0E ; Store accumulator to $0E80.w,Y [Reads: Y Index, Accumulator]
	sta $0BA0.w,Y		; 99 A0 0B ; Store accumulator to $0BA0.w,Y [Reads: Y Index, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1EF1AD.l,X		; 7F AD F1 1E ; Add long $1EF1AD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $1EF1AE.l,X		; 7F AE F1 1E ; Add long $1EF1AE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$27.b		; 69 27 ; Add #$27.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda $0E40.w,Y		; B9 40 0E ; Load $0E40.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$04.b		; 09 04 ; Logical OR #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E40.w,Y		; 99 40 0E ; Store accumulator to $0E40.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F4CE.w		; 20 CE F4 ; Jump to subroutine at $F4CE.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsr $F261.w		; 20 61 F2 ; Jump to subroutine at $F261.w [Writes: Stack Pointer] [Flow: call]
	jsr $F391.w		; 20 91 F3 ; Jump to subroutine at $F391.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $17		; 90 17 ; Branch if carry clear to $90, $17 [Flow: branch]
	lda $7EF35A.l		; AF 5A F3 7E ; Load long $7EF35A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $17		; D0 17 ; Branch if not equal to $D0, $17 [Flow: branch]
	lda #$32.b		; A9 32 ; Load #$32.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $1A		; 90 1A ; Branch if carry clear to $90, $1A [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	ldy #$04.b		; A0 04 ; Load #$04.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F366.w		; 20 66 F3 ; Jump to subroutine at $F366.w [Writes: Stack Pointer] [Flow: call]
	lda #$1C.b		; A9 1C ; Load #$1C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$66.b		; A9 66 ; Load #$66.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	jsr $F38A.w		; 20 8A F3 ; Jump to subroutine at $F38A.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp $F1A1.w		; 4C A1 F1 ; Jump to $F1A1.w [Flow: jump]
	jsr $F4CE.w		; 20 CE F4 ; Jump to subroutine at $F4CE.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsr $F261.w		; 20 61 F2 ; Jump to subroutine at $F261.w [Writes: Stack Pointer] [Flow: call]
	jsr $F391.w		; 20 91 F3 ; Jump to subroutine at $F391.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $19		; 90 19 ; Branch if carry clear to $90, $19 [Flow: branch]
	lda $7EF35A.l		; AF 5A F3 7E ; Load long $7EF35A.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $D7		; B0 D7 ; Branch if carry set to $B0, $D7 [Flow: branch]
	lda #$F4.b		; A9 F4 ; Load #$F4.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $DA		; 90 DA ; Branch if carry clear to $90, $DA [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	ldy #$05.b		; A0 05 ; Load #$05.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F366.w		; 20 66 F3 ; Jump to subroutine at $F366.w [Writes: Stack Pointer] [Flow: call]
	lda #$1C.b		; A9 1C ; Load #$1C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0BA0.w,X		; 9E A0 0B ; Store zero to $0BA0.w,X [Reads: X Index]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B6B.w,X		; 9D 6B 0B ; Store accumulator to $0B6B.w,X [Reads: Accumulator, X Index]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0CAA.w,X		; 9D AA 0C ; Store accumulator to $0CAA.w,X [Reads: Accumulator, X Index]
	lda #$1C.b		; A9 1C ; Load #$1C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	jsl $06F2AA.l		; 22 AA F2 06 ; Jump to subroutine long $06F2AA.l [Writes: Stack Pointer] [Flow: call]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F4CE.w		; 20 CE F4 ; Jump to subroutine at $F4CE.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsr $F391.w		; 20 91 F3 ; Jump to subroutine at $F391.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $1B		; 90 1B ; Branch if carry clear to $90, $1B [Flow: branch]
	lda $7EF36C.l		; AF 6C F3 7E ; Load long $7EF36C.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $7EF36D.l		; CF 6D F3 7E ; Compare accumulator (long) $7EF36D.l [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	ldy #$42.b		; A0 42 ; Load #$42.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F366.w		; 20 66 F3 ; Jump to subroutine at $F366.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F38A.w		; 20 8A F3 ; Jump to subroutine at $F38A.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp $F1A1.w		; 4C A1 F1 ; Jump to $F1A1.w [Flow: jump]
	jsr $F4CE.w		; 20 CE F4 ; Jump to subroutine at $F4CE.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsr $F391.w		; 20 91 F3 ; Jump to subroutine at $F391.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $22		; 90 22 ; Branch if carry clear to $90, $22 [Flow: branch]
	lda $7EF371.l		; AF 71 F3 7E ; Load long $7EF371.l into accumulator [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0DDB58.l,X		; BF 58 DB 0D ; Load long $0DDB58.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp $7EF377.l		; CF 77 F3 7E ; Compare accumulator (long) $7EF377.l [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	lda #$1E.b		; A9 1E ; Load #$1E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $15		; 90 15 ; Branch if carry clear to $90, $15 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	ldy #$44.b		; A0 44 ; Load #$44.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F366.w		; 20 66 F3 ; Jump to subroutine at $F366.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$6E.b		; A9 6E ; Load #$6E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	jsr $F38A.w		; 20 8A F3 ; Jump to subroutine at $F38A.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp $F1A1.w		; 4C A1 F1 ; Jump to $F1A1.w [Flow: jump]
	jsr $F4CE.w		; 20 CE F4 ; Jump to subroutine at $F4CE.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsr $F391.w		; 20 91 F3 ; Jump to subroutine at $F391.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $22		; 90 22 ; Branch if carry clear to $90, $22 [Flow: branch]
	lda $7EF370.l		; AF 70 F3 7E ; Load long $7EF370.l into accumulator [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0DDB48.l,X		; BF 48 DB 0D ; Load long $0DDB48.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp $7EF343.l		; CF 43 F3 7E ; Compare accumulator (long) $7EF343.l [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $D1		; F0 D1 ; Branch if equal to $F0, $D1 [Flow: branch]
	lda #$32.b		; A9 32 ; Load #$32.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $D4		; 90 D4 ; Branch if carry clear to $90, $D4 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	ldy #$31.b		; A0 31 ; Load #$31.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F366.w		; 20 66 F3 ; Jump to subroutine at $F366.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F4CE.w		; 20 CE F4 ; Jump to subroutine at $F4CE.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsr $F391.w		; 20 91 F3 ; Jump to subroutine at $F391.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $17		; 90 17 ; Branch if carry clear to $90, $17 [Flow: branch]
	jsl $1EDE2E.l		; 22 2E DE 1E ; Jump to subroutine long $1EDE2E.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $12		; 30 12 ; Branch if minus to $30, $12 [Flow: branch]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F39E.w		; 20 9E F3 ; Jump to subroutine at $F39E.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $15		; 90 15 ; Branch if carry clear to $90, $15 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	ldy #$0E.b		; A0 0E ; Load #$0E.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F366.w		; 20 66 F3 ; Jump to subroutine at $F366.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$6D.b		; A9 6D ; Load #$6D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	jsr $F38A.w		; 20 8A F3 ; Jump to subroutine at $F38A.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp $F1A1.w		; 4C A1 F1 ; Jump to $F1A1.w [Flow: jump]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	adc [$67.b]		; 67 67 ; Add with carry (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($6A69.w)		; 6C 69 6A ; Jump indirect to ($6A69.w) [Flow: jump]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($9C.b,X)		; 01 9C ; Logical OR ($9C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0799AD.l		; 22 AD 99 07 ; Jump to subroutine long $0799AD.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda $0E80.w,X		; BD 80 0E ; Load $0E80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$07.b		; E9 07 ; Subtract #$07.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $12		; 30 12 ; Branch if minus to $30, $12 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $F358.w,Y		; B9 58 F3 ; Load $F358.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $F35F.w,Y		; B9 5F F3 ; Load $F35F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $05E219.l		; 22 19 E2 05 ; Jump to subroutine long $05E219.l [Writes: Stack Pointer] [Flow: call]
	jsl $0FFAEA.l		; 22 EA FA 0F ; Jump to subroutine long $0FFAEA.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$3C.b		; A9 3C ; Load #$3C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	sty $01.b		; 84 01 ; Store Y register to $01.b [Reads: Y Index]
.ACCU 16
	rep #$20		; C2 20
	lda $7EF360.l		; AF 60 F3 7E ; Load long $7EF360.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $00.b		; C5 00 ; Compare $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $90, $07		; 90 07 ; Branch if carry clear to $90, $07 [Flow: branch]
	sbc $00.b		; E5 00 ; Subtract $00.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7EF360.l		; 8F 60 F3 7E ; Store accumulator (long) $7EF360.l [Reads: Accumulator]
	sec		; 38 ; Set carry flag [Flags: C]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr ($10FF.w,X)		; FC FF 10 ; Jump to subroutine indirect indexed ($10FF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $130010.l,X		; FF 10 00 13 ; Subtract with carry (long,X) $130010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	tsb $3800.w		; 0C 00 38 ; Test and set bits $3800.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $030010.l,X		; FF 10 00 03 ; Subtract with carry (long,X) $030010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $030010.l,X		; FF 10 00 03 ; Subtract with carry (long,X) $030010.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $040000.l		; 0F 00 00 04 ; OR accumulator with memory (long) $040000.l [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $0E		; 80 0E ; Branch always to $80, $0E [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$07.b		; E9 07 ; Subtract #$07.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
	rep #$20		; C2 20
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$F3B6.w		; 69 B6 F3 ; Add #$F3B6.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$0005.w		; A9 05 00 ; Load #$0005.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	jsl $05DF75.l		; 22 75 DF 05 ; Jump to subroutine long $05DF75.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F60.w,X		; BD 60 0F ; Load $0F60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	stz $0F60.w,X		; 9E 60 0F ; Store zero to $0F60.w,X [Reads: X Index]
	jsl $06F129.l		; 22 29 F1 06 ; Jump to subroutine long $06F129.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	jsr $F508.w		; 20 08 F5 ; Jump to subroutine at $F508.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0F60.w,X		; 9D 60 0F ; Store accumulator to $0F60.w,X [Reads: Accumulator, X Index]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0FF540.l		; 22 40 F5 0F ; Jump to subroutine long $0FF540.l [Writes: Stack Pointer] [Flow: call]
	stz $5E.b		; 64 5E ; Store zero to $5E.b
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $62		; D0 62 ; Branch if not equal to $D0, $62 [Flow: branch]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsr $F535.w		; 20 35 F5 ; Jump to subroutine at $F535.w [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$AC.b		; A9 AC ; Load #$AC.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	jsl $09AE64.l		; 22 64 AE 09 ; Jump to subroutine long $09AE64.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,Y		; 99 80 0D ; Store accumulator to $0D80.w,Y [Reads: Y Index, Accumulator]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,Y		; 99 90 0D ; Store accumulator to $0D90.w,Y [Reads: Y Index, Accumulator]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,Y		; 99 70 0F ; Store accumulator to $0F70.w,Y [Reads: Y Index, Accumulator]
	lda #$16.b		; A9 16 ; Load #$16.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,Y		; 99 80 0F ; Store accumulator to $0F80.w,Y [Reads: Y Index, Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $03.b		; A5 03 ; Load $03.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,Y		; 99 40 0D ; Store accumulator to $0D40.w,Y [Reads: Y Index, Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,Y		; 99 50 0D ; Store accumulator to $0D50.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $90BD01.l,X		; FF 01 BD 90 ; Subtract with carry (long,X) $90BD01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $10C9.w		; 0D C9 10 ; Logical OR $10C9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	jsl $06DBF0.l		; 22 F0 DB 06 ; Jump to subroutine long $06DBF0.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $19		; F0 19 ; Branch if equal to $F0, $19 [Flow: branch]
	jsr $FF1E.w		; 20 1E FF ; Jump to subroutine at $FF1E.w [Writes: Stack Pointer] [Flow: call]
	jsr $C26B.w		; 20 6B C2 ; Jump to subroutine at $C26B.w [Writes: Stack Pointer] [Flow: call]
	.db $90, $15		; 90 15 ; Branch if carry clear to $90, $15 [Flow: branch]
	lda #$0B.b		; A9 0B ; Load #$0B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB8A.l		; 22 8A BB 0D ; Jump to subroutine long $0DBB8A.l [Writes: Stack Pointer] [Flow: call]
	lda $7EF372.l		; AF 72 F3 7E ; Load long $7EF372.l into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $7EF372.l		; 8F 72 F3 7E ; Store accumulator (long) $7EF372.l [Reads: Accumulator]
	stz $0DD0.w,X		; 9E D0 0D ; Store zero to $0DD0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	dec $0D90.w,X		; DE 90 0D ; Decrement memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	stz $0F70.w,X		; 9E 70 0F ; Store zero to $0F70.w,X [Reads: X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $F57A.w,Y		; 79 7A F5 ; Add $F57A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $F57A.w,Y		; 79 7A F5 ; Add $F57A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$01.b		; E9 01 ; Subtract #$01.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $1AF88C.l		; 22 8C F8 1A ; Jump to subroutine long $1AF88C.l [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	jsl $1EF4F3.l		; 22 F3 F4 1E ; Jump to subroutine long $1EF4F3.l [Writes: Stack Pointer] [Flow: call]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DF0.w,X		; 9D F0 0D ; Store accumulator to $0DF0.w,X [Reads: Accumulator, X Index]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	lda $0DF0.w,X		; BD F0 0D ; Load $0DF0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	lda #$75.b		; A9 75 ; Load #$75.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $05E1A7.l		; 22 A7 E1 05 ; Jump to subroutine long $05E1A7.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	stz $0DC0.w,X		; 9E C0 0D ; Store zero to $0DC0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1DE0.w		; 8D E0 1D ; Store accumulator to $1DE0.w [Reads: Accumulator]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$AE.b		; E9 AE ; Subtract #$AE.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	jsr $F7C2.w		; 20 C2 F7 ; Jump to subroutine at $F7C2.w [Writes: Stack Pointer] [Flow: call]
	sta $0E90.w,X		; 9D 90 0E ; Store accumulator to $0E90.w,X [Reads: Accumulator, X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$B0.b		; E9 B0 ; Subtract #$B0.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $24		; B0 24 ; Branch if carry set to $B0, $24 [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,X		; 9D 30 0D ; Store accumulator to $0D30.w,X [Reads: Accumulator, X Index]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	.db $80, $D1		; 80 D1 ; Branch always to $80, $D1 [Flow: branch]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $D8		; B0 D8 ; Branch if carry set to $B0, $D8 [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$F8.b		; 29 F8 ; Logical AND #$F8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$F8.b		; 29 F8 ; Logical AND #$F8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	jsr $F7AF.w		; 20 AF F7 ; Jump to subroutine at $F7AF.w [Writes: Stack Pointer] [Flow: call]
	inc $0BA0.w,X		; FE A0 0B ; Increment memory $0BA0.w,X [Reads: X Index] [Flags: NZ]
	stz $02F5.w		; 9C F5 02 ; Store zero to $02F5.w
	lda #$0E.b		; A9 0E ; Load #$0E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,X		; 9D 10 0F ; Store accumulator to $0F10.w,X [Reads: Accumulator, X Index]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $F6D4.w		; 20 D4 F6 ; Jump to subroutine at $F6D4.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $01FF01.l,X		; FF 01 FF 01 ; Subtract with carry (long,X) $01FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0D.b		; C0 0D ; Compare #$0D.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	cmp $F709F6.l,X		; DF F6 09 F7 ; Compare accumulator (long,X) $F709F6.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	jsr $F640.w		; 20 40 F6 ; Jump to subroutine at $F640.w [Writes: Stack Pointer] [Flow: call]
	jsl $09AE40.l		; 22 40 AE 09 ; Jump to subroutine long $09AE40.l [Writes: Stack Pointer] [Flow: call]
	lda $0D10.w,Y		; B9 10 0D ; Load $0D10.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$08.b		; E9 08 ; Subtract #$08.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $0D30.w,Y		; B9 30 0D ; Load $0D30.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $0D00.w,Y		; B9 00 0D ; Load $0D00.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$08.b		; E9 08 ; Subtract #$08.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $0D20.w,Y		; B9 20 0D ; Load $0D20.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F860.w		; 20 60 F8 ; Jump to subroutine at $F860.w [Writes: Stack Pointer] [Flow: call]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0B7C.w		; AD 7C 0B ; Load $0B7C.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0B7D.w		; 0D 7D 0B ; Logical OR $0B7D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0B7E.w		; 0D 7E 0B ; Logical OR $0B7E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0B7F.w		; 0D 7F 0B ; Logical OR $0B7F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $F7A3.w		; 4C A3 F7 ; Jump to $F7A3.w [Flow: jump]
	lda $5B.b		; A5 5B ; Load $5B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	jsl $06F131.l		; 22 31 F1 06 ; Jump to subroutine long $06F131.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $77		; 90 77 ; Branch if carry clear to $90, $77 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DB0.w,X		; 9D B0 0D ; Store accumulator to $0DB0.w,X [Reads: Accumulator, X Index]
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	lda $5D.b		; A5 5D ; Load $5D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$13.b		; C9 13 ; Compare #$13.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $68		; F0 68 ; Branch if equal to $F0, $68 [Flow: branch]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $64		; F0 64 ; Branch if equal to $F0, $64 [Flow: branch]
	lda $0D80.w,X		; BD 80 0D ; Load $0D80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $6B		; D0 6B ; Branch if not equal to $D0, $6B [Flow: branch]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02F5.w		; 8D F5 02 ; Store accumulator to $02F5.w [Reads: Accumulator]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $17		; D0 17 ; Branch if not equal to $D0, $17 [Flow: branch]
	jsr $F7C2.w		; 20 C2 F7 ; Jump to subroutine at $F7C2.w [Writes: Stack Pointer] [Flow: call]
	cmp $0E90.w,X		; DD 90 0E ; Compare accumulator $0E90.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sta $0E90.w,X		; 9D 90 0E ; Store accumulator to $0E90.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	jsr $F7AF.w		; 20 AF F7 ; Jump to subroutine at $F7AF.w [Writes: Stack Pointer] [Flow: call]
	jsr $F901.w		; 20 01 F9 ; Jump to subroutine at $F901.w [Writes: Stack Pointer] [Flow: call]
	lda $A0.b		; A5 A0 ; Load $A0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$24.b		; C9 24 ; Compare #$24.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $F6BD.w,Y		; B9 BD F6 ; Load $F6BD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B7C.w		; 6D 7C 0B ; Add $0B7C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0B7C.w		; 8D 7C 0B ; Store accumulator to $0B7C.w [Reads: Accumulator]
	lda $F6B8.w,Y		; B9 B8 F6 ; Load $F6B8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $0B7D.w		; 6D 7D 0B ; Add $0B7D.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0B7D.w		; 8D 7D 0B ; Store accumulator to $0B7D.w [Reads: Accumulator]
	lda $F6C4.w,Y		; B9 C4 F6 ; Load $F6C4.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B7E.w		; 6D 7E 0B ; Add $0B7E.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0B7E.w		; 8D 7E 0B ; Store accumulator to $0B7E.w [Reads: Accumulator]
	lda $F6CC.w,Y		; B9 CC F6 ; Load $F6CC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $0B7F.w		; 6D 7F 0B ; Add $0B7F.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0B7F.w		; 8D 7F 0B ; Store accumulator to $0B7F.w [Reads: Accumulator]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	jsr $FB49.w		; 20 49 FB ; Jump to subroutine at $FB49.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp $FB34.w		; [PATTERN: Memory clearing operation] 4C 34 FB ; Jump to $FB34.w [Flow: jump]
	lda $0DB0.w,X		; BD B0 0D ; Load $0DB0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	stz $02F5.w		; 9C F5 02 ; Store zero to $02F5.w
	stz $0DB0.w,X		; 9E B0 0D ; Store zero to $0DB0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F87D.w		; 20 7D F8 ; Jump to subroutine at $F87D.w [Writes: Stack Pointer] [Flow: call]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $F6A9.w,Y		; B9 A9 F6 ; Load $F6A9.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $F6B0.w,Y		; B9 B0 F6 ; Load $F6B0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06E87B.l		; 22 7B E8 06 ; Jump to subroutine long $06E87B.l [Writes: Stack Pointer] [Flow: call]
	lda $0FA5.w		; AD A5 0F ; Load $0FA5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	.db $F0, $FF		; F0 FF ; Branch if equal to $F0, $FF [Flow: branch]
	ldy $0000.w		; AC 00 00 ; Load $0000.w into Y register [Writes: Y Index] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0040AC.l,X		; FF AC 40 00 ; Subtract with carry (long,X) $0040AC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $AC0000.l,X		; FF 00 00 AC ; Subtract with carry (long,X) $AC0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	cop $F3.b		; 02 F3 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ACFFF3.l,X		; FF F3 FF AC ; Subtract with carry (long,X) $ACFFF3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ACFFF3.l,X		; FF F3 FF AC ; Subtract with carry (long,X) $ACFFF3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($FF.b,S),Y		; F3 FF ; Subtract with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $ACFF.w,X		; FD FF AC ; Subtract with carry $ACFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ACFFFD.l,X		; FF FD FF AC ; Subtract with carry (long,X) $ACFFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	cop $F6.b		; 02 F6 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ACFFF6.l,X		; FF F6 FF AC ; Subtract with carry (long,X) $ACFFF6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ACFFF6.l,X		; FF F6 FF AC ; Subtract with carry (long,X) $ACFFF6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $0080AC.l,X		; FF AC 80 00 ; Subtract with carry (long,X) $0080AC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ACFFFA.l,X		; FF FA FF AC ; Subtract with carry (long,X) $ACFFFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ACFFF8.l,X		; FF F8 FF AC ; Subtract with carry (long,X) $ACFFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ACFFF8.l,X		; FF F8 FF AC ; Subtract with carry (long,X) $ACFFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $ACFFF8.l,X		; FF F8 FF AC ; Subtract with carry (long,X) $ACFFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $ACFFF8.l,X		; FF F8 FF AC ; Subtract with carry (long,X) $ACFFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	sty $BA.b		; 84 BA ; Store Y register to $BA.b [Reads: Y Index]
	ora $10BD.w		; 0D BD 10 ; Logical OR $10BD.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0A0C29.l		; 0F 29 0C 0A ; OR accumulator with memory (long) $0A0C29.l [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$E0.b		; 69 E0 ; Add #$E0.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$F7.b		; A9 F7 ; Load #$F7.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $87F0.w		; 4C F0 87 ; Jump to $87F0.w [Flow: jump]
	lda $0E90.w,X		; BD 90 0E ; Load $0E90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$B0.b		; E9 B0 ; Subtract #$B0.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $01		; 90 01 ; Branch if carry clear to $90, $01 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $F908.w,Y		; F9 08 F9 ; Subtract with carry $F908.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$F9.b		; 09 F9 ; Logical OR #$F9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($F9.b)		; 12 F9 ; OR accumulator with memory (indirect) ($F9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($F9.b)		; 12 F9 ; OR accumulator with memory (indirect) ($F9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$F9.b		; 09 F9 ; Logical OR #$F9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F946F9.l,X		; 1F F9 46 F9 ; Logical OR long $F946F9.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $F9.b,S		; A3 F9 ; Load accumulator (stack relative) $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($FA.b,X)		; 61 FA ; Add with carry ($FA.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$FA.b		; C0 FA ; Compare #$FA.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $F908FA.l,X		; FF FA 08 F9 ; Subtract with carry (long,X) $F908FA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $0EB0.w,X		; 5D B0 0E ; Exclusive OR accumulator with memory $0EB0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$F8.b		; 29 F8 ; Logical AND #$F8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0D10.w,X		; FD 10 0D ; Subtract with carry $0D10.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sta $0B7C.w		; 8D 7C 0B ; Store accumulator to $0B7C.w [Reads: Accumulator]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B7D.w		; 8D 7D 0B ; Store accumulator to $0B7D.w [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D10.w,X		; 9D 10 0D ; Store accumulator to $0D10.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $0EB0.w,X		; 5D B0 0E ; Exclusive OR accumulator with memory $0EB0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$F8.b		; 29 F8 ; Logical AND #$F8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0D00.w,X		; FD 00 0D ; Subtract with carry $0D00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	sta $0B7E.w		; 8D 7E 0B ; Store accumulator to $0B7E.w [Reads: Accumulator]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B7F.w		; 8D 7F 0B ; Store accumulator to $0B7F.w [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F8AD.w		; 20 AD F8 ; Jump to subroutine at $F8AD.w [Writes: Stack Pointer] [Flow: call]
	jsr $F8D7.w		; 20 D7 F8 ; Jump to subroutine at $F8D7.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$03.b		; 49 03 ; Exclusive OR #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$02.b		; 49 02 ; Exclusive OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	lda $4D.b		; A5 4D ; Load $4D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $F91B.w,Y		; 39 1B F9 ; AND accumulator with memory $F91B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	stz $0D80.w,X		; [PATTERN: Memory clearing operation] 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $4B.b		; 64 4B ; Store zero to $4B.b
	jmp $FB34.w		; 4C 34 FB ; Jump to $FB34.w [Flow: jump]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $F942.w,Y		; 39 42 F9 ; AND accumulator with memory $F942.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $3B		; 80 3B ; Branch always to $80, $3B [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $2B		; 80 2B ; Branch always to $80, $2B [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $1B		; 80 1B ; Branch always to $80, $1B [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$A9.b		; 09 A9 ; Logical OR #$A9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($9D.b,X)		; 01 9D ; Logical OR ($9D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $F99F.w,Y		; 39 9F F9 ; AND accumulator with memory $F99F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $3D		; 80 3D ; Branch always to $80, $3D [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $2D		; 80 2D ; Branch always to $80, $2D [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $1D		; 80 1D ; Branch always to $80, $1D [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$01.b		; C9 01 ; Compare #$01.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora #$05.b		; 09 05 ; Logical OR #$05.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $A90D.w		; 0C 0D A9 ; Test and set bits $A90D.w [Reads: Accumulator] [Flags: Z]
	ora ($9D.b,X)		; 01 9D ; Logical OR ($9D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $F9FE.w,Y		; 39 FE F9 ; AND accumulator with memory $F9FE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $3D		; 80 3D ; Branch always to $80, $3D [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $2D		; 80 2D ; Branch always to $80, $2D [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $1D		; 80 1D ; Branch always to $80, $1D [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	tsb $01A9.w		; 0C A9 01 ; Test and set bits $01A9.w [Reads: Accumulator] [Flags: Z]
	sta $0D80.w,X		; 9D 80 0D ; Store accumulator to $0D80.w,X [Reads: Accumulator, X Index]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $FA5D.w,Y		; 39 5D FA ; AND accumulator with memory $FA5D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $3D		; 80 3D ; Branch always to $80, $3D [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $2D		; 80 2D ; Branch always to $80, $2D [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	.db $80, $1D		; 80 1D ; Branch always to $80, $1D [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $E0BC.w		; 0D BC E0 ; Logical OR $E0BC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F0A5.w		; 0D A5 F0 ; Logical OR $F0A5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $FABC.w,Y		; 39 BC FA ; AND accumulator with memory $FABC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	.db $80, $25		; 80 25 ; Branch always to $80, $25 [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	.db $80, $18		; 80 18 ; Branch always to $80, $18 [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	.db $80, $0B		; 80 0B ; Branch always to $80, $0B [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $030C.w		; 0C 0C 03 ; Test and set bits $030C.w [Reads: Accumulator] [Flags: Z]
	ora $A9.b,S		; 03 A9 ; OR accumulator with stack relative $A9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($9D.b,X)		; 01 9D ; Logical OR ($9D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $0D		; 80 0D ; Branch always to $80, $0D [Flow: branch]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $FAFB.w,Y		; 39 FB FA ; AND accumulator with memory $FAFB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $26		; F0 26 ; Branch if equal to $F0, $26 [Flow: branch]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $16		; 80 16 ; Branch always to $80, $16 [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $0C		; 80 0C ; Branch always to $80, $0C [Flow: branch]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $0D80.w,X		; [PATTERN: Memory clearing operation] 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02F5.w		; 8D F5 02 ; Store accumulator to $02F5.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0D80.w,X		; 9E 80 0D ; Store zero to $0D80.w,X [Reads: X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	stz $4B.b		; 64 4B ; Store zero to $4B.b
	.db $80, $EB		; 80 EB ; Branch always to $80, $EB [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0008.w		; E9 08 00 ; Subtract #$0008.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $22.b		; C5 22 ; Compare $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	dec $0B7C.w		; CE 7C 0B ; Decrement $0B7C.w [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	inc $0B7C.w		; EE 7C 0B ; Increment $0B7C.w [Flags: NZ]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0010.w		; E9 10 00 ; Subtract #$0010.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $20.b		; C5 20 ; Compare $20.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	dec $0B7E.w		; CE 7E 0B ; Decrement $0B7E.w [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	inc $0B7E.w		; EE 7E 0B ; Increment $0B7E.w [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FE78.w		; 20 78 FE ; Jump to subroutine at $FE78.w [Writes: Stack Pointer] [Flow: call]
	lda $0DC0.w,X		; BD C0 0D ; Load $0DC0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	and ($F6.b)		; 32 F6 ; AND accumulator with memory (indirect) ($F6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $FB.b,X		; 94 FB ; Store Y register $FB.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ldx $F4FB.w,Y		; BE FB F4 ; Load X register $F4FB.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora ($FC.b,S),Y		; 13 FC ; OR accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($FC.b,S),Y		; D3 FC ; Compare accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	jsr $F7C2.w		; 20 C2 F7 ; Jump to subroutine at $F7C2.w [Writes: Stack Pointer] [Flow: call]
	cmp #$BE.b		; C9 BE ; Compare #$BE.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	sta $0E90.w,X		; 9D 90 0E ; Store accumulator to $0E90.w,X [Reads: Accumulator, X Index]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	cmp $0E90.w,X		; DD 90 0E ; Compare accumulator $0E90.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	sta $0E90.w,X		; 9D 90 0E ; Store accumulator to $0E90.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	jsr $F7AF.w		; 20 AF F7 ; Jump to subroutine at $F7AF.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1DE0.w		; AD E0 1D ; Load $1DE0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$FF.b		; C9 FF ; Compare #$FF.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $26		; D0 26 ; Branch if not equal to $D0, $26 [Flow: branch]
	jsl $06F131.l		; 22 31 F1 06 ; Jump to subroutine long $06F131.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $20		; 90 20 ; Branch if carry clear to $90, $20 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $07F4F1.l		; 22 F1 F4 07 ; Jump to subroutine long $07F4F1.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $B0, $19		; B0 19 ; Branch if carry set to $B0, $19 [Flow: branch]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	jsl $07F1A3.l		; 22 A3 F1 07 ; Jump to subroutine long $07F1A3.l [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	sta $037B.w		; 8D 7B 03 ; Store accumulator to $037B.w [Reads: Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1DE0.w		; 8D E0 1D ; Store accumulator to $1DE0.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F508.w		; 20 08 F5 ; Jump to subroutine at $F508.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($BD.b,X)		; 01 BD ; Logical OR ($BD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $4B.b		; 85 4B ; Store accumulator to $4B.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02E4.w		; 8D E4 02 ; Store accumulator to $02E4.w [Reads: Accumulator]
	sta $037B.w		; 8D 7B 03 ; Store accumulator to $037B.w [Reads: Accumulator]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $FBF0.w,Y		; B9 F0 FB ; Load $FBF0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $FCFF.w		; 20 FF FC ; Jump to subroutine at $FCFF.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E80.w,X		; 9D 80 0E ; Store accumulator to $0E80.w,X [Reads: Accumulator, X Index]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $3F.b		; 85 3F ; Store accumulator to $3F.b [Reads: Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $41.b		; 85 41 ; Store accumulator to $41.b [Reads: Accumulator]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $3E.b		; 85 3E ; Store accumulator to $3E.b [Reads: Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $40.b		; 85 40 ; Store accumulator to $40.b [Reads: Accumulator]
	inc $0D90.w,X		; FE 90 0D ; Increment memory $0D90.w,X [Reads: X Index] [Flags: NZ]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $33		; D0 33 ; Branch if not equal to $D0, $33 [Flow: branch]
	jsr $F7C2.w		; 20 C2 F7 ; Jump to subroutine at $F7C2.w [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cmp #$B2.b		; C9 B2 ; Compare #$B2.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0A		; 90 0A ; Branch if carry clear to $90, $0A [Flow: branch]
	cmp #$B6.b		; C9 B6 ; Compare #$B6.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	lda #$0B.b		; A9 0B ; Load #$0B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $0DBB7C.l		; 22 7C BB 0D ; Jump to subroutine long $0DBB7C.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cmp $0E90.w,X		; DD 90 0E ; Compare accumulator $0E90.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $1B		; F0 1B ; Branch if equal to $F0, $1B [Flow: branch]
	sta $0E90.w,X		; 9D 90 0E ; Store accumulator to $0E90.w,X [Reads: Accumulator, X Index]
	cmp #$BE.b		; C9 BE ; Compare #$BE.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	inc $0DC0.w,X		; FE C0 0D ; Increment memory $0DC0.w,X [Reads: X Index] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0EB0.w,X		; 9D B0 0E ; Store accumulator to $0EB0.w,X [Reads: Accumulator, X Index]
	jsr $F7AF.w		; 20 AF F7 ; Jump to subroutine at $F7AF.w [Writes: Stack Pointer] [Flow: call]
	jsr $F901.w		; 20 01 F9 ; Jump to subroutine at $F901.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $0D10.w,X		; BD 10 0D ; Load $0D10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$08.b		; E9 08 ; Subtract #$08.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0D30.w,X		; BD 30 0D ; Load $0D30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $0D00.w,X		; BD 00 0D ; Load $0D00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0E.b		; E9 0E ; Subtract #$0E.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0D20.w,X		; BD 20 0D ; Load $0D20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $22.b		; C5 22 ; Compare $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	dec $22.b		; C6 22 ; Decrement $22.b [Reads: Direct Page] [Flags: NZ]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $20.b		; C5 20 ; Compare $20.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	dec $20.b		; C6 20 ; Decrement $20.b [Reads: Direct Page] [Flags: NZ]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	inc $20.b		; E6 20 ; Increment $20.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	dec $0E80.w,X		; DE 80 0E ; Decrement memory $0E80.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $FC28.w		; 4C 28 FC ; Jump to $FC28.w [Flow: jump]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $3F.b		; E5 3F ; Subtract $3F.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $31.b		; 85 31 ; Store accumulator to $31.b [Reads: Accumulator]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $3E.b		; E5 3E ; Subtract $3E.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $30.b		; 85 30 ; Store accumulator to $30.b [Reads: Accumulator]
	ldy $0DE0.w,X		; BC E0 0D ; Load Y register $0DE0.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $FBF0.w,Y		; B9 F0 FB ; Load $FBF0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $26.b		; 85 26 ; Store accumulator to $26.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $07E6A6.l		; 22 A6 E6 07 ; Jump to subroutine long $07E6A6.l [Writes: Stack Pointer] [Flow: call]
	jsl $07F42F.l		; 22 2F F4 07 ; Jump to subroutine long $07F42F.l [Writes: Stack Pointer] [Flow: call]
	jsl $0791B9.l		; 22 B9 91 07 ; Jump to subroutine long $0791B9.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; [PATTERN: Memory clearing operation] 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1A		; D0 1A ; Branch if not equal to $D0, $1A [Flow: branch]
	stz $02E4.w		; 9C E4 02 ; Store zero to $02E4.w
	stz $02F5.w		; 9C F5 02 ; Store zero to $02F5.w
	stz $037B.w		; [PATTERN: Memory clearing operation] 9C 7B 03 ; Store zero to $037B.w
	stz $4B.b		; 64 4B ; Store zero to $4B.b
	stz $31.b		; 64 31 ; Store zero to $31.b
	stz $30.b		; 64 30 ; Store zero to $30.b
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1DE0.w		; 8D E0 1D ; Store accumulator to $1DE0.w [Reads: Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$01.b		; 49 01 ; Exclusive OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $FBF0.w,Y		; B9 F0 FB ; Load $FBF0.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr $FCFF.w		; 20 FF FC ; Jump to subroutine at $FCFF.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	sta $67.b		; 85 67 ; Store accumulator to $67.b [Reads: Accumulator]
	sta $26.b		; 85 26 ; Store accumulator to $26.b [Reads: Accumulator]
	jsl $07E245.l		; 22 45 E2 07 ; Jump to subroutine long $07E245.l [Writes: Stack Pointer] [Flow: call]
	jsl $07E6A6.l		; 22 A6 E6 07 ; Jump to subroutine long $07E6A6.l [Writes: Stack Pointer] [Flow: call]
	jsl $07F42F.l		; 22 2F F4 07 ; Jump to subroutine long $07F42F.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $FD1C.w		; 20 1C FD ; Jump to subroutine at $FD1C.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DC0.w,X		; 9D C0 0D ; Store accumulator to $0DC0.w,X [Reads: Accumulator, X Index]
	lda $1B.b		; A5 1B ; Load $1B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $41		; F0 41 ; Branch if equal to $F0, $41 [Flow: branch]
	lda $0E00.w,X		; BD 00 0E ; Load $0E00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $3C		; D0 3C ; Branch if not equal to $D0, $3C [Flow: branch]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $17		; F0 17 ; Branch if equal to $F0, $17 [Flow: branch]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	lda $0E70.w,X		; BD 70 0E ; Load $0E70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0C.b		; 29 0C ; Logical AND #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $17		; F0 17 ; Branch if equal to $F0, $17 [Flow: branch]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0E00.w,X		; 9D 00 0E ; Store accumulator to $0E00.w,X [Reads: Accumulator, X Index]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$BF.b		; 29 BF ; Logical AND #$BF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	lda $0F50.w,X		; BD 50 0F ; Load $0F50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F50.w,X		; 9D 50 0F ; Store accumulator to $0F50.w,X [Reads: Accumulator, X Index]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$3F.b		; 29 3F ; Logical AND #$3F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $24		; D0 24 ; Branch if not equal to $D0, $24 [Flow: branch]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $07.b		; 85 07 ; Store accumulator to $07.b [Reads: Accumulator]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $06EA22.l		; 22 22 EA 06 ; Jump to subroutine long $06EA22.l [Writes: Stack Pointer] [Flow: call]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0D90.w,X		; 9D 90 0D ; Store accumulator to $0D90.w,X [Reads: Accumulator, X Index]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,X		; 9D E0 0D ; Store accumulator to $0DE0.w,X [Reads: Accumulator, X Index]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $48		; D0 48 ; Branch if not equal to $D0, $48 [Flow: branch]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	lda $0D90.w,X		; BD 90 0D ; Load $0D90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	stz $01.b		; [PATTERN: Memory clearing operation] 64 01 ; Store zero to $01.b
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	stz $03.b		; 64 03 ; Store zero to $03.b
.ACCU 16
	rep #$21		; C2 21
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	lda $0DE0.w,X		; BD E0 0D ; Load $0DE0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	stz $01.b		; [PATTERN: Memory clearing operation] 64 01 ; Store zero to $01.b
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	stz $03.b		; 64 03 ; Store zero to $03.b
.ACCU 16
	rep #$21		; C2 21
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	jsl $0DBA71.l		; 22 71 BA 0D ; Jump to subroutine long $0DBA71.l [Writes: Stack Pointer] [Flow: call]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $FD12.w,Y		; B9 12 FD ; Load $FD12.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0F80.w,X		; 7D 80 0F ; Add $0F80.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	lda $0F70.w,X		; BD 70 0F ; Load $0F70.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$08.b		; A0 08 ; Load #$08.b into Y register [Writes: Y Index] [Flags: NZ]
	cmp #$08.b		; C9 08 ; Compare #$08.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	ldy #$18.b		; A0 18 ; Load #$18.b into Y register [Writes: Y Index] [Flags: NZ]
	cmp #$18.b		; C9 18 ; Compare #$18.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,X		; 9D 70 0F ; Store accumulator to $0F70.w,X [Reads: Accumulator, X Index]
	lda #$FB.b		; A9 FB ; Load #$FB.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0F70.w,X		; 9D 70 0F ; Store accumulator to $0F70.w,X [Reads: Accumulator, X Index]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F80.w,X		; 9D 80 0F ; Store accumulator to $0F80.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$E3.b		; A9 E3 ; Load #$E3.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $1DF65D.l		; 22 5D F6 1D ; Jump to subroutine long $1DF65D.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $2D		; 30 2D ; Branch if minus to $30, $2D [Flow: branch]
	lda $EE.b		; A5 EE ; Load $EE.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0F20.w,Y		; 99 20 0F ; Store accumulator to $0F20.w,Y [Reads: Y Index, Accumulator]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D10.w,Y		; 99 10 0D ; Store accumulator to $0D10.w,Y [Reads: Y Index, Accumulator]
	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D30.w,Y		; 99 30 0D ; Store accumulator to $0D30.w,Y [Reads: Y Index, Accumulator]
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,Y		; 99 00 0D ; Store accumulator to $0D00.w,Y [Reads: Y Index, Accumulator]
	lda $21.b		; A5 21 ; Load $21.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,Y		; 99 20 0D ; Store accumulator to $0D20.w,Y [Reads: Y Index, Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0DE0.w,Y		; 99 E0 0D ; Store accumulator to $0DE0.w,Y [Reads: Y Index, Accumulator]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0F10.w,Y		; 99 10 0F ; Store accumulator to $0F10.w,Y [Reads: Y Index, Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06EAA0.l		; 22 A0 EA 06 ; Jump to subroutine long $06EAA0.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06EACD.l		; 22 CD EA 06 ; Jump to subroutine long $06EACD.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06EAE4.l		; 22 E4 EA 06 ; Jump to subroutine long $06EAE4.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0DD0.w,X		; BD D0 0D ; Load $0DD0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	lda $0FC1.w		; AD C1 0F ; Load $0FC1.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $0CAA.w,X		; BD AA 0C ; Load $0CAA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $07		; 30 07 ; Branch if minus to $30, $07 [Flow: branch]
	lda $0F00.w,X		; BD 00 0F ; Load $0F00.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $BD03.w		; 0C 03 BD ; Test and set bits $BD03.w [Reads: Accumulator] [Flags: Z]
	ldy #$0E.b		; A0 0E ; Load #$0E.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $F0, $79		; F0 79 ; Branch if equal to $F0, $79 [Flow: branch]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $76		; F0 76 ; Branch if equal to $F0, $76 [Flow: branch]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $0D50.w,X		; BD 50 0D ; Load $0D50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	dec $0EA0.w,X		; DE A0 0E ; Decrement memory $0EA0.w,X [Reads: X Index] [Flags: NZ]
	.db $D0, $19		; D0 19 ; Branch if not equal to $D0, $19 [Flow: branch]
	lda $0F40.w,X		; BD 40 0F ; Load $0F40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0A		; B0 0A ; Branch if carry set to $B0, $0A [Flow: branch]
	lda $0F30.w,X		; BD 30 0F ; Load $0F30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda #$90.b		; A9 90 ; Load #$90.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0EA0.w,X		; 9D A0 0E ; Store accumulator to $0EA0.w,X [Reads: Accumulator, X Index]
	lda $0EA0.w,X		; BD A0 0E ; Load $0EA0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $39		; 30 39 ; Branch if minus to $30, $39 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $FE95.w,Y		; 39 95 FE ; AND accumulator with memory $FE95.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2F		; D0 2F ; Branch if not equal to $D0, $2F [Flow: branch]
	lda $0F30.w,X		; BD 30 0F ; Load $0F30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0F40.w,X		; BD 40 0F ; Load $0F40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	lda $0CD2.w,X		; BD D2 0C ; Load $0CD2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $1B		; 30 1B ; Branch if minus to $30, $1B [Flow: branch]
	jsr $8B2E.w		; 20 2E 8B ; Jump to subroutine at $8B2E.w [Writes: Stack Pointer] [Flow: call]
	and #$0F.b		; 29 0F ; Logical AND #$0F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $14		; [PATTERN: Memory clearing operation] F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $08		; B0 08 ; Branch if carry set to $B0, $08 [Flow: branch]
	stz $0F40.w,X		; 9E 40 0F ; Store zero to $0F40.w,X [Reads: X Index]
	stz $0D50.w,X		; 9E 50 0D ; Store zero to $0D50.w,X [Reads: X Index]
	.db $80, $06		; [PATTERN: Memory clearing operation] 80 06 ; Branch always to $80, $06 [Flow: branch]
	stz $0F30.w,X		; 9E 30 0F ; Store zero to $0F30.w,X [Reads: X Index]
	stz $0D40.w,X		; 9E 40 0D ; Store zero to $0D40.w,X [Reads: X Index]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $FF21.w		; 20 21 FF ; Jump to subroutine at $FF21.w [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0D50.w,X		; 9D 50 0D ; Store accumulator to $0D50.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $0D40.w,X		; 9D 40 0D ; Store accumulator to $0D40.w,X [Reads: Accumulator, X Index]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$7A.b		; C9 7A ; Compare #$7A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0EA0.w,X		; 9E A0 0E ; Store zero to $0EA0.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FF62.w		; 20 62 FF ; Jump to subroutine at $FF62.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF28.w		; 20 28 FF ; Jump to subroutine at $FF28.w [Writes: Stack Pointer] [Flow: call]
	jsr $FF34.w		; 20 34 FF ; Jump to subroutine at $FF34.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsr $FF34.w		; 20 34 FF ; Jump to subroutine at $FF34.w [Writes: Stack Pointer] [Flow: call]
	ldx $0FA0.w		; AE A0 0F ; Load $0FA0.w into X register [Writes: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0D60.w,X		; 7D 60 0D ; Add $0D60.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D60.w,X		; 9D 60 0D ; Store accumulator to $0D60.w,X [Reads: Accumulator, X Index]
	lda $0D40.w,X		; BD 40 0D ; Load $0D40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	ora #$F0.b		; 09 F0 ; Logical OR #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $0D00.w,X		; 7D 00 0D ; Add $0D00.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D00.w,X		; 9D 00 0D ; Store accumulator to $0D00.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $0D20.w,X		; 7D 20 0D ; Add $0D20.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0D20.w,X		; 9D 20 0D ; Store accumulator to $0D20.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0F90.w,X		; 7D 90 0F ; Add $0F90.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0F90.w,X		; 9D 90 0F ; Store accumulator to $0F90.w,X [Reads: Accumulator, X Index]
	lda $0F80.w,X		; BD 80 0F ; Load $0F80.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	ora #$F0.b		; 09 F0 ; Logical OR #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $0F70.w,X		; 7D 70 0F ; Add $0F70.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0F70.w,X		; 9D 70 0F ; Store accumulator to $0F70.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $06E416.l		; 22 16 E4 06 ; Jump to subroutine long $06E416.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $7FF9C2.l,X		; BF C2 F9 7F ; Load long $7FF9C2.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$08.b		; C9 08 ; Compare #$08.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cmp #$09.b		; C9 09 ; Compare #$09.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $44		; D0 44 ; Branch if not equal to $D0, $44 [Flow: branch]
	lda $0E60.w,X		; BD 60 0E ; Load $0E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$20.b		; 29 20 ; Logical AND #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $29		; F0 29 ; Branch if equal to $F0, $29 [Flow: branch]
	lda $0FD8.w		; AD D8 0F ; Load $0FD8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$04.b		; E9 04 ; Subtract #$04.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FD8.w		; 8D D8 0F ; Store accumulator to $0FD8.w [Reads: Accumulator]
	lda $0FD9.w		; AD D9 0F ; Load $0FD9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FD9.w		; 8D D9 0F ; Store accumulator to $0FD9.w [Reads: Accumulator]
	lda $0E20.w,X		; BD 20 0E ; Load $0E20.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$DF.b		; C9 DF ; Compare #$DF.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	lda $0FDA.w		; AD DA 0F ; Load $0FDA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$07.b		; E9 07 ; Subtract #$07.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FDA.w		; 8D DA 0F ; Store accumulator to $0FDA.w [Reads: Accumulator]
	lda $0FDB.w		; AD DB 0F ; Load $0FDB.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0FDB.w		; 8D DB 0F ; Store accumulator to $0FDB.w [Reads: Accumulator]
	jsl $059FFA.l		; 22 FA 9F 05 ; Jump to subroutine long $059FFA.l [Writes: Stack Pointer] [Flow: call]
	jsl $0684BD.l		; 22 BD 84 06 ; Jump to subroutine long $0684BD.l [Writes: Stack Pointer] [Flow: call]
	lda $0E40.w,X		; BD 40 0E ; Load $0E40.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $0DBA80.l		; 22 80 BA 0D ; Jump to subroutine long $0DBA80.l [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $FF		; Opcode FF overrunning bank boundry at 0F7FFE. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $FF		; Opcode FF overrunning bank boundry at 0F7FFF. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ENDS
