.BANK 22 SLOT 0
.ORG $0000

.SECTION "Bank22" FORCE

	cmp $8C04CF.l		; CF CF 04 8C ; Compare accumulator (long) $8C04CF.l [Reads: Accumulator] [Flags: NCZ]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $2F43.w		; 0C 43 2F ; Test and set bits $2F43.w [Reads: Accumulator] [Flags: Z]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0302.w		; 0D 02 03 ; Logical OR $0302.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $CB.b		; 00 CB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $32311C.l		; 8F 1C 31 32 ; Store accumulator (long) $32311C.l [Reads: Accumulator]
	ora $F3030F.l,X		; 1F 0F 03 F3 ; Logical OR long $F3030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $C031.w		; 20 31 C0 ; Jump to subroutine at $C031.w [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $43		; 30 43 ; Branch if minus to $30, $43 [Flow: branch]
	pea $1308.w		; F4 08 13 ; Push absolute address $1308.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $B0		; 30 B0 ; Branch if minus to $30, $B0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$D300.w		; C0 00 D3 ; Compare #$D300.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($38.b),Y		; F1 38 ; Subtract with carry ($38.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $F8CC.w		; 8C CC F8 ; Store Y register to $F8CC.w [Reads: Y Index]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	ora $030C04.l		; 0F 04 0C 03 ; OR accumulator with memory (long) $030C04.l [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $85		; 10 85 ; Branch if plus to $10, $85 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $92850F.l		; 0F 0F 85 92 ; OR accumulator with memory (long) $92850F.l [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $43		; 30 43 ; Branch if minus to $30, $43 [Flow: branch]
	pea $8508.w		; F4 08 85 ; Push absolute address $8508.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldx #$0101.w		; A2 01 01 ; Load #$0101.w into X register [Writes: X Index] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sta $AA.b		; 85 AA ; Store accumulator to $AA.b [Reads: Accumulator]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp $7F443B.l		; 5C 3B 44 7F ; Jump long to $7F443B.l [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	ora ($30.b)		; 12 30 ; OR accumulator with memory (indirect) ($30.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $3D.b		; 14 3D ; Test and reset bits $3D.b [Reads: Accumulator] [Flags: Z]
	ora ($1B.b)		; 12 1B ; OR accumulator with memory (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $75.b,X		; 74 75 ; Store zero to $75.b,X [Reads: X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and $101B3F.l,X		; 3F 3F 1B 10 ; AND accumulator with memory (long,X) $101B3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$FE44]		; DC 44 FE ; Jump long indirect [$FE44] [Flow: jump]
	trb $4DE0.w		; 1C E0 4D ; Test and reset bits $4DE0.w [Reads: Accumulator] [Flags: Z]
	tsb $28DC.w		; 0C DC 28 ; Test and set bits $28DC.w [Reads: Accumulator] [Flags: Z]
	ldy $D848.w,X		; BC 48 D8 ; Load Y register $D848.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $DEAE.w		; 2E AE DE ; Rotate left $DEAE.w [Flags: NCZ]
	jsr ($D8FC.w,X)		; FC FC D8 ; Jump to subroutine indirect indexed ($D8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $2F.b		; 05 2F ; Logical OR $2F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($7F.b)		; 12 7F ; OR accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $BD.b,X		; 15 BD ; OR accumulator with memory $BD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($53.b),Y		; 51 53 ; Exclusive OR accumulator with memory ($53.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $793B1F.l		; 0F 1F 3B 79 ; OR accumulator with memory (long) $793B1F.l [Writes: Accumulator] [Flags: NZ]
	sbc $D82173.l,X		; FF 73 21 D8 ; Subtract with carry (long,X) $D82173.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$E874.w		; E0 74 E8 ; Compare #$E874.w with X register [Reads: X Index] [Flags: NCZ]
	jmp ($FCA8.w,X)		; 7C A8 FC ; Jump indirect indexed to ($FCA8.w,X) [Reads: X Index] [Flow: jump]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy $B4.b		; A4 B4 ; Load $B4.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($DCFC.w,X)		; FC FC DC ; Jump to subroutine indirect indexed ($DCFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stz $C8FC.w,X		; 9E FC C8 ; Store zero to $C8FC.w,X [Reads: X Index]
	.db $80, $F9		; 80 F9 ; Branch always to $80, $F9 [Flow: branch]
	adc [$5F.b],Y		; 77 5F ; Add with carry (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $1F17.w,X		; 3E 17 1F ; Rotate left $1F17.w,X [Reads: X Index] [Flags: NCZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $102E.w		; 0E 2E 10 ; Arithmetic shift left $102E.w [Flags: NCZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1F276F.l,X		; FF 6F 27 1F ; Subtract with carry (long,X) $1F276F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00103E.l,X		; 1F 3E 10 00 ; Logical OR long $00103E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	inc $3D.b		; E6 3D ; Increment $3D.b [Reads: Direct Page] [Flags: NZ]
	inc $E0FF.w,X		; FE FF E0 ; Increment memory $E0FF.w,X [Reads: X Index] [Flags: NZ]
	cpx #$7000.w		; E0 00 70 ; Compare #$7000.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$10F8.w		; E0 F8 10 ; Compare #$10F8.w with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8F0E0.l,X		; FF E0 F0 F8 ; Subtract with carry (long,X) $F8F0E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sta $40.b		; 85 40 ; Store accumulator to $40.b [Reads: Accumulator]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $387400.l,X		; 3F 00 74 38 ; AND accumulator with memory (long,X) $387400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsl $FF1400.l		; 22 00 14 FF ; Jump to subroutine long $FF1400.l [Writes: Stack Pointer] [Flow: call]
	adc $7C3F27.l		; 6F 27 3F 7C ; Add with carry (long) $7C3F27.l [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $F83C.w		; CC 3C F8 ; Compare $F83C.w with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$00F8.w		; E0 F8 00 ; Compare #$00F8.w with X register [Reads: X Index] [Flags: NCZ]
	jmp $043E38.l		; 5C 38 3E 04 ; Jump long to $043E38.l [Flow: jump]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $F8FC.w		; CE FC F8 ; Decrement $F8FC.w [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp ($043E.w,X)		; 7C 3E 04 ; Jump indirect indexed to ($043E.w,X) [Reads: X Index] [Flow: jump]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$2E.b]		; 07 2E ; OR accumulator with memory (long) [$2E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $8A.b,X		; 15 8A ; OR accumulator with memory $8A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $02.b,X		; 16 02 ; Arithmetic shift left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $022384.l,X		; 3F 84 23 02 ; AND accumulator with memory (long,X) $022384.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$D0.b],Y		; 17 D0 ; OR accumulator with memory (long indexed) [$D0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$E078.w		; E0 78 E0 ; Compare #$E078.w with X register [Reads: X Index] [Flags: NCZ]
	stz $A8.b,X		; 74 A8 ; Store zero to $A8.b,X [Reads: X Index]
	pea $FE48.w		; F4 48 FE ; Push absolute address $FE48.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $CA8A.w,X		; BD 8A CA ; Load $CA8A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $84.b		; 84 84 ; Store Y register to $84.b [Reads: Y Index]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($9EDC.w,X)		; FC DC 9E ; Jump to subroutine indirect indexed ($9EDC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $8784CE.l,X		; FF CE 84 87 ; Subtract with carry (long,X) $8784CE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $02		; 70 02 ; Branch if overflow set to $70, $02 [Flow: branch]
	asl $72.b		; 06 72 ; Arithmetic shift left $72.b [Reads: Direct Page] [Flags: NCZ]
	bit $40BC.w,X		; 3C BC 40 ; Test bits $40BC.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	jsr $7F84.w		; 20 84 7F ; Jump to subroutine at $7F84.w [Writes: Stack Pointer] [Flow: call]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $70FC.w,X		; 7E FC 70 ; Rotate right $70FC.w,X [Reads: X Index] [Flags: NCZ]
	jsr $CE37.w		; 20 37 CE ; Jump to subroutine at $CE37.w [Writes: Stack Pointer] [Flow: call]
	rol $8B89.w,X		; 3E 89 8B ; Rotate left $8B89.w,X [Reads: X Index] [Flags: NCZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $9A85FE.l		; CF FE 85 9A ; Compare accumulator (long) $9A85FE.l [Reads: Accumulator] [Flags: NCZ]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $F00150.l		; 2F 50 01 F0 ; AND accumulator with memory (long) $F00150.l [Writes: Accumulator] [Flags: NZ]
	and $0A0150.l		; 2F 50 01 0A ; AND accumulator with memory (long) $0A0150.l [Writes: Accumulator] [Flags: NZ]
	bit $6F00.w,X		; 3C 00 6F ; Test bits $6F00.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $2F,$00		; 44 00 2F ; Move block positive $2F,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($3C.b)		; 12 3C ; OR accumulator with memory (indirect) ($3C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $181C3F.l,X		; 7F 3F 1C 18 ; Add long $181C3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $003E.w,X		; 3C 3E 00 ; Test bits $003E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $E7.b		; 04 E7 ; Test and set bits $E7.b [Reads: Accumulator] [Flags: Z]
	mvp $F7,$02		; 44 02 F7 ; Move block positive $F7,$02 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $E000.w		; 0C 00 E0 ; Test and set bits $E000.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $3C		; F0 3C ; Branch if equal to $F0, $3C [Flow: branch]
	asl $3F1F.w,X		; 1E 1F 3F ; Arithmetic shift left $3F1F.w,X [Reads: X Index] [Flags: NCZ]
	adc $080007.l,X		; 7F 07 00 08 ; Add long $080007.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $27010E.l		; 2F 0E 01 27 ; AND accumulator with memory (long) $27010E.l [Writes: Accumulator] [Flags: NZ]
	cop $27.b		; 02 27 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $17.b		; 04 17 ; Test and set bits $17.b [Reads: Accumulator] [Flags: Z]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $303018.l		; 0F 18 30 30 ; OR accumulator with memory (long) $303018.l [Writes: Accumulator] [Flags: NZ]
	and $1F3B.w,Y		; 39 3B 1F ; AND accumulator with memory $1F3B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $7A.b,S		; 83 7A ; Store accumulator (stack relative) $7A.b,S [Reads: Stack Pointer, Accumulator]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pea $8018.w		; F4 18 80 ; Push absolute address $8018.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpx $40.b		; E4 40 ; Compare $40.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $20.b		; E4 20 ; Compare $20.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	tsb $9C0C.w		; 0C 0C 9C ; Test and set bits $9C0C.w [Reads: Accumulator] [Flags: Z]
	jmp.w [$1FF8]		; DC F8 1F ; Jump long indirect [$1FF8] [Flow: jump]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0D01.w,Y		; F9 01 0D ; Subtract with carry $0D01.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$07.b],Y		; F7 07 ; Subtract with carry (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $C3613F.l,X		; 1F 3F 61 C3 ; Logical OR long $C3613F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$9E.b]		; C7 9E ; Compare accumulator (long) [$9E.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldx $00B8.w,Y		; BE B8 00 ; Load X register $00B8.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$0180.w		; C0 80 01 ; Compare #$0180.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	eor $F8.b,S		; 43 F8 ; Exclusive OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $12		; B0 12 ; Branch if carry set to $B0, $12 [Flow: branch]
	pea $0038.w		; F4 38 00 ; Push absolute address $0038.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($000F.w,X)		; FC 0F 00 ; Jump to subroutine indirect indexed ($000F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	and $005E00.l		; 2F 00 5E 00 ; AND accumulator with memory (long) $005E00.l [Writes: Accumulator] [Flags: NZ]
	jmp $7C0044.l		; 5C 44 00 7C ; Jump long to $7C0044.l [Flow: jump]
	cpx #$7B21.w		; E0 21 7B ; Compare #$7B21.w with X register [Reads: X Index] [Flags: NCZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $636130.l,X		; 1F 30 61 63 ; Logical OR long $636130.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $805C5F.l		; 4F 5F 5C 80 ; Exclusive OR accumulator with memory (long) $805C5F.l [Writes: Accumulator] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jmp ($7E40.w)		; 6C 40 7E ; Jump indirect to ($7E40.w) [Flow: jump]
	jmp $CCFE.w		; 4C FE CC ; Jump to $CCFE.w [Flow: jump]
	jsr ($FCD8.w,X)		; FC D8 FC ; Jump to subroutine indirect indexed ($FCD8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	ldy #$BEAC.w		; A0 AC BE ; Load #$BEAC.w into Y register [Writes: Y Index] [Flags: NZ]
	rol $7C3C.w,X		; 3E 3C 7C ; Rotate left $7C3C.w,X [Reads: X Index] [Flags: NCZ]
	cpx $5F.b		; E4 5F ; Compare $5F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $D0.b		; 24 D0 ; Test bits $D0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $D0.b		; 24 D0 ; Test bits $D0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$10.b],Y		; 37 10 ; AND accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0D08.w,Y		; 19 08 0D ; OR accumulator with memory $0D08.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0E.b,X		; 16 0E ; Arithmetic shift left $0E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $3FE00F.l		; 22 0F E0 3F ; Jump to subroutine long $3FE00F.l [Writes: Stack Pointer] [Flow: call]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $169D0A.l		; EF 0A 9D 16 ; Subtract with carry (long) $169D0A.l [Writes: Accumulator] [Flags: NCVZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	tsb $0C3A.w		; 0C 3A 0C ; Test and set bits $0C3A.w [Reads: Accumulator] [Flags: Z]
	pea $A828.w		; F4 28 A8 ; Push absolute address $A828.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc [$6F.b],Y		; 77 6F ; Add with carry (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $FCFE.w,X		; 7E FE FC ; Rotate right $FCFE.w,X [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	ora $1807.w,X		; 1D 07 18 ; OR accumulator with memory $1807.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F070E.l		; 0F 0E 07 0F ; OR accumulator with memory (long) $0F070E.l [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $191C37.l		; 0F 37 1C 19 ; OR accumulator with memory (long) $191C37.l [Writes: Accumulator] [Flags: NZ]
	ora $1F000F.l		; 0F 0F 00 1F ; OR accumulator with memory (long) $1F000F.l [Writes: Accumulator] [Flags: NZ]
	ora $1F0F0F.l,X		; 1F 0F 0F 1F ; Logical OR long $1F0F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $E80F1F.l,X		; 3F 1F 0F E8 ; AND accumulator with memory (long,X) $E80F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$00F0.w		; C0 F0 00 ; Compare #$00F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $F0, $B8		; F0 B8 ; Branch if equal to $F0, $B8 [Flow: branch]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	cpx #$00F0.w		; E0 F0 00 ; Compare #$00F0.w with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $83		; F0 83 ; Branch if equal to $F0, $83 [Flow: branch]
	and ($05.b)		; 32 05 ; AND accumulator with memory (indirect) ($05.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $CF		; F0 CF ; Branch if equal to $F0, $CF [Flow: branch]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $436E.w		; 0E 6E 43 ; Arithmetic shift left $436E.w [Flags: NCZ]
	trb $0F27.w		; 1C 27 0F ; Test and reset bits $0F27.w [Reads: Accumulator] [Flags: Z]
	ora $080F13.l,X		; 1F 13 0F 08 ; Logical OR long $080F13.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $3F3F7E.l,X		; BF 7E 3F 3F ; Load long $3F3F7E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $B4070F.l,X		; 1F 0F 07 B4 ; Logical OR long $B4070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $34,$18		; 44 18 34 ; Move block positive $34,$18 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpx #$F423.w		; E0 23 F4 ; Compare #$F423.w with X register [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	pea $E8F8.w		; F4 F8 E8 ; Push absolute address $E8F8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: NCZ]
	ldy $3C3C.w,X		; BC 3C 3C ; Load Y register $3C3C.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	adc [$00.b]		; 67 00 ; Add with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $7F04.w		; 6E 04 7F ; Rotate right $7F04.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $3F4F3B.l,X		; 5F 3B 4F 3F ; Exclusive OR accumulator with memory (long,X) $3F4F3B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $1F.b		; 24 1F ; Test bits $1F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $5F00.w		; 0C 00 5F ; Test and set bits $5F00.w [Reads: Accumulator] [Flags: Z]
	lsr $7F22.w,X		; 5E 22 7F ; Logical shift right $7F22.w,X [Reads: X Index] [Flags: NCZ]
	ora $3F.b		; 05 3F ; Logical OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $30F80C.l,X		; 1F 0C F8 30 ; Logical OR long $30F80C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	eor $30.b,S		; 43 30 ; Exclusive OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $B0, $F8		; B0 F8 ; Branch if carry set to $B0, $F8 [Flow: branch]
	.db $F0, $D0		; F0 D0 ; Branch if equal to $F0, $D0 [Flow: branch]
	cpx #$C020.w		; E0 20 C0 ; Compare #$C020.w with X register [Reads: X Index] [Flags: NCZ]
	cpy #$F800.w		; C0 00 F8 ; Compare #$F800.w with Y register [Reads: Y Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $F002F8.l		; 22 F8 02 F0 ; Jump to subroutine long $F002F8.l [Writes: Stack Pointer] [Flow: call]
	cpx #$E4C0.w		; E0 C0 E4 ; Compare #$E4C0.w with X register [Reads: X Index] [Flags: NCZ]
	eor $E0FF00.l,X		; 5F 00 FF E0 ; Exclusive OR accumulator with memory (long,X) $E0FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $2F0018.l,X		; BF 18 00 2F ; Load long $2F0018.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $35		; 10 35 ; Branch if plus to $10, $35 [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $071C0B.l,X		; 1F 0B 1C 07 ; Logical OR long $071C0B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $140F.w,X		; 1E 0F 14 ; Arithmetic shift left $140F.w,X [Reads: X Index] [Flags: NCZ]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $3718.w,X		; 1E 18 37 ; Arithmetic shift left $3718.w,X [Reads: X Index] [Flags: NCZ]
	and $1F1F.w,X		; 3D 1F 1F ; AND accumulator with memory $1F1F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$1B.b],Y		; 17 1B ; OR accumulator with memory (long indexed) [$1B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$18.b],Y		; 37 18 ; AND accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldy $78D8.w		; AC D8 78 ; Load $78D8.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $D0, $58		; D0 58 ; Branch if not equal to $D0, $58 [Flow: branch]
	cpy #$F078.w		; C0 78 F0 ; Compare #$F078.w with Y register [Reads: Y Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $F0, $8C		; F0 8C ; Branch if equal to $F0, $8C [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx $F8BC.w		; EC BC F8 ; Compare $F8BC.w with X register [Reads: X Index] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($0006.w,X)		; FC 06 00 ; Jump to subroutine indirect indexed ($0006.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $0B02.w		; 0D 02 0B ; Logical OR $0B02.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$15.b]		; 07 15 ; OR accumulator with memory (long) [$15.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0B1C.w		; 0E 1C 0B ; Arithmetic shift left $0B1C.w [Flags: NCZ]
	ora $0B060F.l,X		; 1F 0F 06 0B ; Logical OR long $0B060F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $160B05.l		; 0F 05 0B 16 ; OR accumulator with memory (long) $160B05.l [Writes: Accumulator] [Flags: NZ]
	ora $000C1F.l,X		; 1F 1F 0C 00 ; Logical OR long $000C1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $F6.b		; 04 F6 ; Test and set bits $F6.b [Reads: Accumulator] [Flags: Z]
	tsb $D82C.w		; 0C 2C D8 ; Test and set bits $D82C.w [Reads: Accumulator] [Flags: Z]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $B0, $34		; B0 34 ; Branch if carry set to $B0, $34 [Flow: branch]
	cpy $F804.w		; CC 04 F8 ; Compare $F804.w with Y register [Reads: Y Index] [Flags: NCZ]
	trb $0CF8.w		; 1C F8 0C ; Test and reset bits $0CF8.w [Reads: Accumulator] [Flags: Z]
	asl $FE.b,X		; 16 FE ; Arithmetic shift left $FE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $B0F8.w,X		; 3C F8 B0 ; Test bits $B0F8.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpy $F4.b		; C4 F4 ; Compare $F4.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $1F19.w		; 2E 19 1F ; Rotate left $1F19.w [Flags: NCZ]
	ora $030E.w		; 0D 0E 03 ; Logical OR $030E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0E.b,X		; 15 0E ; OR accumulator with memory $0E.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1C0E.w,Y		; 19 0E 1C ; OR accumulator with memory $1C0E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $1F3E.w		; 2D 3E 1F ; Logical AND $1F3E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1F1F17.l		; 0F 17 1F 1F ; OR accumulator with memory (long) $1F1F17.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $74		; 10 74 ; Branch if plus to $10, $74 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $78		; B0 78 ; Branch if carry set to $B0, $78 [Flow: branch]
	cpy #$70A8.w		; C0 A8 70 ; Compare #$70A8.w with Y register [Reads: Y Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $38		; 70 38 ; Branch if overflow set to $70, $38 [Flow: branch]
	.db $D0, $18		; D0 18 ; Branch if not equal to $D0, $18 [Flow: branch]
	ldy $7C.b,X		; B4 7C ; Load Y register $7C.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $1F7E7F.l,X		; FF 7F 7E 1F ; Subtract with carry (long,X) $1F7E7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $40AF67.l,X		; 9F 67 AF 40 ; Store accumulator (long,X) $40AF67.l,X [Reads: Accumulator, X Index]
	cmp $084F00.l		; CF 00 4F 08 ; Compare accumulator (long) $084F00.l [Reads: Accumulator] [Flags: NCZ]
	adc $206724.l		; 6F 24 67 20 ; Add with carry (long) $206724.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $FDFF7F.l,X		; FF 7F FF FD ; Subtract with carry (long,X) $FDFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $5377.w,X		; FD 77 53 ; Subtract with carry $5377.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sta [$FE.b]		; 87 FE ; Store accumulator (long) [$FE.b] [Reads: Direct Page, Accumulator]
	asl $F9F8.w		; 0E F8 F9 ; Arithmetic shift left $F9F8.w [Flags: NCZ]
	inc $F5.b		; E6 F5 ; Increment $F5.b [Reads: Direct Page] [Flags: NZ]
	cop $FB.b		; 02 FB ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D6.b		; 00 D6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $F6.b		; 04 F6 ; Test and set bits $F6.b [Reads: Accumulator] [Flags: Z]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	inc $BFFF.w,X		; FE FF BF ; Increment memory $BFFF.w,X [Reads: X Index] [Flags: NZ]
	lda [$E6.b],Y		; B7 E6 ; Load accumulator (long indexed) [$E6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $90.b,S		; 83 90 ; Store accumulator (stack relative) $90.b,S [Reads: Stack Pointer, Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F4307.l,X		; 1F 07 43 3F ; Logical OR long $3F4307.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	adc [$20.b],Y		; 77 20 ; Add with carry (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $7FFF00.l,X		; FF 00 FF 7F ; Subtract with carry (long,X) $7FFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $4F2D2D.l,X		; 1F 2D 2D 4F ; Logical OR long $4F2D2D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$E8.b]		; A7 E8 ; Load accumulator (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $A8.b,S		; 83 A8 ; Store accumulator (stack relative) $A8.b,S [Reads: Stack Pointer, Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$F443.w		; E0 43 F4 ; Compare #$F443.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	nop		; EA ; No operation
	brk $DD.b		; 00 DD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $BCF8.w,X		; FE F8 BC ; Increment memory $BCF8.w,X [Reads: X Index] [Flags: NZ]
	ldy $E3F6.w,X		; BC F6 E3 ; Load Y register $E3F6.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	eor $C184FC.l,X		; 5F FC 84 C1 ; Exclusive OR accumulator with memory (long,X) $C184FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $261D00.l,X		; 1F 00 1D 26 ; Logical OR long $261D00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $FF		; 10 FF ; Branch if plus to $10, $FF [Flow: branch]
	adc $17171F.l,X		; 7F 1F 17 17 ; Add long $17171F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0F213F.l,X		; 1F 3F 21 0F ; Logical OR long $0F213F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $F83E.w,X		; FE 3E F8 ; Increment memory $F83E.w,X [Reads: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$30C8.w		; C0 C8 30 ; Compare #$30C8.w with Y register [Reads: Y Index] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $78		; 30 78 ; Branch if minus to $30, $78 [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $FEFF.w		; 20 FF FE ; Jump to subroutine at $FEFF.w [Writes: Stack Pointer] [Flow: call]
	and $F8.b,S		; 23 F8 ; AND accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($30.b,X)		; 01 30 ; Logical OR ($30.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sta $F0.b		; 85 F0 ; Store accumulator to $F0.b [Reads: Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $BF4300.l,X		; 7F 00 43 BF ; Add long $BF4300.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor $167F11.l,X		; 5F 11 7F 16 ; Exclusive OR accumulator with memory (long,X) $167F11.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $771F7F.l,X		; FF 7F 1F 77 ; Subtract with carry (long,X) $771F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $8468.w		; 6E 68 84 ; Rotate right $8468.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$00F0.w		; E0 F0 00 ; Compare #$00F0.w with X register [Reads: X Index] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $10, $98		; 10 98 ; Branch if plus to $10, $98 [Flow: branch]
	.db $10, $58		; 10 58 ; Branch if plus to $10, $58 [Flow: branch]
	.db $10, $D8		; 10 D8 ; Branch if plus to $10, $D8 [Flow: branch]
	sta $E7.b,S		; 83 E7 ; Store accumulator (stack relative) $E7.b,S [Reads: Stack Pointer, Accumulator]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E8F0.w		; 2C F0 E8 ; Test bits $E8F0.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $FC7F.w,Y		; F9 7F FC ; Subtract with carry $FC7F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $DF67FF.l,X		; 1F FF 67 DF ; Logical OR long $DF67FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $CF		; 50 CF ; Branch if overflow clear to $50, $CF [Flow: branch]
	jmp $2363.w		; 4C 63 23 ; Jump to $2363.w [Flow: jump]
	stz $20.b		; 64 20 ; Store zero to $20.b
	and [$10.b],Y		; 37 10 ; AND accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $AF9FFF.l,X		; FF FF 9F AF ; Subtract with carry (long,X) $AF9FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($5C.b,S),Y		; B3 5C ; Load accumulator (stack relative indirect indexed) ($5C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sta $F83FFE.l		; 8F FE 3F F8 ; Store accumulator (long) $F83FFE.l [Reads: Accumulator]
	sbc $FBE0.w,Y		; F9 E0 FB ; Subtract with carry $FBE0.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc [$32.b],Y		; F7 32 ; Subtract with carry (long indexed) [$32.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $36C4.w,X		; DE C4 36 ; Decrement memory $36C4.w,X [Reads: X Index] [Flags: NZ]
	tsb $CC.b		; 04 CC ; Test and set bits $CC.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $6FE0FF.l		; 22 FF E0 6F ; Jump to subroutine long $6FE0FF.l [Writes: Stack Pointer] [Flow: call]
	sbc $C9.b,X		; F5 C9 ; Subtract $C9.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $3E34CA.l		; 22 CA 34 3E ; Jump to subroutine long $3E34CA.l [Writes: Stack Pointer] [Flow: call]
	ora $473C75.l,X		; 1F 75 3C 47 ; Logical OR long $473C75.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $3B5E.w,X		; 3D 5E 3B ; AND accumulator with memory $3B5E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $1F271F.l		; 2F 1F 27 1F ; AND accumulator with memory (long) $1F271F.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($43.b,S),Y		; 53 43 ; XOR accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $18272F.l,X		; 5F 2F 27 18 ; Exclusive OR accumulator with memory (long,X) $18272F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $DC3E.w,X		; 3C 3E DC ; Test bits $DC3E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	asl $34FC.w		; 0E FC 34 ; Arithmetic shift left $34FC.w [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx $F8.b		; E4 F8 ; Compare $F8.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: NCZ]
	bit $F2D2.w,X		; 3C D2 F2 ; Test bits $F2D2.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	pea $18E4.w		; F4 E4 18 ; Push absolute address $18E4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpx #$010E.w		; E0 0E 01 ; Compare #$010E.w with X register [Reads: X Index] [Flags: NCZ]
	ora $2407.w,Y		; 19 07 24 ; OR accumulator with memory $2407.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $281D2A.l,X		; 1F 2A 1D 28 ; Logical OR long $281D2A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $191F26.l,X		; 1F 26 1F 19 ; Logical OR long $191F26.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2D27.w,Y		; 19 27 2D ; OR accumulator with memory $2D27.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $071927.l		; 2F 27 19 07 ; AND accumulator with memory (long) $071927.l [Writes: Accumulator] [Flags: NZ]
	dec $F4.b,X		; D6 F4 ; Decrement memory $F4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsr ($FC12.w,X)		; FC 12 FC ; Jump to subroutine indirect indexed ($FC12.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ror $CDF0.w		; 6E F0 CD ; Rotate right $CDF0.w [Flags: NCZ]
	inc $FE19.w,X		; FE 19 FE ; Increment memory $FE19.w,X [Reads: X Index] [Flags: NZ]
	inc $F8.b		; E6 F8 ; Increment $F8.b [Reads: Direct Page] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($F2.b)		; F2 F2 ; Subtract with carry (indirect) ($F2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $F9D1.w		; EE D1 F9 ; Increment $F9D1.w [Flags: NZ]
	inc $F8.b		; E6 F8 ; Increment $F8.b [Reads: Direct Page] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tsb $1F30.w		; 0C 30 1F ; Test and set bits $1F30.w [Reads: Accumulator] [Flags: Z]
	eor $3F.b,X		; 55 3F ; Exclusive OR accumulator with memory $3F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and $221F3D.l,X		; 3F 3D 1F 22 ; AND accumulator with memory (long,X) $221F3D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $8B.b		; 84 8B ; Store Y register to $8B.b [Reads: Y Index]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($24.b,S),Y		; 33 24 ; AND accumulator (stack relative indirect indexed) ($24.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $019384.l,X		; 5F 84 93 01 ; Exclusive OR accumulator with memory (long,X) $019384.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pei ($30.b)		; D4 30 ; Push effective indirect address ($30.b) [Reads: Direct Page] [Writes: Stack Pointer]
	trb $8AF8.w		; 1C F8 8A ; Test and reset bits $8AF8.w [Reads: Accumulator] [Flags: Z]
	jsr ($FC0E.w,X)		; FC 0E FC ; Jump to subroutine indirect indexed ($FC0E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	trb $64F8.w		; 1C F8 64 ; Test and reset bits $64F8.w [Reads: Accumulator] [Flags: Z]
	sty $A3.b		; 84 A3 ; Store Y register to $A3.b [Reads: Y Index]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $FA34.w		; CC 34 FA ; Compare $FA34.w with Y register [Reads: Y Index] [Flags: NCZ]
	sty $AB.b		; 84 AB ; Store Y register to $AB.b [Reads: Y Index]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($15.b)		; 32 15 ; AND accumulator with memory (indirect) ($15.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $702B78.l,X		; 1F 78 2B 70 ; Logical OR long $702B78.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($79.b),Y		; 31 79 ; AND accumulator with memory ($79.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $1F14.w,X		; 3C 14 1F ; Test bits $1F14.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	mvn $46,$4E		; 54 4E 46 ; Move block negative $46,$4E [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$4C.b]		; 07 4C ; OR accumulator with memory (long) [$4C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	asl $1AE8.w		; 0E E8 1A ; Arithmetic shift left $1AE8.w [Flags: NCZ]
	.db $D0, $2A		; D0 2A ; Branch if not equal to $D0, $2A [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: NCZ]
	trb $16.b		; 14 16 ; Test and reset bits $16.b [Reads: Accumulator] [Flags: Z]
	rol $1E56.w		; 2E 56 1E ; Rotate left $1E56.w [Flags: NCZ]
	cpx $E018.w		; EC 18 E0 ; Compare $E018.w with X register [Reads: X Index] [Flags: NCZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $65		; 90 65 ; Branch if carry clear to $90, $65 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $783774.l		; 0F 74 37 78 ; OR accumulator with memory (long) $783774.l [Writes: Accumulator] [Flags: NZ]
	and $187C.w,Y		; 39 7C 18 ; AND accumulator with memory $187C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1C.b,S		; 83 1C ; Store accumulator (stack relative) $1C.b,S [Reads: Stack Pointer, Accumulator]
	cop $13.b		; 02 13 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F0FA.w,X)		; FC FA F0 ; Jump to subroutine indirect indexed ($F0FA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lsr $67.b		; 46 67 ; Logical shift right $67.b [Reads: Direct Page] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$F9.b]		; 07 F9 ; OR accumulator with memory (long) [$F9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $59.b		; 06 59 ; Arithmetic shift left $59.b [Reads: Direct Page] [Flags: NCZ]
	ldx $1F.b,Y		; B6 1F ; Load X register $1F.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	.db $F0, $3E		; F0 3E ; Branch if equal to $F0, $3E [Flow: branch]
	cpy $8C6E.w		; CC 6E 8C ; Compare $8C6E.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $8318.w,X		; 1E 18 83 ; Arithmetic shift left $8318.w,X [Reads: X Index] [Flags: NCZ]
	bit $02.b,X		; 34 02 ; Test bits $02.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora ($1F.b,S),Y		; 13 1F ; OR accumulator (stack relative indirect indexed) ($1F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $12020F.l		; 0F 0F 02 12 ; OR accumulator with memory (long) $12020F.l [Writes: Accumulator] [Flags: NZ]
	inc $18.b		; E6 18 ; Increment $18.b [Reads: Direct Page] [Flags: NZ]
	cpx #$344B.w		; E0 4B 34 ; Compare #$344B.w with X register [Reads: X Index] [Flags: NCZ]
	eor $3C.b,S		; 43 3C ; Exclusive OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $7C20.w,X		; 5E 20 7C ; Logical shift right $7C20.w,X [Reads: X Index] [Flags: NCZ]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E002.w		; 1C 02 E0 ; Test and reset bits $E002.w [Reads: Accumulator] [Flags: Z]
	and #$40.b		; 29 40 ; Logical AND #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($43.b,X)		; 41 43 ; Exclusive OR accumulator with memory ($43.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $3F		; 70 3F ; Branch if overflow set to $70, $3F [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$BC.b]		; 07 BC ; OR accumulator with memory (long) [$BC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jmp ($F668.w,X)		; 7C 68 F6 ; Jump indirect indexed to ($F668.w,X) [Reads: X Index] [Flow: jump]
	pei ($6E.b)		; D4 6E ; Push effective indirect address ($6E.b) [Reads: Direct Page] [Writes: Stack Pointer]
	stz $3E.b		; 64 3E ; Store zero to $3E.b
	tsb $303C.w		; 0C 3C 30 ; Test and set bits $303C.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	cpy #$5400.w		; C0 00 54 ; Compare #$5400.w with Y register [Reads: Y Index] [Flags: NCZ]
	sty $2A.b,X		; 94 2A ; Store Y register $2A.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sta ($C2.b)		; 92 C2 ; Store accumulator (indirect) ($C2.b) [Reads: Direct Page, Accumulator]
	cpy $C030.w		; CC 30 C0 ; Compare $C030.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta [$60.b],Y		; 97 60 ; Store accumulator (long indexed) [$60.b],Y [Reads: Direct Page, Y Index, Accumulator]
	eor [$20.b],Y		; 57 20 ; Exclusive OR accumulator with memory (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($5F0C.w,X)		; 7C 0C 5F ; Jump indirect indexed to ($5F0C.w,X) [Reads: X Index] [Flow: jump]
	ora [$4D.b]		; 07 4D ; OR accumulator with memory (long) [$4D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $85.b		; 04 85 ; Test and set bits $85.b [Reads: Accumulator] [Flags: Z]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc ($78.b,S),Y		; 73 78 ; Add with carry (stack relative indirect indexed) ($78.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sty $85.b		; 84 85 ; Store Y register to $85.b [Reads: Y Index]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $D4F648.l		; 5C 48 F6 D4 ; Jump long to $D4F648.l [Flow: jump]
	inc $FEA4.w		; EE A4 FE ; Increment $FEA4.w [Flags: NZ]
	sta [$91.b]		; 87 91 ; Store accumulator (long) [$91.b] [Reads: Direct Page, Accumulator]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	ldy $2A.b,X		; B4 2A ; Load Y register $2A.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora ($02.b)		; 12 02 ; OR accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $C030.w		; CC 30 C0 ; Compare $C030.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($00.b),Y		; 31 00 ; AND accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($7F24.w,X)		; 7C 24 7F ; Jump indirect indexed to ($7F24.w,X) [Reads: X Index] [Flow: jump]
	and $3C3B7B.l		; 2F 7B 3B 3C ; AND accumulator with memory (long) $3C3B7B.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $031F1C.l,X		; 3F 1C 1F 03 ; AND accumulator with memory (long,X) $031F1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $505B.w,X		; 3E 5B 50 ; Rotate left $505B.w,X [Reads: X Index] [Flags: NCZ]
	mvp $20,$23		; 44 23 20 ; Move block positive $20,$23 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	trb $8C03.w		; 1C 03 8C ; Test and reset bits $8C03.w [Reads: Accumulator] [Flags: Z]
	brk $CE.b		; 00 CE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	tsb $C4D6.w		; 0C D6 C4 ; Test and set bits $C4D6.w [Reads: Accumulator] [Flags: Z]
	tsb $FC08.w		; 0C 08 FC ; Test and set bits $FC08.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp ($F23A.w,X)		; 7C 3A F2 ; Jump indirect indexed to ($F23A.w,X) [Reads: X Index] [Flow: jump]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pea $3804.w		; F4 04 38 ; Push absolute address $3804.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpy #$0000.w		; C0 00 00 ; Compare #$0000.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3E13.w,X		; 3D 13 3E ; AND accumulator with memory $3E13.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$16.b]		; 07 16 ; OR accumulator with memory (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1F3F.w		; 0E 3F 1F ; Arithmetic shift left $1F3F.w [Flags: NCZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$3D.b],Y		; 37 3D ; AND accumulator with memory (long indexed) [$3D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $3D171B.l,X		; 3F 1B 17 3D ; AND accumulator with memory (long,X) $3D171B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	pea $BC08.w		; F4 08 BC ; Push absolute address $BC08.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jmp ($58E0.w,X)		; 7C E0 58 ; Jump indirect indexed to ($58E0.w,X) [Reads: X Index] [Flow: jump]
	.db $D0, $B8		; D0 B8 ; Branch if not equal to $D0, $B8 [Flow: branch]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $DCBC.w		; EC BC DC ; Compare $DCBC.w with X register [Reads: X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jsr ($1800.w,X)		; FC 00 18 ; Jump to subroutine indirect indexed ($1800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $B0, $31		; B0 31 ; Branch if carry set to $B0, $31 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $68.b		; 04 68 ; Test and set bits $68.b [Reads: Accumulator] [Flags: Z]
	eor ($48.b,X)		; 41 48 ; Exclusive OR accumulator with memory ($48.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	jsr $2024.w		; 20 24 20 ; Jump to subroutine at $2024.w [Writes: Stack Pointer] [Flow: call]
	jsr $3118.w		; 20 18 31 ; Jump to subroutine at $3118.w [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	jsr $4208.w		; 20 08 42 ; Jump to subroutine at $4208.w [Writes: Stack Pointer] [Flow: call]
	tsb $80.b		; 04 80 ; Test and set bits $80.b [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsr $9074.w		; 20 74 90 ; Jump to subroutine at $9074.w [Writes: Stack Pointer] [Flow: call]
	jsl $420A10.l		; 22 10 0A 42 ; Jump to subroutine long $420A10.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $14		; 80 14 ; Branch always to $80, $14 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $10.b,X		; 74 10 ; Store zero to $10.b,X [Reads: X Index]
	.db $10, $F9		; 10 F9 ; Branch if plus to $10, $F9 [Flow: branch]
	adc $C3847C.l,X		; 7F 7C 84 C3 ; Add long $C3847C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$24.b]		; 67 24 ; Add with carry (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $43.b,S		; C3 43 ; Compare accumulator (stack relative) $43.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	dec $8340.w		; CE 40 83 ; Decrement $8340.w [Flags: NZ]
	stz $0600.w,X		; 9E 00 06 ; Store zero to $0600.w,X [Reads: X Index]
	ora $BC5B2F.l,X		; 1F 2F 5B BC ; Logical OR long $BC5B2F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($58.b),Y		; B1 58 ; Load accumulator ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $013984.l		; 8F 84 39 01 ; Store accumulator (long) $013984.l [Reads: Accumulator]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($F208.w,X)		; FC 08 F2 ; Jump to subroutine indirect indexed ($F208.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $CB		; 30 CB ; Branch if minus to $30, $CB [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$3B		; C2 3B
	cop $DA.b		; 02 DA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $E7.b,S		; 83 E7 ; Store accumulator (stack relative) $E7.b,S [Reads: Stack Pointer, Accumulator]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $F4.b		; 25 F4 ; Logical AND $F4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $C535.w		; CE 35 C5 ; Decrement $C535.w [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $46.b,S		; 03 46 ; OR accumulator with stack relative $46.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $DF.b,S		; 03 DF ; OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $563986.l,X		; 7F 86 39 56 ; Add long $563986.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $3FD0.w,Y		; 39 D0 3F ; AND accumulator with memory $3FD0.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $D3.b,X		; 34 D3 ; Test bits $D3.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc $1F1929.l		; 6F 29 19 1F ; Add with carry (long) $1F1929.l [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($50.b,X)		; 41 50 ; Exclusive OR accumulator with memory ($50.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$84.b],Y		; F7 84 ; Subtract with carry (long indexed) [$84.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $43C2.w,X		; FD C2 43 ; Subtract with carry $43C2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($E060.w,X)		; FC 60 E0 ; Jump to subroutine indirect indexed ($E060.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $FF60FE.l		; 22 FE 60 FF ; Jump to subroutine long $FF60FE.l [Writes: Stack Pointer] [Flow: call]
	eor ($02.b,X)		; 41 02 ; Exclusive OR accumulator with memory ($02.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and [$8D.b],Y		; 37 8D ; AND accumulator with memory (long indexed) [$8D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $E4.b		; C4 E4 ; Compare $E4.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
.ACCU 8
	sep #$E3		; E2 E3
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$16.b]		; 07 16 ; OR accumulator with memory (long) [$16.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1F34.w		; 0D 34 1F ; Logical OR $1F34.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$23.b],Y		; 17 23 ; OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cpy #$F080.w		; C0 80 F0 ; Compare #$F080.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$40F0.w		; C0 F0 40 ; Compare #$40F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$9032.w		; E0 32 90 ; Compare #$9032.w with X register [Reads: X Index] [Flags: NCZ]
	cpy #$18C8.w		; C0 C8 18 ; Compare #$18C8.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $3D4200.l,X		; 3F 00 42 3D ; AND accumulator with memory (long,X) $3D4200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($2D.b)		; 72 2D ; Add with carry (indirect) ($2D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $3A.b		; 45 3A ; Exclusive OR $3A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $181F38.l,X		; 3F 38 1F 18 ; AND accumulator with memory (long,X) $181F38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $433F.w,X		; 3D 3F 43 ; AND accumulator with memory $433F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $3F7E59.l,X		; 7F 59 7E 3F ; Add long $3F7E59.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$6000.w		; C0 00 60 ; Compare #$6000.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $A0		; 80 A0 ; Branch always to $80, $A0 [Flow: branch]
	cpy #$80C0.w		; C0 C0 80 ; Compare #$80C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$A080.w		; E0 80 A0 ; Compare #$A080.w with X register [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $10, $D0		; 10 D0 ; Branch if plus to $10, $D0 [Flow: branch]
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	cpy #$E0A0.w		; C0 A0 E0 ; Compare #$E0A0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$80E0.w		; C0 E0 80 ; Compare #$80E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $2350.w		; 20 50 23 ; Jump to subroutine at $2350.w [Writes: Stack Pointer] [Flow: call]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $63.b		; 84 63 ; Store Y register to $63.b [Reads: Y Index]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1B2615.l		; 2F 15 26 1B ; AND accumulator with memory (long) $1B2615.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $2F1F3E.l		; 2F 3E 1F 2F ; AND accumulator with memory (long) $2F1F3E.l [Writes: Accumulator] [Flags: NZ]
	and [$23.b]		; 27 23 ; AND accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $7B.b		; 84 7B ; Store Y register to $7B.b [Reads: Y Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $A8F4.w		; 6D F4 A8 ; Add $A8F4.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	stz $D8.b		; 64 D8 ; Store zero to $D8.b
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	pea $F87C.w		; F4 7C F8 ; Push absolute address $F87C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	pea $38E4.w		; F4 E4 38 ; Push absolute address $38E4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $3B5C38.l		; 4F 38 5C 3B ; Exclusive OR accumulator with memory (long) $3B5C38.l [Writes: Accumulator] [Flags: NZ]
	and $0E351D.l		; 2F 1D 35 0E ; AND accumulator with memory (long) $0E351D.l [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $77.b,X		; 35 77 ; Logical AND $77.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp $2F7C7F.l		; 5C 7F 7C 2F ; Jump long to $2F7C7F.l [Flow: jump]
	and $4B.b,X		; 35 4B ; Logical AND $4B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$1C.b],Y		; 57 1C ; Exclusive OR accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc ($1C.b)		; F2 1C ; Subtract with carry (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$B8F4]		; DC F4 B8 ; Jump long indirect [$B8F4] [Flow: jump]
	ldy $D270.w		; AC 70 D2 ; Load $D270.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy $DCEE.w		; AC EE DC ; Load $DCEE.w into Y register [Writes: Y Index] [Flags: NZ]
	trb $FE3A.w		; 1C 3A FE ; Test and reset bits $FE3A.w [Reads: Accumulator] [Flags: Z]
	rol $ACF4.w,X		; 3E F4 AC ; Rotate left $ACF4.w,X [Reads: X Index] [Flags: NCZ]
	cmp ($EA.b)		; D2 EA ; Compare accumulator (indirect) ($EA.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $5F1D.w,X		; 3D 1D 5F ; AND accumulator with memory $5F1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4F3F67.l,X		; 1F 67 3F 4F ; Logical OR long $4F3F67.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $1B2E.w,X		; 3C 2E 1B ; Test bits $1B2E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $4F47.w		; 6D 47 4F ; Add $4F47.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and $030C11.l		; 2F 11 0C 03 ; AND accumulator with memory (long) $030C11.l [Writes: Accumulator] [Flags: NZ]
	bit $2AD8.w,X		; 3C D8 2A ; Test bits $2AD8.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpx $3CDA.w		; EC DA 3C ; Compare $3CDA.w with X register [Reads: X Index] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpy $F814.w		; CC 14 F8 ; Compare $F814.w with Y register [Reads: Y Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx $CA12.w		; EC 12 CA ; Compare $CA12.w with X register [Reads: X Index] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	pea $30E8.w		; F4 E8 30 ; Push absolute address $30E8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpy #$0001.w		; C0 01 00 ; Compare #$0001.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $03.b		; 45 03 ; Exclusive OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	asl $3E07.w		; 0E 07 3E ; Arithmetic shift left $3E07.w [Flags: NCZ]
	ora [$7C.b]		; 07 7C ; OR accumulator with memory (long) [$7C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $00807F.l,X		; 3F 7F 80 00 ; AND accumulator with memory (long,X) $00807F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$8044.w		; C0 44 80 ; Compare #$8044.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr $B0C0.w		; 20 C0 B0 ; Jump to subroutine at $B0C0.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $6EE0.w,X		; 3C E0 6E ; Test bits $6EE0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jmp.w [$2280]		; DC 80 22 ; Jump long indirect [$2280] [Flow: jump]
	cpy #$E00E.w		; C0 0E E0 ; Compare #$E00E.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	inc $387B.w,X		; FE 7B 38 ; Increment memory $387B.w,X [Reads: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	ora ($7B.b)		; 12 7B ; OR accumulator with memory (indirect) ($7B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $30.b,X		; 74 30 ; Store zero to $30.b,X [Reads: X Index]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $4B.b		; 84 4B ; Store Y register to $4B.b [Reads: Y Index]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $6D,$6F		; 44 6F 6D ; Move block positive $6D,$6F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	mvp $24,$4B		; 44 4B 24 ; Move block positive $24,$4B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$C6.b]		; 07 C6 ; OR accumulator with memory (long) [$C6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $EE.b		; 04 EE ; Test and set bits $EE.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	brk $92.b		; 00 92 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $DC		; 80 DC ; Branch always to $80, $DC [Flow: branch]
	sty $63.b		; 84 63 ; Store Y register to $63.b [Reads: Y Index]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($3A.b,X)		; 41 3A ; Exclusive OR accumulator with memory ($3A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $BE.b,X		; 16 BE ; Arithmetic shift left $BE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $6E.b		; E6 6E ; Increment $6E.b [Reads: Direct Page] [Flags: NZ]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$7F58.w		; E0 58 7F ; Compare #$7F58.w with X register [Reads: X Index] [Flags: NCZ]
	ora $7F07BF.l		; 0F BF 07 7F ; OR accumulator with memory (long) $7F07BF.l [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $207F00.l,X		; BF 00 7F 20 ; Load long $207F00.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $80194B.l,X		; 1F 4B 19 80 ; Logical OR long $80194B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $5F.b		; 05 5F ; Logical OR $5F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $70A067.l		; 8F 67 A0 70 ; Store accumulator (long) $70A067.l [Reads: Accumulator]
	trb $0519.w		; 1C 19 05 ; Test and reset bits $0519.w [Reads: Accumulator] [Flags: Z]
.ACCU 8
.INDEX 8
	sep #$FD		; E2 FD
.ACCU 16
.INDEX 16
	rep #$FC		; C2 FC
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $90F2.w		; 0C F2 90 ; Test and set bits $90F2.w [Reads: Accumulator] [Flags: Z]
	jsl $E10008.l		; 22 08 00 E1 ; Jump to subroutine long $E10008.l [Writes: Stack Pointer] [Flow: call]
	cpy #$0684.w		; C0 84 06 ; Compare #$0684.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $2232.w		; 0D 32 22 ; Logical OR $2232.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $081F03.l		; 8F 03 1F 08 ; Store accumulator (long) $081F03.l [Reads: Accumulator]
	ora $020B04.l		; 0F 04 0B 02 ; OR accumulator with memory (long) $020B04.l [Writes: Accumulator] [Flags: NZ]
	ora #$0025.w		; 09 25 00 ; Logical OR #$0025.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $87.b		; 04 87 ; Test and set bits $87.b [Reads: Accumulator] [Flags: Z]
	ora ($08.b,S),Y		; 13 08 ; OR accumulator (stack relative indirect indexed) ($08.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$0022.w		; 09 22 00 ; Logical OR #$0022.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	jsr ($F080.w,X)		; FC 80 F0 ; Jump to subroutine indirect indexed ($F080.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $48C0.w		; 20 C0 48 ; Jump to subroutine at $48C0.w [Writes: Stack Pointer] [Flow: call]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($CC.b,X)		; 01 CC ; Logical OR ($CC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $25		; 80 25 ; Branch always to $80, $25 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $0F.b,X		; 35 0F ; Logical AND $0F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $A177A8.l,X		; 3F A8 77 A1 ; AND accumulator with memory (long,X) $A177A8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $447FB1.l,X		; 7F B1 7F 44 ; Add long $447FB1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $070739.l,X		; 3F 39 07 07 ; AND accumulator with memory (long,X) $070739.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $BFBFB7.l		; 4F B7 BF BF ; Exclusive OR accumulator with memory (long) $BFBFB7.l [Writes: Accumulator] [Flags: NZ]
	eor [$39.b]		; 47 39 ; Exclusive OR accumulator with memory (long) [$39.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$50.b]		; 07 50 ; OR accumulator with memory (long) [$50.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp.w [$BAE0]		; DC E0 BA ; Jump long indirect [$BAE0] [Flow: jump]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc ($F6.b,S),Y		; 73 F6 ; Add with carry (stack relative indirect indexed) ($F6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $229E.w,X		; 1D 9E 22 ; OR accumulator with memory $229E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($E0DC.w,X)		; FC DC E0 ; Jump to subroutine indirect indexed ($E0DC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$9000.w		; E0 00 90 ; Compare #$9000.w with X register [Reads: X Index] [Flags: NCZ]
	jmp $FD1FB6.l		; 5C B6 1F FD ; Jump long to $FD1FB6.l [Flow: jump]
.INDEX 8
	sep #$DC		; E2 DC
	cpx #$59.b		; E0 59 ; Compare #$59.b with X register [Reads: X Index] [Flags: NCZ]
	asl $3E7D.w,X		; 1E 7D 3E ; Arithmetic shift left $3E7D.w,X [Reads: X Index] [Flags: NCZ]
	lsr $3B.b,X		; 56 3B ; Logical shift right $3B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($3C.b,S),Y		; 73 3C ; Add with carry (stack relative indirect indexed) ($3C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $8B8425.l,X		; 3F 25 84 8B ; AND accumulator with memory (long,X) $8B8425.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $5B5F5F.l		; 6F 5F 5F 5B ; Add with carry (long) $5B5F5F.l [Writes: Accumulator] [Flags: NCVZ]
	jmp $1827.w		; 4C 27 18 ; Jump to $1827.w [Flow: jump]
	ora [$9A.b]		; 07 9A ; OR accumulator with memory (long) [$9A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldx $6A7C.w,Y		; BE 7C 6A ; Load X register $6A7C.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jmp.w [$3CCE]		; DC CE 3C ; Jump long indirect [$3CCE] [Flow: jump]
	asl $85FC.w,X		; 1E FC 85 ; Arithmetic shift left $85FC.w,X [Reads: X Index] [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($F6.b)		; 12 F6 ; OR accumulator with memory (indirect) ($F6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and ($E4.b)		; 32 E4 ; AND accumulator with memory (indirect) ($E4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$DB.b		; E0 DB ; Compare #$DB.b with X register [Reads: X Index] [Flags: NCZ]
	eor $887FB9.l,X		; 5F B9 7F 88 ; Exclusive OR accumulator with memory (long,X) $887FB9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $6F3F5C.l,X		; 7F 5C 3F 6F ; Add long $6F3F5C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $8B843B.l		; 2F 3B 84 8B ; AND accumulator with memory (long) $8B843B.l [Writes: Accumulator] [Flags: NZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $4F8F8F.l		; AF 8F 8F 4F ; Load long $4F8F8F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	eor [$23.b],Y		; 57 23 ; Exclusive OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$DB.b]		; 07 DB ; OR accumulator with memory (long) [$DB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sta $11FE.w,X		; 9D FE 11 ; Store accumulator to $11FE.w,X [Reads: Accumulator, X Index]
	inc $FC3A.w,X		; FE 3A FC ; Increment memory $FC3A.w,X [Reads: X Index] [Flags: NZ]
	inc $F4.b,X		; F6 F4 ; Increment memory $F4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jmp.w [$A384]		; DC 84 A3 ; Jump long indirect [$A384] [Flow: jump]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $F1.b,X		; F5 F1 ; Subtract $F1.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F2.b),Y		; F1 F2 ; Subtract with carry ($F2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	cpy $18.b		; C4 18 ; Compare $18.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpx #$FF.b		; E0 FF ; Compare #$FF.b with X register [Reads: X Index] [Flags: NCZ]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $0FFE03.l,X		; 7F 03 FE 0F ; Add long $0FFE03.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($3C0F.w,X)		; 7C 0F 3C ; Jump indirect indexed to ($3C0F.w,X) [Reads: X Index] [Flow: jump]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	rol $1B.b,X		; 36 1B ; Rotate left $1B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $083F19.l,X		; 3F 19 3F 08 ; AND accumulator with memory (long,X) $083F19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($6F.b,S),Y		; 13 6F ; OR accumulator (stack relative indirect indexed) ($6F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $3F3F5F.l,X		; BF 5F 3F 3F ; Load long $3F3F5F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00DC.w,Y		; 39 DC 00 ; AND accumulator with memory $00DC.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($7EC0.w,X)		; FC C0 7E ; Jump to subroutine indirect indexed ($7EC0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	.db $F0, $3E		; F0 3E ; Branch if equal to $F0, $3E [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	jmp ($FCD8.w)		; 6C D8 FC ; Jump indirect to ($FCD8.w) [Flow: jump]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($D410.w,X)		; FC 10 D4 ; Jump to subroutine indirect indexed ($D410.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($F9FE.w,X)		; FC FE F9 ; Jump to subroutine indirect indexed ($F9FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $DCFC.w,X		; FE FC DC ; Increment memory $DCFC.w,X [Reads: X Index] [Flags: NZ]
	stz $0023.w		; 9C 23 00 ; Store zero to $0023.w
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $E00022.l		; 0F 22 00 E0 ; OR accumulator with memory (long) $E00022.l [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$1C.b		; E0 1C ; Compare #$1C.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $7C		; F0 7C ; Branch if equal to $F0, $7C [Flow: branch]
	ldy #$FE.b		; A0 FE ; Load #$FE.b into Y register [Writes: Y Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $FF40.w,X		; FE 40 FF ; Increment memory $FF40.w,X [Reads: X Index] [Flags: NZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: NCZ]
	jsr ($F6F4.w,X)		; FC F4 F6 ; Jump to subroutine indirect indexed ($F6F4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ror $00F3.w		; 6E F3 00 ; Rotate right $00F3.w [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $7C.b,S		; 03 7C ; OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $780FF8.l		; 0F F8 0F 78 ; OR accumulator with memory (long) $780FF8.l [Writes: Accumulator] [Flags: NZ]
	ora [$78.b]		; 07 78 ; OR accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $001FFC.l		; 0F FC 1F 00 ; OR accumulator with memory (long) $001FFC.l [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $5F6F9F.l,X		; 7F 9F 6F 5F ; Add long $5F6F9F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $C00000.l,X		; BF 00 00 C0 ; Load long $C00000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$3C.b		; C0 3C ; Compare #$3C.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	cpx #$1E.b		; E0 1E ; Compare #$1E.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $3E		; F0 3E ; Branch if equal to $F0, $3E [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($F5FA.w,X)		; FC FA F5 ; Jump to subroutine indirect indexed ($F5FA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $3F7F07.l,X		; 3F 07 7F 3F ; AND accumulator with memory (long,X) $3F7F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	adc $677BF4.l,X		; 7F F4 7B 67 ; Add long $677BF4.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	eor $103F28.l,X		; 5F 28 3F 10 ; Exclusive OR accumulator with memory (long,X) $103F28.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $78FBFF.l,X		; 7F FF FB 78 ; Add long $78FBFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$FE.b		; E0 FE ; Compare #$FE.b with X register [Reads: X Index] [Flags: NCZ]
	jsr ($FCDE.w,X)		; FC DE FC ; Jump to subroutine indirect indexed ($FCDE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	dec $1EEB.w,X		; DE EB 1E ; Decrement memory $1EEB.w,X [Reads: X Index] [Flags: NZ]
	sbc $0CF71E.l		; EF 1E F7 0C ; Subtract with carry (long) $0CF71E.l [Writes: Accumulator] [Flags: NCVZ]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: NCZ]
	inc $DFFE.w,X		; FE FE DF ; Increment memory $DFFE.w,X [Reads: X Index] [Flags: NZ]
	jsl $00231F.l		; 22 1F 23 00 ; Jump to subroutine long $00231F.l [Writes: Stack Pointer] [Flow: call]
	sta $34.b,S		; 83 34 ; Store accumulator (stack relative) $34.b,S [Reads: Stack Pointer, Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $050022.l		; 0F 22 00 05 ; OR accumulator with memory (long) $050022.l [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $7A.b,S		; 83 7A ; Store accumulator (stack relative) $7A.b,S [Reads: Stack Pointer, Accumulator]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	ldy #$F8.b		; A0 F8 ; Load #$F8.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $30, $7C		; 30 7C ; Branch if minus to $30, $7C [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ldx $0074.w,Y		; BE 74 00 ; Load X register $0074.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($25FE.w,X)		; FC FE 25 ; Jump to subroutine indirect indexed ($25FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $D2.b		; 84 D2 ; Store Y register to $D2.b [Reads: Y Index]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FAA0.w,X)		; FC A0 FA ; Jump to subroutine indirect indexed ($FAA0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp ($F8E4.w,X)		; 7C E4 F8 ; Jump indirect indexed to ($F8E4.w,X) [Reads: X Index] [Flow: jump]
	jsl $C01700.l		; 22 00 17 C0 ; Jump to subroutine long $C01700.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	inc $18FC.w,X		; FE FC 18 ; Increment memory $18FC.w,X [Reads: X Index] [Flags: NZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $7F9F3B.l,X		; 5F 3B 9F 7F ; Exclusive OR accumulator with memory (long,X) $7F9F3B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $7FFF7F.l,X		; BF 7F FF 7F ; Load long $7FFF7F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $181F38.l		; 0F 38 1F 18 ; OR accumulator with memory (long) $181F38.l [Writes: Accumulator] [Flags: NZ]
	and $FF227F.l,X		; 3F 7F 22 FF ; AND accumulator with memory (long,X) $FF227F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $004883.l,X		; 3F 83 48 00 ; AND accumulator with memory (long,X) $004883.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $E0FC.w		; 0C FC E0 ; Test and set bits $E0FC.w [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cpx $DCF2.w		; EC F2 DC ; Compare $DCF2.w with X register [Reads: X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $FECF.w,X		; FE CF FE ; Increment memory $FECF.w,X [Reads: X Index] [Flags: NZ]
	asl $EC.b,X		; 16 EC ; Arithmetic shift left $EC.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $39FEFF.l,X		; FF FF FE 39 ; Subtract with carry (long,X) $39FEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $78		; 50 78 ; Branch if overflow clear to $50, $78 [Flow: branch]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda $4FFE70.l,X		; BF 70 FE 4F ; Load long $4FFE70.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $7F043F.l		; 2F 3F 04 7F ; AND accumulator with memory (long) $7F043F.l [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($FFFF.w,X)		; FC FF FF ; Jump to subroutine indirect indexed ($FFFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $3F6F2F.l,X		; 7F 2F 6F 3F ; Add long $3F6F2F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0D1D.w		; 0C 1D 0D ; Test and set bits $0D1D.w [Reads: Accumulator] [Flags: Z]
	tsb $0604.w		; 0C 04 06 ; Test and set bits $0604.w [Reads: Accumulator] [Flags: Z]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($12.b,S),Y		; 13 12 ; OR accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F888.w,X)		; FC 88 F8 ; Jump to subroutine indirect indexed ($F888.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $B8		; 30 B8 ; Branch if minus to $30, $B8 [Flow: branch]
	.db $B0, $30		; B0 30 ; Branch if carry set to $B0, $30 [Flow: branch]
	jsr $4060.w		; 20 60 40 ; Jump to subroutine at $4060.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $D0, $A0		; D0 A0 ; Branch if not equal to $D0, $A0 [Flow: branch]
	cpy #$40.b		; C0 40 ; Compare #$40.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $33		; 80 33 ; Branch always to $80, $33 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($017F.w,X)		; 7C 7F 01 ; Jump indirect indexed to ($017F.w,X) [Reads: X Index] [Flow: jump]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7E837F.l,X		; 3F 7F 83 7E ; AND accumulator with memory (long,X) $7E837F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $5E7332.l,X		; FF 32 73 5E ; Subtract with carry (long,X) $5E7332.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $EC.b,X		; F6 EC ; Increment memory $EC.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $FCEC.w,X		; FE EC FC ; Increment memory $FCEC.w,X [Reads: X Index] [Flags: NZ]
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($FF.b),Y		; 11 FF ; OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $3C1E1E.l,X		; BF 1E 1E 3C ; Load long $3C1E1E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1E0F1D.l		; 0F 1D 0F 1E ; OR accumulator with memory (long) $1E0F1D.l [Writes: Accumulator] [Flags: NZ]
	ora $07070F.l		; 0F 0F 07 07 ; OR accumulator with memory (long) $07070F.l [Writes: Accumulator] [Flags: NZ]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0F1F1F.l,X		; 5F 1F 1F 0F ; Exclusive OR accumulator with memory (long,X) $0F1F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($B8F0.w,X)		; FC F0 B8 ; Jump to subroutine indirect indexed ($B8F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$25.b		; C0 25 ; Compare #$25.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F8F8.w,X)		; FC F8 F8 ; Jump to subroutine indirect indexed ($F8F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	jsl $7F4300.l		; 22 00 43 7F ; Jump to subroutine long $7F4300.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $1E		; 30 1E ; Branch if minus to $30, $1E [Flow: branch]
	adc [$38.b],Y		; 77 38 ; Add with carry (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $177C.w		; 1C 7C 17 ; Test and reset bits $177C.w [Reads: Accumulator] [Flags: Z]
	eor $3C4E38.l,X		; 5F 38 4E 3C ; Exclusive OR accumulator with memory (long,X) $3C4E38.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $7000.w,X		; 3C 00 70 ; Test bits $7000.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	jmp ($7F7F.w,X)		; 7C 7F 7F ; Jump indirect indexed to ($7F7F.w,X) [Reads: X Index] [Flow: jump]
	ror $FA3C.w,X		; 7E 3C FA ; Rotate right $FA3C.w,X [Reads: X Index] [Flags: NCZ]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $DE1C.w		; EE 1C DE ; Increment $DE1C.w [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	rol $FCE4.w,X		; 3E E4 FC ; Rotate left $FCE4.w,X [Reads: X Index] [Flags: NCZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	asl $3E1E.w		; 0E 1E 3E ; Arithmetic shift left $3E1E.w [Flags: NCZ]
	inc $00FC.w,X		; FE FC 00 ; Increment memory $00FC.w,X [Reads: X Index] [Flags: NZ]
	mvp $0F,$00		; 44 00 0F ; Move block positive $0F,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $080200.l		; 22 00 02 08 ; Jump to subroutine long $080200.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0743.w		; 0D 43 07 ; Logical OR $0743.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $9E.b		; 00 9E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $DE.b,X		; 74 DE ; Store zero to $DE.b,X [Reads: X Index]
	bit $AE.b,X		; 34 AE ; Test bits $AE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	pei ($7C.b)		; D4 7C ; Push effective indirect address ($7C.b) [Reads: Direct Page] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	jsl $FE2200.l		; 22 00 22 FE ; Jump to subroutine long $FE2200.l [Writes: Stack Pointer] [Flow: call]
	sta $08.b,S		; 83 08 ; Store accumulator (stack relative) $08.b,S [Reads: Stack Pointer, Accumulator]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $83070B.l		; 0F 0B 07 83 ; OR accumulator with memory (long) $83070B.l [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora ($14.b,X)		; 01 14 ; Logical OR ($14.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$0F0B.w		; 09 0B 0F ; Logical OR #$0F0B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $03070F.l,X		; 1F 0F 07 03 ; Logical OR long $03070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$FE60]		; DC 60 FE ; Jump long indirect [$FE60] [Flow: jump]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $D67FFA.l,X		; FF FA 7F D6 ; Subtract with carry (long,X) $D67FFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sty $80FC.w		; 8C FC 80 ; Store Y register to $80FC.w [Reads: Y Index]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($4C83.w,X)		; FC 83 4C ; Jump to subroutine indirect indexed ($4C83.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr ($0080.w,X)		; FC 80 00 ; Jump to subroutine indirect indexed ($0080.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $7E3F7C.l,X		; 3F 7C 3F 7E ; AND accumulator with memory (long,X) $7E3F7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $6F1F3F.l,X		; 3F 3F 1F 6F ; AND accumulator with memory (long,X) $6F1F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $2E384F.l,X		; 3F 4F 38 2E ; AND accumulator with memory (long,X) $2E384F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	jsl $3F0F7F.l		; 22 7F 0F 3F ; Jump to subroutine long $3F0F7F.l [Writes: Stack Pointer] [Flow: call]
	adc $1C3E7F.l,X		; 7F 7F 3E 1C ; Add long $1C3E7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $E8.b,X		; 16 E8 ; Arithmetic shift left $E8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $7EF4.w,X		; 3E F4 7E ; Rotate left $7EF4.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($F8FE.w,X)		; FC FE F8 ; Jump to subroutine indirect indexed ($F8FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FCE4.w,X		; FE E4 FC ; Increment memory $FCE4.w,X [Reads: X Index] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $FE.b		; 24 FE ; Test bits $FE.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $0101.w		; 8C 01 01 ; Store Y register to $0101.w [Reads: Y Index]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0103.w,Y		; 19 03 01 ; OR accumulator with memory $0103.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	bit $2874.w		; 2C 74 28 ; Test bits $2874.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc $82.b,S		; 63 82 ; Add with carry (stack relative) $82.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor [$94.b],Y		; 57 94 ; Exclusive OR accumulator with memory (long indexed) [$94.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $A0FFA8.l,X		; 7F A8 FF A0 ; Add long $A0FFA8.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7F7F50.l,X		; FF 50 7F 7F ; Subtract with carry (long,X) $7F7F50.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D5E9FD.l,X		; FF FD E9 D5 ; Subtract with carry (long,X) $D5E9FD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $0023EF.l,X		; DF EF 23 00 ; Compare accumulator (long,X) $0023EF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($86.b,X)		; 01 86 ; Logical OR ($86.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $02.b,X		; D6 02 ; Decrement memory $02.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsl $010100.l		; 22 00 01 01 ; Jump to subroutine long $010100.l [Writes: Stack Pointer] [Flow: call]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $7F07FB.l		; 0F FB 07 7F ; OR accumulator with memory (long) $7F07FB.l [Writes: Accumulator] [Flags: NZ]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $FC.b,S		; C3 FC ; Compare accumulator (stack relative) $FC.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp [$F8.b]		; C7 F8 ; Compare accumulator (long) [$F8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $7C3FF8.l		; 8F F8 3F 7C ; Store accumulator (long) $7C3FF8.l [Reads: Accumulator]
	ora $F7EF3F.l,X		; 1F 3F EF F7 ; Logical OR long $F7EF3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FFFFEF.l		; EF EF FF FF ; Subtract with carry (long) $FFFFEF.l [Writes: Accumulator] [Flags: NCVZ]
	adc $240018.l,X		; 7F 18 00 24 ; Add long $240018.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$25.b		; E0 25 ; Compare #$25.b with X register [Reads: X Index] [Flags: NCZ]
	and $1D08.w,Y		; 39 08 1D ; AND accumulator with memory $1D08.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $060E.w		; 0C 0E 06 ; Test and set bits $060E.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $2F3F.w,X		; 3C 3F 2F ; Test bits $2F3F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $091317.l		; 2F 17 13 09 ; AND accumulator with memory (long) $091317.l [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	adc $70FE00.l,X		; 7F 00 FE 70 ; Add long $70FE00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $3DC7F8.l		; CF F8 C7 3D ; Compare accumulator (long) $3DC7F8.l [Reads: Accumulator] [Flags: NCZ]
	sbc [$1C.b]		; E7 1C ; Subtract with carry (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$0C.b],Y		; F7 0C ; Subtract with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $790638.l,X		; FF 38 06 79 ; Subtract with carry (long,X) $790638.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: NZ]
	and $83FD9E.l,X		; 3F 9E FD 83 ; AND accumulator with memory (long,X) $83FD9E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $EE50.w		; EC 50 EE ; Compare $EE50.w with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $FE		; B0 FE ; Branch if carry set to $B0, $FE [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $EC40.w,X		; FE 40 EC ; Increment memory $EC40.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $EE		; 10 EE ; Branch if plus to $10, $EE [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FE22.w,X)		; FC 22 FE ; Jump to subroutine indirect indexed ($FE22.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($7C.b,X)		; 01 7C ; Logical OR ($7C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $0023.w,X		; FE 23 00 ; Increment memory $0023.w,X [Reads: X Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	ora $010F06.l		; 0F 06 0F 01 ; OR accumulator with memory (long) $010F06.l [Writes: Accumulator] [Flags: NZ]
	trb $830F.w		; 1C 0F 83 ; Test and reset bits $830F.w [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F001F.l		; 0F 1F 00 0F ; OR accumulator with memory (long) $0F001F.l [Writes: Accumulator] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0129E0.l,X		; 1F E0 29 01 ; Logical OR long $0129E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $1F0D.w,X		; 1E 0D 1F ; Arithmetic shift left $1F0D.w,X [Reads: X Index] [Flags: NCZ]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$8300.w		; 09 00 83 ; Logical OR #$8300.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $4F.b,S		; 83 4F ; Store accumulator (stack relative) $4F.b,S [Reads: Stack Pointer, Accumulator]
	tsb $DF.b		; 04 DF ; Test and set bits $DF.b [Reads: Accumulator] [Flags: Z]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jsr ($FE89.w,X)		; FC 89 FE ; Jump to subroutine indirect indexed ($FE89.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lsr $DF.b		; 46 DF ; Logical shift right $DF.b [Reads: Direct Page] [Flags: NCZ]
	ora $CF.b,S		; 03 CF ; OR accumulator with stack relative $CF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $7D.b		; A4 7D ; Load $7D.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$CC.b]		; 07 CC ; OR accumulator with memory (long) [$CC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $8347.w		; 8E 47 83 ; Store X register to $8347.w [Reads: X Index]
	.db $62, $2E, $00		; 62 2E 00 ; Push effective relative address $62, $2E, $00 [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0B1F04.l		; 0F 04 1F 0B ; OR accumulator with memory (long) $0B1F04.l [Writes: Accumulator] [Flags: NZ]
	bit $3E09.w,X		; 3C 09 3E ; Test bits $3E09.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	asl $7F.b		; 06 7F ; Arithmetic shift left $7F.b [Reads: Direct Page] [Flags: NCZ]
	ora $FF.b,S		; 03 FF ; OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $DF.b,S		; 83 DF ; Store accumulator (stack relative) $DF.b,S [Reads: Stack Pointer, Accumulator]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $070E.w		; 0C 0E 07 ; Test and set bits $070E.w [Reads: Accumulator] [Flags: Z]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0411.w		; 0D 11 04 ; Logical OR $0411.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F04.w		; 0E 04 0F ; Arithmetic shift left $0F04.w [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $007F06.l,X		; 3F 06 7F 00 ; AND accumulator with memory (long,X) $007F06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $1CFF08.l,X		; 7F 08 FF 1C ; Add long $1CFF08.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $7C00.w,X		; FE 00 7C ; Increment memory $7C00.w,X [Reads: X Index] [Flags: NZ]
	ora #$1F0C.w		; 09 0C 1F ; Logical OR #$1F0C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and [$30.b]		; 27 30 ; AND accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jmp ($0025.w,X)		; 7C 25 00 ; Jump indirect indexed to ($0025.w,X) [Reads: X Index] [Flow: jump]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $00.b,X		; 16 00 ; Arithmetic shift left $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $013F0A.l,X		; 3F 0A 3F 01 ; AND accumulator with memory (long,X) $013F0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $3F00.w,X		; 1E 00 3F ; Arithmetic shift left $3F00.w,X [Reads: X Index] [Flags: NCZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $160300.l		; 22 00 03 16 ; Jump to subroutine long $160300.l [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $DB.b,S		; 83 DB ; Store accumulator (stack relative) $DB.b,S [Reads: Stack Pointer, Accumulator]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $49FC8B.l,X		; 9F 8B FC 49 ; Store accumulator (long,X) $49FC8B.l,X [Reads: Accumulator, X Index]
	inc $FF86.w,X		; FE 86 FF ; Increment memory $FF86.w,X [Reads: X Index] [Flags: NZ]
	ora $DF.b,S		; 03 DF ; OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $DF.b,S		; 83 DF ; Store accumulator (stack relative) $DF.b,S [Reads: Stack Pointer, Accumulator]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $87CE.w		; 8C CE 87 ; Store Y register to $87CE.w [Reads: Y Index]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $093F0C.l,X		; 1F 0C 3F 09 ; Logical OR long $093F0C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $3C03.w,X		; 1E 03 3C ; Arithmetic shift left $3C03.w,X [Reads: X Index] [Flags: NCZ]
	ora ($7E.b),Y		; 11 7E ; OR accumulator with memory ($7E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $070400.l		; 22 00 04 07 ; Jump to subroutine long $070400.l [Writes: Stack Pointer] [Flow: call]
	ora $1E040E.l		; 0F 0E 04 1E ; OR accumulator with memory (long) $1E040E.l [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $090E05.l		; 0F 05 0E 09 ; OR accumulator with memory (long) $090E05.l [Writes: Accumulator] [Flags: NZ]
	asl $3F08.w,X		; 1E 08 3F ; Arithmetic shift left $3F08.w,X [Reads: X Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	ora $0C0037.l		; 0F 37 00 0C ; OR accumulator with memory (long) $0C0037.l [Writes: Accumulator] [Flags: NZ]
	adc $47FF3F.l,X		; 7F 3F FF 47 ; Add long $47FF3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $7DBF3F.l		; CF 3F BF 7D ; Compare accumulator (long) $7DBF3F.l [Reads: Accumulator] [Flags: NCZ]
	sbc $00FC44.l,X		; FF 44 FC 00 ; Subtract with carry (long,X) $00FC44.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $7F0000.l		; 22 00 00 7F ; Jump to subroutine long $7F0000.l [Writes: Stack Pointer] [Flow: call]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $78FC.w		; 0D FC 78 ; Logical OR $78FC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: NCZ]
	ora $2E.b,X		; 15 2E ; OR accumulator with memory $2E.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $0F387F.l,X		; 7F 7F 38 0F ; Add long $0F387F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $A0BF19.l,X		; 3F 19 BF A0 ; AND accumulator with memory (long,X) $A0BF19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E7FEE9.l,X		; FF E9 FE E7 ; Subtract with carry (long,X) $E7FEE9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FC8F.w,X		; FD 8F FC ; Subtract with carry $FC8F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $07070E.l		; 0F 0E 07 07 ; OR accumulator with memory (long) $07070E.l [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $1F1F.w,Y		; 59 1F 1F ; Exclusive OR accumulator with memory $1F1F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $070FFF.l,X		; 7F FF 0F 07 ; Add long $070FFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $ECFFD8.l,X		; FF D8 FF EC ; Subtract with carry (long,X) $ECFFD8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $38CEF0.l,X		; 3F F0 CE 38 ; AND accumulator with memory (long,X) $38CEF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $98BE0F.l,X		; FF 0F BE 98 ; Subtract with carry (long,X) $98BE0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000B04.l,X		; 1F 04 0B 00 ; Logical OR long $000B04.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($1B.b,S),Y		; 73 1B ; Add with carry (stack relative indirect indexed) ($1B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $0307.w		; 0E 07 03 ; Arithmetic shift left $0307.w [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $070000.l		; 0F 00 00 07 ; OR accumulator with memory (long) $070000.l [Writes: Accumulator] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $002202.l		; 22 02 22 00 ; Jump to subroutine long $002202.l [Writes: Stack Pointer] [Flow: call]
	ora $B7.b,X		; 15 B7 ; OR accumulator with memory $B7.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1BFF12.l,X		; FF 12 FF 1B ; Subtract with carry (long,X) $1BFF12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $EE19.w,X		; FE 19 EE ; Increment memory $EE19.w,X [Reads: X Index] [Flags: NZ]
	bit $0EF7.w		; 2C F7 0E ; Test bits $0EF7.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $001F01.l,X		; 3F 01 1F 00 ; AND accumulator with memory (long,X) $001F01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$F1.b]		; 07 F1 ; OR accumulator with memory (long) [$F1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1B.b,S),Y		; 13 1B ; OR accumulator (stack relative indirect indexed) ($1B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$0FB4.w		; A9 B4 0F ; Load #$0FB4.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $DE.b,S		; 83 DE ; Store accumulator (stack relative) $DE.b,S [Reads: Stack Pointer, Accumulator]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1F00.w		; 2D 00 1F ; Logical AND $1F00.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3F		; 10 3F ; Branch if plus to $10, $3F [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $063F1C.l,X		; 1F 1C 3F 06 ; Logical OR long $063F1C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $000700.l,X		; 1F 00 07 00 ; Logical OR long $000700.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $00071E.l		; 0F 1E 07 00 ; OR accumulator with memory (long) $00071E.l [Writes: Accumulator] [Flags: NZ]
	cpy $BD.b		; C4 BD ; Compare $BD.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	and [$FF.b],Y		; 37 FF ; AND accumulator with memory (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($EE.b,S),Y		; 93 EE ; Store accumulator (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora #$0CF6.w		; 09 F6 0C ; Logical OR #$0CF6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $00FF01.l,X		; FF 01 FF 00 ; Subtract with carry (long,X) $00FF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$A2.b]		; 87 A2 ; Store accumulator (long) [$A2.b] [Reads: Direct Page, Accumulator]
	and ($D3.b),Y		; 31 D3 ; AND accumulator with memory ($D3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $11.b,S		; A3 11 ; Load accumulator (stack relative) $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $0081.w		; EC 81 00 ; Compare $0081.w with X register [Reads: X Index] [Flags: NCZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	rol $7F.b		; 26 7F ; Rotate left $7F.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $7F		; 10 7F ; Branch if plus to $10, $7F [Flow: branch]
	tsb $78FF.w		; 0C FF 78 ; Test and set bits $78FF.w [Reads: Accumulator] [Flags: Z]
	sty $4438.w		; 8C 38 44 ; Store Y register to $4438.w [Reads: Y Index]
	sty $18.b		; 84 18 ; Store Y register to $18.b [Reads: Y Index]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	jmp ($3878.w,X)		; 7C 78 38 ; Jump indirect indexed to ($3878.w,X) [Reads: X Index] [Flow: jump]
	.db $90, $70		; 90 70 ; Branch if carry clear to $90, $70 [Flow: branch]
	jsr $D8F0.w		; 20 F0 D8 ; Jump to subroutine at $D8F0.w [Writes: Stack Pointer] [Flow: call]
	inc $FE64.w,X		; FE 64 FE ; Increment memory $FE64.w,X [Reads: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $FC00.w,X		; FE 00 FC ; Increment memory $FC00.w,X [Reads: X Index] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $90.b		; 04 90 ; Test and set bits $90.b [Reads: Accumulator] [Flags: Z]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	cpx $0C.b		; E4 0C ; Compare $0C.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $030200.l		; 22 00 02 03 ; Jump to subroutine long $030200.l [Writes: Stack Pointer] [Flow: call]
	ora $074301.l		; 0F 01 43 07 ; OR accumulator with memory (long) $074301.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $C4.b		; 06 C4 ; Arithmetic shift left $C4.b [Reads: Direct Page] [Flags: NCZ]
	sbc $FF17.w		; ED 17 FF ; Subtract $FF17.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta ($FF.b)		; 92 FF ; Store accumulator (indirect) ($FF.b) [Reads: Direct Page, Accumulator]
	ora ($83.b,S),Y		; 13 83 ; OR accumulator (stack relative indirect indexed) ($83.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $338405.l,X		; 5F 05 84 33 ; Exclusive OR accumulator with memory (long,X) $338405.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$F1		; C2 F1
	sbc ($03.b,S),Y		; F3 03 ; Subtract with carry (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($0C.b),Y		; 11 0C ; OR accumulator with memory ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $7F		; 30 7F ; Branch if minus to $30, $7F [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $033F0F.l,X		; 7F 0F 3F 03 ; Add long $033F0F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $250700.l,X		; 1F 00 07 25 ; Logical OR long $250700.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $030F3F.l,X		; 3F 3F 0F 03 ; AND accumulator with memory (long,X) $030F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $001F07.l,X		; 1F 07 1F 00 ; Logical OR long $001F07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$29.b]		; 07 29 ; OR accumulator with memory (long) [$29.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $002507.l		; 0F 07 25 00 ; OR accumulator with memory (long) $002507.l [Writes: Accumulator] [Flags: NZ]
	sbc $090025.l,X		; FF 25 00 09 ; Subtract with carry (long,X) $090025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1F3807.l,X		; 1F 07 38 1F ; Logical OR long $1F3807.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $227EC1.l,X		; 3F C1 7E 22 ; AND accumulator with memory (long,X) $227EC1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $25FE7F.l,X		; 3F 7F FE 25 ; AND accumulator with memory (long,X) $25FE7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F800.w		; E0 00 F8 ; Compare #$F800.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$F81C.w		; E0 1C F8 ; Compare #$F81C.w with X register [Reads: X Index] [Flags: NCZ]
	asl $FC.b		; 06 FC ; Arithmetic shift left $FC.b [Reads: Direct Page] [Flags: NCZ]
	sta $7E.b,S		; 83 7E ; Store accumulator (stack relative) $7E.b,S [Reads: Stack Pointer, Accumulator]
	jsl $E00400.l		; 22 00 04 E0 ; Jump to subroutine long $E00400.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($7FFE.w,X)		; FC FE 7F ; Jump to subroutine indirect indexed ($7FFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0038.w		; 09 38 00 ; Logical OR #$0038.w with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $38.b,X		; 74 38 ; Store zero to $38.b,X [Reads: X Index]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tsb $33BD.w		; 0C BD 33 ; Test and set bits $33BD.w [Reads: Accumulator] [Flags: Z]
	adc [$0F.b],Y		; 77 0F ; Add with carry (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $380400.l		; 22 00 04 38 ; Jump to subroutine long $380400.l [Writes: Stack Pointer] [Flow: call]
	jmp ($CDFF.w,X)		; 7C FF CD ; Jump indirect indexed to ($CDFF.w,X) [Reads: X Index] [Flow: jump]
	adc [$25.b],Y		; 77 25 ; Add with carry (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $2E00.w		; 1C 00 2E ; Test and reset bits $2E00.w [Reads: Accumulator] [Flags: Z]
	trb $30DD.w		; 1C DD 30 ; Test and reset bits $30DD.w [Reads: Accumulator] [Flags: Z]
	lda $4ECC.w,X		; BD CC 4E ; Load $4ECC.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $22		; B0 22 ; Branch if carry set to $B0, $22 [Flow: branch]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $FF3E.w		; 1C 3E FF ; Test and reset bits $FF3E.w [Reads: Accumulator] [Flags: Z]
	sbc ($AE.b,S),Y		; F3 AE ; Subtract with carry (stack relative indirect indexed) ($AE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: NZ]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: NZ]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $977FBF.l,X		; DF BF 7F 97 ; Compare accumulator (long,X) $977FBF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $103F.w		; 0C 3F 10 ; Test and set bits $103F.w [Reads: Accumulator] [Flags: Z]
	adc $007F20.l,X		; 7F 20 7F 00 ; Add long $007F20.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$58.b]		; E7 58 ; Subtract with carry (long) [$58.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0A.b,X		; F5 0A ; Subtract $0A.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $67673F.l,X		; 1F 3F 67 67 ; Logical OR long $67673F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $F4.b		; E6 F4 ; Increment $F4.b [Reads: Direct Page] [Flags: NZ]
	cpy #$F000.w		; C0 00 F0 ; Compare #$F000.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$30F8.w		; C0 F8 30 ; Compare #$30F8.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $A638.w		; CC 38 A6 ; Compare $A638.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp $4334CE.l		; 5C CE 34 43 ; Jump long to $4334CE.l [Flow: jump]
	sbc $C00700.l,X		; FF 00 07 C0 ; Subtract with carry (long,X) $C00700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($7EDE.w,X)		; FC DE 7E ; Jump to subroutine indirect indexed ($7EDE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $00233F.l,X		; 3F 3F 23 00 ; AND accumulator with memory (long,X) $00233F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $3005.w,X		; FD 05 30 ; Subtract with carry $3005.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $FF78.w		; CD 78 FF ; Compare $FF78.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $FD.b		; 00 FD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $780000.l		; 22 00 00 78 ; Jump to subroutine long $780000.l [Writes: Stack Pointer] [Flow: call]
	jsl $8701FD.l		; 22 FD 01 87 ; Jump to subroutine long $8701FD.l [Writes: Stack Pointer] [Flow: call]
	sta [$43.b]		; 87 43 ; Store accumulator (long) [$43.b] [Reads: Direct Page, Accumulator]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $FF45A5.l		; EF A5 45 FF ; Subtract with carry (long) $FF45A5.l [Writes: Accumulator] [Flags: NCVZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cmp [$EF.b],Y		; D7 EF ; Compare accumulator (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $1043EF.l,X		; FF EF 43 10 ; Subtract with carry (long,X) $1043EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$0000]		; DC 00 00 ; Jump long indirect [$0000] [Flow: jump]
	eor $45.b		; 45 45 ; Exclusive OR $45.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E98600.l,X		; FF 00 86 E9 ; Subtract with carry (long,X) $E98600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	ror $FE00.w,X		; 7E 00 FE ; Rotate right $FE00.w,X [Reads: X Index] [Flags: NCZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $0B.b,S		; 83 0B ; Store accumulator (stack relative) $0B.b,S [Reads: Stack Pointer, Accumulator]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $9E79.w		; AE 79 9E ; Load $9E79.w into X register [Writes: X Index] [Flags: NZ]
	adc $56.b,X		; 75 56 ; Add $56.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	eor $10EF30.l		; 4F 30 EF 10 ; Exclusive OR accumulator with memory (long) $10EF30.l [Writes: Accumulator] [Flags: NZ]
	sbc $A08300.l,X		; FF 00 83 A0 ; Subtract with carry (long,X) $A08300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($43.b,S),Y		; 73 43 ; Add with carry (stack relative indirect indexed) ($43.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$BF.b]		; E7 BF ; Subtract with carry (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $A8.b		; 85 A8 ; Store accumulator to $A8.b [Reads: Accumulator]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FE08.w,X)		; FC 08 FE ; Jump to subroutine indirect indexed ($FE08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $2FF0.w,X		; 9E F0 2F ; Store zero to $2FF0.w,X [Reads: X Index]
	cmp ($0F.b)		; D2 0F ; Compare accumulator (indirect) ($0F.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc ($83.b)		; F2 83 ; Subtract with carry (indirect) ($83.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $DFFE.w,X		; FE FE DF ; Increment memory $DFFE.w,X [Reads: X Index] [Flags: NZ]
	sbc $47001F.l,X		; FF 1F 00 47 ; Subtract with carry (long,X) $47001F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $0203.w,X		; 3E 03 02 ; Rotate left $0203.w,X [Reads: X Index] [Flags: NCZ]
	ora $430200.l,X		; 1F 00 02 43 ; Logical OR long $430200.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3F.b,S		; 23 3F ; AND accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: NCZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $DC43.w		; 20 43 DC ; Jump to subroutine at $DC43.w [Writes: Stack Pointer] [Flow: call]
	.db $30, $04		; 30 04 ; Branch if minus to $30, $04 [Flow: branch]
	jsr ($F820.w,X)		; FC 20 F8 ; Jump to subroutine indirect indexed ($F820.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $3C.b,S		; 23 3C ; AND accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $F8.b,S		; 43 F8 ; Exclusive OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$7F0B.w		; C0 0B 7F ; Compare #$7F0B.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $7F		; D0 7F ; Branch if not equal to $D0, $7F [Flow: branch]
	ldy #$5A7F.w		; A0 7F 5A ; Load #$5A7F.w into Y register [Writes: Y Index] [Flags: NZ]
	and $181F25.l,X		; 3F 25 1F 18 ; AND accumulator with memory (long,X) $181F25.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $FF1400.l		; 22 00 14 FF ; Jump to subroutine long $FF1400.l [Writes: Stack Pointer] [Flow: call]
	sbc $255FAF.l,X		; FF AF 5F 25 ; Subtract with carry (long,X) $255FAF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc $FE05.w,X		; FE 05 FE ; Increment memory $FE05.w,X [Reads: X Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsr ($F8A4.w,X)		; FC A4 F8 ; Jump to subroutine indirect indexed ($F8A4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$22E0.w		; E0 E0 22 ; Compare #$22E0.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FAF5FF.l,X		; FF FF F5 FA ; Subtract with carry (long,X) $FAF5FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $18.b		; A4 18 ; Load $18.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cpx #$4D00.w		; E0 00 4D ; Compare #$4D00.w with X register [Reads: X Index] [Flags: NCZ]
	and $433B54.l,X		; 3F 54 3B 43 ; AND accumulator with memory (long,X) $433B54.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $79.b,Y		; 96 79 ; Store X register $79.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	cop $4A.b		; 02 4A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $8427.w,X		; 3D 27 84 ; AND accumulator with memory $8427.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit #$0B01.w		; 89 01 0B ; Test bits #$0B01.w with accumulator [Reads: Accumulator] [Flags: Z]
	eor $999B5F.l		; 4F 5F 9B 99 ; Exclusive OR accumulator with memory (long) $999B5F.l [Writes: Accumulator] [Flags: NZ]
	eor $1827.w		; 4D 27 18 ; Exclusive OR $1827.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$B2.b]		; 07 B2 ; OR accumulator with memory (long) [$B2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($DC2A.w,X)		; FC 2A DC ; Jump to subroutine indirect indexed ($DC2A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $69.b,S		; 43 69 ; Exclusive OR accumulator with stack relative $69.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $5202.w,X		; 9E 02 52 ; Store zero to $5202.w,X [Reads: X Index]
	ldy $84E4.w,X		; BC E4 84 ; Load Y register $84E4.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda ($01.b,X)		; A1 01 ; Load accumulator ($01.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$F2.b]		; 07 F2 ; OR accumulator with memory (long) [$F2.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp $B299.w,Y		; D9 99 B2 ; Compare accumulator $B299.w,Y [Reads: Y Index] [Flags: NCZ]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx #$2FF0.w		; E0 F0 2F ; Compare #$2FF0.w with X register [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $BF43.w,X		; BC 43 BF ; Load Y register $BF43.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lda [$58.b]		; A7 58 ; Load accumulator (long) [$58.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $39.b		; 46 39 ; Logical shift right $39.b [Reads: Direct Page] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $898420.l,X		; 3F 20 84 89 ; AND accumulator with memory (long,X) $898420.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stz $808F.w		; 9C 8F 80 ; Store zero to $808F.w
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $0718.w		; 20 18 07 ; Jump to subroutine at $0718.w [Writes: Stack Pointer] [Flow: call]
	mvp $02,$FF		; 44 FF 02 ; Move block positive $02,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $06.b,X		; 16 06 ; Arithmetic shift left $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $3EC4.w,X		; 3E C4 3E ; Rotate left $3EC4.w,X [Reads: X Index] [Flags: NCZ]
	cpy $C83C.w		; CC 3C C8 ; Compare $C83C.w with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $1E1E8F.l,X		; DF 8F 1E 1E ; Compare accumulator (long,X) $1E1E8F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	bit $E0F8.w,X		; 3C F8 E0 ; Test bits $E0F8.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sta $78.b		; 85 78 ; Store accumulator to $78.b [Reads: Accumulator]
	sbc $FD4578.l,X		; FF 78 45 FD ; Subtract with carry (long,X) $FD4578.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $00FD22.l,X		; FF 22 FD 00 ; Subtract with carry (long,X) $00FD22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $EF0B00.l		; 22 00 0B EF ; Jump to subroutine long $EF0B00.l [Writes: Stack Pointer] [Flow: call]
	eor ($C7.b)		; 52 C7 ; Exclusive OR accumulator with memory (indirect) ($C7.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FFFFEF.l,X		; FF EF FF FF ; Subtract with carry (long,X) $FFFFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $221000.l,X		; FF 00 10 22 ; Subtract with carry (long,X) $221000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$EF.b],Y		; D7 EF ; Compare accumulator (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $FF00FF.l		; EF FF 00 FF ; Subtract with carry (long) $FF00FF.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $EF0100.l		; 22 00 01 EF ; Jump to subroutine long $EF0100.l [Writes: Stack Pointer] [Flow: call]
	sta ($89.b)		; 92 89 ; Store accumulator (indirect) ($89.b) [Reads: Direct Page, Accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$EF.b],Y		; D7 EF ; Compare accumulator (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc $00FF43.l		; EF 43 FF 00 ; Subtract with carry (long) $00FF43.l [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$60.b],Y		; 97 60 ; Store accumulator (long indexed) [$60.b],Y [Reads: Direct Page, Y Index, Accumulator]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00FF.w,Y		; 39 FF 00 ; AND accumulator with memory $00FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	stz $97.b		; 64 97 ; Store zero to $97.b
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $007F30.l		; 4F 30 7F 00 ; Exclusive OR accumulator with memory (long) $007F30.l [Writes: Accumulator] [Flags: NZ]
	and $031F00.l,X		; 3F 00 1F 03 ; AND accumulator with memory (long,X) $031F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $4F8783.l		; AF 83 87 4F ; Load long $4F8783.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $071F3F.l,X		; 7F 3F 1F 07 ; Add long $071F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $06FB62.l,X		; 9F 62 FB 06 ; Store accumulator (long,X) $06FB62.l,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	tsb $F6.b		; 04 F6 ; Test and set bits $F6.b [Reads: Accumulator] [Flags: Z]
	tsb $18EC.w		; 0C EC 18 ; Test and set bits $18EC.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $FEFEFF.l,X		; FF FF FE FE ; Subtract with carry (long,X) $FEFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$1F2C.w		; C0 2C 1F ; Compare #$1F2C.w with Y register [Reads: Y Index] [Flags: NCZ]
	rol $2C1F.w		; 2E 1F 2C ; Rotate left $2C1F.w [Flags: NCZ]
	ora $186E.w,X		; 1D 6E 18 ; OR accumulator with memory $186E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $841D.w		; 2C 1D 84 ; Test bits $841D.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $292E2F.l		; 2F 2F 2E 29 ; AND accumulator with memory (long) $292E2F.l [Writes: Accumulator] [Flags: NZ]
	rol $2F22.w		; 2E 22 2F ; Rotate left $2F22.w [Flags: NCZ]
	ora #$F834.w		; 09 34 F8 ; Logical OR #$F834.w with accumulator [Writes: Accumulator] [Flags: NZ]
	trb $F8.b		; 14 F8 ; Test and reset bits $F8.b [Reads: Accumulator] [Flags: Z]
	bit $F0.b		; 24 F0 ; Test bits $F0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $F004E0.l		; 0F E0 04 F0 ; OR accumulator with memory (long) $F004E0.l [Writes: Accumulator] [Flags: NZ]
	sta $E8.b,S		; 83 E8 ; Store accumulator (stack relative) $E8.b,S [Reads: Stack Pointer, Accumulator]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F8.b,X		; 34 F8 ; Test bits $F8.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	pea $ECF4.w		; F4 F4 EC ; Push absolute address $ECF4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $50, $EC		; 50 EC ; Branch if overflow clear to $50, $EC [Flow: branch]
	jsl $0001F4.l		; 22 F4 01 00 ; Jump to subroutine long $0001F4.l [Writes: Stack Pointer] [Flow: call]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	ora #$0F1C.w		; 09 1C 0F ; Logical OR #$0F1C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($1E.b),Y		; 31 1E ; AND accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $1F		; 30 1F ; Branch if minus to $30, $1F [Flow: branch]
	stz $3F.b		; 64 3F ; Store zero to $3F.b
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and $012F83.l,X		; 3F 83 2F 01 ; AND accumulator with memory (long,X) $012F83.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3E.b		; 05 3E ; Logical OR $3E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $007F7F.l,X		; 3F 7F 7F 00 ; AND accumulator with memory (long,X) $007F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $F0, $8C		; F0 8C ; Branch if equal to $F0, $8C [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	tsb $26F8.w		; 0C F8 26 ; Test and set bits $26F8.w [Reads: Accumulator] [Flags: Z]
	jsr ($FC16.w,X)		; FC 16 FC ; Jump to subroutine indirect indexed ($FC16.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $B7.b,S		; 83 B7 ; Store accumulator (stack relative) $B7.b,S [Reads: Stack Pointer, Accumulator]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($7C.b,S),Y		; 33 7C ; AND accumulator (stack relative indirect indexed) ($7C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	bit $145F.w		; 2C 5F 14 ; Test bits $145F.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $1B03.w		; 2D 03 1B ; Logical AND $1B03.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$15.b]		; 07 15 ; OR accumulator with memory (long) [$15.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $181F28.l		; 0F 28 1F 18 ; OR accumulator with memory (long) $181F28.l [Writes: Accumulator] [Flags: NZ]
	bit $6F5E.w,X		; 3C 5E 6F ; Test bits $6F5E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $171B.w,X		; 3D 1B 17 ; AND accumulator with memory $171B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $2C0018.l		; 2F 18 00 2C ; AND accumulator with memory (long) $2C0018.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr $FA34.w,X		; 5E 34 FA ; Logical shift right $FA34.w,X [Reads: X Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ldy $C0.b,X		; B4 C0 ; Load Y register $C0.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy #$F0A8.w		; A0 A8 F0 ; Load #$F0A8.w into Y register [Writes: Y Index] [Flags: NZ]
	trb $F8.b		; 14 F8 ; Test and reset bits $F8.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $F67A.w,X		; 3C 7A F6 ; Test bits $F67A.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jsr ($E8B8.w,X)		; FC B8 E8 ; Jump to subroutine indirect indexed ($E8B8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pea $36F0.w		; F4 F0 36 ; Push absolute address $36F0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7C.b,S),Y		; 13 7C ; OR accumulator (stack relative indirect indexed) ($7C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$79.b]		; 07 79 ; OR accumulator with memory (long) [$79.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $F8.b		; 06 F8 ; Arithmetic shift left $F8.b [Reads: Direct Page] [Flags: NCZ]
	ora [$FC.b]		; 07 FC ; OR accumulator with memory (long) [$FC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor [$83.b]		; 47 83 ; Exclusive OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$0300.w		; A0 00 03 ; Load #$0300.w into Y register [Writes: Y Index] [Flags: NZ]
	adc $FFFF7E.l,X		; 7F 7E FF FF ; Add long $FFFF7E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $38.b		; 86 38 ; Store X register to $38.b [Reads: X Index]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	rol $9EE0.w,X		; 3E E0 9E ; Rotate left $9EE0.w,X [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $E23FE2.l,X		; 1F E2 3F E2 ; Logical OR long $E23FE2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $48.b		; 84 48 ; Store Y register to $48.b [Reads: Y Index]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $FFFF.w,X		; 7E FF FF ; Rotate right $FFFF.w,X [Reads: X Index] [Flags: NCZ]
	sta $90.b,S		; 83 90 ; Store accumulator (stack relative) $90.b,S [Reads: Stack Pointer, Accumulator]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3C0D.w,X		; 1E 0D 3C ; Arithmetic shift left $3C0D.w,X [Reads: X Index] [Flags: NCZ]
	ora ($7C.b,S),Y		; 13 7C ; OR accumulator (stack relative indirect indexed) ($7C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $7E.b,S		; 03 7E ; OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $8446.w,Y		; F9 46 84 ; Subtract with carry $8446.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$0203.w		; A0 03 02 ; Load #$0203.w into Y register [Writes: Y Index] [Flags: NZ]
	adc ($E3.b,S),Y		; 73 E3 ; Add with carry (stack relative indirect indexed) ($E3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($83.b),Y		; F1 83 ; Subtract with carry ($83.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $B0, $BC		; B0 BC ; Branch if carry set to $B0, $BC [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	rol $7EC0.w,X		; 3E C0 7E ; Rotate left $7EC0.w,X [Reads: X Index] [Flags: NCZ]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	cop $9F.b		; 02 9F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $83, $29		; 62 83 29 ; Push effective relative address $62, $83, $29 [Writes: Stack Pointer]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $C7CE.w,X		; FE CE C7 ; Increment memory $C7CE.w,X [Reads: X Index] [Flags: NZ]
	sta $00908B.l		; 8F 8B 90 00 ; Store accumulator (long) $00908B.l [Reads: Accumulator]
	ora $CF.b,S		; 03 CF ; OR accumulator with stack relative $CF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $E7		; 30 E7 ; Branch if minus to $30, $E7 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sty $A0.b		; 84 A0 ; Store Y register to $A0.b [Reads: Y Index]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($C1.b),Y		; 71 C1 ; Add with carry ($C1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $84.b,S		; E3 84 ; Subtract stack-relative $84.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $00FC.w		; 20 FC 00 ; Jump to subroutine at $00FC.w [Writes: Stack Pointer] [Flow: call]
	inc $CE30.w,X		; FE 30 CE ; Increment memory $CE30.w,X [Reads: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$6A.b],Y		; 97 6A ; Store accumulator (long indexed) [$6A.b],Y [Reads: Direct Page, Y Index, Accumulator]
	cmp $488532.l		; CF 32 85 48 ; Compare accumulator (long) $488532.l [Reads: Accumulator] [Flags: NCZ]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $0001FF.l		; EF FF 01 00 ; Subtract with carry (long) $0001FF.l [Writes: Accumulator] [Flags: NCVZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $3806.w,X		; 1E 06 38 ; Arithmetic shift left $3806.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($10.b,S),Y		; 33 10 ; AND accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$23.b]		; 67 23 ; Add with carry (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($CC24.w)		; 6C 24 CC ; Jump indirect to ($CC24.w) [Flow: jump]
	mvp $07,$01		; 44 01 07 ; Move block positive $07,$01 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $7F3F3F.l,X		; 1F 3F 3F 7F ; Logical OR long $7F3F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $025E85.l,X		; 7F 85 5E 02 ; Add long $025E85.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $00FF06.l,X		; FF 06 FF 00 ; Subtract with carry (long,X) $00FF06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $55.b		; 00 55 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $55AA02.l,X		; FF 02 AA 55 ; Subtract with carry (long,X) $55AA02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $1F43.w		; 2E 43 1F ; Rotate left $1F43.w [Flags: NCZ]
	bit $D58F.w		; 2C 8F D5 ; Test bits $D58F.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $02F483.l		; 2F 83 F4 02 ; AND accumulator with memory (long) $02F483.l [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $2202ED.l		; 8F ED 02 22 ; Store accumulator (long) $2202ED.l [Reads: Accumulator]
	pea $780C.w		; F4 0C 78 ; Push absolute address $780C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and $2D3F4A.l,X		; 3F 4A 3F 2D ; AND accumulator with memory (long,X) $2D3F4A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $101F23.l,X		; 1F 23 1F 10 ; Logical OR long $101F23.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $03030C.l		; 0F 0C 03 03 ; OR accumulator with memory (long) $03030C.l [Writes: Accumulator] [Flags: NZ]
	jsl $7F1400.l		; 22 00 14 7F ; Jump to subroutine long $7F1400.l [Writes: Stack Pointer] [Flow: call]
	eor $10232D.l		; 4F 2D 23 10 ; Exclusive OR accumulator with memory (long) $10232D.l [Writes: Accumulator] [Flags: NZ]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsr ($FC5A.w,X)		; FC 5A FC ; Jump to subroutine indirect indexed ($FC5A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldy $F8.b,X		; B4 F8 ; Load Y register $F8.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cpy $F8.b		; C4 F8 ; Compare $F8.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$22C0.w		; C0 C0 22 ; Compare #$22C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy $C4.b,X		; B4 C4 ; Load Y register $C4.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	eor $56.b,S		; 43 56 ; Exclusive OR accumulator with stack relative $56.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $5A04.w,Y		; 39 04 5A ; AND accumulator with memory $5A04.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $1F2C.w,X		; 3D 2C 1F ; AND accumulator with memory $1F2C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($84.b,S),Y		; 13 84 ; OR accumulator (stack relative indirect indexed) ($84.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit #$0904.w		; 89 04 09 ; Test bits #$0904.w with accumulator [Reads: Accumulator] [Flags: Z]
	and $5D595B.l		; 2F 5B 59 5D ; AND accumulator with memory (long) $5D595B.l [Writes: Accumulator] [Flags: NZ]
	and $030C13.l		; 2F 13 0C 03 ; AND accumulator with memory (long) $030C13.l [Writes: Accumulator] [Flags: NZ]
	bit $D8.b,X		; 34 D8 ; Test bits $D8.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $6A.b,S		; 43 6A ; Exclusive OR accumulator with stack relative $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $5A04.w		; 9C 04 5A ; Store zero to $5A04.w
	ldy $F834.w,X		; BC 34 F8 ; Load Y register $F834.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sty $A1.b		; 84 A1 ; Store Y register to $A1.b [Reads: Y Index]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	pea $9ADA.w		; F4 DA 9A ; Push absolute address $9ADA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	pea $30C8.w		; F4 C8 30 ; Push absolute address $30C8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpy #$2FF0.w		; C0 F0 2F ; Compare #$2FF0.w with Y register [Reads: Y Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $40FF43.l,X		; FF 43 FF 40 ; Subtract with carry (long,X) $40FF43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $306F20.l,X		; 5F 20 6F 30 ; Exclusive OR accumulator with memory (long,X) $306F20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($1C.b,S),Y		; 33 1C ; AND accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $0F0F.w		; 1C 0F 0F ; Test and reset bits $0F0F.w [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $3F7F7F.l,X		; FF 7F 7F 3F ; Subtract with carry (long,X) $3F7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF030F.l,X		; 1F 0F 03 FF ; Logical OR long $FF030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$FF		; C2 FF
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $0302.w,X		; BC 02 03 ; Load Y register $0302.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy $3838.w		; CC 38 38 ; Compare $3838.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $8B		; F0 8B ; Branch if equal to $F0, $8B [Flow: branch]
	cpy $02.b		; C4 02 ; Compare $02.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $FF42.w,X		; FD 42 FF ; Subtract with carry $FF42.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0D32.w		; 09 32 0D ; Logical OR #$0D32.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $13.b		; 04 13 ; Test and set bits $13.b [Reads: Accumulator] [Flags: Z]
	sbc $49DF.w,X		; FD DF 49 ; Subtract with carry $49DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $30		; 50 30 ; Branch if overflow clear to $50, $30 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $BF03.w		; 0C 03 BF ; Test and set bits $BF03.w [Reads: Accumulator] [Flags: Z]
	.db $42, $FF		; 42 FF ; Reserved instruction
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $4C		; 90 4C ; Branch if carry clear to $90, $4C [Flow: branch]
	.db $B0, $18		; B0 18 ; Branch if carry set to $B0, $18 [Flow: branch]
	cpx #$A283.w		; E0 83 A2 ; Compare #$A283.w with X register [Reads: X Index] [Flags: NCZ]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	and ($BF.b,X)		; 21 BF ; Logical AND ($BF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta ($0A.b)		; 92 0A ; Store accumulator (indirect) ($0A.b) [Reads: Direct Page, Accumulator]
	tsb $3018.w		; 0C 18 30 ; Test and set bits $3018.w [Reads: Accumulator] [Flags: Z]
	cpy #$00FF.w		; C0 FF 00 ; Compare #$00FF.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $708F30.l		; CF 30 8F 70 ; Compare accumulator (long) $708F30.l [Reads: Accumulator] [Flags: NCZ]
	eor #$4036.w		; 49 36 40 ; Exclusive OR #$4036.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $1F0E31.l,X		; 3F 31 0E 1F ; AND accumulator with memory (long,X) $1F0E31.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $404083.l		; 8F 83 40 40 ; Store accumulator (long) $404083.l [Reads: Accumulator]
	and ($1F.b),Y		; 31 1F ; AND accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $8A.b		; 02 8A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sty $C6.b		; 84 C6 ; Store Y register to $C6.b [Reads: Y Index]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $783C.w,X		; 3E 3C 78 ; Rotate left $783C.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	cmp $DA48.w,Y		; D9 48 DA ; Compare accumulator $DA48.w,Y [Reads: Y Index] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sta $A0.b,S		; 83 A0 ; Store accumulator (stack relative) $A0.b,S [Reads: Stack Pointer, Accumulator]
	ora $87.b		; 05 87 ; Logical OR $87.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$4705.w		; A0 05 47 ; Load #$4705.w into Y register [Writes: Y Index] [Flags: NZ]
	inc $0FFD.w,X		; FE FD 0F ; Increment memory $0FFD.w,X [Reads: X Index] [Flags: NZ]
	jsr ($F203.w,X)		; FC 03 F2 ; Jump to subroutine indirect indexed ($F203.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $30CF.w		; 0D CF 30 ; Logical OR $30CF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($2C.b,S),Y		; D3 2C ; Compare accumulator (stack relative indirect indexed) ($2C.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	lda [$58.b]		; A7 58 ; Load accumulator (long) [$58.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $7E51.w		; AE 51 7E ; Load $7E51.w into X register [Writes: X Index] [Flags: NZ]
	sta ($39.b,X)		; 81 39 ; Store accumulator ($39.b,X) [Reads: Direct Page, Accumulator, X Index]
	dec $27.b		; C6 27 ; Decrement $27.b [Reads: Direct Page] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0060.w		; 2E 60 00 ; Rotate left $0060.w [Flags: NCZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000213.l,X		; FF 13 02 00 ; Subtract with carry (long,X) $000213.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $1C.b		; 02 1C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0D14.w		; 0C 14 0D ; Test and set bits $0D14.w [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: NCZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F1F22.l		; 0F 22 1F 0F ; OR accumulator with memory (long) $0F1F22.l [Writes: Accumulator] [Flags: NZ]
	ora [$40.b],Y		; 17 40 ; OR accumulator with memory (long indexed) [$40.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0090.w		; 20 90 00 ; Jump to subroutine at $0090.w [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $B0, $A8		; B0 A8 ; Branch if carry set to $B0, $A8 [Flow: branch]
	.db $30, $58		; 30 58 ; Branch if minus to $30, $58 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clv		; B8 ; Clear overflow flag [Flags: V]
	eor $40.b,S		; 43 40 ; Exclusive OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $7019.w		; 20 19 70 ; Jump to subroutine at $7019.w [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $000C13.l		; 0F 13 0C 00 ; OR accumulator with memory (long) $000C13.l [Writes: Accumulator] [Flags: NZ]
	ora #$1705.w		; 09 05 17 ; Logical OR #$1705.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $141F22.l		; 0F 22 1F 14 ; OR accumulator with memory (long) $141F22.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$4000.w		; C0 00 40 ; Compare #$4000.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $30		; 80 30 ; Branch always to $80, $30 [Flow: branch]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E8		; 80 E8 ; Branch always to $80, $E8 [Flow: branch]
	cpx #$F0FC.w		; E0 FC F0 ; Compare #$F0FC.w with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$E0C0.w		; E0 C0 E0 ; Compare #$E0C0.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $5FE0F0.l		; 22 F0 E0 5F ; Jump to subroutine long $5FE0F0.l [Writes: Stack Pointer] [Flow: call]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1C00.w		; 0D 00 1C ; Logical OR $1C00.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0D1E.w		; 0D 1E 0D ; Logical OR $0D1E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $3A1C.w,X		; 3E 1C 3A ; Rotate left $3A1C.w,X [Reads: X Index] [Flags: NCZ]
	asl $0C00.w		; 0E 00 0C ; Arithmetic shift left $0C00.w [Flags: NCZ]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: NCZ]
	ora $3F3D1D.l,X		; 1F 1D 3D 3F ; Logical OR long $3F3D1D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $B080.w		; 20 80 B0 ; Jump to subroutine at $B080.w [Writes: Stack Pointer] [Flow: call]
	jsr $10B8.w		; 20 B8 10 ; Jump to subroutine at $10B8.w [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $70, $7C		; 70 7C ; Branch if overflow set to $70, $7C [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jmp $9070.w		; 4C 70 90 ; Jump to $9070.w [Flow: jump]
	cpx #$70E0.w		; E0 E0 70 ; Compare #$70E0.w with X register [Reads: X Index] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldy $01FC.w,X		; BC FC 01 ; Load Y register $01FC.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3F.b,X		; 15 3F ; OR accumulator with memory $3F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0C0604.l,X		; 1F 04 06 0C ; Logical OR long $0C0604.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3F1713.l		; 0F 13 17 3F ; OR accumulator with memory (long) $3F1713.l [Writes: Accumulator] [Flags: NZ]
	and $600000.l,X		; 3F 00 00 60 ; AND accumulator with memory (long,X) $600000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$4070.w		; A0 70 40 ; Load #$4070.w into Y register [Writes: Y Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$A85C.w		; C0 5C A8 ; Compare #$A85C.w with Y register [Reads: Y Index] [Flags: NCZ]
	sty $F8.b,X		; 94 F8 ; Store Y register $F8.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$F0F0.w		; A0 F0 F0 ; Load #$F0F0.w into Y register [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jsr ($43FC.w,X)		; FC FC 43 ; Jump to subroutine indirect indexed ($43FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$022B.w		; E0 2B 02 ; Compare #$022B.w with X register [Reads: X Index] [Flags: NCZ]
	brk $3A.b		; 00 3A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($67.b,X)		; 01 67 ; Logical OR ($67.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $1C3F3C.l,X		; 7F 3C 3F 1C ; Add long $1C3F3C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($040F.w,X)		; 7C 0F 04 ; Jump indirect indexed to ($040F.w,X) [Reads: X Index] [Flow: jump]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $5F3C7C.l,X		; 7F 7C 3C 5F ; Add long $5F3C7C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$8830.w		; C0 30 88 ; Compare #$8830.w with Y register [Reads: Y Index] [Flags: NCZ]
	mvp $A8,$10		; 44 10 A8 ; Move block positive $A8,$10 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx $00.b		; E4 00 ; Compare $00.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$E038.w		; E0 38 E0 ; Compare #$E038.w with X register [Reads: X Index] [Flags: NCZ]
	jsr $D8C0.w		; 20 C0 D8 ; Jump to subroutine at $D8C0.w [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $F0, $78		; F0 78 ; Branch if equal to $F0, $78 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $3E18.w		; 1C 18 3E ; Test and reset bits $3E18.w [Reads: Accumulator] [Flags: Z]
	bit $7F.b,X		; 34 7F ; Test bits $7F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $197F.w,X		; 3C 7F 19 ; Test bits $197F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc $1B0023.l,X		; 7F 23 00 1B ; Add long $1B0023.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $193C.w,X		; 3C 3C 19 ; Test bits $193C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3E3F.w		; 0C 3F 3E ; Test and set bits $3E3F.w [Reads: Accumulator] [Flags: Z]
	adc $C7FF6F.l,X		; 7F 6F FF C7 ; Add long $C7FF6F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FEFFEE.l,X		; FF EE FF FE ; Subtract with carry (long,X) $FEFFEE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FFFC.l,X		; FF FC FF 00 ; Subtract with carry (long,X) $00FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $7F3E.w		; 0C 3E 7F ; Test and set bits $7F3E.w [Reads: Accumulator] [Flags: Z]
	sbc $FCFEFE.l,X		; FF FE FE FC ; Subtract with carry (long,X) $FCFEFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $3C.b,S		; 43 3C ; Exclusive OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $443E00.l,X		; FF 00 3E 44 ; Subtract with carry (long,X) $443E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FE457F.l,X		; FF 7F 45 FE ; Subtract with carry (long,X) $FE457F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFC04.l,X		; FF 04 FC FC ; Subtract with carry (long,X) $FCFC04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: NZ]
	jsl $23E0FE.l		; 22 FE E0 23 ; Jump to subroutine long $23E0FE.l [Writes: Stack Pointer] [Flow: call]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	jmp ($C2FE.w,X)		; 7C FE C2 ; Jump indirect indexed to ($C2FE.w,X) [Reads: X Index] [Flow: jump]
	sbc $FCFFCE.l,X		; FF CE FF FC ; Subtract with carry (long,X) $FCFFCE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $40FEF0.l,X		; FF F0 FE 40 ; Subtract with carry (long,X) $40FEF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($F800.w,X)		; FC 00 F8 ; Jump to subroutine indirect indexed ($F800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $7C		; 70 7C ; Branch if overflow set to $70, $7C [Flow: branch]
	inc $FCFE.w,X		; FE FE FC ; Increment memory $FCFE.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $367F26.l,X		; 7F 26 7F 36 ; Add long $367F26.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $003F1C.l,X		; 7F 1C 3F 00 ; Add long $003F1C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $1C00.w,X		; 3E 00 1C ; Rotate left $1C00.w,X [Reads: X Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3D.b,S		; 03 3D ; OR accumulator with stack relative $3D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $1C3E.w,X		; 3E 3E 1C ; Rotate left $1C3E.w,X [Reads: X Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	eor $C0.b		; 45 C0 ; Exclusive OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $27		; F0 27 ; Branch if equal to $F0, $27 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $11,$3F		; 54 3F 11 ; Move block negative $11,$3F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rol $3C19.w,X		; 3E 19 3C ; Rotate left $3C19.w,X [Reads: X Index] [Flags: NCZ]
	ora $0E0D1E.l,X		; 1F 1E 0D 0E ; Logical OR long $0E0D1E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $0B0F1F.l,X		; 3F 1F 0F 0B ; AND accumulator with memory (long,X) $0B0F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jmp ($0C98.w,X)		; 7C 98 0C ; Jump indirect indexed to ($0C98.w,X) [Reads: X Index] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $B0, $70		; B0 70 ; Branch if carry set to $B0, $70 [Flow: branch]
	cpx #$C0F0.w		; E0 F0 C0 ; Compare #$C0F0.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	jsr $CC00.w		; 20 00 CC ; Jump to subroutine at $CC00.w [Writes: Stack Pointer] [Flow: call]
	jmp.w [$F8FC]		; DC FC F8 ; Jump long indirect [$F8FC] [Flow: jump]
	.db $F0, $D0		; F0 D0 ; Branch if equal to $F0, $D0 [Flow: branch]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	and $304F10.l		; 2F 10 4F 30 ; AND accumulator with memory (long) $304F10.l [Writes: Accumulator] [Flags: NZ]
	sbc $7FFF79.l		; EF 79 FF 7F ; Subtract with carry (long) $7FFF79.l [Writes: Accumulator] [Flags: NCVZ]
	adc $0F3F01.l,X		; 7F 01 3F 0F ; Add long $0F3F01.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $001000.l,X		; 1F 00 10 00 ; Logical OR long $001000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $FD74.w,X		; 3C 74 FD ; Test bits $FD74.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $0F2F7F.l,X		; FF 7F 2F 0F ; Subtract with carry (long,X) $0F2F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	.db $F0, $BC		; F0 BC ; Branch if equal to $F0, $BC [Flow: branch]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	.db $F0, $70		; F0 70 ; Branch if equal to $F0, $70 [Flow: branch]
	cpx #$80E0.w		; E0 E0 80 ; Compare #$80E0.w with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $F0		; 10 F0 ; Branch if plus to $10, $F0 [Flow: branch]
	cpx #$0080.w		; E0 80 00 ; Compare #$0080.w with X register [Reads: X Index] [Flags: NCZ]
	and $3F1E.w,X		; 3D 1E 3F ; AND accumulator with memory $3F1E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $1A3F.w		; 1C 3F 1A ; Test and reset bits $1A3F.w [Reads: Accumulator] [Flags: Z]
	ora $0A1F0D.l,X		; 1F 0D 1F 0A ; Logical OR long $0A1F0D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $220301.l		; 0F 01 03 22 ; OR accumulator with memory (long) $220301.l [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $3F3E.w,X		; 3E 3E 3F ; Rotate left $3F3E.w,X [Reads: X Index] [Flags: NCZ]
	ora $030F1F.l,X		; 1F 1F 0F 03 ; Logical OR long $030F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ldy $4858.w		; AC 58 48 ; Load $4858.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $B0, $F8		; B0 F8 ; Branch if carry set to $B0, $F8 [Flow: branch]
	.db $50, $F0		; 50 F0 ; Branch if overflow clear to $50, $F0 [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	jsl $FC1400.l		; 22 00 14 FC ; Jump to subroutine long $FC1400.l [Writes: Stack Pointer] [Flow: call]
	jmp ($F8FC.w,X)		; 7C FC F8 ; Jump indirect indexed to ($F8FC.w,X) [Reads: X Index] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $113F10.l,X		; 3F 10 3F 11 ; AND accumulator with memory (long,X) $113F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0F03.w,X		; 1E 03 0F ; Arithmetic shift left $0F03.w,X [Reads: X Index] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $3F1400.l		; 22 00 14 3F ; Jump to subroutine long $3F1400.l [Writes: Stack Pointer] [Flow: call]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03070F.l,X		; 1F 0F 07 03 ; Logical OR long $03070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($FC08.w,X)		; FC 08 FC ; Jump to subroutine indirect indexed ($FC08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cpy #$00F0.w		; C0 F0 00 ; Compare #$00F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$C0C0.w		; E0 C0 C0 ; Compare #$C0C0.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $FC1400.l		; 22 00 14 FC ; Jump to subroutine long $FC1400.l [Writes: Stack Pointer] [Flow: call]
	jmp.w [$F8DC]		; DC DC F8 ; Jump long indirect [$F8DC] [Flow: jump]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpy #$7F00.w		; C0 00 7F ; Compare #$7F00.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $220707.l,X		; 1F 07 07 22 ; Logical OR long $220707.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $3F2F37.l,X		; 7F 37 2F 3F ; Add long $3F2F37.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00071F.l,X		; 3F 1F 07 00 ; AND accumulator with memory (long,X) $00071F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$F094.w		; E0 94 F0 ; Compare #$F094.w with X register [Reads: X Index] [Flags: NCZ]
	ldx $F0.b,Y		; B6 F0 ; Load X register $F0.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sta $D1.b,S		; 83 D1 ; Store accumulator (stack relative) $D1.b,S [Reads: Stack Pointer, Accumulator]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($DC83.w,X)		; FC 83 DC ; Jump to subroutine indirect indexed ($DC83.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$023F.w		; 09 3F 02 ; Logical OR #$023F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $043F06.l,X		; 3F 06 3F 04 ; AND accumulator with memory (long,X) $043F06.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0E1F0C.l,X		; 1F 0C 1F 0E ; Logical OR long $0E1F0C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3F1F43.l,X		; 1F 43 1F 3F ; Logical OR long $3F1F43.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $431F1F.l		; 0F 1F 1F 43 ; OR accumulator with memory (long) $431F1F.l [Writes: Accumulator] [Flags: NZ]
	bit $00FF.w,X		; 3C FF 00 ; Test bits $00FF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	rol $FF44.w,X		; 3E 44 FF ; Rotate left $FF44.w,X [Reads: X Index] [Flags: NCZ]
	adc $FFFE45.l,X		; 7F 45 FE FF ; Add long $FFFE45.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $30.b		; 84 30 ; Store Y register to $30.b [Reads: Y Index]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $F302.w,X		; FE 02 F3 ; Increment memory $F302.w,X [Reads: X Index] [Flags: NZ]
	sbc $FF43E7.l,X		; FF E7 43 FF ; Subtract with carry (long,X) $FF43E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: NCZ]
	and $031F07.l,X		; 3F 07 1F 03 ; AND accumulator with memory (long,X) $031F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $000F01.l,X		; 1F 01 0F 00 ; Logical OR long $000F01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $F3.b,S		; 03 F3 ; OR accumulator with stack relative $F3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$22.b]		; E7 22 ; Subtract with carry (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0100.w,Y		; 59 00 01 ; Exclusive OR accumulator with memory $0100.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$2043.w		; E0 43 20 ; Compare #$2043.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	cpy #$80F0.w		; C0 F0 80 ; Compare #$80F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$6E83.w		; E0 83 6E ; Compare #$6E83.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy #$E0E0.w		; C0 E0 E0 ; Compare #$E0E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$0080.w		; C0 80 00 ; Compare #$0080.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $367F.w,X		; 3D 7F 36 ; AND accumulator with memory $367F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $167F32.l,X		; 7F 32 7F 16 ; Add long $167F32.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $57860C.l,X		; 7F 0C 86 57 ; Add long $57860C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $3E3E.w,X		; 3D 3E 3E ; AND accumulator with memory $3E3E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $230C.w,X		; 1E 0C 23 ; Arithmetic shift left $230C.w,X [Reads: X Index] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$43C0.w		; C0 C0 43 ; Compare #$43C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$4500.w		; E0 00 45 ; Compare #$4500.w with X register [Reads: X Index] [Flags: NCZ]
	cpy #$0300.w		; C0 00 03 ; Compare #$0300.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($8000.w,X)		; FC 00 80 ; Jump to subroutine indirect indexed ($8000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$0026.w		; C0 26 00 ; Compare #$0026.w with Y register [Reads: Y Index] [Flags: NCZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $370012.l,X		; 1F 12 00 37 ; Logical OR long $370012.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $183E1C.l		; 2F 1C 3E 18 ; AND accumulator with memory (long) $183E1C.l [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3D1913.l		; 0F 13 19 3D ; OR accumulator with memory (long) $3D1913.l [Writes: Accumulator] [Flags: NZ]
	and $007E3F.l,X		; 3F 3F 7E 00 ; AND accumulator with memory (long,X) $007E3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF4442.l,X		; FF 42 44 FF ; Subtract with carry (long,X) $FF4442.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($04.b,X)		; 81 04 ; Store accumulator ($04.b,X) [Reads: Direct Page, Accumulator, X Index]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $81FF.w,X		; 7E FF 81 ; Rotate right $81FF.w,X [Reads: X Index] [Flags: NCZ]
	jsl $FF247E.l		; 22 7E 24 FF ; Jump to subroutine long $FF247E.l [Writes: Stack Pointer] [Flow: call]
	ora ($7E.b,X)		; 01 7E ; Logical OR ($7E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta ($83.b,X)		; 81 83 ; Store accumulator ($83.b,X) [Reads: Direct Page, Accumulator, X Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F880.w		; E0 80 F8 ; Compare #$F880.w with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc ($DC.b)		; F2 DC ; Subtract with carry (indirect) ($DC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	trb $C000.w		; 1C 00 C0 ; Test and reset bits $C000.w [Reads: Accumulator] [Flags: Z]
	cpx #$8CD8.w		; E0 D8 8C ; Compare #$8CD8.w with X register [Reads: X Index] [Flags: NCZ]
	jmp.w [$FE3E]		; DC 3E FE ; Jump long indirect [$FE3E] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $3B4C1C.l		; 2F 1C 4C 3B ; AND accumulator with memory (long) $3B4C1C.l [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3C2113.l		; 0F 13 21 3C ; OR accumulator with memory (long) $3C2113.l [Writes: Accumulator] [Flags: NZ]
	and $18837C.l,X		; 3F 7C 83 18 ; AND accumulator with memory (long,X) $18837C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $44.b,S		; 03 44 ; OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $C30781.l,X		; FF 81 07 C3 ; Subtract with carry (long,X) $C30781.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $817E7E.l,X		; FF 7E 7E 81 ; Subtract with carry (long,X) $817E7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	ror $FF24.w,X		; 7E 24 FF ; Rotate right $FF24.w,X [Reads: X Index] [Flags: NCZ]
	ora ($7E.b,X)		; 01 7E ; Logical OR ($7E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $83		; 10 83 ; Branch if plus to $10, $83 [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $43		; F0 43 ; Branch if equal to $F0, $43 [Flow: branch]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	asl $FC00.w		; 0E 00 FC ; Arithmetic shift left $FC00.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($7C38.w,X)		; FC 38 7C ; Jump to subroutine indirect indexed ($7C38.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit $7CFC.w,X		; 3C FC 7C ; Test bits $7CFC.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $12.b,S		; 03 12 ; OR accumulator with stack relative $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $073F.w		; 0C 3F 07 ; Test and set bits $073F.w [Reads: Accumulator] [Flags: Z]
	and $185F10.l,X		; 3F 10 5F 18 ; AND accumulator with memory (long,X) $185F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $030008.l		; 4F 08 00 03 ; Exclusive OR accumulator with memory (long) $030008.l [Writes: Accumulator] [Flags: NZ]
	ora $2F3F1F.l		; 0F 1F 3F 2F ; OR accumulator with memory (long) $2F3F1F.l [Writes: Accumulator] [Flags: NZ]
	stz $77.b		; 64 77 ; Store zero to $77.b
	sty $30.b		; 84 30 ; Store Y register to $30.b [Reads: Y Index]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$20F0.w		; C0 F0 20 ; Compare #$20F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $A0		; F0 A0 ; Branch if equal to $F0, $A0 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $C8		; 10 C8 ; Branch if plus to $10, $C8 [Flow: branch]
	.db $30, $C4		; 30 C4 ; Branch if minus to $30, $C4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cpy $23.b		; C4 23 ; Compare $23.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($03.b)		; 92 03 ; Store accumulator (indirect) ($03.b) [Reads: Direct Page, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $A0.b		; 86 A0 ; Store X register to $A0.b [Reads: X Index]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F000.w		; C0 00 F0 ; Compare #$F000.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$30F8.w		; C0 F8 30 ; Compare #$30F8.w with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $B1.b		; 84 B1 ; Store Y register to $B1.b [Reads: Y Index]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F8F0.w		; C0 F0 F8 ; Compare #$F8F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $35E000.l		; 22 00 E0 35 ; Jump to subroutine long $35E000.l [Writes: Stack Pointer] [Flow: call]
	tsb $1E0C.w		; 0C 0C 1E ; Test and set bits $1E0C.w [Reads: Accumulator] [Flags: Z]
	ora ($3F.b)		; 12 3F ; OR accumulator with memory (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $3F.b		; 14 3F ; Test and reset bits $3F.b [Reads: Accumulator] [Flags: Z]
	ora $0B3F.w,Y		; 19 3F 0B ; OR accumulator with memory $0B3F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $003F03.l,X		; 3F 03 3F 00 ; AND accumulator with memory (long,X) $003F03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $191C.w,X		; 1E 1C 19 ; Arithmetic shift left $191C.w,X [Reads: X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3F3F0F.l		; 0F 0F 3F 3F ; OR accumulator with memory (long) $3F3F0F.l [Writes: Accumulator] [Flags: NZ]
	adc $C6FF67.l,X		; 7F 67 FF C6 ; Add long $C6FF67.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFFEC.l,X		; FF EC FF FC ; Subtract with carry (long,X) $FCFFEC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FF78.l,X		; FF 78 FF 00 ; Subtract with carry (long,X) $00FF78.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FE7F3F.l		; 0F 3F 7F FE ; OR accumulator with memory (long) $FE7F3F.l [Writes: Accumulator] [Flags: NZ]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $3FFF3C.l,X		; FF 3C FF 3F ; Subtract with carry (long,X) $3FFF3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7DFF7F.l,X		; FF 7F FF 7D ; Subtract with carry (long,X) $7DFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $FC,$FF		; 44 FF FC ; Move block positive $FC,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $FE.b,X		; 15 FE ; OR accumulator with memory $FE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FFFCF8.l,X		; FF F8 FC FF ; Subtract with carry (long,X) $FFFCF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFCFD.l,X		; FF FD FC FC ; Subtract with carry (long,X) $FCFCFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FE78.w,X		; FE 78 FE ; Increment memory $FE78.w,X [Reads: X Index] [Flags: NZ]
	cpy $18FE.w		; CC FE 18 ; Compare $18FE.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $FC30.w,X		; FE 30 FC ; Increment memory $FC30.w,X [Reads: X Index] [Flags: NZ]
	cpy #$40F8.w		; C0 F8 40 ; Compare #$40F8.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $83		; F0 83 ; Branch if equal to $F0, $83 [Flow: branch]
	inc $0502.w		; EE 02 05 ; Increment $0502.w [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$2540.w		; C0 40 25 ; Compare #$2540.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $3F3C3F.l,X		; 3F 3F 3C 3F ; AND accumulator with memory (long,X) $3F3C3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0F0C43.l,X		; 1F 43 0C 0F ; Logical OR long $0F0C43.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0F1F3F.l,X		; 3F 3F 1F 0F ; AND accumulator with memory (long,X) $0F1F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $090025.l		; 0F 25 00 09 ; OR accumulator with memory (long) $090025.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $1CFC.w,X		; 3C FC 1C ; Test bits $1CFC.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jsr ($7898.w,X)		; FC 98 78 ; Jump to subroutine indirect indexed ($7898.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $3FE000.l		; 22 00 E0 3F ; Jump to subroutine long $3FE000.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jsr ($78FC.w,X)		; FC FC 78 ; Jump to subroutine indirect indexed ($78FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $040F01.l,X		; 1F 01 0F 04 ; Logical OR long $040F01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1308.w,X		; 1D 08 13 ; OR accumulator with memory $1308.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($1C.b,S),Y		; 13 1C ; OR accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($E7.b,X)		; 81 E7 ; Store accumulator ($E7.b,X) [Reads: Direct Page, Accumulator, X Index]
	ldy $FF.b		; A4 FF ; Load $FF.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($C0C0.w,X)		; FC C0 C0 ; Jump to subroutine indirect indexed ($C0C0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $E75B66.l,X		; FF 66 5B E7 ; Subtract with carry (long,X) $E75B66.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($FEC0.w,X)		; FC C0 FE ; Jump to subroutine indirect indexed ($FEC0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sty $F4.b		; 84 F4 ; Store Y register to $F4.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy $B8.b		; C4 B8 ; Compare $B8.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$0024.w		; C0 24 00 ; Compare #$0024.w with Y register [Reads: Y Index] [Flags: NCZ]
	trb $7E.b		; 14 7E ; Test and reset bits $7E.b [Reads: Accumulator] [Flags: Z]
	cpy $787C.w		; CC 7C 78 ; Compare $787C.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$00C0.w		; E0 C0 00 ; Compare #$00C0.w with X register [Reads: X Index] [Flags: NCZ]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $68.b,S		; 03 68 ; OR accumulator with stack relative $68.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$2C.b],Y		; 17 2C ; OR accumulator with memory (long indexed) [$2C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1A.b,S),Y		; 13 1A ; OR accumulator (stack relative indirect indexed) ($1A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $27E000.l		; 22 00 E0 27 ; Jump to subroutine long $27E000.l [Writes: Stack Pointer] [Flow: call]
	jmp ($3C58.w,X)		; 7C 58 3C ; Jump indirect indexed to ($3C58.w,X) [Reads: X Index] [Flow: jump]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $02BF40.l,X		; 7F 40 BF 02 ; Add long $02BF40.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F20D.w,X		; FD 0D F2 ; Subtract with carry $F20D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $007F73.l		; 8F 73 7F 00 ; Store accumulator (long) $007F73.l [Reads: Accumulator]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $D0387F.l		; 8F 7F 38 D0 ; Store accumulator (long) $D0387F.l [Reads: Accumulator]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	sta $32.b,S		; 83 32 ; Store accumulator (stack relative) $32.b,S [Reads: Stack Pointer, Accumulator]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $8040.w		; 2E 40 80 ; Rotate left $8040.w [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $F0, $90		; F0 90 ; Branch if equal to $F0, $90 [Flow: branch]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	cpy #$80C0.w		; C0 C0 80 ; Compare #$80C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $7C0B.w,X		; 3D 0B 7C ; AND accumulator with memory $7C0B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($4F.b,S),Y		; 33 4F ; AND accumulator (stack relative indirect indexed) ($4F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $217E10.l,X		; 5F 10 7E 21 ; Exclusive OR accumulator with memory (long,X) $217E10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$0C.b],Y		; 37 0C ; AND accumulator with memory (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$0707.w		; 09 07 07 ; Logical OR #$0707.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $5D6C77.l		; 4F 77 6C 5D ; Exclusive OR accumulator with memory (long) $5D6C77.l [Writes: Accumulator] [Flags: NZ]
	and $D4070F.l,X		; 3F 0F 07 D4 ; AND accumulator with memory (long,X) $D4070F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cpx $98.b		; E4 98 ; Compare $98.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
.INDEX 8
	sep #$1C		; E2 1C
	.db $62, $9C, $74		; 62 9C 74 ; Push effective relative address $62, $9C, $74 [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $31.b		; 84 31 ; Store Y register to $31.b [Reads: Y Index]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E4D4.w,X		; 3C D4 E4 ; Test bits $E4D4.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
.ACCU 8
	sep #$E2		; E2 E2
	pei ($F8.b)		; D4 F8 ; Push effective indirect address ($F8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	eor $0E3B04.l		; 4F 04 3B 0E ; Exclusive OR accumulator with memory (long) $0E3B04.l [Writes: Accumulator] [Flags: NZ]
	adc ($0F.b,S),Y		; 73 0F ; Add with carry (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $097704.l,X		; 7F 04 77 09 ; Add long $097704.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $003320.l,X		; 7F 20 33 00 ; Add long $003320.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $7F3F.w,X		; 7E 3F 7F ; Rotate right $7F3F.w,X [Reads: X Index] [Flags: NCZ]
	eor $337F6E.l		; 4F 6E 7F 33 ; Exclusive OR accumulator with memory (long) $337F6E.l [Writes: Accumulator] [Flags: NZ]
	ora ($C4.b,X)		; 01 C4 ; Logical OR ($C4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	sty $68.b,X		; 94 68 ; Store Y register $68.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
.ACCU 16
.INDEX 16
	rep #$BC		; C2 BC
	cpx $98.b		; E4 98 ; Compare $98.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	cpx #$4400.w		; E0 00 44 ; Compare #$4400.w with X register [Reads: X Index] [Flags: NCZ]
	sty $E4.b,X		; 94 E4 ; Store Y register $E4.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	.db $42, $64		; 42 64 ; Reserved instruction
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: NCZ]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	ora $0E010C.l,X		; 1F 0C 01 0E ; Logical OR long $0E010C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3F1F43.l,X		; 1F 43 1F 3F ; Logical OR long $3F1F43.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $1F010F.l		; 22 0F 01 1F ; Jump to subroutine long $1F010F.l [Writes: Stack Pointer] [Flow: call]
	ora $042088.l,X		; 1F 88 20 04 ; Logical OR long $042088.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $FC,$FF		; 44 FF FC ; Move block positive $FC,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit #$042E.w		; 89 2E 04 ; Test bits #$042E.w with accumulator [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec $FF.b		; C6 FF ; Decrement $FF.b [Reads: Direct Page] [Flags: NZ]
	ora $FF0EFF.l		; 0F FF 0E FF ; OR accumulator with memory (long) $FF0EFF.l [Writes: Accumulator] [Flags: NZ]
	tsb $0EFF.w		; 0C FF 0E ; Test and set bits $0EFF.w [Reads: Accumulator] [Flags: Z]
	sta $40.b,S		; 83 40 ; Store accumulator (stack relative) $40.b,S [Reads: Stack Pointer, Accumulator]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $C60F00.l,X		; 1F 00 0F C6 ; Logical OR long $C60F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpy #$E046.w		; C0 46 E0 ; Compare #$E046.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $EF.b,S		; 83 EF ; Store accumulator (stack relative) $EF.b,S [Reads: Stack Pointer, Accumulator]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	cpy #$8003.w		; C0 03 80 ; Compare #$8003.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1843.w,X		; 1E 43 18 ; Arithmetic shift left $1843.w,X [Reads: X Index] [Flags: NCZ]
	ora $223C00.l,X		; 1F 00 3C 22 ; Logical OR long $223C00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $1F1F19.l,X		; 3F 19 1F 1F ; AND accumulator with memory (long,X) $1F1F19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $000E.w		; 0E 0E 00 ; Arithmetic shift left $000E.w [Flags: NCZ]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F3F1F.l,X		; 1F 1F 3F 3F ; Logical OR long $3F3F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $D8000E.l,X		; 1F 0E 00 D8 ; Logical OR long $D8000E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sty $0C7C.w		; 8C 7C 0C ; Store Y register to $0C7C.w [Reads: Y Index]
	jsr ($FCDC.w,X)		; FC DC FC ; Jump to subroutine indirect indexed ($FCDC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$38.b]		; 07 38 ; OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($FCFC.w,X)		; 7C FC FC ; Jump indirect indexed to ($FCFC.w,X) [Reads: X Index] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $8F.b		; E4 8F ; Compare $8F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$F7.b]		; 07 F7 ; OR accumulator with memory (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	stz $F761.w,X		; 9E 61 F7 ; Store zero to $F761.w,X [Reads: X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$48.b],Y		; F7 48 ; Subtract with carry (long indexed) [$48.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $4342.w,X		; FD 42 43 ; Subtract with carry $4342.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $51E028.l		; 6F 28 E0 51 ; Add with carry (long) $51E028.l [Writes: Accumulator] [Flags: NCVZ]
	adc $F69697.l,X		; 7F 97 96 F6 ; Add long $F69697.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $BC		; B0 BC ; Branch if carry set to $B0, $BC [Flow: branch]
	mvn $1E,$55		; 54 55 1E ; Move block negative $1E,$55 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpx #$10EF.w		; E0 EF 10 ; Compare #$10EF.w with X register [Reads: X Index] [Flags: NCZ]
	adc $EF86.w,Y		; 79 86 EF ; Add $EF86.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $EF		; 10 EF ; Branch if plus to $10, $EF [Flow: branch]
	ora ($BF.b)		; 12 BF ; OR accumulator with memory (indirect) ($BF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $FE		; 42 FE ; Reserved instruction
	trb $14F6.w		; 1C F6 14 ; Test and reset bits $14F6.w [Reads: Accumulator] [Flags: Z]
	inc $69E9.w,X		; FE E9 69 ; Increment memory $69E9.w,X [Reads: X Index] [Flags: NZ]
	adc $223D0D.l		; 6F 0D 3D 22 ; Add with carry (long) $223D0D.l [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $2711.w		; 2E 11 27 ; Rotate left $2711.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and [$08.b],Y		; 37 08 ; AND accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $9F12.w,X		; 5D 12 9F ; Exclusive OR accumulator with memory $9F12.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $273F18.l,X		; FF 18 3F 27 ; Subtract with carry (long,X) $273F18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	.db $30, $6C		; 30 6C ; Branch if minus to $30, $6C [Flow: branch]
	cpx $E5.b		; E4 E5 ; Compare $E5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $E4E0.w		; 1C E0 E4 ; Test and reset bits $E4E0.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $BA10.w		; EC 10 BA ; Compare $BA10.w with X register [Reads: X Index] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $FF18.w,Y		; F9 18 FF ; Subtract with carry $FF18.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($64E4.w,X)		; FC E4 64 ; Jump to subroutine indirect indexed ($64E4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stz $0C.b		; 64 0C ; Store zero to $0C.b
	rol $27.b,X		; 36 27 ; Rotate left $27.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda [$38.b]		; A7 38 ; Load accumulator (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$45.b]		; 07 45 ; OR accumulator with memory (long) [$45.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $29E000.l,X		; 1F 00 E0 29 ; Logical OR long $29E000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $3001.w,X		; 3E 01 30 ; Rotate left $3001.w,X [Reads: X Index] [Flags: NCZ]
	ora $3F0837.l		; 0F 37 08 3F ; OR accumulator with memory (long) $3F0837.l [Writes: Accumulator] [Flags: NZ]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$16.b],Y		; 17 16 ; OR accumulator with memory (long indexed) [$16.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $20.b,X		; 16 20 ; Arithmetic shift left $20.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $3C27.w		; 20 27 3C ; Jump to subroutine at $3C27.w [Writes: Stack Pointer] [Flow: call]
	trb $F8E0.w		; 1C E0 F8 ; Test and reset bits $F8E0.w [Reads: Accumulator] [Flags: Z]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $64C0.w,X		; 3C C0 64 ; Test bits $64C0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($BC40.w,X)		; FC 40 BC ; Jump to subroutine indirect indexed ($BC40.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $1C		; 80 1C ; Branch always to $80, $1C [Flow: branch]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $64.b		; 24 64 ; Test bits $64.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ldy $FC7C.w,X		; BC 7C FC ; Load Y register $FC7C.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $7F1100.l,X		; 1F 00 11 7F ; Logical OR long $7F1100.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($B0.b,X)		; 01 B0 ; Logical OR ($B0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $7F0877.l		; 4F 77 08 7F ; Exclusive OR accumulator with memory (long) $7F0877.l [Writes: Accumulator] [Flags: NZ]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$16.b],Y		; 17 16 ; OR accumulator with memory (long indexed) [$16.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $A0.b,X		; 76 A0 ; Rotate right $A0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldy #$7867.w		; A0 67 78 ; Load #$7867.w into Y register [Writes: Y Index] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($38.b,X)		; 41 38 ; Exclusive OR accumulator with memory ($38.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$9078.w		; C0 78 90 ; Compare #$9078.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($DC38.w,X)		; FC 38 DC ; Jump to subroutine indirect indexed ($DC38.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cld		; D8 ; Clear decimal flag [Flags: D]
	stz $FC98.w		; 9C 98 FC ; Store zero to $FC98.w
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cpy $24.b		; C4 24 ; Compare $24.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	stz $78.b		; 64 78 ; Store zero to $78.b
	ora [$F7.b]		; 07 F7 ; OR accumulator with memory (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$DE.b]		; 67 DE ; Add with carry (long) [$DE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $44CF.w,Y		; 59 CF 44 ; Exclusive OR accumulator with memory $44CF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $23.b,S		; 63 23 ; Add with carry (stack relative) $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $1838.w		; 20 38 18 ; Jump to subroutine at $1838.w [Writes: Stack Pointer] [Flow: call]
	adc $A698B7.l,X		; 7F B7 98 A6 ; Add long $A698B7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jmp $1E275F.l		; 5C 5F 27 1E ; Jump long to $1E275F.l [Flow: jump]
	cpx #$12EF.w		; E0 EF 12 ; Compare #$12EF.w with X register [Reads: X Index] [Flags: NCZ]
	ora $7BE0.w,Y		; 19 E0 7B ; OR accumulator with memory $7BE0.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc ($22.b,S),Y		; F3 22 ; Subtract with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec $C4.b,X		; D6 C4 ; Decrement memory $C4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ror $04.b		; 66 04 ; Rotate right $04.b [Reads: Direct Page] [Flags: NCZ]
	tsb $FE08.w		; 0C 08 FE ; Test and set bits $FE08.w [Reads: Accumulator] [Flags: Z]
	sbc $651F.w		; ED 1F 65 ; Subtract $651F.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp $9A2A.w,X		; DD 2A 9A ; Compare accumulator $9A2A.w,X [Reads: X Index] [Flags: NCZ]
	pea $8FE4.w		; F4 E4 8F ; Push absolute address $8FE4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$14.b],Y		; 37 14 ; AND accumulator with memory (long indexed) [$14.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jmp ($3E3C.w,X)		; 7C 3C 3E ; Jump indirect indexed to ($3E3C.w,X) [Reads: X Index] [Flow: jump]
	asl $173F.w,X		; 1E 3F 17 ; Arithmetic shift left $173F.w,X [Reads: X Index] [Flags: NCZ]
	ora $000707.l,X		; 1F 07 07 00 ; Logical OR long $000707.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	stz $57.b		; 64 57 ; Store zero to $57.b
	eor $21.b,S		; 43 21 ; Exclusive OR accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$EC.b]		; 07 EC ; OR accumulator with memory (long) [$EC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	dec $1AC8.w		; CE C8 1A ; Decrement $1AC8.w [Flags: NZ]
	.db $10, $0A		; 10 0A ; Branch if plus to $10, $0A [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	bit $E0.b		; 24 E0 ; Test bits $E0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$00E0.w		; E0 E0 00 ; Compare #$00E0.w with X register [Reads: X Index] [Flags: NCZ]
	pei ($36.b)		; D4 36 ; Push effective indirect address ($36.b) [Reads: Direct Page] [Writes: Stack Pointer]
	inc $1CD6.w		; EE D6 1C ; Increment $1CD6.w [Flags: NZ]
	cpx $E018.w		; EC 18 E0 ; Compare $E018.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $6B9B04.l,X		; FF 04 9B 6B ; Subtract with carry (long,X) $6B9B04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $7F1E.w,X		; 7E 1E 7F ; Rotate right $7F1E.w,X [Reads: X Index] [Flags: NCZ]
	ora ($83.b,S),Y		; 13 83 ; OR accumulator (stack relative indirect indexed) ($83.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $1302.w		; 1C 02 13 ; Test and reset bits $1302.w [Reads: Accumulator] [Flags: Z]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sty $F7.b,X		; 94 F7 ; Store Y register $F7.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sbc [$61.b]		; E7 61 ; Subtract with carry (long) [$61.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($0718.w)		; 6C 18 07 ; Jump indirect to ($0718.w) [Flow: jump]
	sbc $D6D920.l,X		; FF 20 D9 D6 ; Subtract with carry (long,X) $D6D920.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $180F10.l,X		; 1F 10 0F 18 ; Logical OR long $180F10.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $1E28.w		; 0E 28 1E ; Arithmetic shift left $1E28.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $34.b,S		; 83 34 ; Store accumulator (stack relative) $34.b,S [Reads: Stack Pointer, Accumulator]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cmp $EF29.w,Y		; D9 29 EF ; Compare accumulator $EF29.w,Y [Reads: Y Index] [Flags: NCZ]
	sbc [$D6.b]		; E7 D6 ; Subtract with carry (long) [$D6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $18.b,X		; F6 18 ; Increment memory $18.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cpx #$0109.w		; E0 09 01 ; Compare #$0109.w with X register [Reads: X Index] [Flags: NCZ]
	ora #$0800.w		; 09 00 08 ; Logical OR #$0800.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F1E0F.l		; 0F 0F 1E 1F ; OR accumulator with memory (long) $1F1E0F.l [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $BC03.w		; 0C 03 BC ; Test and set bits $BC03.w [Reads: Accumulator] [Flags: Z]
	ldy #$F0FC.w		; A0 FC F0 ; Load #$F0FC.w into Y register [Writes: Y Index] [Flags: NZ]
	inc $FB6C.w,X		; FE 6C FB ; Increment memory $FB6C.w,X [Reads: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $A4.b,X		; F6 A4 ; Increment memory $A4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsr ($83D8.w,X)		; FC D8 83 ; Jump to subroutine indirect indexed ($83D8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $02.b,X		; 34 02 ; Test bits $02.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $0C5C.w		; 0D 5C 0C ; Logical OR $0C5C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($95.b)		; 92 95 ; Store accumulator (indirect) ($95.b) [Reads: Direct Page, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$04FC.w		; E0 FC 04 ; Compare #$04FC.w with X register [Reads: X Index] [Flags: NCZ]
	stz $7E64.w		; 9C 64 7E ; Store zero to $7E64.w
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $31E003.l,X		; 1F 03 E0 31 ; Logical OR long $31E003.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $020F04.l		; 0F 04 0F 02 ; OR accumulator with memory (long) $020F04.l [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc $1C1C.w,X		; 7D 1C 1C ; Add $1C1C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $1C03.w		; 0D 03 1C ; Logical OR $1C03.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $3C		; 10 3C ; Branch if plus to $10, $3C [Flow: branch]
	.db $30, $7E		; 30 7E ; Branch if minus to $30, $7E [Flow: branch]
	jmp ($EAFB.w,X)		; 7C FB EA ; Jump indirect indexed to ($EAFB.w,X) [Reads: X Index] [Flow: jump]
	inc $D4.b,X		; F6 D4 ; Increment memory $D4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsr ($F8B8.w,X)		; FC B8 F8 ; Jump to subroutine indirect indexed ($F8B8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$EC00.w		; E0 00 EC ; Compare #$EC00.w with X register [Reads: X Index] [Flags: NCZ]
	cpy $1582.w		; CC 82 15 ; Compare $1582.w with Y register [Reads: Y Index] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	mvp $E0,$98		; 44 98 E0 ; Move block positive $E0,$98 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rol $7F0E.w,X		; 3E 0E 7F ; Rotate left $7F0E.w,X [Reads: X Index] [Flags: NCZ]
	and [$7F.b]		; 27 7F ; AND accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $1838.w,Y		; 39 38 18 ; AND accumulator with memory $1838.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $830C.w		; 1C 0C 83 ; Test and reset bits $830C.w [Reads: Accumulator] [Flags: Z]
	jmp ($1F02.w,X)		; 7C 02 1F ; Jump indirect indexed to ($1F02.w,X) [Reads: X Index] [Flow: jump]
	and ($58.b),Y		; 31 58 ; AND accumulator with memory ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvn $27,$46		; 54 46 27 ; Move block negative $27,$46 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	trb $FE.b		; 14 FE ; Test and reset bits $FE.b [Reads: Accumulator] [Flags: Z]
	jsr ($CCCE.w,X)		; FC CE CC ; Jump to subroutine indirect indexed ($CCCE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $3808.w		; 0C 08 38 ; Test and set bits $3808.w [Reads: Accumulator] [Flags: Z]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx $02EA.w		; EC EA 02 ; Compare $02EA.w with X register [Reads: X Index] [Flags: NCZ]
	and ($F4.b)		; 32 F4 ; AND accumulator with memory (indirect) ($F4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	cpx $30.b		; E4 30 ; Compare $30.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $31		; B0 31 ; Branch if carry set to $B0, $31 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $68.b		; 04 68 ; Test and set bits $68.b [Reads: Accumulator] [Flags: Z]
	eor ($48.b,X)		; 41 48 ; Exclusive OR accumulator with memory ($48.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	jsr $2024.w		; 20 24 20 ; Jump to subroutine at $2024.w [Writes: Stack Pointer] [Flow: call]
	jsr $3118.w		; 20 18 31 ; Jump to subroutine at $3118.w [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	jsr $4208.w		; 20 08 42 ; Jump to subroutine at $4208.w [Writes: Stack Pointer] [Flow: call]
	tsb $80.b		; 04 80 ; Test and set bits $80.b [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsr $9074.w		; 20 74 90 ; Jump to subroutine at $9074.w [Writes: Stack Pointer] [Flow: call]
	jsl $68E010.l		; 22 10 E0 68 ; Jump to subroutine long $68E010.l [Writes: Stack Pointer] [Flow: call]
	.db $42, $80		; 42 80 ; Reserved instruction
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $10.b,X		; 74 10 ; Store zero to $10.b,X [Reads: X Index]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$7E.b]		; 07 7E ; OR accumulator with memory (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $64EF.w,Y		; 19 EF 64 ; OR accumulator with memory $64EF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $43.b,S		; C3 43 ; Compare accumulator (stack relative) $43.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cpx #$7960.w		; E0 60 79 ; Compare #$7960.w with X register [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $661817.l,X		; 3F 17 18 66 ; AND accumulator with memory (long,X) $661817.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldy $469F.w,X		; BC 9F 46 ; Load Y register $469F.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	trb $E8E0.w		; 1C E0 E8 ; Test and reset bits $E8E0.w [Reads: Accumulator] [Flags: Z]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	cpx #$987E.w		; E0 7E 98 ; Compare #$987E.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($22.b,S),Y		; F3 22 ; Subtract with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $C2.b,S		; C3 C2 ; Compare accumulator (stack relative) $C2.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and [$06.b],Y		; 37 06 ; AND accumulator with memory (long indexed) [$06.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $FC0C.w		; EE 0C FC ; Increment $FC0C.w [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $DD.b		; 66 DD ; Rotate right $DD.b [Reads: Direct Page] [Flags: NCZ]
	and $12C9.w,X		; 3D C9 12 ; AND accumulator with memory $12C9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $007F08.l,X		; FF 08 7F 00 ; Subtract with carry (long,X) $007F08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $040C07.l		; 0F 07 0C 04 ; OR accumulator with memory (long) $040C07.l [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	trb $080C.w		; 1C 0C 08 ; Test and reset bits $080C.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $8A9F6B.l		; EF 6B 9F 8A ; Subtract with carry (long) $8A9F6B.l [Writes: Accumulator] [Flags: NCVZ]
	sta $357E91.l,X		; 9F 91 7E 35 ; Store accumulator (long,X) $357E91.l,X [Reads: Accumulator, X Index]
	inc $FCCD.w,X		; FE CD FC ; Increment memory $FCCD.w,X [Reads: X Index] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $E2C7.w,Y		; F9 C7 E2 ; Subtract with carry $E2C7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $6F7594.l,X		; BF 94 75 6F ; Load long $6F7594.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	and ($E7.b,S),Y		; 33 E7 ; AND accumulator (stack relative indirect indexed) ($E7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $46807F.l,X		; 3F 7F 80 46 ; AND accumulator with memory (long,X) $46807F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$F0.b]		; 07 F0 ; OR accumulator with memory (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $F9		; 80 F9 ; Branch always to $80, $F9 [Flow: branch]
	.db $30, $EE		; 30 EE ; Branch if minus to $30, $EE [Flow: branch]
	jsr $24EC.w		; 20 EC 24 ; Jump to subroutine at $24EC.w [Writes: Stack Pointer] [Flow: call]
	jsl $800400.l		; 22 00 04 80 ; Jump to subroutine long $800400.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $C9		; F0 C9 ; Branch if equal to $F0, $C9 [Flow: branch]
	ora $00251B.l,X		; 1F 1B 25 00 ; Logical OR long $00251B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$0060.w		; 09 60 00 ; Logical OR #$0060.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	cpx #$22C0.w		; E0 C0 22 ; Compare #$22C0.w with X register [Reads: X Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $60.b,X		; 34 60 ; Test bits $60.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	.db $90, $F0		; 90 F0 ; Branch if carry clear to $90, $F0 [Flow: branch]
	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	rol $7E00.w,X		; 3E 00 7E ; Rotate left $7E00.w,X [Reads: X Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cmp $31DF78.l		; CF 78 DF 31 ; Compare accumulator (long) $31DF78.l [Reads: Accumulator] [Flags: NCZ]
	inc $FD62.w,X		; FE 62 FD ; Increment memory $FD62.w,X [Reads: X Index] [Flags: NZ]
	ora $FB.b		; 05 FB ; Logical OR $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$1737.w		; 09 37 17 ; Logical OR #$1737.w with accumulator [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jmp ($3AFF.w)		; 6C FF 3A ; Jump indirect to ($3AFF.w) [Flow: jump]
	sbc $3662.w,Y		; F9 62 36 ; Subtract with carry $3662.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E00.w		; 0C 00 1E ; Test and set bits $1E00.w [Reads: Accumulator] [Flags: Z]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $CC.b		; 04 CC ; Test and set bits $CC.b [Reads: Accumulator] [Flags: Z]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $FE		; 30 FE ; Branch if minus to $30, $FE [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	.db $50, $00		; 50 00 ; Branch if overflow clear to $50, $00 [Flow: branch]
	tsb $FE12.w		; 0C 12 FE ; Test and set bits $FE12.w [Reads: Accumulator] [Flags: Z]
	stz $C8.b,X		; 74 C8 ; Store zero to $C8.b,X [Reads: X Index]
	ldx $23BF.w,Y		; BE BF 23 ; Load X register $23BF.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $071F00.l		; 0F 00 1F 07 ; OR accumulator with memory (long) $071F00.l [Writes: Accumulator] [Flags: NZ]
	and $183F0C.l,X		; 3F 0C 3F 18 ; AND accumulator with memory (long,X) $183F0C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $3D10.w,X		; 3E 10 3D ; Rotate left $3D10.w,X [Reads: X Index] [Flags: NCZ]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$2F.b],Y		; 17 2F ; OR accumulator with memory (long indexed) [$2F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $1E3B.w,X		; 3D 3B 1E ; AND accumulator with memory $1E3B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0090.w		; 09 90 00 ; Logical OR #$0090.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $F8		; 90 F8 ; Branch if carry clear to $90, $F8 [Flow: branch]
	.db $90, $DC		; 90 DC ; Branch if carry clear to $90, $DC [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsl $900500.l		; 22 00 05 90 ; Jump to subroutine long $900500.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	stz $01.b,X		; 74 01 ; Store zero to $01.b,X [Reads: X Index]
	jsl $071800.l		; 22 00 18 07 ; Jump to subroutine long $071800.l [Writes: Stack Pointer] [Flow: call]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1A.b,S		; 03 1A ; OR accumulator with stack relative $1A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0D32.w		; 0D 32 0D ; Logical OR $0D32.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $BF1E.w,Y		; 39 1E BF ; AND accumulator with memory $BF1E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3F0D.w,X		; 1D 0D 3F ; OR accumulator with memory $3F0D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C0C0E0.l,X		; 3F E0 C0 C0 ; AND accumulator with memory (long,X) $C0C0E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$80C0.w		; E0 C0 80 ; Compare #$80C0.w with X register [Reads: X Index] [Flags: NCZ]
	cpx $34.b		; E4 34 ; Compare $34.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $0C.b,X		; 35 0C ; Logical AND $0C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $7E.b,S		; 03 7E ; OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $7CFF7B.l		; EF 7B FF 7C ; Subtract with carry (long) $7CFF7B.l [Writes: Accumulator] [Flags: NCVZ]
	adc $03013E.l,X		; 7F 3E 01 03 ; Add long $03013E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $7FFFFF.l,X		; 7F FF FF 7F ; Add long $7FFFFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$D07E.w		; C0 7E D0 ; Compare #$D07E.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$DE.b],Y		; F7 DE ; Subtract with carry (long indexed) [$DE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FE.b]		; E7 FE ; Subtract with carry (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $80FC.w		; 0E FC 80 ; Arithmetic shift left $80FC.w [Flags: NCZ]
	cpy #$F040.w		; C0 40 F0 ; Compare #$F040.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: NZ]
	inc $2C7C.w,X		; FE 7C 2C ; Increment memory $2C7C.w,X [Reads: X Index] [Flags: NZ]
	adc $133F17.l,X		; 7F 17 3F 13 ; Add long $133F17.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $33733F.l,X		; 7F 3F 73 33 ; Add long $33733F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $1C.b,S		; 83 1C ; Store accumulator (stack relative) $1C.b,S [Reads: Stack Pointer, Accumulator]
	cop $13.b		; 02 13 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($68.b,S),Y		; 53 68 ; XOR accumulator (stack relative indirect indexed) ($68.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $4C40.w		; 2C 40 4C ; Test bits $4C40.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $9E.b		; 14 9E ; Test and reset bits $9E.b [Reads: Accumulator] [Flags: Z]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$F6D8]		; DC D8 F6 ; Jump long indirect [$F6D8] [Flow: jump]
	bit $C6.b,X		; 34 C6 ; Test bits $C6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy $1C.b		; C4 1C ; Compare $1C.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $34.b,S		; 83 34 ; Store accumulator (stack relative) $34.b,S [Reads: Stack Pointer, Accumulator]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	nop		; EA ; No operation
	ror $24.b		; 66 24 ; Rotate right $24.b [Reads: Direct Page] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx #$010D.w		; E0 0D 01 ; Compare #$010D.w with X register [Reads: X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $19.b		; 05 19 ; Logical OR $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1716.w		; 0E 16 17 ; Arithmetic shift left $1716.w [Flags: NCZ]
	asl $0023.w		; 0E 23 00 ; Arithmetic shift left $0023.w [Flags: NCZ]
	tsb $B9FE.w		; 0C FE B9 ; Test and set bits $B9FE.w [Reads: Accumulator] [Flags: Z]
	lda $377F06.l,X		; BF 06 7F 37 ; Load long $377F06.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $44FE1A.l,X		; 9F 1A FE 44 ; Store accumulator (long,X) $44FE1A.l,X [Reads: Accumulator, X Index]
	ror $1C00.w,X		; 7E 00 1C ; Rotate right $1C00.w,X [Reads: X Index] [Flags: NCZ]
	jsl $7F0700.l		; 22 00 07 7F ; Jump to subroutine long $7F0700.l [Writes: Stack Pointer] [Flow: call]
	lda $E548.w,Y		; B9 48 E5 ; Load $E548.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ror $001C.w,X		; 7E 1C 00 ; Rotate right $001C.w,X [Reads: X Index] [Flags: NCZ]
	sta [$A8.b],Y		; 97 A8 ; Store accumulator (long indexed) [$A8.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$D8.b]		; 47 D8 ; Exclusive OR accumulator with memory (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $AC		; 80 AC ; Branch always to $80, $AC [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx $FEA0.w		; EC A0 FE ; Compare $FEA0.w with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $FE		; B0 FE ; Branch if carry set to $B0, $FE [Flow: branch]
	.db $90, $FE		; 90 FE ; Branch if carry clear to $90, $FE [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	jsr ($7070.w,X)		; FC 70 70 ; Jump to subroutine indirect indexed ($7070.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldy #$B458.w		; A0 58 B4 ; Load #$B458.w into Y register [Writes: Y Index] [Flags: NZ]
	jmp.w [$EECE]		; DC CE EE ; Jump long indirect [$EECE] [Flow: jump]
	stx $8C.b,Y		; 96 8C ; Store X register $8C.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	.db $D0, $1F		; D0 1F ; Branch if not equal to $D0, $1F [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $041703.l,X		; 1F 03 17 04 ; Logical OR long $041703.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$05.b]		; 27 05 ; AND accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $106E08.l,X		; 7F 08 6E 10 ; Add long $106E08.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$1C.b],Y		; 17 1C ; OR accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$5F.b],Y		; 57 5F ; Exclusive OR accumulator with memory (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($01.b,S),Y		; 33 01 ; AND accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $B0, $9F		; B0 9F ; Branch if carry set to $B0, $9F [Flow: branch]
	ror $2E.b,X		; 76 2E ; Rotate right $2E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy $F8F8.w		; CC F8 F8 ; Compare $F8F8.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$C040.w		; E0 40 C0 ; Compare #$C040.w with X register [Reads: X Index] [Flags: NCZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FCFE.w,Y		; F9 FE FC ; Subtract with carry $FCFE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $A0		; B0 A0 ; Branch if carry set to $B0, $A0 [Flow: branch]
	cpy #$1C83.w		; C0 83 1C ; Compare #$1C83.w with Y register [Reads: Y Index] [Flags: NCZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $DE.b		; 00 DE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($F09C.w)		; 6C 9C F0 ; Jump indirect to ($F09C.w) [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$C080.w		; E0 80 C0 ; Compare #$C080.w with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	jsl $F21F00.l		; 22 00 1F F2 ; Jump to subroutine long $F21F00.l [Writes: Stack Pointer] [Flow: call]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $68FE30.l,X		; 7F 30 FE 68 ; Add long $68FE30.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $367F5A.l,X		; FF 5A 7F 36 ; Subtract with carry (long,X) $367F5A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $FC0C.w,X		; 7E 0C FC ; Rotate right $FC0C.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $E5F6.w,X		; 7D F6 E5 ; Add $E5F6.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $A47E.w		; 4D 7E A4 ; Exclusive OR $A47E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $282FE0.l,X		; FF E0 2F 28 ; Subtract with carry (long,X) $282FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($79.b,X)		; 01 79 ; Logical OR ($79.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$FA.b]		; 07 FA ; OR accumulator with memory (long) [$FA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$74.b]		; 07 74 ; OR accumulator with memory (long) [$74.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $280F32.l		; 0F 32 0F 28 ; OR accumulator with memory (long) $280F32.l [Writes: Accumulator] [Flags: NZ]
	mvn $96,$63		; 54 63 96 ; Move block negative $96,$63 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc #$778B.w		; 69 8B 77 ; Add #$778B.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and ($14.b,S),Y		; 33 14 ; AND accumulator (stack relative indirect indexed) ($14.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $9E		; 80 9E ; Branch always to $80, $9E [Flow: branch]
	cpx #$E05F.w		; E0 5F E0 ; Compare #$E05F.w with X register [Reads: X Index] [Flags: NCZ]
	ldx $4C70.w		; AE 70 4C ; Load $4C70.w into X register [Writes: X Index] [Flags: NZ]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dec $69.b		; C6 69 ; Decrement $69.b [Reads: Direct Page] [Flags: NZ]
	stx $D1.b,Y		; 96 D1 ; Store X register $D1.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ror $27CC.w		; 6E CC 27 ; Rotate right $27CC.w [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	jmp $EE30.w		; 4C 30 EE ; Jump to $EE30.w [Flow: jump]
	trb $CF.b		; 14 CF ; Test and reset bits $CF.b [Reads: Accumulator] [Flags: Z]
	and ($23.b)		; 32 23 ; AND accumulator with memory (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $7C		; 30 7C ; Branch if minus to $30, $7C [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	lda $0027.w,X		; BD 27 00 ; Load $0027.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2877.w		; 0C 77 28 ; Test and set bits $2877.w [Reads: Accumulator] [Flags: Z]
	sbc ($4C.b,S),Y		; F3 4C ; Subtract with carry (stack relative indirect indexed) ($4C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $BD59.w,X		; 3E 59 BD ; Rotate left $BD59.w,X [Reads: X Index] [Flags: NCZ]
	and #$8500.w		; 29 00 85 ; Logical AND #$8500.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $7C		; 30 7C ; Branch if minus to $30, $7C [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	and #$8500.w		; 29 00 85 ; Logical AND #$8500.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $50, $00		; 50 00 ; Branch if overflow clear to $50, $00 [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $2359.w,X		; 3E 59 23 ; Rotate left $2359.w,X [Reads: X Index] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $4200.w,X		; 7E 00 42 ; Rotate right $4200.w,X [Reads: X Index] [Flags: NCZ]
	bit $2447.w,X		; 3C 47 24 ; Test bits $2447.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $23		; 42 23 ; Reserved instruction
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $001D00.l		; 0F 00 1D 00 ; OR accumulator with memory (long) $001D00.l [Writes: Accumulator] [Flags: NZ]
	asl $0045.w,X		; 1E 45 00 ; Arithmetic shift left $0045.w,X [Reads: X Index] [Flags: NCZ]
	and $5F0811.l,X		; 3F 11 08 5F ; AND accumulator with memory (long,X) $5F0811.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3F3F1F.l,X		; 1F 1F 3F 3F ; Logical OR long $3F3F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$77.b],Y		; 37 77 ; AND accumulator with memory (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$F000.w		; C0 00 F0 ; Compare #$F000.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($2EE0.w,X)		; FC E0 2E ; Jump to subroutine indirect indexed ($2EE0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $FA		; 10 FA ; Branch if plus to $10, $FA [Flow: branch]
	.db $90, $C0		; 90 C0 ; Branch if carry clear to $90, $C0 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($ECFC.w,X)		; FC FC EC ; Jump to subroutine indirect indexed ($ECFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ror $7FFE.w		; 6E FE 7F ; Rotate right $7FFE.w [Flags: NCZ]
	sbc $FBBF.w,X		; FD BF FB ; Subtract with carry $FBBF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: NZ]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $737FBF.l,X		; DF BF 7F 73 ; Compare accumulator (long,X) $737FBF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $F7.b,S		; 03 F7 ; OR accumulator with stack relative $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $70, $7F		; 70 7F ; Branch if overflow set to $70, $7F [Flow: branch]
	and ($3C.b,S),Y		; 33 3C ; AND accumulator (stack relative indirect indexed) ($3C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0838.w		; 0C 38 08 ; Test and set bits $0838.w [Reads: Accumulator] [Flags: Z]
	eor $58.b,S		; 43 58 ; Exclusive OR accumulator with stack relative $58.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora $8FFC73.l,X		; 1F 73 FC 8F ; Logical OR long $8FFC73.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $3733.w		; 4C 33 37 ; Jump to $3733.w [Flow: jump]
	adc [$77.b],Y		; 77 77 ; Add with carry (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $80, $E4		; 80 E4 ; Branch always to $80, $E4 [Flow: branch]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $1C		; D0 1C ; Branch if not equal to $D0, $1C [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0D04.w		; 0E 04 0D ; Arithmetic shift left $0D04.w [Flags: NCZ]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $80.b		; 02 80 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($F42C.w,X)		; FC 2C F4 ; Jump to subroutine indirect indexed ($F42C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $011F0E.l		; 0F 0E 1F 01 ; OR accumulator with memory (long) $011F0E.l [Writes: Accumulator] [Flags: NZ]
	asl $3C13.w,X		; 1E 13 3C ; Arithmetic shift left $3C13.w,X [Reads: X Index] [Flags: NCZ]
	ora [$38.b]		; 07 38 ; OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $010400.l		; 22 00 04 01 ; Jump to subroutine long $010400.l [Writes: Stack Pointer] [Flow: call]
	ora $08140E.l		; 0F 0E 14 08 ; OR accumulator with memory (long) $08140E.l [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$40.b]		; 07 40 ; OR accumulator with memory (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jsr ($F020.w,X)		; FC 20 F0 ; Jump to subroutine indirect indexed ($F020.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $10.b,S		; 43 10 ; Exclusive OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$00C7.w		; E0 C7 00 ; Compare #$00C7.w with X register [Reads: X Index] [Flags: NCZ]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0F0.w		; E0 F0 F0 ; Compare #$F0F0.w with X register [Reads: X Index] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1701.w		; 0E 01 17 ; Arithmetic shift left $1701.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $BC01.w,X		; 7E 01 BC ; Rotate right $BC01.w,X [Reads: X Index] [Flags: NCZ]
	.db $42, $AC		; 42 AC ; Reserved instruction
	eor ($03.b,S),Y		; 53 03 ; XOR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $2317.w		; 0E 17 23 ; Arithmetic shift left $2317.w [Flags: NCZ]
	and [$7E.b]		; 27 7E ; AND accumulator with memory (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $C0EC.w,X		; FD EC C0 ; Subtract with carry $C0EC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E8		; 80 E8 ; Branch always to $80, $E8 [Flow: branch]
	.db $10, $C4		; 10 C4 ; Branch if plus to $10, $C4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ror $BD00.w,X		; 7E 00 BD ; Rotate right $BD00.w,X [Reads: X Index] [Flags: NCZ]
	cop $35.b		; 02 35 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpy #$E870.w		; C0 70 E8 ; Compare #$E870.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $E4.b		; C4 E4 ; Compare $E4.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	inc $B77F.w,X		; FE 7F B7 ; Increment memory $B77F.w,X [Reads: X Index] [Flags: NZ]
	eor $463B.w,X		; 5D 3B 46 ; Exclusive OR accumulator with memory $463B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $3F44.w,Y		; 39 44 3F ; AND accumulator with memory $3F44.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $031C1F.l		; 22 1F 1C 03 ; Jump to subroutine long $031C1F.l [Writes: Stack Pointer] [Flow: call]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $4D5E.w,X		; 5D 5E 4D ; Exclusive OR accumulator with memory $4D5E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($BE.b,X)		; 01 BE ; Logical OR ($BE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$9C66]		; DC 66 9C ; Jump long indirect [$9C66] [Flow: jump]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsr ($F844.w,X)		; FC 44 F8 ; Jump to subroutine indirect indexed ($F844.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$80C0.w		; C0 C0 80 ; Compare #$80C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $C4BA.w,X		; 7E BA C4 ; Rotate right $C4BA.w,X [Reads: X Index] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpy #$8040.w		; C0 40 80 ; Compare #$8040.w with Y register [Reads: Y Index] [Flags: NCZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc $2C5E.w		; 6D 5E 2C ; Add $2C5E.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and $143F02.l,X		; 3F 02 3F 14 ; AND accumulator with memory (long,X) $143F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $081F06.l,X		; 1F 06 1F 08 ; Logical OR long $081F06.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($1E.b),Y		; 31 1E ; AND accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $FE00.w,X		; 1E 00 FE ; Arithmetic shift left $FE00.w,X [Reads: X Index] [Flags: NCZ]
	adc $192A3D.l,X		; 7F 3D 2A 19 ; Add long $192A3D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $D91E31.l,X		; 1F 31 1E D9 ; Logical OR long $D91E31.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $7A.b,Y		; B6 7A ; Load X register $7A.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	bit $FC.b,X		; 34 FC ; Test bits $FC.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr ($F828.w,X)		; FC 28 F8 ; Jump to subroutine indirect indexed ($F828.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $8C		; 10 8C ; Branch if plus to $10, $8C [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $54BC.w,X		; FE BC 54 ; Increment memory $54BC.w,X [Reads: X Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sty $CF78.w		; 8C 78 CF ; Store Y register to $CF78.w [Reads: Y Index]
	rol $FD.b,X		; 36 FD ; Rotate left $FD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $66DE.w		; 0D DE 66 ; Logical OR $66DE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $047F62.l,X		; FF 62 7F 04 ; Subtract with carry (long,X) $047F62.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $78C726.l,X		; 7F 26 C7 78 ; Add long $78C726.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($B900.w,X)		; FC 00 B9 ; Jump to subroutine indirect indexed ($B900.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc ($F9.b)		; F2 F9 ; Subtract with carry (indirect) ($F9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7A.b,X		; F5 7A ; Subtract $7A.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FCC7.w,Y		; 79 C7 FC ; Add $FCC7.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($6C.b,S),Y		; F3 6C ; Subtract with carry (stack relative indirect indexed) ($6C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda $667BB0.l,X		; BF B0 7B 66 ; Load long $667BB0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $20FE46.l,X		; FF 46 FE 20 ; Subtract with carry (long,X) $20FE46.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $E364.w,X		; FE 64 E3 ; Increment memory $E364.w,X [Reads: X Index] [Flags: NZ]
	asl $003F.w,X		; 1E 3F 00 ; Arithmetic shift left $003F.w,X [Reads: X Index] [Flags: NCZ]
	sta $9F4F.w,X		; 9D 4F 9F ; Store accumulator to $9F4F.w,X [Reads: Accumulator, X Index]
	lda $E39E5E.l		; AF 5E 9E E3 ; Load long $E39E5E.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and $182443.l,X		; 3F 43 24 18 ; AND accumulator with memory (long,X) $182443.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $18E7.w		; 0E E7 18 ; Arithmetic shift left $18E7.w [Flags: NCZ]
	sbc $F966.w,X		; FD 66 F9 ; Subtract with carry $F966.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $7EF3.w,X		; 7E F3 7E ; Rotate right $7EF3.w,X [Reads: X Index] [Flags: NCZ]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $2400.w,X		; 7E 00 24 ; Rotate right $2400.w,X [Reads: X Index] [Flags: NCZ]
	bit $E7.b		; 24 E7 ; Test bits $E7.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$7E30.w		; E0 30 7E ; Compare #$7E30.w with X register [Reads: X Index] [Flags: NCZ]
	eor $397F09.l,X		; 5F 09 7F 39 ; Exclusive OR accumulator with memory (long,X) $397F09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $0D1F19.l,X		; 3F 19 1F 0D ; AND accumulator with memory (long,X) $0D1F19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0F0E.w,X		; 1E 0E 0F ; Arithmetic shift left $0F0E.w,X [Reads: X Index] [Flags: NCZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $72.b		; 00 72 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsl $091112.l		; 22 12 11 09 ; Jump to subroutine long $091112.l [Writes: Stack Pointer] [Flow: call]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	.db $10, $76		; 10 76 ; Branch if plus to $10, $76 [Flow: branch]
	trb $6C.b		; 14 6C ; Test and reset bits $6C.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $B0		; 10 B0 ; Branch if plus to $10, $B0 [Flow: branch]
	jsr $C0E0.w		; 20 E0 C0 ; Jump to subroutine at $C0E0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$CE00.w		; C0 00 CE ; Compare #$CE00.w with Y register [Reads: Y Index] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pei ($F8.b)		; D4 F8 ; Push effective indirect address ($F8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	cpy #$D897.w		; C0 97 D8 ; Compare #$D897.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($6724.w,X)		; 7C 24 67 ; Jump indirect indexed to ($6724.w,X) [Reads: X Index] [Flow: jump]
	ora ($4F.b,X)		; 01 4F ; Logical OR ($4F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp $307F1B.l		; 5C 1B 7F 30 ; Jump long to $307F1B.l [Flow: jump]
	and $010E00.l,X		; 3F 00 0E 01 ; AND accumulator with memory (long,X) $010E00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $6777.w,X		; 7E 77 67 ; Rotate right $6777.w,X [Reads: X Index] [Flags: NCZ]
	eor $030E3F.l		; 4F 3F 0E 03 ; Exclusive OR accumulator with memory (long) $030E3F.l [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $FFD8.w,Y		; F9 D8 FF ; Subtract with carry $FFD8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $E01E.w		; 0E 1E E0 ; Arithmetic shift left $E01E.w [Flags: NCZ]
	jsr ($F400.w,X)		; FC 00 F4 ; Jump to subroutine indirect indexed ($F400.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	cpy #$00E0.w		; C0 E0 00 ; Compare #$00E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$27.b]		; E7 27 ; Subtract with carry (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($FE.b),Y		; F1 FE ; Subtract with carry ($FE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($38F4.w,X)		; FC F4 38 ; Jump to subroutine indirect indexed ($38F4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$3E19.w		; E0 19 3E ; Compare #$3E19.w with X register [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $0C1F08.l,X		; 3F 08 1F 0C ; AND accumulator with memory (long,X) $0C1F08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $000F03.l,X		; 1F 03 0F 00 ; Logical OR long $000F03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0D1F.w,X		; 1E 1F 0D ; Arithmetic shift left $0D1F.w,X [Reads: X Index] [Flags: NCZ]
	ora $2203.w		; 0D 03 22 ; Logical OR $2203.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $78.b,X		; 94 78 ; Store Y register $78.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $78.b		; 02 78 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$2280.w		; E0 80 22 ; Compare #$2280.w with X register [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$00C1.w		; E0 C1 00 ; Compare #$00C1.w with X register [Reads: X Index] [Flags: NCZ]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($DE.b,S),Y		; 53 DE ; XOR accumulator (stack relative indirect indexed) ($DE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($5F.b,X)		; 21 5F ; Logical AND ($5F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $1966.w		; 20 66 19 ; Jump to subroutine at $1966.w [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and [$5F.b]		; 27 5F ; AND accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $001D0D.l		; 2F 0D 1D 00 ; AND accumulator with memory (long) $001D0D.l [Writes: Accumulator] [Flags: NZ]
	cpx $7FFE.w		; EC FE 7F ; Compare $7FFE.w with X register [Reads: X Index] [Flags: NCZ]
	adc $32675F.l,X		; 7F 5F 67 32 ; Add long $32675F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $CA35.w,X		; 1D 35 CA ; OR accumulator with memory $CA35.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $FA.b		; 84 FA ; Store Y register to $FA.b [Reads: Y Index]
	tsb $66.b		; 04 66 ; Test and set bits $66.b [Reads: Accumulator] [Flags: Z]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $FAEC.w,X		; 1E EC FA ; Arithmetic shift left $FAEC.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	pea $B8B0.w		; F4 B0 B8 ; Push absolute address $B8B0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $F2FEFE.l,X		; 7F FE FE F2 ; Add long $F2FEFE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $4C.b		; E6 4C ; Increment $4C.b [Reads: Direct Page] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1C03.w		; 0C 03 1C ; Test and set bits $1C03.w [Reads: Accumulator] [Flags: Z]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$4E.b],Y		; 17 4E ; OR accumulator with memory (long indexed) [$4E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$6E.b],Y		; 37 6E ; AND accumulator with memory (long indexed) [$6E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$79.b],Y		; 37 79 ; AND accumulator with memory (long indexed) [$79.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $0301.w		; 0E 01 03 ; Arithmetic shift left $0301.w [Flags: NCZ]
	ora $6F3F1F.l		; 0F 1F 3F 6F ; OR accumulator with memory (long) $6F3F1F.l [Writes: Accumulator] [Flags: NZ]
	ror $8078.w		; 6E 78 80 ; Rotate right $8078.w [Flags: NCZ]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $3C		; 80 3C ; Branch always to $80, $3C [Flow: branch]
	.db $D0, $3A		; D0 3A ; Branch if not equal to $D0, $3A [Flow: branch]
	cpy $EC7E.w		; CC 7E EC ; Compare $EC7E.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $EE73E4.l,X		; 7F E4 73 EE ; Add long $EE73E4.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $8070.w,X		; 9E 70 80 ; Store zero to $8070.w,X [Reads: X Index]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	inc $FFFE.w,X		; FE FE FF ; Increment memory $FFFE.w,X [Reads: X Index] [Flags: NZ]
	adc ($1E.b,S),Y		; 73 1E ; Add with carry (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F1602.l		; 0F 02 16 0F ; OR accumulator with memory (long) $0F1602.l [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora [$38.b],Y		; 17 38 ; OR accumulator with memory (long indexed) [$38.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $7B1728.l		; 0F 28 17 7B ; OR accumulator with memory (long) $7B1728.l [Writes: Accumulator] [Flags: NZ]
	bit $02.b,X		; 34 02 ; Test bits $02.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $2B1717.l		; 0F 17 17 2B ; OR accumulator with memory (long) $2B1717.l [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	adc $F000C0.l,X		; 7F C0 00 F0 ; Add long $F000C0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	.db $F0, $D6		; F0 D6 ; Branch if equal to $F0, $D6 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $EE15F2.l,X		; 1F F2 15 EE ; Logical OR long $EE15F2.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $40.b		; 24 40 ; Test bits $40.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $1F.b,X		; D6 1F ; Decrement memory $1F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp $FA.b,X		; D5 FA ; Compare accumulator $FA.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $5807.w		; 0C 07 58 ; Test and set bits $5807.w [Reads: Accumulator] [Flags: Z]
	ora [$FD.b]		; 07 FD ; OR accumulator with memory (long) [$FD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $920FB7.l,X		; 1F B7 0F 92 ; Logical OR long $920FB7.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $070300.l		; 0F 00 03 07 ; OR accumulator with memory (long) $070300.l [Writes: Accumulator] [Flags: NZ]
	ora $DFBF5F.l		; 0F 5F BF DF ; OR accumulator with memory (long) $DFBF5F.l [Writes: Accumulator] [Flags: NZ]
	inc $00F8.w,X		; FE F8 00 ; Increment memory $00F8.w,X [Reads: X Index] [Flags: NZ]
	sty $F8.b		; 84 F8 ; Store Y register to $F8.b [Reads: Y Index]
	trb $74F8.w		; 1C F8 74 ; Test and reset bits $74F8.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $F0, $CC		; F0 CC ; Branch if equal to $F0, $CC [Flow: branch]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	cpx $DE2D.w		; EC 2D DE ; Compare $DE2D.w with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($F4FC.w,X)		; FC FC F4 ; Jump to subroutine indirect indexed ($F4FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpy $2D12.w		; CC 12 2D ; Compare $2D12.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	.db $62, $03, $00		; 62 03 00 ; Push effective relative address $62, $03, $00 [Writes: Stack Pointer]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $03		; 70 03 ; Branch if overflow set to $70, $03 [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $050001.l		; 8F 01 00 05 ; Store accumulator (long) $050001.l [Reads: Accumulator]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $17.b		; 04 17 ; Test and set bits $17.b [Reads: Accumulator] [Flags: Z]
	asl $1F2D.w		; 0E 2D 1F ; Arithmetic shift left $1F2D.w [Flags: NCZ]
	bit $0F.b,X		; 34 0F ; Test bits $0F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and [$EB.b],Y		; 37 EB ; AND accumulator with memory (long indexed) [$EB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$00.b],Y		; 57 00 ; Exclusive OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	ora [$2F.b],Y		; 17 2F ; OR accumulator with memory (long indexed) [$2F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$6B.b],Y		; 37 6B ; AND accumulator with memory (long indexed) [$6B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	ldy #$7000.w		; A0 00 70 ; Load #$7000.w into Y register [Writes: Y Index] [Flags: NZ]
	jsr $70E8.w		; 20 E8 70 ; Jump to subroutine at $70E8.w [Writes: Stack Pointer] [Flow: call]
	ldy $F8.b,X		; B4 F8 ; Load Y register $F8.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	bit $56F0.w		; 2C F0 56 ; Test bits $56F0.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cpx $EAD7.w		; EC D7 EA ; Compare $EAD7.w with X register [Reads: X Index] [Flags: NCZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	pea $D6EC.w		; F4 EC D6 ; Push absolute address $D6EC.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cmp [$03.b],Y		; D7 03 ; Compare accumulator (long indexed) [$03.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1D.b,S		; 03 1D ; OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $335D.w,Y		; 19 5D 33 ; OR accumulator with memory $335D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $34E936.l		; 6F 36 E9 34 ; Add with carry (long) $34E936.l [Writes: Accumulator] [Flags: NCVZ]
	pei ($6A.b)		; D4 6A ; Push effective indirect address ($6A.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $7F37.w,X		; 1D 37 7F ; OR accumulator with memory $7F37.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $D1EA.w		; 6E EA D1 ; Rotate right $D1EA.w [Flags: NCZ]
	cpy #$A000.w		; C0 00 A0 ; Compare #$A000.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$40B8.w		; C0 B8 40 ; Compare #$40B8.w with Y register [Reads: Y Index] [Flags: NCZ]
	stz $98.b		; 64 98 ; Store zero to $98.b
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cpy $6CF6.w		; CC F6 6C ; Compare $6CF6.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta [$2C.b],Y		; 97 2C ; Store accumulator (long indexed) [$2C.b],Y [Reads: Direct Page, Y Index, Accumulator]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	lsr $C0.b,X		; 56 C0 ; Logical shift right $C0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldy #$ECB8.w		; A0 B8 EC ; Load #$ECB8.w into Y register [Writes: Y Index] [Flags: NZ]
	inc $5776.w,X		; FE 76 57 ; Increment memory $5776.w,X [Reads: X Index] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$1F00.w		; 09 00 1F ; Logical OR #$1F00.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($3E.b,X)		; 01 3E ; Logical OR ($3E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $7B.b,S		; 03 7B ; OR accumulator with stack relative $7B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$E7.b]		; 27 E7 ; AND accumulator with memory (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $0073.w,X		; BD 73 00 ; Load $0073.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$2717.w		; 09 17 27 ; Logical OR #$2717.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $B3E37B.l,X		; 3F 7B E3 B3 ; AND accumulator with memory (long,X) $B3E37B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F800.w		; E0 00 F8 ; Compare #$F800.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$F81C.w		; E0 1C F8 ; Compare #$F81C.w with X register [Reads: X Index] [Flags: NCZ]
	asl $FC.b		; 06 FC ; Arithmetic shift left $FC.b [Reads: Direct Page] [Flags: NCZ]
	lda $61FE.w,X		; BD FE 61 ; Load $61FE.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $708E.w,X		; FE 8E 70 ; Increment memory $708E.w,X [Reads: X Index] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FDFE.w,X)		; FC FE FD ; Jump to subroutine indirect indexed ($FDFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc ($8E.b,X)		; 61 8E ; Add with carry ($8E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $60.b,S		; 83 60 ; Store accumulator (stack relative) $60.b,S [Reads: Stack Pointer, Accumulator]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($01.b)		; 52 01 ; Exclusive OR accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($63.b),Y		; 11 63 ; OR accumulator with memory ($63.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $58E7.w		; 1C E7 58 ; Test and reset bits $58E7.w [Reads: Accumulator] [Flags: Z]
	inc $BC01.w,X		; FE 01 BC ; Increment memory $BC01.w,X [Reads: X Index] [Flags: NZ]
	.db $42, $00		; 42 00 ; Reserved instruction
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$63.b],Y		; 17 63 ; OR accumulator with memory (long indexed) [$63.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda [$FE.b]		; A7 FE ; Load accumulator (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $0000.w,X		; FD 00 00 ; Subtract with carry $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $68.b		; 85 68 ; Store accumulator to $68.b [Reads: Accumulator]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $38.b		; C6 38 ; Decrement $38.b [Reads: Direct Page] [Flags: NZ]
	sbc [$1A.b]		; E7 1A ; Subtract with carry (long) [$1A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $02BD00.l,X		; 7F 00 BD 02 ; Add long $02BD00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $E8		; 70 E8 ; Branch if overflow set to $70, $E8 [Flow: branch]
	dec $E5.b		; C6 E5 ; Decrement $E5.b [Reads: Direct Page] [Flags: NZ]
	sbc $1E717F.l,X		; FF 7F 71 1E ; Subtract with carry (long,X) $1E717F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($1C.b),Y		; 71 1C ; Add with carry ($1C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	mvn $76,$2A		; 54 2A 76 ; Move block negative $76,$2A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and #$176A.w		; 29 6A 17 ; Logical AND #$176A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $0703.w,X		; 3D 03 07 ; AND accumulator with memory $0703.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $81E000.l		; 22 00 E0 81 ; Jump to subroutine long $81E000.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc ($51.b)		; 72 51 ; Add with carry (indirect) ($51.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $6B		; 70 6B ; Branch if overflow set to $70, $6B [Flow: branch]
	and $0005.w,X		; 3D 05 00 ; AND accumulator with memory $0005.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $8E78.w		; 8C 78 8E ; Store Y register to $8E78.w [Reads: Y Index]
	sec		; 38 ; Set carry flag [Flags: C]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	mvn $94,$6E		; 54 6E 94 ; Move block negative $94,$6E [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	inc $B3.b		; E6 B3 ; Increment $B3.b [Reads: Direct Page] [Flags: NZ]
	dec $0EFD.w		; CE FD 0E ; Decrement $0EFD.w [Flags: NZ]
	asl $1C00.w		; 0E 00 1C ; Arithmetic shift left $1C00.w [Flags: NCZ]
	lsr $0E8A.w		; 4E 8A 0E ; Logical shift right $0E8A.w [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda ($BF.b,S),Y		; B3 BF ; Load accumulator (stack relative indirect indexed) ($BF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0877.w		; 0E 77 08 ; Arithmetic shift left $0877.w [Flags: NCZ]
	adc #$321E.w		; 69 1E 32 ; Add #$321E.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora $49376B.l,X		; 1F 6B 37 49 ; Logical OR long $49376B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$3B.b],Y		; 37 3B ; AND accumulator with memory (long indexed) [$3B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $6B32.w,Y		; 79 32 6B ; Add $6B32.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor #$073B.w		; 49 3B 07 ; Exclusive OR #$073B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($FC.b,X)		; 01 FC ; Logical OR ($FC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsr ($DCEE.w,X)		; FC EE DC ; Jump to subroutine indirect indexed ($DCEE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sta $EA.b,X		; 95 EA ; Store accumulator to $EA.b,X [Reads: Accumulator, X Index]
	sbc [$CE.b],Y		; F7 CE ; Subtract with carry (long indexed) [$CE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8E86.w,Y		; F9 86 8E ; Subtract with carry $8E86.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $EE6E.w		; 8E 6E EE ; Store X register to $EE6E.w [Reads: X Index]
	sta [$F7.b],Y		; 97 F7 ; Store accumulator (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sbc $638E.w,Y		; F9 8E 63 ; Subtract with carry $638E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F86EDD.l,X		; 1F DD 6E F8 ; Logical OR long $F86EDD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $C67EE1.l		; 4F E1 7E C6 ; Exclusive OR accumulator with memory (long) $C67EE1.l [Writes: Accumulator] [Flags: NZ]
	adc $0679.w,Y		; 79 79 06 ; Add $0679.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$0E.b],Y		; 37 0E ; AND accumulator with memory (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $CD6F00.l		; 0F 00 6F CD ; OR accumulator with memory (long) $CD6F00.l [Writes: Accumulator] [Flags: NZ]
	cpy $C6E9.w		; CC E9 C6 ; Compare $C6E9.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $0F3F.w,Y		; 59 3F 0F ; Exclusive OR accumulator with memory $0F3F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$3E.b],Y		; D7 3E ; Compare accumulator (long indexed) [$3E.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda $7E.b,S		; A3 7E ; Load accumulator (stack relative) $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $5E.b,X		; F5 5E ; Subtract $5E.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $B9DE.w,Y		; 79 DE B9 ; Add $B9DE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $1C3A.w		; 0E 3A 1C ; Arithmetic shift left $1C3A.w [Flags: NCZ]
.INDEX 8
	sep #$1C		; E2 1C
	trb $DF00.w		; 1C 00 DF ; Test and reset bits $DF00.w [Reads: Accumulator] [Flags: Z]
	lda $F979FD.l,X		; BF FD 79 F9 ; Load long $F979FD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	trb $0F92.w		; 1C 92 0F ; Test and reset bits $0F92.w [Reads: Accumulator] [Flags: Z]
	sta [$E0.b]		; 87 E0 ; Store accumulator (long) [$E0.b] [Reads: Direct Page, Accumulator]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	cmp [$79.b]		; C7 79 ; Compare accumulator (long) [$79.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc $2303.w,X		; 7D 03 23 ; Add $2303.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $F0.b,S		; 83 F0 ; Store accumulator (stack relative) $F0.b,S [Reads: Stack Pointer, Accumulator]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	stz $5FC7.w		; 9C C7 5F ; Store zero to $5FC7.w
	and $29.b,S		; 23 29 ; AND accumulator with stack relative $29.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $3EDD.w,X		; DE DD 3E ; Decrement memory $3EDD.w,X [Reads: X Index] [Flags: NZ]
	sta $7E.b		; 85 7E ; Store accumulator to $7E.b [Reads: Accumulator]
	lda $5E.b		; A5 5E ; Load $5E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy $7C92.w,X		; BC 92 7C ; Load Y register $7C92.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	pea $B898.w		; F4 98 B8 ; Push absolute address $B898.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $BDBD.w,X		; DD BD BD ; Compare accumulator $BDBD.w,X [Reads: X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sbc ($F4.b)		; F2 F4 ; Subtract with carry (indirect) ($F4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $6E47.w,Y		; B9 47 6E ; Load $6E47.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $3E71.w,Y		; 19 71 3E ; OR accumulator with memory $3E71.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$3F		; E2 3F
	sbc #$57.b		; E9 57 ; Subtract #$57.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc $017773.l		; EF 73 77 01 ; Subtract with carry (long) $017773.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $717E.w,Y		; B9 7E 71 ; Load $717E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$E9		; E2 E9
	sbc $9D0177.l		; EF 77 01 9D ; Subtract with carry (long) $9D0177.l [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
.INDEX 8
	sep #$76		; E2 76
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $477C.w		; 8E 7C 47 ; Store X register to $477C.w [Reads: X Index]
	jsr ($EA97.w,X)		; FC 97 EA ; Jump to subroutine indirect indexed ($EA97.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc [$CE.b],Y		; F7 CE ; Subtract with carry (long indexed) [$CE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $8080.w		; EE 80 80 ; Increment $8080.w [Flags: NZ]
	brk $9D.b		; 00 9D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $478E.w,X		; 7E 8E 47 ; Rotate right $478E.w,X [Reads: X Index] [Flags: NCZ]
	sta [$F7.b],Y		; 97 F7 ; Store accumulator (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index, Accumulator]
	inc $6E80.w		; EE 80 6E ; Increment $6E80.w [Flags: NZ]
	ora $176B.w,Y		; 19 6B 17 ; OR accumulator with memory $176B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $2B5F28.l,X		; 5F 28 5F 2B ; Exclusive OR accumulator with memory (long,X) $2B5F28.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $FE76.w		; 8E 76 FE ; Store X register to $FE76.w [Reads: X Index]
	adc ($7F.b)		; 72 7F ; Add with carry (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor [$50.b],Y		; 57 50 ; Exclusive OR accumulator with memory (long indexed) [$50.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$FD.b		; C9 FD ; Compare #$FD.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ror $7601.w,X		; 7E 01 76 ; Rotate right $7601.w,X [Reads: X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	pei ($E8.b)		; D4 E8 ; Push effective indirect address ($E8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	trb $FA.b		; 14 FA ; Test and reset bits $FA.b [Reads: Accumulator] [Flags: Z]
	pei ($79.b)		; D4 79 ; Push effective indirect address ($79.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ror $7F.b		; 66 7F ; Rotate right $7F.b [Reads: Direct Page] [Flags: NCZ]
	lsr $80FE.w		; 4E FE 80 ; Logical shift right $80FE.w [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	asl $D4.b,X		; 16 D4 ; Arithmetic shift left $D4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	nop		; EA ; No operation
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $7B807E.l,X		; BF 7E 80 7B ; Load long $7B807E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3F0738.l,X		; 1F 38 07 3F ; Logical OR long $3F0738.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ror $5D2D.w		; 6E 2D 5D ; Rotate right $5D2D.w [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc #$76.b		; E9 76 ; Subtract #$76.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc [$0E.b],Y		; 77 0E ; Add with carry (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $387F00.l		; 0F 00 7F 38 ; OR accumulator with memory (long) $387F00.l [Writes: Accumulator] [Flags: NZ]
	and [$52.b]		; 27 52 ; AND accumulator with memory (long) [$52.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $E9.b		; 65 E9 ; Add $E9.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $847A0F.l,X		; 7F 0F 7A 84 ; Add long $847A0F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	bit $7EF5.w,X		; 3C F5 7E ; Test bits $7EF5.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	eor $FE.b,X		; 55 FE ; Exclusive OR accumulator with memory $FE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $859E.w		; AD 9E 85 ; Load $859E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$7A.b]		; 07 7A ; OR accumulator with memory (long) [$7A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $ED5D.w,X		; FD 5D ED ; Subtract with carry $ED5D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	trb $AC43.w		; 1C 43 AC ; Test and reset bits $AC43.w [Reads: Accumulator] [Flags: Z]
	eor ($15.b,S),Y		; 53 15 ; XOR accumulator (stack relative indirect indexed) ($15.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $DF21.w,X		; DE 21 DF ; Decrement memory $DF21.w,X [Reads: X Index] [Flags: NZ]
	jsr $59E6.w		; 20 E6 59 ; Jump to subroutine at $59E6.w [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	and [$9F.b]		; 27 9F ; AND accumulator with memory (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $73		; 10 73 ; Branch if plus to $10, $73 [Flow: branch]
	ora ($EC.b,X)		; 01 EC ; Logical OR ($EC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx $FFFE.w		; EC FE FF ; Compare $FFFE.w with X register [Reads: X Index] [Flags: NCZ]
	lda $72EFDF.l,X		; BF DF EF 72 ; Load long $72EFDF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $4A.b,X		; 35 4A ; Logical AND $4A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $E8.b,S		; 83 E8 ; Store accumulator (stack relative) $E8.b,S [Reads: Stack Pointer, Accumulator]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $67.b		; 04 67 ; Test and set bits $67.b [Reads: Accumulator] [Flags: Z]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora $F9E4.w,X		; 1D E4 F9 ; OR accumulator with memory $F9E4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec $B780.w		; CE 80 B7 ; Decrement $B780.w [Flags: NZ]
	and [$7F.b],Y		; 37 7F ; AND accumulator with memory (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F7FBFD.l,X		; FF FD FB F7 ; Subtract with carry (long,X) $F7FBFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $E7FF.w		; 4E FF E7 ; Logical shift right $E7FF.w [Flags: NCZ]
	sbc $FFE500.l,X		; FF 00 E5 FF ; Subtract with carry (long,X) $FFE500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$6B.b		; E0 6B ; Compare #$6B.b with X register [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($4F.b,X)		; 01 4F ; Logical OR ($4F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $0D7E2C.l,X		; FF 2C 7E 0D ; Subtract with carry (long,X) $0D7E2C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $011F04.l		; 0F 04 1F 01 ; OR accumulator with memory (long) $011F04.l [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc [$92.b],Y		; 77 92 ; Add with carry (long indexed) [$92.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($0B.b,S),Y		; 73 0B ; Add with carry (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $00E0.w,X		; 1E E0 00 ; Arithmetic shift left $00E0.w,X [Reads: X Index] [Flags: NCZ]
	ror $3B20.w,X		; 7E 20 3B ; Rotate right $3B20.w,X [Reads: X Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc $7E68.w,Y		; F9 68 7E ; Subtract with carry $7E68.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $C8BC.w		; 8C BC C8 ; Store Y register to $C8BC.w [Reads: Y Index]
	jsr ($FCC0.w,X)		; FC C0 FC ; Jump to subroutine indirect indexed ($FCC0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$9E.b		; E0 9E ; Compare #$9E.b with X register [Reads: X Index] [Flags: NCZ]
	cmp $97.b,X		; D5 97 ; Compare accumulator $97.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc ($F4.b)		; F2 F4 ; Subtract with carry (indirect) ($F4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($00FC.w,X)		; FC FC 00 ; Jump to subroutine indirect indexed ($00FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D1.b		; 00 D1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($77.b,X)		; 61 77 ; Add with carry ($77.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	ora #$1F.b		; 09 1F ; Logical OR #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $2F.b		; 05 2F ; Logical OR $2F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda ($9A.b),Y		; B1 9A ; Load accumulator ($9A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $341A17.l		; 6F 17 1A 34 ; Add with carry (long) $341A17.l [Writes: Accumulator] [Flags: NCVZ]
	tsb $1E00.w		; 0C 00 1E ; Test and set bits $1E00.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $3C0C.w,X		; FE 0C 3C ; Increment memory $3C0C.w,X [Reads: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jsr ($FE40.w,X)		; FC 40 FE ; Jump to subroutine indirect indexed ($FE40.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($D6.b)		; 12 D6 ; OR accumulator with memory (indirect) ($D6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $72.b,X		; F6 72 ; Increment memory $72.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	pea $FEFC.w		; F4 FC FE ; Push absolute address $FEFC.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $0F1900.l,X		; 1F 00 19 0F ; Logical OR long $0F1900.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $1707.w		; 1C 07 17 ; Test and reset bits $1707.w [Reads: Accumulator] [Flags: Z]
	ora $13.b,S		; 03 13 ; OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $1F.b		; 24 1F ; Test bits $1F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $FF00.w,X		; 3C 00 FF ; Test bits $FF00.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $7EFF.w,X		; 3C FF 7E ; Test bits $7EFF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $3CE7.w,X		; 7E E7 3C ; Rotate right $3CE7.w,X [Reads: X Index] [Flags: NCZ]
	bit $FF23.w,X		; 3C 23 FF ; Test bits $FF23.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	asl $FFE7.w		; 0E E7 FF ; Arithmetic shift left $FFE7.w [Flags: NCZ]
	sbc $1E0000.l,X		; FF 00 00 1E ; Subtract with carry (long,X) $1E0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F19.w,X		; 1E 19 0F ; Arithmetic shift left $0F19.w,X [Reads: X Index] [Flags: NCZ]
	ora $1707.w,X		; 1D 07 17 ; OR accumulator with memory $1707.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $001F22.l,X		; 3F 22 1F 00 ; AND accumulator with memory (long,X) $001F22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $007784.l		; 0F 84 77 00 ; OR accumulator with memory (long) $007784.l [Writes: Accumulator] [Flags: NZ]
	ora $E7.b		; 05 E7 ; Logical OR $E7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $99E7DB.l,X		; FF DB E7 99 ; Subtract with carry (long,X) $99E7DB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$43.b]		; E7 43 ; Subtract with carry (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index]
	asl $C3.b		; 06 C3 ; Arithmetic shift left $C3.b [Reads: Direct Page] [Flags: NCZ]
	sbc $FFFF3C.l,X		; FF 3C FF FF ; Subtract with carry (long,X) $FFFF3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $33E0FF.l		; 22 FF E0 33 ; Jump to subroutine long $33E0FF.l [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $1303.w		; 0C 03 13 ; Test and set bits $1303.w [Reads: Accumulator] [Flags: Z]
	ora $260F17.l		; 0F 17 0F 26 ; OR accumulator with memory (long) $260F17.l [Writes: Accumulator] [Flags: NZ]
	ora $A31F67.l,X		; 1F 67 1F A3 ; Logical OR long $A31F67.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $037FE1.l,X		; 5F E1 7F 03 ; Exclusive OR accumulator with memory (long,X) $037FE1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $1713.w		; 0C 13 17 ; Test and set bits $1713.w [Reads: Accumulator] [Flags: Z]
	and [$67.b]		; 27 67 ; AND accumulator with memory (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E1.b,S		; E3 E1 ; Subtract stack-relative $E1.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	.db $F0, $14		; F0 14 ; Branch if equal to $F0, $14 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	rol $F8.b,X		; 36 F8 ; Rotate left $F8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $FA.b,X		; F5 FA ; Subtract $FA.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($FE.b,X)		; E1 FE ; Subtract with carry ($FE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$30.b		; C0 30 ; Compare #$30.b with Y register [Reads: Y Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	pea $F7F6.w		; F4 F6 F7 ; Push absolute address $F7F6.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $3C.b,S		; E3 3C ; Subtract stack-relative $3C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $BF43.w		; 20 43 BF ; Jump to subroutine at $BF43.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor $A5.b,S		; 43 A5 ; Exclusive OR accumulator with stack relative $A5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $C1, $D9		; 62 C1 D9 ; Push effective relative address $62, $C1, $D9 [Writes: Stack Pointer]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $833C.w,X		; 7E 3C 83 ; Rotate right $833C.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	eor $BF.b,S		; 43 BF ; Exclusive OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora $CD.b		; 05 CD ; Logical OR $CD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($C9.b)		; 32 C9 ; AND accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $72.b,X		; 36 72 ; Rotate left $72.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $FE84.w		; 0C 84 FE ; Test and set bits $FE84.w [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($CB.b),Y		; F1 CB ; Subtract with carry ($CB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $010685.l		; CF 85 06 01 ; Compare accumulator (long) $010685.l [Reads: Accumulator] [Flags: NCZ]
	eor $BF.b,S		; 43 BF ; Exclusive OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora $9D.b		; 05 9D ; Logical OR $9D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $81, $7E		; 62 81 7E ; Push effective relative address $62, $81, $7E [Writes: Stack Pointer]
	.db $42, $3C		; 42 3C ; Reserved instruction
	sty $FE.b		; 84 FE ; Store Y register to $FE.b [Reads: Y Index]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($E3.b,X)		; C1 E3 ; Compare accumulator ($E3.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc $FE3C7E.l,X		; FF 7E 3C FE ; Subtract with carry (long,X) $FE3C7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FBBFFD.l,X		; 7F FD BF FB ; Add long $FBBFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: NZ]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $237FBF.l,X		; DF BF 7F 23 ; Compare accumulator (long,X) $237FBF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $03.b		; 24 03 ; Test bits $03.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0000.w		; 0D 00 00 ; Logical OR $0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F0F.w		; 0D 0F 0F ; Logical OR $0F0F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $9C0078.l,X		; 1F 78 00 9C ; Logical OR long $9C0078.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsr ($FC08.w,X)		; FC 08 FC ; Jump to subroutine indirect indexed ($FC08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $76		; F0 76 ; Branch if equal to $F0, $76 [Flow: branch]
	cpy $B0CE.w		; CC CE B0 ; Compare $B0CE.w with Y register [Reads: Y Index] [Flags: NCZ]
	stx $60.b,Y		; 96 60 ; Store X register $60.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	lda [$62.b],Y		; B7 62 ; Load accumulator (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jsl $FE22FC.l		; 22 FC 22 FE ; Jump to subroutine long $FE22FC.l [Writes: Stack Pointer] [Flow: call]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	and $345C0A.l,X		; 3F 0A 5C 34 ; AND accumulator with memory (long,X) $345C0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $BD.b,S		; 43 BD ; Exclusive OR accumulator with stack relative $BD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $09.b		; 65 09 ; Add $09.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7F35.w,X		; FD 35 7F ; Subtract with carry $7F35.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $000101.l,X		; 3F 01 01 00 ; AND accumulator with memory (long,X) $000101.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $227B.w		; 2C 7B 22 ; Test bits $227B.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp ($013E.w,X)		; 7C 3E 01 ; Jump indirect indexed to ($013E.w,X) [Reads: X Index] [Flow: jump]
	ror $E604.w,X		; 7E 04 E6 ; Rotate right $E604.w,X [Reads: X Index] [Flags: NCZ]
	stz $1CEE.w		; 9C EE 1C ; Store zero to $1CEE.w
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $F8B0F8.l		; 0F F8 B0 F8 ; OR accumulator with memory (long) $F8B0F8.l [Writes: Accumulator] [Flags: NZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $FCFE.w,X		; 7E FE FC ; Rotate right $FCFE.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($7878.w,X)		; FC 78 78 ; Jump to subroutine indirect indexed ($7878.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $80, $2E		; 80 2E ; Branch always to $80, $2E [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $5E.b,S		; 43 5E ; Exclusive OR accumulator with stack relative $5E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($0A.b)		; 32 0A ; AND accumulator with memory (indirect) ($0A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $7E32.w,X		; 7E 32 7E ; Rotate right $7E32.w,X [Reads: X Index] [Flags: NCZ]
	ora ($3F.b)		; 12 3F ; OR accumulator with memory (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $000101.l,X		; 1F 01 01 00 ; Logical OR long $000101.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $7D23.w,X		; 3D 23 7D ; AND accumulator with memory $7D23.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $011E.w,X		; 3C 1E 01 ; Test bits $011E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sty $F7.b		; 84 F7 ; Store Y register to $F7.b [Reads: Y Index]
	stx $9CEE.w		; 8E EE 9C ; Store X register to $9CEE.w [Reads: X Index]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpx #$35.b		; E0 35 ; Compare #$35.b with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $7C7C7E.l,X		; 7F 7E 7C 7C ; Add long $7C7C7E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	ora $031703.l		; 0F 03 17 03 ; OR accumulator with memory (long) $031703.l [Writes: Accumulator] [Flags: NZ]
	and $063F0D.l		; 2F 0D 3F 06 ; AND accumulator with memory (long) $063F0D.l [Writes: Accumulator] [Flags: NZ]
	adc $3B4F39.l,X		; 7F 39 4F 3B ; Add long $3B4F39.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $237F33.l,X		; 5F 33 7F 23 ; Exclusive OR accumulator with memory (long,X) $237F33.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $39331F.l		; 0F 1F 33 39 ; OR accumulator with memory (long) $39331F.l [Writes: Accumulator] [Flags: NZ]
	ror $7C7C.w,X		; 7E 7C 7C ; Rotate right $7C7C.w,X [Reads: X Index] [Flags: NCZ]
	stz $E7.b,X		; 74 E7 ; Store zero to $E7.b,X [Reads: X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $99.b		; 66 99 ; Rotate right $99.b [Reads: Direct Page] [Flags: NCZ]
	sta $FFFF.w,Y		; 99 FF FF ; Store accumulator to $FFFF.w,Y [Reads: Y Index, Accumulator]
	lda $7EE7.w,X		; BD E7 7E ; Load $7EE7.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $BD.b,S		; C3 BD ; Compare accumulator (stack relative) $BD.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $5A.b		; 66 5A ; Rotate right $5A.b [Reads: Direct Page] [Flags: NCZ]
	bit $2424.w,X		; 3C 24 24 ; Test bits $2424.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $7E22E0.l,X		; FF E0 22 7E ; Subtract with carry (long,X) $7E22E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $07DB.w,X		; BD DB 07 ; Load $07DB.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $33.b		; 05 33 ; Logical OR $33.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($3F.b)		; 12 3F ; OR accumulator with memory (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $4E237F.l		; 0F 7F 23 4E ; OR accumulator with memory (long) $4E237F.l [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $172D3B.l		; 4F 3B 2D 17 ; Exclusive OR accumulator with memory (long) $172D3B.l [Writes: Accumulator] [Flags: NZ]
	ora [$1B.b]		; 07 1B ; OR accumulator with memory (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $7C30.w		; 2D 30 7C ; Logical AND $7C30.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $387C.w,X		; 7D 7C 38 ; Add $387C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFBDFF.l,X		; FF FF BD FF ; Subtract with carry (long,X) $FFBDFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $2B843C.l,X		; FF 3C 84 2B ; Subtract with carry (long,X) $2B843C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $8181.w,X		; 3C 81 81 ; Test bits $8181.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$33.b		; E0 33 ; Compare #$33.b with X register [Reads: X Index] [Flags: NCZ]
	bit $C300.w,X		; 3C 00 C3 ; Test bits $C300.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ror $5FB0.w,X		; 7E B0 5F ; Rotate right $5FB0.w,X [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	and [$DF.b]		; 27 DF ; AND accumulator with memory (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lda [$7F.b]		; A7 7F ; Load accumulator (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $18673F.l		; 5C 3F 67 18 ; Jump long to $18673F.l [Flow: jump]
	jmp $1BF523.l		; 5C 23 F5 1B ; Jump long to $1BF523.l [Flow: jump]
	.db $B0, $F8		; B0 F8 ; Branch if carry set to $B0, $F8 [Flow: branch]
	sbc $675CBF.l,X		; FF BF 5C 67 ; Subtract with carry (long,X) $675CBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $FA07F5.l		; 5C F5 07 FA ; Jump long to $FA07F5.l [Flow: jump]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpx $E3.b		; E4 E3 ; Compare $E3.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $FEC5.w,X		; 1E C5 FE ; Arithmetic shift left $FEC5.w,X [Reads: X Index] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsr ($18E6.w,X)		; FC E6 18 ; Jump to subroutine indirect indexed ($18E6.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rol $2FC4.w,X		; 3E C4 2F ; Rotate left $2FC4.w,X [Reads: X Index] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $E61AFD.l,X		; FF FD 1A E6 ; Subtract with carry (long,X) $E61AFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $83AF.w,X		; 3E AF 83 ; Rotate left $83AF.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $91.b,S		; 03 91 ; OR accumulator with stack relative $91.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $1C62.w		; 6E 62 1C ; Rotate right $1C62.w [Flags: NCZ]
	sty $FE.b		; 84 FE ; Store Y register to $FE.b [Reads: Y Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($93.b,X)		; A1 93 ; Load accumulator ($93.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $010685.l,X		; 9F 85 06 01 ; Store accumulator (long,X) $010685.l,X [Reads: Accumulator, X Index]
	ora [$DF.b]		; 07 DF ; OR accumulator with memory (long) [$DF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $40BF.w		; 20 BF 40 ; Jump to subroutine at $40BF.w [Writes: Stack Pointer] [Flow: call]
	lda $C142.w,X		; BD 42 C1 ; Load $C142.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $2C85.w,X		; 3E 85 2C ; Rotate left $2C85.w,X [Reads: X Index] [Flags: NCZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc ($A1.b,X)		; E1 A1 ; Subtract with carry ($A1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $FF.b,S		; A3 FF ; Load accumulator (stack relative) $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $243C.w,X		; 7E 3C 24 ; Rotate right $243C.w,X [Reads: X Index] [Flags: NCZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0118.w,X		; 3C 18 01 ; Test bits $0118.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $389700.l		; 22 00 97 38 ; Jump to subroutine long $389700.l [Writes: Stack Pointer] [Flow: call]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $182708.l,X		; 1F 08 27 18 ; Logical OR long $182708.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $39.b		; 46 39 ; Logical shift right $39.b [Reads: Direct Page] [Flags: NCZ]
	sta $FF7F.w,Y		; 99 7F FF ; Store accumulator to $FF7F.w,Y [Reads: Y Index, Accumulator]
	adc $06067F.l,X		; 7F 7F 06 06 ; Add long $06067F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $1F1400.l		; 22 00 14 1F ; Jump to subroutine long $1F1400.l [Writes: Stack Pointer] [Flow: call]
	and $FFFF7F.l,X		; 3F 7F FF FF ; AND accumulator with memory (long,X) $FFFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $EF0006.l,X		; 7F 06 00 EF ; Add long $EF0006.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $FF.b		; C6 FF ; Decrement $FF.b [Reads: Direct Page] [Flags: NZ]
	dec $9EFB.w		; CE FB 9E ; Decrement $9EFB.w [Flags: NZ]
	inc $FC.b		; E6 FC ; Increment $FC.b [Reads: Direct Page] [Flags: NZ]
	inc $FC7C.w,X		; FE 7C FC ; Increment memory $FC7C.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	jsl $FF2200.l		; 22 00 22 FF ; Jump to subroutine long $FF2200.l [Writes: Stack Pointer] [Flow: call]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	inc $F0FC.w,X		; FE FC F0 ; Increment memory $F0FC.w,X [Reads: X Index] [Flags: NZ]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0022FF.l,X		; FF FF 22 00 ; Subtract with carry (long,X) $0022FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $01E0.w,X		; 9E E0 01 ; Store zero to $01E0.w,X [Reads: X Index]
	cop $7E.b		; 02 7E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$BD.b]		; E7 BD ; Subtract with carry (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7E7E10.l,X		; FF 10 7E 7E ; Subtract with carry (long,X) $7E7E10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $7FDB.w,X		; BD DB 7F ; Load $7FDB.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($2F.b,X)		; 01 2F ; Logical OR ($2F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($13.b),Y		; 11 13 ; OR accumulator with memory ($13.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $030F.w		; 0C 0F 03 ; Test and set bits $030F.w [Reads: Accumulator] [Flags: Z]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($3222.w)		; 6C 22 32 ; Jump indirect to ($3222.w) [Flow: jump]
	ora $03070F.l,X		; 1F 0F 07 03 ; Logical OR long $03070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $FF7E.w,Y		; 99 7E FF ; Store accumulator to $FF7E.w,Y [Reads: Y Index, Accumulator]
	.db $42, $83		; 42 83 ; Reserved instruction
	sty $0300.w		; 8C 00 03 ; Store Y register to $0300.w [Reads: Y Index]
	bit $C3FF.w,X		; 3C FF C3 ; Test bits $C3FF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp $22.b,S		; C3 22 ; Compare accumulator (stack relative) $22.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $22.b		; 66 22 ; Rotate right $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $00.b,S		; C3 00 ; Compare accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $0F0F1E.l		; 0F 1E 0F 0F ; OR accumulator with memory (long) $0F0F1E.l [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $100900.l		; 22 00 09 10 ; Jump to subroutine long $100900.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	tsb $0707.w		; 0C 07 07 ; Test and set bits $0707.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0022.w,X		; 3C 22 00 ; Test bits $0022.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sta $8C.b,S		; 83 8C ; Store accumulator (stack relative) $8C.b,S [Reads: Stack Pointer, Accumulator]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldx $EF63.w,Y		; BE 63 EF ; Load X register $EF63.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cmp $35DB3B.l,X		; DF 3B DB 35 ; Compare accumulator (long,X) $35DB3B.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	eor $B736.w,Y		; 59 36 B7 ; Exclusive OR accumulator with memory $B736.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $66DB.w		; 6E DB 66 ; Rotate right $66DB.w [Flags: NCZ]
	adc $FF2210.l,X		; 7F 10 22 FF ; Add long $FF2210.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $FB.b		; 14 FB ; Test and reset bits $FB.b [Reads: Accumulator] [Flags: Z]
	adc $DFF7.w,Y		; 79 F7 DF ; Add $DFF7.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $37C63D.l,X		; 7F 3D C6 37 ; Add long $37C63D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$ACDB]		; DC DB AC ; Jump long indirect [$ACDB] [Flow: jump]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	jmp ($76ED.w)		; 6C ED 76 ; Jump indirect to ($76ED.w) [Flow: jump]
	cmp $08FE66.l,X		; DF 66 FE 08 ; Compare accumulator (long,X) $08FE66.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	jsl $DF04FF.l		; 22 FF 04 DF ; Jump to subroutine long $DF04FF.l [Writes: Stack Pointer] [Flow: call]
	stz $FFEF.w,X		; 9E EF FF ; Store zero to $FFEF.w,X [Reads: X Index]
	inc $27F0.w,X		; FE F0 27 ; Increment memory $27F0.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $3C.b,S		; 83 3C ; Store accumulator (stack relative) $3C.b,S [Reads: Stack Pointer, Accumulator]
	cop $29.b		; 02 29 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $153606.l,X		; 1F 06 36 15 ; Logical OR long $153606.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $272B.w,Y		; 19 2B 27 ; OR accumulator with memory $272B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $74		; 10 74 ; Branch if plus to $10, $74 [Flow: branch]
	.db $D0, $23		; D0 23 ; Branch if not equal to $D0, $23 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $ECEC.w		; 1C EC EC ; Test and reset bits $ECEC.w [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: NCZ]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	inc $0C23.w		; EE 23 0C ; Increment $0C23.w [Flags: NZ]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $30.b,S		; 23 30 ; AND accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $60.b,S		; 23 60 ; AND accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $82.b,S		; 83 82 ; Store accumulator (stack relative) $82.b,S [Reads: Stack Pointer, Accumulator]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3C3C0F.l		; 0F 0F 3C 3C ; OR accumulator with memory (long) $3C3C0F.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $C0F03C.l		; 0F 3C F0 C0 ; OR accumulator with memory (long) $C0F03C.l [Writes: Accumulator] [Flags: NZ]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $13		; 10 13 ; Branch if plus to $10, $13 [Flow: branch]
	ora $260F.w		; 0D 0F 26 ; Logical OR $260F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($3322.w)		; 6C 22 33 ; Jump indirect to ($3322.w) [Flow: jump]
	ora $00220F.l,X		; 1F 0F 22 00 ; Logical OR long $00220F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $78.b		; 86 78 ; Store X register to $78.b [Reads: X Index]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $1F1CFF.l,X		; 7F FF 1C 1F ; Add long $1F1CFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $87.b,S		; 83 87 ; Store accumulator (stack relative) $87.b,S [Reads: Stack Pointer, Accumulator]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $E3		; 80 E3 ; Branch always to $80, $E3 [Flow: branch]
	ora $FE0307.l,X		; 1F 07 03 FE ; Logical OR long $FE0307.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$7C.b		; C0 7C ; Compare #$7C.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $F4		; 80 F4 ; Branch always to $80, $F4 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	.db $80, $90		; 80 90 ; Branch always to $80, $90 [Flow: branch]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $36.b		; 00 36 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F8,$4C		; 44 4C F8 ; Move block positive $F8,$4C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsl $E007F0.l		; 22 F0 07 E0 ; Jump to subroutine long $E007F0.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$F0.b		; E0 F0 ; Compare #$F0.b with X register [Reads: X Index] [Flags: NCZ]
	ldy #$E0.b		; A0 E0 ; Load #$E0.b into Y register [Writes: Y Index] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: NCZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$7E.b]		; E7 7E ; Subtract with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc [$5A.b]		; E7 5A ; Subtract with carry (long) [$5A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $5A42.w,X		; BD 42 5A ; Load $5A42.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $FF2300.l		; 22 00 23 FF ; Jump to subroutine long $FF2300.l [Writes: Stack Pointer] [Flow: call]
	ora $7E.b,S		; 03 7E ; OR accumulator with stack relative $7E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $0018.w,X		; 3C 18 00 ; Test bits $0018.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sta $D8.b,S		; 83 D8 ; Store accumulator (stack relative) $D8.b,S [Reads: Stack Pointer, Accumulator]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $063B01.l,X		; 3F 01 3B 06 ; AND accumulator with memory (long,X) $063B01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $1C1C.w		; 2E 1C 1C ; Rotate left $1C1C.w [Flags: NCZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$FF.b],Y		; 17 FF ; OR accumulator with memory (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $3E3F3F.l,X		; 7F 3F 3F 3E ; Add long $3E3F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $0000.w		; 1C 00 00 ; Test and reset bits $0000.w [Reads: Accumulator] [Flags: Z]
	adc $3F403F.l,X		; 7F 3F 40 3F ; Add long $3F403F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $3F603F.l,X		; 5F 3F 60 3F ; Exclusive OR accumulator with memory (long,X) $3F603F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$7F.b		; E0 7F ; Compare #$7F.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$7F.b		; C0 7F ; Compare #$7F.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	sbc $7F2200.l,X		; FF 00 22 7F ; Subtract with carry (long,X) $7F2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $60.b		; 14 60 ; Test and reset bits $60.b [Reads: Accumulator] [Flags: Z]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	inc $02FC.w,X		; FE FC 02 ; Increment memory $02FC.w,X [Reads: X Index] [Flags: NZ]
	jsr ($FCFA.w,X)		; FC FA FC ; Jump to subroutine indirect indexed ($FCFA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl $FC.b		; 06 FC ; Arithmetic shift left $FC.b [Reads: Direct Page] [Flags: NCZ]
	ora [$FE.b]		; 07 FE ; OR accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FE.b,X)		; 01 FE ; Logical OR ($FE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $FE2200.l,X		; FF 00 22 FE ; Subtract with carry (long,X) $FE2200.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $90.b		; 84 90 ; Store Y register to $90.b [Reads: Y Index]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $100200.l		; 22 00 02 10 ; Jump to subroutine long $100200.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	jsl $A6880F.l		; 22 0F 88 A6 ; Jump to subroutine long $A6880F.l [Writes: Stack Pointer] [Flow: call]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $F8F8FF.l,X		; 7F FF F8 F8 ; Add long $F8F8FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	jsl $39E000.l		; 22 00 E0 39 ; Jump to subroutine long $39E000.l [Writes: Stack Pointer] [Flow: call]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $80, $87		; 80 87 ; Branch always to $80, $87 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	bit $3F0B.w		; 2C 0B 3F ; Test bits $3F0B.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	.db $10, $7E		; 10 7E ; Branch if plus to $10, $7E [Flow: branch]
	and ($7C.b,X)		; 21 7C ; Logical AND ($7C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($3F.b,S),Y		; 33 3F ; AND accumulator (stack relative indirect indexed) ($3F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $070904.l,X		; 1F 04 09 07 ; Logical OR long $070904.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$2B.b],Y		; 37 2B ; AND accumulator with memory (long indexed) [$2B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $274B.w,Y		; 59 4B 27 ; Exclusive OR accumulator with memory $274B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $E4070F.l,X		; 1F 0F 07 E4 ; Logical OR long $E4070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$EE.b		; C0 EE ; Compare #$EE.b with Y register [Reads: Y Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	nop		; EA ; No operation
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jmp ($F88C.w,X)		; 7C 8C F8 ; Jump indirect indexed to ($F88C.w,X) [Reads: X Index] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $9E.b,X		; D6 9E ; Decrement memory $9E.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $82, $04, $F8		; 82 04 F8 ; Branch always long to $82, $04, $F8 [Flow: branch]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	rol $15.b,X		; 36 15 ; Rotate left $15.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $A0.b		; 85 A0 ; Store accumulator to $A0.b [Reads: Accumulator]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($9F13.w)		; 6C 13 9F ; Jump indirect to ($9F13.w) [Flow: jump]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $000F0C.l,X		; 7F 0C 0F 00 ; Add long $000F0C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and [$2B.b],Y		; 37 2B ; AND accumulator with memory (long indexed) [$2B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $FF7B.w,Y		; 59 7B FF ; Exclusive OR accumulator with memory $FF7B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $D0720F.l,X		; 7F 0F 72 D0 ; Add long $D0720F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$D2.b],Y		; F7 D2 ; Subtract with carry (long indexed) [$D2.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F9BE.w,X		; FD BE F9 ; Subtract with carry $F9BE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $78DE.w,X		; 7E DE 78 ; Rotate right $78DE.w,X [Reads: X Index] [Flags: NCZ]
	stx $F0F0.w		; 8E F0 F0 ; Store X register to $F0F0.w [Reads: X Index]
	jsl $EE0700.l		; 22 00 07 EE ; Jump to subroutine long $EE0700.l [Writes: Stack Pointer] [Flow: call]
	sbc $81C1.w		; ED C1 81 ; Subtract $81C1.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	stx $0E.b		; 86 0E ; Store X register to $0E.b [Reads: X Index]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sbc $006008.l,X		; FF 08 60 00 ; Subtract with carry (long,X) $006008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $206000.l,X		; 9F 00 60 20 ; Store accumulator (long,X) $206000.l,X [Reads: Accumulator, X Index]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $0022.w		; 1C 22 00 ; Test and reset bits $0022.w [Reads: Accumulator] [Flags: Z]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $1C275F.l,X		; FF 5F 27 1C ; Subtract with carry (long,X) $1C275F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A3.b		; 00 A3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $FF22.w,X		; FE 22 FF ; Increment memory $FF22.w,X [Reads: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
.ACCU 8
	sep #$E2		; E2 E2
.ACCU 16
.INDEX 16
	rep #$38		; C2 38
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $43		; 10 43 ; Branch if plus to $10, $43 [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $085C.w		; 0D 5C 08 ; Logical OR $085C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($D6EE.w,X)		; 7C EE D6 ; Jump indirect indexed to ($D6EE.w,X) [Reads: X Index] [Flow: jump]
	dec $D4.b,X		; D6 D4 ; Decrement memory $D4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $2B		; F0 2B ; Branch if equal to $F0, $2B [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	cpx #$3822.w		; E0 22 38 ; Compare #$3822.w with X register [Reads: X Index] [Flags: NCZ]
	jmp ($0007.w,X)		; 7C 07 00 ; Jump indirect indexed to ($0007.w,X) [Reads: X Index] [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($49.b,X)		; 01 49 ; Logical OR ($49.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp ($40.b,S),Y		; D3 40 ; Compare accumulator (stack relative indirect indexed) ($40.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	jmp ($0720.w)		; 6C 20 07 ; Jump indirect to ($0720.w) [Flow: jump]
	ora $70793E.l,X		; 1F 3E 79 70 ; Logical OR long $70793E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $B3		; B0 B3 ; Branch if carry set to $B0, $B3 [Flow: branch]
	eor $400080.l,X		; 5F 80 00 40 ; Exclusive OR accumulator with memory (long,X) $400080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	jsl $0C0B00.l		; 22 00 0B 0C ; Jump to subroutine long $0C0B00.l [Writes: Stack Pointer] [Flow: call]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$60E0.w		; C0 E0 60 ; Compare #$60E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$0C00.w		; C0 00 0C ; Compare #$0C00.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $02002B.l,X		; 9F 2B 00 02 ; Store accumulator (long,X) $02002B.l,X [Reads: Accumulator, X Index]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($26.b)		; 12 26 ; OR accumulator with memory (indirect) ($26.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($F3.b,X)		; E1 F3 ; Subtract with carry ($F3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $1100.w		; 0E 00 11 ; Arithmetic shift left $1100.w [Flags: NCZ]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2A.b		; 04 2A ; Test and set bits $2A.b [Reads: Accumulator] [Flags: Z]
	mvp $14,$00		; 44 00 14 ; Move block positive $14,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $0094.w		; 0D 94 00 ; Logical OR $0094.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1C3E3B.l,X		; 1F 3B 3E 1C ; Logical OR long $1C3E3B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $F89C.w		; 1C 9C F8 ; Test and reset bits $F89C.w [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	tsb $3E03.w		; 0C 03 3E ; Test and set bits $3E03.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	adc $3D7F3B.l		; 6F 3B 7F 3D ; Add with carry (long) $3D7F3B.l [Writes: Accumulator] [Flags: NCVZ]
	and $03011F.l,X		; 3F 1F 01 03 ; AND accumulator with memory (long,X) $03011F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $3F7F7F.l,X		; 3F 7F 7F 3F ; AND accumulator with memory (long,X) $3F7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$D07C.w		; C0 7C D0 ; Compare #$D07C.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $DC.b,X		; F6 DC ; Increment memory $DC.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $FC.b		; E6 FC ; Increment $FC.b [Reads: Direct Page] [Flags: NZ]
	tsb $80F8.w		; 0C F8 80 ; Test and set bits $80F8.w [Reads: Accumulator] [Flags: Z]
	cpy #$F040.w		; C0 40 F0 ; Compare #$F040.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($0001.w,X)		; FC 01 00 ; Jump to subroutine indirect indexed ($0001.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $CF.b		; 85 CF ; Store accumulator to $CF.b [Reads: Accumulator]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $00D88D.l,X		; 7F 8D D8 00 ; Add long $00D88D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $E7.b		; 85 E7 ; Store accumulator to $E7.b [Reads: Accumulator]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $5FE4.w,X		; FE E4 5F ; Increment memory $5FE4.w,X [Reads: X Index] [Flags: NZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$1A61.w		; E0 61 1A ; Compare #$1A61.w with X register [Reads: X Index] [Flags: NCZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3070.w		; 20 70 30 ; Jump to subroutine at $3070.w [Writes: Stack Pointer] [Flow: call]
	and $1E1C.w,X		; 3D 1C 1E ; AND accumulator with memory $1E1C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $234F5F.l,X		; 3F 5F 4F 23 ; AND accumulator with memory (long,X) $234F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0143.w,X		; 1E 43 01 ; Arithmetic shift left $0143.w,X [Reads: X Index] [Flags: NCZ]
	eor [$03.b]		; 47 03 ; Exclusive OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $9E06.w		; 8E 06 9E ; Store X register to $9E06.w [Reads: X Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $D902.w		; AE 02 D9 ; Load $D902.w into X register [Writes: X Index] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $89.b		; C4 89 ; Compare $89.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sta $AD.b,X		; 95 AD ; Store accumulator to $AD.b,X [Reads: Accumulator, X Index]
	sbc $081C3E.l,X		; FF 3E 1C 08 ; Subtract with carry (long,X) $081C3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $23EF.w		; 20 EF 23 ; Jump to subroutine at $23EF.w [Writes: Stack Pointer] [Flow: call]
	adc [$30.b],Y		; 77 30 ; Add with carry (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($10.b),Y		; 31 10 ; AND accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $F800.w,X		; 1E 00 F8 ; Arithmetic shift left $F800.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($DBBD.w,X)		; FC BD DB ; Jump to subroutine indirect indexed ($DBBD.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp.w [$2F4F]		; DC 4F 2F ; Jump long indirect [$2F4F] [Flow: jump]
	asl $0092.w,X		; 1E 92 00 ; Arithmetic shift left $0092.w,X [Reads: X Index] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	brk $B4.b		; 00 B4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $A8		; 80 A8 ; Branch always to $80, $A8 [Flow: branch]
	.db $80, $92		; 80 92 ; Branch always to $80, $92 [Flow: branch]
	.db $80, $DD		; 80 DD ; Branch always to $80, $DD [Flow: branch]
	cpy #$60E2.w		; C0 E2 60 ; Compare #$60E2.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp ($FE00.w,X)		; 7C 00 FE ; Jump indirect indexed to ($FE00.w,X) [Reads: X Index] [Flow: jump]
	inc $787C.w,X		; FE 7C 78 ; Increment memory $787C.w,X [Reads: X Index] [Flags: NZ]
	adc ($3F.b)		; 72 3F ; Add with carry (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $337C.w,X		; 9E 7C 33 ; Store zero to $337C.w,X [Reads: X Index]
	ora $37.b,S		; 03 37 ; OR accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $68		; 10 68 ; Branch if plus to $10, $68 [Flow: branch]
	jsr $E843.w		; 20 43 E8 ; Jump to subroutine at $E843.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$772B.w		; E0 2B 77 ; Compare #$772B.w with X register [Reads: X Index] [Flags: NCZ]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $2F3C00.l,X		; 1F 00 3C 2F ; Logical OR long $2F3C00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $A21F27.l		; 4F 27 1F A2 ; Exclusive OR accumulator with memory (long) $A21F27.l [Writes: Accumulator] [Flags: NZ]
	brk $79.b		; 00 79 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $7B20.w,Y		; 79 20 7B ; Add $7B20.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $00AB.w		; 20 AB 00 ; Jump to subroutine at $00AB.w [Writes: Stack Pointer] [Flow: call]
	adc ($40.b,S),Y		; 73 40 ; Add with carry (stack relative indirect indexed) ($40.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec $8C8C.w,X		; DE 8C 8C ; Decrement memory $8C8C.w,X [Reads: X Index] [Flags: NZ]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$5F.b]		; 47 5F ; Exclusive OR accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $52BFEF.l,X		; 5F EF BF 52 ; Exclusive OR accumulator with memory (long,X) $52BFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $40CC.w		; 8C CC 40 ; Store Y register to $40CC.w [Reads: Y Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cmp $4344.w,X		; DD 44 43 ; Compare accumulator $4344.w,X [Reads: X Index] [Flags: NCZ]
	sta $E084.w,X		; 9D 84 E0 ; Store accumulator to $E084.w,X [Reads: Accumulator, X Index]
	sta $DC.b		; 85 DC ; Store accumulator to $DC.b [Reads: Accumulator]
	cpy $EF.b		; C4 EF ; Compare $EF.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	adc $73.b,S		; 63 73 ; Add with carry (stack relative) $73.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $7B7BBB.l,X		; BF BB 7B 7B ; Load long $7B7BBB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $2873.w		; 9C 73 28 ; Store zero to $2873.w
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E2.b		; 00 E2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($9818.w,X)		; 7C 18 98 ; Jump indirect indexed to ($9818.w,X) [Reads: X Index] [Flow: jump]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $74		; 70 74 ; Branch if overflow set to $70, $74 [Flow: branch]
	ror $E49E.w,X		; 7E 9E E4 ; Rotate right $E49E.w,X [Reads: X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $002F07.l,X		; 3F 07 2F 00 ; AND accumulator with memory (long,X) $002F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $041F18.l,X		; 3F 18 1F 04 ; AND accumulator with memory (long,X) $041F18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $2E14.w,X		; 3C 14 2E ; Test bits $2E14.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $3A7F39.l		; 4F 39 7F 3A ; Exclusive OR accumulator with memory (long) $3A7F39.l [Writes: Accumulator] [Flags: NZ]
	and $19253F.l,X		; 3F 3F 25 19 ; AND accumulator with memory (long,X) $19253F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $7F7E.w,X		; 3D 7E 7F ; AND accumulator with memory $7F7E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($F4E0.w,X)		; FC E0 F4 ; Jump to subroutine indirect indexed ($F4E0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr $283C.w		; 20 3C 28 ; Jump to subroutine at $283C.w [Writes: Stack Pointer] [Flow: call]
	stz $58.b,X		; 74 58 ; Store zero to $58.b,X [Reads: X Index]
	sbc ($9C.b)		; F2 9C ; Subtract with carry (indirect) ($9C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $FC5C.w,X		; FE 5C FC ; Increment memory $FC5C.w,X [Reads: X Index] [Flags: NZ]
	jsr ($98A4.w,X)		; FC A4 98 ; Jump to subroutine indirect indexed ($98A4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp.w [$7EBC]		; DC BC 7E ; Jump long indirect [$7EBC] [Flow: jump]
	inc $073F.w,X		; FE 3F 07 ; Increment memory $073F.w,X [Reads: X Index] [Flags: NZ]
	sbc $089F00.l,X		; FF 00 9F 08 ; Subtract with carry (long,X) $089F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $14EC24.l,X		; BF 24 EC 14 ; Load long $14EC24.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $3A.b		; 66 3A ; Rotate right $3A.b [Reads: Direct Page] [Flags: NCZ]
	adc ($1D.b,S),Y		; 73 1D ; Add with carry (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $FF3F.w		; 0E 3F FF ; Arithmetic shift left $FF3F.w [Flags: NCZ]
	sbc $D9.b,X		; F5 D9 ; Subtract $D9.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc $3F7E.w,X		; 7D 7E 3F ; Add $3F7E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($FFE0.w,X)		; FC E0 FF ; Jump to subroutine indirect indexed ($FFE0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $FD		; 10 FD ; Branch if plus to $10, $FD [Flow: branch]
	bit $37.b		; 24 37 ; Test bits $37.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ror $5C.b		; 66 5C ; Rotate right $5C.b [Reads: Direct Page] [Flags: NCZ]
	dec $DCB8.w		; CE B8 DC ; Decrement $DCB8.w [Flags: NZ]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	sbc $DF9BAF.l,X		; FF AF 9B DF ; Subtract with carry (long,X) $DF9BAF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $FC7E.w,Y		; BE 7E FC ; Load X register $FC7E.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $1F.b		; E5 1F ; Subtract $1F.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $226702.l,X		; 7F 02 67 22 ; Add long $226702.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $3E36.w,Y		; 79 36 3E ; Add $3E36.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $3F.b		; 05 3F ; Logical OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $26		; 10 26 ; Branch if plus to $10, $26 [Flow: branch]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	jsl $7F1400.l		; 22 00 14 7F ; Jump to subroutine long $7F1400.l [Writes: Stack Pointer] [Flow: call]
	eor $2F3E4F.l,X		; 5F 4F 3E 2F ; Exclusive OR accumulator with memory (long,X) $2F3E4F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	trb $FE00.w		; 1C 00 FE ; Test and reset bits $FE00.w [Reads: Accumulator] [Flags: Z]
	rti		; [PATTERN: Memory clearing operation] 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $44.b		; E6 44 ; Increment $44.b [Reads: Direct Page] [Flags: NZ]
	stz $7C6C.w,X		; 9E 6C 7C ; Store zero to $7C6C.w,X [Reads: X Index]
	ldy #$08FC.w		; A0 FC 08 ; Load #$08FC.w into Y register [Writes: Y Index] [Flags: NZ]
	stz $20.b		; 64 20 ; Store zero to $20.b
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $37E000.l		; 22 00 E0 37 ; Jump to subroutine long $37E000.l [Writes: Stack Pointer] [Flow: call]
	inc $F2FA.w,X		; FE FA F2 ; Increment memory $F2FA.w,X [Reads: X Index] [Flags: NZ]
	jmp ($5CF4.w,X)		; 7C F4 5C ; Jump indirect indexed to ($5CF4.w,X) [Reads: X Index] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3D66.w,X		; 1E 66 3D ; Arithmetic shift left $3D66.w,X [Reads: X Index] [Flags: NCZ]
	adc $096E24.l,X		; 7F 24 6E 09 ; Add long $096E24.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $007F04.l,X		; 5F 04 7F 00 ; Exclusive OR accumulator with memory (long,X) $007F04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $1C00.w,X		; 3E 00 1C ; Rotate left $1C00.w,X [Reads: X Index] [Flags: NCZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $767F.w,X		; 7E 7F 76 ; Rotate right $767F.w,X [Reads: X Index] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $DC1C3E.l,X		; 7F 3E 1C DC ; Add long $DC1C3E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ror $BC.b		; 66 BC ; Rotate right $BC.b [Reads: Direct Page] [Flags: NCZ]
	inc $7624.w,X		; FE 24 76 ; Increment memory $7624.w,X [Reads: X Index] [Flags: NZ]
	.db $90, $FA		; 90 FA ; Branch if carry clear to $90, $FA [Flow: branch]
	jsr $00FE.w		; 20 FE 00 ; Jump to subroutine at $00FE.w [Writes: Stack Pointer] [Flow: call]
	jmp ($3800.w,X)		; 7C 00 38 ; Jump indirect indexed to ($3800.w,X) [Reads: X Index] [Flow: jump]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $6EFE.w,X		; 7E FE 6E ; Rotate right $6EFE.w,X [Reads: X Index] [Flags: NCZ]
	dec $7CFE.w,X		; DE FE 7C ; Decrement memory $7CFE.w,X [Reads: X Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $DF.b		; E5 DF ; Subtract $DF.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$032F.w		; E0 2F 03 ; Compare #$032F.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $771C3B.l		; 0F 3B 1C 77 ; OR accumulator with memory (long) $771C3B.l [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $D8.b,X		; 34 D8 ; Test bits $D8.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc [$E4.b]		; 67 E4 ; Add with carry (long) [$E4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $1F0F03.l,X		; 7F 03 0F 1F ; Add long $1F0F03.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $7478.w,X		; 3C 78 74 ; Test bits $7478.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$F000.w		; C0 00 F0 ; Compare #$F000.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$F0F8.w		; C0 F8 F0 ; Compare #$F0F8.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp ($BED8.w,X)		; 7C D8 BE ; Jump indirect indexed to ($BED8.w,X) [Reads: X Index] [Flow: jump]
	jmp ($E47E.w)		; 6C 7E E4 ; Jump indirect to ($E47E.w) [Flow: jump]
	adc $C2FFC2.l,X		; 7F C2 FF C2 ; Add long $C2FFC2.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$F8F0.w		; C0 F0 F8 ; Compare #$F8F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($FE7E.w,X)		; FC 7E FE ; Jump to subroutine indirect indexed ($FE7E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $0083FF.l,X		; FF FF 83 00 ; Subtract with carry (long,X) $0083FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F09.w,X		; 1E 09 3F ; Arithmetic shift left $3F09.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $66		; 10 66 ; Branch if plus to $10, $66 [Flow: branch]
	and $3B44.w,Y		; 39 44 3B ; AND accumulator with memory $3B44.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $E471.w		; CE 71 E4 ; Decrement $E471.w [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $7930.w,Y		; 19 30 79 ; OR accumulator with memory $7930.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($FB.b),Y		; F1 FB ; Subtract with carry ($FB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $18.b		; 86 18 ; Store X register to $18.b [Reads: X Index]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	rol $3EF4.w,X		; 3E F4 3E ; Rotate left $3EF4.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $7F		; F0 7F ; Branch if equal to $F0, $7F [Flow: branch]
	cpx #$E0FF.w		; E0 FF E0 ; Compare #$E0FF.w with X register [Reads: X Index] [Flags: NCZ]
	sta $28.b,S		; 83 28 ; Store accumulator (stack relative) $28.b,S [Reads: Stack Pointer, Accumulator]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FFFE.w,X		; FE FE FF ; Increment memory $FFFE.w,X [Reads: X Index] [Flags: NZ]
	sbc $090025.l,X		; FF 25 00 09 ; Subtract with carry (long,X) $090025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	tsb $1807.w		; 0C 07 18 ; Test and set bits $1807.w [Reads: Accumulator] [Flags: Z]
	ora $220E11.l		; 0F 11 0E 22 ; OR accumulator with memory (long) $220E11.l [Writes: Accumulator] [Flags: NZ]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F1E1F.l		; 0F 1F 1E 0F ; OR accumulator with memory (long) $0F1E1F.l [Writes: Accumulator] [Flags: NZ]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$E3.b]		; 07 E3 ; OR accumulator with memory (long) [$E3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $3FFE9F.l,X		; 3F 9F FE 3F ; AND accumulator with memory (long,X) $3FFE9F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $1EE7BC.l		; 4F BC E7 1E ; Exclusive OR accumulator with memory (long) $1EE7BC.l [Writes: Accumulator] [Flags: NZ]
	sbc [$0E.b],Y		; F7 0E ; Subtract with carry (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF223F.l		; 0F 3F 22 FF ; OR accumulator with memory (long) $FF223F.l [Writes: Accumulator] [Flags: NZ]
	cop $BF.b		; 02 BF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00250F.l,X		; 1F 0F 25 00 ; Logical OR long $00250F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $66.b		; 85 66 ; Store accumulator to $66.b [Reads: Accumulator]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $110E.w,Y		; 19 0E 11 ; OR accumulator with memory $110E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $0022.w		; 0E 22 00 ; Arithmetic shift left $0022.w [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $7789.w,X		; 1E 89 77 ; Arithmetic shift left $7789.w,X [Reads: X Index] [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $9F		; F0 9F ; Branch if equal to $F0, $9F [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp $38DF3C.l		; CF 3C DF 38 ; Compare accumulator (long) $38DF3C.l [Reads: Accumulator] [Flags: NCZ]
	ora $FF223F.l		; 0F 3F 22 FF ; OR accumulator with memory (long) $FF223F.l [Writes: Accumulator] [Flags: NZ]
	asl $3F7F.w		; 0E 7F 3F ; Arithmetic shift left $3F7F.w [Flags: NCZ]
	and $3C00F0.l,X		; 3F F0 00 3C ; AND accumulator with memory (long,X) $3C00F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$FCC7.w		; E0 C7 FC ; Compare #$FCC7.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $FE7F.w,Y		; F9 7F FE ; Subtract with carry $FE7F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $4303FF.l		; 0F FF 03 43 ; OR accumulator with memory (long) $4303FF.l [Writes: Accumulator] [Flags: NZ]
	sbc $F00100.l,X		; FF 00 01 F0 ; Subtract with carry (long,X) $F00100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($FF25.w,X)		; FC 25 FF ; Jump to subroutine indirect indexed ($FF25.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0080.w		; 09 80 00 ; Logical OR #$0080.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	cpy #$E090.w		; C0 90 E0 ; Compare #$E090.w with Y register [Reads: Y Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $70, $22		; 70 22 ; Branch if overflow set to $70, $22 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpx #$F8F0.w		; E0 F0 F8 ; Compare #$F8F0.w with X register [Reads: X Index] [Flags: NCZ]
	eor $17.b,S		; 43 17 ; Exclusive OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpx #$3F21.w		; E0 21 3F ; Compare #$3F21.w with X register [Reads: X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $7F16.w,X		; 5D 16 7F ; Exclusive OR accumulator with memory $7F16.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($77.b)		; 32 77 ; AND accumulator with memory (indirect) ($77.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $5EF3.w		; 2C F3 5E ; Test bits $5EF3.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $1F1F5E.l,X		; FF 5E 1F 1F ; Subtract with carry (long,X) $1F1F5E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $BF5F4F.l		; 6F 4F 5F BF ; Add with carry (long) $BF5F4F.l [Writes: Accumulator] [Flags: NCVZ]
	lda $7EFF81.l,X		; BF 81 FF 7E ; Load long $7EFF81.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($BD.b,X)		; 81 BD ; Store accumulator ($BD.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $42, $C3		; 42 C3 ; Reserved instruction
	bit $81FF.w,X		; 3C FF 81 ; Test bits $81FF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jsl $8103FF.l		; 22 FF 03 81 ; Jump to subroutine long $8103FF.l [Writes: Stack Pointer] [Flow: call]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jsl $0012FF.l		; 22 FF 12 00 ; Jump to subroutine long $0012FF.l [Writes: Stack Pointer] [Flow: call]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2F1F23.l		; 0F 23 1F 2F ; OR accumulator with memory (long) $2F1F23.l [Writes: Accumulator] [Flags: NZ]
	asl $113F.w,X		; 1E 3F 11 ; Arithmetic shift left $113F.w,X [Reads: X Index] [Flags: NCZ]
	ora $030F03.l,X		; 1F 03 0F 03 ; Logical OR long $030F03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $073F22.l,X		; 1F 22 3F 07 ; Logical OR long $073F22.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $003C0F.l,X		; 1F 0F 3C 00 ; Logical OR long $003C0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7EC33C.l,X		; FF 3C C3 7E ; Subtract with carry (long,X) $7EC33C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $99.b,S		; 43 99 ; Exclusive OR accumulator with stack relative $99.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$0A.b]		; E7 0A ; Subtract with carry (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $81FFC3.l,X		; FF C3 FF 81 ; Subtract with carry (long,X) $81FFC3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF3C7E.l,X		; FF 7E 3C FF ; Subtract with carry (long,X) $FF3C7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $22E7E7.l,X		; FF E7 E7 22 ; Subtract with carry (long,X) $22E7E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $090023.l,X		; FF 23 00 09 ; Subtract with carry (long,X) $090023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0E1700.l		; 0F 00 17 0E ; OR accumulator with memory (long) $0E1700.l [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora [$23.b],Y		; 17 23 ; OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $831F37.l,X		; 1F 37 1F 83 ; Logical OR long $831F37.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $0500.w		; 8E 00 05 ; Store X register to $0500.w [Reads: X Index]
	ora $3F371F.l		; 0F 1F 37 3F ; OR accumulator with memory (long) $3F371F.l [Writes: Accumulator] [Flags: NZ]
	and $38841F.l,X		; 3F 1F 84 38 ; AND accumulator with memory (long,X) $38841F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $18E799.l,X		; FF 99 E7 18 ; Subtract with carry (long,X) $18E799.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvp $81,$FF		; 44 FF 81 ; Move block positive $81,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sty $48.b		; 84 48 ; Store Y register to $48.b [Reads: Y Index]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $FF7F02.l,X		; FF 02 7F FF ; Subtract with carry (long,X) $FF7F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $7F43.w		; 4E 43 7F ; Logical shift right $7F43.w [Flags: NCZ]
	jsr $3F13.w		; 20 13 3F ; Jump to subroutine at $3F13.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	tsb $030F.w		; 0C 0F 03 ; Test and set bits $030F.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $7F7FFF.l,X		; FF FF 7F 7F ; Subtract with carry (long,X) $7F7FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $030F1F.l,X		; 3F 1F 0F 03 ; AND accumulator with memory (long,X) $030F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $02FF82.l,X		; FF 82 FF 02 ; Subtract with carry (long,X) $02FF82.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $1D.b		; 04 1D ; Test and set bits $1D.b [Reads: Accumulator] [Flags: Z]
	jsr ($F808.w,X)		; FC 08 F8 ; Jump to subroutine indirect indexed ($F808.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $FEFEFF.l,X		; FF FF FE FE ; Subtract with carry (long,X) $FEFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$7FF1.w		; C0 F1 7F ; Compare #$7FF1.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $0E7F5F.l,X		; FF 5F 7F 0E ; Subtract with carry (long,X) $0E7F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $003F00.l,X		; 7F 00 3F 00 ; Add long $003F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $000F00.l,X		; 1F 00 0F 00 ; Logical OR long $000F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $0201.w		; 8E 01 02 ; Store X register to $0201.w [Reads: X Index]
	cpy #$80FF.w		; C0 FF 80 ; Compare #$80FF.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F800.w,X)		; FC 00 F8 ; Jump to subroutine indirect indexed ($F800.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $01.b		; A6 01 ; Load $01.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and ($1E.b),Y		; 31 1E ; AND accumulator with memory ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $1F.b		; 24 1F ; Test bits $1F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	rol $6D1F.w		; 2E 1F 6D ; Rotate left $6D1F.w [Flags: NCZ]
	rol $3B7E.w,X		; 3E 7E 3B ; Rotate left $3B7E.w,X [Reads: X Index] [Flags: NCZ]
	adc $5F4331.l,X		; 7F 31 43 5F ; Add long $5F4331.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	rol $3F3F.w,X		; 3E 3F 3F ; Rotate left $3F3F.w,X [Reads: X Index] [Flags: NCZ]
	ror $7F23.w,X		; 7E 23 7F ; Rotate right $7F23.w,X [Reads: X Index] [Flags: NCZ]
	ora #$1EE7.w		; 09 E7 1E ; Logical OR #$1EE7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $F81F3C.l		; CF 3C 1F F8 ; Compare accumulator (long) $F81F3C.l [Reads: Accumulator] [Flags: NCZ]
	adc $80FFF0.l,X		; 7F F0 FF 80 ; Add long $80FFF0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FF.b		; 45 FF ; Exclusive OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF253F.l,X		; 1F 3F 25 FF ; Logical OR long $FF253F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $33.b		; 14 33 ; Test and reset bits $33.b [Reads: Accumulator] [Flags: Z]
	trb $1C27.w		; 1C 27 1C ; Test and reset bits $1C27.w [Reads: Accumulator] [Flags: Z]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $3D4A.w,X		; 3C 4A 3D ; Test bits $3D4A.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	and $5D.b,X		; 35 5D ; Logical AND $5D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and [$5F.b],Y		; 37 5F ; AND accumulator with memory (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($5F.b)		; 32 5F ; AND accumulator with memory (indirect) ($5F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	bit $7D7C.w,X		; 3C 7C 7D ; Test bits $7D7C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc $7F22.w,X		; 7D 22 7F ; Add $7F22.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($BF.b,X)		; 01 BF ; Logical OR ($BF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $70, $43		; 70 43 ; Branch if overflow set to $70, $43 [Flow: branch]
	adc $C883E0.l,X		; 7F E0 83 C8 ; Add long $C883E0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($45.b,X)		; 01 45 ; Logical OR ($45.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $7F0000.l,X		; FF 00 00 7F ; Subtract with carry (long,X) $7F0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $FF00.w		; 4E 00 FF ; Logical shift right $FF00.w [Flags: NCZ]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$E8.b]		; 07 E8 ; OR accumulator with memory (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $F4		; 30 F4 ; Branch if minus to $30, $F4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	pea $F618.w		; F4 18 F6 ; Push absolute address $F618.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $FA43.w		; 0C 43 FA ; Test and set bits $FA43.w [Reads: Accumulator] [Flags: Z]
	tsb $F802.w		; 0C 02 F8 ; Test and set bits $F802.w [Reads: Accumulator] [Flags: Z]
	jsr ($24FC.w,X)		; FC FC 24 ; Jump to subroutine indirect indexed ($24FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FF08.w,X		; FE 08 FF ; Increment memory $FF08.w,X [Reads: X Index] [Flags: NZ]
	.db $50, $79		; 50 79 ; Branch if overflow clear to $50, $79 [Flow: branch]
	rol $0E3D.w		; 2E 3D 0E ; Rotate left $0E3D.w [Flags: NCZ]
	ora $260300.l		; 0F 00 03 26 ; OR accumulator with memory (long) $260300.l [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $0F3F5F.l,X		; BF 5F 3F 0F ; Load long $0F3F5F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc [$3C.b]		; E7 3C ; Subtract with carry (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2DEF42.l,X		; FF 42 EF 2D ; Subtract with carry (long,X) $2DEF42.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0403.w,X		; FD 03 04 ; Subtract with carry $0403.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $FF0700.l		; 22 00 07 FF ; Jump to subroutine long $FF0700.l [Writes: Stack Pointer] [Flow: call]
	sbc $FFD3BD.l,X		; FF BD D3 FF ; Subtract with carry (long,X) $FFD3BD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0A.b],Y		; 17 0A ; OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $21		; F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	pea $2200.w		; F4 00 22 ; Push absolute address $2200.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $011983.l,X		; FF 83 19 01 ; Subtract with carry (long,X) $011983.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $27E0FF.l		; 22 FF E0 27 ; Jump to subroutine long $27E0FF.l [Writes: Stack Pointer] [Flow: call]
	ora $0B1F06.l,X		; 1F 06 1F 0B ; Logical OR long $0B1F06.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $2717.w		; 2D 17 27 ; Logical AND $2717.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $163705.l,X		; 1F 05 37 16 ; Logical OR long $163705.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$07.b]		; 27 07 ; AND accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $1F1F2F.l		; 6F 2F 1F 1F ; Add with carry (long) $1F1F2F.l [Writes: Accumulator] [Flags: NCVZ]
	and $291B26.l		; 2F 26 1B 29 ; AND accumulator with memory (long) $291B26.l [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $50, $E7		; 50 E7 ; Branch if overflow clear to $50, $E7 [Flow: branch]
	sbc $FF7EFF.l,X		; FF FF 7E FF ; Subtract with carry (long,X) $FF7EFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$7E.b]		; E7 7E ; Subtract with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFE799.l,X		; FF 99 E7 FF ; Subtract with carry (long,X) $FFE799.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $81FF.w,X		; 7E FF 81 ; Rotate right $81FF.w,X [Reads: X Index] [Flags: NCZ]
	ror $237E.w,X		; 7E 7E 23 ; Rotate right $237E.w,X [Reads: X Index] [Flags: NCZ]
	sbc $FFE703.l,X		; FF 03 E7 FF ; Subtract with carry (long,X) $FFE703.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $8881.w,X		; 7E 81 88 ; Rotate right $8881.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora [$06.b],Y		; 17 06 ; OR accumulator with memory (long indexed) [$06.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$07.b],Y		; 37 07 ; AND accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $E08313.l		; 2F 13 83 E0 ; AND accumulator with memory (long) $E08313.l [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2C3819.l,X		; 1F 19 38 2C ; Logical OR long $2C3819.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $2302E8.l		; 8F E8 02 23 ; Store accumulator (long) $2302E8.l [Reads: Accumulator]
	sbc $02FC83.l,X		; FF 83 FC 02 ; Subtract with carry (long,X) $02FC83.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($20.b)		; 92 20 ; Store accumulator (indirect) ($20.b) [Reads: Direct Page, Accumulator]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $013687.l,X		; 3F 87 36 01 ; AND accumulator with memory (long,X) $013687.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $99.b,S		; 43 99 ; Exclusive OR accumulator with stack relative $99.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$8A.b]		; E7 8A ; Subtract with carry (long) [$8A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $01		; 42 01 ; Reserved instruction
	jsl $2092FF.l		; 22 FF 92 20 ; Jump to subroutine long $2092FF.l [Writes: Stack Pointer] [Flow: call]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $013687.l,X		; 3F 87 36 01 ; AND accumulator with memory (long,X) $013687.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $99.b,S		; 43 99 ; Exclusive OR accumulator with stack relative $99.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$8A.b]		; E7 8A ; Subtract with carry (long) [$8A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $01		; 42 01 ; Reserved instruction
	jsl $002BFF.l		; 22 FF 2B 00 ; Jump to subroutine long $002BFF.l [Writes: Stack Pointer] [Flow: call]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $2F.b		; 04 2F ; Test and set bits $2F.b [Reads: Accumulator] [Flags: Z]
	ora $0025.w,X		; 1D 25 00 ; OR accumulator with memory $0025.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $070027.l,X		; 3F 27 00 07 ; AND accumulator with memory (long,X) $070027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $EC04.w,X		; 1E 04 EC ; Arithmetic shift left $EC04.w,X [Reads: X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp $2388.w		; 4C 88 23 ; Jump to $2388.w [Flow: jump]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $2DF4.w		; F4 F4 2D ; Push absolute address $2DF4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $002604.l,X		; 1F 04 26 00 ; Logical OR long $002604.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0500.w		; 29 00 05 ; Logical AND #$0500.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	asl $EE04.w,X		; 1E 04 EE ; Arithmetic shift left $EE04.w,X [Reads: X Index] [Flags: NCZ]
	tsb $0024.w		; 0C 24 00 ; Test and set bits $0024.w [Reads: Accumulator] [Flags: Z]
	ora $F21A06.l,X		; 1F 06 1A F2 ; Logical OR long $F21A06.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora [$34.b]		; 07 34 ; OR accumulator with memory (long) [$34.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $1E.b,S		; 23 1E ; AND accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($1D.b)		; 72 1D ; Add with carry (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$4C.b],Y		; F7 4C ; Subtract with carry (long indexed) [$4C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $C0FF7F.l,X		; 3F 7F FF C0 ; AND accumulator with memory (long,X) $C0FF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$84E0.w		; C0 E0 84 ; Compare #$84E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $1A00.w,Y		; 19 00 1A ; OR accumulator with memory $1A00.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $30, $3C		; 30 3C ; Branch if minus to $30, $3C [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	bit $C0E8.w,X		; 3C E8 C0 ; Test bits $C0E8.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpx #$F0E0.w		; E0 E0 F0 ; Compare #$F0E0.w with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FFFC.w,X)		; FC FC FF ; Jump to subroutine indirect indexed ($FFFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $50, $F9		; 50 F9 ; Branch if overflow clear to $50, $F9 [Flow: branch]
	ror $2E7D.w		; 6E 7D 2E ; Rotate right $2E7D.w [Flags: NCZ]
	and $011F10.l,X		; 3F 10 1F 01 ; AND accumulator with memory (long,X) $011F10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $2F5F9F.l,X		; BF 9F 5F 2F ; Load long $2F5F9F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $880307.l,X		; 1F 07 03 88 ; Logical OR long $880307.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$02.b]		; 87 02 ; Store accumulator (long) [$02.b] [Reads: Direct Page, Accumulator]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	cmp $24.b,S		; C3 24 ; Compare accumulator (stack relative) $24.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	jsl $988400.l		; 22 00 84 98 ; Jump to subroutine long $988400.l [Writes: Stack Pointer] [Flow: call]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$C3.b]		; E7 C3 ; Subtract with carry (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	adc $3B31.w,X		; 7D 31 3B ; Add $3B31.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	trb $64.b		; 14 64 ; Test and reset bits $64.b [Reads: Accumulator] [Flags: Z]
	lsr $0C3C.w		; 4E 3C 0C ; Logical shift right $0C3C.w [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc ($B0.b),Y		; F1 B0 ; Subtract with carry ($B0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B4.b,X		; F5 B4 ; Subtract $B4.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	ror $0022.w,X		; 7E 22 00 ; Rotate right $0022.w,X [Reads: X Index] [Flags: NCZ]
	ora #$7EE7.w		; 09 E7 7E ; Logical OR #$7EE7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $4B4F.w,X		; 3C 4F 4B ; Test bits $4B4F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp [$7E.b]		; C7 7E ; Compare accumulator (long) [$7E.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	eor $13.b,S		; 43 13 ; Exclusive OR accumulator with stack relative $13.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0906.w		; 0D 06 09 ; Logical OR $0906.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $240900.l		; 22 00 09 24 ; Jump to subroutine long $240900.l [Writes: Stack Pointer] [Flow: call]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0707.w		; 09 07 07 ; Logical OR #$0707.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $C1.b,S		; 23 C1 ; AND accumulator with stack relative $C1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $E1.b		; 06 E1 ; Arithmetic shift left $E1.b [Reads: Direct Page] [Flags: NCZ]
	adc ($F3.b,X)		; 61 F3 ; Add with carry ($F3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($FF.b)		; 72 FF ; Add with carry (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $22FF.w,X		; 9E FF 22 ; Store zero to $22FF.w,X [Reads: X Index]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$3E.b]		; 67 3E ; Add with carry (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $8D9E.w,X		; 3E 9E 8D ; Rotate left $8D9E.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($FF.b,X)		; E1 FF ; Subtract with carry ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0A.b],Y		; 17 0A ; OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($F4.b,S),Y		; 93 F4 ; Store accumulator (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $44.b,S		; C3 44 ; Compare accumulator (stack relative) $44.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $C30081.l,X		; FF 81 00 C3 ; Subtract with carry (long,X) $C30081.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $E9.b,S		; 83 E9 ; Store accumulator (stack relative) $E9.b,S [Reads: Stack Pointer, Accumulator]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $81FF.w,X		; 3C FF 81 ; Test bits $81FF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and #$43FF.w		; 29 FF 43 ; Logical AND #$43FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$0A.b],Y		; 17 0A ; OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $B4.b,X		; 95 B4 ; Store accumulator to $B4.b,X [Reads: Accumulator, X Index]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	sbc ($02.b)		; F2 02 ; Subtract with carry (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stx $0F.b		; 86 0F ; Store X register to $0F.b [Reads: X Index]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $DB9901.l,X		; FF 01 99 DB ; Subtract with carry (long,X) $DB9901.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $31E0FF.l		; 22 FF E0 31 ; Jump to subroutine long $31E0FF.l [Writes: Stack Pointer] [Flow: call]
	rol $3F1B.w		; 2E 1B 3F ; Rotate left $3F1B.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $2B07.w,Y		; 19 07 2B ; OR accumulator with memory $2B07.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $2F3F1F.l,X		; 3F 1F 3F 2F ; AND accumulator with memory (long,X) $2F3F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $7A070F.l,X		; 1F 0F 07 7A ; Logical OR long $7A070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sbc ($D0.b)		; F2 D0 ; Subtract with carry (indirect) ($D0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $FE1C.w,X		; FE 1C FE ; Increment memory $FE1C.w,X [Reads: X Index] [Flags: NZ]
	cpy $04FE.w		; CC FE 04 ; Compare $04FE.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx $C0.b		; E4 C0 ; Compare $C0.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpy #$C600.w		; C0 00 C6 ; Compare #$C600.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $E2E6.w		; EE E6 E2 ; Increment $E2E6.w [Flags: NZ]
	and ($FA.b)		; 32 FA ; AND accumulator with memory (indirect) ($FA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $C0.b		; E4 C0 ; Compare $C0.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and $10861D.l		; 2F 1D 86 10 ; AND accumulator with memory (long) $10861D.l [Writes: Accumulator] [Flags: NZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$5F.b],Y		; 17 5F ; OR accumulator with memory (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $000F0C.l,X		; 3F 0C 0F 00 ; AND accumulator with memory (long,X) $000F0C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $1F113F.l		; 22 3F 11 1F ; Jump to subroutine long $1F113F.l [Writes: Stack Pointer] [Flow: call]
	and $0F3F7F.l,X		; 3F 7F 3F 0F ; AND accumulator with memory (long,X) $0F3F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	sbc $FBBC.w,X		; FD BC FB ; Subtract with carry $FBBC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc $FC1C.w,X		; FE 1C FC ; Increment memory $FC1C.w,X [Reads: X Index] [Flags: NZ]
	cpy #$22F8.w		; C0 F8 22 ; Compare #$22F8.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $E5.b,X		; F6 E5 ; Increment memory $E5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp $C5.b,S		; C3 C5 ; Compare accumulator (stack relative) $C5.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
.ACCU 8
.INDEX 8
	sep #$3C		; E2 3C
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $DF.b		; 64 DF ; Store zero to $DF.b
	bit $EF.b,X		; 34 EF ; Test bits $EF.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $1AEF18.l		; EF 18 EF 1A ; Subtract with carry (long) $1AEF18.l [Writes: Accumulator] [Flags: NCVZ]
	adc $221B13.l		; 6F 13 1B 22 ; Add with carry (long) $221B13.l [Writes: Accumulator] [Flags: NCVZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DF9FBF.l,X		; FF BF 9F DF ; Subtract with carry (long,X) $DF9FBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $1B7F.w,X		; DE 7F 1B ; Decrement memory $1B7F.w,X [Reads: X Index] [Flags: NZ]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inc $FED8.w,X		; FE D8 FE ; Increment memory $FED8.w,X [Reads: X Index] [Flags: NZ]
	bit $F6.b,X		; 34 F6 ; Test bits $F6.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpy $F83C.w		; CC 3C F8 ; Compare $F83C.w with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	jsl $FC0000.l		; 22 00 00 FC ; Jump to subroutine long $FC0000.l [Writes: Stack Pointer] [Flow: call]
	jsl $FC03FE.l		; 22 FE 03 FC ; Jump to subroutine long $FC03FE.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	stx $20.b		; 86 20 ; Store X register to $20.b [Reads: X Index]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $308400.l		; 22 00 84 30 ; Jump to subroutine long $308400.l [Writes: Stack Pointer] [Flow: call]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $4F8407.l		; 0F 07 84 4F ; OR accumulator with memory (long) $4F8407.l [Writes: Accumulator] [Flags: NZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($3B.b,S),Y		; 33 3B ; AND accumulator (stack relative indirect indexed) ($3B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03030F.l		; 0F 0F 03 03 ; OR accumulator with memory (long) $03030F.l [Writes: Accumulator] [Flags: NZ]
	jsl $640600.l		; 22 00 06 64 ; Jump to subroutine long $640600.l [Writes: Stack Pointer] [Flow: call]
	lsr $2D4C.w		; 4E 4C 2D ; Logical shift right $2D4C.w [Flags: NCZ]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	ora $E4.b,S		; 03 E4 ; OR accumulator with stack relative $E4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	sbc $002FE0.l,X		; FF E0 2F 00 ; Subtract with carry (long,X) $002FE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $57.b		; 00 57 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5B.b		; 00 5B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $676D.w		; 2C 6D 67 ; Test bits $676D.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $B0, $48		; B0 48 ; Branch if carry set to $B0, $48 [Flow: branch]
	bit $34.b		; 24 34 ; Test bits $34.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ldx $E6.b,Y		; B6 E6 ; Load X register $E6.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	jsl $010C00.l		; 22 00 0C 01 ; Jump to subroutine long $010C00.l [Writes: Stack Pointer] [Flow: call]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00627F.l		; 0F 7F 62 00 ; OR accumulator with memory (long) $00627F.l [Writes: Accumulator] [Flags: NZ]
	ora $0804.w		; 0D 04 08 ; Logical OR $0804.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	eor $057F00.l		; 4F 00 7F 05 ; Exclusive OR accumulator with memory (long) $057F00.l [Writes: Accumulator] [Flags: NZ]
	sbc $7EFF13.l,X		; FF 13 FF 7E ; Subtract with carry (long,X) $7EFF13.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF44CC.l,X		; FF CC 44 FF ; Subtract with carry (long,X) $FF44CC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	tsb $FFCE.w		; 0C CE FF ; Test and set bits $FFCE.w [Reads: Accumulator] [Flags: Z]
	.db $70, $85		; 70 85 ; Branch if overflow set to $70, $85 [Flow: branch]
	ora ($7F.b,S),Y		; 13 7F ; OR accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FF7F7F.l,X		; FF 7F 7F FF ; Subtract with carry (long,X) $FF7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($62.b,X)		; 01 62 ; Logical OR ($62.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	asl $150F.w		; 0E 0F 15 ; Arithmetic shift left $150F.w [Flags: NCZ]
	ora $513F29.l,X		; 1F 29 3F 51 ; Logical OR long $513F29.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $E00062.l,X		; 7F 62 00 E0 ; Add long $E00062.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $07		; 30 07 ; Branch if minus to $30, $07 [Flow: branch]
	ora $5F2F17.l		; 0F 17 2F 5F ; OR accumulator with memory (long) $5F2F17.l [Writes: Accumulator] [Flags: NZ]
	adc ($7F.b),Y		; 71 7F ; Add with carry ($7F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	sty $70FF.w		; 8C FF 70 ; Store Y register to $70FF.w [Reads: Y Index]
	sbc $87FF41.l,X		; FF 41 FF 87 ; Subtract with carry (long,X) $87FF41.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $10FF1E.l,X		; FF 1E FF 10 ; Subtract with carry (long,X) $10FF1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FC8C71.l,X		; FF 71 8C FC ; Subtract with carry (long,X) $FC8C71.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $C1		; F0 C1 ; Branch if equal to $F0, $C1 [Flow: branch]
	sta [$1F.b]		; 87 1F ; Store accumulator (long) [$1F.b] [Reads: Direct Page, Accumulator]
	ora $3F0003.l,X		; 1F 03 00 3F ; Logical OR long $3F0003.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($4F.b,X)		; 01 4F ; Logical OR ($4F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $4F		; 30 4F ; Branch if minus to $30, $4F [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sta $74BF78.l,X		; 9F 78 BF 74 ; Store accumulator (long,X) $74BF78.l,X [Reads: Accumulator, X Index]
	lda $BC67.w,X		; BD 67 BC ; Load $BC67.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $03.b,S		; 63 03 ; Add with carry (stack relative) $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $237D.w,Y		; 79 7D 23 ; Add $237D.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00C013.l,X		; FF 13 C0 00 ; Subtract with carry (long,X) $00C013.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($F280.w,X)		; FC 80 F2 ; Jump to subroutine indirect indexed ($F280.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $1CF2.w		; 0C F2 1C ; Test and set bits $1CF2.w [Reads: Accumulator] [Flags: Z]
	sbc $FD1E.w,Y		; F9 1E FD ; Subtract with carry $FD1E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $E6BD.w		; 2E BD E6 ; Rotate left $E6BD.w [Flags: NCZ]
	and $C0C6.w,X		; 3D C6 C0 ; AND accumulator with memory $C0C6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$BE9E]		; DC 9E BE ; Jump long indirect [$BE9E] [Flow: jump]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $38.b		; 05 38 ; Logical OR $38.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $8F		; 30 8F ; Branch if minus to $30, $8F [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta $98.b,S		; 83 98 ; Store accumulator (stack relative) $98.b,S [Reads: Stack Pointer, Accumulator]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $000060.l,X		; BF 60 00 00 ; Load long $000060.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $FFFDFD.l,X		; 7F FD FD FF ; Add long $FFFDFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $050023.l,X		; FF 23 00 05 ; Subtract with carry (long,X) $050023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $F200.w		; 1C 00 F2 ; Test and reset bits $F200.w [Reads: Accumulator] [Flags: Z]
	trb $1EF1.w		; 1C F1 1E ; Test and reset bits $1EF1.w [Reads: Accumulator] [Flags: Z]
	sta $B0.b,S		; 83 B0 ; Store accumulator (stack relative) $B0.b,S [Reads: Stack Pointer, Accumulator]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0006.w,X		; FD 06 00 ; Subtract with carry $0006.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $BFBF.w,X		; FE BF BF ; Increment memory $BFBF.w,X [Reads: X Index] [Flags: NZ]
	sbc $0007FF.l,X		; FF FF 07 00 ; Subtract with carry (long,X) $0007FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $03,$3F		; 44 3F 03 ; Move block positive $03,$3F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($17.b)		; 12 17 ; OR accumulator with memory (indirect) ($17.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $3C773B.l,X		; 7F 3B 77 3C ; Add long $3C773B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $DF5F.w,X		; FE 5F DF ; Increment memory $DF5F.w,X [Reads: X Index] [Flags: NZ]
	adc [$07.b]		; 67 07 ; Add with carry (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $7C383C.l,X		; 3F 3C 38 7C ; AND accumulator with memory (long,X) $7C383C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $E0FFFF.l,X		; 7F FF FF E0 ; Add long $E0FFFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($E0C0.w,X)		; FC C0 E0 ; Jump to subroutine indirect indexed ($E0C0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jmp.w [$AEC8]		; DC C8 AE ; Jump long indirect [$AEC8] [Flow: jump]
	stz $2CD6.w		; 9C D6 2C ; Store zero to $2CD6.w
	and $EE13C6.l,X		; 3F C6 13 EE ; AND accumulator with memory (long,X) $EE13C6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$FC.b		; E0 FC ; Compare #$FC.b with X register [Reads: X Index] [Flags: NCZ]
	bit $7E3C.w,X		; 3C 3C 7E ; Test bits $7E3C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	inc $EFC7.w		; EE C7 EF ; Increment $EFC7.w [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $033F01.l,X		; 3F 01 3F 03 ; AND accumulator with memory (long,X) $033F01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $031F00.l		; 0F 00 1F 03 ; OR accumulator with memory (long) $031F00.l [Writes: Accumulator] [Flags: NZ]
	and $3E771D.l,X		; 3F 1D 77 3E ; AND accumulator with memory (long,X) $3E771D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $075F.w,Y		; BE 5F 07 ; Load X register $075F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	and $1C0F3F.l,X		; 3F 3F 0F 1C ; AND accumulator with memory (long,X) $1C0F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $837F.w,X		; 3E 7F 83 ; Rotate left $837F.w,X [Reads: X Index] [Flags: NCZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $7C80.w,X		; 1E 80 7C ; Arithmetic shift left $7C80.w,X [Reads: X Index] [Flags: NCZ]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $4C		; 80 4C ; Branch always to $80, $4C [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	stx $6C.b,Y		; 96 6C ; Store X register $6C.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	and $FCE0C6.l,X		; 3F C6 E0 FC ; AND accumulator with memory (long,X) $FCE0C6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($78F0.w,X)		; FC F0 78 ; Jump to subroutine indirect indexed ($78F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($C7EE.w,X)		; FC EE C7 ; Jump to subroutine indirect indexed ($C7EE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $1E3D00.l,X		; 1F 00 3D 1E ; Logical OR long $1E3D00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	and $3A75.w,X		; 3D 75 3A ; AND accumulator with memory $3A75.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $FE4527.l,X		; 7F 27 45 FE ; Add long $FE4527.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $7F223F.l,X		; 1F 3F 22 7F ; Logical OR long $7F223F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $8008FF.l		; 22 FF 08 80 ; Jump to subroutine long $8008FF.l [Writes: Stack Pointer] [Flow: call]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E6		; 80 E6 ; Branch always to $80, $E6 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc $E0.b,X		; F6 E0 ; Increment memory $E0.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ldx $E043.w,Y		; BE 43 E0 ; Load X register $E043.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $D489E0.l,X		; FF E0 89 D4 ; Subtract with carry (long,X) $D489E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $C080B6.l,X		; 7F B6 80 C0 ; Add long $C080B6.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $F6.b		; E6 F6 ; Increment $F6.b [Reads: Direct Page] [Flags: NZ]
	inc $EFFF.w,X		; FE FF EF ; Increment memory $EFFF.w,X [Reads: X Index] [Flags: NZ]
	cmp $330021.l		; CF 21 00 33 ; Compare accumulator (long) $330021.l [Reads: Accumulator] [Flags: NCZ]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($26.b)		; 12 26 ; OR accumulator with memory (indirect) ($26.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $060F01.l,X		; 1F 01 0F 06 ; Logical OR long $060F01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $272F3F.l,X		; 3F 3F 2F 27 ; AND accumulator with memory (long,X) $272F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $03070F.l,X		; 1F 0F 07 03 ; Logical OR long $03070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	cpy $F400.w		; CC 00 F4 ; Compare $F400.w with Y register [Reads: Y Index] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	stz $D8.b		; 64 D8 ; Store zero to $D8.b
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $B0		; 80 B0 ; Branch always to $80, $B0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C0C0.w		; 20 C0 C0 ; Jump to subroutine at $C0C0.w [Writes: Stack Pointer] [Flow: call]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($E4F4.w,X)		; FC F4 E4 ; Jump to subroutine indirect indexed ($E4F4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpy #$08.b		; C0 08 ; Compare #$08.b with Y register [Reads: Y Index] [Flags: NCZ]
	adc $08FF18.l,X		; 7F 18 FF 08 ; Add long $08FF18.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $08FF28.l,X		; FF 28 FF 08 ; Subtract with carry (long,X) $08FF28.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $31FF58.l,X		; FF 58 FF 31 ; Subtract with carry (long,X) $31FF58.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $4FFF23.l,X		; FF 23 FF 4F ; Subtract with carry (long,X) $4FFF23.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0FAF8F.l,X		; 9F 8F AF 0F ; Store accumulator (long,X) $0FAF8F.l,X [Reads: Accumulator, X Index]
	eor $0F3F3F.l,X		; 5F 3F 3F 0F ; Exclusive OR accumulator with memory (long,X) $0F3F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F8FF09.l,X		; FF 09 FF F8 ; Subtract with carry (long,X) $F8FF09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $46FFC0.l,X		; FF C0 FF 46 ; Subtract with carry (long,X) $46FFC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C6FFE7.l,X		; FF E7 FF C6 ; Subtract with carry (long,X) $C6FFE7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFF1C.l,X		; FF 1C FF FF ; Subtract with carry (long,X) $FFFF1C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C0F8.w,Y		; F9 F8 C0 ; Subtract with carry $C0F8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $E7.b		; C6 E7 ; Decrement $E7.b [Reads: Direct Page] [Flags: NZ]
	cmp [$1F.b]		; C7 1F ; Compare accumulator (long) [$1F.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor ($7F.b),Y		; 51 7F ; Exclusive OR accumulator with memory ($7F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $B1FF.w,X		; 9E FF B1 ; Store zero to $B1FF.w,X [Reads: X Index]
	sbc $A1FFD1.l,X		; FF D1 FF A1 ; Subtract with carry (long,X) $A1FFD1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $CBFF43.l,X		; FF 43 FF CB ; Subtract with carry (long,X) $CBFF43.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $5FFFC1.l,X		; FF C1 FF 5F ; Subtract with carry (long,X) $5FFFC1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $F1B1.w,Y		; BE B1 F1 ; Load X register $F1B1.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc ($43.b,X)		; E1 43 ; Subtract with carry ($43.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc ($90.b),Y		; F1 90 ; Subtract with carry ($90.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F3FF11.l,X		; FF 11 FF F3 ; Subtract with carry (long,X) $F3FF11.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF4403.l,X		; FF 03 44 FF ; Subtract with carry (long,X) $FF4403.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $29E0.w,X		; 3E E0 29 ; Rotate left $29E0.w,X [Reads: X Index] [Flags: NCZ]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF1F9F.l,X		; FF 9F 1F FF ; Subtract with carry (long,X) $FF1F9F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F0FEFE.l,X		; FF FE FE F0 ; Subtract with carry (long,X) $F0FEFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $FE43.w,X		; FE 43 FE ; Increment memory $FE43.w,X [Reads: X Index] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	adc $25671D.l,X		; 7F 1D 67 25 ; Add long $25671D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$35.b],Y		; 77 35 ; Add with carry (long indexed) [$35.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $071F1E.l,X		; 3F 1E 1F 07 ; AND accumulator with memory (long,X) $071F1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $5B63F7.l,X		; FF F7 63 5B ; Subtract with carry (long,X) $5B63F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$7F		; C2 7F
	cmp ($EE.b)		; D2 EE ; Compare accumulator (indirect) ($EE.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor $CC.b,S		; 43 CC ; Exclusive OR accumulator with stack relative $CC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora ($B8.b)		; 12 B8 ; OR accumulator with memory (indirect) ($B8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $F4D6EF.l,X		; FF EF D6 F4 ; Subtract with carry (long,X) $F4D6EF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pea $30C8.w		; F4 C8 30 ; Push absolute address $30C8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpy #$43BF.w		; C0 BF 43 ; Compare #$43BF.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $FC47.w,X		; FD 47 FC ; Subtract with carry $FC47.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $17.b,S		; 43 17 ; Exclusive OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $31E0.w,X		; FE E0 31 ; Increment memory $31E0.w,X [Reads: X Index] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$35.b],Y		; 77 35 ; Add with carry (long indexed) [$35.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $000F0D.l,X		; 3F 0D 0F 00 ; AND accumulator with memory (long,X) $000F0D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $EFEFFF.l,X		; FF FF EF EF ; Subtract with carry (long,X) $EFEFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp [$4B.b]		; C7 4B ; Compare accumulator (long) [$4B.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($0F.b,S),Y		; 33 0F ; AND accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $BFC6.w,X		; FD C6 BF ; Subtract with carry $BFC6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
.INDEX 8
	sep #$3F		; E2 3F
	nop		; EA ; No operation
	adc $DC7FE8.l,X		; 7F E8 7F DC ; Add long $DC7FE8.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FCAC.w		; EE AC FC ; Increment $FCAC.w [Flags: NZ]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E3F7F7.l,X		; FF F7 F7 E3 ; Subtract with carry (long,X) $E3F7F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp ($CC.b)		; D2 CC ; Compare accumulator (indirect) ($CC.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $F0, $E7		; F0 E7 ; Branch if equal to $F0, $E7 [Flow: branch]
	eor $E764DF.l,X		; 5F DF 64 E7 ; Exclusive OR accumulator with memory (long,X) $E764DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $3B7F7C.l,X		; FF 7C 7F 3B ; Subtract with carry (long,X) $3B7F7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $3B7F.w		; 0E 7F 3B ; Arithmetic shift left $3B7F.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($FE.b,S),Y		; F3 FE ; Subtract with carry (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($3E.b,S),Y		; F3 3E ; Subtract with carry (stack relative indirect indexed) ($3E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($1E.b,S),Y		; F3 1E ; Subtract with carry (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$3E.b]		; E7 3E ; Subtract with carry (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $DCDC.w,X		; FE DC DC ; Increment memory $DCDC.w,X [Reads: X Index] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FE.b,S),Y		; 13 FE ; OR accumulator (stack relative indirect indexed) ($FE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$0000]		; DC 00 00 ; Jump long indirect [$0000] [Flow: jump]
	cld		; D8 ; Clear decimal flag [Flags: D]
	and $DF5FAF.l		; 2F AF 5F DF ; AND accumulator with memory (long) $DF5FAF.l [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sbc $70FF70.l		; EF 70 FF 70 ; Subtract with carry (long) $70FF70.l [Writes: Accumulator] [Flags: NCVZ]
	adc $073F38.l,X		; 7F 38 3F 07 ; Add long $073F38.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($7F.b,S),Y		; 13 7F ; OR accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $EE1307.l,X		; 3F 07 13 EE ; AND accumulator with memory (long,X) $EE1307.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FE.b,S		; E3 FE ; Subtract stack-relative $FE.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $0EFB.w,X		; 1E FB 0E ; Arithmetic shift left $0EFB.w,X [Reads: X Index] [Flags: NCZ]
	sbc $1CFE0E.l,X		; FF 0E FE 1C ; Subtract with carry (long,X) $1CFE0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($E0E0.w,X)		; FC E0 E0 ; Jump to subroutine indirect indexed ($E0E0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($45E0.w,X)		; FC E0 45 ; Jump to subroutine indirect indexed ($45E0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0943.w,X		; FE 43 09 ; Increment memory $0943.w,X [Reads: X Index] [Flags: NZ]
	adc $7C26.w,X		; 7D 26 7C ; Add $7C26.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $3F3F70.l,X		; 3F 70 3F 3F ; AND accumulator with memory (long,X) $3F3F70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $22001F.l,X		; 1F 1F 00 22 ; Logical OR long $22001F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7F7E1F.l,X		; FF 1F 7E 7F ; Subtract with carry (long,X) $7F7E1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $5B1F3F.l,X		; 7F 3F 1F 5B ; Add long $5B1F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stx $2F.b,Y		; 96 2F ; Store X register $2F.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	cpy $9F.b		; C4 9F ; Compare $9F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $B620.w,X		; DE 20 B6 ; Decrement memory $B620.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $C0.b		; E6 C0 ; Increment $C0.b [Reads: Direct Page] [Flags: NZ]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sbc $3E7FFF.l		; EF FF 7F 3E ; Subtract with carry (long) $3E7FFF.l [Writes: Accumulator] [Flags: NCVZ]
	ror $E6.b,X		; 76 E6 ; Rotate right $E6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0044.w		; 20 44 00 ; Jump to subroutine at $0044.w [Writes: Stack Pointer] [Flow: call]
	.db $70, $43		; 70 43 ; Branch if overflow set to $70, $43 [Flow: branch]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	asl $00B8.w		; 0E B8 00 ; Arithmetic shift left $00B8.w [Flags: NCZ]
	lda [$00.b],Y		; B7 00 ; Load accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $50		; 50 50 ; Branch if overflow clear to $50, $50 [Flow: branch]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp $0000.w		; CD 00 00 ; Compare $0000.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsb $44.b		; 04 44 ; Test and set bits $44.b [Reads: Accumulator] [Flags: Z]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0F.b,S		; 43 0F ; Exclusive OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $ED00.w,X		; 1D 00 ED ; OR accumulator with memory $ED00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora #$09.b		; 09 09 ; Logical OR #$09.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($B3.b,S),Y		; 13 B3 ; OR accumulator (stack relative indirect indexed) ($B3.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $60.b,S		; 83 60 ; Store accumulator (stack relative) $60.b,S [Reads: Stack Pointer, Accumulator]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $03.b		; 26 03 ; Rotate left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $2E1F1E.l		; 0F 1E 1F 2E ; OR accumulator with memory (long) $2E1F1E.l [Writes: Accumulator] [Flags: NZ]
	and $007F7E.l,X		; 3F 7E 7F 00 ; AND accumulator with memory (long,X) $007F7E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $707F2F.l,X		; 1F 2F 7F 70 ; Logical OR long $707F2F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $7DFF8F.l,X		; 7F 8F FF 7D ; Add long $7DFF8F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C0FFF0.l,X		; FF F0 FF C0 ; Subtract with carry (long,X) $C0FFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $38FF07.l,X		; FF 07 FF 38 ; Subtract with carry (long,X) $38FF07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $70FF20.l,X		; FF 20 FF 70 ; Subtract with carry (long,X) $70FF20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $FF227F.l		; 8F 7F 22 FF ; Store accumulator (long) $FF227F.l [Reads: Accumulator]
	ora ($F8.b,X)		; 01 F8 ; Logical OR ($F8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$23.b		; E0 23 ; Compare #$23.b with X register [Reads: X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $000707.l,X		; 3F 07 07 00 ; AND accumulator with memory (long,X) $000707.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3F1F1F.l		; 0F 1F 1F 3F ; OR accumulator with memory (long) $3F1F1F.l [Writes: Accumulator] [Flags: NZ]
	and $1D0023.l,X		; 3F 23 00 1D ; AND accumulator with memory (long,X) $1D0023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$98.b		; E0 98 ; Compare #$98.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $2C		; F0 2C ; Branch if equal to $F0, $2C [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	tsb $00F8.w		; 0C F8 00 ; Test and set bits $00F8.w [Reads: Accumulator] [Flags: Z]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp.w [$0FFC]		; DC FC 0F ; Jump long indirect [$0FFC] [Flow: jump]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $003F1C.l		; 2F 1C 3F 00 ; AND accumulator with memory (long) $003F1C.l [Writes: Accumulator] [Flags: NZ]
	adc [$2C.b],Y		; 77 2C ; Add with carry (long indexed) [$2C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $67.b,S		; 43 67 ; Exclusive OR accumulator with stack relative $67.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $2F05.w,X		; 1E 05 2F ; Arithmetic shift left $2F05.w,X [Reads: X Index] [Flags: NCZ]
	trb $1F0F.w		; 1C 0F 1F ; Test and reset bits $1F0F.w [Reads: Accumulator] [Flags: Z]
	and $E3833E.l,X		; 3F 3E 83 E3 ; AND accumulator with memory (long,X) $E3833E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F4		; 10 F4 ; Branch if plus to $10, $F4 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($EE00.w,X)		; FC 00 EE ; Jump to subroutine indirect indexed ($EE00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $78.b		; E6 78 ; Increment $78.b [Reads: Direct Page] [Flags: NZ]
	ora $F4.b		; 05 F4 ; Logical OR $F4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	jsr ($22FC.w,X)		; FC FC 22 ; Jump to subroutine indirect indexed ($22FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FC0E.w,X		; FE 0E FC ; Increment memory $FC0E.w,X [Reads: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1100.w		; 0E 00 11 ; Arithmetic shift left $1100.w [Flags: NCZ]
	asl $1E25.w		; 0E 25 1E ; Arithmetic shift left $1E25.w [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $2B55.w,X		; 1D 55 2B ; OR accumulator with memory $2B55.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $1B.b		; 26 1B ; Rotate left $1B.b [Reads: Direct Page] [Flags: NCZ]
	jsl $0E0500.l		; 22 00 05 0E ; Jump to subroutine long $0E0500.l [Writes: Stack Pointer] [Flow: call]
	ora $3B3D.w,X		; 1D 3D 3B ; OR accumulator with memory $3B3D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$26.b],Y		; 77 26 ; Add with carry (long indexed) [$26.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	asl $1908.w		; 0E 08 19 ; Arithmetic shift left $1908.w [Flags: NCZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $060400.l		; 22 00 04 06 ; Jump to subroutine long $060400.l [Writes: Stack Pointer] [Flow: call]
	asl $1F19.w		; 0E 19 1F ; Arithmetic shift left $1F19.w [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($62.b,X)		; 01 62 ; Logical OR ($62.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $C77F60.l,X		; 1F 60 7F C7 ; Logical OR long $C77F60.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $53.b		; 84 53 ; Store Y register to $53.b [Reads: Y Index]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $E0F8FF.l,X		; 7F FF F8 E0 ; Add long $E0F8FF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F1F00.l		; 0F 00 1F 0F ; OR accumulator with memory (long) $0F1F00.l [Writes: Accumulator] [Flags: NZ]
	and $431E.w,X		; 3D 1E 43 ; AND accumulator with memory $431E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $1F01.w,X		; 1D 01 1F ; OR accumulator with memory $1F01.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $3F221F.l		; 0F 1F 22 3F ; OR accumulator with memory (long) $3F221F.l [Writes: Accumulator] [Flags: NZ]
	trb $1F.b		; 14 1F ; Test and reset bits $1F.b [Reads: Accumulator] [Flags: Z]
	and $00C03F.l,X		; 3F 3F C0 00 ; AND accumulator with memory (long,X) $00C03F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	ror $FEB0.w,X		; 7E B0 FE ; Rotate right $FEB0.w,X [Reads: X Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	dec $FF70.w,X		; DE 70 FF ; Decrement memory $FF70.w,X [Reads: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $DEBFDE.l,X		; FF DE BF DE ; Subtract with carry (long,X) $DEBFDE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsl $F70EFE.l		; 22 FE 0E F7 ; Jump to subroutine long $F70EFE.l [Writes: Stack Pointer] [Flow: call]
	sbc $E3.b,S		; E3 E3 ; Subtract stack-relative $E3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	eor $004301.l,X		; 5F 01 43 00 ; Exclusive OR accumulator with memory (long,X) $004301.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $1B2712.l		; 2F 12 27 1B ; AND accumulator with memory (long) $1B2712.l [Writes: Accumulator] [Flags: NZ]
	ora $8C8304.l,X		; 1F 04 83 8C ; Logical OR long $8C8304.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $7F.b		; 65 7F ; Add $7F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $91.b,S		; 83 91 ; Store accumulator (stack relative) $91.b,S [Reads: Stack Pointer, Accumulator]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $80, $C2		; 80 C2 ; Branch always to $80, $C2 [Flow: branch]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	bit $D8.b		; 24 D8 ; Test bits $D8.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr $C0A0.w		; 20 A0 C0 ; Jump to subroutine at $C0A0.w [Writes: Stack Pointer] [Flow: call]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	ldx $FE.b		; A6 FE ; Load $FE.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sta $A9.b,S		; 83 A9 ; Store accumulator (stack relative) $A9.b,S [Reads: Stack Pointer, Accumulator]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $C0E0.w,X		; 3C E0 C0 ; Test bits $C0E0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $50, $7F		; 50 7F ; Branch if overflow clear to $50, $7F [Flow: branch]
	.db $B0, $FF		; B0 FF ; Branch if carry set to $B0, $FF [Flow: branch]
	lda ($FF.b),Y		; B1 FF ; Load accumulator ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($FF.b)		; B2 FF ; Load accumulator (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $FF.b		; 64 FF ; Store zero to $FF.b
	adc $FF.b		; 65 FF ; Add $FF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvp $42,$FF		; 44 FF 42 ; Move block positive $42,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $BFBF5F.l,X		; FF 5F BF BF ; Subtract with carry (long,X) $BFBF5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $7D7C.w,Y		; BE 7C 7D ; Load X register $7D7C.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jmp ($437E.w,X)		; 7C 7E 43 ; Jump indirect indexed to ($437E.w,X) [Reads: X Index] [Flow: jump]
	sbc $C8FF4D.l,X		; FF 4D FF C8 ; Subtract with carry (long,X) $C8FF4D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $71FF08.l,X		; FF 08 FF 71 ; Subtract with carry (long,X) $71FF08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $41FF81.l,X		; FF 81 FF 41 ; Subtract with carry (long,X) $41FF81.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C3FF27.l,X		; FF 27 FF C3 ; Subtract with carry (long,X) $C3FF27.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $7F0FCF.l		; CF CF 0F 7F ; Compare accumulator (long) $7F0FCF.l [Reads: Accumulator] [Flags: NCZ]
	sbc $3F3F7F.l,X		; FF 7F 3F 3F ; Subtract with carry (long,X) $3F3F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $DB.b,S		; 83 DB ; Store accumulator (stack relative) $DB.b,S [Reads: Stack Pointer, Accumulator]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $000003.l		; 0F 03 00 00 ; OR accumulator with memory (long) $000003.l [Writes: Accumulator] [Flags: NZ]
	stz $FCF8.w		; 9C F8 FC ; Store zero to $FCF8.w
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: NCZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsr ($F8FC.w,X)		; FC FC F8 ; Jump to subroutine indirect indexed ($F8FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $2A7E19.l		; 2F 19 7E 2A ; AND accumulator with memory (long) $2A7E19.l [Writes: Accumulator] [Flags: NZ]
	eor $7C.b,S		; 43 7C ; Exclusive OR accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $3C		; 10 3C ; Branch if plus to $10, $3C [Flow: branch]
	trb $1C83.w		; 1C 83 1C ; Test and reset bits $1C83.w [Reads: Accumulator] [Flags: Z]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $5F5D.w,X		; 3E 5D 5F ; Rotate left $5F5D.w,X [Reads: X Index] [Flags: NCZ]
	eor $18232F.l,X		; 5F 2F 23 18 ; Exclusive OR accumulator with memory (long,X) $18232F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$F4.b]		; 07 F4 ; OR accumulator with memory (long) [$F4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($43D0.w,X)		; FC D0 43 ; Jump to subroutine indirect indexed ($43D0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp ($0350.w,X)		; 7C 50 03 ; Jump indirect indexed to ($0350.w,X) [Reads: X Index] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$F8.b		; E0 F8 ; Compare #$F8.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $83		; F0 83 ; Branch if equal to $F0, $83 [Flow: branch]
	bit $02.b,X		; 34 02 ; Test bits $02.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpx #$31.b		; E0 31 ; Compare #$31.b with X register [Reads: X Index] [Flags: NCZ]
	jmp ($BC3C.w,X)		; 7C 3C BC ; Jump indirect indexed to ($BC3C.w,X) [Reads: X Index] [Flow: jump]
	ldy $0818.w,X		; BC 18 08 ; Load Y register $0818.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $3907.w		; 0E 07 39 ; Arithmetic shift left $3907.w [Flags: NCZ]
	asl $2C53.w		; 0E 53 2C ; Arithmetic shift left $2C53.w [Flags: NCZ]
	sty $B973.w		; 8C 73 B9 ; Store Y register to $B973.w [Reads: Y Index]
	adc [$66.b],Y		; 77 66 ; Add with carry (long indexed) [$66.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($01.b),Y		; 31 01 ; AND accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $FFFF7F.l,X		; 3F 7F FF FF ; AND accumulator with memory (long,X) $FFFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $251F11.l		; 0F 11 1F 25 ; OR accumulator with memory (long) $251F11.l [Writes: Accumulator] [Flags: NZ]
	and $5A7F07.l,X		; 3F 07 7F 5A ; AND accumulator with memory (long,X) $5A7F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $9AFF69.l,X		; 7F 69 FF 9A ; Add long $9AFF69.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $830F03.l,X		; FF 03 0F 83 ; Subtract with carry (long,X) $830F03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $0443FE.l,X		; FF FE 43 04 ; Subtract with carry (long,X) $0443FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $450F09.l		; 0F 09 0F 45 ; OR accumulator with memory (long) $450F09.l [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b)		; 12 1F ; OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F0707.l,X		; 1F 07 07 0F ; Logical OR long $0F0707.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $001E22.l		; 0F 22 1E 00 ; OR accumulator with memory (long) $001E22.l [Writes: Accumulator] [Flags: NZ]
	ora $04C897.l,X		; 1F 97 C8 04 ; Logical OR long $04C897.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1F0A11.l,X		; 3F 11 0A 1F ; AND accumulator with memory (long,X) $1F0A11.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and [$1F.b],Y		; 37 1F ; AND accumulator with memory (long indexed) [$1F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $1F		; 30 1F ; Branch if minus to $30, $1F [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $0F0F1F.l,X		; 1F 1F 0F 0F ; Logical OR long $0F0F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $EF.b,S		; 83 EF ; Store accumulator (stack relative) $EF.b,S [Reads: Stack Pointer, Accumulator]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	and $0F1F0C.l,X		; 3F 0C 1F 0F ; AND accumulator with memory (long,X) $0F1F0C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $CE2FDE.l,X		; 3F DE 2F CE ; AND accumulator with memory (long,X) $CE2FDE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$A0.b],Y		; 57 A0 ; Exclusive OR accumulator with memory (long indexed) [$A0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $5E10.w		; EE 10 5E ; Increment $5E10.w [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ror $3384.w,X		; 7E 84 33 ; Rotate right $3384.w,X [Reads: X Index] [Flags: NCZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $F3.b,S		; E3 F3 ; Subtract stack-relative $F3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda $FEBE1E.l,X		; BF 1E BE FE ; Load long $FEBE1E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	sbc $0A0023.l,X		; FF 23 00 0A ; Subtract with carry (long,X) $0A0023.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $041D00.l		; 22 00 1D 04 ; Jump to subroutine long $041D00.l [Writes: Stack Pointer] [Flow: call]
	asl $0E0F.w		; 0E 0F 0E ; Arithmetic shift left $0E0F.w [Flags: NCZ]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	dec $09.b,X		; D6 09 ; Decrement memory $09.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp [$CF.b]		; C7 CF ; Compare accumulator (long) [$CF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $717EBC.l,X		; 3F BC 7E 71 ; AND accumulator with memory (long,X) $717EBC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($1000.w,X)		; FC 00 10 ; Jump to subroutine indirect indexed ($1000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $FBDE.w,Y		; 39 DE FB ; AND accumulator with memory $FBDE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $837EBF.l		; CF BF 7E 83 ; Compare accumulator (long) $837EBF.l [Reads: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	brk $6D.b		; 00 6D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($DD.b)		; 92 DD ; Store accumulator (indirect) ($DD.b) [Reads: Direct Page, Accumulator]
.ACCU 8
.INDEX 8
	sep #$F2		; E2 F2
	jsr ($7E3D.w,X)		; FC 3D 7E ; Jump to subroutine indirect indexed ($7E3D.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stx $003F.w		; 8E 3F 00 ; Store X register to $003F.w [Reads: X Index]
	.db $10, $BA		; 10 BA ; Branch if plus to $10, $BA [Flow: branch]
	adc $FDF2DF.l,X		; 7F DF F2 FD ; Add long $FDF2DF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $0027.w,X		; 7E 27 00 ; Rotate right $0027.w,X [Reads: X Index] [Flags: NCZ]
	asl $38.b		; 06 38 ; Arithmetic shift left $38.b [Reads: Direct Page] [Flags: NCZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $BA		; 30 BA ; Branch if minus to $30, $BA [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $24.b		; E5 24 ; Subtract $24.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($E7FA.w,X)		; 7C FA E7 ; Jump indirect indexed to ($E7FA.w,X) [Reads: X Index] [Flow: jump]
	and $0000.w		; 2D 00 00 ; Logical AND $0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $27.b		; 02 27 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $47.b		; 04 47 ; Test and set bits $47.b [Reads: Accumulator] [Flags: Z]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$22.b]		; 47 22 ; Exclusive OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $470E.w		; 1C 0E 47 ; Test and reset bits $470E.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $50, $04		; 50 04 ; Branch if overflow clear to $50, $04 [Flow: branch]
	jsr $00E4.w		; 20 E4 00 ; Jump to subroutine at $00E4.w [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpx $22.b		; E4 22 ; Compare $22.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7070.w		; 20 70 70 ; Jump to subroutine at $7070.w [Writes: Stack Pointer] [Flow: call]
	cpx $1E.b		; E4 1E ; Compare $1E.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: NCZ]
	jsl $225500.l		; 22 00 55 22 ; Jump to subroutine long $225500.l [Writes: Stack Pointer] [Flow: call]
	rol $5911.w		; 2E 11 59 ; Rotate left $5911.w [Flags: NCZ]
	ora [$B6.b]		; 07 B6 ; OR accumulator with memory (long) [$B6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $2A1F69.l		; 4F 69 1F 2A ; Exclusive OR accumulator with memory (long) $2A1F69.l [Writes: Accumulator] [Flags: NZ]
	asl $3C55.w,X		; 1E 55 3C ; Arithmetic shift left $3C55.w,X [Reads: X Index] [Flags: NCZ]
	jsl $593E77.l		; 22 77 3E 59 ; Jump to subroutine long $593E77.l [Writes: Stack Pointer] [Flow: call]
	sbc [$6E.b],Y		; F7 6E ; Subtract with carry (long indexed) [$6E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $205A.w		; 2D 5A 20 ; Logical AND $205A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8C72.w		; 20 72 8C ; Jump to subroutine at $8C72.w [Writes: Stack Pointer] [Flow: call]
	stz $68E0.w		; 9C E0 68 ; Store zero to $68E0.w
	.db $F0, $94		; F0 94 ; Branch if equal to $F0, $94 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	mvn $AA,$78		; 54 78 AA ; Move block negative $AA,$78 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $FC20.w,X		; 3C 20 FC ; Test bits $FC20.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ror $E89C.w,X		; 7E 9C E8 ; Rotate right $E89C.w,X [Reads: X Index] [Flags: NCZ]
	ror $B4.b,X		; 76 B4 ; Rotate right $B4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1E03.w		; 0E 03 1E ; Arithmetic shift left $1E03.w [Flags: NCZ]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $080026.l		; 0F 26 00 08 ; OR accumulator with memory (long) $080026.l [Writes: Accumulator] [Flags: NZ]
	cpy #$80.b		; C0 80 ; Compare #$80.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	.db $70, $C0		; 70 C0 ; Branch if overflow set to $70, $C0 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $80, $D8		; 80 D8 ; Branch always to $80, $D8 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $1303.w		; 0C 03 13 ; Test and set bits $1303.w [Reads: Accumulator] [Flags: Z]
	ora $290F14.l		; 0F 14 0F 29 ; OR accumulator with memory (long) $290F14.l [Writes: Accumulator] [Flags: NZ]
	asl $1C2B.w,X		; 1E 2B 1C ; Arithmetic shift left $1C2B.w,X [Reads: X Index] [Flags: NCZ]
	and $01FE00.l,X		; 3F 00 FE 01 ; AND accumulator with memory (long,X) $01FE00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($17.b,S),Y		; 13 17 ; OR accumulator (stack relative indirect indexed) ($17.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $3F2C.w		; 2E 2C 3F ; Rotate left $3F2C.w [Flags: NCZ]
	sbc $008043.l,X		; FF 43 80 00 ; Subtract with carry (long,X) $008043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($F0.b,S),Y		; 13 F0 ; OR accumulator (stack relative indirect indexed) ($F0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $F2		; 30 F2 ; Branch if minus to $30, $F2 [Flow: branch]
	bit $3CCA.w,X		; 3C CA 3C ; Test bits $3CCA.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $1E.b		; E5 1E ; Subtract $1E.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8E.b,X		; F5 8E ; Subtract $8E.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	.db $F0, $CC		; F0 CC ; Branch if equal to $F0, $CC [Flow: branch]
	sbc ($FA.b)		; F2 FA ; Subtract with carry (indirect) ($FA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $E4CD.w,X		; DD CD E4 ; Compare accumulator $E4CD.w,X [Reads: X Index] [Flags: NCZ]
	and $23E000.l		; 2F 00 E0 23 ; AND accumulator with memory (long) $23E000.l [Writes: Accumulator] [Flags: NZ]
	asl $09.b,X		; 16 09 ; Arithmetic shift left $09.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $2F03.w,X		; 1D 03 2F ; OR accumulator with memory $2F03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($5B.b,S),Y		; 13 5B ; OR accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$B6.b]		; 27 B6 ; AND accumulator with memory (long) [$B6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $5C0FB6.l		; 4F B6 0F 5C ; Exclusive OR accumulator with memory (long) $5C0FB6.l [Writes: Accumulator] [Flags: NZ]
	ora $1E1F2C.l		; 0F 2C 1F 1E ; OR accumulator with memory (long) $1E1F2C.l [Writes: Accumulator] [Flags: NZ]
	ora $7B3F.w,X		; 1D 3F 7B ; OR accumulator with memory $7B3F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$F7.b],Y		; F7 F7 ; Subtract with carry (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $F8C32F.l,X		; 5F 2F C3 F8 ; Exclusive OR accumulator with memory (long,X) $F8C32F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $3EFC.w,X		; 1D FC 3E ; OR accumulator with memory $3EFC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FC7C.w,X		; FE 7C FC ; Increment memory $FC7C.w,X [Reads: X Index] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $F7.b,S		; 43 F7 ; Exclusive OR accumulator with stack relative $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $13		; F0 13 ; Branch if equal to $F0, $13 [Flow: branch]
	jsr ($E2F4.w,X)		; FC F4 E2 ; Jump to subroutine indirect indexed ($E2F4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp ($83.b,X)		; C1 83 ; Compare accumulator ($83.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sty $08.b		; 84 08 ; Store Y register to $08.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $1F.b,S		; C3 1F ; Compare accumulator (stack relative) $1F.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp ($1F.b),Y		; D1 1F ; Compare accumulator ($1F.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	and $3E7F7C.l,X		; 3F 7C 7F 3E ; AND accumulator with memory (long,X) $3E7F7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $431FDE.l,X		; 3F DE 1F 43 ; AND accumulator with memory (long,X) $431FDE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $3F0F0F.l		; EF 0F 0F 3F ; Subtract with carry (long) $3F0F0F.l [Writes: Accumulator] [Flags: NCVZ]
	and $C18347.l		; 2F 47 83 C1 ; AND accumulator with memory (long) $C18347.l [Writes: Accumulator] [Flags: NZ]
	and ($10.b,X)		; 21 10 ; Logical AND ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $55		; 10 55 ; Branch if plus to $10, $55 [Flow: branch]
	ldx #$AA.b		; A2 AA ; Load #$AA.b into X register [Writes: X Index] [Flags: NZ]
	cpy $F4.b		; C4 F4 ; Compare $F4.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpx #$43.b		; E0 43 ; Compare #$43.b with X register [Reads: X Index] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	adc $3A.b,S		; 63 3A ; Add with carry (stack relative) $3A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $35		; F0 35 ; Branch if equal to $F0, $35 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$AE.b],Y		; 77 AE ; Add with carry (long indexed) [$AE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($E8D8.w,X)		; FC D8 E8 ; Jump to subroutine indirect indexed ($E8D8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc [$05.b],Y		; F7 05 ; Subtract with carry (long indexed) [$05.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	asl $63.b		; 06 63 ; Arithmetic shift left $63.b [Reads: Direct Page] [Flags: NCZ]
	ora $B13E5E.l,X		; 1F 5E 3E B1 ; Logical OR long $B13E5E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($FC61.w,X)		; 7C 61 FC ; Jump indirect indexed to ($FC61.w,X) [Reads: X Index] [Flow: jump]
	lsr $FE.b		; 46 FE ; Logical shift right $FE.b [Reads: Direct Page] [Flags: NCZ]
	lsr $9DFE.w		; 4E FE 9D ; Logical shift right $9DFE.w [Flags: NCZ]
	jsr ($F89B.w,X)		; FC 9B F8 ; Jump to subroutine indirect indexed ($F89B.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $5F.b,S		; 63 5F ; Add with carry (stack relative) $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ldx $797E.w,Y		; BE 7E 79 ; Load X register $797E.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc ($E2.b),Y		; 71 E2 ; Add with carry ($E2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $C4.b		; E4 C4 ; Compare $C4.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jmp ($3E8D.w,X)		; 7C 8D 3E ; Jump indirect indexed to ($3E8D.w,X) [Reads: X Index] [Flow: jump]
	stx $3F.b		; 86 3F ; Store X register to $3F.b [Reads: X Index]
	.db $62, $7F, $72		; 62 7F 72 ; Push effective relative address $62, $7F, $72 [Writes: Stack Pointer]
	adc $D93FB9.l,X		; 7F B9 3F D9 ; Add long $D93FB9.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $7DFAC4.l,X		; 1F C4 FA 7D ; Logical OR long $7DFAC4.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $8E9E.w,X		; 7E 9E 8E ; Rotate right $8E9E.w,X [Reads: X Index] [Flags: NCZ]
	eor [$27.b]		; 47 27 ; Exclusive OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsr $D0C0.w		; 20 C0 D0 ; Jump to subroutine at $D0C0.w [Writes: Stack Pointer] [Flow: call]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$70.b		; A0 70 ; Load #$70.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $68		; 80 68 ; Branch always to $80, $68 [Flow: branch]
	.db $80, $83		; 80 83 ; Branch always to $80, $83 [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $70A0.w,X		; 3D A0 70 ; AND accumulator with memory $70A0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	eor $3C.b,X		; 55 3C ; Exclusive OR accumulator with memory $3C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $1F29.w,X		; 1E 29 1F ; Arithmetic shift left $1F29.w,X [Reads: X Index] [Flags: NCZ]
	lsr $2F.b,X		; 56 2F ; Logical shift right $2F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $B647.w,Y		; B9 47 B6 ; Load $B647.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$69.b		; 09 69 ; Logical OR #$69.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $772E.w		; 2D 2E 77 ; Logical AND $772E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $79FE.w,Y		; F9 FE 79 ; Subtract with carry $79FE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $AA		; 10 AA ; Branch if plus to $10, $AA [Flow: branch]
	bit $7855.w,X		; 3C 55 78 ; Test bits $7855.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sta $FA.b,X		; 95 FA ; Store accumulator to $FA.b,X [Reads: Accumulator, X Index]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pea $E09C.w		; F4 9C E0 ; Push absolute address $E09C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	stz $98.b		; 64 98 ; Store zero to $98.b
	clv		; B8 ; Clear overflow flag [Flags: V]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$77.b],Y		; B7 77 ; Load accumulator (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $7C9C.w		; EE 9C 7C ; Increment $7C9C.w [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cop $19.b		; 02 19 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0307.w		; 0E 07 03 ; Arithmetic shift left $0307.w [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $18		; 80 18 ; Branch always to $80, $18 [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $B0.b,S		; 03 B0 ; OR accumulator with stack relative $B0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	cpy #$23.b		; C0 23 ; Compare #$23.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $78A771.l		; AF 71 A7 78 ; Load long $78A771.l into accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($3C.b,S),Y		; 53 3C ; XOR accumulator (stack relative indirect indexed) ($3C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $0C333C.l		; 4F 3C 33 0C ; Exclusive OR accumulator with memory (long) $0C333C.l [Writes: Accumulator] [Flags: NZ]
	ora $010044.l		; 0F 44 00 01 ; OR accumulator with memory (long) $010044.l [Writes: Accumulator] [Flags: NZ]
	ora $5FBBB3.l,X		; 1F B3 BB 5F ; Logical OR long $5FBBB3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $010F33.l		; 4F 33 0F 01 ; Exclusive OR accumulator with memory (long) $010F33.l [Writes: Accumulator] [Flags: NZ]
	ora ($7F.b,X)		; 01 7F ; Logical OR ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sty $78.b,X		; 94 78 ; Store Y register $78.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $F0, $C8		; F0 C8 ; Branch if equal to $F0, $C8 [Flow: branch]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($7434.w,X)		; FC 34 74 ; Jump to subroutine indirect indexed ($7434.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	cpx $2F.b		; E4 2F ; Compare $2F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $5C1F.w		; 2C 1F 5C ; Test bits $5C1F.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $018883.l		; 2F 83 88 01 ; AND accumulator with memory (long) $018883.l [Writes: Accumulator] [Flags: NZ]
	ora $2F075B.l		; 0F 5B 07 2F ; OR accumulator with memory (long) $2F075B.l [Writes: Accumulator] [Flags: NZ]
	ora ($55.b,S),Y		; 13 55 ; OR accumulator (stack relative indirect indexed) ($55.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $09.b,X		; 36 09 ; Rotate left $09.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $F7F77F.l		; 2F 7F F7 F7 ; AND accumulator with memory (long) $F7F77F.l [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	and $433E7D.l,X		; 3F 7D 3E 43 ; AND accumulator with memory (long,X) $433E7D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$F0.b],Y		; F7 F0 ; Subtract with carry (long indexed) [$F0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($7B.b,S),Y		; 13 7B ; OR accumulator (stack relative indirect indexed) ($7B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp ($3FFC.w,X)		; 7C FC 3F ; Jump indirect indexed to ($3FFC.w,X) [Reads: X Index] [Flow: jump]
	sbc $8FFF1F.l,X		; FF 1F FF 8F ; Subtract with carry (long,X) $8FFF1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $08FFC3.l,X		; FF C3 FF 08 ; Subtract with carry (long,X) $08FFC3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $83.b		; 84 83 ; Store Y register to $83.b [Reads: Y Index]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	eor $EF.b,S		; 43 EF ; Exclusive OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $DE32E0.l		; 0F E0 32 DE ; OR accumulator with memory (long) $DE32E0.l [Writes: Accumulator] [Flags: NZ]
	ora $FC3F3E.l,X		; 1F 3E 3F FC ; Logical OR long $FC3F3E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F1FFF8.l,X		; FF F8 FF F1 ; Subtract with carry (long,X) $F1FFF8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $10FFC3.l,X		; FF C3 FF 10 ; Subtract with carry (long,X) $10FFC3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $21		; 10 21 ; Branch if plus to $10, $21 [Flow: branch]
	cmp ($03.b,X)		; C1 03 ; Compare accumulator ($03.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $3AFA35.l,X		; 3F 35 FA 3A ; AND accumulator with memory (long,X) $3AFA35.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pea $F06C.w		; F4 6C F0 ; Push absolute address $F06C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $F0, $DC		; F0 DC ; Branch if equal to $F0, $DC [Flow: branch]
	cpx #$F2.b		; E0 F2 ; Compare #$F2.b with X register [Reads: X Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ldy $70D0.w		; AC D0 70 ; Load $70D0.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $F7		; 80 F7 ; Branch always to $80, $F7 [Flow: branch]
	inc $E8EC.w,X		; FE EC E8 ; Increment memory $E8EC.w,X [Reads: X Index] [Flags: NZ]
	jmp.w [$BCFE]		; DC FE BC ; Jump long indirect [$BCFE] [Flow: jump]
	.db $70, $0A		; 70 0A ; Branch if overflow set to $70, $0A [Flow: branch]
	ora $16.b		; 05 16 ; Logical OR $16.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $E1.b,S		; 83 E1 ; Store accumulator (stack relative) $E1.b,S [Reads: Stack Pointer, Accumulator]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $0100.w,X		; 3E 00 01 ; Rotate left $0100.w,X [Reads: X Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $030A.w,X		; 1E 0A 03 ; Arithmetic shift left $030A.w,X [Reads: X Index] [Flags: NCZ]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $4EFC.w,X		; 9D FC 4E ; Store accumulator to $4EFC.w,X [Reads: Accumulator, X Index]
	inc $FF47.w,X		; FE 47 FF ; Increment memory $FF47.w,X [Reads: X Index] [Flags: NZ]
	adc $FF.b,S		; 63 FF ; Add with carry (stack relative) $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $7F		; B0 7F ; Branch if carry set to $B0, $7F [Flow: branch]
	jmp $1FA3BF.l		; 5C BF A3 1F ; Jump long to $1FA3BF.l [Flow: jump]
	cpx $E2.b		; E4 E2 ; Compare $E2.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($78.b),Y		; 71 78 ; Add with carry ($78.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($DFBF.w,X)		; 7C BF DF ; Jump indirect indexed to ($DFBF.w,X) [Reads: X Index] [Flow: jump]
	lda $D9.b,S		; A3 D9 ; Load accumulator (stack relative) $D9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $723FB9.l,X		; 1F B9 3F 72 ; Logical OR long $723FB9.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $C6FFE2.l,X		; 7F E2 FF C6 ; Add long $C6FFE2.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3AFE0D.l,X		; FF 0D FE 3A ; Subtract with carry (long,X) $3AFE0D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8C5.w,X		; FD C5 F8 ; Subtract with carry $F8C5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$47.b]		; 27 47 ; AND accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $3E1E.w		; 8E 1E 3E ; Store X register to $3E1E.w [Reads: X Index]
	sbc $C5FB.w,X		; FD FB C5 ; Subtract with carry $C5FB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $A0		; 50 A0 ; Branch if overflow clear to $50, $A0 [Flow: branch]
	eor $60.b,S		; 43 60 ; Exclusive OR accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	ldy #$83.b		; A0 83 ; Load #$83.b into Y register [Writes: Y Index] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $A0		; F0 A0 ; Branch if equal to $F0, $A0 [Flow: branch]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$26.b		; C0 26 ; Compare #$26.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $1801.w		; 0C 01 18 ; Test and set bits $1801.w [Reads: Accumulator] [Flags: Z]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $0026.w		; 0C 26 00 ; Test and set bits $0026.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	.db $30, $80		; 30 80 ; Branch if minus to $30, $80 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $80, $78		; 80 78 ; Branch always to $80, $78 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: NCZ]
	.db $70, $26		; 70 26 ; Branch if overflow set to $70, $26 [Flow: branch]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$03.b]		; C7 03 ; Compare accumulator (long) [$03.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0023.w,Y		; 19 23 00 ; OR accumulator with memory $0023.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0026.w		; 0D 26 00 ; Logical OR $0026.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $DF.b,S		; 83 DF ; Store accumulator (stack relative) $DF.b,S [Reads: Stack Pointer, Accumulator]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $70, $60		; 70 60 ; Branch if overflow set to $70, $60 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $98		; F0 98 ; Branch if equal to $F0, $98 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $1C.b,S		; 83 1C ; Store accumulator (stack relative) $1C.b,S [Reads: Stack Pointer, Accumulator]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$03.b],Y		; F7 03 ; Subtract with carry (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $04.b,S		; 83 04 ; Store accumulator (stack relative) $04.b,S [Reads: Stack Pointer, Accumulator]
	tsb $26.b		; 04 26 ; Test and set bits $26.b [Reads: Accumulator] [Flags: Z]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $400103.l,X		; DF 03 01 40 ; Compare accumulator (long,X) $400103.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$70.b		; E0 70 ; Compare #$70.b with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $E4		; B0 E4 ; Branch if carry set to $B0, $E4 [Flow: branch]
	and $0B0800.l		; 2F 00 08 0B ; AND accumulator with memory (long) $0B0800.l [Writes: Accumulator] [Flags: NZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $001D.w		; 0C 1D 00 ; Test and set bits $001D.w [Reads: Accumulator] [Flags: Z]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $011D3E.l,X		; 1F 3E 1D 01 ; Logical OR long $011D3E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $700C00.l		; 22 00 0C 70 ; Jump to subroutine long $700C00.l [Writes: Stack Pointer] [Flow: call]
	sbc $CF7FBC.l,X		; FF BC 7F CF ; Subtract with carry (long,X) $CF7FBC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $6E8F73.l,X		; 3F 73 8F 6E ; AND accumulator with memory (long,X) $6E8F73.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($D1.b),Y		; 91 D1 ; Store accumulator ($D1.b),Y [Reads: Direct Page, Y Index, Accumulator]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $7F1400.l		; 22 00 14 7F ; Jump to subroutine long $7F1400.l [Writes: Stack Pointer] [Flow: call]
	lda $FEF3CF.l,X		; BF CF F3 FE ; Load long $FEF3CF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($20.b),Y		; F1 20 ; Subtract with carry ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $F3FE3D.l,X		; FF 3D FE F3 ; Subtract with carry (long,X) $F3FE3D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($F1CE.w,X)		; FC CE F1 ; Jump to subroutine indirect indexed ($F1CE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $88.b,X		; 75 88 ; Add $88.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $00.b,X		; 94 00 ; Store Y register $00.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $FE1200.l		; 22 00 12 FE ; Jump to subroutine long $FE1200.l [Writes: Stack Pointer] [Flow: call]
	sbc $CFF3.w,X		; FD F3 CF ; Subtract with carry $CFF3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $089C.w,X		; 7D 9C 08 ; Add $089C.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	.db $50, $A0		; 50 A0 ; Branch if overflow clear to $50, $A0 [Flow: branch]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	jsr $0024.w		; 20 24 00 ; Jump to subroutine at $0024.w [Writes: Stack Pointer] [Flow: call]
	ora ($C0.b,X)		; 01 C0 ; Logical OR ($C0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	jsr $6C83.w		; 20 83 6C ; Jump to subroutine at $6C83.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2C.b,X)		; 01 2C ; Logical OR ($2C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora [$57.b]		; 07 57 ; OR accumulator with memory (long) [$57.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $042A.w		; 20 2A 04 ; Jump to subroutine at $042A.w [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $B8.b		; 04 B8 ; Test and set bits $B8.b [Reads: Accumulator] [Flags: Z]
	adc [$2E.b],Y		; 77 2E ; Add with carry (long indexed) [$2E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $2204.w		; 0E 04 22 ; Arithmetic shift left $2204.w [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpx $F4.b		; E4 F4 ; Compare $F4.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0028.w		; 20 28 00 ; Jump to subroutine at $0028.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $26		; 10 26 ; Branch if plus to $10, $26 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $70F4.w,X		; 1E F4 70 ; Arithmetic shift left $70F4.w,X [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $3A		; 10 3A ; Branch if plus to $10, $3A [Flow: branch]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $76.b,S		; 83 76 ; Store accumulator (stack relative) $76.b,S [Reads: Stack Pointer, Accumulator]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $070F.w		; 0C 0F 07 ; Test and set bits $070F.w [Reads: Accumulator] [Flags: Z]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $E0.b		; 05 E0 ; Logical OR $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $40		; 90 40 ; Branch if carry clear to $90, $40 [Flow: branch]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$25.b		; C0 25 ; Compare #$25.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit #$70.b		; 89 70 ; Test bits #$70.b with accumulator [Reads: Accumulator] [Flags: Z]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $F0.b		; 05 F0 ; Logical OR $F0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $8E.b,S		; 83 8E ; Store accumulator (stack relative) $8E.b,S [Reads: Stack Pointer, Accumulator]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora $23.b		; 05 23 ; Logical OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $230307.l		; 0F 07 03 23 ; OR accumulator with memory (long) $230307.l [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $D8		; 80 D8 ; Branch always to $80, $D8 [Flow: branch]
	cpy #$78.b		; C0 78 ; Compare #$78.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$70.b		; C0 70 ; Compare #$70.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $68.b,S		; 83 68 ; Store accumulator (stack relative) $68.b,S [Reads: Stack Pointer, Accumulator]
	ora $E4.b		; 05 E4 ; Logical OR $E4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($00.b,S),Y		; 33 00 ; AND accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $03EFE0.l,X		; FF E0 EF 03 ; Subtract with carry (long,X) $03EFE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $37.b,S		; 03 37 ; OR accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $6F.b,S		; 03 6F ; OR accumulator with stack relative $6F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ror $7D3B.w,X		; 7E 3B 7D ; Rotate right $7D3B.w,X [Reads: X Index] [Flags: NCZ]
	asl $D2.b,X		; 16 D2 ; Arithmetic shift left $D2.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $0E03.w		; 2D 03 0E ; Logical AND $0E03.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $2F.b,X		; 15 2F ; OR accumulator with memory $2F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$46.b],Y		; 57 46 ; Exclusive OR accumulator with memory (long indexed) [$46.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $C0F3.w		; 6D F3 C0 ; Add $C0F3.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $38		; 80 38 ; Branch always to $80, $38 [Flow: branch]
	cpy #$AC.b		; C0 AC ; Compare #$AC.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$F6.b		; C0 F6 ; Compare #$F6.b with Y register [Reads: Y Index] [Flags: NCZ]
	pei ($3E.b)		; D4 3E ; Push effective indirect address ($3E.b) [Reads: Direct Page] [Writes: Stack Pointer]
	jmp.w [$68BE]		; DC BE 68 ; Jump long indirect [$68BE] [Flow: jump]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ldy $C0.b,X		; B4 C0 ; Load Y register $C0.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	.db $70, $A8		; 70 A8 ; Branch if overflow set to $70, $A8 [Flow: branch]
	pea $22EA.w		; F4 EA 22 ; Push absolute address $22EA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldx $DE.b,Y		; B6 DE ; Load X register $DE.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $2500.w,X		; 1E 00 25 ; Arithmetic shift left $2500.w,X [Reads: X Index] [Flags: NCZ]
	ora $3C43.w,Y		; 19 43 3C ; OR accumulator with memory $3C43.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $FD3F.w		; 4E 3F FD ; Logical shift right $FD3F.w [Flags: NCZ]
	asl $0DDA.w,X		; 1E DA 0D ; Arithmetic shift left $0DDA.w,X [Reads: X Index] [Flags: NCZ]
	ldx $2B.b,Y		; B6 2B ; Load X register $2B.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $4F.b		; 26 4F ; Rotate left $4F.b [Reads: Direct Page] [Flags: NCZ]
	lsr $BBBD.w,X		; 5E BD BB ; Logical shift right $BBBD.w,X [Reads: X Index] [Flags: NCZ]
	cmp [$80.b],Y		; D7 80 ; Compare accumulator (long indexed) [$80.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	cpy #$F4.b		; C0 F4 ; Compare #$F4.b with Y register [Reads: Y Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpx $16FD.w		; EC FD 16 ; Compare $16FD.w with X register [Reads: X Index] [Flags: NCZ]
	eor $BA.b,X		; 55 BA ; Exclusive OR accumulator with memory $BA.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4080FC.l		; 0F FC 80 40 ; OR accumulator with memory (long) $4080FC.l [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($FD1E.w,X)		; FC 1E FD ; Jump to subroutine indirect indexed ($FD1E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp $00CF.w,X		; DD CF 00 ; Compare accumulator $00CF.w,X [Reads: X Index] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0637.w		; 0D 37 06 ; Logical OR $0637.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $037E0D.l		; 6F 0D 7E 03 ; Add with carry (long) $037E0D.l [Writes: Accumulator] [Flags: NCVZ]
	cmp #$3E.b		; C9 3E ; Compare #$3E.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	adc $0F00.w,X		; 7D 00 0F ; Add $0F00.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($29.b,S),Y		; 13 29 ; OR accumulator (stack relative indirect indexed) ($29.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($7E.b,S),Y		; 53 7E ; XOR accumulator (stack relative indirect indexed) ($7E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $F0BB.w,Y		; D9 BB F0 ; Compare accumulator $F0BB.w,Y [Reads: Y Index] [Flags: NCZ]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F4		; F0 F4 ; Branch if equal to $F0, $F4 [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	and ($FC.b)		; 32 FC ; AND accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($7E.b,X)		; E1 7E ; Subtract with carry ($7E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $4440.w,Y		; BE 40 44 ; Load X register $4440.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $42, $E4		; 42 E4 ; Reserved instruction
	.db $F0, $E8		; F0 E8 ; Branch if equal to $F0, $E8 [Flow: branch]
	pea $E172.w		; F4 72 E1 ; Push absolute address $E172.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ldx $DAF4.w,Y		; BE F4 DA ; Load X register $DAF4.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $28.b		; 06 28 ; Arithmetic shift left $28.b [Reads: Direct Page] [Flags: NCZ]
	ora $54.b,X		; 15 54 ; OR accumulator with memory $54.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $6E99.w,X		; 1D 99 6E ; OR accumulator with memory $6E99.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$9C.b],Y		; 57 9C ; Exclusive OR accumulator with memory (long indexed) [$9C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	eor [$6F.b],Y		; 57 6F ; Exclusive OR accumulator with memory (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $E0DFBF.l,X		; 9F BF DF E0 ; Store accumulator (long,X) $E0DFBF.l,X [Reads: Accumulator, X Index]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $A8.b		; 14 A8 ; Test and reset bits $A8.b [Reads: Accumulator] [Flags: Z]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pei ($4E.b)		; D4 4E ; Push effective indirect address ($4E.b) [Reads: Direct Page] [Writes: Stack Pointer]
	clv		; B8 ; Clear overflow flag [Flags: V]
	bit #$76.b		; 89 76 ; Test bits #$76.b with accumulator [Reads: Accumulator] [Flags: Z]
	ora $3DEA.w,Y		; 19 EA 3D ; OR accumulator with memory $3DEA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$98E0]		; DC E0 98 ; Jump long indirect [$98E0] [Flow: jump]
	pei ($FA.b)		; D4 FA ; Push effective indirect address ($FA.b) [Reads: Direct Page] [Writes: Stack Pointer]
	inc $FDF9.w,X		; FE F9 FD ; Increment memory $FDF9.w,X [Reads: X Index] [Flags: NZ]
	sbc $030000.l,X		; FF 00 00 03 ; Subtract with carry (long,X) $030000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $370F33.l		; 0F 33 0F 37 ; OR accumulator with memory (long) $370F33.l [Writes: Accumulator] [Flags: NZ]
	ora $7F375E.l		; 0F 5E 37 7F ; OR accumulator with memory (long) $7F375E.l [Writes: Accumulator] [Flags: NZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$5F.b],Y		; 37 5F ; AND accumulator with memory (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $C00000.l,X		; 7F 00 00 C0 ; Add long $C00000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C8.b		; C0 C8 ; Compare #$C8.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $EC		; F0 EC ; Branch if equal to $F0, $EC [Flow: branch]
	.db $F0, $3C		; F0 3C ; Branch if equal to $F0, $3C [Flow: branch]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	cpx $EC3E.w		; EC 3E EC ; Compare $EC3E.w with X register [Reads: X Index] [Flags: NCZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $C8		; 30 C8 ; Branch if minus to $30, $C8 [Flow: branch]
	cpx $FEFC.w		; EC FC FE ; Compare $FEFC.w with X register [Reads: X Index] [Flags: NCZ]
	inc $C085.w,X		; FE 85 C0 ; Increment memory $C085.w,X [Reads: X Index] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $1F		; 30 1F ; Branch if minus to $30, $1F [Flow: branch]
	eor $5F3F.w,Y		; 59 3F 5F ; Exclusive OR accumulator with memory $5F3F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $0C0300.l,X		; 3F 00 03 0C ; AND accumulator with memory (long,X) $0C0300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$2F.b],Y		; 17 2F ; OR accumulator with memory (long indexed) [$2F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $835F5F.l,X		; 3F 5F 5F 83 ; AND accumulator with memory (long,X) $835F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $30, $CC		; 30 CC ; Branch if minus to $30, $CC [Flow: branch]
	.db $B0, $F2		; B0 F2 ; Branch if carry set to $B0, $F2 [Flow: branch]
	cpy #$E9.b		; C0 E9 ; Compare #$E9.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $ED		; D0 ED ; Branch if not equal to $D0, $ED [Flow: branch]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpy $EFFE.w		; CC FE EF ; Compare $EFFE.w with Y register [Reads: Y Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $C0.b,S		; 83 C0 ; Store accumulator (stack relative) $C0.b,S [Reads: Stack Pointer, Accumulator]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0D.b,X		; 35 0D ; Logical AND $0D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $1F27.w		; 1C 27 1F ; Test and reset bits $1F27.w [Reads: Accumulator] [Flags: Z]
	eor $3F5D3F.l		; 4F 3F 5D 3F ; Exclusive OR accumulator with memory (long) $3F5D3F.l [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $231F.w		; 0D 1F 23 ; Logical OR $231F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and [$4F.b]		; 27 4F ; AND accumulator with memory (long) [$4F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $CC0038.l,X		; 5F 38 00 CC ; Exclusive OR accumulator with memory (long,X) $CC0038.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$1B.b		; C0 1B ; Compare #$1B.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$D6.b		; E0 D6 ; Compare #$D6.b with X register [Reads: X Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	bit $D8.b,X		; 34 D8 ; Test bits $D8.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cpx $ECDA.w		; EC DA EC ; Compare $ECDA.w with X register [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	pea $1D3A.w		; F4 3A 1D ; Push absolute address $1D3A.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	dec $34.b,X		; D6 34 ; Decrement memory $34.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora $0E1F00.l		; 0F 00 1F 0E ; OR accumulator with memory (long) $0E1F00.l [Writes: Accumulator] [Flags: NZ]
	rol $2B19.w		; 2E 19 2B ; Rotate left $2B19.w [Flags: NCZ]
	trb $57.b		; 14 57 ; Test and reset bits $57.b [Reads: Accumulator] [Flags: Z]
	bit $AF43.w		; 2C 43 AF ; Test bits $AF43.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	lsr $33E1.w,X		; 5E E1 33 ; Logical shift right $33E1.w,X [Reads: X Index] [Flags: NCZ]
	eor $1F0F3E.l		; 4F 3E 0F 1F ; Exclusive OR accumulator with memory (long) $1F0F3E.l [Writes: Accumulator] [Flags: NZ]
	rol $572B.w		; 2E 2B 57 ; Rotate left $572B.w [Flags: NCZ]
	lda $B84FAF.l		; AF AF 4F B8 ; Load long $B84FAF.l into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $DC.b		; 00 DC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($7CC0.w,X)		; FC C0 7C ; Jump to subroutine indirect indexed ($7CC0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	rol $1BFC.w,X		; 3E FC 1B ; Rotate left $1BFC.w,X [Reads: X Index] [Flags: NCZ]
	jsr ($708F.w,X)		; FC 8F 70 ; Jump to subroutine indirect indexed ($708F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $DCB806.l,X		; FF 06 B8 DC ; Subtract with carry (long,X) $DCB806.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($3E7C.w,X)		; FC 7C 3E ; Jump to subroutine indirect indexed ($3E7C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sta $73AFFF.l		; 8F FF AF 73 ; Store accumulator (long) $73AFFF.l [Reads: Accumulator]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $59FC.w,X		; 5D FC 59 ; Exclusive OR accumulator with memory $59FC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $58.b,X		; B4 58 ; Load Y register $58.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	mvp $26,$3A		; 44 3A 26 ; Move block positive $26,$3A [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $0815.w,Y		; 19 15 08 ; OR accumulator with memory $0815.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $45B7.w,X		; FE B7 45 ; Increment memory $45B7.w,X [Reads: X Index] [Flags: NZ]
	rol $15.b		; 26 15 ; Rotate left $15.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $CE.b,X		; 35 CE ; Logical AND $CE.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$BA.b],Y		; D7 BA ; Compare accumulator (long indexed) [$BA.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	and $1A2D9A.l,X		; 3F 9A 2D 1A ; AND accumulator with memory (long,X) $1A2D9A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $98645C.l		; 22 5C 64 98 ; Jump to subroutine long $98645C.l [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $A2ED7F.l,X		; DF 7F ED A2 ; Compare accumulator (long,X) $A2ED7F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	stz $A8.b		; 64 A8 ; Store zero to $A8.b
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc [$29.b],Y		; 77 29 ; Add with carry (long indexed) [$29.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $1B.b,X		; 34 1B ; Test bits $1B.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rol $2D07.w,X		; 3E 07 2D ; Rotate left $2D07.w,X [Reads: X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora [$0D.b],Y		; 17 0D ; OR accumulator with memory (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$57.b],Y		; 97 57 ; Store accumulator (long indexed) [$57.b],Y [Reads: Direct Page, Y Index, Accumulator]
	bit $3E.b,X		; 34 3E ; Test bits $3E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $07091F.l,X		; 3F 1F 09 07 ; AND accumulator with memory (long,X) $07091F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($CE.b),Y		; 91 CE ; Store accumulator ($CE.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ora #$C6.b		; 09 C6 ; Logical OR #$C6.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $50		; 10 50 ; Branch if plus to $10, $50 [Flow: branch]
	ldy #$20.b		; A0 20 ; Load #$20.b into Y register [Writes: Y Index] [Flags: NZ]
	cpy #$10.b		; C0 10 ; Compare #$10.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	brk $B1.b		; 00 B1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $EAF5.w,Y		; 39 F5 EA ; AND accumulator with memory $EAF5.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	adc $3EDD.w,X		; 7D DD 3E ; Add $3EDD.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $6E03.w,X		; 7E 03 6E ; Rotate right $6E03.w,X [Reads: X Index] [Flags: NCZ]
	ora $0637.w		; 0D 37 06 ; Logical OR $0637.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $0F0D.w,X		; 1E 0D 0F ; Arithmetic shift left $0F0D.w,X [Reads: X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BB.b		; 00 BB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $527E.w,X		; DD 7E 52 ; Compare accumulator $527E.w,X [Reads: X Index] [Flags: NCZ]
	and #$13.b		; 29 13 ; Logical AND #$13.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $E4C201.l		; 0F 01 C2 E4 ; OR accumulator with memory (long) $E4C201.l [Writes: Accumulator] [Flags: NZ]
	cpy $88.b		; C4 88 ; Compare $88.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ldx $E140.w,Y		; BE 40 E1 ; Load X register $E140.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ror $FC32.w,X		; 7E 32 FC ; Rotate right $FC32.w,X [Reads: X Index] [Flags: NCZ]
	pea $6888.w		; F4 88 68 ; Push absolute address $6888.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $E1BE.w		; F4 BE E1 ; Push absolute address $E1BE.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	adc ($F4.b)		; 72 F4 ; Add with carry (indirect) ($F4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $F0, $8E		; F0 8E ; Branch if equal to $F0, $8E [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $6E9B57.l		; 8F 57 9B 6E ; Store accumulator (long) $6E9B57.l [Reads: Accumulator]
	adc ($1D.b)		; 72 1D ; Add with carry (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	mvn $28,$2B		; 54 2B 28 ; Move block negative $28,$2B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $18.b,X		; 15 18 ; OR accumulator with memory $18.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $54729B.l		; AF 9B 72 54 ; Load long $54729B.l into accumulator [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $3907.w,Y		; 19 07 39 ; OR accumulator with memory $3907.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$EAF1]		; DC F1 EA ; Jump long indirect [$EAF1] [Flow: jump]
	sbc $4E76.w,Y		; F9 76 4E ; Subtract with carry $4E76.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pei ($14.b)		; D4 14 ; Push effective indirect address ($14.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $F9.b,X		; F5 F9 ; Subtract $F9.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $542A.w		; 4E 2A 54 ; Logical shift right $542A.w [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$4B.b		; E0 4B ; Compare #$4B.b with X register [Reads: X Index] [Flags: NCZ]
	and [$49.b],Y		; 37 49 ; AND accumulator with memory (long indexed) [$49.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$A4.b],Y		; 37 A4 ; AND accumulator with memory (long indexed) [$A4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sta $0FD304.l,X		; 9F 04 D3 0F ; Store accumulator (long,X) $0FD304.l,X [Reads: Accumulator, X Index]
	jmp ($3B03.w)		; 6C 03 3B ; Jump indirect to ($3B03.w) [Flow: jump]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor #$E4.b		; 49 E4 ; Exclusive OR #$E4.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $2B5CB3.l,X		; FF B3 5C 2B ; Subtract with carry (long,X) $2B5CB3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $FA		; 10 FA ; Branch if plus to $10, $FA [Flow: branch]
	cpx $ECDA.w		; EC DA EC ; Compare $ECDA.w with X register [Reads: X Index] [Flags: NCZ]
	and $D8.b		; 25 D8 ; Logical AND $D8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $CB20.w,Y		; F9 20 CB ; Subtract with carry $CB20.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $36		; F0 36 ; Branch if equal to $F0, $36 [Flow: branch]
	cpy #$DC.b		; C0 DC ; Compare #$DC.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and [$FF.b]		; 27 FF ; AND accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $D43A.w		; CD 3A D4 ; Compare $D43A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc [$0F.b],Y		; 77 0F ; Add with carry (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $1B.b		; 24 1B ; Test bits $1B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and [$24.b]		; 27 24 ; AND accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03070E.l,X		; 1F 0E 07 03 ; Logical OR long $03070E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$D8.b],Y		; B7 D8 ; Load accumulator (long indexed) [$D8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$98.b],Y		; 77 98 ; Add with carry (long indexed) [$98.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $38.b		; E6 38 ; Increment $38.b [Reads: Direct Page] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	cpx #$43.b		; E0 43 ; Compare #$43.b with X register [Reads: X Index] [Flags: NCZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	ora #$C0.b		; 09 C0 ; Logical OR #$C0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $B5.b		; 00 B5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $E6.b,X		; 75 E6 ; Add $E6.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	jsr $43C0.w		; 20 C0 43 ; Jump to subroutine at $43C0.w [Writes: Stack Pointer] [Flow: call]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	and $1F2D08.l,X		; 3F 08 2D 1F ; AND accumulator with memory (long,X) $1F2D08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$1C.b]		; 27 1C ; AND accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $030F03.l,X		; 1F 03 0F 03 ; Logical OR long $030F03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $272F5F.l,X		; 5F 5F 2F 27 ; Exclusive OR accumulator with memory (long,X) $272F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00030F.l,X		; 1F 0F 03 00 ; Logical OR long $00030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $DA.b,S		; 43 DA ; Exclusive OR accumulator with stack relative $DA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $A3E0.w		; EC E0 A3 ; Compare $A3E0.w with X register [Reads: X Index] [Flags: NCZ]
	ldy $D8.b,X		; B4 D8 ; Load Y register $D8.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	dec $28.b,X		; D6 28 ; Decrement memory $28.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cpx #$26.b		; E0 26 ; Compare #$26.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$CC.b		; C0 CC ; Compare #$CC.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldy $D6.b,X		; B4 D6 ; Load Y register $D6.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cmp $F43A.w,X		; DD 3A F4 ; Compare accumulator $F43A.w,X [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp $3E.b		; C5 3E ; Compare $3E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda $5C.b,S		; A3 5C ; Load accumulator (stack relative) $5C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $BB22.w,X		; 7D 22 BB ; Add $BB22.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$99.b],Y		; 77 99 ; Add with carry (long indexed) [$99.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$4C.b],Y		; 77 4C ; Add with carry (long indexed) [$4C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($37.b,S),Y		; 33 37 ; AND accumulator (stack relative indirect indexed) ($37.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $7D.b,S		; A3 7D ; Load accumulator (stack relative) $7D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sta $374C.w,Y		; 99 4C 37 ; Store accumulator to $374C.w,Y [Reads: Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $CD.b,X		; 16 CD ; Arithmetic shift left $CD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($FD.b)		; 32 FD ; AND accumulator with memory (indirect) ($FD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $E6.b		; 02 E6 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	cmp $BCCEBC.l		; CF BC CE BC ; Compare accumulator (long) $BCCEBC.l [Reads: Accumulator] [Flags: NCZ]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $E6FD.w		; CD FD E6 ; Compare $E6FD.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $F8E4CE.l		; CF CE E4 F8 ; Compare accumulator (long) $F8E4CE.l [Reads: Accumulator] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3002.w		; 0D 02 30 ; Logical OR $3002.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $741F20.l		; 0F 20 1F 74 ; OR accumulator with memory (long) $741F20.l [Writes: Accumulator] [Flags: NZ]
	ora $DE0EB9.l		; 0F B9 0E DE ; OR accumulator with memory (long) $DE0EB9.l [Writes: Accumulator] [Flags: NZ]
	eor #$FC.b		; 49 FC ; Exclusive OR #$FC.b with accumulator [Writes: Accumulator] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($27.b)		; 32 27 ; AND accumulator with memory (indirect) ($27.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $9FBFD9.l		; 5C D9 BF 9F ; Jump long to $9FBFD9.l [Flow: jump]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $B0, $20		; B0 20 ; Branch if carry set to $B0, $20 [Flow: branch]
	jsr ($7230.w,X)		; FC 30 72 ; Jump to subroutine indirect indexed ($7230.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sty $EC7E.w		; 8C 7E EC ; Store Y register to $EC7E.w [Reads: Y Index]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	rol $75.b		; 26 75 ; Rotate left $75.b [Reads: Direct Page] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $CC		; D0 CC ; Branch if not equal to $D0, $CC [Flow: branch]
	ror $DB7E.w,X		; 7E 7E DB ; Rotate right $DB7E.w,X [Reads: X Index] [Flags: NCZ]
	sbc $0007.w,X		; FD 07 00 ; Subtract with carry $0007.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $3D.b,S		; 03 3D ; OR accumulator with stack relative $3D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($2F.b,X)		; 01 2F ; Logical OR ($2F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $47		; 10 47 ; Branch if plus to $10, $47 [Flow: branch]
	and $823C4B.l,X		; 3F 4B 3C 82 ; AND accumulator with memory (long,X) $823C4B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $3BC4.w,X		; 7D C4 3B ; Add $3BC4.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($2F.b)		; 32 2F ; AND accumulator with memory (indirect) ($2F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $D7B35B.l		; 4F 5B B3 D7 ; Exclusive OR accumulator with memory (long) $D7B35B.l [Writes: Accumulator] [Flags: NZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	jmp.w [$BA30]		; DC 30 BA ; Jump long indirect [$BA30] [Flow: jump]
	jmp ($8C72.w,X)		; 7C 72 8C ; Jump indirect indexed to ($8C72.w,X) [Reads: X Index] [Flow: jump]
	ldx $FA70.w,Y		; BE 70 FA ; Load X register $FA70.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jmp.w [$EED1]		; DC D1 EE ; Jump long indirect [$EED1] [Flow: jump]
	.db $80, $70		; 80 70 ; Branch always to $80, $70 [Flow: branch]
	jsr ($72FA.w,X)		; FC FA 72 ; Jump to subroutine indirect indexed ($72FA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldx $D1FA.w,Y		; BE FA D1 ; Load X register $D1FA.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sta $C0.b,S		; 83 C0 ; Store accumulator (stack relative) $C0.b,S [Reads: Stack Pointer, Accumulator]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E1100.l		; 0F 00 11 0E ; OR accumulator with memory (long) $0E1100.l [Writes: Accumulator] [Flags: NZ]
	rol $1F.b		; 26 1F ; Rotate left $1F.b [Reads: Direct Page] [Flags: NCZ]
	and $3F5B1F.l		; 2F 1F 5B 3F ; AND accumulator with memory (long) $3F5B1F.l [Writes: Accumulator] [Flags: NZ]
	eor ($3F.b),Y		; 51 3F ; Exclusive OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2F2611.l		; 0F 11 26 2F ; OR accumulator with memory (long) $2F2611.l [Writes: Accumulator] [Flags: NZ]
	sta $06.b,S		; 83 06 ; Store accumulator (stack relative) $06.b,S [Reads: Stack Pointer, Accumulator]
	ora ($15.b,X)		; 01 15 ; Logical OR ($15.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	stz $A260.w		; 9C 60 A2 ; Store zero to $A260.w
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	lsr $A0.b,X		; 56 A0 ; Logical shift right $A0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $D8B7D0.l		; 2F D0 B7 D8 ; AND accumulator with memory (long) $D8B7D0.l [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cpx $E000.w		; EC 00 E0 ; Compare $E000.w with X register [Reads: X Index] [Flags: NCZ]
	stz $5ABE.w		; 9C BE 5A ; Store zero to $5ABE.w
	and #$B5.b		; 29 B5 ; Logical AND #$B5.b with accumulator [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sta $C0.b		; 85 C0 ; Store accumulator to $C0.b [Reads: Accumulator]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $1F.b		; 26 1F ; Rotate left $1F.b [Reads: Direct Page] [Flags: NCZ]
	bit $6E1F.w		; 2C 1F 6E ; Test bits $6E1F.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $000F77.l,X		; 1F 77 0F 00 ; Logical OR long $000F77.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($27.b,S),Y		; 13 27 ; OR accumulator (stack relative indirect indexed) ($27.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $83776F.l		; 2F 6F 77 83 ; AND accumulator with memory (long) $83776F.l [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $8070.w,X		; 7D 70 80 ; Add $8070.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $90, $64		; 90 64 ; Branch if carry clear to $90, $64 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	bit $D8.b,X		; 34 D8 ; Test bits $D8.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cpx #$F9.b		; E0 F9 ; Compare #$F9.b with X register [Reads: X Index] [Flags: NCZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$70.b		; C0 70 ; Compare #$70.b with Y register [Reads: Y Index] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx $F4.b		; E4 F4 ; Compare $F4.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	inc $04FF.w,X		; FE FF 04 ; Increment memory $04FF.w,X [Reads: X Index] [Flags: NZ]
	tsb $32.b		; 04 32 ; Test and set bits $32.b [Reads: Accumulator] [Flags: Z]
	asl $52.b,X		; 16 52 ; Arithmetic shift left $52.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $3E4C.w,X		; 3E 4C 3E ; Rotate left $3E4C.w,X [Reads: X Index] [Flags: NCZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $1017.w		; 2C 17 10 ; Test bits $1017.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $042F32.l		; 0F 32 2F 04 ; OR accumulator with memory (long) $042F32.l [Writes: Accumulator] [Flags: NZ]
	and ($52.b)		; 32 52 ; AND accumulator with memory (indirect) ($52.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $2C2D.w		; 4C 2D 2C ; Jump to $2C2D.w [Flow: jump]
	.db $10, $32		; 10 32 ; Branch if plus to $10, $32 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cld		; D8 ; Clear decimal flag [Flags: D]
	bit $965C.w		; 2C 5C 96 ; Test bits $965C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	stx $CE92.w		; 8E 92 CE ; Store X register to $CE92.w [Reads: X Index]
	lsr $21F2.w		; 4E F2 21 ; Logical shift right $21F2.w [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	bit $D296.w		; 2C 96 D2 ; Test bits $D296.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ror $0021.w		; 6E 21 00 ; Rotate right $0021.w [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	stz $6C.b		; 64 6C ; Store zero to $6C.b
	.db $30, $F4		; 30 F4 ; Branch if minus to $30, $F4 [Flow: branch]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0808.w,Y		; 19 08 08 ; OR accumulator with memory $0808.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $64.b		; 04 64 ; Test and set bits $64.b [Reads: Accumulator] [Flags: Z]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $061C.w		; 0C 1C 06 ; Test and set bits $061C.w [Reads: Accumulator] [Flags: Z]
	asl $0E02.w,X		; 1E 02 0E ; Arithmetic shift left $0E02.w,X [Reads: X Index] [Flags: NCZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($C3.b,X)		; 41 C3 ; Exclusive OR accumulator with memory ($C3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	tsb $0206.w		; 0C 06 02 ; Test and set bits $0206.w [Reads: Accumulator] [Flags: Z]
	cop $41.b		; 02 41 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $4F01.w		; 1C 01 4F ; Test and reset bits $4F01.w [Reads: Accumulator] [Flags: Z]
	rol $0062.w,X		; 3E 62 00 ; Rotate left $0062.w,X [Reads: X Index] [Flags: NCZ]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	ora $2F.b,X		; 15 2F ; OR accumulator with memory $2F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $D8834F.l		; 2F 4F 83 D8 ; AND accumulator with memory (long) $D8834F.l [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$C0.b		; E0 C0 ; Compare #$C0.b with X register [Reads: X Index] [Flags: NCZ]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	.db $F0, $8C		; F0 8C ; Branch if equal to $F0, $8C [Flow: branch]
	.db $70, $FE		; 70 FE ; Branch if overflow set to $70, $FE [Flow: branch]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $70, $38		; 70 38 ; Branch if overflow set to $70, $38 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sty $25FE.w		; 8C FE 25 ; Store Y register to $25FE.w [Reads: Y Index]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0E1300.l		; 0F 00 13 0E ; OR accumulator with memory (long) $0E1300.l [Writes: Accumulator] [Flags: NZ]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $002204.l		; 0F 04 22 00 ; OR accumulator with memory (long) $002204.l [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $0F1713.l		; 0F 13 17 0F ; OR accumulator with memory (long) $0F1713.l [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $3A.b		; 85 3A ; Store accumulator to $3A.b [Reads: Accumulator]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$20.b		; E0 20 ; Compare #$20.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$E0.b		; C0 E0 ; Compare #$E0.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $70, $90		; 70 90 ; Branch if overflow set to $70, $90 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc [$4B.b],Y		; F7 4B ; Subtract with carry (long indexed) [$4B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora [$5E.b],Y		; 17 5E ; OR accumulator with memory (long indexed) [$5E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $7F.b,X		; 35 7F ; Logical AND $7F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	bit $1B.b		; 24 1B ; Test bits $1B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $0101.w,X		; 1E 01 01 ; Arithmetic shift left $0101.w,X [Reads: X Index] [Flags: NCZ]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $367F.w,X		; 7E 7F 36 ; Rotate right $367F.w,X [Reads: X Index] [Flags: NCZ]
	bit $1E.b		; 24 1E ; Test bits $1E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($BD.b,X)		; 01 BD ; Logical OR ($BD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	asl $43DC.w		; 0E DC 43 ; Arithmetic shift left $43DC.w [Flags: NCZ]
	ora ($0C.b)		; 12 0C ; OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$34.b		; E0 34 ; Compare #$34.b with X register [Reads: X Index] [Flags: NCZ]
	sty $28.b,X		; 94 28 ; Store Y register $28.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $F2F2.w		; 2E F2 F2 ; Rotate left $F2F2.w [Flags: NCZ]
	pei ($A8.b)		; D4 A8 ; Push effective indirect address ($A8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $F2		; 80 F2 ; Branch always to $80, $F2 [Flow: branch]
	ora $059F.w		; 0D 9F 05 ; Logical OR $059F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $3F36.w,X		; 7D 36 3F ; Add $3F36.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $16		; 10 16 ; Branch if plus to $10, $16 [Flow: branch]
	ora $0E15.w		; 0D 15 0E ; Logical OR $0E15.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $0303.w		; 0E 03 03 ; Arithmetic shift left $0303.w [Flags: NCZ]
	brk $B3.b		; 00 B3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1F2F4D.l,X		; FF 4D 2F 1F ; Subtract with carry (long,X) $1F2F4D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $030E.w,X		; 1D 0E 03 ; OR accumulator with memory $030E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02C2.w		; 8D C2 02 ; Store accumulator to $02C2.w [Reads: Accumulator]
	cpx $84.b		; E4 84 ; Compare $84.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpy #$C4.b		; C0 C4 ; Compare #$C4.b with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	sta $A5.b,S		; 83 A5 ; Store accumulator (stack relative) $A5.b,S [Reads: Stack Pointer, Accumulator]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pea $C4B8.w		; F4 B8 C4 ; Push absolute address $C4B8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	eor ($3F.b),Y		; 51 3F ; Exclusive OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $27033F.l		; 0F 3F 03 27 ; OR accumulator with memory (long) $27033F.l [Writes: Accumulator] [Flags: NZ]
	trb $0C13.w		; 1C 13 0C ; Test and reset bits $0C13.w [Reads: Accumulator] [Flags: Z]
	tsb $0200.w		; 0C 00 02 ; Test and set bits $0200.w [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $13273F.l,X		; 7F 3F 27 13 ; Add long $13273F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $9A0103.l		; 0F 03 01 9A ; OR accumulator with memory (long) $9A0103.l [Writes: Accumulator] [Flags: NZ]
	cpx $DCB2.w		; EC B2 DC ; Compare $DCB2.w with X register [Reads: X Index] [Flags: NCZ]
	bit $D8.b,X		; 34 D8 ; Test bits $D8.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpx $38.b		; E4 38 ; Compare $38.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9A.b		; 00 9A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($34.b)		; B2 34 ; Load accumulator (indirect) ($34.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $C8.b		; E4 C8 ; Compare $C8.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $30, $88		; 30 88 ; Branch if minus to $30, $88 [Flow: branch]
	.db $F0, $73		; F0 73 ; Branch if equal to $F0, $73 [Flow: branch]
	ora $563748.l		; 0F 48 37 56 ; OR accumulator with memory (long) $563748.l [Writes: Accumulator] [Flags: NZ]
	and #$2B.b		; 29 2B ; Logical AND #$2B.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $25.b		; 06 25 ; Arithmetic shift left $25.b [Reads: Direct Page] [Flags: NCZ]
	ora $2E.b,S		; 03 2E ; OR accumulator with stack relative $2E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lsr $3B.b,X		; 56 3B ; Logical shift right $3B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $1932.w,X		; 3D 32 19 ; AND accumulator with memory $1932.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $DD.b		; 06 DD ; Arithmetic shift left $DD.b [Reads: Direct Page] [Flags: NCZ]
	cpx #$1F.b		; E0 1F ; Compare #$1F.b with X register [Reads: X Index] [Flags: NCZ]
	cpx #$77.b		; E0 77 ; Compare #$77.b with X register [Reads: X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$78.b]		; E7 78 ; Subtract with carry (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	jsl $41E000.l		; 22 00 E0 41 ; Jump to subroutine long $41E000.l [Writes: Stack Pointer] [Flow: call]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora $E575.w,Y		; 19 75 E5 ; OR accumulator with memory $E575.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($8A.b,S),Y		; 73 8A ; Add with carry (stack relative indirect indexed) ($8A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc ($40.b),Y		; 71 40 ; Add with carry ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $3E28.w		; 2C 28 3E ; Test bits $3E28.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	eor #$3E.b		; 49 3E ; Exclusive OR #$3E.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $0C.b,X		; 35 0C ; Logical AND $0C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $408A.w,X		; BD 8A 40 ; Load $408A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	eor $0635.w		; 4D 35 06 ; Exclusive OR $0635.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0C7C.w		; 0C 7C 0C ; Test and set bits $0C7C.w [Reads: Accumulator] [Flags: Z]
	rol $B876.w,X		; 3E 76 B8 ; Rotate left $B876.w,X [Reads: X Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp.w [$64BC]		; DC BC 64 ; Jump long indirect [$64BC] [Flow: jump]
	jmp.w [$06DA]		; DC DA 06 ; Jump long indirect [$06DA] [Flow: jump]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jmp ($B83E.w,X)		; 7C 3E B8 ; Jump indirect indexed to ($B83E.w,X) [Reads: X Index] [Flow: jump]
	jmp.w [$DA64]		; DC 64 DA ; Jump long indirect [$DA64] [Flow: jump]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	adc $3D0C.w,Y		; 79 0C 3D ; Add $3D0C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	tsb $0024.w		; 0C 24 00 ; Test and set bits $0024.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$60.b		; C0 60 ; Compare #$60.b with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$30.b		; E0 30 ; Compare #$30.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $30, $25		; 30 25 ; Branch if minus to $30, $25 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $22		; 30 22 ; Branch if minus to $30, $22 [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $3E.b		; 45 3E ; Exclusive OR $3E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $031C1D.l		; 22 1D 1C 03 ; Jump to subroutine long $031C1D.l [Writes: Stack Pointer] [Flow: call]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0703.w		; 0C 03 07 ; Test and set bits $0703.w [Reads: Accumulator] [Flags: Z]
	jsl $451400.l		; 22 00 14 45 ; Jump to subroutine long $451400.l [Writes: Stack Pointer] [Flow: call]
	jsl $13171C.l		; 22 1C 17 13 ; Jump to subroutine long $13171C.l [Writes: Stack Pointer] [Flow: call]
	tsb $0007.w		; 0C 07 00 ; Test and set bits $0007.w [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	trb $3CC2.w		; 1C C2 3C ; Test and reset bits $3CC2.w [Reads: Accumulator] [Flags: Z]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sty $D4.b		; 84 D4 ; Store Y register to $D4.b [Reads: Y Index]
	clv		; B8 ; Clear overflow flag [Flags: V]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	jsl $FA1000.l		; 22 00 10 FA ; Jump to subroutine long $FA1000.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
.INDEX 16
	rep #$7A		; C2 7A
	pei ($C8.b)		; D4 C8 ; Push effective indirect address ($C8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0F17.w		; 0E 17 0F ; Arithmetic shift left $0F17.w [Flags: NCZ]
	ora ($0F.b)		; 12 0F ; OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0706.w		; 09 06 07 ; Logical OR #$0706.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $17.b		; 04 17 ; Test and set bits $17.b [Reads: Accumulator] [Flags: Z]
	ora [$12.b],Y		; 17 12 ; OR accumulator with memory (long indexed) [$12.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$2207.w		; 09 07 22 ; Logical OR #$2207.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldy $78.b,X		; B4 78 ; Load Y register $78.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $8F.b,S		; 83 8F ; Store accumulator (stack relative) $8F.b,S [Reads: Stack Pointer, Accumulator]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($08B4.w,X)		; FC B4 08 ; Jump to subroutine indirect indexed ($08B4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0334E0.l,X		; FF E0 34 03 ; Subtract with carry (long,X) $0334E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $100F16.l		; 0F 16 0F 10 ; OR accumulator with memory (long) $100F16.l [Writes: Accumulator] [Flags: NZ]
	ora $0F031C.l		; 0F 1C 03 0F ; OR accumulator with memory (long) $0F031C.l [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	tsb $0080.w		; 0C 80 00 ; Test and set bits $0080.w [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $A0		; 80 A0 ; Branch always to $80, $A0 [Flow: branch]
	cpy #$E050.w		; C0 50 E0 ; Compare #$E050.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	cpx #$8040.w		; E0 40 80 ; Compare #$8040.w with X register [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ldy #$D0D0.w		; A0 D0 D0 ; Load #$D0D0.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $10, $70		; 10 70 ; Branch if plus to $10, $70 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $09.b,X		; 15 09 ; OR accumulator with memory $09.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1D08.w,X		; 1D 08 1D ; OR accumulator with memory $1D08.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $31.b,S		; 83 31 ; Store accumulator (stack relative) $31.b,S [Reads: Stack Pointer, Accumulator]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0815.w		; 09 15 08 ; Logical OR #$0815.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$FC15.w		; 29 15 FC ; Logical AND #$FC15.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1F1E44.l		; 0F 44 1E 1F ; OR accumulator with memory (long) $1F1E44.l [Writes: Accumulator] [Flags: NZ]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $207049.l,X		; FF 49 70 20 ; Subtract with carry (long,X) $207049.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $50.b		; 05 50 ; Logical OR $50.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $5028.w		; 20 28 50 ; Jump to subroutine at $5028.w [Writes: Stack Pointer] [Flow: call]
	ror $24E0.w,X		; 7E E0 24 ; Rotate right $24E0.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	.db $D0, $A8		; D0 A8 ; Branch if not equal to $D0, $A8 [Flow: branch]
	inc $32DF.w,X		; FE DF 32 ; Increment memory $32DF.w,X [Reads: X Index] [Flags: NZ]
	sbc $1EA30E.l,X		; FF 0E A3 1E ; Subtract with carry (long,X) $1EA30E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $1F.b		; A4 1F ; Load $1F.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $0F1743.l,X		; 1F 43 17 0F ; Logical OR long $0F1743.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $A1F9DD.l		; 0F DD F9 A1 ; OR accumulator with memory (long) $A1F9DD.l [Writes: Accumulator] [Flags: NZ]
	ldy $17AF.w		; AC AF 17 ; Load $17AF.w into Y register [Writes: Y Index] [Flags: NZ]
	ora [$10.b],Y		; 17 10 ; OR accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $99.b,X		; F6 99 ; Increment memory $99.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $F08BE0.l,X		; FF E0 8B F0 ; Subtract with carry (long,X) $F08BE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	.db $F0, $2B		; F0 2B ; Branch if equal to $F0, $2B [Flow: branch]
	.db $F0, $43		; F0 43 ; Branch if equal to $F0, $43 [Flow: branch]
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	ora #$E010.w		; 09 10 E0 ; Logical OR #$E010.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $3F.b,X		; 76 3F ; Rotate right $3F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	.db $10, $4F		; 10 4F ; Branch if plus to $10, $4F [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $47.b,X		; 16 47 ; Arithmetic shift left $47.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	eor [$D0.b]		; 47 D0 ; Exclusive OR accumulator with memory (long) [$D0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$F027.w		; E0 27 F0 ; Compare #$F027.w with X register [Reads: X Index] [Flags: NCZ]
	eor $27071A.l		; 4F 1A 07 27 ; Exclusive OR accumulator with memory (long) $27071A.l [Writes: Accumulator] [Flags: NZ]
	asl $4F.b,X		; 16 4F ; Arithmetic shift left $4F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	and [$F0.b]		; 27 F0 ; AND accumulator with memory (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($0F.b)		; 12 0F ; OR accumulator with memory (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $1A0F16.l		; 0F 16 0F 1A ; OR accumulator with memory (long) $1A0F16.l [Writes: Accumulator] [Flags: NZ]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sta $F6.b,S		; 83 F6 ; Store accumulator (stack relative) $F6.b,S [Reads: Stack Pointer, Accumulator]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1604.w,X		; 1E 04 16 ; Arithmetic shift left $1604.w,X [Reads: X Index] [Flags: NCZ]
	ora ($1A.b)		; 12 1A ; OR accumulator with memory (indirect) ($1A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $12.b,X		; 16 12 ; Arithmetic shift left $12.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $C0F0.w		; 4D F0 C0 ; Exclusive OR $C0F0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($B0.b,X)		; 01 B0 ; Logical OR ($B0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy #$D027.w		; C0 27 D0 ; Compare #$D027.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $14.b,S		; 03 14 ; OR accumulator with stack relative $14.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$47.b]		; 07 47 ; OR accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0403.w		; 1C 03 04 ; Test and reset bits $0403.w [Reads: Accumulator] [Flags: Z]
	trb $0B.b		; 14 0B ; Test and reset bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora ($1A.b)		; 12 1A ; OR accumulator with memory (indirect) ($1A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $23.b,X		; 16 23 ; Arithmetic shift left $23.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($00.b)		; 12 00 ; OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $27C0B0.l		; 4F B0 C0 27 ; Exclusive OR accumulator with memory (long) $27C0B0.l [Writes: Accumulator] [Flags: NZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	trb $0B.b		; 14 0B ; Test and reset bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora $1D07.w,Y		; 19 07 1D ; OR accumulator with memory $1D07.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $47.b,S		; 03 47 ; OR accumulator with stack relative $47.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0E0401.l		; 0F 01 04 0E ; OR accumulator with memory (long) $0E0401.l [Writes: Accumulator] [Flags: NZ]
	ora ($1A.b,X)		; 01 1A ; Logical OR ($1A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$13.b],Y		; 17 13 ; OR accumulator with memory (long indexed) [$13.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $09.b		; 24 09 ; Test bits $09.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $30.b		; 45 30 ; Exclusive OR $30.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$2001.w		; C0 01 20 ; Compare #$2001.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$6047.w		; C0 47 60 ; Compare #$6047.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	cpx #$A023.w		; E0 23 A0 ; Compare #$A023.w with X register [Reads: X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $1F2C00.l,X		; 1F 00 2C 1F ; Logical OR long $1F2C00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $081C00.l,X		; 1F 00 1C 08 ; Logical OR long $081C00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $09.b,X		; 15 09 ; OR accumulator with memory $09.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $83.b,X		; 15 83 ; OR accumulator with memory $83.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$01.b]		; 87 01 ; Store accumulator (long) [$01.b] [Reads: Direct Page, Accumulator]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $441F2F.l,X		; 1F 2F 1F 44 ; Logical OR long $441F2F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $F0051E.l,X		; 1F 1E 05 F0 ; Logical OR long $F0051E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $20		; 70 20 ; Branch if overflow set to $70, $20 [Flow: branch]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	and $F0.b		; 25 F0 ; Logical AND $F0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$3750.w		; E0 50 37 ; Compare #$3750.w with X register [Reads: X Index] [Flags: NCZ]
	cmp $47FF88.l		; CF 88 FF 47 ; Compare accumulator (long) $47FF88.l [Reads: Accumulator] [Flags: NCZ]
	sbc $E0FFC0.l,X		; FF C0 FF E0 ; Subtract with carry (long,X) $E0FFC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $43FF00.l,X		; FF 00 FF 43 ; Subtract with carry (long,X) $43FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $F71CEF.l,X		; BF EF 1C F7 ; Load long $F71CEF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $00E7DF.l,X		; FF DF E7 00 ; Subtract with carry (long,X) $00E7DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $EF.b,S		; 43 EF ; Exclusive OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $22E6.w,Y		; D9 E6 22 ; Compare accumulator $22E6.w,Y [Reads: Y Index] [Flags: NCZ]
	sbc $07FFC4.l,X		; FF C4 FF 07 ; Subtract with carry (long,X) $07FFC4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $01FF0F.l,X		; FF 0F FF 01 ; Subtract with carry (long,X) $01FF0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EEFB84.l,X		; FF 84 FB EE ; Subtract with carry (long,X) $EEFB84.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($DF.b),Y		; 71 DF ; Add with carry ($DF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $CFF7FF.l,X		; 3F FF F7 CF ; AND accumulator with memory (long,X) $CFF7FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $050A.w		; EE 0A 05 ; Increment $050A.w [Flags: NZ]
	ora $070900.l		; 0F 00 09 07 ; OR accumulator with memory (long) $070900.l [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $140F19.l		; 0F 19 0F 14 ; OR accumulator with memory (long) $140F19.l [Writes: Accumulator] [Flags: NZ]
	ora $1A0718.l		; 0F 18 07 1A ; OR accumulator with memory (long) $1A0718.l [Writes: Accumulator] [Flags: NZ]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $191B09.l		; 0F 09 1B 19 ; OR accumulator with memory (long) $191B09.l [Writes: Accumulator] [Flags: NZ]
	trb $1614.w		; 1C 14 16 ; Test and reset bits $1614.w [Reads: Accumulator] [Flags: Z]
	ldy #$E040.w		; A0 40 E0 ; Load #$E040.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E0B0.w		; C0 B0 E0 ; Compare #$E0B0.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $44		; 30 44 ; Branch if minus to $30, $44 [Flow: branch]
	cpx #$0970.w		; E0 70 09 ; Compare #$0970.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	ldy #$20E0.w		; A0 E0 20 ; Load #$20E0.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $B0, $30		; B0 30 ; Branch if carry set to $B0, $30 [Flow: branch]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	.db $F0, $4F		; F0 4F ; Branch if equal to $F0, $4F [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora [$27.b]		; 07 27 ; OR accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $4F.b,X		; 16 4F ; Arithmetic shift left $4F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	and [$F0.b]		; 27 F0 ; AND accumulator with memory (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $27071A.l		; 4F 1A 07 27 ; Exclusive OR accumulator with memory (long) $27071A.l [Writes: Accumulator] [Flags: NZ]
	asl $4F.b,X		; 16 4F ; Arithmetic shift left $4F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $D0, $E0		; D0 E0 ; Branch if not equal to $D0, $E0 [Flow: branch]
	and [$F0.b]		; 27 F0 ; AND accumulator with memory (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $1E.b,S		; 43 1E ; Exclusive OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0B.b,X		; 16 0B ; Arithmetic shift left $0B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $F2.b		; 85 F2 ; Store accumulator to $F2.b [Reads: Accumulator]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0203.w		; 1C 03 02 ; Test and reset bits $0203.w [Reads: Accumulator] [Flags: Z]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $01.b,S		; 83 01 ; Store accumulator (stack relative) $01.b,S [Reads: Stack Pointer, Accumulator]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($4F.b)		; 12 4F ; OR accumulator with memory (indirect) ($4F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $C0		; B0 C0 ; Branch if carry set to $B0, $C0 [Flow: branch]
	and [$D0.b]		; 27 D0 ; AND accumulator with memory (long) [$D0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $4B0718.l		; 0F 18 07 4B ; OR accumulator with memory (long) $4B0718.l [Writes: Accumulator] [Flags: NZ]
	trb $0103.w		; 1C 03 01 ; Test and reset bits $0103.w [Reads: Accumulator] [Flags: Z]
	asl $2516.w,X		; 1E 16 25 ; Arithmetic shift left $2516.w,X [Reads: X Index] [Flags: NCZ]
	ora ($49.b)		; 12 49 ; OR accumulator with memory (indirect) ($49.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $C0		; B0 C0 ; Branch if carry set to $B0, $C0 [Flow: branch]
	eor $30.b		; 45 30 ; Exclusive OR $30.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$D027.w		; C0 27 D0 ; Compare #$D027.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$0523.w		; 09 23 05 ; Logical OR #$0523.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	cop $80.b		; 02 80 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $A00000.l		; 22 00 00 A0 ; Jump to subroutine long $A00000.l [Writes: Stack Pointer] [Flow: call]
	and $C0.b,S		; 23 C0 ; AND accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $38		; 80 38 ; Branch always to $80, $38 [Flow: branch]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($08.b,S),Y		; 13 08 ; OR accumulator (stack relative indirect indexed) ($08.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$11.b]		; 07 11 ; OR accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $270F13.l		; 0F 13 0F 27 ; OR accumulator with memory (long) $270F13.l [Writes: Accumulator] [Flags: NZ]
	ora $5C1F26.l,X		; 1F 26 1F 5C ; Logical OR long $5C1F26.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $0F0703.l,X		; 3F 03 07 0F ; AND accumulator with memory (long,X) $0F0703.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3E3F1F.l,X		; 1F 1F 3F 3E ; Logical OR long $3E3F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($1883.w,X)		; 7C 83 18 ; Jump indirect indexed to ($1883.w,X) [Reads: X Index] [Flow: jump]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $10C0.w		; 20 C0 10 ; Jump to subroutine at $10C0.w [Writes: Stack Pointer] [Flow: call]
	cpx #$E090.w		; E0 90 E0 ; Compare #$E090.w with X register [Reads: X Index] [Flags: NCZ]
	eor $C8.b,S		; 43 C8 ; Exclusive OR accumulator with stack relative $C8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	stz $F8.b,X		; 74 F8 ; Store zero to $F8.b,X [Reads: X Index]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpx #$F0F0.w		; E0 F0 F0 ; Compare #$F0F0.w with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	jmp ($0039.w,X)		; 7C 39 00 ; Jump indirect indexed to ($0039.w,X) [Reads: X Index] [Flow: jump]
	eor $20.b,S		; 43 20 ; Exclusive OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	eor $38.b,S		; 43 38 ; Exclusive OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0028.w		; 1C 28 00 ; Test and reset bits $0028.w [Reads: Accumulator] [Flags: Z]
	sta $64.b,S		; 83 64 ; Store accumulator (stack relative) $64.b,S [Reads: Stack Pointer, Accumulator]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $1C,$00		; 44 00 1C ; Move block positive $1C,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0000.w		; 2E 00 00 ; Rotate left $0000.w [Flags: NCZ]
	ora ($44.b),Y		; 11 44 ; OR accumulator with memory ($44.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0E.b,S		; 43 0E ; Exclusive OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	dec $10.b		; C6 10 ; Decrement $10.b [Reads: Direct Page] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $83		; 10 83 ; Branch if plus to $10, $83 [Flow: branch]
	ldx $03.b		; A6 03 ; Load $03.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	dec $28.b		; C6 28 ; Decrement $28.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $B0.b,S		; 83 B0 ; Store accumulator (stack relative) $B0.b,S [Reads: Stack Pointer, Accumulator]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $E4		; 10 E4 ; Branch if plus to $10, $E4 [Flow: branch]
	rep #$00		; C2 00 ; Reset processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp ($AD3F.w,X)		; 7C 3F AD ; Jump indirect indexed to ($AD3F.w,X) [Reads: X Index] [Flow: jump]
	ror $7E91.w,X		; 7E 91 7E ; Rotate right $7E91.w,X [Reads: X Index] [Flags: NCZ]
	sta ($7E.b,X)		; 81 7E ; Store accumulator ($7E.b,X) [Reads: Direct Page, Accumulator, X Index]
	sbc $040026.l,X		; FF 26 00 04 ; Subtract with carry (long,X) $040026.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($91AD.w,X)		; 7C AD 91 ; Jump indirect indexed to ($91AD.w,X) [Reads: X Index] [Flow: jump]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index]
	jsl $7C0800.l		; 22 00 08 7C ; Jump to subroutine long $7C0800.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora ($FC.b)		; 12 FC ; OR accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $FC02FC.l		; 22 FC 02 FC ; Jump to subroutine long $FC02FC.l [Writes: Stack Pointer] [Flow: call]
	inc $0026.w,X		; FE 26 00 ; Increment memory $0026.w,X [Reads: X Index] [Flags: NZ]
	tsb $7C.b		; 04 7C ; Test and set bits $7C.b [Reads: Accumulator] [Flags: Z]
	ora ($22.b)		; 12 22 ; OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0044.w		; 1C 44 00 ; Test and reset bits $0044.w [Reads: Accumulator] [Flags: Z]
	tsb $0443.w		; 0C 43 04 ; Test and set bits $0443.w [Reads: Accumulator] [Flags: Z]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2C.b		; 04 2C ; Test and set bits $2C.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	mvp $0E,$00		; 44 00 0E ; Move block positive $0E,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $44, $28		; 82 44 28 ; Branch always long to $82, $44, $28 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	mvn $28,$10		; 54 10 28 ; Move block negative $28,$10 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	mvn $28,$44		; 54 44 28 ; Move block negative $28,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $44, $28		; 82 44 28 ; Branch always long to $82, $44, $28 [Flow: branch]
	mvn $82,$00		; 54 00 82 ; Move block negative $82,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $D3.b,S		; 83 D3 ; Store accumulator (stack relative) $D3.b,S [Reads: Stack Pointer, Accumulator]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $28.b		; 02 28 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $C2.b		; E4 C2 ; Compare $C2.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$1E2F.w		; E0 2F 1E ; Compare #$1E2F.w with X register [Reads: X Index] [Flags: NCZ]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $3B54.w		; 1C 54 3B ; Test and reset bits $3B54.w [Reads: Accumulator] [Flags: Z]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and [$E8.b],Y		; 37 E8 ; AND accumulator with memory (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$D4.b],Y		; 77 D4 ; Add with carry (long indexed) [$D4.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $5A077D.l		; 6F 7D 07 5A ; Add with carry (long) $5A077D.l [Writes: Accumulator] [Flags: NCVZ]
	and [$1E.b]		; 27 1E ; AND accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $6B.b,X		; 74 6B ; Store zero to $6B.b,X [Reads: X Index]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp [$77.b],Y		; D7 77 ; Compare accumulator (long indexed) [$77.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor ($00.b)		; 52 00 ; Exclusive OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F7E8.w		; E0 E8 F7 ; Compare #$F7E8.w with X register [Reads: X Index] [Flags: NCZ]
	trb $6CEF.w		; 1C EF 6C ; Test and reset bits $6CEF.w [Reads: Accumulator] [Flags: Z]
	sbc $3AFFF2.l,X		; FF F2 FF 3A ; Subtract with carry (long,X) $3AFFF2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$EF1F.w		; E0 1F EF ; Compare #$EF1F.w with X register [Reads: X Index] [Flags: NCZ]
	cmp $3BF3EF.l,X		; DF EF F3 3B ; Compare accumulator (long,X) $3BF3EF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	cpy #$0023.w		; C0 23 00 ; Compare #$0023.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$E02B.w		; E0 2B E0 ; Compare #$E02B.w with X register [Reads: X Index] [Flags: NCZ]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$30C8.w		; E0 C8 30 ; Compare #$30C8.w with X register [Reads: X Index] [Flags: NCZ]
	pea $8AC8.w		; F4 C8 8A ; Push absolute address $8AC8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	pea $F40A.w		; F4 0A F4 ; Push absolute address $F40A.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$C8D0.w		; E0 D0 C8 ; Compare #$C8D0.w with X register [Reads: X Index] [Flags: NCZ]
	pea $0A8A.w		; F4 8A 0A ; Push absolute address $0A8A.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	bit $7E00.w,X		; 3C 00 7E ; Test bits $7E00.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $266F.w,X		; 3C 6F 26 ; Test bits $266F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc $6021.w		; 6D 21 60 ; Add $6021.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	jsr $1030.w		; 20 30 10 ; Jump to subroutine at $1030.w [Writes: Stack Pointer] [Flow: call]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $423C06.l,X		; 1F 06 3C 42 ; Logical OR long $423C06.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($52.b),Y		; 51 52 ; Exclusive OR accumulator with memory ($52.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $19342F.l,X		; 5F 2F 34 19 ; Exclusive OR accumulator with memory (long,X) $19342F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $80.b,S		; 03 80 ; OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $45		; 80 45 ; Branch always to $80, $45 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	sta $56.b,S		; 83 56 ; Store accumulator (stack relative) $56.b,S [Reads: Stack Pointer, Accumulator]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	jsl $400080.l		; 22 80 00 40 ; Jump to subroutine long $400080.l [Writes: Stack Pointer] [Flow: call]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0003.w		; 09 03 00 ; Logical OR #$0003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $002207.l,X		; 1F 07 22 00 ; Logical OR long $002207.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$B843.w		; E0 43 B8 ; Compare #$B843.w with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $23		; B0 23 ; Branch if carry set to $B0, $23 [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$4810.w		; E0 10 48 ; Compare #$4810.w with X register [Reads: X Index] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $3F093F.l		; 0F 3F 09 3F ; OR accumulator with memory (long) $3F093F.l [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lsr $3F.b		; 46 3F ; Logical shift right $3F.b [Reads: Direct Page] [Flags: NCZ]
	ora $380001.l		; 0F 01 00 38 ; OR accumulator with memory (long) $380001.l [Writes: Accumulator] [Flags: NZ]
	and $3F.b		; 25 3F ; Logical AND $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $E0.b		; 06 E0 ; Arithmetic shift left $E0.b [Reads: Direct Page] [Flags: NCZ]
	cpx #$FCFC.w		; E0 FC FC ; Compare #$FCFC.w with X register [Reads: X Index] [Flags: NCZ]
	cpx $FC.b		; E4 FC ; Compare $FC.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	pea $FC22.w		; F4 22 FC ; Push absolute address $FC22.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jsl $E00000.l		; 22 00 00 E0 ; Jump to subroutine long $E00000.l [Writes: Stack Pointer] [Flow: call]
	and $FC.b,S		; 23 FC ; AND accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$4500.w		; 29 00 45 ; Logical AND #$4500.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $002B03.l		; 22 03 2B 00 ; Jump to subroutine long $002B03.l [Writes: Stack Pointer] [Flow: call]
	and $80.b,S		; 23 80 ; AND accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$8021.w		; E0 21 80 ; Compare #$8021.w with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $07		; 80 07 ; Branch always to $80, $07 [Flow: branch]
	brk $59.b		; 00 59 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FB.b,X)		; 01 FB ; Logical OR ($FB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sbc $1BFF3C.l,X		; FF 3C FF 1B ; Subtract with carry (long,X) $1BFF3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $007C14.l,X		; FF 14 7C 00 ; Subtract with carry (long,X) $007C14.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0708.w,Y		; 79 08 07 ; Add $0708.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $C3A4.w,X		; 5E A4 C3 ; Logical shift right $C3A4.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$EF.b]		; E7 EF ; Subtract with carry (long) [$EF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $00E077.l,X		; 7F 77 E0 00 ; Add long $00E077.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $83FFE0.l,X		; FF E0 FF 83 ; Subtract with carry (long,X) $83FFE0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF227F.l,X		; FF 7F 22 FF ; Subtract with carry (long,X) $FF227F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$F0.b]		; 07 F0 ; OR accumulator with memory (long) [$F0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $609F40.l,X		; FF 40 9F 60 ; Subtract with carry (long,X) $609F40.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$7F1F.w		; E0 1F 7F ; Compare #$7F1F.w with X register [Reads: X Index] [Flags: NCZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$7124.w		; E0 24 71 ; Compare #$7124.w with X register [Reads: X Index] [Flags: NCZ]
	rol $3C73.w		; 2E 73 3C ; Rotate left $3C73.w [Flags: NCZ]
	eor ($3E.b,X)		; 41 3E ; Exclusive OR accumulator with memory ($3E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $3F0F38.l,X		; 1F 38 0F 3F ; Logical OR long $3F0F38.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $000606.l,X		; 1F 06 06 00 ; Logical OR long $000606.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sei		; 78 ; Set interrupt disable flag [Flags: I]
	rol $1F3F.w,X		; 3E 3F 1F ; Rotate left $1F3F.w,X [Reads: X Index] [Flags: NCZ]
	asl $F9.b		; 06 F9 ; Arithmetic shift left $F9.b [Reads: Direct Page] [Flags: NCZ]
	adc [$E8.b],Y		; 77 E8 ; Add with carry (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$EF.b],Y		; 17 EF ; OR accumulator with memory (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($FC.b)		; 72 FC ; Add with carry (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sty $78.b		; 84 78 ; Store Y register to $78.b [Reads: Y Index]
	clv		; B8 ; Clear overflow flag [Flags: V]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$0022.w		; C0 22 00 ; Compare #$0022.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $79.b		; 06 79 ; Arithmetic shift left $79.b [Reads: Direct Page] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $380472.l,X		; 3F 72 04 38 ; AND accumulator with memory (long,X) $380472.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$AD83.w		; C0 83 AD ; Compare #$AD83.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$2580.w		; C0 80 25 ; Compare #$2580.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $47.b		; 00 47 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $074300.l		; 0F 00 43 07 ; OR accumulator with memory (long) $074300.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $07070F.l		; 0F 0F 07 07 ; OR accumulator with memory (long) $07070F.l [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	trb $FA.b		; 14 FA ; Test and reset bits $FA.b [Reads: Accumulator] [Flags: Z]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	mvp $F8,$00		; 44 00 F8 ; Move block positive $F8,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $F0.b		; 02 F0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $CA0900.l		; 22 00 09 CA ; Jump to subroutine long $CA0900.l [Writes: Stack Pointer] [Flow: call]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jsr ($F8F8.w,X)		; FC F8 F8 ; Jump to subroutine indirect indexed ($F8F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $44.b		; 06 44 ; Arithmetic shift left $44.b [Reads: Direct Page] [Flags: NCZ]
	ora $0C0200.l,X		; 1F 00 02 0C ; Logical OR long $0C0200.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1F440A.l,X		; 1F 0A 44 1F ; Logical OR long $1F440A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1F22.w,Y		; 19 22 1F ; OR accumulator with memory $1F22.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$1D35.w		; E0 35 1D ; Compare #$1D35.w with X register [Reads: X Index] [Flags: NCZ]
	ora $7F1D1F.l,X		; 1F 1F 1D 7F ; Logical OR long $7F1D1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	ora $3F4FBF.l		; 0F BF 4F 3F ; OR accumulator with memory (long) $3F4FBF.l [Writes: Accumulator] [Flags: NZ]
	cmp [$FF.b]		; C7 FF ; Compare accumulator (long) [$FF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $DF.b,S		; 03 DF ; OR accumulator with stack relative $DF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($9F.b,X)		; 21 9F ; Logical AND ($9F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc ($FD.b,X)		; 61 FD ; Add with carry ($FD.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $7F.b		; 02 7F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($9E9E.w,X)		; FC 9E 9E ; Jump to subroutine indirect indexed ($9E9E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $1FFF.w,X		; FD FF 1F ; Subtract with carry $1FFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FCFCFF.l,X		; FF FF FC FC ; Subtract with carry (long,X) $FCFCFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpx #$F8E0.w		; E0 E0 F8 ; Compare #$F8E0.w with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($FEFC.w,X)		; FC FC FE ; Jump to subroutine indirect indexed ($FEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $00E0.w,X		; FE E0 00 ; Increment memory $00E0.w,X [Reads: X Index] [Flags: NZ]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $010307.l,X		; 1F 07 03 01 ; Logical OR long $010307.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $43B8.w,X		; BC B8 43 ; Load Y register $43B8.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	trb $4718.w		; 1C 18 47 ; Test and reset bits $4718.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $04		; 10 04 ; Branch if plus to $10, $04 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $44		; 30 44 ; Branch if minus to $30, $44 [Flow: branch]
	cpx $E4.b		; E4 E4 ; Compare $E4.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	and $E8.b,S		; 23 E8 ; AND accumulator with stack relative $E8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0FC8.w		; 0C C8 0F ; Test and set bits $0FC8.w [Reads: Accumulator] [Flags: Z]
	and $093F0B.l,X		; 3F 0B 3F 09 ; AND accumulator with memory (long,X) $093F0B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $013F0F.l,X		; 3F 0F 3F 01 ; AND accumulator with memory (long,X) $013F0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $230700.l,X		; 3F 00 07 23 ; AND accumulator with memory (long,X) $230700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $223100.l,X		; 3F 00 31 22 ; AND accumulator with memory (long,X) $223100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($F409.w,X)		; FC 09 F4 ; Jump to subroutine indirect indexed ($F409.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($FCE4.w,X)		; FC E4 FC ; Jump to subroutine indirect indexed ($FCE4.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $04FC.w,X		; 3C FC 04 ; Test bits $04FC.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jsr ($1C00.w,X)		; FC 00 1C ; Jump to subroutine indirect indexed ($1C00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $FC.b		; 24 FC ; Test bits $FC.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $3C.b		; 02 3C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	eor [$01.b]		; 47 01 ; Exclusive OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$0180.w		; 29 80 01 ; Logical AND #$0180.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $80.b		; 24 80 ; Test bits $80.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $41E000.l		; 22 00 E0 41 ; Jump to subroutine long $41E000.l [Writes: Stack Pointer] [Flow: call]
	eor $8F18.w,Y		; 59 18 8F ; Exclusive OR accumulator with memory $8F18.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $01B2.w		; 0C B2 01 ; Test and set bits $01B2.w [Reads: Accumulator] [Flags: Z]
	.db $82, $01, $43		; 82 01 43 ; Branch always long to $82, $01, $43 [Flow: branch]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0E3F.w,X		; 1E 3F 0E ; Arithmetic shift left $0E3F.w,X [Reads: X Index] [Flags: NCZ]
	and $F36710.l,X		; 3F 10 67 F3 ; AND accumulator with memory (long,X) $F36710.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dec $7DFE.w		; CE FE 7D ; Decrement $7DFE.w [Flags: NZ]
	and ($31.b,X)		; 21 31 ; Logical AND ($31.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $F7C03F.l,X		; 3F 3F C0 F7 ; AND accumulator with memory (long,X) $F7C03F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sta [$7C.b]		; 87 7C ; Store accumulator (long) [$7C.b] [Reads: Direct Page, Accumulator]
	sta $FF.b,S		; 83 FF ; Store accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and [$C6.b],Y		; 37 C6 ; AND accumulator with memory (long indexed) [$C6.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $00FFC2.l,X		; 3F C2 FF 00 ; AND accumulator with memory (long,X) $00FFC2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $7F7FFF.l,X		; 3F FF 7F 7F ; AND accumulator with memory (long,X) $7F7FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$39.b],Y		; F7 39 ; Subtract with carry (long indexed) [$39.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $07FF.w,X		; 3D FF 07 ; AND accumulator with memory $07FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $15.b,S		; 03 15 ; OR accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $170F13.l		; 0F 13 0F 17 ; OR accumulator with memory (long) $170F13.l [Writes: Accumulator] [Flags: NZ]
	ora $12071B.l		; 0F 1B 07 12 ; OR accumulator with memory (long) $12071B.l [Writes: Accumulator] [Flags: NZ]
	ora $070F17.l		; 0F 17 0F 07 ; OR accumulator with memory (long) $070F17.l [Writes: Accumulator] [Flags: NZ]
	ora $E01722.l		; 0F 22 17 E0 ; OR accumulator with memory (long) $E01722.l [Writes: Accumulator] [Flags: NZ]
	and [$1B.b]		; 27 1B ; AND accumulator with memory (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($17.b,S),Y		; 13 17 ; OR accumulator (stack relative indirect indexed) ($17.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$6000.w		; C0 00 60 ; Compare #$6000.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	cpy #$80F0.w		; C0 F0 80 ; Compare #$80F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sty $0670.w		; 8C 70 06 ; Store Y register to $0670.w [Reads: Y Index]
	jsr ($FC1E.w,X)		; FC 1E FC ; Jump to subroutine indirect indexed ($FC1E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and ($FC.b)		; 32 FC ; AND accumulator with memory (indirect) ($FC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$F0E0.w		; C0 E0 F0 ; Compare #$F0E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $FC		; F0 FC ; Branch if equal to $F0, $FC [Flow: branch]
	inc $F2FE.w,X		; FE FE F2 ; Increment memory $F2FE.w,X [Reads: X Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr $5E34.w		; 4E 34 5E ; Logical shift right $5E34.w [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	bit $1818.w,X		; 3C 18 18 ; Test bits $1818.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $3418.w,X		; 1D 18 34 ; OR accumulator with memory $3418.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: NZ]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: NZ]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $837FBF.l,X		; DF BF 7F 83 ; Compare accumulator (long,X) $837FBF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $62, $00, $01		; 62 00 01 ; Push effective relative address $62, $00, $01 [Writes: Stack Pointer]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $04.b,S		; 43 04 ; Exclusive OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$09.b],Y		; 57 09 ; Exclusive OR accumulator with memory (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $000E0E.l		; 0F 0E 0E 00 ; OR accumulator with memory (long) $000E0E.l [Writes: Accumulator] [Flags: NZ]
	brk $E3.b		; 00 E3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1B.b,S		; E3 1B ; Subtract stack-relative $1B.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc [$98.b],Y		; F7 98 ; Subtract with carry (long indexed) [$98.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F2BF54.l,X		; FF 54 BF F2 ; Subtract with carry (long,X) $F2BF54.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $0003BD.l,X		; 5F BD 03 00 ; Exclusive OR accumulator with memory (long,X) $0003BD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F4.b,S		; E3 F4 ; Subtract stack-relative $F4.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	eor $1FF1B3.l,X		; 5F B3 F1 1F ; Exclusive OR accumulator with memory (long,X) $1FF1B3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0A1F02.l,X		; 1F 02 1F 0A ; Logical OR long $0A1F02.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $061F0E.l,X		; 1F 0E 1F 06 ; Logical OR long $061F0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0C1F0A.l,X		; 1F 0A 1F 0C ; Logical OR long $0C1F0A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1D1D06.l		; 0F 06 1D 1D ; OR accumulator with memory (long) $1D1D06.l [Writes: Accumulator] [Flags: NZ]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1F1D.w,Y		; 19 1D 1F ; OR accumulator with memory $1F1D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $63629D.l		; 0F 9D 62 63 ; OR accumulator with memory (long) $63629D.l [Writes: Accumulator] [Flags: NZ]
	stz $847B.w		; 9C 7B 84 ; Store zero to $847B.w
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy $C3.b		; C4 C3 ; Compare $C3.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	bit $00FF.w,X		; 3C FF 00 ; Test bits $00FF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $4B43.w,X		; 9D 43 4B ; Store accumulator to $4B43.w,X [Reads: Accumulator, X Index]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	eor $CF.b,S		; 43 CF ; Exclusive OR accumulator with stack relative $CF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FEFEFF.l,X		; FF FF FE FE ; Subtract with carry (long,X) $FEFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $FF.b		; 26 FF ; Rotate left $FF.b [Reads: Direct Page] [Flags: NCZ]
	eor $7F.b		; 45 7F ; Exclusive OR $7F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $013C01.l,X		; FF 01 3C 01 ; Subtract with carry (long,X) $013C01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $802200.l		; 22 00 22 80 ; Jump to subroutine long $802200.l [Writes: Stack Pointer] [Flow: call]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $30.b,S		; 43 30 ; Exclusive OR accumulator with stack relative $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $3413.w		; 20 13 34 ; Jump to subroutine at $3413.w [Writes: Stack Pointer] [Flow: call]
	jsr $243E.w		; 20 3E 24 ; Jump to subroutine at $243E.w [Writes: Stack Pointer] [Flow: call]
	rol $772C.w,X		; 3E 2C 77 ; Rotate left $772C.w,X [Reads: X Index] [Flags: NCZ]
	mvn $AC,$EF		; 54 EF AC ; Move block negative $AC,$EF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	dec $D058.w,X		; DE 58 D0 ; Decrement memory $D058.w,X [Reads: X Index] [Flags: NZ]
	.db $D0, $D4		; D0 D4 ; Branch if not equal to $D0, $D4 [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp ($AB.b)		; D2 AB ; Compare accumulator (indirect) ($AB.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	eor ($A6.b,S),Y		; 53 A6 ; XOR accumulator (stack relative indirect indexed) ($A6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $44.b		; 02 44 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $002203.l		; 0F 03 22 00 ; OR accumulator with memory (long) $002203.l [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and #$0500.w		; 29 00 05 ; Logical AND #$0500.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$E0C0.w		; C0 C0 E0 ; Compare #$E0C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$F0D0.w		; E0 D0 F0 ; Compare #$F0D0.w with X register [Reads: X Index] [Flags: NCZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $E0C0.w,X		; 1E C0 E0 ; Arithmetic shift left $E0C0.w,X [Reads: X Index] [Flags: NCZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$14.b]		; 07 14 ; OR accumulator with memory (long) [$14.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $391D22.l		; 0F 22 1D 39 ; OR accumulator with memory (long) $391D22.l [Writes: Accumulator] [Flags: NZ]
	asl $5C.b		; 06 5C ; Arithmetic shift left $5C.b [Reads: Direct Page] [Flags: NCZ]
	and $013F6E.l,X		; 3F 6E 3F 01 ; AND accumulator with memory (long,X) $013F6E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	trb $22.b		; 14 22 ; Test and reset bits $22.b [Reads: Accumulator] [Flags: Z]
	and $7E5C.w,Y		; 39 5C 7E ; AND accumulator with memory $7E5C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $E643.w		; F4 43 E6 ; Push absolute address $E643.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora ($46.b),Y		; 11 46 ; OR accumulator with memory ($46.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	asl $FA.b		; 06 FA ; Arithmetic shift left $FA.b [Reads: Direct Page] [Flags: NCZ]
	sty $F874.w		; 8C 74 F8 ; Store Y register to $F874.w [Reads: Y Index]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx $E4.b		; E4 E4 ; Compare $E4.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	mvp $88,$04		; 44 04 88 ; Move block positive $88,$04 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $7F431A.l,X		; 3F 1A 43 7F ; AND accumulator with memory (long,X) $7F431A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $173F44.l		; 2F 44 3F 17 ; AND accumulator with memory (long) $173F44.l [Writes: Accumulator] [Flags: NZ]
	tsb $7F08.w		; 0C 08 7F ; Test and set bits $7F08.w [Reads: Accumulator] [Flags: Z]
	ora [$7F.b],Y		; 17 7F ; OR accumulator with memory (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $2F5F5F.l,X		; 3F 5F 5F 2F ; AND accumulator with memory (long,X) $2F5F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $7F7837.l		; 2F 37 78 7F ; AND accumulator with memory (long) $7F7837.l [Writes: Accumulator] [Flags: NZ]
	eor $9F.b,S		; 43 9F ; Exclusive OR accumulator with stack relative $9F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $98E7.w		; 1C E7 98 ; Test and reset bits $98E7.w [Reads: Accumulator] [Flags: Z]
	cpx $9B.b		; E4 9B ; Compare $9B.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	and [$F8.b]		; 27 F8 ; AND accumulator with memory (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$FE.b]		; 67 FE ; Add with carry (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $9F.b		; 00 9F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $D8E4E7.l,X		; 9F E7 E4 D8 ; Store accumulator (long,X) $D8E4E7.l,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($0BFE.w,X)		; 7C FE 0B ; Jump indirect indexed to ($0BFE.w,X) [Reads: X Index] [Flow: jump]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora #$0204.w		; 09 04 02 ; Logical OR #$0204.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FCE2FC.l		; 22 FC E2 FC ; Jump to subroutine long $FCE2FC.l [Writes: Stack Pointer] [Flow: call]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$26E0.w		; E0 E0 26 ; Compare #$26E0.w with X register [Reads: X Index] [Flags: NCZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 8
	sep #$E2		; E2 E2
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	cpx #$0022.w		; E0 22 00 ; Compare #$0022.w with X register [Reads: X Index] [Flags: NCZ]
	asl $38.b,X		; 16 38 ; Arithmetic shift left $38.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $82, $7C, $E6		; 82 7C E6 ; Branch always long to $82, $7C, $E6 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $2C7E66.l,X		; FF 66 7E 2C ; Subtract with carry (long,X) $2C7E66.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $1808.w,X		; 3C 08 18 ; Test bits $1808.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp ($6618.w,X)		; 7C 18 66 ; Jump indirect indexed to ($6618.w,X) [Reads: X Index] [Flow: jump]
	bit $9808.w		; 2C 08 98 ; Test bits $9808.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	eor [$03.b]		; 47 03 ; Exclusive OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0000.w		; 2E 00 00 ; Rotate left $0000.w [Flags: NCZ]
	ora [$26.b]		; 07 26 ; OR accumulator with memory (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $AE21.w,X		; FE 21 AE ; Increment memory $AE21.w,X [Reads: X Index] [Flags: NZ]
	adc ($B0.b),Y		; 71 B0 ; Add with carry ($B0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $313F48.l,X		; 7F 48 3F 31 ; Add long $313F48.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1F053F.l		; 0F 3F 05 1F ; OR accumulator with memory (long) $1F053F.l [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $234B.w,X		; BD 4B 23 ; Load $234B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $0F031F.l		; 2F 1F 03 0F ; AND accumulator with memory (long) $0F031F.l [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $240207.l		; 0F 07 02 24 ; OR accumulator with memory (long) $240207.l [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7FCF7C.l,X		; FF 7C CF 7F ; Subtract with carry (long,X) $7FCF7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $637F.w		; CD 7F 63 ; Compare $637F.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and $3F3E67.l,X		; 3F 67 3E 3F ; AND accumulator with memory (long,X) $3F3E67.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $221E.w		; 1C 1E 22 ; Test and reset bits $221E.w [Reads: Accumulator] [Flags: Z]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7F7F0F.l,X		; FF 0F 7F 7F ; Subtract with carry (long,X) $7F7F0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FF001E.l,X		; 3F 1E 00 FF ; AND accumulator with memory (long,X) $FF001E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $FF9FFF.l,X		; 3F FF 9F FF ; AND accumulator with memory (long,X) $FF9FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $BF2FFF.l		; 6F FF 2F BF ; Add with carry (long) $BF2FFF.l [Writes: Accumulator] [Flags: NCVZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $28.b,S		; 83 28 ; Store accumulator (stack relative) $28.b,S [Reads: Stack Pointer, Accumulator]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$FC43.w		; E0 43 FC ; Compare #$FC43.w with X register [Reads: X Index] [Flags: NCZ]
	cpy #$F804.w		; C0 04 F8 ; Compare #$F804.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $783C.w,X		; 3C 3C 78 ; Test bits $783C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $03.b,S		; 43 03 ; Exclusive OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03FA83.l		; 0F 83 FA 03 ; OR accumulator with memory (long) $03FA83.l [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $270023.l		; 0F 23 00 27 ; OR accumulator with memory (long) $270023.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	.db $D0, $F0		; D0 F0 ; Branch if not equal to $D0, $F0 [Flow: branch]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $F0.b		; 24 F0 ; Test bits $F0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $7699.w,X		; 7E 99 76 ; Rotate right $7699.w,X [Reads: X Index] [Flags: NCZ]
	cmp $AB36.w,Y		; D9 36 AB ; Compare accumulator $AB36.w,Y [Reads: Y Index] [Flags: NCZ]
	lsr $D6.b,X		; 56 D6 ; Logical shift right $D6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	cpx #$6040.w		; E0 40 60 ; Compare #$6040.w with X register [Reads: X Index] [Flags: NCZ]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $E0F0D6.l,X		; BF D6 F0 E0 ; Load long $E0F0D6.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $2E		; 80 2E ; Branch always to $80, $2E [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $26		; 80 26 ; Branch always to $80, $26 [Flow: branch]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $387F3F.l,X		; 7F 3F 7F 38 ; Add long $387F3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $30387F.l,X		; 7F 7F 38 30 ; Add long $30387F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $C7F8.w		; 0C F8 C7 ; Test and set bits $C7F8.w [Reads: Accumulator] [Flags: Z]
	sbc $1A.b		; E5 1A ; Subtract $1A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $030704.l		; 0F 04 07 03 ; OR accumulator with memory (long) $030704.l [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $1F3F.w,X		; FD 3F 1F ; Subtract with carry $1F3F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $000307.l		; 0F 07 03 00 ; OR accumulator with memory (long) $000307.l [Writes: Accumulator] [Flags: NZ]
	sbc $000008.l,X		; FF 08 00 00 ; Subtract with carry (long,X) $000008.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	bit $0443.w		; 2C 43 04 ; Test bits $0443.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	jmp $0C57E0.l		; 5C E0 57 0C ; Jump long to $0C57E0.l [Flow: jump]
	lsr $000E.w,X		; 5E 0E 00 ; Logical shift right $000E.w,X [Reads: X Index] [Flags: NCZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$2B.b]		; 07 2B ; OR accumulator with memory (long) [$2B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($71.b,S),Y		; 73 71 ; Add with carry (stack relative indirect indexed) ($71.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$E000.w		; C0 00 E0 ; Compare #$E000.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$0020.w		; C0 20 00 ; Compare #$0020.w with Y register [Reads: Y Index] [Flags: NCZ]
	pei ($00.b)		; D4 00 ; Push effective indirect address ($00.b) [Reads: Direct Page] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $3A		; 10 3A ; Branch if plus to $10, $3A [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	cpy #$E020.w		; C0 20 E0 ; Compare #$E020.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $3E.b,X		; 34 3E ; Test bits $3E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $00CE.w		; EE CE 00 ; Increment $00CE.w [Flags: NZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $D0, $60		; D0 60 ; Branch if not equal to $D0, $60 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $30, $74		; 30 74 ; Branch if minus to $30, $74 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	bit $3B20.w,X		; 3C 20 3B ; Test bits $3B20.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp ($3E3C.w,X)		; 7C 3C 3E ; Jump indirect indexed to ($3E3C.w,X) [Reads: X Index] [Flow: jump]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: NCZ]
	tsb $1A2F.w		; 0C 2F 1A ; Test and set bits $1A2F.w [Reads: Accumulator] [Flags: Z]
	and $DE06.w,X		; 3D 06 DE ; AND accumulator with memory $DE06.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	ora $3F3F1E.l		; 0F 1E 3F 3F ; OR accumulator with memory (long) $3F3F1E.l [Writes: Accumulator] [Flags: NZ]
	adc $070000.l,X		; 7F 00 00 07 ; Add long $070000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $1F,$00		; 44 00 1F ; Move block positive $1F,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $070000.l,X		; 5F 00 00 07 ; Exclusive OR accumulator with memory (long,X) $070000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $841F1F.l		; 0F 1F 1F 84 ; OR accumulator with memory (long) $841F1F.l [Writes: Accumulator] [Flags: NZ]
	eor $0200.w,X		; 5D 00 02 ; Exclusive OR accumulator with memory $0200.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $F8,$00		; 44 00 F8 ; Move block positive $F8,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0080FA.l,X		; 3F FA 80 00 ; AND accumulator with memory (long,X) $0080FA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $D0, $E8		; D0 E8 ; Branch if not equal to $D0, $E8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($7EFC.w,X)		; FC FC 7E ; Jump to subroutine indirect indexed ($7EFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr ($5B00.w,X)		; FC 00 5B ; Jump to subroutine indirect indexed ($5B00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $57.b,S		; 03 57 ; OR accumulator with stack relative $57.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$CCB0.w		; E0 B0 CC ; Compare #$CCB0.w with X register [Reads: X Index] [Flags: NCZ]
	adc [$3B.b]		; 67 3B ; Add with carry (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $003F02.l		; 0F 02 3F 00 ; OR accumulator with memory (long) $003F02.l [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpy #$10EA.w		; C0 EA 10 ; Compare #$10EA.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($E6.b,S),Y		; 33 E6 ; AND accumulator (stack relative indirect indexed) ($E6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$001A]		; DC 1A 00 ; Jump long indirect [$001A] [Flow: jump]
	asl $310E.w,X		; 1E 0E 31 ; Arithmetic shift left $310E.w,X [Reads: X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	bit $44.b		; 24 44 ; Test bits $44.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $0742.w,X		; 3D 42 07 ; AND accumulator with memory $0742.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($3C.b)		; 52 3C ; Exclusive OR accumulator with memory (indirect) ($3C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora $1E27.w,X		; 1D 27 1E ; OR accumulator with memory $1E27.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($3C.b),Y		; 31 3C ; AND accumulator with memory ($3C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $7F017E.l		; 22 7E 01 7F ; Jump to subroutine long $7F017E.l [Writes: Stack Pointer] [Flow: call]
	and $140022.l,X		; 3F 22 00 14 ; AND accumulator with memory (long,X) $140022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$20C0.w		; C0 C0 20 ; Compare #$20C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy #$D050.w		; A0 50 D0 ; Load #$D050.w into Y register [Writes: Y Index] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cpx #$D498.w		; E0 98 D4 ; Compare #$D498.w with X register [Reads: X Index] [Flags: NCZ]
	ldy $D42C.w		; AC 2C D4 ; Load $D42C.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2850.w		; 20 50 28 ; Jump to subroutine at $2850.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $87D4.w		; AC D4 87 ; Load $87D4.w into Y register [Writes: Y Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0044.w		; 20 44 00 ; Jump to subroutine at $0044.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sta $70.b,S		; 83 70 ; Store accumulator (stack relative) $70.b,S [Reads: Stack Pointer, Accumulator]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7F7F3F.l,X		; 3F 3F 7F 7F ; AND accumulator with memory (long,X) $7F7F3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$7B83.w		; E0 83 7B ; Compare #$7B83.w with X register [Reads: X Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$10.b		; 29 10 ; Logical AND #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $6C18.w		; 9C 18 6C ; Store zero to $6C18.w
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $0E0C.w		; 2E 0C 0E ; Rotate left $0E0C.w [Flags: NCZ]
	tsb $E000.w		; 0C 00 E0 ; Test and set bits $E000.w [Reads: Accumulator] [Flags: Z]
	.db $B0, $E8		; B0 E8 ; Branch if carry set to $B0, $E8 [Flow: branch]
	cpx $94.b		; E4 94 ; Compare $94.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp ($F2.b)		; D2 F2 ; Compare accumulator (indirect) ($F2.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1C3703.l,X		; 1F 03 37 1C ; Logical OR long $1C3703.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $006320.l,X		; 7F 20 63 00 ; Add long $006320.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cmp ($00.b,X)		; C1 00 ; Compare accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	sbc $00.b,S		; E3 00 ; Subtract stack-relative $00.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $FF7F7F.l,X		; 3F 7F 7F FF ; AND accumulator with memory (long,X) $FF7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $8480BE.l,X		; FF BE 80 84 ; Subtract with carry (long,X) $8480BE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($98.b),Y		; 11 98 ; OR accumulator with memory ($98.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $FC60.w		; 9C 60 FC ; Store zero to $FC60.w
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F4		; 80 F4 ; Branch always to $80, $F4 [Flow: branch]
	.db $90, $80		; 90 80 ; Branch if carry clear to $90, $80 [Flow: branch]
	cpx #$F8F0.w		; E0 F0 F8 ; Compare #$F8F0.w with X register [Reads: X Index] [Flags: NCZ]
	jsr ($7CFC.w,X)		; FC FC 7C ; Jump to subroutine indirect indexed ($7CFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jmp ($0029.w)		; 6C 29 00 ; Jump indirect to ($0029.w) [Flow: jump]
	ora $38.b		; 05 38 ; Logical OR $38.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $002410.l		; EF 10 24 00 ; Subtract with carry (long) $002410.l [Writes: Accumulator] [Flags: NCVZ]
	cop $38.b		; 02 38 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $002998.l		; 4F 98 29 00 ; Exclusive OR accumulator with memory (long) $002998.l [Writes: Accumulator] [Flags: NZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $F21C.w		; 0E 1C F2 ; Arithmetic shift left $F21C.w [Flags: NCZ]
	ora $276F.w,Y		; 19 6F 27 ; OR accumulator with memory $276F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $0D1F19.l,X		; 3F 19 1F 0D ; AND accumulator with memory (long,X) $0D1F19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $1E04.w,X		; 1E 04 1E ; Arithmetic shift left $1E04.w,X [Reads: X Index] [Flags: NCZ]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($58.b,S),Y		; 13 58 ; OR accumulator (stack relative indirect indexed) ($58.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $1312.w		; 20 12 13 ; Jump to subroutine at $1312.w [Writes: Stack Pointer] [Flow: call]
	ora ($08.b),Y		; 11 08 ; OR accumulator with memory ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	inc $E4.b,X		; F6 E4 ; Increment memory $E4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jsr ($F898.w,X)		; FC 98 F8 ; Jump to subroutine indirect indexed ($F898.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $B0, $78		; B0 78 ; Branch if carry set to $B0, $78 [Flow: branch]
	jsr $4078.w		; 20 78 40 ; Jump to subroutine at $4078.w [Writes: Stack Pointer] [Flow: call]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $48.b		; 04 48 ; Test and set bits $48.b [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	jsr $3A7D.w		; 20 7D 3A ; Jump to subroutine at $3A7D.w [Writes: Stack Pointer] [Flow: call]
	ror $7E39.w,X		; 7E 39 7E ; Rotate right $7E39.w,X [Reads: X Index] [Flags: NCZ]
	and ($7F.b,X)		; 21 7F ; Logical AND ($7F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($7E.b)		; 12 7E ; OR accumulator with memory (indirect) ($7E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($37.b,S),Y		; 33 37 ; AND accumulator (stack relative indirect indexed) ($37.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$0D.b		; 09 0D ; Logical OR #$0D.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $7F1400.l		; 22 00 14 7F ; Jump to subroutine long $7F1400.l [Writes: Stack Pointer] [Flow: call]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ror $77.b,X		; 76 77 ; Rotate right $77.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$3F.b],Y		; 77 3F ; Add with carry (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $BF00.w		; 0D 00 BF ; Logical OR $BF00.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $9C7F.w,Y		; 59 7F 9C ; Exclusive OR accumulator with memory $9C7F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $BE8C.w,X		; 7E 8C BE ; Rotate right $BE8C.w,X [Reads: X Index] [Flags: NCZ]
	jmp $C43E.w		; 4C 3E C4 ; Jump to $C43E.w [Flow: jump]
	cpx $F0D0.w		; EC D0 F0 ; Compare $F0D0.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $FE1200.l		; 22 00 12 FE ; Jump to subroutine long $FE1200.l [Writes: Stack Pointer] [Flow: call]
	eor $EEEE6E.l,X		; 5F 6E EE EE ; Exclusive OR accumulator with memory (long,X) $EEEE6E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($00F0.w,X)		; FC F0 00 ; Jump to subroutine indirect indexed ($00F0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $307E21.l,X		; 7F 21 7E 30 ; Add long $307E21.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	tsb $030F.w		; 0C 0F 03 ; Test and set bits $030F.w [Reads: Accumulator] [Flags: Z]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $030C13.l		; 2F 13 0C 03 ; AND accumulator with memory (long) $030C13.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $7E84.w,X		; FE 84 7E ; Increment memory $7E84.w,X [Reads: X Index] [Flags: NZ]
	tsb $085C.w		; 0C 5C 08 ; Test and set bits $085C.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$24C0.w		; C0 C0 24 ; Compare #$24C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp ($F4.b)		; D2 F4 ; Compare accumulator (indirect) ($F4.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $5CE740.l,X		; FF 40 E7 5C ; Subtract with carry (long,X) $5CE740.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $227F5F.l,X		; FF 5F 7F 22 ; Subtract with carry (long,X) $227F5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $BFBF.w,X		; BC BF BF ; Load Y register $BFBF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc $060023.l,X		; 7F 23 00 06 ; Add long $060023.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3AE702.l,X		; FF 02 E7 3A ; Subtract with carry (long,X) $3AE702.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $22FEFA.l,X		; FF FA FE 22 ; Subtract with carry (long,X) $22FEFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $3D0300.l		; 22 00 03 3D ; Jump to subroutine long $3D0300.l [Writes: Stack Pointer] [Flow: call]
	sbc $FEFD.w,X		; FD FD FE ; Subtract with carry $FEFD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $39133B.l,X		; 1F 3B 13 39 ; Logical OR long $39133B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($43.b),Y		; 11 43 ; OR accumulator with memory ($43.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $20		; 70 20 ; Branch if overflow set to $70, $20 [Flow: branch]
	eor $E0.b,S		; 43 E0 ; Exclusive OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora ($40.b),Y		; 11 40 ; OR accumulator with memory ($40.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and #$50.b		; 29 50 ; Logical AND #$50.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $50, $A0		; 50 A0 ; Branch if overflow clear to $50, $A0 [Flow: branch]
	ldy #$5440.w		; A0 40 54 ; Load #$5440.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy $FC04.w		; AC 04 FC ; Load $FC04.w into Y register [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,S		; 03 AC ; OR accumulator with stack relative $AC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($60F8.w,X)		; FC F8 60 ; Jump to subroutine indirect indexed ($60F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $55.b		; 00 55 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $3F0F7F.l		; 22 7F 0F 3F ; Jump to subroutine long $3F0F7F.l [Writes: Stack Pointer] [Flow: call]
	ora $000007.l,X		; 1F 07 00 00 ; Logical OR long $000007.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $5E0C.w		; 8E 0C 5E ; Store X register to $5E0C.w [Reads: X Index]
	trb $1C1E.w		; 1C 1E 1C ; Test and reset bits $1C1E.w [Reads: Accumulator] [Flags: Z]
	bit $F838.w,X		; 3C 38 F8 ; Test bits $F838.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpx #$24E0.w		; E0 E0 24 ; Compare #$24E0.w with X register [Reads: X Index] [Flags: NCZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($E2.b)		; F2 E2 ; Subtract with carry (indirect) ($E2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sep #$C4		; E2 C4 ; Set processor status bits #$C4 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$0000.w		; E0 00 00 ; Compare #$0000.w with X register [Reads: X Index] [Flags: NCZ]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda [$00.b],Y		; B7 00 ; Load accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta ($01.b,X)		; 81 01 ; Store accumulator ($01.b,X) [Reads: Direct Page, Accumulator, X Index]
	adc $014100.l,X		; 7F 00 41 01 ; Add long $014100.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $221F1F.l,X		; 3F 1F 1F 22 ; AND accumulator with memory (long,X) $221F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $FEC8.w,Y		; BE C8 FE ; Load X register $FEC8.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $7E.b		; 65 7E ; Add $7E.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $001F.w		; 20 1F 00 ; Jump to subroutine at $001F.w [Writes: Stack Pointer] [Flow: call]
	pea $E8B0.w		; F4 B0 E8 ; Push absolute address $E8B0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	mvp $F0,$E0		; 44 E0 F0 ; Move block positive $F0,$E0 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$24C0.w		; C0 C0 24 ; Compare #$24C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$4C.b]		; 67 4C ; Add with carry (long) [$4C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	jsr $00C0.w		; 20 C0 00 ; Jump to subroutine at $00C0.w [Writes: Stack Pointer] [Flow: call]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $04BB.w		; 20 BB 04 ; Jump to subroutine at $04BB.w [Writes: Stack Pointer] [Flow: call]
	mvn $17,$0B		; 54 0B 17 ; Move block negative $17,$0B [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $0E1F.w		; 0C 1F 0E ; Test and set bits $0E1F.w [Reads: Accumulator] [Flags: Z]
	asl $1E00.w,X		; 1E 00 1E ; Arithmetic shift left $1E00.w,X [Reads: X Index] [Flags: NCZ]
	tsb $001C.w		; 0C 1C 00 ; Test and set bits $001C.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($1F5F.w,X)		; FC 5F 1F ; Jump to subroutine indirect indexed ($1F5F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $1C121E.l,X		; 1F 1E 12 1C ; Logical OR long $1C121E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $DD.b		; 04 DD ; Test and set bits $DD.b [Reads: Accumulator] [Flags: Z]
	jsr $D02A.w		; 20 2A D0 ; Jump to subroutine at $D02A.w [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $30, $F8		; 30 F8 ; Branch if minus to $30, $F8 [Flow: branch]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $F8F8FA.l,X		; 3F FA F8 F8 ; AND accumulator with memory (long,X) $F8F8FA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $30, $EC		; 30 EC ; Branch if minus to $30, $EC [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	lda $29B72C.l,X		; BF 2C B7 29 ; Load long $29B72C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$08.b],Y		; B7 08 ; Load accumulator (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	stz $CB.b		; 64 CB ; Store zero to $CB.b
	mvp $78,$30		; 44 30 78 ; Move block positive $78,$30 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ldy $DADF.w,X		; BC DF DA ; Load Y register $DADF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc $BD9E.w,X		; FD 9E BD ; Subtract with carry $BD9E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $1400.w		; 0C 00 14 ; Test and set bits $1400.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpx $EC34.w		; EC 34 EC ; Compare $EC34.w with X register [Reads: X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $CC18.w		; EC 18 CC ; Compare $CC18.w with X register [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	jmp.w [$0C30]		; DC 30 0C ; Jump long indirect [$0C30] [Flow: jump]
	trb $F83C.w		; 1C 3C F8 ; Test and reset bits $F83C.w [Reads: Accumulator] [Flags: Z]
	jmp $BC7CBC.l		; 5C BC 7C BC ; Jump long to $BC7CBC.l [Flow: jump]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F3F03.l		; 0F 03 3F 0F ; OR accumulator with memory (long) $0F3F03.l [Writes: Accumulator] [Flags: NZ]
	ror $FC0E.w,X		; 7E 0E FC ; Rotate right $FC0E.w,X [Reads: X Index] [Flags: NCZ]
	trb $F843.w		; 1C 43 F8 ; Test and reset bits $F843.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $51		; 30 51 ; Branch if minus to $30, $51 [Flow: branch]
	lda $A7.b,S		; A3 A7 ; Load accumulator (stack relative) $A7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda [$83.b]		; A7 83 ; Load accumulator (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	jsr ($3EF0.w,X)		; FC F0 3E ; Jump to subroutine indirect indexed ($3EF0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $30, $5F		; 30 5F ; Branch if minus to $30, $5F [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $084F08.l		; EF 08 4F 08 ; Subtract with carry (long) $084F08.l [Writes: Accumulator] [Flags: NCVZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $0C		; 30 0C ; Branch if minus to $30, $0C [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda $15.b		; A5 15 ; Load $15.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $07.b,X		; B5 07 ; Load $07.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $67.b,S		; 83 67 ; Store accumulator (stack relative) $67.b,S [Reads: Stack Pointer, Accumulator]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $7F		; 10 7F ; Branch if plus to $10, $7F [Flow: branch]
	.db $30, $9F		; 30 9F ; Branch if minus to $30, $9F [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp $78FF70.l		; CF 70 FF 78 ; Compare accumulator (long) $78FF70.l [Reads: Accumulator] [Flags: NCZ]
	adc $0708.w,X		; 7D 08 07 ; Add $0708.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $227F3F.l,X		; 1F 3F 7F 22 ; Logical OR long $227F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E07F01.l,X		; FF 01 7F E0 ; Subtract with carry (long,X) $E07F01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $7F.b,S		; 83 7F ; Store accumulator (stack relative) $7F.b,S [Reads: Stack Pointer, Accumulator]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $F90C.w,X		; FE 0C F9 ; Increment memory $F90C.w,X [Reads: X Index] [Flags: NZ]
	asl $F3.b		; 06 F3 ; Arithmetic shift left $F3.b [Reads: Direct Page] [Flags: NCZ]
	asl $1EFF.w		; 0E FF 1E ; Arithmetic shift left $1EFF.w [Flags: NCZ]
	ldx $E010.w,Y		; BE 10 E0 ; Load X register $E010.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($22FE.w,X)		; FC FE 22 ; Jump to subroutine indirect indexed ($22FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $0CFE08.l,X		; FF 08 FE 0C ; Subtract with carry (long,X) $0CFE08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $001E.w		; 0C 1E 00 ; Test and set bits $001E.w [Reads: Accumulator] [Flags: Z]
	eor $16.b,S		; 43 16 ; Exclusive OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx #$1243.w		; E0 43 12 ; Compare #$1243.w with X register [Reads: X Index] [Flags: NCZ]
	tsb $0408.w		; 0C 08 04 ; Test and set bits $0408.w [Reads: Accumulator] [Flags: Z]
	tsb $131E.w		; 0C 1E 13 ; Test and set bits $131E.w [Reads: Accumulator] [Flags: Z]
	asl $1A1A.w,X		; 1E 1A 1A ; Arithmetic shift left $1A1A.w,X [Reads: X Index] [Flags: NCZ]
	trb $060C.w		; 1C 0C 06 ; Test and reset bits $060C.w [Reads: Accumulator] [Flags: Z]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $16.b		; 06 16 ; Arithmetic shift left $16.b [Reads: Direct Page] [Flags: NCZ]
	tsb $2E.b		; 04 2E ; Test and set bits $2E.b [Reads: Accumulator] [Flags: Z]
	tsb $387C.w		; 0C 7C 38 ; Test and set bits $387C.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1A091F.l		; 0F 1F 09 1A ; OR accumulator with memory (long) $1A091F.l [Writes: Accumulator] [Flags: NZ]
	and ($44.b)		; 32 44 ; AND accumulator with memory (indirect) ($44.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $74		; 30 74 ; Branch if minus to $30, $74 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $181C.w,X		; 3C 1C 18 ; Test bits $181C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	.db $B0, $78		; B0 78 ; Branch if carry set to $B0, $78 [Flow: branch]
	jmp ($183C.w,X)		; 7C 3C 18 ; Jump indirect indexed to ($183C.w,X) [Reads: X Index] [Flow: jump]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $78		; 10 78 ; Branch if plus to $10, $78 [Flow: branch]
	.db $30, $43		; 30 43 ; Branch if minus to $30, $43 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $10, $0B		; 10 0B ; Branch if plus to $10, $0B [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	jsr $7830.w		; 20 30 78 ; Jump to subroutine at $7830.w [Writes: Stack Pointer] [Flow: call]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $29		; 50 29 ; Branch if overflow clear to $50, $29 [Flow: branch]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $291A.w		; 0D 1A 29 ; Logical OR $291A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$A000.w		; C0 00 A0 ; Compare #$A000.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$0025.w		; E0 25 00 ; Compare #$0025.w with X register [Reads: X Index] [Flags: NCZ]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$8360.w		; A0 60 83 ; Load #$8360.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $29.b		; 02 29 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: NCZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $7474.w		; 2D 74 74 ; Logical AND $7474.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $18.b,S		; 83 18 ; Store accumulator (stack relative) $18.b,S [Reads: Stack Pointer, Accumulator]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $48		; 80 48 ; Branch always to $80, $48 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$D0A0.w		; C0 A0 D0 ; Compare #$D0A0.w with Y register [Reads: Y Index] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3E0018.l		; 0F 18 00 3E ; OR accumulator with memory (long) $3E0018.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $3E473E.l		; 6F 3E 47 3E ; Add with carry (long) $3E473E.l [Writes: Accumulator] [Flags: NCVZ]
	cmp [$7E.b]		; C7 7E ; Compare accumulator (long) [$7E.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc $00003E.l		; EF 3E 00 00 ; Subtract with carry (long) $00003E.l [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $3383.w,X		; 3E 83 33 ; Rotate left $3383.w,X [Reads: X Index] [Flags: NCZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($18.b),Y		; B1 18 ; Load accumulator ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $74.b		; 00 74 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $FE70.w		; EE 70 FE ; Increment $FE70.w [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $FB60.w,Y		; F9 60 FB ; Subtract with carry $FB60.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($FEFE.w,X)		; 7C FE FE ; Jump indirect indexed to ($FEFE.w,X) [Reads: X Index] [Flow: jump]
	sbc $165FFD.l,X		; FF FD 5F 16 ; Subtract with carry (long,X) $165FFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $0E3F09.l,X		; 3F 09 3F 0E ; AND accumulator with memory (long,X) $0E3F09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $003606.l		; 2F 06 36 00 ; AND accumulator with memory (long) $003606.l [Writes: Accumulator] [Flags: NZ]
	rol $2210.w		; 2E 10 22 ; Rotate left $2210.w [Flags: NCZ]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	adc $393136.l		; 6F 36 31 39 ; Add with carry (long) $393136.l [Writes: Accumulator] [Flags: NCVZ]
	rol $222E.w,X		; 3E 2E 22 ; Rotate left $222E.w,X [Reads: X Index] [Flags: NCZ]
	trb $68FC.w		; 1C FC 68 ; Test and reset bits $68FC.w [Reads: Accumulator] [Flags: Z]
	jsr ($FC98.w,X)		; FC 98 FC ; Jump to subroutine indirect indexed ($FC98.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $70, $F4		; 70 F4 ; Branch if overflow set to $70, $F4 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp ($7400.w)		; 6C 00 74 ; Jump indirect to ($7400.w) [Flow: jump]
	php		; [PATTERN: Memory clearing operation] 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	mvp $38,$38		; 44 38 38 ; Move block positive $38,$38 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $8C.b		; 64 8C ; Store zero to $8C.b
	stz $747C.w		; 9C 7C 74 ; Store zero to $747C.w
	mvp $F8,$38		; 44 38 F8 ; Move block positive $F8,$38 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pea $7004.w		; F4 04 70 ; Push absolute address $7004.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b),Y		; 11 3F ; OR accumulator with memory ($3F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $081F.w		; 0C 1F 08 ; Test and set bits $081F.w [Reads: Accumulator] [Flags: Z]
	ora $000E00.l,X		; 1F 00 0E 00 ; Logical OR long $000E00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$9B.b],Y		; 97 9B ; Store accumulator (long indexed) [$9B.b],Y [Reads: Direct Page, Y Index, Accumulator]
	eor $10322E.l,X		; 5F 2E 32 10 ; Exclusive OR accumulator with memory (long,X) $10322E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $101F00.l,X		; 1F 00 1F 10 ; Logical OR long $101F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $DC00.w		; 0E 00 DC ; Arithmetic shift left $DC00.w [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jsr ($F830.w,X)		; FC 30 F8 ; Jump to subroutine indirect indexed ($F830.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E9.b		; 00 E9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc #$FA.b		; E9 FA ; Subtract #$FA.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	stz $4C.b,X		; 74 4C ; Store zero to $4C.b,X [Reads: X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $70, $4D		; 70 4D ; Branch if overflow set to $70, $4D [Flow: branch]
	bit $5E.b,X		; 34 5E ; Test bits $5E.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and ($5F.b,X)		; 21 5F ; Logical AND ($5F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($2B.b,X)		; 21 2B ; Logical AND ($2B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $23.b		; 14 23 ; Test and reset bits $23.b [Reads: Accumulator] [Flags: Z]
	trb $205E.w		; 1C 5E 20 ; Test and reset bits $205E.w [Reads: Accumulator] [Flags: Z]
	.db $42, $34		; 42 34 ; Reserved instruction
	bit $7B00.w,X		; 3C 00 7B ; Test bits $7B00.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	adc [$63.b]		; 67 63 ; Add with carry (long) [$63.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and [$3F.b],Y		; 37 3F ; AND accumulator with memory (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $3C4A.w,X		; 5E 4A 3C ; Logical shift right $3C4A.w,X [Reads: X Index] [Flags: NCZ]
	lda ($2C.b)		; B2 2C ; Load accumulator (indirect) ($2C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sty $FA.b		; 84 FA ; Store Y register to $FA.b [Reads: Y Index]
	sty $D4.b		; 84 D4 ; Store Y register to $D4.b [Reads: Y Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	tsb $42.b		; 04 42 ; Test and set bits $42.b [Reads: Accumulator] [Flags: Z]
	bit $003C.w		; 2C 3C 00 ; Test bits $003C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	dec $C6E6.w,X		; DE E6 C6 ; Decrement memory $C6E6.w,X [Reads: X Index] [Flags: NZ]
	cpx $7AFC.w		; EC FC 7A ; Compare $7AFC.w with X register [Reads: X Index] [Flags: NCZ]
	eor ($3C.b)		; 52 3C ; Exclusive OR accumulator with memory (indirect) ($3C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $28,$EE		; 44 EE 28 ; Move block positive $28,$EE [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jmp ($3810.w,X)		; 7C 10 38 ; Jump indirect indexed to ($3810.w,X) [Reads: X Index] [Flow: jump]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jmp ($EE44.w,X)		; 7C 44 EE ; Jump indirect indexed to ($EE44.w,X) [Reads: X Index] [Flow: jump]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta [$C0.b]		; 87 C0 ; Store accumulator (long) [$C0.b] [Reads: Direct Page, Accumulator]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsr $205C.w		; 20 5C 20 ; Jump to subroutine at $205C.w [Writes: Stack Pointer] [Flow: call]
	bit $8510.w		; 2C 10 85 ; Test bits $8510.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	dec $0303.w		; CE 03 03 ; Decrement $0303.w [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	stz $30.b		; 64 30 ; Store zero to $30.b
	clc		; 18 ; Clear carry flag [Flags: C]
	sta [$90.b]		; 87 90 ; Store accumulator (long) [$90.b] [Reads: Direct Page, Accumulator]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b)		; 12 0C ; OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $0E1E.w		; 0C 1E 0E ; Test and set bits $0E1E.w [Reads: Accumulator] [Flags: Z]
	tsb $9F83.w		; 0C 83 9F ; Test and set bits $9F83.w [Reads: Accumulator] [Flags: Z]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $25E0.w,X		; 1E E0 25 ; Arithmetic shift left $25E0.w,X [Reads: X Index] [Flags: NCZ]
	tsb $5CE6.w		; 0C E6 5C ; Test and set bits $5CE6.w [Reads: Accumulator] [Flags: Z]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	tsb $E5.b		; 04 E5 ; Test and set bits $E5.b [Reads: Accumulator] [Flags: Z]
	cop $6F.b		; 02 6F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $42BF46.l,X		; BF 46 BF 42 ; Load long $42BF46.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $12FFA2.l,X		; 5F A2 FF 12 ; Exclusive OR accumulator with memory (long,X) $12FFA2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FFFE.w,X		; FE FE FF ; Increment memory $FFFE.w,X [Reads: X Index] [Flags: NZ]
	sbc [$7F.b],Y		; F7 7F ; Subtract with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $13EFDF.l,X		; 7F DF EF 13 ; Add long $13EFDF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $1F20.w		; 0C 20 1F ; Test and set bits $1F20.w [Reads: Accumulator] [Flags: Z]
	and $072700.l,X		; 3F 00 27 07 ; AND accumulator with memory (long,X) $072700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $1B0800.l		; 22 00 08 1B ; Jump to subroutine long $1B0800.l [Writes: Stack Pointer] [Flow: call]
	.db $30, $3F		; 30 3F ; Branch if minus to $30, $3F [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $0707.w		; 1C 07 07 ; Test and reset bits $0707.w [Reads: Accumulator] [Flags: Z]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $90,$00		; 44 00 90 ; Move block positive $90,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F0F0.w		; E0 F0 F0 ; Compare #$F0F0.w with X register [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$8080.w		; C0 80 80 ; Compare #$8080.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $081F.w		; 0D 1F 08 ; Logical OR $081F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $1712.w		; 0C 12 17 ; Test and set bits $1712.w [Reads: Accumulator] [Flags: Z]
	ora $1F170F.l		; 0F 0F 17 1F ; OR accumulator with memory (long) $1F170F.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $24		; 80 24 ; Branch always to $80, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	jsl $000E80.l		; 22 80 0E 00 ; Jump to subroutine long $000E80.l [Writes: Stack Pointer] [Flow: call]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $CCFF.w		; 0D FF CC ; Logical OR $CCFF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $1A.b		; E5 1A ; Subtract $1A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	adc $7F.b		; 65 7F ; Add $7F.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and [$06.b],Y		; 37 06 ; AND accumulator with memory (long indexed) [$06.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $140022.l		; 0F 22 00 14 ; OR accumulator with memory (long) $140022.l [Writes: Accumulator] [Flags: NZ]
	sbc $FBE63E.l,X		; FF 3E E6 FB ; Subtract with carry (long,X) $FBE63E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$39.b],Y		; 77 39 ; Add with carry (long indexed) [$39.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $B07E00.l		; 0F 00 7E B0 ; OR accumulator with memory (long) $B07E00.l [Writes: Accumulator] [Flags: NZ]
	ldx $BE58.w,Y		; BE 58 BE ; Load X register $BE58.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jmp $FEA45E.l		; 5C 5E A4 FE ; Jump long to $FEA45E.l [Flow: jump]
	trb $EC.b		; 14 EC ; Test and reset bits $EC.b [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $7E7E.w,X		; FE 7E 7E ; Increment memory $7E7E.w,X [Reads: X Index] [Flags: NZ]
	dec $9CEE.w,X		; DE EE 9C ; Decrement memory $9CEE.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	sbc $090025.l,X		; FF 25 00 09 ; Subtract with carry (long,X) $090025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $0B1B06.l		; 0F 06 1B 0B ; OR accumulator with memory (long) $0B1B06.l [Writes: Accumulator] [Flags: NZ]
	bit $3F18.w,X		; 3C 18 3F ; Test bits $3F18.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	trb $0022.w		; 1C 22 00 ; Test and reset bits $0022.w [Reads: Accumulator] [Flags: Z]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora #$14.b		; 09 14 ; Logical OR #$14.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$60.b		; 09 60 ; Logical OR #$60.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $D0, $3C		; D0 3C ; Branch if not equal to $D0, $3C [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($2238.w,X)		; FC 38 22 ; Jump to subroutine indirect indexed ($2238.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $28		; 90 28 ; Branch if carry clear to $90, $28 [Flow: branch]
	cpy $04.b		; C4 04 ; Compare $04.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($18.b,S),Y		; 13 18 ; OR accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7E.b		; 00 7E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($7B.b,X)		; 01 7B ; Logical OR ($7B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $64.b		; 14 64 ; Test and reset bits $64.b [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $5A53.w		; 2C 53 5A ; Test bits $5A53.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	adc $235F.w		; 6D 5F 23 ; Add $235F.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora $7E00FE.l		; 0F FE 00 7E ; OR accumulator with memory (long) $7E00FE.l [Writes: Accumulator] [Flags: NZ]
	.db $80, $DE		; 80 DE ; Branch always to $80, $DE [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	rol $C4.b		; 26 C4 ; Rotate left $C4.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $CA.b,X		; 34 CA ; Test bits $CA.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ldx $FA.b,Y		; B6 FA ; Load X register $FA.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,S),Y		; 13 07 ; OR accumulator (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $17.b		; 05 17 ; Logical OR $17.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $3D.b		; 05 3D ; Logical OR $3D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lsr $000D.w,X		; 5E 0D 00 ; Logical shift right $000D.w,X [Reads: X Index] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($18.b),Y		; 11 18 ; OR accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $72.b,X		; 35 72 ; Logical AND $72.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($60.b,S),Y		; 13 60 ; OR accumulator (stack relative indirect indexed) ($60.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $50E8.w		; 20 E8 50 ; Jump to subroutine at $50E8.w [Writes: Stack Pointer] [Flow: call]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ldy #$D0BC.w		; A0 BC D0 ; Load #$D0BC.w into Y register [Writes: Y Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $88		; D0 88 ; Branch if not equal to $D0, $88 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldy $2B4E.w		; AC 4E 2B ; Load $2B4E.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F2.b		; 00 F2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $025D.w		; 0C 5D 02 ; Test and set bits $025D.w [Reads: Accumulator] [Flags: Z]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora $BD.b,X		; 15 BD ; OR accumulator with memory $BD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $DC57E8.l		; [PATTERN: Memory clearing operation] 22 E8 57 DC ; Jump to subroutine long $DC57E8.l [Writes: Stack Pointer] [Flow: call]
	and $60.b,S		; 23 60 ; AND accumulator with stack relative $60.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $77AE.w		; 9C AE 77 ; Store zero to $77AE.w
	sbc $BBDE.w		; ED DE BB ; Subtract $BBDE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	stz $25.b		; 64 25 ; Store zero to $25.b
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $60		; B0 60 ; Branch if carry set to $B0, $60 [Flow: branch]
	ora $F7.b,S		; 03 F7 ; OR accumulator with stack relative $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	adc $002215.l,X		; 7F 15 22 00 ; Add long $002215.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $60.b		; 04 60 ; Test and set bits $60.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sbc [$7F.b],Y		; F7 7F ; Subtract with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0306.w		; 0D 06 03 ; Logical OR $0306.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $A8FE02.l		; EF 02 FE A8 ; Subtract with carry (long) $A8FE02.l [Writes: Accumulator] [Flags: NCVZ]
	jsl $061C00.l		; 22 00 1C 06 ; Jump to subroutine long $061C00.l [Writes: Stack Pointer] [Flow: call]
	ora $FEEF0F.l		; 0F 0F EF FE ; OR accumulator with memory (long) $FEEF0F.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1902.w		; 0D 02 19 ; Logical OR $1902.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $7D.b		; 06 7D ; Arithmetic shift left $7D.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $F717.w,X		; 9D 17 F7 ; Store accumulator to $F717.w,X [Reads: Accumulator, X Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sbc ($5E.b),Y		; F1 5E ; Subtract with carry ($5E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $ED7D1F.l		; 0F 1F 7D ED ; OR accumulator with memory (long) $ED7D1F.l [Writes: Accumulator] [Flags: NZ]
	cmp $0029FF.l,X		; DF FF 29 00 ; Compare accumulator (long,X) $0029FF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $80, $B8		; 80 B8 ; Branch always to $80, $B8 [Flow: branch]
	jsr ($0004.w,X)		; FC 04 00 ; Jump to subroutine indirect indexed ($0004.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	ora $1D.b		; 05 1D ; Logical OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3C.b,S		; 03 3C ; OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ror $7B27.w,X		; 7E 27 7B ; Rotate right $7B27.w,X [Reads: X Index] [Flags: NCZ]
	rol $73.b		; 26 73 ; Rotate left $73.b [Reads: Direct Page] [Flags: NCZ]
	asl $0F04.w,X		; 1E 04 0F ; Arithmetic shift left $0F04.w,X [Reads: X Index] [Flags: NCZ]
	ora $663E1F.l		; 0F 1F 3E 66 ; OR accumulator with memory (long) $663E1F.l [Writes: Accumulator] [Flags: NZ]
	adc [$7F.b],Y		; 77 7F ; Add with carry (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$80.b]		; 47 80 ; Exclusive OR accumulator with memory (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$F280]		; DC 80 F2 ; Jump long indirect [$F280] [Flow: jump]
	jmp.w [$0000]		; DC 00 00 ; Jump long indirect [$0000] [Flow: jump]
	and $80.b,S		; 23 80 ; AND accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($DC.b,X)		; 01 DC ; Logical OR ($DC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $002D.w,X		; FE 2D 00 ; Increment memory $002D.w,X [Reads: X Index] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0101.w,X		; 1E 01 01 ; Arithmetic shift left $0101.w,X [Reads: X Index] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$13.b]		; 07 13 ; OR accumulator with memory (long) [$13.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $106F.w		; 0C 6F 10 ; Test and set bits $106F.w [Reads: Accumulator] [Flags: Z]
	ldy $1B.b		; A4 1B ; Load $1B.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	eor [$01.b]		; 47 01 ; Exclusive OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1310.w		; 0E 10 13 ; Arithmetic shift left $1310.w [Flags: NCZ]
	ror $F0E4.w		; 6E E4 F0 ; Rotate right $F0E4.w [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	and [$17.b],Y		; 37 17 ; AND accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $367F29.l		; 6F 29 7F 36 ; Add with carry (long) $367F29.l [Writes: Accumulator] [Flags: NCVZ]
	eor $7A.b,S		; 43 7A ; Exclusive OR accumulator with stack relative $7A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $13		; 30 13 ; Branch if minus to $30, $13 [Flow: branch]
	bit $1714.w,X		; 3C 14 17 ; Test bits $1714.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $49.b,X		; 56 49 ; Logical shift right $49.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $142B4F.l		; 4F 4F 2B 14 ; Exclusive OR accumulator with memory (long) $142B4F.l [Writes: Accumulator] [Flags: NZ]
	ora $EC.b,S		; 03 EC ; OR accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inc $94.b,X		; F6 94 ; Increment memory $94.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $436C.w,X		; FE 6C 43 ; Increment memory $436C.w,X [Reads: X Index] [Flags: NZ]
	lsr $E00C.w,X		; 5E 0C E0 ; Logical shift right $E00C.w,X [Reads: X Index] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $E828.w,X		; 3C 28 E8 ; Test bits $E828.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	trb $6A.b		; 14 6A ; Test and reset bits $6A.b [Reads: Accumulator] [Flags: Z]
	sta ($F2.b)		; 92 F2 ; Store accumulator (indirect) ($F2.b) [Reads: Direct Page, Accumulator]
	sbc ($D4.b)		; F2 D4 ; Subtract with carry (indirect) ($D4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	cpy #$1037.w		; C0 37 10 ; Compare #$1037.w with Y register [Reads: Y Index] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$77.b]		; 27 77 ; AND accumulator with memory (long) [$77.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $3F17.w,X		; 3E 17 3F ; Rotate left $3F17.w,X [Reads: X Index] [Flags: NCZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $3F3F7F.l,X		; 7F 7F 3F 3F ; Add long $3F3F7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $EE030F.l,X		; 1F 0F 03 EE ; Logical OR long $EE030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cpx $7E.b		; E4 7E ; Compare $7E.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $F01C.w		; EC 1C F0 ; Compare $F01C.w with X register [Reads: X Index] [Flags: NCZ]
	bit $F8E0.w,X		; 3C E0 F8 ; Test bits $F8E0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FCFE.w,X		; FE FE FC ; Increment memory $FCFE.w,X [Reads: X Index] [Flags: NZ]
	jsr ($F0F8.w,X)		; FC F8 F0 ; Jump to subroutine indirect indexed ($F0F8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy #$085F.w		; C0 5F 08 ; Compare #$085F.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $107E21.l		; 6F 21 7E 10 ; Add with carry (long) $107E21.l [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jsr $347C.w		; 20 7C 34 ; Jump to subroutine at $347C.w [Writes: Stack Pointer] [Flow: call]
	and [$01.b],Y		; 37 01 ; AND accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$58.b],Y		; 77 58 ; Add with carry (long indexed) [$58.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $01364B.l,X		; 5F 4B 36 01 ; Exclusive OR accumulator with memory (long,X) $01364B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $F6		; 10 F6 ; Branch if plus to $10, $F6 [Flow: branch]
	sty $7E.b		; 84 7E ; Store Y register to $7E.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr $3E04.w,X		; 5E 04 3E ; Logical shift right $3E04.w,X [Reads: X Index] [Flags: NCZ]
	bit $80EC.w		; 2C EC 80 ; Test bits $80EC.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $D61A.w		; EE 1A D6 ; Increment $D61A.w [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cmp ($6C.b)		; D2 6C ; Compare accumulator (indirect) ($6C.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($2A.b,X)		; 01 2A ; Logical OR ($2A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($DE03.w,X)		; FC 03 DE ; Jump to subroutine indirect indexed ($DE03.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and ($FF.b,X)		; 21 FF ; Logical AND ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $F3.b		; 00 F3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $863C.w		; 0C 3C 86 ; Test and set bits $863C.w [Reads: Accumulator] [Flags: Z]
	lda $0301.w,Y		; B9 01 03 ; Load $0301.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$73.b]		; 47 73 ; Exclusive OR accumulator with memory (long) [$73.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($FC.b),Y		; 31 FC ; AND accumulator with memory ($FC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $C4.b,S		; 83 C4 ; Store accumulator (stack relative) $C4.b,S [Reads: Stack Pointer, Accumulator]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $6E3D.w		; 6E 3D 6E ; Rotate right $6E3D.w [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$3C.b],Y		; 17 3C ; OR accumulator with memory (long indexed) [$3C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $07070F.l		; 0F 0F 07 07 ; OR accumulator with memory (long) $07070F.l [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($7F.b)		; 12 7F ; OR accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $0F3C3B.l,X		; 7F 3B 3C 0F ; Add long $0F3C3B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $DC76.w,X		; BC 76 DC ; Load Y register $DC76.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jmp.w [$38E8]		; DC E8 38 ; Jump long indirect [$38E8] [Flow: jump]
	cpx #$E0F0.w		; E0 F0 E0 ; Compare #$E0F0.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$0024.w		; E0 24 00 ; Compare #$0024.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$FE3F.w		; E0 3F FE ; Compare #$FE3F.w with X register [Reads: X Index] [Flags: NCZ]
	inc $38DC.w,X		; FE DC 38 ; Increment memory $38DC.w,X [Reads: X Index] [Flags: NZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	eor $1F0F7D.l,X		; 5F 7D 0F 1F ; Exclusive OR accumulator with memory (long,X) $1F0F7D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $070F1F.l,X		; 7F 1F 0F 07 ; Add long $070F1F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $C60F.w,Y		; 19 0F C6 ; OR accumulator with memory $C60F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $FC6E.w,X		; BC 6E FC ; Load Y register $FC6E.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $F2FFEE.l,X		; BF EE FF F2 ; Load long $F2FFEE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$C080.w		; E0 80 C0 ; Compare #$C080.w with X register [Reads: X Index] [Flags: NCZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	cpy #$237E.w		; C0 7E 23 ; Compare #$237E.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $1C3F1F.l,X		; 5F 1F 3F 1C ; Exclusive OR accumulator with memory (long,X) $1C3F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $8703.w,X		; 1E 03 87 ; Arithmetic shift left $8703.w,X [Reads: X Index] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $1F3F6F.l,X		; 5F 6F 3F 1F ; Exclusive OR accumulator with memory (long,X) $1F3F6F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $84.b,S		; 83 84 ; Store accumulator (stack relative) $84.b,S [Reads: Stack Pointer, Accumulator]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $BE.b,S		; 43 BE ; Exclusive OR accumulator with stack relative $BE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $F6BFFE.l		; 6F FE BF F6 ; Add with carry (long) $F6BFFE.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $F2DFF2.l,X		; FF F2 DF F2 ; Subtract with carry (long,X) $F2DFF2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $84.b,X		; F6 84 ; Increment memory $84.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sta ($02.b,S),Y		; 93 02 ; Store accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$F656.w		; E0 56 F6 ; Compare #$F656.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$07C0.w		; E0 C0 07 ; Compare #$07C0.w with X register [Reads: X Index] [Flags: NCZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$1B.b]		; 07 1B ; OR accumulator with memory (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $311F33.l		; 0F 33 1F 31 ; OR accumulator with memory (long) $311F33.l [Writes: Accumulator] [Flags: NZ]
	ora $653F78.l,X		; 1F 78 3F 65 ; Logical OR long $653F78.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $0747FB.l,X		; 3F FB 47 07 ; AND accumulator with memory (long,X) $0747FB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3F3F1F.l		; 0F 1F 3F 3F ; OR accumulator with memory (long) $3F3F1F.l [Writes: Accumulator] [Flags: NZ]
	adc $FFFB67.l,X		; 7F 67 FB FF ; Add long $FFFB67.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sbc $10F28F.l,X		; FF 8F F2 10 ; Subtract with carry (long,X) $10F28F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jsr ($FF84.w,X)		; FC 84 FF ; Jump to subroutine indirect indexed ($FF84.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cpx #$A0FF.w		; E0 FF A0 ; Compare #$A0FF.w with X register [Reads: X Index] [Flags: NCZ]
	sta [$C0.b]		; 87 C0 ; Store accumulator (long) [$C0.b] [Reads: Direct Page, Accumulator]
	cmp $E0C3C7.l		; CF C7 C3 E0 ; Compare accumulator (long) $E0C3C7.l [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C3C03.l		; 0F 03 3C 0C ; OR accumulator with memory (long) $0C3C03.l [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($000C.w,X)		; FC 0C 00 ; Jump to subroutine indirect indexed ($000C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($57.b,S),Y		; 33 57 ; AND accumulator (stack relative indirect indexed) ($57.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda [$97.b]		; A7 97 ; Load accumulator (long) [$97.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($00.b,S),Y		; 93 00 ; Store accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$307C.w		; C0 7C 30 ; Compare #$307C.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $4F10.w,X		; FE 10 4F ; Increment memory $4F10.w,X [Reads: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $BA.b,S		; 83 BA ; Store accumulator (stack relative) $BA.b,S [Reads: Stack Pointer, Accumulator]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $8C		; 30 8C ; Branch if minus to $30, $8C [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $E9.b,X		; B5 E9 ; Load $E9.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0025.w,Y		; F9 25 00 ; Subtract with carry $0025.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0107.w		; 0C 07 01 ; Test and set bits $0107.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $040022.l		; 0F 22 00 04 ; OR accumulator with memory (long) $040022.l [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $251F0F.l		; 0F 0F 1F 25 ; OR accumulator with memory (long) $251F0F.l [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	ora ($98.b,X)		; 01 98 ; Logical OR ($98.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $9A.b,S		; 83 9A ; Store accumulator (stack relative) $9A.b,S [Reads: Stack Pointer, Accumulator]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $011F01.l		; 0F 01 1F 01 ; OR accumulator with memory (long) $011F01.l [Writes: Accumulator] [Flags: NZ]
	and $0C3310.l		; 2F 10 33 0C ; AND accumulator with memory (long) $0C3310.l [Writes: Accumulator] [Flags: NZ]
	adc $5E32.w,X		; 7D 32 5E ; Add $5E32.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0100.w,Y		; 19 00 01 ; OR accumulator with memory $0100.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $3D3113.l		; 0F 13 31 3D ; OR accumulator with memory (long) $3D3113.l [Writes: Accumulator] [Flags: NZ]
	eor $007E67.l		; 4F 67 7E 00 ; Exclusive OR accumulator with memory (long) $007E67.l [Writes: Accumulator] [Flags: NZ]
	sbc $FF4442.l,X		; FF 42 44 FF ; Subtract with carry (long,X) $FF4442.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($07.b,X)		; 81 07 ; Store accumulator ($07.b,X) [Reads: Direct Page, Accumulator, X Index]
	cmp $FF.b,S		; C3 FF ; Compare accumulator (stack relative) $FF.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $81FF.w,X		; 7E FF 81 ; Rotate right $81FF.w,X [Reads: X Index] [Flags: NCZ]
	ror $7EDB.w,X		; 7E DB 7E ; Rotate right $7EDB.w,X [Reads: X Index] [Flags: NCZ]
	rol $FF.b		; 26 FF ; Rotate left $FF.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1B3C.w		; 0C 3C 1B ; Test and set bits $1B3C.w [Reads: Accumulator] [Flags: Z]
	rol $1D.b,X		; 36 1D ; Rotate left $1D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $7D1D.w,X		; 3E 1D 7D ; Rotate left $7D1D.w,X [Reads: X Index] [Flags: NCZ]
	jsl $0F0301.l		; 22 01 03 0F ; Jump to subroutine long $0F0301.l [Writes: Stack Pointer] [Flow: call]
	asl $3F22.w,X		; 1E 22 3F ; Arithmetic shift left $3F22.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $0080.w,X		; 7E 80 00 ; Rotate right $0080.w,X [Reads: X Index] [Flags: NCZ]
	cpy #$F080.w		; C0 80 F0 ; Compare #$F080.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $EC		; 30 EC ; Branch if minus to $30, $EC [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jmp.w [$EC28]		; DC 28 EC ; Jump long indirect [$EC28] [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	inc $8004.w,X		; FE 04 80 ; Increment memory $8004.w,X [Reads: X Index] [Flags: NZ]
	cpy #$78F0.w		; C0 F0 78 ; Compare #$78F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $7C6C.w,X		; 3C 6C 7C ; Test bits $7C6C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	rol $002D.w,X		; 3E 2D 00 ; Rotate left $002D.w,X [Reads: X Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $A8.b		; 85 A8 ; Store accumulator to $A8.b [Reads: Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $AF84.w,X		; DD 84 AF ; Compare accumulator $AF84.w,X [Reads: X Index] [Flags: NCZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $F7AE.w		; 9C AE F7 ; Store zero to $F7AE.w
	sbc $10DE.w		; ED DE 10 ; Subtract $10DE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	jmp ($3843.w,X)		; 7C 43 38 ; Jump indirect indexed to ($3843.w,X) [Reads: X Index] [Flow: jump]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	mvp $54,$54		; 44 54 54 ; Move block positive $54,$54 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sec		; 38 ; Set carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	ora ($76.b,X)		; 01 76 ; Logical OR ($76.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$78.b]		; 07 78 ; OR accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $B0		; 90 B0 ; Branch if carry clear to $90, $B0 [Flow: branch]
	.db $F0, $76		; F0 76 ; Branch if equal to $F0, $76 [Flow: branch]
	ora $83090B.l		; 0F 0B 09 83 ; OR accumulator with memory (long) $83090B.l [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $16.b		; 02 16 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $3C1C.w		; 2E 1C 3C ; Rotate left $3C1C.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $E9.b,S		; 83 E9 ; Store accumulator (stack relative) $E9.b,S [Reads: Stack Pointer, Accumulator]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3E1E.w		; 0D 1E 3E ; Logical OR $3E1E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $8318.w,X		; 3C 18 83 ; Test bits $8318.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $3C08.w		; 2C 08 3C ; Test bits $3C08.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $2D83.w		; 2C 83 2D ; Test bits $2D83.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $2234.w,X		; 3C 34 22 ; Test bits $2234.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $B8E0.w,X		; 3C E0 B8 ; Test bits $B8E0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	cmp $8D03.w		; CD 03 8D ; Compare $8D03.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cmp $7D5B.w,X		; DD 5B 7D ; Compare accumulator $7D5B.w,X [Reads: X Index] [Flags: NCZ]
	and ($7D.b)		; 32 7D ; AND accumulator with memory (indirect) ($7D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $3B.b		; 02 3B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3A.b		; 05 3A ; Logical OR $3A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $15.b		; 05 15 ; Logical OR $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $A5F5.w,X		; FD F5 A5 ; Subtract with carry $A5F5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $3B7D.w		; 4D 7D 3B ; Exclusive OR $3B7D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $FF.b,X		; 15 FF ; OR accumulator with memory $FF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $EF		; B0 EF ; Branch if carry set to $B0, $EF [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc [$3C.b]		; E7 3C ; Subtract with carry (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($4F.b,S),Y		; F3 4F ; Subtract with carry (stack relative indirect indexed) ($4F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $B0F040.l		; CF 40 F0 B0 ; Compare accumulator (long) $B0F040.l [Reads: Accumulator] [Flags: NCZ]
	adc $70BFCF.l,X		; 7F CF BF 70 ; Add long $70BFCF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsr ($BFFF.w,X)		; FC FF BF ; Jump to subroutine indirect indexed ($BFFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lda $BF70CF.l,X		; BF CF 70 BF ; Load long $BF70CF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $35771F.l,X		; FF 1F 77 35 ; Subtract with carry (long,X) $35771F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $3B		; 10 3B ; Branch if plus to $10, $3B [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $011F08.l,X		; 1F 08 1F 01 ; Logical OR long $011F08.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $000800.l,X		; 1F 00 08 00 ; Logical OR long $000800.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$2F4A.w		; A0 4A 2F ; Load #$2F4A.w into Y register [Writes: Y Index] [Flags: NZ]
	bit $10.b		; 24 10 ; Test bits $10.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $10, $17		; 10 17 ; Branch if plus to $10, $17 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $A4E618.l,X		; 1F 18 E6 A4 ; Logical OR long $A4E618.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvn $9C,$00		; 54 00 9C ; Move block negative $9C,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $F8		; 10 F8 ; Branch if plus to $10, $F8 [Flow: branch]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	jsr ($0864.w,X)		; FC 64 08 ; Jump to subroutine indirect indexed ($0864.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $3C		; 10 3C ; Branch if plus to $10, $3C [Flow: branch]
	ora $4F172E.l		; 0F 2E 17 4F ; OR accumulator with memory (long) $4F172E.l [Writes: Accumulator] [Flags: NZ]
	and ($7F.b,S),Y		; 33 7F ; AND accumulator (stack relative indirect indexed) ($7F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $123F0C.l,X		; 5F 0C 3F 12 ; Exclusive OR accumulator with memory (long,X) $123F0C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $000D0D.l,X		; 1F 0D 0D 00 ; Logical OR long $000D0D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $7B4F2F.l,X		; 3F 2F 4F 7B ; AND accumulator with memory (long,X) $7B4F2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($132E.w,X)		; 7C 2E 13 ; Jump indirect indexed to ($132E.w,X) [Reads: X Index] [Flow: jump]
	ora $F03C.w		; 0D 3C F0 ; Logical OR $F03C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $E8.b,X		; 74 E8 ; Store zero to $E8.b,X [Reads: X Index]
	sbc ($CC.b)		; F2 CC ; Subtract with carry (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $FA10.w,X		; FE 10 FA ; Increment memory $FA10.w,X [Reads: X Index] [Flags: NZ]
	.db $30, $FC		; 30 FC ; Branch if minus to $30, $FC [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $B0, $B0		; B0 B0 ; Branch if carry set to $B0, $B0 [Flow: branch]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $DEF2.w		; F4 F2 DE ; Push absolute address $DEF2.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	rol $C874.w,X		; 3E 74 C8 ; Rotate left $C874.w,X [Reads: X Index] [Flags: NCZ]
	.db $B0, $6F		; B0 6F ; Branch if carry set to $B0, $6F [Flow: branch]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $013F.w		; 20 3F 01 ; Jump to subroutine at $013F.w [Writes: Stack Pointer] [Flow: call]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $060901.l,X		; 1F 01 09 06 ; Logical OR long $060901.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $57.b		; 00 57 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	and $3F.b,S		; 23 3F ; AND accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0809.w,X		; 1E 09 08 ; Arithmetic shift left $0809.w,X [Reads: X Index] [Flags: NCZ]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc $18E7E7.l,X		; FF E7 E7 18 ; Subtract with carry (long,X) $18E7E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $BD.b,S		; C3 BD ; Compare accumulator (stack relative) $BD.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc [$BD.b]		; E7 BD ; Subtract with carry (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $3C5A.w,X		; BD 5A 3C ; Load $3C5A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $C3.b,S		; C3 C3 ; Compare accumulator (stack relative) $C3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7E34E0.l,X		; FF E0 34 7E ; Subtract with carry (long,X) $7E34E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $C33C.w,X		; BD 3C C3 ; Load $C33C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $7F2B.w,X		; 5E 2B 7F ; Logical shift right $7F2B.w,X [Reads: X Index] [Flags: NCZ]
	and $1677.w		; 2D 77 16 ; Logical AND $1677.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($11.b,S),Y		; 33 11 ; AND accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $0F0C.w		; 1C 0C 0F ; Test and reset bits $0F0C.w [Reads: Accumulator] [Flags: Z]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($69.b,S),Y		; 73 69 ; Add with carry (stack relative indirect indexed) ($69.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	rol $1327.w		; 2E 27 13 ; Rotate left $1327.w [Flags: NCZ]
	tsb $7A07.w		; 0C 07 7A ; Test and set bits $7A07.w [Reads: Accumulator] [Flags: Z]
	pei ($FE.b)		; D4 FE ; Push effective indirect address ($FE.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ldy $EE.b,X		; B4 EE ; Load Y register $EE.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cpy $5C88.w		; CC 88 5C ; Compare $5C88.w with Y register [Reads: Y Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	cpy #$00E0.w		; C0 E0 00 ; Compare #$00E0.w with Y register [Reads: Y Index] [Flags: NCZ]
	inc $96CE.w		; EE CE 96 ; Increment $96CE.w [Flags: NZ]
	stz $E4.b,X		; 74 E4 ; Store zero to $E4.b,X [Reads: X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$E8.b],Y		; 17 E8 ; OR accumulator with memory (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$5C.b],Y		; 57 5C ; Exclusive OR accumulator with memory (long indexed) [$5C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $DC.b,S		; A3 DC ; Load accumulator (stack relative) $DC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $DE.b,S		; 23 DE ; AND accumulator with stack relative $DE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($DF.b,X)		; 21 DF ; Logical AND ($DF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $0877.w		; 20 77 08 ; Jump to subroutine at $0877.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $BB.b		; 00 BB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $67.b		; E4 67 ; Compare $67.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $F1.b,S		; 63 F1 ; Add with carry (stack relative) $F1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $284D07.l,X		; 1F 07 4D 28 ; Logical OR long $284D07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	rol $28.b		; 26 28 ; Rotate left $28.b [Reads: Direct Page] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $09.b		; 45 09 ; Exclusive OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $47.b		; 06 47 ; Arithmetic shift left $47.b [Reads: Direct Page] [Flags: NCZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$23.b		; 09 23 ; Logical OR #$23.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $E4.b		; 02 E4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $174300.l		; 2F 00 43 17 ; AND accumulator with memory (long) $174300.l [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $0F1717.l		; 0F 17 17 0F ; OR accumulator with memory (long) $0F1717.l [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $60BFDF.l,X		; 7F DF BF 60 ; Add long $60BFDF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $45E0FF.l,X		; 5F FF E0 45 ; Exclusive OR accumulator with memory (long,X) $45E0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $3F0500.l,X		; FF 00 05 3F ; Subtract with carry (long,X) $3F0500.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $221FA0.l,X		; 5F A0 1F 22 ; Exclusive OR accumulator with memory (long,X) $221FA0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF3F00.l,X		; FF 00 3F FF ; Subtract with carry (long,X) $FF3F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$062F.w		; E0 2F 06 ; Compare #$062F.w with X register [Reads: X Index] [Flags: NCZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3F.b		; 04 3F ; Test and set bits $3F.b [Reads: Accumulator] [Flags: Z]
	ora $226E.w,X		; 1D 6E 22 ; OR accumulator with memory $226E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $3AFE5D.l,X		; DF 5D FE 3A ; Compare accumulator (long,X) $3AFE5D.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $75F77B.l,X		; FF 7B F7 75 ; Subtract with carry (long,X) $75F77B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: NCZ]
	jsl $C5A25D.l		; 22 5D A2 C5 ; Jump to subroutine long $C5A25D.l [Writes: Stack Pointer] [Flow: call]
	sty $8A.b		; 84 8A ; Store Y register to $8A.b [Reads: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0A.b,X		; 95 0A ; Store accumulator to $0A.b,X [Reads: Accumulator, X Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $8A.b		; 05 8A ; Logical OR $8A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $92.b		; 05 92 ; Logical OR $92.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $EFF0.w		; 0D F0 EF ; Logical OR $EFF0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$F1.b]		; E7 F1 ; Subtract with carry (long) [$F1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $10		; F0 10 ; Branch if equal to $F0, $10 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($C0.b,S),Y		; 13 C0 ; OR accumulator (stack relative indirect indexed) ($C0.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$70F8.w		; C0 F8 70 ; Compare #$70F8.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $CC78.w		; CC 78 CC ; Compare $CC78.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $70, $C6		; 70 C6 ; Branch if overflow set to $70, $C6 [Flow: branch]
	jmp ($0000.w,X)		; 7C 00 00 ; Jump indirect indexed to ($0000.w,X) [Reads: X Index] [Flow: jump]
	cpy #$F8F0.w		; C0 F0 F8 ; Compare #$F8F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsr ($FEFC.w,X)		; FC FC FE ; Jump to subroutine indirect indexed ($FEFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $B0, $40		; B0 40 ; Branch if carry set to $B0, $40 [Flow: branch]
	eor $D0.b,S		; 43 D0 ; Exclusive OR accumulator with stack relative $D0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	.db $D0, $F0		; D0 F0 ; Branch if not equal to $D0, $F0 [Flow: branch]
	.db $F0, $25		; F0 25 ; Branch if equal to $F0, $25 [Flow: branch]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1F00.w		; 0E 00 1F ; Arithmetic shift left $1F00.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $7507.w,Y		; 39 07 75 ; AND accumulator with memory $7507.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $3C7B.w		; 2E 7B 3C ; Rotate left $3C7B.w [Flags: NCZ]
	jsl $0E0400.l		; 22 00 04 0E ; Jump to subroutine long $0E0400.l [Writes: Stack Pointer] [Flow: call]
	ora $7B7D3F.l,X		; 1F 3F 7D 7B ; Logical OR long $7B7D3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $96.b		; 00 96 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1EE7.w		; 0C E7 1E ; Test and set bits $1EE7.w [Reads: Accumulator] [Flags: Z]
	sbc [$DE.b]		; E7 DE ; Subtract with carry (long) [$DE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $FFFF.w,X		; 9E FF FF ; Store zero to $FFFF.w,X [Reads: X Index]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $002300.l		; 0F 00 23 00 ; OR accumulator with memory (long) $002300.l [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2F.b,S		; 03 2F ; OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$FD.b]		; 07 FD ; OR accumulator with memory (long) [$FD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($7E.b,X)		; 01 7E ; Logical OR ($7E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stx $7F.b		; 86 7F ; Store X register to $7F.b [Reads: X Index]
	sta $3F.b,S		; 83 3F ; Store accumulator (stack relative) $3F.b,S [Reads: Stack Pointer, Accumulator]
	cmp ($3C.b),Y		; D1 3C ; Compare accumulator ($3C.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $28.b		; 14 28 ; Test and reset bits $28.b [Reads: Accumulator] [Flags: Z]
	dec $E9.b,X		; D6 E9 ; Decrement memory $E9.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	pei ($EE.b)		; D4 EE ; Push effective indirect address ($EE.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$48.b]		; E7 48 ; Subtract with carry (long) [$48.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $060D04.l		; 0F 04 0D 06 ; OR accumulator with memory (long) $060D04.l [Writes: Accumulator] [Flags: NZ]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,X		; 15 03 ; OR accumulator with memory $03.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $DD50DC.l		; 0F DC 50 DD ; OR accumulator with memory (long) $DD50DC.l [Writes: Accumulator] [Flags: NZ]
	eor #$B7.b		; 49 B7 ; Exclusive OR #$B7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $1FB3.w		; 0C B3 1F ; Test and set bits $1FB3.w [Reads: Accumulator] [Flags: Z]
	.db $B0, $1F		; B0 1F ; Branch if carry set to $B0, $1F [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	and $3FA7BD.l		; 2F BD A7 3F ; AND accumulator with memory (long) $3FA7BD.l [Writes: Accumulator] [Flags: NZ]
	asl $AF.b		; 06 AF ; Arithmetic shift left $AF.b [Reads: Direct Page] [Flags: NCZ]
	ldx $FF22.w,Y		; BE 22 FF ; Load X register $FF22.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cop $DF.b		; 02 DF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0023FF.l,X		; 5F FF 23 00 ; Exclusive OR accumulator with memory (long,X) $0023FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $FC77F8.l		; 6F F8 77 FC ; Add with carry (long) $FC77F8.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $ABFFAE.l,X		; FF AE FF AB ; Subtract with carry (long,X) $ABFFAE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D9FF69.l,X		; FF 69 FF D9 ; Subtract with carry (long,X) $D9FF69.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF28D1.l,X		; FF D1 28 FF ; Subtract with carry (long,X) $FF28D1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $C09703.l		; 22 03 97 C0 ; Jump to subroutine long $C09703.l [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$1B.b],Y		; 57 1B ; Exclusive OR accumulator with memory (long indexed) [$1B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $27.b		; 05 27 ; Logical OR $27.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $152B.w,Y		; 19 2B 15 ; OR accumulator with memory $152B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $2C.b,X		; 56 2C ; Logical shift right $2C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $5CA3.w		; 0C A3 5C ; Test and set bits $5CA3.w [Reads: Accumulator] [Flags: Z]
	sta [$6C.b],Y		; 97 6C ; Store accumulator (long indexed) [$6C.b],Y [Reads: Direct Page, Y Index, Accumulator]
	asl $3A.b,X		; 16 3A ; Arithmetic shift left $3A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $3E.b,X		; 36 3E ; Rotate left $3E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $EFDF4F.l		; 6F 4F DF EF ; Add with carry (long) $EFDF4F.l [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $0B1F1B.l,X		; 3F 1B 1F 0B ; AND accumulator with memory (long,X) $0B1F1B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0C1F0A.l,X		; 1F 0A 1F 0C ; Logical OR long $0C1F0A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $000404.l		; 0F 04 04 00 ; OR accumulator with memory (long) $000404.l [Writes: Accumulator] [Flags: NZ]
	eor $2445.w		; 4D 45 24 ; Exclusive OR $2445.w with accumulator [Writes: Accumulator] [Flags: NZ]
	trb $15.b		; 14 15 ; Test and reset bits $15.b [Reads: Accumulator] [Flags: Z]
	ora ($0B.b,S),Y		; 13 0B ; OR accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $E9.b		; 04 E9 ; Test and set bits $E9.b [Reads: Accumulator] [Flags: Z]
	stx $E7.b,Y		; 96 E7 ; Store X register $E7.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	eor $ABD7.w,Y		; 59 D7 AB ; Exclusive OR accumulator with memory $ABD7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$98.b]		; E7 98 ; Subtract with carry (long) [$98.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $81FF93.l		; EF 93 FF 81 ; Subtract with carry (long) $81FF93.l [Writes: Accumulator] [Flags: NCVZ]
	cmp $00B890.l,X		; DF 90 B8 00 ; Compare accumulator (long,X) $00B890.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	adc ($A7.b,X)		; 61 A7 ; Add with carry ($A7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$47.b]		; 47 47 ; Exclusive OR accumulator with memory (long) [$47.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $B86F7F.l		; 4F 7F 6F B8 ; Exclusive OR accumulator with memory (long) $B86F7F.l [Writes: Accumulator] [Flags: NZ]
	inc $FC.b		; E6 FC ; Increment $FC.b [Reads: Direct Page] [Flags: NZ]
	dec $1E3C.w,X		; DE 3C 1E ; Decrement memory $1E3C.w,X [Reads: X Index] [Flags: NZ]
	jsr ($F4CE.w,X)		; FC CE F4 ; Jump to subroutine indirect indexed ($F4CE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $FA78.w,X		; FE 78 FA ; Increment memory $FA78.w,X [Reads: X Index] [Flags: NZ]
	.db $D0, $F2		; D0 F2 ; Branch if not equal to $D0, $F2 [Flow: branch]
	.db $80, $BC		; 80 BC ; Branch always to $80, $BC [Flow: branch]
	brk $26.b		; 00 26 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $BC06.w,X		; FE 06 BC ; Increment memory $BC06.w,X [Reads: X Index] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $07.b,S		; 43 07 ; Exclusive OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$E0.b]		; 07 E0 ; OR accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$06.b]		; 27 06 ; AND accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp.w [$FA60]		; DC 60 FA ; Jump long indirect [$FA60] [Flow: jump]
	pea $6CFA.w		; F4 FA 6C ; Push absolute address $6CFA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ror $2E94.w		; 6E 94 2E ; Rotate right $2E94.w [Flags: NCZ]
	sty $96.b,X		; 94 96 ; Store Y register $96.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	stz $F4.b		; 64 F4 ; Store zero to $F4.b
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr ($FEFE.w,X)		; FC FE FE ; Jump to subroutine indirect indexed ($FEFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ror $964E.w		; 6E 4E 96 ; Rotate right $964E.w [Flags: NCZ]
	pea $F7F0.w		; F4 F0 F7 ; Push absolute address $F7F0.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor $4DF6.w		; 4D F6 4D ; Exclusive OR $4DF6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $FF73.w,Y		; BE 73 FF ; Load X register $FF73.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	rol $0C7E.w		; 2E 7E 0C ; Rotate left $0C7E.w [Flags: NCZ]
	ora $0604.w		; 0D 04 06 ; Logical OR $0604.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $CF1400.l		; 22 00 14 CF ; Jump to subroutine long $CF1400.l [Writes: Stack Pointer] [Flow: call]
	sbc $73BFFF.l		; EF FF BF 73 ; Subtract with carry (long) $73BFFF.l [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	and $9A7FF6.l		; 2F F6 7F 9A ; AND accumulator with memory (long) $9A7FF6.l [Writes: Accumulator] [Flags: NZ]
	sta $7C8E6C.l,X		; 9F 6C 8E 7C ; Store accumulator (long,X) $7C8E6C.l,X [Reads: Accumulator, X Index]
	jmp $60F878.l		; 5C 78 F8 60 ; Jump long to $60F878.l [Flow: jump]
	.db $70, $22		; 70 22 ; Branch if overflow set to $70, $22 [Flow: branch]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FE68E0.l,X		; FF E0 68 FE ; Subtract with carry (long,X) $FE68E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $70B8.w,X		; BC B8 70 ; Load Y register $70B8.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $041B.w		; 0C 1B 04 ; Test and set bits $041B.w [Reads: Accumulator] [Flags: Z]
	asl $1F03.w,X		; 1E 03 1F ; Arithmetic shift left $1F03.w,X [Reads: X Index] [Flags: NCZ]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1D.b		; 05 1D ; Logical OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $17.b		; 06 17 ; Arithmetic shift left $17.b [Reads: Direct Page] [Flags: NCZ]
	ora $141C.w		; 0D 1C 14 ; Logical OR $141C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($13.b,S),Y		; 13 13 ; OR accumulator (stack relative indirect indexed) ($13.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1B.b,X		; 15 1B ; OR accumulator with memory $1B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$1E.b],Y		; 17 1E ; OR accumulator with memory (long indexed) [$1E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $7ED0.w,X		; 3C D0 7E ; Test bits $7ED0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ldy $5A.b,X		; B4 5A ; Load Y register $5A.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	.db $90, $D8		; 90 D8 ; Branch if carry clear to $90, $D8 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ldy $FE21.w,X		; BC 21 FE ; Load Y register $FE21.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$C2FF.w		; C0 FF C2 ; Compare #$C2FF.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $A3.b,S		; E3 A3 ; Subtract stack-relative $A3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $BFEFCF.l		; EF CF EF BF ; Subtract with carry (long) $BFEFCF.l [Writes: Accumulator] [Flags: NCVZ]
	dec $3D3F.w,X		; DE 3F 3D ; Decrement memory $3D3F.w,X [Reads: X Index] [Flags: NZ]
	jmp $0D0205.l		; 5C 05 02 0D ; Jump long to $0D0205.l [Flow: jump]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $070307.l		; 0F 07 03 07 ; OR accumulator with memory (long) $070307.l [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3F.b		; 05 3F ; Logical OR $3F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $3B.b		; 04 3B ; Test and set bits $3B.b [Reads: Accumulator] [Flags: Z]
	asl $5F79.w		; 0E 79 5F ; Arithmetic shift left $5F79.w [Flags: NCZ]
	adc $C63E.w		; 6D 3E C6 ; Add $C63E.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lda $ED3ED3.l,X		; BF D3 3E ED ; Load long $ED3ED3.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $FE5FF0.l,X		; 3F F0 5F FE ; AND accumulator with memory (long,X) $FE5FF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $7FFEBF.l,X		; FF BF FE 7F ; Subtract with carry (long,X) $7FFEBF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FFFF.w,X		; FE FF FF ; Increment memory $FFFF.w,X [Reads: X Index] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $03.b,S		; 43 03 ; Exclusive OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $FF.b,X		; 95 FF ; Store accumulator to $FF.b,X [Reads: Accumulator, X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $FF.b,X		; 35 FF ; Logical AND $FF.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $FF.b		; 65 FF ; Add $FF.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3F.b		; E5 3F ; Subtract $3F.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $7F3F.w		; 6D 3F 7F ; Add $7F3F.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $7F7F02.l,X		; FF 02 7F 7F ; Subtract with carry (long,X) $7F7F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $43.b,X		; 36 43 ; Rotate left $43.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $03.b		; 45 03 ; Exclusive OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $07.b		; 26 07 ; Rotate left $07.b [Reads: Direct Page] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$40.b],Y		; 97 40 ; Store accumulator (long indexed) [$40.b],Y [Reads: Direct Page, Y Index, Accumulator]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	bit $54AB.w		; 2C AB 54 ; Test bits $54AB.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	bit $37.b		; 24 37 ; Test bits $37.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $86.b,X		; 16 86 ; Arithmetic shift left $86.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc ($02.b,X)		; 61 02 ; Add with carry ($02.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$6F.b]		; 07 6F ; OR accumulator with memory (long) [$6F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$E5.b],Y		; D7 E5 ; Compare accumulator (long indexed) [$E5.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora [$07.b],Y		; 17 07 ; OR accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $002305.l		; 0F 05 23 00 ; OR accumulator with memory (long) $002305.l [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	ror $1F00.w,X		; 7E 00 1F ; Rotate right $1F00.w,X [Reads: X Index] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $F0.b		; 04 F0 ; Test and set bits $F0.b [Reads: Accumulator] [Flags: Z]
	ror $071F.w,X		; 7E 1F 07 ; Rotate right $071F.w,X [Reads: X Index] [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $3B0A.w,X		; 1D 0A 3B ; OR accumulator with memory $3B0A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $79.b		; 06 79 ; Arithmetic shift left $79.b [Reads: Direct Page] [Flags: NCZ]
	rol $FD.b,X		; 36 FD ; Rotate left $FD.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $4DF7.w		; 4E F7 4D ; Logical shift right $4DF7.w [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $3F1F.w,X		; 1E 1F 3F ; Arithmetic shift left $3F1F.w,X [Reads: X Index] [Flags: NCZ]
	adc $EFCD.w,X		; 7D CD EF ; Add $EFCD.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0C.b		; 09 0C ; Logical OR #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1EA3.w		; 0C A3 1E ; Test and set bits $1EA3.w [Reads: Accumulator] [Flags: Z]
	sbc [$9E.b]		; E7 9E ; Subtract with carry (long) [$9E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0022D6.l		; EF D6 22 00 ; Subtract with carry (long) $0022D6.l [Writes: Accumulator] [Flags: NCVZ]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	asl $FFBF.w,X		; 1E BF FF ; Arithmetic shift left $FFBF.w,X [Reads: X Index] [Flags: NCZ]
	sbc $090025.l,X		; FF 25 00 09 ; Subtract with carry (long,X) $090025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	and $1E.b,S		; 23 1E ; AND accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $2206.w,X		; 3D 06 22 ; AND accumulator with memory $2206.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $273F1F.l,X		; 1F 1F 3F 27 ; Logical OR long $273F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $C0.b		; 05 C0 ; Logical OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $FA.b		; 00 FA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$EAB5.w		; C0 B5 EA ; Compare #$EAB5.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sbc $83.b,X		; F5 83 ; Subtract $83.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1702.w		; 0D 02 17 ; Logical OR $1702.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$1D.b]		; 27 1D ; AND accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $4B.b,S		; 83 4B ; Store accumulator (stack relative) $4B.b,S [Reads: Stack Pointer, Accumulator]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $3F1F1F.l		; 0F 1F 1F 3F ; OR accumulator with memory (long) $3F1F1F.l [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$9E7D.w		; E0 7D 9E ; Compare #$9E7D.w with X register [Reads: X Index] [Flags: NCZ]
	inc $78.b,X		; F6 78 ; Increment memory $78.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cpx $E470.w		; EC 70 E4 ; Compare $E470.w with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy $9EF0.w		; CC F0 9E ; Compare $9EF0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$FEF8.w		; E0 F8 FE ; Compare #$FEF8.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $FCFCFE.l,X		; FF FE FC FC ; Subtract with carry (long,X) $FCFCFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pea $00EE.w		; F4 EE 00 ; Push absolute address $00EE.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $32.b		; 00 32 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B2.b		; 00 B2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6E.b		; 00 6E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $5D2E.w		; 1C 2E 5D ; Test and reset bits $5D2E.w [Reads: Accumulator] [Flags: Z]
	sbc $315FFF.l		; EF FF 5F 31 ; Subtract with carry (long) $315FFF.l [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EA.b		; 00 EA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $95.b		; 00 95 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $E8		; 70 E8 ; Branch if overflow set to $70, $E8 [Flow: branch]
	pea $F7EE.w		; F4 EE F7 ; Push absolute address $F7EE.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sbc $00277D.l,X		; FF 7D 27 00 ; Subtract with carry (long,X) $00277D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3B.b		; 00 3B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $37.b		; 05 37 ; Logical OR $37.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0023.w		; 0D 23 00 ; Logical OR $0023.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $26.b,X		; 15 26 ; OR accumulator with memory $26.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $0026.w		; 2E 26 00 ; Rotate left $0026.w [Flags: NCZ]
	adc $0FFF06.l,X		; 7F 06 FF 0F ; Add long $0FFF06.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FD2D.w,X		; 7D 2D FD ; Add $FD2D.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FE.b		; 05 FE ; Logical OR $FE.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $03FF.w		; 8E FF 03 ; Store X register to $03FF.w [Reads: X Index]
	sbc ($A0.b)		; F2 A0 ; Subtract with carry (indirect) ($A0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $59.b		; 26 59 ; Rotate left $59.b [Reads: Direct Page] [Flags: NCZ]
	.db $B0, $52		; B0 52 ; Branch if carry set to $B0, $52 [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	eor ($AC.b),Y		; 51 AC ; Exclusive OR accumulator with memory ($AC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $50F043.l,X		; 5F 43 F0 50 ; Exclusive OR accumulator with memory (long,X) $50F043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$FB2B.w		; E0 2B FB ; Compare #$FB2B.w with X register [Reads: X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	adc ($11.b),Y		; 71 11 ; Add with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($21.b,X)		; 61 21 ; Add with carry ($21.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $22.b,S		; 63 22 ; Add with carry (stack relative) $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ror $25.b		; 66 25 ; Rotate right $25.b [Reads: Direct Page] [Flags: NCZ]
	bit $03.b		; 24 03 ; Test bits $03.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	lda $6EF4AF.l		; AF AF F4 6E ; Load long $6EF4AF.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $5B5D.w,X		; 5E 5D 5B ; Logical shift right $5B5D.w,X [Reads: X Index] [Flags: NCZ]
	and $3C487B.l,X		; 3F 7B 48 3C ; AND accumulator with memory (long,X) $3C487B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $0F.b,X		; 35 0F ; Logical AND $0F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$27.b]		; E7 27 ; Subtract with carry (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	adc $04FB92.l		; 6F 92 FB 04 ; Add with carry (long) $04FB92.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $CAB700.l,X		; FF 00 B7 CA ; Subtract with carry (long,X) $CAB700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$D8.b],Y		; F7 D8 ; Subtract with carry (long indexed) [$D8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$9D.b],Y		; F7 9D ; Subtract with carry (long indexed) [$9D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $1F.b,S		; 43 1F ; Exclusive OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1F3F13.l		; 0F 13 3F 1F ; OR accumulator with memory (long) $1F3F13.l [Writes: Accumulator] [Flags: NZ]
	adc $1BFF3B.l,X		; 7F 3B FF 1B ; Add long $1BFF3B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0F5F07.l,X		; FF 07 5F 0F ; Subtract with carry (long,X) $0F5F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $1F1F07.l,X		; 7F 07 1F 1F ; Add long $1F1F07.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $BFFF7F.l,X		; 3F 7F FF BF ; AND accumulator with memory (long,X) $BFFF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $80455F.l,X		; 7F 5F 45 80 ; Add long $80455F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFC043.l,X		; FF 43 C0 FF ; Subtract with carry (long,X) $FFC043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $D0.b		; 05 D0 ; Logical OR $D0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $D97FD1.l,X		; FF D1 7F D9 ; Subtract with carry (long,X) $D97FD1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $27FF27.l,X		; 7F 27 FF 27 ; Add long $27FF27.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $45BB.w		; 20 BB 45 ; Jump to subroutine at $45BB.w [Writes: Stack Pointer] [Flow: call]
	lda [$6D.b],Y		; B7 6D ; Load accumulator (long indexed) [$6D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$38.b		; 09 38 ; Logical OR #$38.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $C6.b		; 65 C6 ; Add $C6.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $00B0.w		; EE B0 00 ; Increment $00B0.w [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	.db $D0, $20		; D0 20 ; Branch if not equal to $D0, $20 [Flow: branch]
	sta $68.b,S		; 83 68 ; Store accumulator (stack relative) $68.b,S [Reads: Stack Pointer, Accumulator]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	.db $90, $60		; 90 60 ; Branch if carry clear to $90, $60 [Flow: branch]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	.db $D0, $90		; D0 90 ; Branch if not equal to $D0, $90 [Flow: branch]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	.db $D0, $D0		; D0 D0 ; Branch if not equal to $D0, $D0 [Flow: branch]
	.db $F0, $70		; F0 70 ; Branch if equal to $F0, $70 [Flow: branch]
	lda [$7D.b]		; A7 7D ; Load accumulator (long) [$7D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $9F03.w,X		; 7E 03 9F ; Rotate right $9F03.w,X [Reads: X Index] [Flags: NCZ]
	ora $1C1C7F.l,X		; 1F 7F 1C 1C ; Logical OR long $1C1C7F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	adc $1C6FEF.l,X		; 7F EF 6F 1C ; Add long $1C6FEF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $3F0C00.l		; 22 00 0C 3F ; Jump to subroutine long $3F0C00.l [Writes: Stack Pointer] [Flow: call]
	sbc ($1F.b)		; F2 1F ; Subtract with carry (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dec $F4F8.w		; CE F8 F4 ; Decrement $F4F8.w [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	inc $3E38.w,X		; FE 38 3E ; Increment memory $3E38.w,X [Reads: X Index] [Flags: NZ]
	trb $221C.w		; 1C 1C 22 ; Test and reset bits $221C.w [Reads: Accumulator] [Flags: Z]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FCFEFF.l,X		; FF FF FE FC ; Subtract with carry (long,X) $FCFEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $22.b,X		; F6 22 ; Increment memory $22.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	trb $5F00.w		; 1C 00 5F ; Test and reset bits $5F00.w [Reads: Accumulator] [Flags: Z]
	and $9B.b,S		; 23 9B ; AND accumulator with stack relative $9B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $7F.b,X		; 76 7F ; Rotate right $7F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $011F.w,X		; 1D 1F 01 ; OR accumulator with memory $011F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($97.b,S),Y		; 53 97 ; XOR accumulator (stack relative indirect indexed) ($97.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $16831F.l,X		; 7F 1F 83 16 ; Add long $16831F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cpx $24.b		; E4 24 ; Compare $24.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sty $43.b,X		; 94 43 ; Store Y register $43.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	adc $1882.w,X		; 7D 82 18 ; Add $1882.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $DCC0.w,Y		; BE C0 DC ; Load X register $DCC0.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsr $0030.w		; 20 30 00 ; Jump to subroutine at $0030.w [Writes: Stack Pointer] [Flow: call]
.ACCU 8
	sep #$E4		; E2 E4
	lda ($91.b)		; B2 91 ; Load accumulator (indirect) ($91.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $ECCA.w,Y		; B9 CA EC ; Load $ECCA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $3E		; 30 3E ; Branch if minus to $30, $3E [Flow: branch]
	ora $5D.b		; 05 5D ; Logical OR $5D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $9B.b,S		; 23 9B ; AND accumulator with stack relative $9B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $7E.b,X		; 76 7E ; Rotate right $7E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $021D.w,X		; 1D 1D 02 ; OR accumulator with memory $021D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$53.b]		; 27 53 ; AND accumulator with memory (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$7F.b],Y		; 97 7F ; Store accumulator (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index, Accumulator]
	asl $0003.w,X		; 1E 03 00 ; Arithmetic shift left $0003.w,X [Reads: X Index] [Flags: NCZ]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	pei ($54.b)		; D4 54 ; Push effective indirect address ($54.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sty $ED.b		; 84 ED ; Store Y register to $ED.b [Reads: Y Index]
	cop $CD.b		; 02 CD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9D.b		; 00 9D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($E4.b)		; F2 E4 ; Subtract with carry (indirect) ($E4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($29.b)		; 92 29 ; Store accumulator (indirect) ($29.b) [Reads: Direct Page, Accumulator]
	cmp #$0A.b		; C9 0A ; Compare #$0A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	cpx #$0500.w		; E0 00 05 ; Compare #$0500.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $98.b,S		; 83 98 ; Store accumulator (stack relative) $98.b,S [Reads: Stack Pointer, Accumulator]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	ora $0F0F.w		; 0D 0F 0F ; Logical OR $0F0F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $00.b,X		; D6 00 ; Decrement memory $00.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ldy $7040.w		; AC 40 70 ; Load $7040.w into Y register [Writes: Y Index] [Flags: NZ]
	cpx #$C0F0.w		; E0 F0 C0 ; Compare #$C0F0.w with X register [Reads: X Index] [Flags: NCZ]
	.db $50, $A0		; 50 A0 ; Branch if overflow clear to $50, $A0 [Flow: branch]
	.db $30, $E0		; 30 E0 ; Branch if minus to $30, $E0 [Flow: branch]
	cpx #$C0C0.w		; E0 C0 C0 ; Compare #$C0C0.w with X register [Reads: X Index] [Flags: NCZ]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $D0F0.w		; EC F0 D0 ; Compare $D0F0.w with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $F0		; B0 F0 ; Branch if carry set to $B0, $F0 [Flow: branch]
	cpx #$26C0.w		; E0 C0 26 ; Compare #$26C0.w with X register [Reads: X Index] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	rol $2F0A.w,X		; 3E 0A 2F ; Rotate left $2F0A.w,X [Reads: X Index] [Flags: NCZ]
	ora [$3F.b],Y		; 17 3F ; OR accumulator with memory (long indexed) [$3F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: NCZ]
	tsb $183F.w		; 0C 3F 18 ; Test and set bits $183F.w [Reads: Accumulator] [Flags: Z]
	adc $F835.w,X		; 7D 35 F8 ; Add $F835.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and $382D.w,X		; 3D 2D 38 ; AND accumulator with memory $382D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $2733.w,Y		; 39 33 27 ; AND accumulator with memory $2733.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta [$FC.b],Y		; 97 FC ; Store accumulator (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index, Accumulator]
	cpy $7F.b		; C4 7F ; Compare $7F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ora $FE.b,S		; 03 FE ; OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $40C8.w		; 20 C8 40 ; Jump to subroutine at $40C8.w [Writes: Stack Pointer] [Flow: call]
	stx $8B08.w		; 8E 08 8B ; Store X register to $8B08.w [Reads: X Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $D0, $50		; D0 50 ; Branch if not equal to $D0, $50 [Flow: branch]
	pea $3FB1.w		; F4 B1 3F ; Push absolute address $3FB1.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	inc $BFDF.w		; EE DF BF ; Increment $BFDF.w [Flags: NZ]
	sbc [$F5.b],Y		; F7 F5 ; Subtract with carry (long indexed) [$F5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $0B2C4E.l		; AF 4E 2C 0B ; Load long $0B2C4E.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $BF0B.w		; 4E 0B BF ; Logical shift right $BF0B.w [Flags: NCZ]
	and ($F3.b,X)		; 21 F3 ; Logical AND ($F3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $37190F.l,X		; 1F 0F 19 37 ; Logical OR long $37190F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$DF.b],Y		; 77 DF ; Add with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($07.b,S),Y		; F3 07 ; Subtract with carry (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF1F1F.l		; 0F 1F 1F FF ; OR accumulator with memory (long) $FF1F1F.l [Writes: Accumulator] [Flags: NZ]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	sbc $FFFFC7.l,X		; FF C7 FF FF ; Subtract with carry (long,X) $FFFFC7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $C0FFF0.l,X		; 3F F0 FF C0 ; AND accumulator with memory (long,X) $C0FFF0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $00FF80.l,X		; FF 80 FF 00 ; Subtract with carry (long,X) $00FF80.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$25.b]		; 87 25 ; Store accumulator (long) [$25.b] [Reads: Direct Page, Accumulator]
	sbc $062F0A.l,X		; FF 0A 2F 06 ; Subtract with carry (long,X) $062F0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $011B01.l,X		; 3F 01 1B 01 ; AND accumulator with memory (long,X) $011B01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $000700.l		; 0F 00 07 00 ; OR accumulator with memory (long) $000700.l [Writes: Accumulator] [Flags: NZ]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0B1F2F.l,X		; 3F 2F 1F 0B ; AND accumulator with memory (long,X) $0B1F2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $39FF.w,Y		; 99 FF 39 ; Store accumulator to $39FF.w,Y [Reads: Y Index, Accumulator]
	sbc $FFEEF3.l		; EF F3 EE FF ; Subtract with carry (long) $FFEEF3.l [Writes: Accumulator] [Flags: NCVZ]
	trb $01BF.w		; 1C BF 01 ; Test and reset bits $01BF.w [Reads: Accumulator] [Flags: Z]
	nop		; EA ; No operation
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $BFFE0F.l,X		; FF 0F FE BF ; Subtract with carry (long,X) $BFFE0F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	ora $9E.b,X		; 15 9E ; OR accumulator with memory $9E.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ldx $BF4A.w,Y		; BE 4A BF ; Load X register $BF4A.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor [$BF.b]		; 47 BF ; Exclusive OR accumulator with memory (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $BF.b		; 46 BF ; Logical shift right $BF.b [Reads: Direct Page] [Flags: NCZ]
	jmp $58BF.w		; 4C BF 58 ; Jump to $58BF.w [Flow: jump]
	sta $64.b,S		; 83 64 ; Store accumulator (stack relative) $64.b,S [Reads: Stack Pointer, Accumulator]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $C8CD.w,X		; FD CD C8 ; Subtract with carry $C8CD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$F3.b		; C9 F3 ; Compare #$F3.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc [$4A.b]		; E7 4A ; Subtract with carry (long) [$4A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta [$FF.b],Y		; 97 FF ; Store accumulator (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora $400080.l		; 0F 80 00 40 ; OR accumulator with memory (long) $400080.l [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($10.b)		; 12 10 ; OR accumulator with memory (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $10.b,X		; 15 10 ; OR accumulator with memory $10.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $C4.b		; 00 C4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$3030.w		; C0 30 30 ; Compare #$3030.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($10.b)		; D2 10 ; Compare accumulator (indirect) ($10.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpx $E808.w		; EC 08 E8 ; Compare $E808.w with X register [Reads: X Index] [Flags: NCZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $1010.w		; 20 10 10 ; Jump to subroutine at $1010.w [Writes: Stack Pointer] [Flow: call]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $80.b		; 05 80 ; Logical OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0025.w		; 20 25 00 ; Jump to subroutine at $0025.w [Writes: Stack Pointer] [Flow: call]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx $27.b		; E4 27 ; Compare $27.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $2F		; 80 2F ; Branch always to $80, $2F [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	ora $3FE7.w		; 0D E7 3F ; Logical OR $3FE7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $2F3E56.l		; 0F 56 3E 2F ; OR accumulator with memory (long) $2F3E56.l [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	asl $0000.w		; 0E 00 00 ; Arithmetic shift left $0000.w [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp [$00.b]		; C7 00 ; Compare accumulator (long) [$00.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ror $F441.w		; 6E 41 F4 ; Rotate right $F441.w [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sbc $F7A6.w,Y		; F9 A6 F7 ; Subtract with carry $F7A6.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	inc $0051.w		; EE 51 00 ; Increment $0051.w [Flags: NZ]
	ora $C5.b,S		; 03 C5 ; OR accumulator with stack relative $C5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$5B.b		; A9 5B ; Load #$5B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	eor $C0B1DF.l,X		; 5F DF B1 C0 ; Exclusive OR accumulator with memory (long,X) $C0B1DF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($6C.b)		; B2 6C ; Load accumulator (indirect) ($6C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $FA70.w,X		; FE 70 FA ; Increment memory $FA70.w,X [Reads: X Index] [Flags: NZ]
	jmp $60E0C0.l		; 5C C0 E0 60 ; Jump long to $60E0C0.l [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	pea $FEF2.w		; F4 F2 FE ; Push absolute address $FEF2.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	inc $0003.w,X		; FE 03 00 ; Increment memory $0003.w,X [Reads: X Index] [Flags: NZ]
	ora [$44.b]		; 07 44 ; OR accumulator with memory (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $F2.b,S		; 83 F2 ; Store accumulator (stack relative) $F2.b,S [Reads: Stack Pointer, Accumulator]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $1F00.w		; 1C 00 1F ; Test and reset bits $1F00.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	trb $13.b		; 14 13 ; Test and reset bits $13.b [Reads: Accumulator] [Flags: Z]
	cpx #$F000.w		; E0 00 F0 ; Compare #$F000.w with X register [Reads: X Index] [Flags: NCZ]
	mvp $F8,$00		; 44 00 F8 ; Move block positive $F8,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $0A.b,S		; 83 0A ; Store accumulator (stack relative) $0A.b,S [Reads: Stack Pointer, Accumulator]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $7C.b,S		; 23 7C ; AND accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $E8		; 10 E8 ; Branch if plus to $10, $E8 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $50, $E8		; 50 E8 ; Branch if overflow clear to $50, $E8 [Flow: branch]
	bit $14.b,X		; 34 14 ; Test bits $14.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: NZ]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: NZ]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $977FBF.l,X		; DF BF 7F 97 ; Compare accumulator (long,X) $977FBF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	jsr $F001.w		; 20 01 F0 ; Jump to subroutine at $F001.w [Writes: Stack Pointer] [Flow: call]
	and $0C0120.l		; 2F 20 01 0C ; AND accumulator with memory (long) $0C0120.l [Writes: Accumulator] [Flags: NZ]
	and [$10.b],Y		; 37 10 ; AND accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $040D08.l		; 0F 08 0D 04 ; OR accumulator with memory (long) $040D08.l [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,S),Y		; 13 02 ; OR accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $0200.w		; 0C 00 02 ; Test and set bits $0200.w [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$D8.b		; 09 D8 ; Logical OR #$D8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	.db $D0, $C0		; D0 C0 ; Branch if not equal to $D0, $C0 [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $20.b,S		; 03 20 ; OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $50, $20		; 50 20 ; Branch if overflow clear to $50, $20 [Flow: branch]
	cpy #$0023.w		; C0 23 00 ; Compare #$0023.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $040000.l		; 22 00 00 04 ; Jump to subroutine long $040000.l [Writes: Stack Pointer] [Flow: call]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	asl $A0.b		; 06 A0 ; Arithmetic shift left $A0.b [Reads: Direct Page] [Flags: NCZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $10		; 80 10 ; Branch always to $80, $10 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $35		; 80 35 ; Branch always to $80, $35 [Flow: branch]
	brk $87.b		; 00 87 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	trb $DE37.w		; 1C 37 DE ; Test and reset bits $DE37.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	trb $04.b		; 14 04 ; Test and reset bits $04.b [Reads: Accumulator] [Flags: Z]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	asl $0703.w,X		; 1E 03 07 ; Arithmetic shift left $0703.w,X [Reads: X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $DD1200.l		; 22 00 12 DD ; Jump to subroutine long $DD1200.l [Writes: Stack Pointer] [Flow: call]
	ldx #$659B.w		; A2 9B 65 ; Load #$659B.w into X register [Writes: X Index] [Flags: NZ]
	ora ($ED.b,S),Y		; 13 ED ; OR accumulator (stack relative indirect indexed) ($ED.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$BB.b]		; 47 BB ; Exclusive OR accumulator with memory (long) [$BB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$1B.b]		; E7 1B ; Subtract with carry (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FF03.l,X		; FF 03 FF 00 ; Subtract with carry (long,X) $00FF03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $E76300.l,X		; 3F 00 63 E7 ; AND accumulator with memory (long,X) $E76300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0DFF23.l		; EF 23 FF 0D ; Subtract with carry (long) $0DFF23.l [Writes: Accumulator] [Flags: NCVZ]
	and $FD3CFA.l,X		; 3F FA 3C FD ; AND accumulator with memory (long,X) $FD3CFA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($F3.b)		; B2 F3 ; Load accumulator (indirect) ($F3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $EB		; 80 EB ; Branch always to $80, $EB [Flow: branch]
	.db $D0, $E5		; D0 E5 ; Branch if not equal to $D0, $E5 [Flow: branch]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc ($0E.b),Y		; F1 0E ; Subtract with carry ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $0022.w		; EE 22 00 ; Increment $0022.w [Flags: NZ]
	asl $FE.b		; 06 FE ; Arithmetic shift left $FE.b [Reads: Direct Page] [Flags: NCZ]
	sbc $EFFF.w,X		; FD FF EF ; Subtract with carry $EFFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F1.b		; E5 F1 ; Subtract $F1.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $0044.w		; EE 44 00 ; Increment $0044.w [Flags: NZ]
	ora $001C43.l,X		; 1F 43 1C 00 ; Logical OR long $001C43.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $F6.b,S		; 83 F6 ; Store accumulator (stack relative) $F6.b,S [Reads: Stack Pointer, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $17.b		; 14 17 ; Test and reset bits $17.b [Reads: Accumulator] [Flags: Z]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $3C,$00		; 44 00 3C ; Move block positive $3C,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $0E.b,S		; 83 0E ; Store accumulator (stack relative) $0E.b,S [Reads: Stack Pointer, Accumulator]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$0022.w		; E0 22 00 ; Compare #$0022.w with X register [Reads: X Index] [Flags: NCZ]
	ora [$B4.b]		; 07 B4 ; OR accumulator with memory (long) [$B4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stz $14.b,X		; 74 14 ; Store zero to $14.b,X [Reads: X Index]
	trb $E8.b		; 14 E8 ; Test and reset bits $E8.b [Reads: Accumulator] [Flags: Z]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $230120.l,X		; 5F 20 01 23 ; Exclusive OR accumulator with memory (long,X) $230120.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1000.w		; 20 00 10 ; Jump to subroutine at $1000.w [Writes: Stack Pointer] [Flow: call]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$08.b		; 09 08 ; Logical OR #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$2020.w		; C0 20 20 ; Compare #$2020.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $10		; D0 10 ; Branch if not equal to $D0, $10 [Flow: branch]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$2020.w		; C0 20 20 ; Compare #$2020.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $012700.l		; 2F 00 27 01 ; AND accumulator with memory (long) $012700.l [Writes: Accumulator] [Flags: NZ]
	cpx $47.b		; E4 47 ; Compare $47.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $7F00.w,X		; 3C 00 7F ; Test bits $7F00.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $F3.b,X		; 34 F3 ; Test bits $F3.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rep #$40		; C2 40 ; Reset processor status bits #$40 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	jsr ($F970.w,X)		; FC 70 F9 ; Jump to subroutine indirect indexed ($F970.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $0F7F.w,Y		; 39 7F 0F ; AND accumulator with memory $0F7F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $BC4B.w,X		; 3C 4B BC ; Test bits $BC4B.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	lda $C68FBF.l,X		; BF BF 8F C6 ; Load long $C68FBF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $23		; 70 23 ; Branch if overflow set to $70, $23 [Flow: branch]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$6E00.w		; C0 00 6E ; Compare #$6E00.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $AA.b,X		; F5 AA ; Subtract $AA.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $A9.b,X		; F6 A9 ; Increment memory $A9.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $FC21.w,X		; FE 21 FC ; Increment memory $FC21.w,X [Reads: X Index] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $5D5B.w		; AE 5B 5D ; Load $5D5B.w into X register [Writes: X Index] [Flags: NZ]
	cmp $25B3.w,Y		; D9 B3 25 ; Compare accumulator $25B3.w,Y [Reads: Y Index] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $D4.b		; 00 D4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sta $E2.b		; 85 E2 ; Store accumulator to $E2.b [Reads: Accumulator]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	sta $EC.b,S		; 83 EC ; Store accumulator (stack relative) $EC.b,S [Reads: Stack Pointer, Accumulator]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0A00.w		; 2E 00 0A ; Rotate left $0A00.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $03		; 90 03 ; Branch if carry clear to $90, $03 [Flow: branch]
	ora $C4.b		; 05 C4 ; Logical OR $C4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dec $FE40.w		; CE 40 FE ; Decrement $FE40.w [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta [$9C.b]		; 87 9C ; Store accumulator (long) [$9C.b] [Reads: Direct Page, Accumulator]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sta ($C6.b),Y		; 91 C6 ; Store accumulator ($C6.b),Y [Reads: Direct Page, Y Index, Accumulator]
	.db $70, $23		; 70 23 ; Branch if overflow set to $70, $23 [Flow: branch]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $40		; 10 40 ; Branch if plus to $10, $40 [Flow: branch]
	.db $10, $04		; 10 04 ; Branch if plus to $10, $04 [Flow: branch]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $39		; 10 39 ; Branch if plus to $10, $39 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldy $1800.w,X		; BC 00 18 ; Load Y register $1800.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	ora $F098.w,Y		; 19 98 F0 ; OR accumulator with memory $F098.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sta $0B4302.l,X		; 9F 02 43 0B ; Store accumulator (long,X) $0B4302.l,X [Reads: Accumulator, X Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $D0, $00		; D0 00 ; Branch if not equal to $D0, $00 [Flow: branch]
	.db $B0, $10		; B0 10 ; Branch if carry set to $B0, $10 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C0C0.w		; 20 C0 C0 ; Jump to subroutine at $C0C0.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $24.b		; 04 24 ; Test and set bits $24.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8040.w		; 20 40 80 ; Jump to subroutine at $8040.w [Writes: Stack Pointer] [Flow: call]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $27.b		; E4 27 ; Compare $27.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $000036.l,X		; FF 36 00 00 ; Subtract with carry (long,X) $000036.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0C0026.l,X		; FF 26 00 0C ; Subtract with carry (long,X) $0C0026.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $387F23.l		; 6F 23 7F 38 ; Add with carry (long) $387F23.l [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	ora #$18.b		; 09 18 ; Logical OR #$18.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $5C1100.l		; 22 00 11 5C ; Jump to subroutine long $5C1100.l [Writes: Stack Pointer] [Flow: call]
	eor [$3E.b]		; 47 3E ; Exclusive OR accumulator with memory (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F1F.w,Y		; 19 1F 0F ; OR accumulator with memory $0F1F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $A586.w,Y		; F9 86 A5 ; Subtract with carry $A586.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $27		; 42 27 ; Reserved instruction
	cpy $5F.b		; C4 5F ; Compare $5F.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	lda $13EF.w		; AD EF 13 ; Load $13EF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $4A.b		; 85 4A ; Store accumulator to $4A.b [Reads: Accumulator]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $F3FBFF.l,X		; 7F FF FB F3 ; Add long $F3FBFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $578DFF.l		; 22 FF 8D 57 ; Jump to subroutine long $578DFF.l [Writes: Stack Pointer] [Flow: call]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	mvp $24,$00		; 44 00 24 ; Move block positive $24,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0400.w		; 2C 00 04 ; Test bits $0400.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $C30000.l		; 22 00 00 C3 ; Jump to subroutine long $C30000.l [Writes: Stack Pointer] [Flow: call]
	jsl $2A0200.l		; 22 00 02 2A ; Jump to subroutine long $2A0200.l [Writes: Stack Pointer] [Flow: call]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $30,$E8		; 44 E8 30 ; Move block positive $30,$E8 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	bit $2810.w		; 2C 10 28 ; Test bits $2810.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	bit $7E.b		; 24 7E ; Test bits $7E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	trb $187E.w		; 1C 7E 18 ; Test and reset bits $187E.w [Reads: Accumulator] [Flags: Z]
	jmp ($3800.w,X)		; 7C 00 38 ; Jump indirect indexed to ($3800.w,X) [Reads: X Index] [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	bit $3C08.w		; 2C 08 3C ; Test bits $3C08.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	trb $0018.w		; 1C 18 00 ; Test and reset bits $0018.w [Reads: Accumulator] [Flags: Z]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $1000.w		; 20 00 10 ; Jump to subroutine at $1000.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $F0, $47		; F0 47 ; Branch if equal to $F0, $47 [Flow: branch]
	sta $7F0002.l,X		; 9F 02 00 7F ; Store accumulator (long,X) $7F0002.l,X [Reads: Accumulator, X Index]
	sbc $00030A.l,X		; FF 0A 03 00 ; Subtract with carry (long,X) $00030A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $003F00.l,X		; 1F 00 3F 00 ; Logical OR long $003F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($7B00.w,X)		; 7C 00 7B ; Jump indirect indexed to ($7B00.w,X) [Reads: X Index] [Flow: jump]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $EF,$00		; 44 00 EF ; Move block positive $EF,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $3F1F03.l,X		; 1F 03 1F 3F ; Logical OR long $3F1F03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $F9FC7F.l,X		; 7F 7F FC F9 ; Add long $F9FC7F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cpx #$FC00.w		; E0 00 FC ; Compare #$FC00.w with X register [Reads: X Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$D1.b]		; 07 D1 ; OR accumulator with memory (long) [$D1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($EE.b,X)		; 01 EE ; Logical OR ($EE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $07F7.w		; 0E F7 07 ; Arithmetic shift left $07F7.w [Flags: NCZ]
	sbc [$06.b],Y		; F7 06 ; Subtract with carry (long indexed) [$06.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$FFFC.w		; E0 FC FF ; Compare #$FFFC.w with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $9831.w,X		; FE 31 98 ; Increment memory $9831.w,X [Reads: X Index] [Flags: NZ]
	cmp $0023.w,Y		; D9 23 00 ; Compare accumulator $0023.w,Y [Reads: Y Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$F880.w		; E0 80 F8 ; Compare #$F880.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$007C.w		; E0 7C 00 ; Compare #$007C.w with X register [Reads: X Index] [Flags: NCZ]
	inc $FF60.w,X		; FE 60 FF ; Increment memory $FF60.w,X [Reads: X Index] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($E19E.w,X)		; FC 9E E1 ; Jump to subroutine indirect indexed ($E19E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $00		; 50 00 ; Branch if overflow clear to $50, $00 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sta $49.b,S		; 83 49 ; Store accumulator (stack relative) $49.b,S [Reads: Stack Pointer, Accumulator]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0000.w		; 2E 00 00 ; Rotate left $0000.w [Flags: NCZ]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$84.b]		; 07 84 ; OR accumulator with memory (long) [$84.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($7F.b),Y		; 11 7F ; OR accumulator with memory ($7F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $DF.b		; 00 DF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($9F.b,X)		; 01 9F ; Logical OR ($9F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b),Y		; 11 00 ; OR accumulator with memory ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $BE5F3F.l,X		; 1F 3F 5F BE ; Logical OR long $BE5F3F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $0008.w		; 6E 08 00 ; Rotate right $0008.w [Flags: NCZ]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	sta $A8.b,S		; 83 A8 ; Store accumulator (stack relative) $A8.b,S [Reads: Stack Pointer, Accumulator]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0400.w		; 0C 00 04 ; Test and set bits $0400.w [Reads: Accumulator] [Flags: Z]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C3.b		; 00 C3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $25		; 80 25 ; Branch always to $80, $25 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $41		; 80 41 ; Branch always to $80, $41 [Flow: branch]
	ora ($46.b,X)		; 01 46 ; Logical OR ($46.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora [$44.b]		; 07 44 ; OR accumulator with memory (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $820605.l		; 22 05 06 82 ; Jump to subroutine long $820605.l [Writes: Stack Pointer] [Flow: call]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E5.b		; 00 E5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	sep #$04		; E2 04 ; Set processor status bits #$04 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc $80.b,S		; E3 80 ; Subtract stack-relative $80.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpy #$E023.w		; C0 23 E0 ; Compare #$E023.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr $0424.w		; 20 24 04 ; Jump to subroutine at $0424.w [Writes: Stack Pointer] [Flow: call]
	bit $08.b		; 24 08 ; Test bits $08.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $2418.w,X		; 1D 18 24 ; OR accumulator with memory $2418.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $83FFE9.l,X		; 3F E9 FF 83 ; AND accumulator with memory (long,X) $83FFE9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $839F80.l,X		; BF 80 9F 83 ; Load long $839F80.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($55C4.w)		; 6C C4 55 ; Jump indirect to ($55C4.w) [Flow: jump]
	cmp $5F.b,S		; C3 5F ; Compare accumulator (stack relative) $5F.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cpy #$C04F.w		; C0 4F C0 ; Compare #$C04F.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $5BF4E3.l		; EF E3 F4 5B ; Subtract with carry (long) $5BF4E3.l [Writes: Accumulator] [Flags: NCVZ]
	adc $7063.w		; 6D 63 70 ; Add $7063.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $29.b		; 02 29 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0024.w		; 20 24 00 ; Jump to subroutine at $0024.w [Writes: Stack Pointer] [Flow: call]
	ora [$FE.b],Y		; 17 FE ; OR accumulator with memory (long indexed) [$FE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $FBBFFD.l,X		; 7F FD BF FB ; Add long $FBBFFD.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $EFEFF7.l,X		; DF F7 EF EF ; Compare accumulator (long,X) $EFEFF7.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc [$DF.b],Y		; F7 DF ; Subtract with carry (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: NZ]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $977FBF.l,X		; DF BF 7F 97 ; Compare accumulator (long,X) $977FBF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $50, $01		; 50 01 ; Branch if overflow clear to $50, $01 [Flow: branch]
	eor $EF.b,S		; 43 EF ; Exclusive OR accumulator with stack relative $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F7C.w		; 0C 7C 0F ; Test and set bits $0F7C.w [Reads: Accumulator] [Flags: Z]
	jmp ($291E.w)		; 6C 1E 29 ; Jump indirect to ($291E.w) [Flow: jump]
	trb $F9FB.w		; 1C FB F9 ; Test and reset bits $F9FB.w [Reads: Accumulator] [Flags: Z]
	jsr ($7F22.w,X)		; FC 22 7F ; Jump to subroutine indirect indexed ($7F22.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$6F49.w		; E0 49 6F ; Compare #$6F49.w with X register [Reads: X Index] [Flags: NCZ]
	and $F304F7.l		; 2F F7 04 F3 ; AND accumulator with memory (long) $F304F7.l [Writes: Accumulator] [Flags: NZ]
	brk $EF.b		; 00 EF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cmp $3C3F18.l,X		; DF 18 3F 3C ; Compare accumulator (long,X) $3C3F18.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	and $1FDF3E.l,X		; 3F 3E DF 1F ; AND accumulator with memory (long,X) $1FDF3E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $9FDB0F.l		; EF 0F DB 9F ; Subtract with carry (long) $9FDB0F.l [Writes: Accumulator] [Flags: NCVZ]
	bit $E7.b,X		; 34 E7 ; Test bits $E7.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cmp $C1.b,S		; C3 C1 ; Compare accumulator (stack relative) $C1.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cpx #$F730.w		; E0 30 F7 ; Compare #$F730.w with X register [Reads: X Index] [Flags: NCZ]
	ora [$FB.b]		; 07 FB ; OR accumulator with memory (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $9E7D.w,X		; FD 7D 9E ; Subtract with carry $9E7D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $22EF.w,X		; 1E EF 22 ; Arithmetic shift left $22EF.w,X [Reads: X Index] [Flags: NCZ]
	sbc ($0C.b,S),Y		; F3 0C ; Subtract with carry (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $10FF00.l,X		; FF 00 FF 10 ; Subtract with carry (long,X) $10FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sty $02.b		; 84 02 ; Store Y register to $02.b [Reads: Y Index]
	adc ($9D.b,X)		; 61 9D ; Add with carry ($9D.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $8FCFEC.l,X		; DF EC CF 8F ; Compare accumulator (long,X) $8FCFEC.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora ($DF.b,X)		; 01 DF ; Logical OR ($DF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $93FD.w		; 8D FD 93 ; Store accumulator to $93FD.w [Reads: Accumulator]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	eor #$75.b		; 49 75 ; Exclusive OR #$75.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$92EB.w		; C0 EB 92 ; Compare #$92EB.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $8D.b,X		; 15 8D ; OR accumulator with memory $8D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $B67D.w,X		; 5D 7D B6 ; Exclusive OR accumulator with memory $B67D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $3BB7.w		; ED B7 3B ; Subtract $3BB7.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $034300.l		; 22 00 43 03 ; Jump to subroutine long $034300.l [Writes: Stack Pointer] [Flow: call]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $80.b		; 86 80 ; Store X register to $80.b [Reads: X Index]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $0044.w		; 0D 44 00 ; Logical OR $0044.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $1A12.w		; 0C 12 1A ; Test and set bits $1A12.w [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $1E.b,X		; 15 1E ; OR accumulator with memory $1E.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $19DF.w,Y		; 19 DF 19 ; OR accumulator with memory $19DF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $1F1846.l,X		; 3F 46 18 1F ; AND accumulator with memory (long,X) $1F1846.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $26E6EE.l		; EF EE E6 26 ; Subtract with carry (long) $26E6EE.l [Writes: Accumulator] [Flags: NCVZ]
	cmp [$E7.b]		; C7 E7 ; Compare accumulator (long) [$E7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	inc $E7.b		; E6 E7 ; Increment $E7.b [Reads: Direct Page] [Flags: NZ]
	sbc $0D3FC1.l,X		; FF C1 3F 0D ; Subtract with carry (long,X) $0D3FC1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	cpy $0101.w		; CC 01 01 ; Compare $0101.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $85FD.w,X		; 3D FD 85 ; AND accumulator with memory $85FD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora ($45.b,X)		; 01 45 ; Logical OR ($45.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $00.b		; 46 00 ; Logical shift right $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	jsl $2FE002.l		; 22 02 E0 2F ; Jump to subroutine long $2FE002.l [Writes: Stack Pointer] [Flow: call]
	sbc $CDFF81.l		; EF 81 FF CD ; Subtract with carry (long) $CDFF81.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $7A53.w,X		; FD 53 7A ; Subtract with carry $7A53.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor #$75.b		; 49 75 ; Exclusive OR #$75.b with accumulator [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor ($77.b)		; 52 77 ; Exclusive OR accumulator with memory (indirect) ($77.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $6D.b		; 45 6D ; Exclusive OR $6D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $B63D.w,X		; 3D 3D B6 ; AND accumulator with memory $B63D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda $BBB7.w		; AD B7 BB ; Load $BBB7.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $6600.w,X		; 7E 00 66 ; Rotate right $6600.w,X [Reads: X Index] [Flags: NCZ]
	rep #$C3		; C2 C3 ; Reset processor status bits #$C3 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	eor $C3.b,S		; 43 C3 ; Exclusive OR accumulator with stack relative $C3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $1808.w,X		; 7E 08 18 ; Rotate right $1808.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $C306.w,X		; 1E 06 C3 ; Arithmetic shift left $C306.w,X [Reads: X Index] [Flags: NCZ]
	cmp $60.b,S		; C3 60 ; Compare accumulator (stack relative) $60.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta [$50.b],Y		; 97 50 ; Store accumulator (long indexed) [$50.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $35.b		; 04 35 ; Test and set bits $35.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	.db $F0, $2F		; F0 2F ; Branch if equal to $F0, $2F [Flow: branch]
	.db $50, $01		; 50 01 ; Branch if overflow clear to $50, $01 [Flow: branch]
	eor $23.b,S		; 43 23 ; Exclusive OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $29.b,S		; 03 29 ; OR accumulator with stack relative $29.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $0E14.w		; 1C 14 0E ; Test and reset bits $0E14.w [Reads: Accumulator] [Flags: Z]
	eor $16.b,S		; 43 16 ; Exclusive OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $060843.l		; 0F 43 08 06 ; OR accumulator with memory (long) $060843.l [Writes: Accumulator] [Flags: NZ]
	cop $2E.b		; 02 2E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $222F.w		; 2E 2F 22 ; Rotate left $222F.w [Flags: NCZ]
	ora [$0D.b],Y		; 17 0D ; OR accumulator with memory (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc ($00.b),Y		; F1 00 ; Subtract with carry ($00.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$07.b],Y		; F7 07 ; Subtract with carry (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $0FCF0E.l		; EF 0E CF 0F ; Subtract with carry (long) $0FCF0E.l [Writes: Accumulator] [Flags: NCVZ]
	and [$07.b],Y		; 37 07 ; AND accumulator with memory (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E001.w,X		; FD 01 E0 ; Subtract with carry $E001.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$DF.b],Y		; 37 DF ; AND accumulator with memory (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	and ($F0.b),Y		; 31 F0 ; AND accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp $B6B6.w		; CD B6 B6 ; Compare $B6B6.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc ($2C.b,S),Y		; F3 2C ; Subtract with carry (stack relative indirect indexed) ($2C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $18FBB0.l,X		; FF B0 FB 18 ; Subtract with carry (long,X) $18FBB0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$06.b],Y		; F7 06 ; Subtract with carry (long indexed) [$06.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $417EE6.l,X		; FF E6 7E 41 ; Subtract with carry (long,X) $417EE6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
.ACCU 16
.INDEX 16
	rep #$F7		; C2 F7
	sty $9F.b		; 84 9F ; Store Y register to $9F.b [Reads: Y Index]
	tsb $E9C7.w		; 0C C7 E9 ; Test and set bits $E9C7.w [Reads: Accumulator] [Flags: Z]
	ora ($BB.b),Y		; 11 BB ; OR accumulator with memory ($BB.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $6B.b,X		; 35 6B ; Logical AND $6B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $E739.w,X		; DE 39 E7 ; Decrement memory $E739.w,X [Reads: X Index] [Flags: NZ]
	trb $1DFA.w		; 1C FA 1D ; Test and reset bits $1DFA.w [Reads: Accumulator] [Flags: Z]
	sbc $0DF20D.l,X		; FF 0D F2 0D ; Subtract with carry (long,X) $0DF20D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0EF180.l,X		; 7F 80 F1 0E ; Add long $0EF180.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $4F.b,X		; D6 4F ; Decrement memory $4F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $DF3FBE.l,X		; FF BE 3F DF ; Subtract with carry (long,X) $DF3FBE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($FF.b)		; 92 FF ; Store accumulator (indirect) ($FF.b) [Reads: Direct Page, Accumulator]
	sbc ($B6.b),Y		; F1 B6 ; Subtract with carry ($B6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($00.b)		; 32 00 ; AND accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $19.b,S		; 43 19 ; Exclusive OR accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $30		; 80 30 ; Branch always to $80, $30 [Flow: branch]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $34.b		; 00 34 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $17.b,X		; 16 17 ; Arithmetic shift left $17.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $2B272F.l		; 2F 2F 27 2B ; AND accumulator with memory (long) $2B272F.l [Writes: Accumulator] [Flags: NZ]
	bit $3E43.w		; 2C 43 3E ; Test bits $3E43.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and $13.b,X		; 35 13 ; Logical AND $13.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $607F30.l,X		; BF 30 7F 60 ; Load long $607F30.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $607F68.l,X		; 7F 68 7F 60 ; Add long $607F68.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $D0FED8.l,X		; FF D8 FE D0 ; Subtract with carry (long,X) $D0FED8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sta $9F96.w,X		; 9D 96 9F ; Store accumulator to $9F96.w,X [Reads: Accumulator, X Index]
	rol $2D.b		; 26 2D ; Rotate left $2D.b [Reads: Direct Page] [Flags: NCZ]
	bit #$0348.w		; 89 48 03 ; Test bits #$0348.w with accumulator [Reads: Accumulator] [Flags: Z]
	ora $BF.b		; 05 BF ; Logical OR $BF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0FF6.w		; 6E F6 0F ; Rotate right $0FF6.w [Flags: NCZ]
	sta $58.b,S		; 83 58 ; Store accumulator (stack relative) $58.b,S [Reads: Stack Pointer, Accumulator]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($7F.b)		; D2 7F ; Compare accumulator (indirect) ($7F.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta ($F6.b),Y		; 91 F6 ; Store accumulator ($F6.b),Y [Reads: Direct Page, Y Index, Accumulator]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor $03.b,S		; 43 03 ; Exclusive OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $012402.l		; 22 02 24 01 ; Jump to subroutine long $012402.l [Writes: Stack Pointer] [Flow: call]
	ora [$FE.b],Y		; 17 FE ; OR accumulator with memory (long indexed) [$FE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $5C67.w,Y		; 59 67 5C ; Exclusive OR accumulator with memory $5C67.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	adc $2DBF.w		; 6D BF 2D ; Add $2DBF.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	lda ($2D.b)		; B2 2D ; Load accumulator (indirect) ($2D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $2EB120.l,X		; FF 20 B1 2E ; Subtract with carry (long,X) $2EB120.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $2F.b,Y		; B6 2F ; Load X register $2F.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and $5F9FBE.l,X		; 3F BE 9F 5F ; AND accumulator with memory (long,X) $5F9FBE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($1F.b)		; 52 1F ; Exclusive OR accumulator with memory (indirect) ($1F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($56.b),Y		; 51 56 ; Exclusive OR accumulator with memory ($56.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3022.w		; 20 22 30 ; Jump to subroutine at $3022.w [Writes: Stack Pointer] [Flow: call]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $23		; 30 23 ; Branch if minus to $30, $23 [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	cpy #$00F0.w		; C0 F0 00 ; Compare #$00F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $00070C.l		; 22 0C 07 00 ; Jump to subroutine long $00070C.l [Writes: Stack Pointer] [Flow: call]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $2B0C.w		; 0C 0C 2B ; Test and set bits $2B0C.w [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $020000.l		; 22 00 00 02 ; Jump to subroutine long $020000.l [Writes: Stack Pointer] [Flow: call]
	rol $8300.w		; 2E 00 83 ; Rotate left $8300.w [Flags: NCZ]
	ldy #$0002.w		; A0 02 00 ; Load #$0002.w into Y register [Writes: Y Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $200000.l		; 22 00 00 20 ; Jump to subroutine long $200000.l [Writes: Stack Pointer] [Flow: call]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	eor $040601.l		; 4F 01 06 04 ; Exclusive OR accumulator with memory (long) $040601.l [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0022.w		; 20 22 00 ; Jump to subroutine at $0022.w [Writes: Stack Pointer] [Flow: call]
	tsb $037B.w		; 0C 7B 03 ; Test and set bits $037B.w [Reads: Accumulator] [Flags: Z]
	and [$87.b],Y		; 37 87 ; AND accumulator with memory (long indexed) [$87.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta [$CE.b]		; 87 CE ; Store accumulator (long) [$CE.b] [Reads: Direct Page, Accumulator]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc $3ECD.w,X		; FE CD 3E ; Increment memory $3ECD.w,X [Reads: X Index] [Flags: NZ]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $0022.w		; 0E 22 00 ; Arithmetic shift left $0022.w [Flags: NCZ]
	.db $10, $CC		; 10 CC ; Branch if plus to $10, $CC [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $CF3D.w,Y		; F9 3D CF ; Subtract with carry $CF3D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($0E.b),Y		; 31 0E ; AND accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FC.b,S		; 03 FC ; OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $03A3.w,X		; 3C A3 03 ; Test bits $03A3.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $260F0F.l,X		; 1F 0F 0F 26 ; Logical OR long $260F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($BCC3.w,X)		; FC C3 BC ; Jump to subroutine indirect indexed ($BCC3.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $10, $2F		; 10 2F ; Branch if plus to $10, $2F [Flow: branch]
	jsl $BD1300.l		; 22 00 13 BD ; Jump to subroutine long $BD1300.l [Writes: Stack Pointer] [Flow: call]
	lda [$73.b]		; A7 73 ; Load accumulator (long) [$73.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $036E.w		; 6E 6E 03 ; Rotate right $036E.w [Flags: NCZ]
	bit #$0506.w		; 89 06 05 ; Test bits #$0506.w with accumulator [Reads: Accumulator] [Flags: Z]
	ora $85.b,S		; 03 85 ; OR accumulator with stack relative $85.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $82.b,S		; 83 82 ; Store accumulator (stack relative) $82.b,S [Reads: Stack Pointer, Accumulator]
	sta ($01.b,X)		; 81 01 ; Store accumulator ($01.b,X) [Reads: Direct Page, Accumulator, X Index]
	brk $5F.b		; 00 5F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($EF.b)		; 92 EF ; Store accumulator (indirect) ($EF.b) [Reads: Direct Page, Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta $90.b,S		; 83 90 ; Store accumulator (stack relative) $90.b,S [Reads: Stack Pointer, Accumulator]
	tsb $27.b		; 04 27 ; Test and set bits $27.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0C00.w		; 2D 00 0C ; Logical AND $0C00.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($01.b),Y		; 31 01 ; AND accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($03.b,S),Y		; 33 03 ; AND accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$06.b],Y		; 37 06 ; AND accumulator with memory (long indexed) [$06.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $083C0C.l,X		; 3F 0C 3C 08 ; AND accumulator with memory (long,X) $083C0C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $0800.w		; 1C 00 08 ; Test and reset bits $0800.w [Reads: Accumulator] [Flags: Z]
	jsl $2E1000.l		; 22 00 10 2E ; Jump to subroutine long $2E1000.l [Writes: Stack Pointer] [Flow: call]
	bit $2329.w		; 2C 29 23 ; Test bits $2329.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	bit $14.b		; 24 14 ; Test bits $14.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$47FF.w		; A0 FF 47 ; Load #$47FF.w into Y register [Writes: Y Index] [Flags: NZ]
	cpy $0704.w		; CC 04 07 ; Compare $0704.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $5F.b		; 04 5F ; Test and set bits $5F.b [Reads: Accumulator] [Flags: Z]
	clv		; B8 ; Clear overflow flag [Flags: V]
	wai		; CB ; Wait for interrupt
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	jsl $DD0A00.l		; 22 00 0A DD ; Jump to subroutine long $DD0A00.l [Writes: Stack Pointer] [Flow: call]
	cmp [$35.b]		; C7 35 ; Compare accumulator (long) [$35.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rol $B3BE.w		; 2E BE B3 ; Rotate left $B3BE.w [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	dec $E5.b		; C6 E5 ; Decrement $E5.b [Reads: Direct Page] [Flags: NZ]
	cmp $C5.b,S		; C3 C5 ; Compare accumulator (stack relative) $C5.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sty $83.b		; 84 83 ; Store Y register to $83.b [Reads: Y Index]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	and $3A4FD6.l,X		; 3F D6 4F 3A ; AND accumulator with memory (long,X) $3A4FD6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C5.b		; 25 C5 ; Logical AND $C5.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $2F		; 10 2F ; Branch if plus to $10, $2F [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DD37.w,X		; FD 37 DD ; Subtract with carry $DD37.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $DE.b,X		; 16 DE ; Arithmetic shift left $DE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($7B.b,S),Y		; 13 7B ; OR accumulator (stack relative indirect indexed) ($7B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $43.b,X		; 16 43 ; Arithmetic shift left $43.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $1713.w,X		; 7D 13 17 ; Add $1713.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($01.b)		; 32 01 ; AND accumulator with memory (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $4AAFAE.l		; 8F AE AF 4A ; Store accumulator (long) $4AAFAE.l [Reads: Accumulator]
	eor $324D.w		; 4D 4D 32 ; Exclusive OR $324D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($30.b,X)		; 01 30 ; Logical OR ($30.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($30.b,S),Y		; 13 30 ; OR accumulator (stack relative indirect indexed) ($30.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	trb $030F.w		; 1C 0F 03 ; Test and reset bits $030F.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $040C.w		; 0C 0C 04 ; Test and set bits $040C.w [Reads: Accumulator] [Flags: Z]
	tsb $1800.w		; 0C 00 18 ; Test and set bits $1800.w [Reads: Accumulator] [Flags: Z]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	cpy #$23C0.w		; C0 C0 23 ; Compare #$23C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $8304.w		; 0C 04 83 ; Test and set bits $8304.w [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $27.b		; 04 27 ; Test and set bits $27.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $0100.w		; 2D 00 01 ; Logical AND $0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $F0, $2E		; F0 2E ; Branch if equal to $F0, $2E [Flow: branch]
	.db $50, $01		; 50 01 ; Branch if overflow clear to $50, $01 [Flow: branch]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $070027.l,X		; FF 27 00 07 ; Subtract with carry (long,X) $070027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $23.b		; 05 23 ; Logical OR $23.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F7000.l		; 0F 00 70 0F ; OR accumulator with memory (long) $0F7000.l [Writes: Accumulator] [Flags: NZ]
	sta [$7F.b]		; 87 7F ; Store accumulator (long) [$7F.b] [Reads: Direct Page, Accumulator]
	bit $F0FF.w,X		; 3C FF F0 ; Test bits $F0FF.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc $00FCE3.l,X		; FF E3 FC 00 ; Subtract with carry (long,X) $00FCE3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $87		; 70 87 ; Branch if overflow set to $70, $87 [Flow: branch]
	and $25FCFF.l,X		; 3F FF FC 25 ; AND accumulator with memory (long,X) $25FCFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0B07.w		; 09 07 0B ; Logical OR #$0B07.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sta [$1A.b]		; 87 1A ; Store accumulator (long) [$1A.b] [Reads: Direct Page, Accumulator]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FFF8FF.l,X		; 3F FF F8 FF ; AND accumulator with memory (long,X) $FFF8FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$C3FF.w		; E0 FF C3 ; Compare #$C3FF.w with X register [Reads: X Index] [Flags: NCZ]
	jsr ($2985.w,X)		; FC 85 29 ; Jump to subroutine indirect indexed ($2985.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0023FC.l,X		; FF FC 23 00 ; Subtract with carry (long,X) $0023FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta [$36.b]		; 87 36 ; Store accumulator (long) [$36.b] [Reads: Direct Page, Accumulator]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,S),Y		; 13 0F ; OR accumulator (stack relative indirect indexed) ($0F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b],Y		; 17 0F ; OR accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora ($17.b,S),Y		; 13 17 ; OR accumulator (stack relative indirect indexed) ($17.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $004A.w		; 8D 4A 00 ; Store accumulator to $004A.w [Reads: Accumulator]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sed		; F8 ; Set decimal flag [Flags: D]
	stx $59.b		; 86 59 ; Store X register to $59.b [Reads: X Index]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($F8.b)		; 32 F8 ; AND accumulator with memory (indirect) ($F8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C1C03.l		; 0F 03 1C 0C ; OR accumulator with memory (long) $0C1C03.l [Writes: Accumulator] [Flags: NZ]
	ora $0B3B0E.l,X		; 1F 0E 3B 0B ; Logical OR long $0B3B0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($31.b,S),Y		; 73 31 ; Add with carry (stack relative indirect indexed) ($31.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $60.b,S		; E3 60 ; Subtract stack-relative $60.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc #$0360.w		; E9 60 03 ; Subtract #$0360.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tsb $1013.w		; 0C 13 10 ; Test and set bits $1013.w [Reads: Accumulator] [Flags: Z]
	bit $4C.b,X		; 34 4C ; Test bits $4C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	stz $809E.w		; 9C 9E 80 ; Store zero to $809E.w
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $7C		; 80 7C ; Branch always to $80, $7C [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	inc $24.b		; E6 24 ; Increment $24.b [Reads: Direct Page] [Flags: NZ]
	inc $04.b,X		; F6 04 ; Increment memory $04.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc ($02.b,S),Y		; F3 02 ; Subtract with carry (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $04F70E.l,X		; FF 0E F7 04 ; Subtract with carry (long,X) $04F70E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $78		; 80 78 ; Branch always to $80, $78 [Flow: branch]
	ldy $1A.b		; A4 1A ; Load $1A.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $8B01.w		; 0D 01 8B ; Logical OR $8B01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $90.b		; 85 90 ; Store accumulator to $90.b [Reads: Accumulator]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($10.b,S),Y		; 33 10 ; AND accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($02.b,S),Y		; 33 02 ; AND accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$32.b],Y		; 77 32 ; Add with carry (long indexed) [$32.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $0300.w		; 20 00 03 ; Jump to subroutine at $0300.w [Writes: Stack Pointer] [Flow: call]
	tsb $2C13.w		; 0C 13 2C ; Test and set bits $2C13.w [Reads: Accumulator] [Flags: Z]
	bit $5C48.w,X		; 3C 48 5C ; Test bits $5C48.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$F000.w		; C0 00 F0 ; Compare #$F000.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$1018.w		; C0 18 10 ; Compare #$1018.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx $F408.w		; EC 08 F4 ; Compare $F408.w with X register [Reads: X Index] [Flags: NCZ]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	trb $C000.w		; 1C 00 C0 ; Test and reset bits $C000.w [Reads: Accumulator] [Flags: Z]
	.db $30, $E8		; 30 E8 ; Branch if minus to $30, $E8 [Flow: branch]
	trb $0C.b		; 14 0C ; Test and reset bits $0C.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $82, $01, $00		; 82 01 00 ; Branch always long to $82, $01, $00 [Flow: branch]
	ora $44.b,S		; 03 44 ; OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$0F27.w		; E0 27 0F ; Compare #$0F27.w with X register [Reads: X Index] [Flags: NCZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $15.b		; 06 15 ; Arithmetic shift left $15.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	ora $C1161F.l		; 0F 1F 16 C1 ; OR accumulator with memory (long) $C1161F.l [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $DB2400.l,X		; FF 00 24 DB ; Subtract with carry (long,X) $DB2400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $BD		; 42 BD ; Reserved instruction
	sbc $7EC142.l,X		; FF 42 C1 7E ; Subtract with carry (long,X) $7EC142.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $DB.b		; A5 DB ; Load $DB.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $42, $BD		; 42 BD ; Reserved instruction
	sta $06.b,S		; 83 06 ; Store accumulator (stack relative) $06.b,S [Reads: Stack Pointer, Accumulator]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5E.b		; 00 5E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $205F.w		; 20 5F 20 ; Jump to subroutine at $205F.w [Writes: Stack Pointer] [Flow: call]
	eor $324D30.l		; 4F 30 4D 32 ; Exclusive OR accumulator with memory (long) $324D30.l [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $62.b		; 25 62 ; Logical AND $62.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($71.b,X)		; 61 71 ; Add with carry ($71.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($00.b,S),Y		; 73 00 ; Add with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $81.b		; 00 81 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $0109.w		; 8C 09 01 ; Store Y register to $0109.w [Reads: Y Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta ($85.b,X)		; 81 85 ; Store accumulator ($85.b,X) [Reads: Direct Page, Accumulator, X Index]
	ora $2301.w,Y		; 19 01 23 ; OR accumulator with memory $2301.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010500.l		; 22 00 05 01 ; Jump to subroutine long $010500.l [Writes: Stack Pointer] [Flow: call]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora ($46.b,S),Y		; 13 46 ; OR accumulator (stack relative indirect indexed) ($46.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $274317.l		; 0F 17 43 27 ; OR accumulator with memory (long) $274317.l [Writes: Accumulator] [Flags: NZ]
	ora $0B0902.l,X		; 1F 02 09 0B ; Logical OR long $0B0902.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b],Y		; 17 03 ; OR accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$27.b]		; 27 27 ; AND accumulator with memory (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $FB.b		; C4 FB ; Compare $FB.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	eor $C0.b,S		; 43 C0 ; Exclusive OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $24E700.l,X		; FF 00 E7 24 ; Subtract with carry (long,X) $24E700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8F704.l,X		; FF 04 F7 F8 ; Subtract with carry (long,X) $F8F704.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sbc [$FB.b]		; E7 FB ; Subtract with carry (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $6C.b,S		; 83 6C ; Store accumulator (stack relative) $6C.b,S [Reads: Stack Pointer, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$46.b]		; 27 46 ; AND accumulator with memory (long) [$46.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $4F432F.l,X		; 1F 2F 43 4F ; Logical OR long $4F432F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $171302.l,X		; 3F 02 13 17 ; AND accumulator with memory (long,X) $171302.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$22.b]		; 27 22 ; AND accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $4F4F05.l		; 2F 05 4F 4F ; AND accumulator with memory (long) $4F4F05.l [Writes: Accumulator] [Flags: NZ]
	sta [$F8.b]		; 87 F8 ; Store accumulator (long) [$F8.b] [Reads: Direct Page, Accumulator]
	sty $FB.b		; 84 FB ; Store Y register to $FB.b [Reads: Y Index]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $22C700.l,X		; FF 00 C7 22 ; Subtract with carry (long,X) $22C700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8E705.l,X		; FF 05 E7 F8 ; Subtract with carry (long,X) $F8E705.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc [$F8.b]		; E7 F8 ; Subtract with carry (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3F5F47.l,X		; 1F 47 5F 3F ; Logical OR long $3F5F47.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9E.b		; 05 9E ; Logical OR $9E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $2F7FB8.l,X		; 7F B8 7F 2F ; Add long $2F7FB8.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $035F23.l		; 2F 23 5F 03 ; AND accumulator with memory (long) $035F23.l [Writes: Accumulator] [Flags: NZ]
	sta $FB04BC.l,X		; 9F BC 04 FB ; Store accumulator (long,X) $FB04BC.l,X [Reads: Accumulator, X Index]
	eor $00.b		; 45 00 ; Exclusive OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FF8308.l,X		; FF 08 83 FF ; Subtract with carry (long,X) $FF8308.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $F887FF.l		; CF FF 87 F8 ; Compare accumulator (long) $F887FF.l [Reads: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc [$FB.b]		; E7 FB ; Subtract with carry (long) [$FB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$9F39.w		; E0 39 9F ; Compare #$9F39.w with X register [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $60.b		; E5 60 ; Subtract $60.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $30.b,X		; 74 30 ; Store zero to $30.b,X [Reads: X Index]
	adc [$32.b],Y		; 77 32 ; Add with carry (long indexed) [$32.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$1C3C.w		; 09 3C 1C ; Logical OR #$1C3C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $030F0F.l,X		; 1F 0F 0F 03 ; Logical OR long $030F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $34484B.l,X		; 9F 4B 48 34 ; Store accumulator (long,X) $34484B.l,X [Reads: Accumulator, X Index]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $6703.w		; 0C 03 67 ; Test and set bits $6703.w [Reads: Accumulator] [Flags: Z]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	asl $0EEF.w		; 0E EF 0E ; Arithmetic shift left $0EEF.w [Flags: NCZ]
	stz $7C9C.w,X		; 9E 9C 7C ; Store zero to $7C9C.w,X [Reads: X Index]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $11F1.w,Y		; 99 F1 11 ; Store accumulator to $11F1.w,Y [Reads: Y Index, Accumulator]
	.db $62, $8C, $08		; 62 8C 08 ; Push effective relative address $62, $8C, $08 [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	adc $20.b		; 65 20 ; Add $20.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$30.b],Y		; 77 30 ; Add with carry (long indexed) [$30.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $841D.w,X		; 3D 1D 84 ; AND accumulator with memory $841D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $223448.l,X		; 5F 48 34 22 ; Exclusive OR accumulator with memory (long,X) $223448.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $8E0C.w		; 6E 0C 8E ; Rotate right $8E0C.w [Flags: NCZ]
	tsb $189C.w		; 0C 9C 18 ; Test and set bits $189C.w [Reads: Accumulator] [Flags: Z]
	jmp ($8478.w,X)		; 7C 78 84 ; Jump indirect indexed to ($8478.w,X) [Reads: X Index] [Flow: jump]
	and ($02.b)		; 32 02 ; AND accumulator with memory (indirect) ($02.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $31E000.l		; 22 00 E0 31 ; Jump to subroutine long $31E000.l [Writes: Stack Pointer] [Flow: call]
	sta ($72.b)		; 92 72 ; Store accumulator (indirect) ($72.b) [Reads: Direct Page, Accumulator]
	stz $84.b		; 64 84 ; Store zero to $84.b
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2B.b,X)		; 01 2B ; Logical OR ($2B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $56.b		; 02 56 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $2C.b		; 04 2C ; Test and set bits $2C.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0B0D.w		; 0E 0D 0B ; Arithmetic shift left $0B0D.w [Flags: NCZ]
	ora $7A2D0E.l		; 0F 0E 2D 7A ; OR accumulator with memory (long) $7A2D0E.l [Writes: Accumulator] [Flags: NZ]
	bit $BD.b,X		; 34 BD ; Test bits $BD.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	cmp $81.b,S		; C3 81 ; Compare accumulator (stack relative) $81.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $C366.w,X		; BD 66 C3 ; Load $C366.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $187E.w,X		; 7E 7E 18 ; Rotate right $187E.w,X [Reads: X Index] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	bit $A5.b		; 24 A5 ; Test bits $A5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc [$7E.b]		; E7 7E ; Subtract with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $22E0FF.l		; 22 FF E0 22 ; Jump to subroutine long $22E0FF.l [Writes: Stack Pointer] [Flow: call]
	ror $E7DB.w,X		; 7E DB E7 ; Rotate right $E7DB.w,X [Reads: X Index] [Flags: NCZ]
	jsl $0D321D.l		; 22 1D 32 0D ; Jump to subroutine long $0D321D.l [Writes: Stack Pointer] [Flow: call]
	jmp ($7903.w,X)		; 7C 03 79 ; Jump indirect indexed to ($7903.w,X) [Reads: X Index] [Flow: jump]
	asl $4A.b		; 06 4A ; Arithmetic shift left $4A.b [Reads: Direct Page] [Flags: NCZ]
	bit $34.b,X		; 34 34 ; Test bits $34.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $09.b,X		; 15 09 ; OR accumulator with memory $09.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $3E.b		; 02 3E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $495C.w,X		; 3E 5C 49 ; Rotate left $495C.w,X [Reads: X Index] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$16.b],Y		; 37 16 ; AND accumulator with memory (long indexed) [$16.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $42FF.w		; 0D FF 42 ; Logical OR $42FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $4218.w,X		; BD 18 42 ; Load $4218.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($E7.b,X)		; 81 E7 ; Store accumulator ($E7.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $42, $83		; 42 83 ; Reserved instruction
	stx $0602.w		; 8E 02 06 ; Store X register to $0602.w [Reads: X Index]
	sbc $25DB18.l,X		; FF 18 DB 25 ; Subtract with carry (long,X) $25DB18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $7EE7.w,X		; BD E7 7E ; Load $7EE7.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	and $7A02.w,X		; 3D 02 7A ; AND accumulator with memory $7A02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $F2.b		; 05 F2 ; Logical OR $F2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $7B84.w		; 0D 84 7B ; Logical OR $7B84.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$3A16.w		; 69 16 3A ; Add #$3A16.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tsb $74.b		; 04 74 ; Test and set bits $74.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $09.b,X		; F5 09 ; Subtract $09.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $8E.b		; 46 8E ; Logical shift right $8E.b [Reads: Direct Page] [Flags: NCZ]
	jsr ($3B79.w,X)		; FC 79 3B ; Jump to subroutine indirect indexed ($3B79.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor [$96.b],Y		; 57 96 ; Exclusive OR accumulator with memory (long indexed) [$96.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $14.b,S		; 83 14 ; Store accumulator (stack relative) $14.b,S [Reads: Stack Pointer, Accumulator]
	ora ($8B.b,X)		; 01 8B ; Logical OR ($8B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $BD		; 42 BD ; Reserved instruction
	sbc [$7E.b]		; E7 7E ; Subtract with carry (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$26.b]		; 07 26 ; OR accumulator with memory (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $111F24.l,X		; 1F 24 1F 11 ; Logical OR long $111F24.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $430F33.l		; 0F 33 0F 43 ; OR accumulator with memory (long) $430F33.l [Writes: Accumulator] [Flags: NZ]
	adc ($2F.b,S),Y		; 73 2F ; Add with carry (stack relative indirect indexed) ($2F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$493B.w		; E0 3B 49 ; Compare #$493B.w with X register [Reads: X Index] [Flags: NCZ]
	and [$34.b],Y		; 37 34 ; AND accumulator with memory (long indexed) [$34.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $24.b		; 26 24 ; Rotate left $24.b [Reads: Direct Page] [Flags: NCZ]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor #$2734.w		; 49 34 27 ; Exclusive OR #$2734.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $D0BF5C.l,X		; DF 5C BF D0 ; Compare accumulator (long,X) $D0BF5C.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	lda $8B7DA2.l,X		; BF A2 7D 8B ; Load long $8B7DA2.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stz $D7.b,X		; 74 D7 ; Store zero to $D7.b,X [Reads: X Index]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	dec $4D26.w,X		; DE 26 4D ; Decrement memory $4D26.w,X [Reads: X Index] [Flags: NZ]
	ldy $27.b,X		; B4 27 ; Load Y register $27.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	eor $B7BDDF.l,X		; 5F DF BD B7 ; Exclusive OR accumulator with memory (long,X) $B7BDDF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $7BE9.w		; EC E9 7B ; Compare $7BE9.w with X register [Reads: X Index] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	and $273F42.l,X		; 3F 42 3F 27 ; AND accumulator with memory (long,X) $273F42.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $E71F67.l,X		; 1F 67 1F E7 ; Logical OR long $E71F67.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $915FE3.l,X		; 5F E3 5F 91 ; Exclusive OR accumulator with memory (long,X) $915FE3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $4C1778.l		; 6F 78 17 4C ; Add with carry (long) $4C1778.l [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and [$67.b]		; 27 67 ; AND accumulator with memory (long) [$67.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$E3.b]		; E7 E3 ; Subtract with carry (long) [$E3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta ($78.b),Y		; 91 78 ; Store accumulator ($78.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sta [$18.b],Y		; 97 18 ; Store accumulator (long indexed) [$18.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $7F		; B0 7F ; Branch if carry set to $B0, $7F [Flow: branch]
	ldy #$437F.w		; A0 7F 43 ; Load #$437F.w into Y register [Writes: Y Index] [Flags: NZ]
	mvp $C7,$3F		; 44 3F C7 ; Move block positive $C7,$3F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $10, $A7		; 10 A7 ; Branch if plus to $10, $A7 [Flow: branch]
	eor $B15FE3.l,X		; 5F E3 5F B1 ; Exclusive OR accumulator with memory (long,X) $B15FE3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $43A0B8.l		; 6F B8 A0 43 ; Add with carry (long) $43A0B8.l [Writes: Accumulator] [Flags: NCVZ]
	cmp [$C7.b]		; C7 C7 ; Compare accumulator (long) [$C7.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc [$E3.b]		; E7 E3 ; Subtract with carry (long) [$E3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($27.b),Y		; B1 27 ; Load accumulator ($27.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1B8ADC.l,X		; DF DC 8A 1B ; Compare accumulator (long,X) $1B8ADC.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $27B4.w		; CD B4 27 ; Compare $27B4.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $032A84.l,X		; DF 84 2A 03 ; Compare accumulator (long,X) $032A84.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,S),Y		; 13 07 ; OR accumulator (stack relative indirect indexed) ($07.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $1C3D.w		; 0C 3D 1C ; Test and set bits $1C3D.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	adc $0034.w,X		; 7D 34 00 ; Add $0034.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($22.b,S),Y		; 13 22 ; OR accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $4A.b		; 24 4A ; Test bits $4A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpy #$F800.w		; C0 00 F8 ; Compare #$F800.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$3038.w		; C0 38 30 ; Compare #$3038.w with Y register [Reads: Y Index] [Flags: NCZ]
	jmp.w [$EC18]		; DC 18 EC ; Jump long indirect [$EC18] [Flow: jump]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cpx $0022.w		; EC 22 00 ; Compare $0022.w with X register [Reads: X Index] [Flags: NCZ]
	ora $C0.b		; 05 C0 ; Logical OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit $14.b		; 24 14 ; Test bits $14.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	stz $7F43.w		; 9C 43 7F ; Store zero to $7F43.w
	rol $07.b,X		; 36 07 ; Rotate left $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $103D12.l,X		; 3F 12 3D 10 ; AND accumulator with memory (long,X) $103D12.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $6E00.w		; 2E 00 6E ; Rotate left $6E00.w [Flags: NCZ]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	lsr $00.b,X		; 56 00 ; Logical shift right $00.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora [$49.b]		; 07 49 ; OR accumulator with memory (long) [$49.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor #$2F2D.w		; 49 2D 2F ; Exclusive OR #$2F2D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $7F7F7B.l,X		; 3F 7B 7F 7F ; AND accumulator with memory (long,X) $7F7F7B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $F7.b,S		; 43 F7 ; Exclusive OR accumulator with stack relative $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $22FF06.l		; 22 06 FF 22 ; Jump to subroutine long $22FF06.l [Writes: Stack Pointer] [Flow: call]
	cmp $00D502.l,X		; DF 02 D5 00 ; Compare accumulator (long,X) $00D502.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sta $44.b,X		; 95 44 ; Store accumulator to $44.b,X [Reads: Accumulator, X Index]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $D5.b,X		; D5 D5 ; Compare accumulator $D5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $FFFD.w,X		; DD FD FF ; Compare accumulator $FFFD.w,X [Reads: X Index] [Flags: NCZ]
	sbc $18FEFE.l,X		; FF FE FE 18 ; Subtract with carry (long,X) $18FEFE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $0000.w		; 2E 00 00 ; Rotate left $0000.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $5A.b		; 05 5A ; Logical OR $5A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $BD.b		; 24 BD ; Test bits $BD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $4300.w,Y		; 99 00 43 ; Store accumulator to $4300.w,Y [Reads: Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $3C.b		; 45 3C ; Exclusive OR $3C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $FF7E.w		; 0E 7E FF ; Arithmetic shift left $FF7E.w [Flags: NCZ]
	sbc $246666.l,X		; FF 66 66 24 ; Subtract with carry (long,X) $246666.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $3C.b		; 24 3C ; Test bits $3C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $36.b		; 02 36 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $4C.b		; 04 4C ; Test and set bits $4C.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sec		; 38 ; Set carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $743A.w		; 0D 3A 74 ; Logical OR $743A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($A5.b,X)		; 01 A5 ; Logical OR ($A5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	mvp $3C,$18		; 44 18 3C ; Move block positive $3C,$18 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sta $98.b,S		; 83 98 ; Store accumulator (stack relative) $98.b,S [Reads: Stack Pointer, Accumulator]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$66.b]		; 67 66 ; Add with carry (long) [$66.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc $4D11.w		; ED 11 4D ; Subtract $4D11.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($3B.b),Y		; 31 3B ; AND accumulator with memory ($3B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $9E.b		; 04 9E ; Test and set bits $9E.b [Reads: Accumulator] [Flags: Z]
	ror $1E3D.w,X		; 7E 3D 1E ; Rotate right $1E3D.w,X [Reads: X Index] [Flags: NCZ]
	tsb $0022.w		; 0C 22 00 ; Test and set bits $0022.w [Reads: Accumulator] [Flags: Z]
	sta $94.b,S		; 83 94 ; Store accumulator (stack relative) $94.b,S [Reads: Stack Pointer, Accumulator]
	cop $85.b		; 02 85 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $43.b		; 04 43 ; Test and set bits $43.b [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	cop $3C.b		; 02 3C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sta $98.b,S		; 83 98 ; Store accumulator (stack relative) $98.b,S [Reads: Stack Pointer, Accumulator]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $66.b		; 66 66 ; Rotate right $66.b [Reads: Direct Page] [Flags: NCZ]
	bit $1B.b		; 24 1B ; Test bits $1B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $0F14.w		; 0C 14 0F ; Test and set bits $0F14.w [Reads: Accumulator] [Flags: Z]
	ora #$0907.w		; 09 07 09 ; Logical OR #$0907.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $1B.b		; 04 1B ; Test and set bits $1B.b [Reads: Accumulator] [Flags: Z]
	trb $0B.b		; 14 0B ; Test and reset bits $0B.b [Reads: Accumulator] [Flags: Z]
	ora #$2207.w		; 09 07 22 ; Logical OR #$2207.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1ED4.w		; 2D D4 1E ; Logical AND $1ED4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sep #$87		; E2 87 ; Set processor status bits #$87 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc [$EF.b],Y		; 77 EF ; Add with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $EF.b		; 14 EF ; Test and reset bits $EF.b [Reads: Accumulator] [Flags: Z]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $3B1200.l		; 22 00 12 3B ; Jump to subroutine long $3B1200.l [Writes: Stack Pointer] [Flow: call]
	ora $7FC7.w,X		; 1D C7 7F ; OR accumulator with memory $7FC7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$E8.b],Y		; 17 E8 ; OR accumulator with memory (long indexed) [$E8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $2419.w,X		; 3E 19 24 ; Rotate left $2419.w,X [Reads: X Index] [Flags: NCZ]
	ora $130F14.l,X		; 1F 14 0F 13 ; Logical OR long $130F14.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $010E.w		; 0D 0E 01 ; Logical OR $010E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $152C.w,X		; 3E 2C 15 ; Rotate left $152C.w,X [Reads: X Index] [Flags: NCZ]
	ora ($0E.b,S),Y		; 13 0E ; OR accumulator (stack relative indirect indexed) ($0E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stx $04.b,Y		; 96 04 ; Store X register $04.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	tsb $67.b		; 04 67 ; Test and set bits $67.b [Reads: Accumulator] [Flags: Z]
	lda $16EEF9.l,X		; BF F9 EE 16 ; Load long $16EEF9.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $A1.b		; 84 A1 ; Store Y register to $A1.b [Reads: Y Index]
	tsb $14.b		; 04 14 ; Test and set bits $14.b [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $AF87.w,X		; 1D 87 AF ; OR accumulator with memory $AF87.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $E817.w,X		; FE 17 E8 ; Increment memory $E817.w,X [Reads: X Index] [Flags: NZ]
	ora [$78.b]		; 07 78 ; OR accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$46.b],Y		; 17 46 ; OR accumulator with memory (long indexed) [$46.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $3759.w,Y		; 39 59 37 ; AND accumulator with memory $3759.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $111F.w		; 2D 1F 11 ; Logical AND $111F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $000F.w		; 0E 0F 00 ; Arithmetic shift left $000F.w [Flags: NCZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	lsr $2D55.w,X		; 5E 55 2D ; Logical shift right $2D55.w,X [Reads: X Index] [Flags: NCZ]
	ora ($0F.b),Y		; 11 0F ; OR accumulator with memory ($0F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $9984.w		; AD 84 99 ; Load $9984.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	cmp ($3C.b,S),Y		; D3 3C ; Compare accumulator (stack relative indirect indexed) ($3C.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	cmp #$37FE.w		; C9 FE 37 ; Compare #$37FE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $BB00CF.l		; CF CF 00 BB ; Compare accumulator (long) $BB00CF.l [Reads: Accumulator] [Flags: NCZ]
	ora $F887.w,X		; 1D 87 F8 ; OR accumulator with memory $F887.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $37CE.w,X		; 3C CE 37 ; Test bits $37CE.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cmp $7B3A7F.l		; CF 7F 3A 7B ; Compare accumulator (long) $7B3A7F.l [Reads: Accumulator] [Flags: NCZ]
	and $1C3D.w,Y		; 39 3D 1C ; AND accumulator with memory $1C3D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $1F0E.w,X		; 1E 0E 1F ; Arithmetic shift left $1F0E.w,X [Reads: X Index] [Flags: NCZ]
	asl $240E.w		; 0E 0E 24 ; Arithmetic shift left $240E.w [Flags: NCZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $44.b		; 45 44 ; Exclusive OR $44.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $0E1111.l		; 22 11 11 0E ; Jump to subroutine long $0E1111.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $1C28.w		; EC 28 1C ; Compare $1C28.w with X register [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	.db $70, $F0		; 70 F0 ; Branch if overflow set to $70, $F0 [Flow: branch]
	cpx #$24E0.w		; E0 E0 24 ; Compare #$24E0.w with X register [Reads: X Index] [Flags: NCZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $E4.b		; 14 E4 ; Test and reset bits $E4.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $7D00.w,X		; 5D 00 7D ; Exclusive OR accumulator with memory $7D00.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	trb $77.b		; 14 77 ; Test and reset bits $77.b [Reads: Accumulator] [Flags: Z]
	eor [$5D.b],Y		; 57 5D ; Exclusive OR accumulator with memory (long indexed) [$5D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $03.b		; 25 03 ; Logical AND $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $5A.b		; 00 5A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $FE0600.l		; 22 00 06 FE ; Jump to subroutine long $FE0600.l [Writes: Stack Pointer] [Flow: call]
	dec $D4F4.w,X		; DE F4 D4 ; Decrement memory $D4F4.w,X [Reads: X Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $38		; 80 38 ; Branch always to $80, $38 [Flow: branch]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $183C.w,X		; 3C 3C 18 ; Test bits $183C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $0000.w,X		; 3C 00 00 ; Test bits $0000.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $1844.w,X		; 3C 44 18 ; Test bits $1844.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1800.w,X		; 3C 00 18 ; Test bits $1800.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $4318.w,X		; 3C 18 43 ; Test bits $4318.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $18003C.l		; 22 3C 00 18 ; Jump to subroutine long $18003C.l [Writes: Stack Pointer] [Flow: call]
	jsl $37FF00.l		; 22 00 FF 37 ; Jump to subroutine long $37FF00.l [Writes: Stack Pointer] [Flow: call]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $780700.l		; 22 00 07 78 ; Jump to subroutine long $780700.l [Writes: Stack Pointer] [Flow: call]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E4.b		; 00 E4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $70, $3F		; 70 3F ; Branch if overflow set to $70, $3F [Flow: branch]
	jsl $000C01.l		; 22 01 0C 00 ; Jump to subroutine long $000C01.l [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc [$FB.b],Y		; F7 FB ; Subtract with carry (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $9300E0.l,X		; 7F E0 00 93 ; Add long $9300E0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$F0CF.w		; E0 CF F0 ; Compare #$F0CF.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $FF4340.l,X		; FF 40 43 FF ; Subtract with carry (long,X) $FF4340.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $9841.w,Y		; BE 41 98 ; Load X register $9841.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc [$E0.b]		; 67 E0 ; Add with carry (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($23.b,S),Y		; F3 23 ; Subtract with carry (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $BE35E0.l,X		; FF E0 35 BE ; Subtract with carry (long,X) $BE35E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $07F800.l,X		; 7F 00 F8 07 ; Add long $07F800.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $3F.b,S		; C3 3F ; Compare accumulator (stack relative) $3F.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta $FF3C7F.l		; 8F 7F 3C FF ; Store accumulator (long) $FF3C7F.l [Reads: Accumulator]
	.db $70, $FE		; 70 FE ; Branch if overflow set to $70, $FE [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $7FFCC0.l,X		; FF C0 FC 7F ; Subtract with carry (long,X) $7FFCC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp $8F.b,S		; C3 8F ; Compare accumulator (stack relative) $8F.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and $FF7F7F.l,X		; 3F 7F 7F FF ; AND accumulator with memory (long,X) $FF7F7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($7FB8.w,X)		; 7C B8 7F ; Jump indirect indexed to ($7FB8.w,X) [Reads: X Index] [Flow: jump]
	sta $087F.w		; 8D 7F 08 ; Store accumulator to $087F.w [Reads: Accumulator]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	and $BFFF74.l,X		; 3F 74 FF BF ; AND accumulator with memory (long,X) $BFFF74.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $2DE1FE.l		; 8F FE E1 2D ; Store accumulator (long) $2DE1FE.l [Reads: Accumulator]
	cmp ($43.b,S),Y		; D3 43 ; Compare accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
.ACCU 16
.INDEX 16
	rep #$3F		; C2 3F
	cpx #$309F.w		; E0 9F 30 ; Compare #$309F.w with X register [Reads: X Index] [Flags: NCZ]
	ora $04C609.l		; 0F 09 C6 04 ; OR accumulator with memory (long) $04C609.l [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($FEFB.w,X)		; FC FB FE ; Jump to subroutine indirect indexed ($FEFB.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $C2C2.w		; 2D C2 C2 ; Logical AND $C2C2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F9		; F0 F9 ; Branch if equal to $F0, $F9 [Flow: branch]
	jsr ($5FFC.w,X)		; FC FC 5F ; Jump to subroutine indirect indexed ($5FFC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $C1BF4C.l,X		; FF 4C BF C1 ; Subtract with carry (long,X) $C1BF4C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $F71FE1.l,X		; 3F E1 1F F7 ; AND accumulator with memory (long,X) $F71FE1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8E3BCF.l		; 0F CF 3B 8E ; OR accumulator with memory (long) $8E3BCF.l [Writes: Accumulator] [Flags: NZ]
	eor $5F8F36.l,X		; 5F 36 8F 5F ; Exclusive OR accumulator with memory (long,X) $5F8F36.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $E1C1.w		; 4C C1 E1 ; Jump to $E1C1.w [Flow: jump]
	sbc [$CB.b],Y		; F7 CB ; Subtract with carry (long indexed) [$CB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $FCF14F.l,X		; BF 4F F1 FC ; Load long $FCF14F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$81F8.w		; C0 F8 81 ; Compare #$81F8.w with Y register [Reads: Y Index] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora $B0.b,S		; 03 B0 ; OR accumulator with stack relative $B0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $E0.b,S		; 03 E0 ; OR accumulator with stack relative $E0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $E0.b		; 06 E0 ; Arithmetic shift left $E0.b [Reads: Direct Page] [Flags: NCZ]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($F8.b,X)		; 01 F8 ; Logical OR ($F8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $FEFF.w,X		; FE FF FE ; Increment memory $FEFF.w,X [Reads: X Index] [Flags: NZ]
	jsr ($F9FC.w,X)		; FC FC F9 ; Jump to subroutine indirect indexed ($F9FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $1F20FE.l,X		; FF FE 20 1F ; Subtract with carry (long,X) $1F20FE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0606.w,Y		; 19 06 06 ; OR accumulator with memory $0606.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$2B.b]		; 07 2B ; OR accumulator with memory (long) [$2B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$4C.b]		; 07 4C ; OR accumulator with memory (long) [$4C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $071920.l,X		; 1F 20 19 07 ; Logical OR long $071920.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $847C37.l,X		; 1F 37 7C 84 ; Logical OR long $847C37.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $3A3D.w		; 0E 3D 3A ; Arithmetic shift left $3A3D.w [Flags: NCZ]
	adc $7BB4.w,X		; 7D B4 7B ; Add $7BB4.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $FB.b		; C5 FB ; Compare $FB.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta $FB.b		; 85 FB ; Store accumulator to $FB.b [Reads: Accumulator]
	ora $70E7.w,Y		; 19 E7 70 ; OR accumulator with memory $70E7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $FAFEFC.l		; 8F FC FE FA ; Store accumulator (long) $FAFEFC.l [Reads: Accumulator]
	stz $C5.b,X		; 74 C5 ; Store zero to $C5.b,X [Reads: X Index]
	sta $19.b		; 85 19 ; Store accumulator to $19.b [Reads: Accumulator]
	.db $70, $E0		; 70 E0 ; Branch if overflow set to $70, $E0 [Flow: branch]
	ora $FE0FF0.l,X		; 1F F0 0F FE ; Logical OR long $FE0FF0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($F1.b,X)		; 01 F1 ; Logical OR ($F1.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $9D6B.w		; 0E 6B 9D ; Arithmetic shift left $9D6B.w [Flags: NCZ]
	sta ($F5.b,S),Y		; 93 F5 ; Store accumulator (stack relative indirect indexed) ($F5.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	adc $4BDF8B.l		; 6F 8B DF 4B ; Add with carry (long) $4BDF8B.l [Writes: Accumulator] [Flags: NCVZ]
	cpx #$FEF0.w		; E0 F0 FE ; Compare #$FEF0.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($6B.b),Y		; F1 6B ; Subtract with carry ($6B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc $FF6CFF.l,X		; 7F FF 6C FF ; Add long $FF6CFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $33DE.w,Y		; F9 DE 33 ; Subtract with carry $33DE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($7887.w,X)		; FC 87 78 ; Jump to subroutine indirect indexed ($7887.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	eor $932C30.l		; 4F 30 2C 93 ; Exclusive OR accumulator with memory (long) $932C30.l [Writes: Accumulator] [Flags: NZ]
	ora ($EF.b,S),Y		; 13 EF ; OR accumulator (stack relative indirect indexed) ($EF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $7CFE.w		; CD FE 7C ; Compare $7CFE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $8773.w,Y		; D9 73 87 ; Compare accumulator $8773.w,Y [Reads: Y Index] [Flags: NCZ]
	cmp $CDD3EC.l		; CF EC D3 CD ; Compare accumulator (long) $CDD3EC.l [Reads: Accumulator] [Flags: NCZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $13E3.w,X		; 1D E3 13 ; OR accumulator with memory $13E3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $3F4C1F.l		; EF 1F 4C 3F ; Subtract with carry (long) $3F4C1F.l [Writes: Accumulator] [Flags: NCVZ]
	eor $3C.b,S		; 43 3C ; Exclusive OR accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc #$434C.w		; E9 4C 43 ; Subtract #$434C.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and $11.b,S		; 23 11 ; AND accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$9B.b]		; 07 9B ; OR accumulator with memory (long) [$9B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $34FB15.l,X		; FF 15 FB 34 ; Subtract with carry (long,X) $34FB15.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	eor $36.b,S		; 43 36 ; Exclusive OR accumulator with stack relative $36.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $25E0.w,Y		; F9 E0 25 ; Subtract with carry $25E0.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor [$F8.b],Y		; 57 F8 ; Exclusive OR accumulator with memory (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$D8.b]		; 27 D8 ; AND accumulator with memory (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$D8.b]		; 07 D8 ; OR accumulator with memory (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora $35.b,X		; 15 35 ; OR accumulator with memory $35.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$57.b],Y		; 77 57 ; Add with carry (long indexed) [$57.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$AF.b],Y		; 77 AF ; Add with carry (long indexed) [$AF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $97DF3F.l		; CF 3F DF 97 ; Compare accumulator (long) $97DF3F.l [Reads: Accumulator] [Flags: NCZ]
	sbc [$5F.b]		; E7 5F ; Subtract with carry (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$2B.b]		; E7 2B ; Subtract with carry (long) [$2B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($17.b,S),Y		; 73 17 ; Add with carry (stack relative indirect indexed) ($17.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3CDA.w,Y		; F9 DA 3C ; Subtract with carry $3CDA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B01E.w		; ED 1E B0 ; Subtract $B01E.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsr $D098.w		; 20 98 D0 ; Jump to subroutine at $D098.w [Writes: Stack Pointer] [Flow: call]
	cpx $DB34.w		; EC 34 DB ; Compare $DB34.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $070027.l		; EF 27 00 07 ; Subtract with carry (long) $070027.l [Writes: Accumulator] [Flags: NCVZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($2E.b,X)		; 01 2E ; Logical OR ($2E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $230F17.l,X		; 1F 17 0F 23 ; Logical OR long $230F17.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $3F7B17.l		; 2F 17 7B 3F ; AND accumulator with memory (long) $3F7B17.l [Writes: Accumulator] [Flags: NZ]
	rol $2D1F.w,X		; 3E 1F 2D ; Rotate left $2D1F.w,X [Reads: X Index] [Flags: NCZ]
	asl $0D72.w,X		; 1E 72 0D ; Arithmetic shift left $0D72.w,X [Reads: X Index] [Flags: NCZ]
	inc $2612.w		; EE 12 26 ; Increment $2612.w [Flags: NZ]
	dec $EF10.w,X		; DE 10 EF ; Decrement memory $EF10.w,X [Reads: X Index] [Flags: NZ]
	inc $E9.b,X		; F6 E9 ; Increment memory $E9.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc $722D3E.l,X		; 7F 3E 2D 72 ; Add long $722D3E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F6F1F7.l		; EF F7 F1 F6 ; Subtract with carry (long) $F6F1F7.l [Writes: Accumulator] [Flags: NCVZ]
	eor $81.b,S		; 43 81 ; Exclusive OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $2222E0.l,X		; 7F E0 22 22 ; Add long $2222E0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1C7F36.l,X		; FF 36 7F 1C ; Subtract with carry (long,X) $1C7F36.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	lda $AB1D4A.l,X		; BF 4A 1D AB ; Load long $AB1D4A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $638181.l,X		; BF 81 81 63 ; Load long $638181.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$FB.b],Y		; F7 FB ; Subtract with carry (long indexed) [$FB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $81EFAD.l,X		; FF AD EF 81 ; Subtract with carry (long,X) $81EFAD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	cpy #$8001.w		; C0 01 80 ; Compare #$8001.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $98.b		; 00 98 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $30.b		; 04 30 ; Test and set bits $30.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $70.b		; E6 70 ; Increment $70.b [Reads: Direct Page] [Flags: NZ]
	inc $C0.b,X		; F6 C0 ; Increment memory $C0.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $FF0A.w,X		; FE 0A FF ; Increment memory $FF0A.w,X [Reads: X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc [$FF.b],Y		; F7 FF ; Subtract with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $203F43.l,X		; DF 43 3F 20 ; Compare accumulator (long,X) $203F43.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $830F10.l,X		; 1F 10 0F 83 ; Logical OR long $830F10.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $E0,$01		; 44 01 E0 ; Move block positive $E0,$01 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $4F.b,S		; 03 4F ; OR accumulator with stack relative $4F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$5F.b],Y		; 17 5F ; OR accumulator with memory (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $102043.l,X		; 3F 43 20 10 ; AND accumulator with memory (long,X) $102043.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$5F.b],Y		; 77 5F ; Add with carry (long indexed) [$5F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $7B.b		; E5 7B ; Subtract $7B.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$12.b],Y		; F7 12 ; Subtract with carry (long indexed) [$12.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $869F61.l		; EF 61 9F 86 ; Subtract with carry (long) $869F61.l [Writes: Accumulator] [Flags: NCVZ]
	adc $718E.w,Y		; 79 8E 71 ; Add $718E.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $D891.w		; 6E 91 D8 ; Rotate right $D891.w [Flags: NCZ]
	sta [$65.b]		; 87 65 ; Store accumulator (long) [$65.b] [Reads: Direct Page, Accumulator]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ora ($61.b,S),Y		; 13 61 ; OR accumulator (stack relative indirect indexed) ($61.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stx $8E.b		; 86 8E ; Store X register to $8E.b [Reads: X Index]
	inc $88F8.w		; EE F8 88 ; Increment $88F8.w [Flags: NZ]
	cmp $5BFF49.l,X		; DF 49 FF 5B ; Compare accumulator (long,X) $5BFF49.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	jsl $2AE0FF.l		; 22 FF E0 2A ; Jump to subroutine long $2AE0FF.l [Writes: Stack Pointer] [Flow: call]
	sbc ($FF.b)		; F2 FF ; Subtract with carry (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $FF.b		; 64 FF ; Store zero to $FF.b
	eor [$BF.b]		; 47 BF ; Exclusive OR accumulator with memory (long) [$BF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $BF.b,S		; 43 BF ; Exclusive OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FFDFEF.l,X		; FF EF DF FF ; Subtract with carry (long,X) $FFDFEF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($67.b,S),Y		; F3 67 ; Subtract with carry (stack relative indirect indexed) ($67.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	eor [$43.b]		; 47 43 ; Exclusive OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b,X)		; 01 F0 ; Logical OR ($F0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $F0.b		; C4 F0 ; Compare $F0.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	.db $80, $EE		; 80 EE ; Branch always to $80, $EE [Flow: branch]
	.db $80, $7E		; 80 7E ; Branch always to $80, $7E [Flow: branch]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc [$B3.b],Y		; F7 B3 ; Subtract with carry (long indexed) [$B3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FEEF37.l		; EF 37 EF FE ; Subtract with carry (long) $FEEF37.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $F7FF7F.l,X		; FF 7F FF F7 ; Subtract with carry (long,X) $F7FF7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $3E412F.l		; AF 2F 41 3E ; Load long $3E412F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	rol $002C.w,X		; 3E 2C 00 ; Rotate left $002C.w,X [Reads: X Index] [Flags: NCZ]
	ora ($61.b,X)		; 01 61 ; Logical OR ($61.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $0025.w,X		; 3E 25 00 ; Rotate left $0025.w,X [Reads: X Index] [Flags: NCZ]
	cpx #$F147.w		; E0 47 F1 ; Compare #$F147.w with X register [Reads: X Index] [Flags: NCZ]
	asl $0C73.w		; 0E 73 0C ; Arithmetic shift left $0C73.w [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	trb $1C63.w		; 1C 63 1C ; Test and reset bits $1C63.w [Reads: Accumulator] [Flags: Z]
	sbc $7FBF00.l,X		; FF 00 BF 7F ; Subtract with carry (long,X) $7FBF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy #$D47F.w		; A0 7F D4 ; Load #$D47F.w into Y register [Writes: Y Index] [Flags: NZ]
	and ($F1.b,S),Y		; 33 F1 ; AND accumulator (stack relative indirect indexed) ($F1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($2B.b,S),Y		; 73 2B ; Add with carry (stack relative indirect indexed) ($2B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $FF.b,S		; 63 FF ; Add with carry (stack relative) $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda $C7DBBF.l,X		; BF BF DB C7 ; Load long $C7DBBF.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$7FA0.w		; 69 A0 7F ; Add #$7FA0.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ldy $9D7F.w,X		; BC 7F 9D ; Load Y register $9D7F.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc $855FAB.l,X		; 7F AB 5F 85 ; Add long $855FAB.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C9FD49.l,X		; FF 49 FD C9 ; Subtract with carry (long,X) $C9FD49.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $BCB8F7.l,X		; FF F7 B8 BC ; Subtract with carry (long,X) $BCB8F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $87AB.w,X		; 9D AB 87 ; Store accumulator to $87AB.w,X [Reads: Accumulator, X Index]
	cmp $FDABCB.l		; CF CB AB FD ; Compare accumulator (long) $FDABCB.l [Reads: Accumulator] [Flags: NCZ]
	eor [$DB.b],Y		; 57 DB ; Exclusive OR accumulator with memory (long indexed) [$DB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $5DB6.w		; AE B6 5D ; Load $5DB6.w into X register [Writes: X Index] [Flags: NZ]
	cpx $ECDD.w		; EC DD EC ; Compare $ECDD.w with X register [Reads: X Index] [Flags: NCZ]
	ldx $AFDE.w,Y		; BE DE AF ; Load X register $AFDE.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cmp $BBCF3F.l		; CF 3F CF BB ; Compare accumulator (long) $BBCF3F.l [Reads: Accumulator] [Flags: NCZ]
	stz $E9.b,X		; 74 E9 ; Store zero to $E9.b,X [Reads: X Index]
	cmp ($D2.b)		; D2 D2 ; Compare accumulator (indirect) ($D2.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda ($B0.b,X)		; A1 B0 ; Load accumulator ($B0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$2FE4.w		; A0 E4 2F ; Load #$2FE4.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$78.b],Y		; D7 78 ; Compare accumulator (long indexed) [$78.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jmp ($3C5B.w,X)		; 7C 5B 3C ; Jump indirect indexed to ($3C5B.w,X) [Reads: X Index] [Flow: jump]
	and #$161E.w		; 29 1E 16 ; Logical AND #$161E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $61840B.l		; 0F 0B 84 61 ; OR accumulator with memory (long) $61840B.l [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$BB.b],Y		; F7 BB ; Subtract with carry (long indexed) [$BB.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	and $0B16.w		; 2D 16 0B ; Logical AND $0B16.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	inc $0E.b,X		; F6 0E ; Increment memory $0E.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc ($0E.b)		; F2 0E ; Subtract with carry (indirect) ($0E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	mvp $FB,$07		; 44 07 FB ; Move block positive $FB,$07 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora [$36.b]		; 07 36 ; OR accumulator with memory (long) [$36.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $3BFEC8.l		; CF C8 FE 3B ; Compare accumulator (long) $3BFEC8.l [Reads: Accumulator] [Flags: NCZ]
	jsr ($F3F7.w,X)		; FC F7 F3 ; Jump to subroutine indirect indexed ($F3F7.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsl $3702FB.l		; 22 FB 02 37 ; Jump to subroutine long $3702FB.l [Writes: Stack Pointer] [Flow: call]
	wai		; CB ; Wait for interrupt
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and [$00.b],Y		; 37 00 ; AND accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $CC.b		; 04 CC ; Test and set bits $CC.b [Reads: Accumulator] [Flags: Z]
	rol $0F30.w,X		; 3E 30 0F ; Rotate left $0F30.w,X [Reads: X Index] [Flags: NCZ]
	ora $02002A.l,X		; 1F 2A 00 02 ; Logical OR long $02002A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $E40F31.l		; CF 31 0F E4 ; Compare accumulator (long) $E40F31.l [Reads: Accumulator] [Flags: NCZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cpx #$3D48.w		; E0 48 3D ; Compare #$3D48.w with X register [Reads: X Index] [Flags: NCZ]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F0D1F.l		; 0F 1F 0D 0F ; OR accumulator with memory (long) $0F0D1F.l [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $070F1F.l,X		; 3F 1F 0F 07 ; AND accumulator with memory (long,X) $070F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $F2FBE4.l		; 0F E4 FB F2 ; OR accumulator with memory (long) $F2FBE4.l [Writes: Accumulator] [Flags: NZ]
	lda $9CF3.w,X		; BD F3 9C ; Load $9CF3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $B9DE.w,Y		; 79 DE B9 ; Add $B9DE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FE35.w,X		; FE 35 FE ; Increment memory $FE35.w,X [Reads: X Index] [Flags: NZ]
	and $6DFE.w		; 2D FE 6D ; Logical AND $6DFE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $B2E4.w,X		; FE E4 B2 ; Increment memory $B2E4.w,X [Reads: X Index] [Flags: NZ]
	sta ($D9.b,S),Y		; 93 D9 ; Store accumulator (stack relative indirect indexed) ($D9.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	sbc $2DB5.w,Y		; F9 B5 2D ; Subtract with carry $2DB5.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0008.w		; 6D 08 00 ; Add $0008.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$26.b]		; 47 26 ; Exclusive OR accumulator with memory (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $2FCF2F.l,X		; 5F 2F CF 2F ; Exclusive OR accumulator with memory (long,X) $2FCF2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $07FF1E.l,X		; FF 1E FF 07 ; Subtract with carry (long,X) $07FF1E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $7F3F.w		; 1C 3F 7F ; Test and reset bits $7F3F.w [Reads: Accumulator] [Flags: Z]
	adc $FFFEFF.l		; 6F FF FE FF ; Add with carry (long) $FFFEFF.l [Writes: Accumulator] [Flags: NCVZ]
	ora $FF0043.l,X		; 1F 43 00 FF ; Logical OR long $FF0043.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FF38.w		; 0D 38 FF ; Logical OR $FF38.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr ($FEFF.w,X)		; FC FF FE ; Jump to subroutine indirect indexed ($FEFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FFE0FF.l,X		; FF FF E0 FF ; Subtract with carry (long,X) $FFE0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sbc [$1F.b]		; E7 1F ; Subtract with carry (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF223F.l		; EF 3F 22 FF ; Subtract with carry (long) $FF223F.l [Writes: Accumulator] [Flags: NCVZ]
	cpx #$E031.w		; E0 31 E0 ; Compare #$E031.w with X register [Reads: X Index] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora #$0407.w		; 09 07 04 ; Logical OR #$0407.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$3C.b]		; 07 3C ; OR accumulator with memory (long) [$3C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	adc $7F0A.w,X		; 7D 0A 7F ; Add $7F0A.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$107F.w		; 09 7F 10 ; Logical OR #$107F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1F0F07.l		; 0F 07 0F 1F ; OR accumulator with memory (long) $1F0F07.l [Writes: Accumulator] [Flags: NZ]
	bit $45.b		; 24 45 ; Test bits $45.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	lsr $4C.b		; 46 4C ; Logical shift right $4C.b [Reads: Direct Page] [Flags: NCZ]
	lda ($FC.b,S),Y		; B3 FC ; Load accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($FEF5.w,X)		; FC F5 FE ; Jump to subroutine indirect indexed ($FEF5.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lda $FE.b		; A5 FE ; Load $FE.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and [$FE.b]		; 27 FE ; AND accumulator with memory (long) [$FE.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $98FF64.l,X		; BF 64 FF 98 ; Load long $98FF64.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FBB3A0.l,X		; FF A0 B3 FB ; Subtract with carry (long,X) $FBB3A0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFBD.w,X		; FD BD FF ; Subtract with carry $FFBD.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $444367.l,X		; FF 67 43 44 ; Subtract with carry (long,X) $444367.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $400400.l,X		; FF 00 04 40 ; Subtract with carry (long,X) $400400.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $5FFF47.l,X		; FF 47 FF 5F ; Subtract with carry (long,X) $5FFF47.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $BF.b,S		; 43 BF ; Exclusive OR accumulator with stack relative $BF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $2F7E01.l		; 4F 01 7E 2F ; Exclusive OR accumulator with memory (long) $2F7E01.l [Writes: Accumulator] [Flags: NZ]
	bit $FF.b		; 24 FF ; Test bits $FF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $EF.b		; 02 EF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF447F.l		; EF 7F 44 FF ; Subtract with carry (long) $FF447F.l [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.ACCU 8
.INDEX 8
	sep #$FF		; E2 FF
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($01.b)		; F2 01 ; Subtract with carry (indirect) ($01.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $24F4.w,X		; 7E F4 24 ; Rotate right $24F4.w,X [Reads: X Index] [Flags: NCZ]
	sbc $F732E0.l,X		; FF E0 32 F7 ; Subtract with carry (long,X) $F732E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FE.b],Y		; F7 FE ; Subtract with carry (long indexed) [$FE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $061900.l		; 0F 00 19 06 ; OR accumulator with memory (long) $061900.l [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora [$26.b]		; 07 26 ; OR accumulator with memory (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jmp $78A33C.l		; 5C 3C A3 78 ; Jump long to $78A33C.l [Flow: jump]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $273A19.l		; 0F 19 3A 27 ; OR accumulator with memory (long) $273A19.l [Writes: Accumulator] [Flags: NZ]
	eor $0000BC.l,X		; 5F BC 00 00 ; Exclusive OR accumulator with memory (long,X) $0000BC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp $D864E0.l		; 5C E0 64 D8 ; Jump long to $D864E0.l [Flow: jump]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $1EC5.w,X		; 3C C5 1E ; Test bits $1EC5.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $98		; F0 98 ; Branch if equal to $F0, $98 [Flow: branch]
	jmp $3DFAE4.l		; 5C E4 FA 3D ; Jump long to $3DFAE4.l [Flow: jump]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $7C.b		; 00 7C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $30, $43		; 30 43 ; Branch if minus to $30, $43 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $70, $07		; 70 07 ; Branch if overflow set to $70, $07 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $5C24.w		; 1C 24 5C ; Test and reset bits $5C24.w [Reads: Accumulator] [Flags: Z]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx $47.b		; E4 47 ; Compare $47.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	ora $45073F.l		; 0F 3F 07 45 ; OR accumulator with memory (long) $45073F.l [Writes: Accumulator] [Flags: NZ]
	and $3E0401.l,X		; 3F 01 04 3E ; AND accumulator with memory (long,X) $3E0401.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3F241F.l		; 0F 1F 24 3F ; OR accumulator with memory (long) $3F241F.l [Writes: Accumulator] [Flags: NZ]
	cpx #$47.b		; E0 47 ; Compare #$47.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and [$D8.b]		; 27 D8 ; AND accumulator with memory (long) [$D8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($CF.b,S),Y		; 33 CF ; AND accumulator (stack relative indirect indexed) ($CF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $FF4FFF.l		; 0F FF 4F FF ; OR accumulator with memory (long) $FF4FFF.l [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $C0FFE1.l,X		; FF E1 FF C0 ; Subtract with carry (long,X) $C0FFE1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cmp $FFFFCF.l,X		; DF CF FF FF ; Compare accumulator (long,X) $FFFFCF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc ($0F.b,X)		; E1 0F ; Subtract with carry ($0F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $7F.b		; 06 7F ; Arithmetic shift left $7F.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $217F10.l,X		; 7F 10 7F 21 ; Add long $217F10.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $000602.l,X		; 3F 02 06 00 ; AND accumulator with memory (long,X) $000602.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $462111.l		; 0F 11 21 46 ; OR accumulator with memory (long) $462111.l [Writes: Accumulator] [Flags: NZ]
	jmp $3D5C.w		; 4C 5C 3D ; Jump to $3D5C.w [Flow: jump]
	asl $CD.b		; 06 CD ; Arithmetic shift left $CD.b [Reads: Direct Page] [Flags: NCZ]
	sbc ($DF.b)		; F2 DF ; Subtract with carry (indirect) ($DF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $02FF.w		; 20 FF 02 ; Jump to subroutine at $02FF.w [Writes: Stack Pointer] [Flow: call]
	sbc $82FF42.l,X		; FF 42 FF 82 ; Subtract with carry (long,X) $82FF42.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $9E02.w,X		; FE 02 9E ; Increment memory $9E02.w,X [Reads: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $CD00.w		; 0C 00 CD ; Test and set bits $CD00.w [Reads: Accumulator] [Flags: Z]
	cmp ($21.b,S),Y		; D3 21 ; Compare accumulator (stack relative indirect indexed) ($21.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	and ($71.b,X)		; 21 71 ; Logical AND ($71.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $92		; F0 92 ; Branch if equal to $F0, $92 [Flow: branch]
	tsb $FF46.w		; 0C 46 FF ; Test and set bits $FF46.w [Reads: Accumulator] [Flags: Z]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$7F.b]		; 07 7F ; OR accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $270F77.l		; 0F 77 0F 27 ; OR accumulator with memory (long) $270F77.l [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($0D.b)		; 12 0D ; OR accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $FF.b,S		; 23 FF ; AND accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $431D3B.l,X		; 7F 3B 1D 43 ; Add long $431D3B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $1E43.w,X		; BC 43 1E ; Load Y register $1E43.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $E09FC0.l,X		; BF C0 9F E0 ; Load long $E09FC0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $F8C7F0.l		; CF F0 C7 F8 ; Compare accumulator (long) $F8C7F0.l [Reads: Accumulator] [Flags: NCZ]
	sbc [$78.b]		; E7 78 ; Subtract with carry (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FC.b,S		; E3 FC ; Subtract stack-relative $FC.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	bit $BF3C.w,X		; 3C 3C BF ; Test bits $BF3C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sta $E7C7CF.l,X		; 9F CF C7 E7 ; Store accumulator (long,X) $E7C7CF.l,X [Reads: Accumulator, X Index]
	sbc $FF.b,S		; E3 FF ; Subtract stack-relative $FF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and ($FF.b,X)		; 21 FF ; Logical AND ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $EF00FF.l		; 22 FF 00 EF ; Jump to subroutine long $EF00FF.l [Writes: Stack Pointer] [Flow: call]
	brk $4F.b		; 00 4F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$9C.b]		; 07 9C ; OR accumulator with memory (long) [$9C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $ABBB.w,Y		; 99 BB AB ; Store accumulator to $ABBB.w,Y [Reads: Y Index, Accumulator]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $DE0210.l,X		; FF 10 02 DE ; Subtract with carry (long,X) $DE0210.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $1C,$00		; 44 00 1C ; Move block positive $1C,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E31000.l		; 22 00 10 E3 ; Jump to subroutine long $E31000.l [Writes: Stack Pointer] [Flow: call]
	sbc $D2.b,S		; E3 D2 ; Subtract stack-relative $D2.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sty $14.b,X		; 94 14 ; Store Y register $14.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	brk $5D.b		; 00 5D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $132E.w		; 2E 2E 13 ; Rotate left $132E.w [Flags: NCZ]
	ora [$08.b],Y		; 17 08 ; OR accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $7E.b		; 04 7E ; Test and set bits $7E.b [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $22070F.l,X		; 1F 0F 07 22 ; Logical OR long $22070F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	stz $74.b,X		; 74 74 ; Store zero to $74.b,X [Reads: X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	cpx #$E0.b		; E0 E0 ; Compare #$E0.b with X register [Reads: X Index] [Flags: NCZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $7E.b		; 04 7E ; Test and set bits $7E.b [Reads: Accumulator] [Flags: Z]
	jmp.w [$F0F8]		; DC F8 F0 ; Jump long indirect [$F0F8] [Flow: jump]
	cpx #$22.b		; E0 22 ; Compare #$22.b with X register [Reads: X Index] [Flags: NCZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $78.b,S		; A3 78 ; Load accumulator (stack relative) $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp $1B263C.l		; 5C 3C 26 1B ; Jump long to $1B263C.l [Flow: jump]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $BC1400.l		; 22 00 14 BC ; Jump to subroutine long $BC1400.l [Writes: Stack Pointer] [Flow: call]
	eor $193A27.l,X		; 5F 27 3A 19 ; Exclusive OR accumulator with memory (long,X) $193A27.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $C50003.l		; 0F 03 00 C5 ; OR accumulator with memory (long) $C50003.l [Writes: Accumulator] [Flags: NZ]
	asl $3C3A.w,X		; 1E 3A 3C ; Arithmetic shift left $3C3A.w,X [Reads: X Index] [Flags: NCZ]
	stz $D8.b		; 64 D8 ; Store zero to $D8.b
	jmp $6098E0.l		; 5C E0 98 60 ; Jump long to $6098E0.l [Flow: jump]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $E4FA.w,X		; 3D FA E4 ; AND accumulator with memory $E4FA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $C0F098.l		; 5C 98 F0 C0 ; Jump long to $C0F098.l [Flow: jump]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $D8		; 70 D8 ; Branch if overflow set to $70, $D8 [Flow: branch]
	.db $70, $43		; 70 43 ; Branch if overflow set to $70, $43 [Flow: branch]
	pei ($78.b)		; D4 78 ; Push effective indirect address ($78.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ora $C47CCB.l		; 0F CB 7C C4 ; OR accumulator with memory (long) $C47CCB.l [Writes: Accumulator] [Flags: NZ]
	adc $D87FC3.l,X		; 7F C3 7F D8 ; Add long $D87FC3.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $DCD8F8.l,X		; 7F F8 D8 DC ; Add long $DCD8F8.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$C7CF]		; DC CF C7 ; Jump long indirect [$C7CF] [Flow: jump]
	cmp $D8.b,S		; C3 D8 ; Compare accumulator (stack relative) $D8.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $C0.b		; 05 C0 ; Logical OR $C0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$C7.b		; C0 C7 ; Compare #$C7.b with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $C0.b		; 02 C0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $1FE1FF.l,X		; FF FF E1 1F ; Subtract with carry (long,X) $1FE1FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	cmp #$70.b		; C9 70 ; Compare #$70.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	dec $39.b,X		; D6 39 ; Decrement memory $39.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $2DBE.w,X		; 5D BE 2D ; Exclusive OR accumulator with memory $2DBE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $FC0F.w,X		; 5E 0F FC ; Logical shift right $FC0F.w,X [Reads: X Index] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ldx $7051.w,Y		; BE 51 70 ; Load X register $7051.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $AFDE.w,Y		; F9 DE AF ; Subtract with carry $AFDE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $F2FC7E.l,X		; DF 7E FC F2 ; Compare accumulator (long,X) $F2FC7E.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	asl $9300.w		; 0E 00 93 ; Arithmetic shift left $9300.w [Flags: NCZ]
	asl $9C6B.w		; 0E 6B 9C ; Arithmetic shift left $9C6B.w [Flags: NCZ]
	cmp [$BA.b],Y		; D7 BA ; Compare accumulator (long indexed) [$BA.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc $7AB4.w,X		; 7D B4 7A ; Add $7AB4.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	cmp ($7D.b)		; D2 7D ; Compare accumulator (indirect) ($7D.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $7B9F.w		; 0E 9F 7B ; Arithmetic shift left $7B9F.w [Flags: NCZ]
	sbc $FB.b,X		; F5 FB ; Subtract $FB.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $4F3F.w,X		; 7E 3F 4F ; Rotate right $4F3F.w,X [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $67.b		; 00 67 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	bit $3D13.w,X		; 3C 13 3D ; Test bits $3D13.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora [$39.b],Y		; 17 39 ; OR accumulator with memory (long indexed) [$39.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $7D0F38.l		; 0F 38 0F 7D ; OR accumulator with memory (long) $7D0F38.l [Writes: Accumulator] [Flags: NZ]
	and [$7F.b]		; 27 7F ; AND accumulator with memory (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $38.b		; 26 38 ; Rotate left $38.b [Reads: Direct Page] [Flags: NCZ]
	adc $3D3F3C.l,X		; 7F 3C 3F 3D ; Add long $3D3F3C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $0C67.w		; 6D 67 0C ; Add $0C67.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $B846.w		; 0C 46 B8 ; Test and set bits $B846.w [Reads: Accumulator] [Flags: Z]
	ldx $FE74.w		; AE 74 FE ; Load $FE74.w into X register [Writes: X Index] [Flags: NZ]
	jmp ($E8FA.w)		; 6C FA E8 ; Jump indirect to ($E8FA.w) [Flow: jump]
	sbc $62.b,X		; F5 62 ; Subtract $62.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	bit $0C.b,X		; 34 0C ; Test bits $0C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	inc $EA76.w,X		; FE 76 EA ; Increment memory $EA76.w,X [Reads: X Index] [Flags: NZ]
	sbc ($F6.b)		; F2 F6 ; Subtract with carry (indirect) ($F6.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00073E.l,X		; FF 3E 07 00 ; Subtract with carry (long,X) $00073E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	ora $1A.b,S		; 03 1A ; OR accumulator with stack relative $1A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $331E35.l		; 0F 35 1E 33 ; OR accumulator with memory (long) $331E35.l [Writes: Accumulator] [Flags: NZ]
	ora $7F1977.l,X		; 1F 77 19 7F ; Logical OR long $7F1977.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b),Y		; 11 07 ; OR accumulator with memory ($07.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $3D1E0C.l		; 0F 0C 1E 3D ; OR accumulator with memory (long) $3D1E0C.l [Writes: Accumulator] [Flags: NZ]
	and ($57.b,S),Y		; 33 57 ; AND accumulator (stack relative indirect indexed) ($57.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $0080.w,Y		; 59 80 00 ; Exclusive OR accumulator with memory $0080.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy $7460.w,X		; BC 60 74 ; Load Y register $7460.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $D0, $F4		; D0 F4 ; Branch if not equal to $D0, $F4 [Flow: branch]
	.db $D0, $EA		; D0 EA ; Branch if not equal to $D0, $EA [Flow: branch]
	ldy $F6.b		; A4 F6 ; Load $F6.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cpy $F880.w		; CC 80 F8 ; Compare $F880.w with Y register [Reads: Y Index] [Flags: NCZ]
	stz $FC.b,X		; 74 FC ; Store zero to $FC.b,X [Reads: X Index]
	cpx $DEEC.w		; EC EC DE ; Compare $DEEC.w with X register [Reads: X Index] [Flags: NCZ]
	inc $0000.w,X		; FE 00 00 ; Increment memory $0000.w,X [Reads: X Index] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F1203.l		; 0F 03 12 0F ; OR accumulator with memory (long) $0F1203.l [Writes: Accumulator] [Flags: NZ]
	and $1E.b,X		; 35 1E ; Logical AND $1E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $3D15.w,X		; 3E 15 3D ; Rotate left $3D15.w,X [Reads: X Index] [Flags: NCZ]
	ora [$7E.b]		; 07 7E ; OR accumulator with memory (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $3F3D.w,X		; 1E 3D 3F ; Arithmetic shift left $3F3D.w,X [Reads: X Index] [Flags: NCZ]
	and $62.b,X		; 35 62 ; Logical AND $62.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	.db $80, $9C		; 80 9C ; Branch always to $80, $9C [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $E8D8.w,X		; 3C D8 E8 ; Test bits $E8D8.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ldy #$EC.b		; A0 EC ; Load #$EC.b into Y register [Writes: Y Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $7040.w,X		; DE 40 70 ; Decrement memory $7040.w,X [Reads: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	jmp.w [$D8A4]		; DC A4 D8 ; Jump long indirect [$D8A4] [Flow: jump]
	stz $00BE.w		; 9C BE 00 ; Store zero to $00BE.w
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: NCZ]
	ora $0A3E.w		; 0D 3E 0A ; Logical OR $0A3E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror $7B2A.w,X		; 7E 2A 7B ; Rotate right $7B2A.w,X [Reads: X Index] [Flags: NCZ]
	trb $0100.w		; 1C 00 01 ; Test and reset bits $0100.w [Reads: Accumulator] [Flags: Z]
	ora $3D3E1F.l		; 0F 1F 3E 3D ; OR accumulator with memory (long) $3D3E1F.l [Writes: Accumulator] [Flags: NZ]
	adc $385B.w,X		; 7D 5B 38 ; Add $385B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F4.b		; 00 F4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	ldy $FCC8.w,X		; BC C8 FC ; Load Y register $FCC8.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $84		; B0 84 ; Branch if carry set to $B0, $84 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ldy $78.b		; A4 78 ; Load $78.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $42, $FC		; 42 FC ; Reserved instruction
	sec		; 38 ; Set carry flag [Flags: C]
	pea $FCBC.w		; F4 BC FC ; Push absolute address $FCBC.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jmp $B484.w		; 4C 84 B4 ; Jump to $B484.w [Flow: jump]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	trb $3300.w		; 1C 00 33 ; Test and reset bits $3300.w [Reads: Accumulator] [Flags: Z]
	trb $3F4D.w		; 1C 4D 3F ; Test and reset bits $3F4D.w [Reads: Accumulator] [Flags: Z]
	and [$0F.b],Y		; 37 0F ; AND accumulator with memory (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$6D.b],Y		; 17 6D ; OR accumulator with memory (long indexed) [$6D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	mvn $8B,$23		; 54 23 8B ; Move block negative $8B,$23 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc [$1C.b],Y		; 77 1C ; Add with carry (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $2B374F.l,X		; 3F 4F 37 2B ; AND accumulator with memory (long,X) $2B374F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $5C.b,X		; 75 5C ; Add $5C.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	trb $F200.w		; 1C 00 F2 ; Test and reset bits $F200.w [Reads: Accumulator] [Flags: Z]
	trb $6E9D.w		; 1C 9D 6E ; Test and reset bits $6E9D.w [Reads: Accumulator] [Flags: Z]
	nop		; EA ; No operation
	ldy $F4.b,X		; B4 F4 ; Load Y register $F4.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	jmp ($C6F8.w,X)		; 7C F8 C6 ; Jump indirect indexed to ($C6F8.w,X) [Reads: X Index] [Flow: jump]
	jsr ($FC8A.w,X)		; FC 8A FC ; Jump to subroutine indirect indexed ($FC8A.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	trb $9DFE.w		; 1C FE 9D ; Test and reset bits $9DFE.w [Reads: Accumulator] [Flags: Z]
	nop		; EA ; No operation
	pea $FE7C.w		; F4 7C FE ; Push absolute address $FE7C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	inc $0083.w,X		; FE 83 00 ; Increment memory $0083.w,X [Reads: X Index] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx $79.b,Y		; B6 79 ; Load X register $79.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	and $1D6F.w,X		; 3D 6F 1D ; AND accumulator with memory $1D6F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $2F.b,X		; 76 2F ; Rotate right $2F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit $0F.b,X		; 34 0F ; Test bits $0F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	jmp $703F.w		; 4C 3F 70 ; Jump to $703F.w [Flow: jump]
	sbc $5FBE.w,Y		; F9 BE 5F ; Subtract with carry $5FBE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $6F3757.l		; 6F 57 37 6F ; Add with carry (long) $6F3757.l [Writes: Accumulator] [Flags: NCVZ]
	sta $18.b,S		; 83 18 ; Store accumulator (stack relative) $18.b,S [Reads: Stack Pointer, Accumulator]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $DA9E.w		; 6D 9E DA ; Add $DA9E.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ldy $B8F6.w,X		; BC F6 B8 ; Load Y register $B8F6.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ror $2CF4.w		; 6E F4 2C ; Rotate right $2CF4.w [Flags: NCZ]
	.db $F0, $32		; F0 32 ; Branch if equal to $F0, $32 [Flow: branch]
	jsr ($9F0E.w,X)		; FC 0E 9F ; Jump to subroutine indirect indexed ($9F0E.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $F6FA.w,X		; 7D FA F6 ; Add $F6FA.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	cpx $70F6.w		; EC F6 70 ; Compare $70F6.w with X register [Reads: X Index] [Flags: NCZ]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $B1		; 70 B1 ; Branch if overflow set to $70, $B1 [Flow: branch]
	lsr $43BC.w		; 4E BC 43 ; Logical shift right $43BC.w [Flags: NCZ]
	ldx $9F41.w,Y		; BE 41 9F ; Load X register $9F41.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $5F.b,S		; 43 5F ; Exclusive OR accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $7007.w		; 20 07 70 ; Jump to subroutine at $7007.w [Writes: Stack Pointer] [Flow: call]
	inc $C3CF.w,X		; FE CF C3 ; Increment memory $C3CF.w,X [Reads: X Index] [Flags: NZ]
	cmp ($E0.b,X)		; C1 E0 ; Compare accumulator ($E0.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$4A.b		; E0 4A ; Compare #$4A.b with X register [Reads: X Index] [Flags: NCZ]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sta [$20.b]		; 87 20 ; Store accumulator (long) [$20.b] [Reads: Direct Page, Accumulator]
	cmp $9FF00F.l,X		; DF 0F F0 9F ; Compare accumulator (long,X) $9FF00F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp $000030.l		; CF 30 00 00 ; Compare accumulator (long) $000030.l [Reads: Accumulator] [Flags: NCZ]
	sta [$DF.b]		; 87 DF ; Store accumulator (long) [$DF.b] [Reads: Direct Page, Accumulator]
	sbc $3060F0.l,X		; FF F0 60 30 ; Subtract with carry (long,X) $3060F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $396F71.l,X		; DF 71 6F 39 ; Compare accumulator (long,X) $396F71.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ldx $5F4F.w,Y		; BE 4F 5F ; Load X register $5F4F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsr $207F.w		; 20 7F 20 ; Jump to subroutine at $207F.w [Writes: Stack Pointer] [Flow: call]
	and [$08.b],Y		; 37 08 ; AND accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $7DFE.w,Y		; 79 FE 7D ; Add $7DFE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0C37.w,X		; 7D 37 0C ; Add $0C37.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FB.b,S		; 03 FB ; OR accumulator with stack relative $FB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stx $9CF6.w		; 8E F6 9C ; Store X register to $9CF6.w [Reads: X Index]
	adc $FAF2.w,X		; 7D F2 FA ; Add $FAF2.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	tsb $EC.b		; 04 EC ; Test and set bits $EC.b [Reads: Accumulator] [Flags: Z]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $BE7F.w,X		; 9E 7F BE ; Store zero to $BE7F.w,X [Reads: X Index]
	ldx $30EC.w,Y		; BE EC 30 ; Load X register $30EC.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	cpy #$FF.b		; C0 FF ; Compare #$FF.b with Y register [Reads: Y Index] [Flags: NCZ]
	ror $7B.b		; 66 7B ; Rotate right $7B.b [Reads: Direct Page] [Flags: NCZ]
	rol $1F61.w,X		; 3E 61 1F ; Rotate left $1F61.w,X [Reads: X Index] [Flags: NCZ]
	adc $3F0043.l,X		; 7F 43 00 3F ; Add long $3F0043.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$2B.b		; E0 2B ; Compare #$2B.b with X register [Reads: X Index] [Flags: NCZ]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	adc ($76.b,X)		; 61 76 ; Add with carry ($76.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $3F.b,X		; 36 3F ; Rotate left $3F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $3CEF07.l,X		; 1F 07 EF 3C ; Logical OR long $3CEF07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $7A.b		; C5 7A ; Compare $7A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc ($EE.b,S),Y		; F3 EE ; Subtract with carry (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	inc $FA0C.w,X		; FE 0C FA ; Increment memory $FA0C.w,X [Reads: X Index] [Flags: NZ]
	trb $CC.b		; 14 CC ; Test and reset bits $CC.b [Reads: Accumulator] [Flags: Z]
	.db $30, $B0		; 30 B0 ; Branch if minus to $30, $B0 [Flow: branch]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FAFEFF.l,X		; 7F FF FE FA ; Add long $FAFEFF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $C0B0.w		; CC B0 C0 ; Compare $C0B0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $33DF71.l,X		; FF 71 DF 33 ; Subtract with carry (long,X) $33DF71.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($1F.b,X)		; 61 1F ; Add with carry ($1F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $3F0043.l,X		; 7F 43 00 3F ; Add long $3F0043.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $0707.w,X		; 1E 07 07 ; Arithmetic shift left $0707.w,X [Reads: X Index] [Flags: NCZ]
	brk $F1.b		; 00 F1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($41.b,S),Y		; D3 41 ; Compare accumulator (stack relative indirect indexed) ($41.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $3E071E.l,X		; 3F 1E 07 3E ; AND accumulator with memory (long,X) $3E071E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	trb $D2F0.w		; 1C F0 D2 ; Test and reset bits $D2F0.w [Reads: Accumulator] [Flags: Z]
	jsr ($3CFA.w,X)		; FC FA 3C ; Jump to subroutine indirect indexed ($3CFA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pea $C838.w		; F4 38 C8 ; Push absolute address $C838.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $70, $83		; 70 83 ; Branch if overflow set to $70, $83 [Flow: branch]
	ldy $01.b		; A4 01 ; Load $01.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ora $FCFE.w		; 0D FE FC ; Logical OR $FCFE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $F4FA.w,X		; FE FA F4 ; Increment memory $F4FA.w,X [Reads: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	cmp $3FDE67.l,X		; DF 67 DE 3F ; Compare accumulator (long,X) $3FDE67.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	stz $1F.b		; 64 1F ; Store zero to $1F.b
	eor $7F.b,S		; 43 7F ; Exclusive OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $071C01.l,X		; 3F 01 1C 07 ; AND accumulator with memory (long,X) $071C01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$DF.b]		; C7 DF ; Compare accumulator (long) [$DF.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc [$6F.b]		; 67 6F ; Add with carry (long) [$6F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $071C3F.l		; 6F 3F 1C 07 ; Add with carry (long) $071C3F.l [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sty $9C.b,X		; 94 9C ; Store Y register $9C.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cpx $B2.b		; E4 B2 ; Compare $B2.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp ($F8E4.w,X)		; 7C E4 F8 ; Jump indirect indexed to ($F8E4.w,X) [Reads: X Index] [Flow: jump]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $87		; F0 87 ; Branch if equal to $F0, $87 [Flow: branch]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora $30C8E4.l		; 0F E4 C8 30 ; OR accumulator with memory (long) $30C8E4.l [Writes: Accumulator] [Flags: NZ]
	cpy #$F0.b		; C0 F0 ; Compare #$F0.b with Y register [Reads: Y Index] [Flags: NCZ]
	eor $6F3ED1.l,X		; 5F D1 3E 6F ; Exclusive OR accumulator with memory (long,X) $6F3ED1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $3F027F.l,X		; 1F 7F 02 3F ; Logical OR long $3F027F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$31.b]		; 07 31 ; OR accumulator with memory (long) [$31.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $8C83.w		; 0E 83 8C ; Arithmetic shift left $8C83.w [Flags: NCZ]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$6FDF]		; DC DF 6F ; Jump long indirect [$6FDF] [Flow: jump]
	adc $0C313F.l,X		; 7F 3F 31 0C ; Add long $0C313F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $CA.b,S		; 03 CA ; OR accumulator with stack relative $CA.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $5CA2.w,X		; BC A2 5C ; Load Y register $5CA2.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	.db $42, $BC		; 42 BC ; Reserved instruction
	ldx #$5C.b		; A2 5C ; Load #$5C.b into X register [Writes: X Index] [Flags: NZ]
	mvp $88,$B8		; 44 B8 88 ; Move block positive $88,$B8 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sty $03.b		; 84 03 ; Store Y register to $03.b [Reads: Y Index]
	cop $13.b		; 02 13 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	sep #$C2		; E2 C2 ; Set processor status bits #$C2 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sep #$C4		; E2 C4 ; Set processor status bits #$C4 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	sta $779B7F.l		; 8F 7F 9B 77 ; Store accumulator (long) $779B7F.l [Reads: Accumulator]
	eor $375B39.l		; 4F 39 5B 37 ; Exclusive OR accumulator with memory (long) $375B39.l [Writes: Accumulator] [Flags: NZ]
	and $101B.w		; 2D 1B 10 ; Logical AND $101B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $018C83.l		; 0F 83 8C 01 ; OR accumulator with memory (long) $018C83.l [Writes: Accumulator] [Flags: NZ]
	ora ($8F.b)		; 12 8F ; OR accumulator with memory (indirect) ($8F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $2D5F4F.l,X		; 9F 4F 5F 2D ; Store accumulator (long,X) $2D5F4F.l,X [Reads: Accumulator, X Index]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	ora $CC.b,S		; 03 CC ; OR accumulator with stack relative $CC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr ($FCDA.w,X)		; FC DA FC ; Jump to subroutine indirect indexed ($FCDA.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rol $F8.b,X		; 36 F8 ; Rotate left $F8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cpx $F8.b		; E4 F8 ; Compare $F8.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $33.b		; 84 33 ; Store Y register to $33.b [Reads: Y Index]
	cop $11.b		; 02 11 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($DAFE.w,X)		; FC FE DA ; Jump to subroutine indirect indexed ($DAFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rol $E4.b,X		; 36 E4 ; Rotate left $E4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	ldx $7F7F.w,Y		; BE 7F 7F ; Load X register $7F7F.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $A67FD7.l,X		; 1F D7 7F A6 ; Logical OR long $A67FD7.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $851F63.l,X		; 5F 63 1F 85 ; Exclusive OR accumulator with memory (long,X) $851F63.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $E6F77F.l,X		; FF 7F F7 E6 ; Subtract with carry (long,X) $E6F77F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $10.b,S		; 63 10 ; Add with carry (stack relative) $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $7D03.w		; 0C 03 7D ; Test and set bits $7D03.w [Reads: Accumulator] [Flags: Z]
	inc $F8FE.w,X		; FE FE F8 ; Increment memory $F8FE.w,X [Reads: X Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc $FA65.w,X		; FE 65 FA ; Increment memory $FA65.w,X [Reads: X Index] [Flags: NZ]
	dec $86.b		; C6 86 ; Decrement $86.b [Reads: Direct Page] [Flags: NZ]
	sta ($02.b),Y		; 91 02 ; Store accumulator ($02.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ora ($FF.b,S),Y		; 13 FF ; OR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $67EF.w,X		; FE EF 67 ; Increment memory $67EF.w,X [Reads: X Index] [Flags: NZ]
	dec $08.b		; C6 08 ; Decrement $08.b [Reads: Direct Page] [Flags: NZ]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	eor $386730.l		; 4F 30 67 38 ; Exclusive OR accumulator with memory (long) $386730.l [Writes: Accumulator] [Flags: NZ]
	and ($1C.b,S),Y		; 33 1C ; AND accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $1C1E.w,Y		; 39 1E 1C ; AND accumulator with memory $1C1E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $43030C.l		; 0F 0C 03 43 ; OR accumulator with memory (long) $43030C.l [Writes: Accumulator] [Flags: NZ]
	ora #$06.b		; 09 06 ; Logical OR #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $70, $78		; 70 78 ; Branch if overflow set to $70, $78 [Flow: branch]
	bit $1F3E.w,X		; 3C 3E 1F ; Test bits $1F3E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $D70E0E.l		; 0F 0E 0E D7 ; OR accumulator with memory (long) $D70E0E.l [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $770100.l,X		; FF 00 01 77 ; Subtract with carry (long,X) $770100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta $EA.b,S		; 83 EA ; Store accumulator (stack relative) $EA.b,S [Reads: Stack Pointer, Accumulator]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $2801.w,X		; FE 01 28 ; Increment memory $2801.w,X [Reads: X Index] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $1B3443.l		; 0F 43 34 1B ; OR accumulator with memory (long) $1B3443.l [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3B1F1F.l		; 0F 1F 1F 3B ; OR accumulator with memory (long) $3B1F1F.l [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor #$FF.b		; 49 FF ; Exclusive OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0191.w		; 6E 91 01 ; Rotate right $0191.w [Flags: NCZ]
	tsb $FB.b		; 04 FB ; Test and set bits $FB.b [Reads: Accumulator] [Flags: Z]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta ($91.b),Y		; 91 91 ; Store accumulator ($91.b),Y [Reads: Direct Page, Y Index, Accumulator]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	asl $0C03.w		; 0E 03 0C ; Arithmetic shift left $0C03.w [Flags: NCZ]
	ora [$43.b]		; 07 43 ; OR accumulator with memory (long) [$43.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $1F3043.l		; 0F 43 30 1F ; OR accumulator with memory (long) $1F3043.l [Writes: Accumulator] [Flags: NZ]
	ora ($34.b,X)		; 01 34 ; Logical OR ($34.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sty $11.b		; 84 11 ; Store Y register to $11.b [Reads: Y Index]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $473B3F.l,X		; 3F 3F 3B 47 ; AND accumulator with memory (long,X) $473B3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $6F0700.l,X		; FF 00 07 6F ; Subtract with carry (long,X) $6F0700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $4E		; 90 4E ; Branch if carry clear to $90, $4E [Flow: branch]
	lda ($0E.b),Y		; B1 0E ; Load accumulator ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($0C.b),Y		; F1 0C ; Subtract with carry ($0C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($23.b,S),Y		; F3 23 ; Subtract with carry (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $B1		; 90 B1 ; Branch if carry clear to $90, $B1 [Flow: branch]
	sbc ($F3.b),Y		; F1 F3 ; Subtract with carry ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $30.b,S		; 83 30 ; Store accumulator (stack relative) $30.b,S [Reads: Stack Pointer, Accumulator]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $1F.b,X		; 34 1F ; Test bits $1F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $1C1F.w,X		; 3C 1F 1C ; Test bits $1C1F.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $070F1A.l		; 0F 1A 0F 07 ; OR accumulator with memory (long) $070F1A.l [Writes: Accumulator] [Flags: NZ]
	ora $3F221F.l		; 0F 1F 22 3F ; OR accumulator with memory (long) $3F221F.l [Writes: Accumulator] [Flags: NZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $4700FF.l,X		; 1F FF 00 47 ; Logical OR long $4700FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $3F0680.l,X		; 7F 80 06 3F ; Add long $3F0680.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$2E.b		; C0 2E ; Compare #$2E.b with Y register [Reads: Y Index] [Flags: NCZ]
	cmp ($1E.b),Y		; D1 1E ; Compare accumulator ($1E.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sbc ($00.b,X)		; E1 00 ; Subtract with carry ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $80.b,S		; 23 80 ; AND accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$3C.b		; E0 3C ; Compare #$3C.b with X register [Reads: X Index] [Flags: NCZ]
	cpy #$D1.b		; C0 D1 ; Compare #$D1.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($22.b,X)		; E1 22 ; Subtract with carry ($22.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $2205.w		; 20 05 22 ; Jump to subroutine at $2205.w [Writes: Stack Pointer] [Flow: call]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $2102.w,Y		; F9 02 21 ; Subtract with carry $2102.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	jsl $23FB27.l		; 22 27 FB 23 ; Jump to subroutine long $23FB27.l [Writes: Stack Pointer] [Flow: call]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $5420.w		; 20 20 54 ; Jump to subroutine at $5420.w [Writes: Stack Pointer] [Flow: call]
	.db $70, $AA		; 70 AA ; Branch if overflow set to $70, $AA [Flow: branch]
	bit $94.b		; 24 94 ; Test bits $94.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	pei ($88.b)		; D4 88 ; Push effective indirect address ($88.b) [Reads: Direct Page] [Writes: Stack Pointer]
	cmp ($8C.b)		; D2 8C ; Compare accumulator (indirect) ($8C.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ldx #$DC.b		; A2 DC ; Load #$DC.b into X register [Writes: X Index] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$FC		; C2 FC
	jsr $AE74.w		; 20 74 AE ; Jump to subroutine at $AE74.w [Writes: Stack Pointer] [Flow: call]
	stz $DEDC.w		; 9C DC DE ; Store zero to $DEDC.w
	inc $00FE.w,X		; FE FE 00 ; Increment memory $00FE.w,X [Reads: X Index] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $7050.w		; 20 50 70 ; Jump to subroutine at $7050.w [Writes: Stack Pointer] [Flow: call]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $0A.b,S		; 43 0A ; Exclusive OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0006.w		; 09 06 00 ; Logical OR #$0006.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $2170.w		; 20 70 21 ; Jump to subroutine at $2170.w [Writes: Stack Pointer] [Flow: call]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $500B.w		; 0E 0B 50 ; Arithmetic shift left $500B.w [Flags: NCZ]
	jsr $A044.w		; 20 44 A0 ; Jump to subroutine at $A044.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora #$90C0.w		; 09 C0 90 ; Logical OR #$90C0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$E0D0.w		; E0 D0 E0 ; Compare #$E0D0.w with X register [Reads: X Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $64		; F0 64 ; Branch if equal to $F0, $64 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $70, $22		; 70 22 ; Branch if overflow set to $70, $22 [Flow: branch]
	cpx #$F003.w		; E0 03 F0 ; Compare #$F003.w with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jmp ($0025.w,X)		; 7C 25 00 ; Jump indirect indexed to ($0025.w,X) [Reads: X Index] [Flow: jump]
	ora #$0001.w		; 09 01 00 ; Logical OR #$0001.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1703.w		; 0E 03 17 ; Arithmetic shift left $1703.w [Flags: NCZ]
	ora #$0609.w		; 09 09 06 ; Logical OR #$0609.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $011C00.l		; 22 00 1C 01 ; Jump to subroutine long $011C00.l [Writes: Stack Pointer] [Flow: call]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00000D.l,X		; 1F 0D 00 00 ; Logical OR long $00000D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $68		; 10 68 ; Branch if plus to $10, $68 [Flow: branch]
	.db $30, $B8		; 30 B8 ; Branch if minus to $30, $B8 [Flow: branch]
	.db $10, $94		; 10 94 ; Branch if plus to $10, $94 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $10, $78		; 10 78 ; Branch if plus to $10, $78 [Flow: branch]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	.db $30, $38		; 30 38 ; Branch if minus to $30, $38 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	clv		; B8 ; Clear overflow flag [Flags: V]
	stz $F8B8.w		; 9C B8 F8 ; Store zero to $F8B8.w
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $063B00.l		; 0F 00 3B 06 ; OR accumulator with memory (long) $063B00.l [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and [$27.b],Y		; 37 27 ; AND accumulator with memory (long indexed) [$27.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F3000.l		; 0F 00 30 0F ; OR accumulator with memory (long) $0F3000.l [Writes: Accumulator] [Flags: NZ]
	cmp $C03F30.l		; CF 30 3F C0 ; Compare accumulator (long) $C03F30.l [Reads: Accumulator] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$0F27.w		; E0 27 0F ; Compare #$0F27.w with X register [Reads: X Index] [Flags: NCZ]
	and $20C0F0.l,X		; 3F F0 C0 20 ; AND accumulator with memory (long,X) $20C0F0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3C43.w		; 20 43 3C ; Jump to subroutine at $3C43.w [Writes: Stack Pointer] [Flow: call]
	eor $2E23.w,X		; 5D 23 2E ; Exclusive OR accumulator with memory $2E23.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($33.b),Y		; 11 33 ; OR accumulator with memory ($33.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $0E1D.w		; 1C 1D 0E ; Test and reset bits $0E1D.w [Reads: Accumulator] [Flags: Z]
	asl $2007.w		; 0E 07 20 ; Arithmetic shift left $2007.w [Flags: NCZ]
	jmp ($637F.w,X)		; 7C 7F 63 ; Jump indirect indexed to ($637F.w,X) [Reads: X Index] [Flow: jump]
	and ($3C.b),Y		; 31 3C ; AND accumulator with memory ($3C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $0F0F.w,X		; 1E 0F 0F ; Arithmetic shift left $0F0F.w,X [Reads: X Index] [Flags: NCZ]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F708F.l		; 0F 8F 70 1F ; OR accumulator with memory (long) $1F708F.l [Writes: Accumulator] [Flags: NZ]
	cpx #$F08F.w		; E0 8F F0 ; Compare #$F08F.w with X register [Reads: X Index] [Flags: NCZ]
	eor [$B8.b]		; 47 B8 ; Exclusive OR accumulator with memory (long) [$B8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $FF.b,S		; 43 FF ; Exclusive OR accumulator with stack relative $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $E0F07F.l		; 0F 7F F0 E0 ; OR accumulator with memory (long) $E0F07F.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $B8		; F0 B8 ; Branch if equal to $F0, $B8 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($1D.b)		; 32 1D ; AND accumulator with memory (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $0F0F19.l		; 0F 19 0F 0F ; OR accumulator with memory (long) $0F0F19.l [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$3D23.w		; E0 23 3D ; Compare #$3D23.w with X register [Reads: X Index] [Flags: NCZ]
	ora $070F1F.l,X		; 1F 1F 0F 07 ; Logical OR long $070F1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$F4FF.w		; E0 FF F4 ; Compare #$F4FF.w with X register [Reads: X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora $07FC.w		; 0D FC 07 ; Logical OR $07FC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $001F03.l,X		; FF 03 1F 00 ; Subtract with carry (long,X) $001F03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $FDFBFF.l,X		; FF FF FB FD ; Subtract with carry (long,X) $FDFBFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3C1FFF.l,X		; FF FF 1F 3C ; Subtract with carry (long,X) $3C1FFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $4305.w,X		; 3E 05 43 ; Rotate left $4305.w,X [Reads: X Index] [Flags: NCZ]
	asl $0203.w,X		; 1E 03 02 ; Arithmetic shift left $0203.w,X [Reads: X Index] [Flags: NCZ]
	ora $240701.l		; 0F 01 07 24 ; OR accumulator with memory (long) $240701.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $90.b		; 84 90 ; Store Y register to $90.b [Reads: Y Index]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	stx $04.b,Y		; 96 04 ; Store X register $04.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $CF3007.l,X		; FF 07 30 CF ; Subtract with carry (long,X) $CF3007.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $FEFF.w		; 1C FF FE ; Test and reset bits $FEFF.w [Reads: Accumulator] [Flags: Z]
	sbc $FF.b,S		; E3 FF ; Subtract stack-relative $FF.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ldx $04.b		; A6 04 ; Load $04.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	brk $CF.b		; 00 CF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1F0DFF.l		; 22 FF 0D 1F ; Jump to subroutine long $1F0DFF.l [Writes: Stack Pointer] [Flow: call]
	trb $1C0B.w		; 1C 0B 1C ; Test and reset bits $1C0B.w [Reads: Accumulator] [Flags: Z]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $1B0600.l		; 22 00 06 1B ; Jump to subroutine long $1B0600.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $0F0E.w,X		; 1D 0E 0F ; OR accumulator with memory $0F0E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $97.b		; 84 97 ; Store Y register to $97.b [Reads: Y Index]
	tsb $16.b		; 04 16 ; Test and set bits $16.b [Reads: Accumulator] [Flags: Z]
	.db $80, $7F		; 80 7F ; Branch always to $80, $7F [Flow: branch]
	dec $3B.b		; C6 3B ; Decrement $3B.b [Reads: Direct Page] [Flags: NZ]
	sbc [$0D.b],Y		; F7 0D ; Subtract with carry (long indexed) [$0D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $F0FFF8.l		; 0F F8 FF F0 ; OR accumulator with memory (long) $F0FFF8.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $0F3B7F.l,X		; FF 7F 3B 0F ; Subtract with carry (long,X) $0F3B7F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $02F0FF.l,X		; FF FF F0 02 ; Subtract with carry (long,X) $02F0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$0933.w		; E0 33 09 ; Compare #$0933.w with X register [Reads: X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $1D.b,X		; 16 1D ; Arithmetic shift left $1D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora #$0008.w		; 09 08 00 ; Logical OR #$0008.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0009.w,X		; 1E 09 00 ; Arithmetic shift left $0009.w,X [Reads: X Index] [Flags: NCZ]
	sbc [$FE.b],Y		; F7 FE ; Subtract with carry (long indexed) [$FE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7EBFFE.l,X		; 7F FE BF 7E ; Add long $7EBFFE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $017E.w,X		; 9D 7E 01 ; Store accumulator to $017E.w,X [Reads: Accumulator, X Index]
	inc $FC02.w,X		; FE 02 FC ; Increment memory $FC02.w,X [Reads: X Index] [Flags: NZ]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $019DBF.l,X		; 7F BF 9D 01 ; Add long $019DBF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $23.b		; 24 23 ; Test bits $23.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor ($71.b)		; 52 71 ; Exclusive OR accumulator with memory (indirect) ($71.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $20.b		; 25 20 ; Logical AND $20.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $030405.l		; 0F 05 04 03 ; OR accumulator with memory (long) $030405.l [Writes: Accumulator] [Flags: NZ]
	sta $10.b,S		; 83 10 ; Store accumulator (stack relative) $10.b,S [Reads: Stack Pointer, Accumulator]
	ora $E0.b		; 05 E0 ; Logical OR $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $05.b		; 25 05 ; Logical AND $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $72.b		; 24 72 ; Test bits $72.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $0F.b		; 25 0F ; Logical AND $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($32.b,X)		; 01 32 ; Logical OR ($32.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr ($FC36.w,X)		; FC 36 FC ; Jump to subroutine indirect indexed ($FC36.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $FE3FFE.l,X		; 1F FE 3F FE ; Logical OR long $FE3FFE.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $62FE.w,Y		; F9 FE 62 ; Subtract with carry $62FE.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($F00C.w,X)		; FC 0C F0 ; Jump to subroutine indirect indexed ($F00C.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	rol $1F3E.w,X		; 3E 3E 1F ; Rotate left $1F3E.w,X [Reads: X Index] [Flags: NCZ]
	and $0C62F9.l,X		; 3F F9 62 0C ; AND accumulator with memory (long,X) $0C62F9.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $43.b,S		; 23 43 ; AND accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $240E0E.l		; 0F 0E 0E 24 ; OR accumulator with memory (long) $240E0E.l [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0000.w		; 09 00 00 ; Logical OR #$0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $FEF8.w,X		; BC F8 FE ; Load Y register $FEF8.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	jsr ($FE7F.w,X)		; FC 7F FE ; Jump to subroutine indirect indexed ($FE7F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $83FE.w,X		; 1D FE 83 ; OR accumulator with memory $83FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $05		; 30 05 ; Branch if minus to $30, $05 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $FC.b		; 00 FC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $1D7F.w,X		; FE 7F 1D ; Increment memory $1D7F.w,X [Reads: X Index] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $38.b		; C4 38 ; Compare $38.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ror $09.b,X		; 76 09 ; Rotate right $09.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stz $6767.w		; 9C 67 67 ; Store zero to $6767.w
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $07001F.l,X		; 1F 1F 00 07 ; Logical OR long $07001F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $4F0700.l		; 22 00 07 4F ; Jump to subroutine long $4F0700.l [Writes: Stack Pointer] [Flow: call]
	sbc [$7B.b]		; E7 7B ; Subtract with carry (long) [$7B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $01071F.l,X		; 3F 1F 07 01 ; AND accumulator with memory (long,X) $01071F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $3F0F80.l,X		; 7F 80 0F 3F ; Add long $3F0F80.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$F8C7.w		; C0 C7 F8 ; Compare #$F8C7.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $3F		; D0 3F ; Branch if not equal to $D0, $3F [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$3F.b]		; 07 3F ; OR accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $3F0DFF.l		; 22 FF 0D 3F ; Jump to subroutine long $3F0DFF.l [Writes: Stack Pointer] [Flow: call]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora [$B0.b]		; 07 B0 ; OR accumulator with memory (long) [$B0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $203C43.l		; 4F 43 3C 20 ; Exclusive OR accumulator with memory (long) $203C43.l [Writes: Accumulator] [Flags: NZ]
	ora $0F001F.l,X		; 1F 1F 00 0F ; Logical OR long $0F001F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $4F0500.l		; 22 00 05 4F ; Jump to subroutine long $4F0500.l [Writes: Stack Pointer] [Flow: call]
	sbc $1F3F7C.l,X		; FF 7C 3F 1F ; Subtract with carry (long,X) $1F3F7C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $05B683.l		; 0F 83 B6 05 ; OR accumulator with memory (long) $05B683.l [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$FF43.w		; E0 43 FF ; Compare #$FF43.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $80E1.w,X		; 1E E1 80 ; Arithmetic shift left $80E1.w,X [Reads: X Index] [Flags: NCZ]
	adc $3F3CC3.l,X		; 7F C3 3C 3F ; Add long $3F3CC3.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$0000.w		; E0 00 00 ; Compare #$0000.w with X register [Reads: X Index] [Flags: NCZ]
	sbc ($FF.b,X)		; E1 FF ; Subtract with carry ($FF.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $24FF3F.l,X		; FF 3F FF 24 ; Subtract with carry (long,X) $24FF3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $221F0E.l		; 0F 0E 1F 22 ; OR accumulator with memory (long) $221F0E.l [Writes: Accumulator] [Flags: NZ]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1C1E00.l		; 0F 00 1E 1C ; OR accumulator with memory (long) $1C1E00.l [Writes: Accumulator] [Flags: NZ]
	and $CFF72B.l,X		; 3F 2B F7 CF ; AND accumulator with memory (long,X) $CFF72B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($B87F.w,X)		; FC 7F B8 ; Jump to subroutine indirect indexed ($B87F.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $986F18.l,X		; FF 18 6F 98 ; Subtract with carry (long,X) $986F18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1C007C.l		; 8F 7C 00 1C ; Store accumulator (long) $1C007C.l [Reads: Accumulator]
	and ($DC.b,S),Y		; 33 DC ; AND accumulator (stack relative indirect indexed) ($DC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clc		; 18 ; Clear carry flag [Flags: C]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($0022.w,X)		; 7C 22 00 ; Jump indirect indexed to ($0022.w,X) [Reads: X Index] [Flow: jump]
	trb $E6.b		; 14 E6 ; Test and reset bits $E6.b [Reads: Accumulator] [Flags: Z]
	inc $FF.b		; E6 FF ; Increment $FF.b [Reads: Direct Page] [Flags: NZ]
	sta $3CCF79.l,X		; 9F 79 CF 3C ; Store accumulator (long,X) $3CCF79.l,X [Reads: Accumulator, X Index]
	dec $C43D.w		; CE 3D C4 ; Decrement $C43D.w [Flags: NZ]
	and $00FF00.l,X		; 3F 00 FF 00 ; AND accumulator with memory (long,X) $00FF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $E6.b		; 00 E6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $3D3C.w,Y		; 79 3C 3D ; Add $3D3C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $0024FF.l,X		; 3F FF 24 00 ; AND accumulator with memory (long,X) $0024FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cpy #$60C0.w		; C0 C0 60 ; Compare #$60C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$F000.w		; E0 00 F0 ; Compare #$F000.w with X register [Reads: X Index] [Flags: NCZ]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	jsl $800400.l		; 22 00 04 80 ; Jump to subroutine long $800400.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$F080.w		; C0 80 F0 ; Compare #$F080.w with Y register [Reads: Y Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $0100.w,Y		; 19 00 01 ; OR accumulator with memory $0100.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $002298.l		; 6F 98 22 00 ; Add with carry (long) $002298.l [Writes: Accumulator] [Flags: NCVZ]
	sta $29.b,S		; 83 29 ; Store accumulator (stack relative) $29.b,S [Reads: Stack Pointer, Accumulator]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	inc $E6.b		; E6 E6 ; Increment $E6.b [Reads: Direct Page] [Flags: NZ]
	sbc $CFF91F.l,X		; FF 1F F9 CF ; Subtract with carry (long,X) $CFF91F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $3FCC.w,X		; 3C CC 3F ; Test bits $3FCC.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $E6.b,S		; 03 E6 ; OR accumulator with stack relative $E6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $3F3C.w,Y		; F9 3C 3F ; Subtract with carry $3F3C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $80.b		; 02 80 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $081F00.l		; 0F 00 1F 08 ; OR accumulator with memory (long) $081F00.l [Writes: Accumulator] [Flags: NZ]
	rol $3C10.w,X		; 3E 10 3C ; Rotate left $3C10.w,X [Reads: X Index] [Flags: NCZ]
	brk $37.b		; 00 37 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$00E0.w		; 09 E0 00 ; Logical OR #$00E0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $20		; 30 20 ; Branch if minus to $30, $20 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $78.b		; 00 78 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $50F8.w		; 20 F8 50 ; Jump to subroutine at $50F8.w [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $C6.b,S		; 83 C6 ; Store accumulator (stack relative) $C6.b,S [Reads: Stack Pointer, Accumulator]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $207E10.l,X		; 3F 10 7E 20 ; AND accumulator with memory (long,X) $207E10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($7600.w,X)		; 7C 00 76 ; Jump indirect indexed to ($7600.w,X) [Reads: X Index] [Flow: jump]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $F01500.l		; 22 00 15 F0 ; Jump to subroutine long $F01500.l [Writes: Stack Pointer] [Flow: call]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol $7E10.w,X		; 3E 10 7E ; Rotate left $7E10.w,X [Reads: X Index] [Flags: NCZ]
	bit $7E.b		; 24 7E ; Test bits $7E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$00A0.w		; C0 A0 00 ; Compare #$00A0.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0303.w		; 09 03 03 ; Logical OR #$0303.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $130F.w		; 0C 0F 13 ; Test and set bits $130F.w [Reads: Accumulator] [Flags: Z]
	trb $3827.w		; 1C 27 38 ; Test and reset bits $3827.w [Reads: Accumulator] [Flags: Z]
	and $002330.l		; 2F 30 23 00 ; AND accumulator with memory (long) $002330.l [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $1318.w		; 0C 18 13 ; Test and set bits $1318.w [Reads: Accumulator] [Flags: Z]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$C0C0.w		; 09 C0 C0 ; Logical OR #$C0C0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx $1C.b		; E4 1C ; Compare $1C.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	pea $230C.w		; F4 0C 23 ; Push absolute address $230C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$1830.w		; C0 30 18 ; Compare #$1830.w with Y register [Reads: Y Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$6000.w		; C0 00 60 ; Compare #$6000.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($43.b),Y		; 31 43 ; AND accumulator with memory ($43.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $4573.w		; 2C 73 45 ; Test bits $4573.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	jsr $067F.w		; 20 7F 06 ; Jump to subroutine at $067F.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	and [$3D.b],Y		; 37 3D ; AND accumulator with memory (long indexed) [$3D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $11, $33		; 62 11 33 ; Push effective relative address $62, $11, $33 [Writes: Stack Pointer]
	and ($22.b,S),Y		; 33 22 ; AND accumulator (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $22171F.l,X		; 3F 1F 17 22 ; AND accumulator with memory (long,X) $22171F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($8E.b),Y		; 71 8E ; Add with carry ($8E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tsb $FF.b		; 04 FF ; Test and set bits $FF.b [Reads: Accumulator] [Flags: Z]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $1F		; 80 1F ; Branch always to $80, $1F [Flow: branch]
	cpx #$C03F.w		; E0 3F C0 ; Compare #$C03F.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $8EFF00.l,X		; FF 00 FF 8E ; Subtract with carry (long,X) $8EFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	cpy #$8000.w		; C0 00 80 ; Compare #$8000.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $DF31CE.l,X		; 7F CE 31 DF ; Add long $DF31CE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $FF43.w		; 20 43 FF ; Jump to subroutine at $FF43.w [Writes: Stack Pointer] [Flow: call]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$11EE.w		; 29 EE 11 ; Logical AND #$11EE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$F01F.w		; E0 1F F0 ; Compare #$F01F.w with X register [Reads: X Index] [Flags: NCZ]
	ora $20317F.l		; 0F 7F 31 20 ; OR accumulator with memory (long) $20317F.l [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $3C8C78.l		; 0F 78 8C 3C ; OR accumulator with memory (long) $3C8C78.l [Writes: Accumulator] [Flags: NZ]
	dec $14.b		; C6 14 ; Decrement $14.b [Reads: Direct Page] [Flags: NZ]
	inc $FE04.w		; EE 04 FE ; Increment $FE04.w [Flags: NZ]
	tsb $10FE.w		; 0C FE 10 ; Test and set bits $10FE.w [Reads: Accumulator] [Flags: Z]
	jsr ($CC38.w,X)		; FC 38 CC ; Jump to subroutine indirect indexed ($CC38.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	bit $88C6.w,X		; 3C C6 88 ; Test bits $88C6.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cpy $EC.b		; C4 EC ; Compare $EC.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	jsr ($F0FC.w,X)		; FC FC F0 ; Jump to subroutine indirect indexed ($F0FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy $06.b		; C4 06 ; Compare $06.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	ora $43180F.l		; 0F 0F 18 43 ; OR accumulator with memory (long) $43180F.l [Writes: Accumulator] [Flags: NZ]
	asl $39.b,X		; 16 39 ; Arithmetic shift left $39.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $10.b		; 45 10 ; Exclusive OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $1B0C05.l,X		; 3F 05 0C 1B ; AND accumulator with memory (long,X) $1B0C05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $2219.w,Y		; 19 19 22 ; OR accumulator with memory $2219.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $860B04.l,X		; 1F 04 0B 86 ; Logical OR long $860B04.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $FE01.w,X		; 7D 01 FE ; Add $FE01.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit #$019A.w		; 89 9A 01 ; Test bits #$019A.w with accumulator [Reads: Accumulator] [Flags: Z]
	ora $7F.b,S		; 03 7F ; OR accumulator with stack relative $7F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $7D		; 80 7D ; Branch always to $80, $7D [Flow: branch]
	inc $A984.w,X		; FE 84 A9 ; Increment memory $A984.w,X [Reads: X Index] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	sbc $EEFF00.l,X		; FF 00 FF EE ; Subtract with carry (long,X) $EEFF00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($45.b),Y		; 11 45 ; OR accumulator with memory ($45.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F60600.l,X		; FF 00 06 F6 ; Subtract with carry (long,X) $F60600.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$0FF0.w		; 09 F0 0F ; Logical OR #$0FF0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $2211FF.l,X		; FF FF 11 22 ; Subtract with carry (long,X) $2211FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $09.b		; 24 09 ; Test bits $09.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $70F060.l		; 0F 60 F0 70 ; OR accumulator with memory (long) $70F060.l [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sty $DC28.w		; 8C 28 DC ; Store Y register to $DC28.w [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsr ($FC18.w,X)		; FC 18 FC ; Jump to subroutine indirect indexed ($FC18.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr $70F8.w		; 20 F8 70 ; Jump to subroutine at $70F8.w [Writes: Stack Pointer] [Flow: call]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$8890.w		; E0 90 88 ; Compare #$8890.w with X register [Reads: X Index] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$3F90.w		; E0 90 3F ; Compare #$3F90.w with X register [Reads: X Index] [Flags: NCZ]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $35		; 10 35 ; Branch if plus to $10, $35 [Flow: branch]
	.db $10, $2E		; 10 2E ; Branch if plus to $10, $2E [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0F0C.w,X		; 1D 0C 0F ; OR accumulator with memory $0F0C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $00, $22		; 62 00 22 ; Push effective relative address $62, $00, $22 [Writes: Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $43		; 80 43 ; Branch always to $80, $43 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	cpx #$0025.w		; E0 25 00 ; Compare #$0025.w with X register [Reads: X Index] [Flags: NCZ]
	and $40.b,S		; 23 40 ; AND accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $7F0C00.l		; 22 00 0C 7F ; Jump to subroutine long $7F0C00.l [Writes: Stack Pointer] [Flow: call]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3077.w		; 20 77 30 ; Jump to subroutine at $3077.w [Writes: Stack Pointer] [Flow: call]
	adc $3E29.w		; 6D 29 3E ; Add $3E29.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora ($1D.b)		; 12 1D ; OR accumulator with memory (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $230F.w		; 0C 0F 23 ; Test and set bits $230F.w [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $62, $00, $00		; 62 00 00 ; Push effective relative address $62, $00, $00 [Writes: Stack Pointer]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $EE.b		; 00 EE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$EE24.w		; 09 24 EE ; Logical OR #$EE24.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $6E.b		; 04 6E ; Test and set bits $6E.b [Reads: Accumulator] [Flags: Z]
	tsb $EC.b		; 04 EC ; Test and set bits $EC.b [Reads: Accumulator] [Flags: Z]
	brk $E8.b		; 00 E8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $22F0.w		; 20 F0 22 ; Jump to subroutine at $22F0.w [Writes: Stack Pointer] [Flow: call]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $1F		; 30 1F ; Branch if minus to $30, $1F [Flow: branch]
	and ($07.b)		; 32 07 ; AND accumulator with memory (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0807.w,Y		; 19 07 08 ; OR accumulator with memory $0807.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $37.b,S		; 03 37 ; OR accumulator with stack relative $37.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $0E.b		; 14 0E ; Test and reset bits $0E.b [Reads: Accumulator] [Flags: Z]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $F80C.w		; F4 0C F8 ; Push absolute address $F80C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	jmp $98E0.w		; 4C E0 98 ; Jump to $98E0.w [Flow: jump]
	cpx #$0010.w		; E0 10 00 ; Compare #$0010.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$0025.w		; E0 25 00 ; Compare #$0025.w with X register [Reads: X Index] [Flags: NCZ]
	ora $EC.b,S		; 03 EC ; OR accumulator with stack relative $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $70, $C0		; 70 C0 ; Branch if overflow set to $70, $C0 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $26.b		; 04 26 ; Test and set bits $26.b [Reads: Accumulator] [Flags: Z]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $00		; B0 00 ; Branch if carry set to $B0, $00 [Flow: branch]
	cop $E0.b		; 02 E0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $5F72.w		; 2D 72 5F ; Logical AND $5F72.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$E45B.w		; E0 5B E4 ; Compare #$E45B.w with X register [Reads: X Index] [Flags: NCZ]
	eor ($EC.b,S),Y		; 53 EC ; XOR accumulator (stack relative indirect indexed) ($EC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($FE.b,X)		; 41 FE ; Exclusive OR accumulator with memory ($FE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($7E.b,X)		; 21 7E ; Logical AND ($7E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $107F.w		; 20 7F 10 ; Jump to subroutine at $107F.w [Writes: Stack Pointer] [Flow: call]
	and $646032.l,X		; 3F 32 60 64 ; AND accumulator with memory (long,X) $646032.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($3E7E.w)		; 6C 7E 3E ; Jump indirect to ($3E7E.w) [Flow: jump]
	and $08F71F.l,X		; 3F 1F F7 08 ; AND accumulator with memory (long,X) $08F71F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $CF4310.l		; EF 10 43 CF ; Subtract with carry (long) $CF4310.l [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $11		; 30 11 ; Branch if minus to $30, $11 [Flow: branch]
	sbc $08F710.l		; EF 10 F7 08 ; Subtract with carry (long) $08F710.l [Writes: Accumulator] [Flags: NCVZ]
	sbc $C03F00.l,X		; FF 00 3F C0 ; Subtract with carry (long,X) $C03F00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	.db $30, $10		; 30 10 ; Branch if minus to $30, $10 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($4303.w,X)		; FC 03 43 ; Jump to subroutine indirect indexed ($4303.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $F60100.l,X		; FF 00 01 F6 ; Subtract with carry (long,X) $F60100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora #$F843.w		; 09 43 F8 ; Logical OR #$F843.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx #$F71F.w		; E0 1F F7 ; Compare #$F71F.w with X register [Reads: X Index] [Flags: NCZ]
	tsb $0003.w		; 0C 03 00 ; Test and set bits $0003.w [Reads: Accumulator] [Flags: Z]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $8E780C.l,X		; 1F 0C 78 8E ; Logical OR long $8E780C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($4386.w,X)		; 7C 86 43 ; Jump indirect indexed to ($4386.w,X) [Reads: X Index] [Flow: jump]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp [$E0.b]		; C7 E0 ; Compare accumulator (long) [$E0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($12.b),Y		; 31 12 ; AND accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $D0BE4C.l		; EF 4C BE D0 ; Subtract with carry (long) $D0BE4C.l [Writes: Accumulator] [Flags: NCVZ]
	bit $3CC8.w,X		; 3C C8 3C ; Test bits $3CC8.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sty $C6.b		; 84 C6 ; Store Y register to $C6.b [Reads: Y Index]
	dec $EE.b		; C6 EE ; Decrement $EE.b [Reads: Direct Page] [Flags: NZ]
	ldy $3830.w,X		; BC 30 38 ; Load Y register $3830.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ora $3A.b,X		; 15 3A ; OR accumulator with memory $3A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $2A73.w		; 2C 73 2A ; Test bits $2A73.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	adc $23.b,X		; 75 23 ; Add $23.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($7E21.w,X)		; 7C 21 7E ; Jump indirect indexed to ($7E21.w,X) [Reads: X Index] [Flow: jump]
	ora $183E.w,Y		; 19 3E 18 ; OR accumulator with memory $183E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $1A1F0C.l,X		; 3F 0C 1F 1A ; AND accumulator with memory (long,X) $1A1F0C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($35.b,S),Y		; 33 35 ; AND accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $1E3E.w,X		; 3C 3E 1E ; Test bits $1E3E.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $00FF0F.l,X		; 1F 0F FF 00 ; Logical OR long $00FF0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$08.b],Y		; F7 08 ; Subtract with carry (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $18E710.l		; EF 10 E7 18 ; Subtract with carry (long) $18E710.l [Writes: Accumulator] [Flags: NCVZ]
	sta $22.b,S		; 83 22 ; Store accumulator (stack relative) $22.b,S [Reads: Stack Pointer, Accumulator]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0800E0.l,X		; 1F E0 00 08 ; Logical OR long $0800E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($4503.w,X)		; FC 03 45 ; Jump to subroutine indirect indexed ($4503.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $FD0800.l,X		; FF 00 08 FD ; Subtract with carry (long,X) $FD0800.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FE.b		; 02 FE ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($F8.b,X)		; 01 F8 ; Logical OR ($F8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$F7.b]		; 07 F7 ; OR accumulator with memory (long) [$F7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $2203.w		; 0C 03 22 ; Test and set bits $2203.w [Reads: Accumulator] [Flags: Z]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $70, $9C		; 70 9C ; Branch if overflow set to $70, $9C [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $8E74.w		; 0C 74 8E ; Test and set bits $8E74.w [Reads: Accumulator] [Flags: Z]
	bit $CE.b,X		; 34 CE ; Test bits $CE.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $DE.b		; 24 DE ; Test bits $DE.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsr ($43A0.w,X)		; FC A0 43 ; Jump to subroutine indirect indexed ($43A0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	.db $90, $06		; 90 06 ; Branch if carry clear to $90, $06 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sty $DCCC.w		; 8C CC DC ; Store Y register to $DCCC.w [Reads: Y Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $26		; 70 26 ; Branch if overflow set to $70, $26 [Flow: branch]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $080400.l		; 22 00 04 08 ; Jump to subroutine long $080400.l [Writes: Stack Pointer] [Flow: call]
	trb $08.b		; 14 08 ; Test and reset bits $08.b [Reads: Accumulator] [Flags: Z]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $303F10.l		; 0F 10 3F 30 ; OR accumulator with memory (long) $303F10.l [Writes: Accumulator] [Flags: NZ]
	ora $002320.l,X		; 1F 20 23 00 ; Logical OR long $002320.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $C0.b,S		; 03 C0 ; OR accumulator with stack relative $C0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$E020.w		; C0 20 E0 ; Compare #$E020.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $D0.b,S		; 43 D0 ; Exclusive OR accumulator with stack relative $D0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $24		; 30 24 ; Branch if minus to $30, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$2020.w		; C0 20 20 ; Compare #$2020.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $06.b,S		; 83 06 ; Store accumulator (stack relative) $06.b,S [Reads: Stack Pointer, Accumulator]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $120F10.l		; 0F 10 0F 12 ; OR accumulator with memory (long) $120F10.l [Writes: Accumulator] [Flags: NZ]
	ora $118314.l		; 0F 14 83 11 ; OR accumulator with memory (long) $118314.l [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora $2309.w		; 0D 09 23 ; Logical OR $2309.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $04		; 10 04 ; Branch if plus to $10, $04 [Flow: branch]
	ora $90.b,S		; 03 90 ; OR accumulator with stack relative $90.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $70, $D0		; 70 D0 ; Branch if overflow set to $70, $D0 [Flow: branch]
	.db $30, $43		; 30 43 ; Branch if minus to $30, $43 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $C01C00.l		; 22 00 1C C0 ; Jump to subroutine long $C01C00.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $9090.w		; 20 90 90 ; Jump to subroutine at $9090.w [Writes: Stack Pointer] [Flow: call]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: NZ]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: NZ]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $977FBF.l,X		; DF BF 7F 97 ; Compare accumulator (long,X) $977FBF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $50, $04		; 50 04 ; Branch if overflow clear to $50, $04 [Flow: branch]
	ora #$3F00.w		; 09 00 3F ; Logical OR #$3F00.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0F06.w,X		; 1D 06 0F ; OR accumulator with memory $0F06.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2406.w		; 0D 06 24 ; Logical OR $2406.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0F.b,X		; 35 0F ; Logical AND $0F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jsr ($FF08.w,X)		; FC 08 FF ; Jump to subroutine indirect indexed ($FF08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lda ($CF.b,S),Y		; B3 CF ; Load accumulator (stack relative indirect indexed) ($CF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $4DE3.w		; 9C E3 4D ; Store zero to $4DE3.w
	sbc ($3C.b,S),Y		; F3 3C ; Subtract with carry (stack relative indirect indexed) ($3C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $F03C00.l,X		; 7F 00 3C F0 ; Add long $F03C00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($C3EF.w,X)		; FC EF C3 ; Jump to subroutine indirect indexed ($C3EF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$3C71.w		; E0 71 3C ; Compare #$3C71.w with X register [Reads: X Index] [Flags: NCZ]
	brk $ED.b		; 00 ED ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2D3BD6.l,X		; 1F D6 3B 2D ; Logical OR long $2D3BD6.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($DC.b,S),Y		; F3 DC ; Subtract with carry (stack relative indirect indexed) ($DC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3C.b,S		; E3 3C ; Subtract stack-relative $3C.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $E3.b,S		; C3 E3 ; Compare accumulator (stack relative) $E3.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sta $00FF7C.l,X		; 9F 7C FF 00 ; Store accumulator (long,X) $00FF7C.l,X [Reads: Accumulator, X Index]
	jmp ($321F.w,X)		; 7C 1F 32 ; Jump indirect indexed to ($321F.w,X) [Reads: X Index] [Flow: jump]
	sbc $C3.b,S		; E3 C3 ; Subtract stack-relative $C3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora $9F.b,S		; 03 9F ; OR accumulator with stack relative $9F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($1000.w,X)		; 7C 00 10 ; Jump indirect indexed to ($1000.w,X) [Reads: X Index] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $80.b,S		; 43 80 ; Exclusive OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpy #$0001.w		; C0 01 00 ; Compare #$0001.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($FC.b,S),Y		; 13 FC ; OR accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $B3DF.w		; 2C DF B3 ; Test bits $B3DF.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cmp $3CE7D8.l		; CF D8 E7 3C ; Compare accumulator (long) $3CE7D8.l [Reads: Accumulator] [Flags: NCZ]
	sbc $233C00.l,X		; FF 00 3C 23 ; Subtract with carry (long,X) $233C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($C3CF.w,X)		; FC CF C3 ; Jump to subroutine indirect indexed ($C3CF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $3C.b		; E4 3C ; Compare $3C.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $ED0B00.l		; 22 00 0B ED ; Jump to subroutine long $ED0B00.l [Writes: Stack Pointer] [Flow: call]
	ora $EDFF15.l,X		; 1F 15 FF ED ; Logical OR long $EDFF15.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($1B.b,S),Y		; F3 1B ; Subtract with carry (stack relative indirect indexed) ($1B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$74.b]		; E7 74 ; Subtract with carry (long) [$74.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $237C00.l		; 8F 00 7C 23 ; Store accumulator (long) $237C00.l [Reads: Accumulator]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07E3F5.l,X		; 1F F5 E3 07 ; Logical OR long $07E3F5.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0022.w		; 0C 22 00 ; Test and set bits $0022.w [Reads: Accumulator] [Flags: Z]
	ora $20.b,S		; 03 20 ; OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpx #$0043.w		; E0 43 00 ; Compare #$0043.w with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $27		; 80 27 ; Branch always to $80, $27 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$0027.w		; E0 27 00 ; Compare #$0027.w with X register [Reads: X Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sty $C7.b		; 84 C7 ; Store Y register to $C7.b [Reads: Y Index]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $84.b		; 02 84 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($03.b),Y		; D1 03 ; Compare accumulator ($03.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	stx $DD.b		; 86 DD ; Store X register to $DD.b [Reads: X Index]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $25		; 10 25 ; Branch if plus to $10, $25 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $241F20.l,X		; 1F 20 1F 24 ; Logical OR long $241F20.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $140F2A.l,X		; 1F 2A 0F 14 ; Logical OR long $140F2A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $A6.b,S		; 83 A6 ; Store accumulator (stack relative) $A6.b,S [Reads: Stack Pointer, Accumulator]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $111B.w,X		; 1E 1B 11 ; Arithmetic shift left $111B.w,X [Reads: X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$E0.b]		; 07 E0 ; OR accumulator with memory (long) [$E0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$C010.w		; E0 10 C0 ; Compare #$C010.w with X register [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpy #$0023.w		; C0 23 00 ; Compare #$0023.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsl $901010.l		; 22 10 10 90 ; Jump to subroutine long $901010.l [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $120F14.l		; 0F 14 0F 12 ; OR accumulator with memory (long) $120F14.l [Writes: Accumulator] [Flags: NZ]
	ora $0C0310.l		; 0F 10 03 0C ; OR accumulator with memory (long) $0C0310.l [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0407.w		; 0D 07 04 ; Logical OR $0407.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $76.b,S		; 83 76 ; Store accumulator (stack relative) $76.b,S [Reads: Stack Pointer, Accumulator]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$D0.b]		; 07 D0 ; OR accumulator with memory (long) [$D0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $90		; 30 90 ; Branch if minus to $30, $90 [Flow: branch]
	.db $70, $20		; 70 20 ; Branch if overflow set to $70, $20 [Flow: branch]
	cpx #$C0C0.w		; E0 C0 C0 ; Compare #$C0C0.w with X register [Reads: X Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $90.b		; 04 90 ; Test and set bits $90.b [Reads: Accumulator] [Flags: Z]
	.db $90, $20		; 90 20 ; Branch if carry clear to $90, $20 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$0022.w		; C0 22 00 ; Compare #$0022.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $2E		; F0 2E ; Branch if equal to $F0, $2E [Flow: branch]
	.db $50, $04		; 50 04 ; Branch if overflow clear to $50, $04 [Flow: branch]
	brk $7F.b		; 00 7F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $090025.l,X		; FF 25 00 09 ; Subtract with carry (long,X) $090025.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $081F04.l		; 0F 04 1F 08 ; OR accumulator with memory (long) $081F04.l [Writes: Accumulator] [Flags: NZ]
	jsl $010C00.l		; 22 00 0C 01 ; Jump to subroutine long $010C00.l [Writes: Stack Pointer] [Flow: call]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0718.w		; 0C 18 07 ; Test and set bits $0718.w [Reads: Accumulator] [Flags: Z]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc [$C0.b],Y		; F7 C0 ; Subtract with carry (long indexed) [$C0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $FB.b		; 45 FB ; Exclusive OR $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0700.w,X		; FD 00 07 ; Subtract with carry $0700.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $22C8F8.l,X		; 3F F8 C8 22 ; AND accumulator with memory (long,X) $22C8F8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $26.b		; 02 26 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	ora $0C.b,S		; 03 0C ; OR accumulator with stack relative $0C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	and [$C0.b],Y		; 37 C0 ; AND accumulator with memory (long indexed) [$C0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $FB.b		; 45 FB ; Exclusive OR $FB.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $0000.w,X		; FD 00 00 ; Subtract with carry $0000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$38.b]		; 07 38 ; OR accumulator with memory (long) [$38.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jsl $020004.l		; 22 04 00 02 ; Jump to subroutine long $020004.l [Writes: Stack Pointer] [Flow: call]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $231F00.l		; 0F 00 1F 23 ; OR accumulator with memory (long) $231F00.l [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $48.b,S		; 83 48 ; Store accumulator (stack relative) $48.b,S [Reads: Stack Pointer, Accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: NCZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $FB22F7.l,X		; 3F F7 22 FB ; AND accumulator with memory (long,X) $FB22F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$FD30.w		; E0 30 FD ; Compare #$FD30.w with X register [Reads: X Index] [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $101F.w		; 0C 1F 10 ; Test and set bits $101F.w [Reads: Accumulator] [Flags: Z]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($7A.b,X)		; 21 7A ; Logical AND ($7A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $407F.w		; 20 7F 40 ; Jump to subroutine at $407F.w [Writes: Stack Pointer] [Flow: call]
	cmp $00FF40.l		; CF 40 FF 00 ; Compare accumulator (long) $00FF40.l [Reads: Accumulator] [Flags: NCZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $7C3F3E.l,X		; 1F 3E 3F 7C ; Logical OR long $7C3F3E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$30F0.w		; C0 F0 30 ; Compare #$30F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp.w [$5E84]		; DC 84 5E ; Jump long indirect [$5E84] [Flow: jump]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	cop $F3.b		; 02 F3 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jmp ($3EFC.w,X)		; 7C FC 3E ; Jump indirect indexed to ($3EFC.w,X) [Reads: X Index] [Flow: jump]
	asl $0025.w,X		; 1E 25 00 ; Arithmetic shift left $0025.w,X [Reads: X Index] [Flags: NCZ]
	bit #$0006.w		; 89 06 00 ; Test bits #$0006.w with accumulator [Reads: Accumulator] [Flags: Z]
	jsl $138C00.l		; 22 00 8C 13 ; Jump to subroutine long $138C00.l [Writes: Stack Pointer] [Flow: call]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$00.b],Y		; F7 00 ; Subtract with carry (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $27.b		; 84 27 ; Store Y register to $27.b [Reads: Y Index]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$09.b],Y		; 17 09 ; OR accumulator with memory (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$FC00.w		; E0 00 FC ; Compare #$FC00.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$1CFF.w		; E0 FF 1C ; Compare #$1CFF.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $03.b,S		; E3 03 ; Subtract stack-relative $03.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $00BF00.l,X		; DF 00 BF 00 ; Compare accumulator (long,X) $00BF00.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	adc $00FF00.l,X		; 7F 00 FF 00 ; Add long $00FF00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$1FFC.w		; E0 FC 1F ; Compare #$1FFC.w with X register [Reads: X Index] [Flags: NCZ]
	ora $804020.l,X		; 1F 20 40 80 ; Logical OR long $804020.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora #$0080.w		; 09 80 00 ; Logical OR #$0080.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$E080.w		; C0 80 E0 ; Compare #$E080.w with Y register [Reads: Y Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $F0, $20		; F0 20 ; Branch if equal to $F0, $20 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $85.b		; 05 85 ; Logical OR $85.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $011000.l		; 22 00 10 01 ; Jump to subroutine long $011000.l [Writes: Stack Pointer] [Flow: call]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	trb $E8.b		; 14 E8 ; Test and reset bits $E8.b [Reads: Accumulator] [Flags: Z]
	.db $10, $E0		; 10 E0 ; Branch if plus to $10, $E0 [Flow: branch]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $3E.b		; 00 3E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $40.b		; 05 40 ; Logical OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$415E.w		; A0 5E 41 ; Load #$415E.w into Y register [Writes: Y Index] [Flags: NZ]
	rol $2901.w,X		; 3E 01 29 ; Rotate left $2901.w,X [Reads: X Index] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$2000.w		; C0 00 20 ; Compare #$2000.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $C0.b		; 04 C0 ; Test and set bits $C0.b [Reads: Accumulator] [Flags: Z]
	jsr $28D0.w		; 20 D0 28 ; Jump to subroutine at $28D0.w [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	adc [$20.b],Y		; 77 20 ; Add with carry (long indexed) [$20.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $207D.w		; 20 7D 20 ; Jump to subroutine at $207D.w [Writes: Stack Pointer] [Flow: call]
	inc $4043.w,X		; FE 43 40 ; Increment memory $4043.w,X [Reads: X Index] [Flags: NZ]
	sbc $4120E0.l,X		; FF E0 20 41 ; Subtract with carry (long,X) $4120E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	stz $62.b		; 64 62 ; Store zero to $62.b
	cmp ($C0.b,X)		; C1 C0 ; Compare accumulator ($C0.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	cmp ($FD.b,X)		; C1 FD ; Compare accumulator ($FD.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$F9.b]		; 07 F9 ; OR accumulator with memory (long) [$F9.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $3EE1.w,X		; 1E E1 3E ; Arithmetic shift left $3EE1.w,X [Reads: X Index] [Flags: NCZ]
	jmp.w [$BE7F]		; DC 7F BE ; Jump long indirect [$BE7F] [Flow: jump]
	sbc $7BFFBC.l,X		; FF BC FF 7B ; Subtract with carry (long,X) $7BFFBC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($0702.w,X)		; FC 02 07 ; Jump to subroutine indirect indexed ($0702.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	asl $7F3E.w,X		; 1E 3E 7F ; Arithmetic shift left $7F3E.w,X [Reads: X Index] [Flags: NCZ]
	sbc $43FBFC.l,X		; FF FC FB 43 ; Subtract with carry (long,X) $43FBFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $170730.l		; 0F 30 07 17 ; OR accumulator with memory (long) $170730.l [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $70, $05		; 70 05 ; Branch if overflow set to $70, $05 [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $101007.l,X		; FF 07 10 10 ; Subtract with carry (long,X) $101007.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	bit $3A.b,X		; 34 3A ; Test bits $3A.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc $7F7F.w,X		; 7D 7F 7F ; Add $7F7F.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0198.w		; 8D 98 01 ; Store accumulator to $0198.w [Reads: Accumulator]
	brk $FB.b		; 00 FB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda [$01.b]		; A7 01 ; Load accumulator (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $7F0806.l,X		; 3F 06 08 7F ; AND accumulator with memory (long,X) $7F0806.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $7F.b		; 04 7F ; Test and set bits $7F.b [Reads: Accumulator] [Flags: Z]
	cop $7F.b		; 02 7F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $1F1000.l,X		; FF 00 10 1F ; Subtract with carry (long,X) $1F1000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $3D3B37.l,X		; 1F 37 3B 3D ; Logical OR long $3D3B37.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $7F7F.w,X		; 7E 7F 7F ; Rotate right $7F7F.w,X [Reads: X Index] [Flags: NCZ]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$FF.b]		; 07 FF ; OR accumulator with memory (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $FF4420.l,X		; FF 20 44 FF ; Subtract with carry (long,X) $FF4420.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora #$FC83.w		; 09 83 FC ; Logical OR #$FC83.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $FFFF.w,X		; FD FF FF ; Subtract with carry $FFFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx #$C0C0.w		; E0 C0 C0 ; Compare #$C0C0.w with X register [Reads: X Index] [Flags: NCZ]
	sta $43.b,S		; 83 43 ; Store accumulator (stack relative) $43.b,S [Reads: Stack Pointer, Accumulator]
	eor ($FE.b,X)		; 41 FE ; Exclusive OR accumulator with memory ($FE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($20.b,S),Y		; 13 20 ; OR accumulator (stack relative indirect indexed) ($20.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $107F20.l		; 6F 20 7F 10 ; Add with carry (long) $107F20.l [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $031F.w		; 0C 1F 03 ; Test and set bits $031F.w [Reads: Accumulator] [Flags: Z]
	ora $790300.l		; 0F 00 03 79 ; OR accumulator with memory (long) $790300.l [Writes: Accumulator] [Flags: NZ]
	adc $3C38.w,Y		; 79 38 3C ; Add $3C38.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00030F.l,X		; 1F 0F 03 00 ; Logical OR long $00030F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $82.b,S		; 43 82 ; Exclusive OR accumulator with stack relative $82.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $F60413.l,X		; 7F 13 04 F6 ; Add long $F60413.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jmp.w [$F830]		; DC 30 F8 ; Jump long indirect [$F830] [Flow: jump]
	cpy #$00F0.w		; C0 F0 00 ; Compare #$00F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$9E9E.w		; C0 9E 9E ; Compare #$9E9E.w with Y register [Reads: Y Index] [Flags: NCZ]
	trb $F83C.w		; 1C 3C F8 ; Test and reset bits $F83C.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $6F4310.l,X		; 3F 10 43 6F ; AND accumulator with memory (long,X) $6F4310.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $3CE0.w		; 20 E0 3C ; Jump to subroutine at $3CE0.w [Writes: Stack Pointer] [Flow: call]
	adc [$21.b],Y		; 77 21 ; Add with carry (long indexed) [$21.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $FD.b,S		; 43 FD ; Exclusive OR accumulator with stack relative $FD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$30.b]		; 47 30 ; Exclusive OR accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $30, $70		; 30 70 ; Branch if minus to $30, $70 [Flow: branch]
	.db $70, $69		; 70 69 ; Branch if overflow set to $70, $69 [Flow: branch]
	cmp [$C3.b]		; C7 C3 ; Compare accumulator (long) [$C3.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp [$F6.b]		; C7 F6 ; Compare accumulator (long) [$F6.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $997EE1.l,X		; 1F E1 7E 99 ; Logical OR long $997EE1.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FF7C.w,X		; FE 7C FF ; Increment memory $FF7C.w,X [Reads: X Index] [Flags: NZ]
	inc $E1FF.w,X		; FE FF E1 ; Increment memory $E1FF.w,X [Reads: X Index] [Flags: NZ]
	sbc $09E1DE.l,X		; FF DE E1 09 ; Subtract with carry (long,X) $09E1DE.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FFFE7E.l,X		; 1F 7E FE FF ; Logical OR long $FFFE7E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FFDEE1.l,X		; FF E1 DE FF ; Subtract with carry (long,X) $FFDEE1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $F82E70.l,X		; 9F 70 2E F8 ; Store accumulator (long,X) $F82E70.l,X [Reads: Accumulator, X Index]
	adc $FC.b,X		; 75 FC ; Add $FC.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$FC.b],Y		; F7 FC ; Subtract with carry (long indexed) [$FC.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $8000.w,X		; FE 00 80 ; Increment memory $8000.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $70, $F9		; 70 F9 ; Branch if overflow set to $70, $F9 [Flow: branch]
	eor $FE.b,S		; 43 FE ; Exclusive OR accumulator with stack relative $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($0808.w,X)		; FC 08 08 ; Jump to subroutine indirect indexed ($0808.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	jsr ($EE08.w,X)		; FC 08 EE ; Jump to subroutine indirect indexed ($EE08.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	tsb $45.b		; 04 45 ; Test and set bits $45.b [Reads: Accumulator] [Flags: Z]
	sbc $0C0402.l,X		; FF 02 04 0C ; Subtract with carry (long,X) $0C0402.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $E616.w		; 0C 16 E6 ; Test and set bits $E616.w [Reads: Accumulator] [Flags: Z]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora $47.b,S		; 03 47 ; OR accumulator with stack relative $47.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	mvp $40,$B8		; 44 B8 40 ; Move block positive $40,$B8 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $29.b,S		; 03 29 ; OR accumulator with stack relative $29.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	jsl $400200.l		; 22 00 02 40 ; Jump to subroutine long $400200.l [Writes: Stack Pointer] [Flow: call]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $E01D00.l		; 22 00 1D E0 ; Jump to subroutine long $E01D00.l [Writes: Stack Pointer] [Flow: call]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	cpx #$E810.w		; E0 10 E8 ; Compare #$E810.w with X register [Reads: X Index] [Flags: NCZ]
	ora [$10.b],Y		; 17 10 ; OR accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $41FF.w		; 0E FF 41 ; Arithmetic shift left $41FF.w [Flags: NCZ]
	ora $13C1.w		; 0D C1 13 ; Logical OR $13C1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($2F.b,X)		; E1 2F ; Subtract with carry ($2F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($27.b),Y		; 71 27 ; Add with carry ($27.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7F20.w,Y		; 79 20 7F ; Add $7F20.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $18.b,S		; 43 18 ; Exclusive OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $73C107.l,X		; 3F 07 C1 73 ; AND accumulator with memory (long,X) $73C107.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $3931.w		; 6D 31 39 ; Add $3931.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and $471F1F.l,X		; 3F 1F 1F 47 ; AND accumulator with memory (long,X) $471F1F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$F8.b],Y		; 77 F8 ; Add with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$7B.b]		; 07 7B ; OR accumulator with memory (long) [$7B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr ($FFCC.w,X)		; FC CC FF ; Jump to subroutine indirect indexed ($FFCC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	sbc $23FF20.l,X		; FF 20 FF 23 ; Subtract with carry (long,X) $23FF20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$09.b],Y		; F7 09 ; Subtract with carry (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cpy $E0C0.w		; CC C0 E0 ; Compare $E0C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($FF.b)		; 32 FF ; AND accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $45FF.w		; 0C FF 45 ; Test and set bits $45FF.w [Reads: Accumulator] [Flags: Z]
	jsr $437F.w		; 20 7F 43 ; Jump to subroutine at $437F.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $4D7F02.l,X		; 3F 02 7F 4D ; AND accumulator with memory (long,X) $4D7F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($22.b,S),Y		; 73 22 ; Add with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $1F1F02.l,X		; 3F 02 1F 1F ; AND accumulator with memory (long,X) $1F1F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$46.b],Y		; 97 46 ; Store accumulator (long indexed) [$46.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta [$02.b]		; 87 02 ; Store accumulator (long) [$02.b] [Reads: Direct Page, Accumulator]
	sta $FC.b,S		; 83 FC ; Store accumulator (stack relative) $FC.b,S [Reads: Stack Pointer, Accumulator]
	.db $80, $84		; 80 84 ; Branch always to $80, $84 [Flow: branch]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $97.b		; 00 97 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $830187.l		; 22 87 01 83 ; Jump to subroutine long $830187.l [Writes: Stack Pointer] [Flow: call]
	.db $80, $87		; 80 87 ; Branch always to $80, $87 [Flow: branch]
	rol $4503.w		; 2E 03 45 ; Rotate left $4503.w [Flags: NCZ]
	jsr $437F.w		; 20 7F 43 ; Jump to subroutine at $437F.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $4D7F02.l,X		; 3F 02 7F 4D ; AND accumulator with memory (long,X) $4D7F02.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($22.b,S),Y		; 73 22 ; Add with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $1F1F01.l,X		; 3F 01 1F 1F ; AND accumulator with memory (long,X) $1F1F01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$87.b]		; 47 87 ; Exclusive OR accumulator with memory (long) [$87.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta [$50.b]		; 87 50 ; Store accumulator (long) [$50.b] [Reads: Direct Page, Accumulator]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta [$84.b]		; 87 84 ; Store accumulator (long) [$84.b] [Reads: Direct Page, Accumulator]
	jmp $42E003.l		; 5C 03 E0 42 ; Jump long to $42E003.l [Flow: jump]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0B1C03.l		; 0F 03 1C 0B ; OR accumulator with memory (long) $0B1C03.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $1B		; 30 1B ; Branch if minus to $30, $1B [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	trb $0B63.w		; 1C 63 0B ; Test and reset bits $0B63.w [Reads: Accumulator] [Flags: Z]
	dec $34.b		; C6 34 ; Decrement $34.b [Reads: Direct Page] [Flags: NZ]
	cmp $0C0300.l		; CF 00 03 0C ; Compare accumulator (long) $0C0300.l [Reads: Accumulator] [Flags: NCZ]
	trb $24.b		; 14 24 ; Test and reset bits $24.b [Reads: Accumulator] [Flags: Z]
	and $76.b,S		; 23 76 ; AND accumulator with stack relative $76.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp $C000.w		; 4C 00 C0 ; Jump to $C000.w [Flow: jump]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$D038.w		; C0 38 D0 ; Compare #$D038.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $06D8.w		; 0C D8 06 ; Test and set bits $06D8.w [Reads: Accumulator] [Flags: Z]
	sec		; 38 ; Set carry flag [Flags: C]
	dec $D0.b		; C6 D0 ; Decrement $D0.b [Reads: Direct Page] [Flags: NZ]
	adc $2C.b,S		; 63 2C ; Add with carry (stack relative) $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$2830.w		; C0 30 28 ; Compare #$2830.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $C4.b		; 24 C4 ; Test bits $C4.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ror $FD32.w		; 6E 32 FD ; Rotate right $FD32.w [Flags: NCZ]
	eor [$0D.b]		; 47 0D ; Exclusive OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp [$15.b]		; C7 15 ; Compare accumulator (long) [$15.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sbc [$2D.b]		; E7 2D ; Subtract with carry (long) [$2D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc [$25.b],Y		; 77 25 ; Add with carry (long indexed) [$25.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $197F23.l,X		; 7F 23 7F 19 ; Add long $197F23.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $C73F18.l,X		; 3F 18 3F C7 ; AND accumulator with memory (long,X) $C73F18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$6F.b],Y		; 77 6F ; Add with carry (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$83.b],Y		; 37 83 ; AND accumulator with memory (long indexed) [$83.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $47,$03		; 44 03 47 ; Move block positive $47,$03 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda $DE02C0.l,X		; BF C0 02 DE ; Load long $DE02C0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($C3.b,X)		; E1 C3 ; Subtract with carry ($C3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $70.b		; 84 70 ; Store Y register to $70.b [Reads: Y Index]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $C3DE06.l,X		; BF 06 DE C3 ; Load long $C3DE06.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $447A.w,X		; FE 7A 44 ; Increment memory $447A.w,X [Reads: X Index] [Flags: NZ]
	inc $1B7B.w,X		; FE 7B 1B ; Increment memory $1B7B.w,X [Reads: X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $FF8C.w,X		; FE 8C FF ; Increment memory $FF8C.w,X [Reads: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $7EFF10.l,X		; FF 10 FF 7E ; Subtract with carry (long,X) $7EFF10.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FE7E7E.l,X		; 7F 7E 7E FE ; Add long $FE7E7E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $FF1F0F.l		; 8F 0F 1F FF ; Store accumulator (long) $FF1F0F.l [Reads: Accumulator]
	cop $60.b		; 02 60 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $98.b,S		; 03 98 ; OR accumulator with stack relative $98.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$F4.b]		; 07 F4 ; OR accumulator with memory (long) [$F4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1EE4.w		; 0E E4 1E ; Arithmetic shift left $1EE4.w [Flags: NCZ]
	tsb $FE.b		; 04 FE ; Test and set bits $FE.b [Reads: Accumulator] [Flags: Z]
	eor $18.b,S		; 43 18 ; Exclusive OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($0307.w,X)		; FC 07 03 ; Jump to subroutine indirect indexed ($0307.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stz $0C66.w,X		; 9E 66 0C ; Store zero to $0C66.w,X [Reads: X Index]
	trb $F8FC.w		; 1C FC F8 ; Test and reset bits $F8FC.w [Reads: Accumulator] [Flags: Z]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $50.b		; 85 50 ; Store accumulator to $50.b [Reads: Accumulator]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	tsb $0200.w		; 0C 00 02 ; Test and set bits $0200.w [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $400700.l		; 22 00 07 40 ; Jump to subroutine long $400700.l [Writes: Stack Pointer] [Flow: call]
	ldy #$4C50.w		; A0 50 4C ; Load #$4C50.w into Y register [Writes: Y Index] [Flags: NZ]
	and ($0D.b)		; 32 0D ; AND accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0000.w		; 2D 00 00 ; Logical AND $0000.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $26		; 80 26 ; Branch always to $80, $26 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	sta $3C.b		; 85 3C ; Store accumulator to $3C.b [Reads: Accumulator]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stz $88.b,X		; 74 88 ; Store zero to $88.b,X [Reads: X Index]
	.db $70, $80		; 70 80 ; Branch if overflow set to $70, $80 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $90, $0C		; 90 0C ; Branch if carry clear to $90, $0C [Flow: branch]
	ora $030F06.l,X		; 1F 06 0F 03 ; Logical OR long $030F06.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $010307.l		; 0F 07 03 01 ; OR accumulator with memory (long) $010307.l [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $40FF27.l,X		; FF 27 FF 40 ; Subtract with carry (long,X) $40FF27.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F8FFC0.l,X		; FF C0 FF F8 ; Subtract with carry (long,X) $F8FFC0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $07FF3F.l,X		; FF 3F FF 07 ; Subtract with carry (long,X) $07FF3F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $F80700.l,X		; 3F 00 07 F8 ; AND accumulator with memory (long,X) $F80700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $FF7FBF.l,X		; DF BF 7F FF ; Compare accumulator (long,X) $FF7FBF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	and $890007.l,X		; 3F 07 00 89 ; AND accumulator with memory (long,X) $890007.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $90.b,S		; 83 90 ; Store accumulator (stack relative) $90.b,S [Reads: Stack Pointer, Accumulator]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($98.b,X)		; 21 98 ; Logical AND ($98.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $04		; 90 04 ; Branch if carry clear to $90, $04 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta [$98.b],Y		; 97 98 ; Store accumulator (long indexed) [$98.b],Y [Reads: Direct Page, Y Index, Accumulator]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	and $CE.b,X		; 35 CE ; Logical AND $CE.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $EE.b,X		; 55 EE ; Exclusive OR accumulator with memory $EE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $6F.b		; 24 6F ; Test bits $6F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $88.b,S		; 23 88 ; AND accumulator with stack relative $88.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$02.b],Y		; 17 02 ; OR accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $4D.b,S		; 03 4D ; OR accumulator with stack relative $4D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $3F3C.w		; 6D 3C 3F ; Add $3F3C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $24.b,S		; 83 24 ; Store accumulator (stack relative) $24.b,S [Reads: Stack Pointer, Accumulator]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $AA73.w		; AC 73 AA ; Load $AA73.w into Y register [Writes: Y Index] [Flags: NZ]
	adc [$24.b],Y		; 77 24 ; Add with carry (long indexed) [$24.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $C4.b,X		; F6 C4 ; Increment memory $C4.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	and $B20302.l		; 2F 02 03 B2 ; AND accumulator with memory (long) $B20302.l [Writes: Accumulator] [Flags: NZ]
	ldx $3C.b,Y		; B6 3C ; Load X register $3C.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	jsr ($3C83.w,X)		; FC 83 3C ; Jump to subroutine indirect indexed ($3C83.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cop $89.b		; 02 89 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $04		; 80 04 ; Branch always to $80, $04 [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $90.b,S		; 83 90 ; Store accumulator (stack relative) $90.b,S [Reads: Stack Pointer, Accumulator]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $9B8C5F.l,X		; FF 5F 8C 9B ; Subtract with carry (long,X) $9B8C5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	cpx #$85BF.w		; E0 BF 85 ; Compare #$85BF.w with X register [Reads: X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tsb $11.b		; 04 11 ; Test and set bits $11.b [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $02FF9C.l,X		; FF 9C FF 02 ; Subtract with carry (long,X) $02FF9C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1FFF03.l,X		; FF 03 FF 1F ; Subtract with carry (long,X) $1FFF03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E0FFFC.l,X		; FF FC FF E0 ; Subtract with carry (long,X) $E0FFFC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($E000.w,X)		; FC 00 E0 ; Jump to subroutine indirect indexed ($E000.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $FD62E3.l,X		; 7F E3 62 FD ; Add long $FD62E3.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $E0FC.w		; 0C FC E0 ; Test and set bits $E0FC.w [Reads: Accumulator] [Flags: Z]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	cpx #$C080.w		; E0 80 C0 ; Compare #$C080.w with X register [Reads: X Index] [Flags: NCZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$80C0.w		; E0 C0 80 ; Compare #$80C0.w with X register [Reads: X Index] [Flags: NCZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $08,$00		; 44 00 08 ; Move block positive $08,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $0018.w		; 0E 18 00 ; Arithmetic shift left $0018.w [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0B.b		; 04 0B ; Test and set bits $0B.b [Reads: Accumulator] [Flags: Z]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	stz $98.b		; 64 98 ; Store zero to $98.b
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $2E		; 80 2E ; Branch always to $80, $2E [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $27		; 80 27 ; Branch always to $80, $27 [Flow: branch]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $26.b,S		; 03 26 ; OR accumulator with stack relative $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $E3.b,S		; 83 E3 ; Store accumulator (stack relative) $E3.b,S [Reads: Stack Pointer, Accumulator]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$3800.w		; C0 00 38 ; Compare #$3800.w with Y register [Reads: Y Index] [Flags: NCZ]
	sty $59.b		; 84 59 ; Store Y register to $59.b [Reads: Y Index]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	dec $39.b		; C6 39 ; Decrement $39.b [Reads: Direct Page] [Flags: NZ]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $03,$00		; 44 00 03 ; Move block positive $03,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $C0,$00		; 44 00 C0 ; Move block positive $C0,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($A0.b,X)		; 01 A0 ; Logical OR ($A0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$806C.w		; E0 6C 80 ; Compare #$806C.w with X register [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp $7FD17F.l,X		; DF 7F D1 7F ; Compare accumulator (long,X) $7FD17F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	pei ($7B.b)		; D4 7B ; Push effective indirect address ($7B.b) [Reads: Direct Page] [Writes: Stack Pointer]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	adc $7CCB.w,X		; 7D CB 7C ; Add $7CCB.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $7E.b		; C5 7E ; Compare $7E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $42, $3F		; 42 3F ; Reserved instruction
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $CDDBDF.l,X		; DF DF DB CD ; Compare accumulator (long,X) $CDDBDF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cpy $43C6.w		; CC C6 43 ; Compare $43C6.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor $38.b,S		; 43 38 ; Exclusive OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $C0FF87.l,X		; FF 87 FF C0 ; Subtract with carry (long,X) $C0FF87.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $38FF70.l,X		; FF 70 FF 38 ; Subtract with carry (long,X) $38FF70.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $DE7F8C.l,X		; FF 8C 7F DE ; Subtract with carry (long,X) $DE7F8C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $3FBF58.l,X		; 3F 58 BF 3F ; AND accumulator with memory (long,X) $3FBF58.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$C0.b]		; 87 C0 ; Store accumulator (long) [$C0.b] [Reads: Direct Page, Accumulator]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	jmp ($B83E.w,X)		; 7C 3E B8 ; Jump indirect indexed to ($B83E.w,X) [Reads: X Index] [Flow: jump]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsr ($FEF9.w,X)		; FC F9 FE ; Jump to subroutine indirect indexed ($FEF9.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	adc $39FE.w,Y		; 79 FE 39 ; Add $39FE.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FE19.w,X		; FE 19 FE ; Increment memory $FE19.w,X [Reads: X Index] [Flags: NZ]
	tsb $0DFF.w		; 0C FF 0D ; Test and set bits $0DFF.w [Reads: Accumulator] [Flags: Z]
	inc $FF0C.w,X		; FE 0C FF ; Increment memory $FF0C.w,X [Reads: X Index] [Flags: NZ]
	jsr ($7EFE.w,X)		; FC FE 7E ; Jump to subroutine indirect indexed ($7EFE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rol $0F1E.w,X		; 3E 1E 0F ; Rotate left $0F1E.w,X [Reads: X Index] [Flags: NCZ]
	asl $DF0F.w		; 0E 0F DF ; Arithmetic shift left $DF0F.w [Flags: NCZ]
	and $9E7F9F.l,X		; 3F 9F 7F 9E ; AND accumulator with memory (long,X) $9E7F9F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $987F9C.l,X		; 7F 9C 7F 98 ; Add long $987F9C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $B0FF30.l,X		; 7F 30 FF B0 ; Add long $B0FF30.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $3FFF30.l,X		; 7F 30 FF 3F ; Add long $3FFF30.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $787C7E.l,X		; 7F 7E 7C 78 ; Add long $787C7E.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $70		; F0 70 ; Branch if equal to $F0, $70 [Flow: branch]
	.db $F0, $80		; F0 80 ; Branch if equal to $F0, $80 [Flow: branch]
	adc $181F60.l,X		; 7F 60 1F 18 ; Add long $181F60.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $81.b		; 04 81 ; Test and set bits $81.b [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $01FFC0.l		; CF C0 FF 01 ; Compare accumulator (long) $01FFC0.l [Reads: Accumulator] [Flags: NCZ]
	sbc $3F3FC3.l,X		; FF C3 3F 3F ; Subtract with carry (long,X) $3F3FC3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $010700.l		; 22 00 07 01 ; Jump to subroutine long $010700.l [Writes: Stack Pointer] [Flow: call]
	cmp #$01F1.w		; C9 F1 01 ; Compare #$01F1.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $3F.b,S		; C3 3F ; Compare accumulator (stack relative) $3F.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ora $308500.l		; 0F 00 85 30 ; OR accumulator with memory (long) $308500.l [Writes: Accumulator] [Flags: NZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $6DDA.w,X		; 3D DA 6D ; AND accumulator with memory $6DDA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	stz $CA.b,X		; 74 CA ; Store zero to $CA.b,X [Reads: X Index]
	adc [$49.b],Y		; 77 49 ; Add with carry (long indexed) [$49.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $46.b,X		; 36 46 ; Rotate left $46.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cmp $FDDBDF.l,X		; DF DF DB FD ; Compare accumulator (long,X) $FDDBDF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	jmp.w [$4FDF]		; DC DF 4F ; Jump long indirect [$4FDF] [Flow: jump]
	lsr $28.b		; 46 28 ; Logical shift right $28.b [Reads: Direct Page] [Flags: NCZ]
	sbc $EDEF97.l,X		; FF 97 EF ED ; Subtract with carry (long,X) $EDEF97.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $FE45.w,X		; DE 45 FE ; Decrement memory $FE45.w,X [Reads: X Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $D4.b,X		; D5 D4 ; Compare accumulator $D4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$2F.b]		; 07 2F ; OR accumulator with memory (long) [$2F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $FEFFFF.l,X		; 9F FF FF FE ; Store accumulator (long,X) $FEFFFF.l,X [Reads: Accumulator, X Index]
	pei ($06.b)		; D4 06 ; Push effective indirect address ($06.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0300.w		; 0C 00 03 ; Test and set bits $0300.w [Reads: Accumulator] [Flags: Z]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$5F.b]		; 07 5F ; OR accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $099F.w		; 0D 9F 09 ; Logical OR $099F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $24FF09.l,X		; DF 09 FF 24 ; Compare accumulator (long,X) $24FF09.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sbc $030000.l,X		; FF 00 00 03 ; Subtract with carry (long,X) $030000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $002710.l		; 0F 10 27 00 ; OR accumulator with memory (long) $002710.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $FE		; 70 FE ; Branch if overflow set to $70, $FE [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $FF0C.w,X		; FE 0C FF ; Increment memory $FF0C.w,X [Reads: X Index] [Flags: NZ]
	jmp ($83FF.w,X)		; 7C FF 83 ; Jump indirect indexed to ($83FF.w,X) [Reads: X Index] [Flow: jump]
	asl $0300.w,X		; 1E 00 03 ; Arithmetic shift left $0300.w,X [Reads: X Index] [Flags: NCZ]
	.db $70, $F8		; 70 F8 ; Branch if overflow set to $70, $F8 [Flow: branch]
	jsr ($24FC.w,X)		; FC FC 24 ; Jump to subroutine indirect indexed ($24FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0A2F03.l		; 2F 03 2F 0A ; AND accumulator with memory (long) $0A2F03.l [Writes: Accumulator] [Flags: NZ]
	and $233F0E.l,X		; 3F 0E 3F 23 ; AND accumulator with memory (long,X) $233F0E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0A0024.l		; 0F 24 00 0A ; OR accumulator with memory (long) $0A0024.l [Writes: Accumulator] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	cpy #$F0C0.w		; C0 C0 F0 ; Compare #$F0C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	cpx #$30FC.w		; E0 FC 30 ; Compare #$30FC.w with X register [Reads: X Index] [Flags: NCZ]
	jsr ($0023.w,X)		; FC 23 00 ; Jump to subroutine indirect indexed ($0023.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx #$C035.w		; E0 35 C0 ; Compare #$C035.w with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $C6		; 30 C6 ; Branch if minus to $30, $C6 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $42, $3C		; 42 3C ; Reserved instruction
	adc $1C.b,S		; 63 1C ; Add with carry (stack relative) $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($0C.b,S),Y		; 33 0C ; AND accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $F86000.l,X		; 1F 00 60 F8 ; Logical OR long $F86000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $42C6.w		; CC C6 42 ; Compare $42C6.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $33.b,S		; 63 33 ; Add with carry (stack relative) $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $980060.l,X		; 1F 60 00 98 ; Logical OR long $980060.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy $78.b		; A4 78 ; Load $78.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	jmp ($3C76.w,X)		; 7C 76 3C ; Jump indirect indexed to ($3C76.w,X) [Reads: X Index] [Flow: jump]
	eor $253E.w,Y		; 59 3E 25 ; Exclusive OR accumulator with memory $253E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $0619.w,X		; 1E 19 06 ; Arithmetic shift left $0619.w,X [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $BA.b		; A4 BA ; Load $BA.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ror $255D.w,X		; 7E 5D 25 ; Rotate right $255D.w,X [Reads: X Index] [Flags: NCZ]
	ora $0205.w,Y		; 19 05 02 ; OR accumulator with memory $0205.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $09.b,S		; 43 09 ; Exclusive OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: NCZ]
	ora ($0C.b,S),Y		; 13 0C ; OR accumulator (stack relative indirect indexed) ($0C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $C31827.l		; 0F 27 18 C3 ; OR accumulator with memory (long) $C31827.l [Writes: Accumulator] [Flags: NZ]
	bit $FC33.w,X		; 3C 33 FC ; Test bits $FC33.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	asl $1C1C.w		; 0E 1C 1C ; Arithmetic shift left $1C1C.w [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	jsr ($A0FC.w,X)		; FC FC A0 ; Jump to subroutine indirect indexed ($A0FC.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor $90.b,S		; 43 90 ; Exclusive OR accumulator with stack relative $90.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $C8.b,S		; 43 C8 ; Exclusive OR accumulator with stack relative $C8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $13		; 30 13 ; Branch if minus to $30, $13 [Flow: branch]
	cpx $18.b		; E4 18 ; Compare $18.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp $3C.b,S		; C3 3C ; Compare accumulator (stack relative) $3C.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cpy $603F.w		; CC 3F 60 ; Compare $603F.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $3F3F.w		; 1C 3F 3F ; Test and reset bits $3F3F.w [Reads: Accumulator] [Flags: Z]
	eor $3F.b,S		; 43 3F ; Exclusive OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $431F.w		; 20 1F 43 ; Jump to subroutine at $431F.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	cpx #$082F.w		; E0 2F 08 ; Compare #$082F.w with X register [Reads: X Index] [Flags: NCZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	lda $B0FF30.l,X		; BF 30 FF B0 ; Load long $B0FF30.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($F8E0.w,X)		; FC E0 F8 ; Jump to subroutine indirect indexed ($F8E0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sed		; F8 ; Set decimal flag [Flags: D]
	jsr $30F8.w		; 20 F8 30 ; Jump to subroutine at $30F8.w [Writes: Stack Pointer] [Flow: call]
	jsr ($FC10.w,X)		; FC 10 FC ; Jump to subroutine indirect indexed ($FC10.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$2060.w		; E0 60 20 ; Compare #$2060.w with X register [Reads: X Index] [Flags: NCZ]
	bit $10.b,X		; 34 10 ; Test bits $10.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	tsb $05FF.w		; 0C FF 05 ; Test and set bits $05FF.w [Reads: Accumulator] [Flags: Z]
	inc $FF04.w,X		; FE 04 FF ; Increment memory $FF04.w,X [Reads: X Index] [Flags: NZ]
	asl $3F.b		; 06 3F ; Arithmetic shift left $3F.b [Reads: Direct Page] [Flags: NCZ]
	cop $1F.b		; 02 1F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $0F,$02		; 44 02 0F ; Move block positive $0F,$02 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora $070706.l		; 0F 06 07 07 ; OR accumulator with memory (long) $070706.l [Writes: Accumulator] [Flags: NZ]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$FF30.w		; 09 30 FF ; Logical OR #$FF30.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy #$207F.w		; A0 7F 20 ; Load #$207F.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $40FC60.l,X		; FF 60 FC 40 ; Subtract with carry (long,X) $40FC60.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	mvp $F0,$40		; 44 40 F0 ; Move block positive $F0,$40 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $E0.b		; 04 E0 ; Test and set bits $E0.b [Reads: Accumulator] [Flags: Z]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	cpx #$23E0.w		; E0 E0 23 ; Compare #$23E0.w with X register [Reads: X Index] [Flags: NCZ]
	cpy #$2FE4.w		; C0 E4 2F ; Compare #$2FE4.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $38,$38		; 44 38 38 ; Move block positive $38,$38 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($4C.b,X)		; 01 4C ; Logical OR ($4C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $148300.l		; 22 00 83 14 ; Jump to subroutine long $148300.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $E001.w,X		; BC 01 E0 ; Load Y register $E001.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $B8.b		; 00 B8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $70, $BC		; 70 BC ; Branch if overflow set to $70, $BC [Flow: branch]
	.db $90, $7C		; 90 7C ; Branch if carry clear to $90, $7C [Flow: branch]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	clv		; B8 ; Clear overflow flag [Flags: V]
	stz $90.b,X		; 74 90 ; Store zero to $90.b,X [Reads: X Index]
	rol $30FF.w,X		; 3E FF 30 ; Rotate left $30FF.w,X [Reads: X Index] [Flags: NCZ]
	sbc $0E7F19.l,X		; FF 19 7F 0E ; Subtract with carry (long,X) $0E7F19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $011F00.l,X		; 7F 00 1F 01 ; Add long $011F00.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1F3F3F.l		; 0F 3F 3F 1F ; OR accumulator with memory (long) $1F3F3F.l [Writes: Accumulator] [Flags: NZ]
	asl $0100.w		; 0E 00 01 ; Arithmetic shift left $0100.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $43.b		; 24 43 ; Test bits $43.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sbc $FB0590.l,X		; FF 90 05 FB ; Subtract with carry (long,X) $FB0590.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $B0, $F9		; B0 F9 ; Branch if carry set to $B0, $F9 [Flow: branch]
	cpx #$C0FA.w		; E0 FA C0 ; Compare #$C0FA.w with X register [Reads: X Index] [Flags: NCZ]
	eor $F0.b,S		; 43 F0 ; Exclusive OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$22E4.w		; C0 E4 22 ; Compare #$22E4.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	cpx #$00C0.w		; E0 C0 00 ; Compare #$00C0.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $013F07.l,X		; 3F 07 3F 01 ; AND accumulator with memory (long,X) $013F07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $830F03.l,X		; 1F 03 0F 83 ; Logical OR long $830F03.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $00		; F0 00 ; Branch if equal to $F0, $00 [Flow: branch]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $FC		; 70 FC ; Branch if overflow set to $70, $FC [Flow: branch]
	.db $50, $FC		; 50 FC ; Branch if overflow clear to $50, $FC [Flow: branch]
	cpy #$80F4.w		; C0 F4 80 ; Compare #$80F4.w with Y register [Reads: Y Index] [Flags: NCZ]
	pea $E000.w		; F4 00 E0 ; Push absolute address $E000.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $F0.b,S		; 03 F0 ; OR accumulator with stack relative $F0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $C0		; D0 C0 ; Branch if not equal to $D0, $C0 [Flow: branch]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0060.w		; 2E 60 00 ; Rotate left $0060.w [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp.w [$C678]		; DC 78 C6 ; Jump long indirect [$C678] [Flow: jump]
	jmp ($344A.w,X)		; 7C 4A 34 ; Jump indirect indexed to ($344A.w,X) [Reads: X Index] [Flow: jump]
	adc [$3A.b]		; 67 3A ; Add with carry (long) [$3A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $061D.w,X		; 1E 1D 06 ; Arithmetic shift left $061D.w,X [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clv		; B8 ; Clear overflow flag [Flags: V]
	jsr ($76FE.w,X)		; FC FE 76 ; Jump to subroutine indirect indexed ($76FE.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $1C001D.l,X		; 3F 1D 00 1C ; AND accumulator with memory (long,X) $1C001D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	.db $10, $BE		; 10 BE ; Branch if plus to $10, $BE [Flow: branch]
	asl $FF.b		; 06 FF ; Arithmetic shift left $FF.b [Reads: Direct Page] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $087D08.l,X		; FF 08 7D 08 ; Subtract with carry (long,X) $087D08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $3800.w		; 1C 00 38 ; Test and reset bits $3800.w [Reads: Accumulator] [Flags: Z]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	brk $38.b		; 00 38 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $38		; 10 38 ; Branch if plus to $10, $38 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $D000.w		; 20 00 D0 ; Jump to subroutine at $D000.w [Writes: Stack Pointer] [Flow: call]
	jsr $E050.w		; 20 50 E0 ; Jump to subroutine at $E050.w [Writes: Stack Pointer] [Flow: call]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $D0D0.w		; 20 D0 D0 ; Jump to subroutine at $D0D0.w [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,S),Y		; 13 02 ; OR accumulator (stack relative indirect indexed) ($02.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$11.b]		; 07 11 ; OR accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $000F13.l		; 0F 13 0F 00 ; OR accumulator with memory (long) $000F13.l [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $251B.w,Y		; 19 1B 25 ; OR accumulator with memory $251B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	cpy #$E0B0.w		; C0 B0 E0 ; Compare #$E0B0.w with Y register [Reads: Y Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $80.b,X		; 34 80 ; Test bits $80.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsr $C8B0.w		; 20 B0 C8 ; Jump to subroutine at $C8B0.w [Writes: Stack Pointer] [Flow: call]
	cpx #$DB00.w		; E0 00 DB ; Compare #$DB00.w with X register [Reads: X Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sty $7B.b,X		; 94 7B ; Store Y register $7B.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	adc $2F.b,S		; 63 2F ; Add with carry (stack relative) $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $37		; 42 37 ; Reserved instruction
	jsr $581F.w		; 20 1F 58 ; Jump to subroutine at $581F.w [Writes: Stack Pointer] [Flow: call]
	rol $7CA1.w,X		; 3E A1 7C ; Rotate left $7CA1.w,X [Reads: X Index] [Flags: NCZ]
	cpx #$B4DB.w		; E0 DB B4 ; Compare #$B4DB.w with X register [Reads: X Index] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $BE5F2F.l,X		; 5F 2F 5F BE ; Exclusive OR accumulator with memory (long,X) $BE5F2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	asl $29.b		; 06 29 ; Arithmetic shift left $29.b [Reads: Direct Page] [Flags: NCZ]
	dec $F4C6.w,X		; DE C6 F4 ; Decrement memory $F4C6.w,X [Reads: X Index] [Flags: NZ]
	.db $42, $EC		; 42 EC ; Reserved instruction
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jmp ($3E85.w,X)		; 7C 85 3E ; Jump indirect indexed to ($3E85.w,X) [Reads: X Index] [Flow: jump]
	ora [$DB.b]		; 07 DB ; OR accumulator with memory (long) [$DB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $FADE.w		; 2D DE FA ; Logical AND $FADE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pea $7DFA.w		; F4 FA 7D ; Push absolute address $7DFA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpx $F3.b		; E4 F3 ; Compare $F3.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $183C.w		; 1C 3C 18 ; Test and reset bits $183C.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	bit $0100.w		; 2C 00 01 ; Test bits $0100.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $70, $25		; 70 25 ; Branch if overflow set to $70, $25 [Flow: branch]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($1F.b,X)		; 21 1F ; Logical AND ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	ora #$0606.w		; 09 06 06 ; Logical OR #$0606.w with accumulator [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($19.b),Y		; 31 19 ; AND accumulator with memory ($19.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $002306.l		; 0F 06 23 00 ; OR accumulator with memory (long) $002306.l [Writes: Accumulator] [Flags: NZ]
	asl $A4.b		; 06 A4 ; Arithmetic shift left $A4.b [Reads: Direct Page] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	tsb $F8.b		; 04 F8 ; Test and set bits $F8.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $04.b		; A4 04 ; Load $04.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	.db $F0, $23		; F0 23 ; Branch if equal to $F0, $23 [Flow: branch]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $587CA1.l		; 2F A1 7C 58 ; AND accumulator with memory (long) $587CA1.l [Writes: Accumulator] [Flags: NZ]
	rol $1F20.w,X		; 3E 20 1F ; Rotate left $1F20.w,X [Reads: X Index] [Flags: NCZ]
	.db $42, $37		; 42 37 ; Reserved instruction
	adc $2F.b,S		; 63 2F ; Add with carry (stack relative) $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sty $7B.b,X		; 94 7B ; Store Y register $7B.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpx #$BE00.w		; E0 00 BE ; Compare #$BE00.w with X register [Reads: X Index] [Flags: NCZ]
	eor $7B5F2F.l,X		; 5F 2F 5F 7B ; Exclusive OR accumulator with memory (long,X) $7B5F2F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $DB.b,X		; B4 DB ; Load Y register $DB.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cpx #$3E85.w		; E0 85 3E ; Compare #$3E85.w with X register [Reads: X Index] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jmp ($F804.w,X)		; 7C 04 F8 ; Jump indirect indexed to ($F804.w,X) [Reads: X Index] [Flow: jump]
	.db $42, $EC		; 42 EC ; Reserved instruction
	dec $F4.b		; C6 F4 ; Decrement $F4.b [Reads: Direct Page] [Flags: NZ]
	and #$DBDE.w		; 29 DE DB ; Logical AND #$DBDE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	brk $7D.b		; 00 7D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	pea $DEFA.w		; F4 FA DE ; Push absolute address $DEFA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and $07DB.w		; 2D DB 07 ; Logical AND $07DB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $EF.b		; E4 EF ; Compare $EF.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$E0.b],Y		; 17 E0 ; OR accumulator with memory (long indexed) [$E0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $D8.b		; 00 D8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	dec $E758.w,X		; DE 58 E7 ; Decrement memory $E758.w,X [Reads: X Index] [Flags: NZ]
	ldx $AFE1.w		; AE E1 AF ; Load $AFE1.w into X register [Writes: X Index] [Flags: NZ]
	stz $DF.b,X		; 74 DF ; Store zero to $DF.b,X [Reads: X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	and $E0D77D.l		; 2F 7D D7 E0 ; AND accumulator with memory (long) $E0D77D.l [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldx $D1D7.w,Y		; BE D7 D1 ; Load X register $D1D7.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pea $25BA.w		; F4 BA 25 ; Push absolute address $25BA.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpy #$4380.w		; C0 80 43 ; Compare #$4380.w with Y register [Reads: Y Index] [Flags: NCZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$3001.w		; C0 01 30 ; Compare #$3001.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpx #$0022.w		; E0 22 00 ; Compare #$0022.w with X register [Reads: X Index] [Flags: NCZ]
	tsb $80.b		; 04 80 ; Test and set bits $80.b [Reads: Accumulator] [Flags: Z]
	cpy #$6060.w		; C0 60 60 ; Compare #$6060.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $2B		; 30 2B ; Branch if minus to $30, $2B [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1C7F00.l,X		; 1F 00 7F 1C ; Logical OR long $1C7F00.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E0FF78.l,X		; FF 78 FF E0 ; Subtract with carry (long,X) $E0FF78.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0000C0.l,X		; 7F C0 00 00 ; Add long $0000C0.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $7FBFDF.l,X		; 7F DF BF 7F ; Add long $7FBFDF.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($F0.b),Y		; 11 F0 ; OR accumulator with memory ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	dec $F78B.w		; CE 8B F7 ; Decrement $F78B.w [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $00FF7D.l,X		; FF 7D FF 00 ; Subtract with carry (long,X) $00FF7D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $8BFF.w,X		; FE FF 8B ; Increment memory $8BFF.w,X [Reads: X Index] [Flags: NZ]
	and #$0700.w		; 29 00 07 ; Logical AND #$0700.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	cpx #$7080.w		; E0 80 70 ; Compare #$7080.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$F018.w		; E0 18 F0 ; Compare #$F018.w with X register [Reads: X Index] [Flags: NCZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	.db $70, $18		; 70 18 ; Branch if overflow set to $70, $18 [Flow: branch]
	inc $FD7F.w,X		; FE 7F FD ; Increment memory $FD7F.w,X [Reads: X Index] [Flags: NZ]
	lda $F7DFFB.l,X		; BF FB DF F7 ; Load long $F7DFFB.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $DFF7EF.l		; EF EF F7 DF ; Subtract with carry (long) $DFF7EF.l [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda $FE7FFD.l,X		; BF FD 7F FE ; Load long $FE7FFD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $FBFD.w,X		; FE FD FB ; Increment memory $FBFD.w,X [Reads: X Index] [Flags: NZ]
	sbc [$EF.b],Y		; F7 EF ; Subtract with carry (long indexed) [$EF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $977FBF.l,X		; DF BF 7F 97 ; Compare accumulator (long,X) $977FBF.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	.db $F0, $2F		; F0 2F ; Branch if equal to $F0, $2F [Flow: branch]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	.db $F0, $5F		; F0 5F ; Branch if equal to $F0, $5F [Flow: branch]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	.db $F0, $2F		; F0 2F ; Branch if equal to $F0, $2F [Flow: branch]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	ora $2EB42C.l,X		; 1F 2C B4 2E ; Logical OR long $2EB42C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jmp ($4E4B.w,X)		; 7C 4B 4E ; Jump indirect indexed to ($4E4B.w,X) [Reads: X Index] [Flow: jump]
	adc ($4E.b,S),Y		; 73 4E ; Add with carry (stack relative indirect indexed) ($4E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	bit $BC52.w,X		; 3C 52 BC ; Test bits $BC52.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	nop		; EA ; No operation
	adc $CBD0.w,X		; 7D D0 CB ; Add $CBD0.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $8DBD.w		; 0C BD 8D ; Test and set bits $8DBD.w [Reads: Accumulator] [Flags: Z]
	ora $31BF.w		; 0D BF 31 ; Logical OR $31BF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $B0.b,S		; 63 B0 ; Add with carry (stack relative) $B0.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$F038.w		; E0 38 F0 ; Compare #$F038.w with X register [Reads: X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	.db $D0, $44		; D0 44 ; Branch if not equal to $D0, $44 [Flow: branch]
	jmp.w [$06E8]		; DC E8 06 ; Jump long indirect [$06E8] [Flow: jump]
	.db $F0, $3C		; F0 3C ; Branch if equal to $F0, $3C [Flow: branch]
	.db $F0, $30		; F0 30 ; Branch if equal to $F0, $30 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	jsl $60E01C.l		; 22 1C E0 60 ; Jump to subroutine long $60E01C.l [Writes: Stack Pointer] [Flow: call]
	bit $0306.w,X		; 3C 06 03 ; Test bits $0306.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	asl $1C07.w		; 0E 07 1C ; Arithmetic shift left $1C07.w [Flags: NCZ]
	asl $1C35.w		; 0E 35 1C ; Arithmetic shift left $1C35.w [Flags: NCZ]
	and $1E.b		; 25 1E ; Logical AND $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($3C.b,S),Y		; 53 3C ; XOR accumulator (stack relative indirect indexed) ($3C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$3B.b]		; 47 3B ; Exclusive OR accumulator with memory (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $0627.w,X		; 5D 27 06 ; Exclusive OR accumulator with memory $0627.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $331B.w		; 0C 1B 33 ; Test and set bits $331B.w [Reads: Accumulator] [Flags: Z]
	and #$4743.w		; 29 43 47 ; Logical AND #$4743.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $CD80FF.l		; 5C FF 80 CD ; Jump long to $CD80FF.l [Flow: jump]
	and ($BA.b,S),Y		; 33 BA ; AND accumulator (stack relative indirect indexed) ($BA.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$B4.b]		; 67 B4 ; Add with carry (long) [$B4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $1BF9.w		; 4D F9 1B ; Exclusive OR $1BF9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp [$06.b]		; C7 06 ; Compare accumulator (long) [$06.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc $B383C1.l,X		; 7F C1 83 B3 ; Add long $B383C1.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B399CC.l,X		; FF CC 99 B3 ; Subtract with carry (long,X) $B399CC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $F9.b		; E6 F9 ; Increment $F9.b [Reads: Direct Page] [Flags: NZ]
	adc $1E807C.l,X		; 7F 7C 80 1E ; Add long $1E807C.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ror $01FF.w,X		; 7E FF 01 ; Rotate right $01FF.w,X [Reads: X Index] [Flags: NCZ]
	sbc $BBE456.l,X		; FF 56 E4 BB ; Subtract with carry (long,X) $BBE456.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$5B.b]		; E7 5B ; Subtract with carry (long) [$5B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $40FE.w		; 9C FE 40 ; Store zero to $40FE.w
	cmp ($FD.b,S),Y		; D3 FD ; Compare accumulator (stack relative indirect indexed) ($FD.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	lda ($3E.b,X)		; A1 3E ; Load accumulator ($3E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $81E464.l,X		; 3F 64 E4 81 ; AND accumulator with memory (long,X) $81E464.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $F098.w		; 2D 98 F0 ; Logical AND $F098.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $ACF8.w		; 4C F8 AC ; Jump to $ACF8.w [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	dec $7C.b		; C6 7C ; Decrement $7C.b [Reads: Direct Page] [Flags: NZ]
	inc $A4.b		; E6 A4 ; Increment $A4.b [Reads: Direct Page] [Flags: NZ]
	sbc $FF58.w,Y		; F9 58 FF ; Subtract with carry $FF58.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $5F.b		; A6 5F ; Load $5F.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	clc		; 18 ; Clear carry flag [Flags: C]
	sty $A64C.w		; 8C 4C A6 ; Store Y register to $A64C.w [Reads: Y Index]
	dec $79E7.w,X		; DE E7 79 ; Decrement memory $79E7.w,X [Reads: X Index] [Flags: NZ]
	cmp $90EFF0.l,X		; DF F0 EF 90 ; Compare accumulator (long,X) $90EFF0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($DE.b,S),Y		; F3 DE ; Subtract with carry (stack relative indirect indexed) ($DE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B6.b		; E5 B6 ; Subtract $B6.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $1857.w		; 2C 57 18 ; Test bits $1857.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	eor $5D92.w,X		; 5D 92 5D ; Exclusive OR accumulator with memory $5D92.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $73.b		; 86 73 ; Store X register to $73.b [Reads: X Index]
	jmp $C1BF.w		; 4C BF C1 ; Jump to $C1BF.w [Flow: jump]
	adc $D359.w		; 6D 59 D3 ; Add $D359.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sbc [$ED.b]		; E7 ED ; Subtract with carry (long) [$ED.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3FF3.w,Y		; F9 F3 3F ; Subtract with carry $3FF3.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($0043.w,X)		; FC 43 00 ; Jump to subroutine indirect indexed ($0043.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $F8.b,S		; 43 F8 ; Exclusive OR accumulator with stack relative $F8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $30, $06		; 30 06 ; Branch if minus to $30, $06 [Flow: branch]
	.db $F0, $60		; F0 60 ; Branch if equal to $F0, $60 [Flow: branch]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy #$23FC.w		; C0 FC 23 ; Compare #$23FC.w with Y register [Reads: Y Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cop $D0.b		; 02 D0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $60		; B0 60 ; Branch if carry set to $B0, $60 [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0003.w		; 09 03 00 ; Logical OR #$0003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1B07.w		; 0D 07 1B ; Logical OR $1B07.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $220E1F.l		; 0F 1F 0E 22 ; OR accumulator with memory (long) $220E1F.l [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$1F13.w		; 09 13 1F ; Logical OR #$1F13.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $073C00.l		; 0F 00 3C 07 ; OR accumulator with memory (long) $073C00.l [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $F143.w		; 2D 43 F1 ; Logical AND $F143.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora $BBE8.w		; 0D E8 BB ; Logical OR $BBE8.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $77		; D0 77 ; Branch if not equal to $D0, $77 [Flow: branch]
	sta ($F2.b)		; 92 F2 ; Store accumulator (indirect) ($F2.b) [Reads: Direct Page, Accumulator]
	ora $76FB3C.l		; 0F 3C FB 76 ; OR accumulator with memory (long) $76FB3C.l [Writes: Accumulator] [Flags: NZ]
	inc $E7.b,X		; F6 E7 ; Increment memory $E7.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp $00228D.l		; CF 8D 22 00 ; Compare accumulator (long) $00228D.l [Reads: Accumulator] [Flags: NCZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $25.b		; 04 25 ; Test and set bits $25.b [Reads: Accumulator] [Flags: Z]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $43		; 10 43 ; Branch if plus to $10, $43 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	.db $90, $28		; 90 28 ; Branch if carry clear to $90, $28 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $25.b		; 02 25 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $2C.b		; 02 2C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $03.b		; 84 03 ; Store Y register to $03.b [Reads: Y Index]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $E4		; 10 E4 ; Branch if plus to $10, $E4 [Flow: branch]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $5F		; F0 5F ; Branch if equal to $F0, $5F [Flow: branch]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0303.w		; 09 03 03 ; Logical OR #$0303.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $130F.w		; 0C 0F 13 ; Test and set bits $130F.w [Reads: Accumulator] [Flags: Z]
	trb $3827.w		; 1C 27 38 ; Test and reset bits $3827.w [Reads: Accumulator] [Flags: Z]
	and $002330.l		; 2F 30 23 00 ; AND accumulator with memory (long) $002330.l [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $1E18.w		; 0C 18 1E ; Test and set bits $1E18.w [Reads: Accumulator] [Flags: Z]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$C0C0.w		; 09 C0 C0 ; Logical OR #$C0C0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $30, $F0		; 30 F0 ; Branch if minus to $30, $F0 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	cpx $1C.b		; E4 1C ; Compare $1C.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	pea $230C.w		; F4 0C 23 ; Push absolute address $230C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$1830.w		; C0 30 18 ; Compare #$1830.w with Y register [Reads: Y Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp $63.b,S		; C3 63 ; Compare accumulator (stack relative) $63.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cmp [$DF.b],Y		; D7 DF ; Compare accumulator (long indexed) [$DF.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ldx $7C86.w,Y		; BE 86 7C ; Load X register $7C86.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $1878.w		; AC 78 18 ; Load $1878.w into Y register [Writes: Y Index] [Flags: NZ]
	cpx #$22E0.w		; E0 E0 22 ; Compare #$22E0.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($C36D.w,X)		; 7C 6D C3 ; Jump indirect indexed to ($C36D.w,X) [Reads: X Index] [Flow: jump]
	stx $8C.b,Y		; 96 8C ; Store X register $8C.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$C000.w		; E0 00 C0 ; Compare #$C000.w with X register [Reads: X Index] [Flags: NCZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	bit $0100.w		; 2C 00 01 ; Test bits $0100.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cpy #$2580.w		; C0 80 25 ; Compare #$2580.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $163F18.l,X		; 3F 18 3F 16 ; AND accumulator with memory (long,X) $163F18.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $F11F71.l		; 2F 71 1F F1 ; AND accumulator with memory (long) $F11F71.l [Writes: Accumulator] [Flags: NZ]
	mvp $E3,$7F		; 44 7F E3 ; Move block positive $E3,$7F [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	asl $E7.b		; 06 E7 ; Arithmetic shift left $E7.b [Reads: Direct Page] [Flags: NCZ]
	adc $7A3D3F.l,X		; 7F 3F 3D 7A ; Add long $7A3D3F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($F0.b),Y		; 71 F0 ; Add with carry ($F0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $9F0BE0.l		; 22 E0 0B 9F ; Jump to subroutine long $9F0BE0.l [Writes: Stack Pointer] [Flow: call]
	sbc $E3FF89.l,X		; FF 89 FF E3 ; Subtract with carry (long,X) $E3FF89.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7C9CF7.l,X		; 7F F7 9C 7C ; Add long $7C9CF7.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda [$43.b],Y		; B7 43 ; Load accumulator (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	dec $10.b,X		; D6 10 ; Decrement memory $10.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	sbc $77.b,S		; E3 77 ; Subtract stack-relative $77.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	stz $2948.w		; 9C 48 29 ; Store zero to $2948.w
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $00,$6C		; 54 6C 00 ; Move block negative $00,$6C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsl $002310.l		; 22 10 23 00 ; Jump to subroutine long $002310.l [Writes: Stack Pointer] [Flow: call]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b)		; 12 11 ; OR accumulator with memory (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp ($8E83.w)		; 6C 83 8E ; Jump indirect to ($8E83.w) [Flow: jump]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvn $00,$6C		; 54 6C 00 ; Move block negative $00,$6C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	.db $10, $40		; 10 40 ; Branch if plus to $10, $40 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($1090.w)		; 6C 90 10 ; Jump indirect to ($1090.w) [Flow: jump]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($32.b,X)		; 01 32 ; Logical OR ($32.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $00,$6C		; 54 6C 00 ; Move block negative $00,$6C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	jsl $002910.l		; 22 10 29 00 ; Jump to subroutine long $002910.l [Writes: Stack Pointer] [Flow: call]
	cop $6C.b		; 02 6C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $30.b		; 04 30 ; Test and set bits $30.b [Reads: Accumulator] [Flags: Z]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $0003.w,X		; 7E 03 00 ; Rotate right $0003.w,X [Reads: X Index] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $25		; 10 25 ; Branch if plus to $10, $25 [Flow: branch]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $090090.l,X		; 5F 90 00 09 ; Exclusive OR accumulator with memory (long,X) $090090.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $3A1F20.l,X		; 3F 20 1F 3A ; AND accumulator with memory (long,X) $3A1F20.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $080714.l		; 0F 14 07 08 ; OR accumulator with memory (long) $080714.l [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3F.b,S		; 03 3F ; OR accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b),Y		; 11 0B ; OR accumulator with memory ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pea $F80C.w		; F4 0C F8 ; Push absolute address $F80C.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	tsb $18E0.w		; 0C E0 18 ; Test and set bits $18E0.w [Reads: Accumulator] [Flags: Z]
	cpx #$0010.w		; E0 10 00 ; Compare #$0010.w with X register [Reads: X Index] [Flags: NCZ]
	cpx #$0025.w		; E0 25 00 ; Compare #$0025.w with X register [Reads: X Index] [Flags: NCZ]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $90, $24		; 90 24 ; Branch if carry clear to $90, $24 [Flow: branch]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0500.w		; 29 00 05 ; Logical AND #$0500.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$0132.w		; E0 32 01 ; Compare #$0132.w with X register [Reads: X Index] [Flags: NCZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1F7807.l,X		; 1F 07 78 1F ; Logical OR long $1F7807.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $C567.w,Y		; F9 67 C5 ; Subtract with carry $C567.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	stx $FF.b		; 86 FF ; Store X register to $FF.b [Reads: X Index]
	sta $00FD.w		; 8D FD 00 ; Store accumulator to $00FD.w [Reads: Accumulator]
	ora [$1F.b]		; 07 1F ; OR accumulator with memory (long) [$1F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpy $80.b		; C4 80 ; Compare $80.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	.db $82, $FC, $00		; 82 FC 00 ; Branch always long to $82, $FC, $00 [Flow: branch]
	sbc $FF00FC.l,X		; FF FC 00 FF ; Subtract with carry (long,X) $FF00FC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $C0C0FF.l,X		; 3F FF C0 C0 ; AND accumulator with memory (long,X) $C0C0FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $C3FF3C.l,X		; 3F 3C FF C3 ; AND accumulator with memory (long,X) $C3FF3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $FCAF.w,X		; 7E AF FC ; Rotate right $FCAF.w,X [Reads: X Index] [Flags: NCZ]
	sbc $3F0000.l,X		; FF 00 00 3F ; Subtract with carry (long,X) $3F0000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $3F.b,S		; C3 3F ; Compare accumulator (stack relative) $3F.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	ror $0023.w,X		; 7E 23 00 ; Rotate right $0023.w,X [Reads: X Index] [Flags: NCZ]
	cpx #$802B.w		; E0 2B 80 ; Compare #$802B.w with X register [Reads: X Index] [Flags: NCZ]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F0		; 80 F0 ; Branch always to $80, $F0 [Flow: branch]
	brk $F8.b		; 00 F8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $F8		; 80 F8 ; Branch always to $80, $F8 [Flow: branch]
	cpy #$F86C.w		; C0 6C F8 ; Compare #$F86C.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $60		; 80 60 ; Branch always to $80, $60 [Flow: branch]
	.db $F0, $F8		; F0 F8 ; Branch if equal to $F0, $F8 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	stz $F0.b		; 64 F0 ; Store zero to $F0.b
	brk $2E.b		; 00 2E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $99		; F0 99 ; Branch if equal to $F0, $99 [Flow: branch]
	ror $9C.b,X		; 76 9C ; Rotate right $9C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$8E.b],Y		; 77 8E ; Add with carry (long indexed) [$8E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $CE3FCE.l,X		; 7F CE 3F CE ; Add long $CE3FCE.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F07F8C.l,X		; FF 8C 7F F0 ; Subtract with carry (long,X) $F07F8C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $7C79.w		; EE 79 7C ; Increment $7C79.w [Flags: NZ]
	ror $DE1E.w		; 6E 1E DE ; Rotate right $DE1E.w [Flags: NCZ]
	jmp ($0023.w)		; 6C 23 00 ; Jump indirect to ($0023.w) [Flow: jump]
	ora $80.b,S		; 03 80 ; OR accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $47		; 80 47 ; Branch always to $80, $47 [Flow: branch]
	jsr $03C0.w		; 20 C0 03 ; Jump to subroutine at $03C0.w [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$032F.w		; E0 2F 03 ; Compare #$032F.w with X register [Reads: X Index] [Flags: NCZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1D.b,S		; 03 1D ; OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $2D.b		; 06 2D ; Arithmetic shift left $2D.b [Reads: Direct Page] [Flags: NCZ]
	asl $78.b,X		; 16 78 ; Arithmetic shift left $78.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $364E.w		; 2D 4E 36 ; Logical AND $364E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $6B.b		; 85 6B ; Store accumulator to $6B.b [Reads: Accumulator]
	stx $6B.b		; 86 6B ; Store X register to $6B.b [Reads: X Index]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $5B2E.w		; 1C 2E 5B ; Test and reset bits $5B2E.w [Reads: Accumulator] [Flags: Z]
	eor $969C.w		; 4D 9C 96 ; Exclusive OR $969C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$3000.w		; C0 00 30 ; Compare #$3000.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy #$60B8.w		; C0 B8 60 ; Compare #$60B8.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $68.b,X		; B4 68 ; Load Y register $68.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	asl $72B4.w,X		; 1E B4 72 ; Arithmetic shift left $72B4.w,X [Reads: X Index] [Flags: NCZ]
	jmp ($D6A1.w)		; 6C A1 D6 ; Jump indirect to ($D6A1.w) [Flow: jump]
	adc ($D6.b,X)		; 61 D6 ; Add with carry ($D6.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy #$38B0.w		; C0 B0 38 ; Compare #$38B0.w with Y register [Reads: Y Index] [Flags: NCZ]
	stz $DA.b,X		; 74 DA ; Store zero to $DA.b,X [Reads: X Index]
	lda ($39.b)		; B2 39 ; Load accumulator (indirect) ($39.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$0023.w		; 69 23 00 ; Add #$0023.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora ($03.b,S),Y		; 13 03 ; OR accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1A.b,X)		; 01 1A ; Logical OR ($1A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$15.b]		; 07 15 ; OR accumulator with memory (long) [$15.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1D2A.w		; 0E 2A 1D ; Arithmetic shift left $1D2A.w [Flags: NCZ]
	ora [$09.b],Y		; 17 09 ; OR accumulator with memory (long indexed) [$09.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1D.b,X		; 16 1D ; Arithmetic shift left $1D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora [$23.b],Y		; 17 23 ; OR accumulator with memory (long indexed) [$23.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy #$7000.w		; C0 00 70 ; Compare #$7000.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $80, $58		; 80 58 ; Branch always to $80, $58 [Flow: branch]
	cpx #$70A8.w		; E0 A8 70 ; Compare #$70A8.w with X register [Reads: X Index] [Flags: NCZ]
	mvn $E8,$B8		; 54 B8 E8 ; Move block negative $E8,$B8 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $90, $00		; 90 00 ; Branch if carry clear to $90, $00 [Flow: branch]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $68		; B0 68 ; Branch if carry set to $B0, $68 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	pei ($E8.b)		; D4 E8 ; Push effective indirect address ($E8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	and $003C00.l,X		; 3F 00 3C 00 ; AND accumulator with memory (long,X) $003C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0310.w		; 20 10 03 ; Jump to subroutine at $0310.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $3F.b,S		; 23 3F ; AND accumulator with stack relative $3F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $1F172F.l		; 2F 2F 17 1F ; AND accumulator with memory (long) $1F172F.l [Writes: Accumulator] [Flags: NZ]
	jsr ($3C00.w,X)		; FC 00 3C ; Jump to subroutine indirect indexed ($3C00.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	jsr ($F403.w,X)		; FC 03 F4 ; Jump to subroutine indirect indexed ($F403.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pea $F8E8.w		; F4 E8 F8 ; Push absolute address $F8E8.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $02		; 70 02 ; Branch if overflow set to $70, $02 [Flow: branch]
	jsr ($0147.w,X)		; FC 47 01 ; Jump to subroutine indirect indexed ($0147.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	inc $0003.w,X		; FE 03 00 ; Increment memory $0003.w,X [Reads: X Index] [Flags: NZ]
	.db $70, $8C		; 70 8C ; Branch if overflow set to $70, $8C [Flow: branch]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($E4.b,X)		; 01 E4 ; Logical OR ($E4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $074300.l		; 2F 00 43 07 ; AND accumulator with memory (long) $074300.l [Writes: Accumulator] [Flags: NZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1F4304.l		; 0F 04 43 1F ; OR accumulator with memory (long) $1F4304.l [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$0707.w		; 09 07 07 ; Logical OR #$0707.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $36E00F.l		; 22 0F E0 36 ; Jump to subroutine long $36E00F.l [Writes: Stack Pointer] [Flow: call]
	ora $8B1E1F.l,X		; 1F 1F 1E 8B ; Logical OR long $8B1E1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	inc $5EA3.w,X		; FE A3 5E ; Increment memory $5EA3.w,X [Reads: X Index] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	rol $38DF.w,X		; 3E DF 38 ; Rotate left $38DF.w,X [Reads: X Index] [Flags: NCZ]
	cmp [$3D.b],Y		; D7 3D ; Compare accumulator (long indexed) [$3D.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor [$BD.b],Y		; 57 BD ; Exclusive OR accumulator with memory (long indexed) [$BD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$B5.b],Y		; 57 B5 ; Exclusive OR accumulator with memory (long indexed) [$B5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $05.b		; 84 05 ; Store Y register to $05.b [Reads: Y Index]
	lda $C1.b		; A5 C1 ; Load $C1.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $CB.b,S		; C3 CB ; Compare accumulator (stack relative) $CB.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	adc [$D1.b],Y		; 77 D1 ; Add with carry (long indexed) [$D1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$A0.b],Y		; 37 A0 ; AND accumulator with memory (long indexed) [$A0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp [$A1.b],Y		; D7 A1 ; Compare accumulator (long indexed) [$A1.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	rep #$C7		; C2 C7 ; Reset processor status bits #$C7 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sty $D34B.w		; 8C 4B D3 ; Store Y register to $D34B.w [Reads: Y Index]
	sbc $DCFF.w,X		; FD FF DC ; Subtract with carry $DCFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy $97AE.w		; CC AE 97 ; Compare $97AE.w with Y register [Reads: Y Index] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy $03.b,X		; B4 03 ; Load Y register $03.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	and $EACC6A.l,X		; 3F 6A CC EA ; AND accumulator with memory (long,X) $EACC6A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy $EB44.w		; CC 44 EB ; Compare $EB44.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldx $2E08.w		; AE 08 2E ; Load $2E08.w into X register [Writes: X Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ldx $5ED3.w		; AE D3 5E ; Load $5ED3.w into X register [Writes: X Index] [Flags: NZ]
	eor ($DE.b,S),Y		; 53 DE ; XOR accumulator (stack relative indirect indexed) ($DE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($F2.b)		; 72 F2 ; Add with carry (indirect) ($F2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $D3.b,S		; 23 D3 ; AND accumulator with stack relative $D3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$23A3.w		; 09 A3 23 ; Logical OR #$23A3.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$39.b],Y		; 77 39 ; Add with carry (long indexed) [$39.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $3F.b,X		; F6 3F ; Increment memory $3F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $F0, $2E		; F0 2E ; Branch if equal to $F0, $2E [Flow: branch]
	sbc ($43.b),Y		; F1 43 ; Subtract with carry ($43.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $43E1.w,X		; 5E E1 43 ; Logical shift right $43E1.w,X [Reads: X Index] [Flags: NCZ]
	ldx $09C1.w,Y		; BE C1 09 ; Load X register $09C1.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	sbc $EEFF.w,Y		; F9 FF EE ; Subtract with carry $EEFF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $BEDE.w,X		; DE DE BE ; Decrement memory $BEDE.w,X [Reads: X Index] [Flags: NZ]
	ldx $8040.w,Y		; BE 40 80 ; Load X register $8040.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor #$0080.w		; 49 80 00 ; Exclusive OR #$0080.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $40.b		; 04 40 ; Test and set bits $40.b [Reads: Accumulator] [Flags: Z]
	.db $80, $C0		; 80 C0 ; Branch always to $80, $C0 [Flow: branch]
	.db $80, $40		; 80 40 ; Branch always to $80, $40 [Flow: branch]
	bit $80.b		; 24 80 ; Test bits $80.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$C03C.w		; E0 3C C0 ; Compare #$C03C.w with X register [Reads: X Index] [Flags: NCZ]
	cpy #$7B96.w		; C0 96 7B ; Compare #$7B96.w with Y register [Reads: Y Index] [Flags: NCZ]
	dec $7B.b,X		; D6 7B ; Decrement memory $7B.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	adc [$3B.b]		; 67 3B ; Add with carry (long) [$3B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $173F33.l,X		; 7F 33 3F 17 ; Add long $173F33.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $030F0F.l,X		; 1F 0F 0F 03 ; Logical OR long $030F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stx $C6.b		; 86 C6 ; Store X register to $C6.b [Reads: X Index]
	eor [$76.b]		; 47 76 ; Exclusive OR accumulator with memory (long) [$76.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $0F1F.w,X		; 3E 1F 0F ; Rotate left $0F1F.w,X [Reads: X Index] [Flags: NCZ]
	ora $69.b,S		; 03 69 ; OR accumulator with stack relative $69.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $DE6B.w,X		; DE 6B DE ; Decrement memory $DE6B.w,X [Reads: X Index] [Flags: NZ]
	inc $DC.b		; E6 DC ; Increment $DC.b [Reads: Direct Page] [Flags: NZ]
	inc $FCCC.w,X		; FE CC FC ; Increment memory $FCCC.w,X [Reads: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpy #$00C0.w		; C0 C0 00 ; Compare #$00C0.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc ($63.b,X)		; 61 63 ; Add with carry ($63.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
	sep #$6E		; E2 6E
	jmp ($F0F8.w,X)		; 7C F8 F0 ; Jump indirect indexed to ($F0F8.w,X) [Reads: X Index] [Flow: jump]
	cpy #$0916.w		; C0 16 09 ; Compare #$0916.w with Y register [Reads: Y Index] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0D06.w,Y		; 19 06 0D ; OR accumulator with memory $0D06.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($16.b)		; 12 16 ; OR accumulator with memory (indirect) ($16.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $19.b,X		; 15 19 ; OR accumulator with memory $19.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0003.w		; 0D 03 00 ; Logical OR $0003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $90, $54		; 90 54 ; Branch if carry clear to $90, $54 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $50, $98		; 50 98 ; Branch if overflow clear to $50, $98 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $B0, $40		; B0 40 ; Branch if carry set to $B0, $40 [Flow: branch]
	cpy #$0024.w		; C0 24 00 ; Compare #$0024.w with Y register [Reads: Y Index] [Flags: NCZ]
	asl $5468.w		; 0E 68 54 ; Arithmetic shift left $5468.w [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $C0		; B0 C0 ; Branch if carry set to $B0, $C0 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0604.w		; 0C 04 06 ; Test and set bits $0604.w [Reads: Accumulator] [Flags: Z]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $010207.l		; 0F 07 02 01 ; OR accumulator with memory (long) $010207.l [Writes: Accumulator] [Flags: NZ]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $30.b		; 06 30 ; Arithmetic shift left $30.b [Reads: Direct Page] [Flags: NCZ]
	jsr $4060.w		; 20 60 40 ; Jump to subroutine at $4060.w [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $E0		; F0 E0 ; Branch if equal to $F0, $E0 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $0A.b,S		; 43 0A ; Exclusive OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$43.b],Y		; 17 43 ; OR accumulator with memory (long indexed) [$43.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $0A14.w		; 0C 14 0A ; Test and set bits $0A14.w [Reads: Accumulator] [Flags: Z]
	ora $090908.l		; 0F 08 09 09 ; OR accumulator with memory (long) $090908.l [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $13.b		; 14 13 ; Test and reset bits $13.b [Reads: Accumulator] [Flags: Z]
	ora ($10.b,S),Y		; 13 10 ; OR accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $43F0.w		; CE F0 43 ; Decrement $43F0.w [Flags: NZ]
	sta ($EC.b)		; 92 EC ; Store accumulator (indirect) ($EC.b) [Reads: Direct Page, Accumulator]
	ora $72.b		; 05 72 ; Logical OR $72.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $2CF2.w		; CC F2 2C ; Compare $2CF2.w with Y register [Reads: Y Index] [Flags: NCZ]
	nop		; EA ; No operation
	pei ($43.b)		; D4 43 ; Push effective indirect address ($43.b) [Reads: Direct Page] [Writes: Stack Pointer]
	pei ($B8.b)		; D4 B8 ; Push effective indirect address ($B8.b) [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b)		; 12 12 ; OR accumulator with memory (indirect) ($12.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($D2.b)		; 32 D2 ; AND accumulator with memory (indirect) ($D2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	mvp $E4,$44		; 44 44 E4 ; Move block positive $E4,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $1E0100.l		; 2F 00 01 1E ; AND accumulator with memory (long) $1E0100.l [Writes: Accumulator] [Flags: NZ]
	ora #$43.b		; 09 43 ; Logical OR #$43.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $72E00C.l,X		; 1F 0C E0 72 ; Logical OR long $72E00C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0A.b),Y		; 11 0A ; OR accumulator with memory ($0A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0D1F0E.l,X		; 1F 0E 1F 0D ; Logical OR long $0D1F0E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora #$1E.b		; 09 1E ; Logical OR #$1E.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1D1517.l,X		; 1F 17 15 1D ; Logical OR long $1D1517.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1F1B.w,Y		; 19 1B 1F ; OR accumulator with memory $1F1B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$58B8]		; DC B8 58 ; Jump long indirect [$58B8] [Flow: jump]
	.db $B0, $F1		; B0 F1 ; Branch if carry set to $B0, $F1 [Flow: branch]
	bit $8DE3.w		; 2C E3 8D ; Test bits $8DE3.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cpy $43.b		; C4 43 ; Compare $43.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cmp [$6B.b]		; C7 6B ; Compare accumulator (long) [$6B.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	pea $EB1D.w		; F4 1D EB ; Push absolute address $EB1D.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor [$4F.b]		; 47 4F ; Exclusive OR accumulator with memory (long) [$4F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $38FCFF.l,X		; FF FF FC 38 ; Subtract with carry (long,X) $38FCFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	trb $E1FF.w		; 1C FF E1 ; Test and reset bits $E1FF.w [Reads: Accumulator] [Flags: Z]
	sbc $EEF00F.l,X		; FF 0F F0 EE ; Subtract with carry (long,X) $EEF00F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	adc $04FFFA.l,X		; 7F FA FF 04 ; Add long $04FFFA.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$3D.b]		; 07 3D ; OR accumulator with memory (long) [$3D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $7E.b,S		; C3 7E ; Compare accumulator (stack relative) $7E.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $F0, $07		; F0 07 ; Branch if equal to $F0, $07 [Flow: branch]
	cpx #$0400.w		; E0 00 04 ; Compare #$0400.w with X register [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $FCB6.w,X		; 3D B6 FC ; AND accumulator with memory $FCB6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $7C.b		; 46 7C ; Logical shift right $7C.b [Reads: Direct Page] [Flags: NCZ]
	inc $DC.b		; E6 DC ; Increment $DC.b [Reads: Direct Page] [Flags: NZ]
	stz $1CE8.w		; 9C E8 1C ; Store zero to $1CE8.w
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $F0, $38		; F0 38 ; Branch if equal to $F0, $38 [Flow: branch]
	.db $F0, $F0		; F0 F0 ; Branch if equal to $F0, $F0 [Flow: branch]
	cpx #$8606.w		; E0 06 86 ; Compare #$8606.w with X register [Reads: X Index] [Flags: NCZ]
	rol $1C.b		; 26 1C ; Rotate left $1C.b [Reads: Direct Page] [Flags: NCZ]
	trb $3818.w		; 1C 18 38 ; Test and reset bits $3818.w [Reads: Accumulator] [Flags: Z]
	.db $F0, $7D		; F0 7D ; Branch if equal to $F0, $7D [Flow: branch]
	sta $7B.b,S		; 83 7B ; Store accumulator (stack relative) $7B.b,S [Reads: Stack Pointer, Accumulator]
	stx $76.b		; 86 76 ; Store X register to $76.b [Reads: X Index]
	sty $7C82.w		; 8C 82 7C ; Store Y register to $7C82.w [Reads: Y Index]
	.db $7C		; Opcode 7C overrunning bank boundry at 0B7FFE. Skipping. ; Jump indirect indexed to $7C [Reads: X Index] [Flow: jump]
	.db $D8		; Opcode D8 overrunning bank boundry at 0B7FFF. Skipping. ; Clear decimal flag [Flags: D]
.ENDS
