.BANK 12 SLOT 0
.ORG $0000

.SECTION "Bank12" FORCE

	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $2A.b		; 04 2A ; Test and set bits $2A.b [Reads: Accumulator] [Flags: Z]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0123.w,Y		; 19 23 01 ; OR accumulator with memory $0123.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor $00.b,S		; 43 00 ; Exclusive OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $19.b,X		; 15 19 ; OR accumulator with memory $19.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $000D.w,Y		; 19 0D 00 ; OR accumulator with memory $000D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $0B0519.l		; 22 19 05 0B ; Jump to subroutine long $0B0519.l [Writes: Stack Pointer] [Flow: call]
	ora [$04.b],Y		; 17 04 ; OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $25.b		; 05 25 ; Logical OR $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $0519.w,X		; 1E 19 05 ; Arithmetic shift left $0519.w,X [Reads: X Index] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $11.b,S		; 03 11 ; OR accumulator with stack relative $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b),Y		; 11 19 ; OR accumulator with memory ($19.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and [$0D.b]		; 27 0D ; AND accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $17.b		; 02 17 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $19190B.l		; 0F 0B 19 19 ; OR accumulator with memory (long) $19190B.l [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $02.b		; 25 02 ; Logical AND $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $19020B.l		; 22 0B 02 19 ; Jump to subroutine long $19020B.l [Writes: Stack Pointer] [Flow: call]
	ora $250B.w,Y		; 19 0B 25 ; OR accumulator with memory $250B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $09.b		; 02 09 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $08.b		; 02 08 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0519.w,Y		; 19 19 05 ; OR accumulator with memory $0519.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $02.b		; 25 02 ; Logical AND $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0C.b		; 09 0C ; Logical OR #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $080C.w		; 0C 0C 08 ; Test and set bits $080C.w [Reads: Accumulator] [Flags: Z]
	tsb $1917.w		; 0C 17 19 ; Test and set bits $1917.w [Reads: Accumulator] [Flags: Z]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	tsb $0406.w		; 0C 06 04 ; Test and set bits $0406.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora #$22.b		; 09 22 ; Logical OR #$22.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora ($88.b,X)		; 01 88 ; Logical OR ($88.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $CA.b		; 00 CA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	tsb $0086.w		; 0C 86 00 ; Test and set bits $0086.w [Reads: Accumulator] [Flags: Z]
	cpy $0083.w		; CC 83 00 ; Compare $0083.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $0088.w		; CC 88 00 ; Compare $0088.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc ($FF.b),Y		; F1 FF ; Subtract with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $C8.b		; 02 C8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $09620B.l		; 22 0B 62 09 ; Jump to subroutine long $09620B.l [Writes: Stack Pointer] [Flow: call]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$8E.b		; C9 8E ; Compare #$8E.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $30C8.w		; 0D C8 30 ; Logical OR $30C8.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $06, $0F		; 62 06 0F ; Push effective relative address $62, $06, $0F [Writes: Stack Pointer]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	asl $B062.w		; 0E 62 B0 ; Arithmetic shift left $B062.w [Flags: NCZ]
	and ($08.b),Y		; 31 08 ; AND accumulator with memory ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	stx $C80D.w		; 8E 0D C8 ; Store X register to $C80D.w [Reads: X Index]
	ora $001A.w,Y		; 19 1A 00 ; OR accumulator with memory $001A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $63.b		; 04 63 ; Test and set bits $63.b [Reads: Accumulator] [Flags: Z]
	sta $391B.w		; 8D 1B 39 ; Store accumulator to $391B.w [Reads: Accumulator]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $8E73.w		; 1C 73 8E ; Test and reset bits $8E73.w [Reads: Accumulator] [Flags: Z]
	.db $62, $CE, $99		; 62 CE 99 ; Push effective relative address $62, $CE, $99 [Writes: Stack Pointer]
	and [$09.b]		; 27 09 ; AND accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$E5.b]		; 07 E5 ; OR accumulator with memory (long) [$E5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	cpy #$91.b		; C0 91 ; Compare #$91.b with Y register [Reads: Y Index] [Flags: NCZ]
	stx $2937.w		; 8E 37 29 ; Store X register to $2937.w [Reads: X Index]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	stx $920D.w		; 8E 0D 92 ; Store X register to $920D.w [Reads: X Index]
	lda ($D2.b)		; B2 D2 ; Load accumulator (indirect) ($D2.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pea $62D3.w		; F4 D3 62 ; Push absolute address $62D3.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	sta ($08.b,S),Y		; 93 08 ; Store accumulator (stack relative indirect indexed) ($08.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $A1.b,S		; 03 A1 ; OR accumulator with stack relative $A1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
	rep #$AA		; C2 AA
	stx $C9.b,Y		; 96 C9 ; Store X register $C9.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ldx $65.b		; A6 65 ; Load $65.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cpx #$30.b		; E0 30 ; Compare #$30.b with X register [Reads: X Index] [Flags: NCZ]
	stx $4A.b,Y		; 96 4A ; Store X register $4A.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldy $E0AA.w		; AC AA E0 ; Load $E0AA.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $239D.w		; ED 9D 23 ; Subtract $239D.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc ($E2.b,X)		; E1 E2 ; Subtract with carry ($E2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $E409.w		; EE 09 E4 ; Increment $E409.w [Flags: NZ]
	lda ($02.b),Y		; B1 02 ; Load accumulator ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,S		; 03 97 ; OR accumulator with stack relative $97.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$7ACA.w		; C9 CA 7A ; Compare #$7ACA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	adc ($22.b,S),Y		; 73 22 ; Add with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $E8.b,S		; 23 E8 ; AND accumulator with stack relative $E8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc #$3023.w		; E9 23 30 ; Subtract #$3023.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	asl $EBEA.w		; 0E EA EB ; Arithmetic shift left $EBEA.w [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $2222.w,Y		; 99 22 22 ; Store accumulator to $2222.w,Y [Reads: Y Index, Accumulator]
	tsb $26.b		; 04 26 ; Test and set bits $26.b [Reads: Accumulator] [Flags: Z]
	sbc $244973.l		; EF 73 49 24 ; Subtract with carry (long) $244973.l [Writes: Accumulator] [Flags: NCVZ]
	adc ($CC.b)		; 72 CC ; Add with carry (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($F1.b),Y		; 11 F1 ; OR accumulator with memory ($F1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sbc ($F4.b,S),Y		; F3 F4 ; Subtract with carry (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $E9.b		; 24 E9 ; Test bits $E9.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $3E.b,S		; 03 3E ; OR accumulator with stack relative $3E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$5A.b],Y		; 77 5A ; Add with carry (long indexed) [$5A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($62.b)		; 12 62 ; OR accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $03.b,X		; F6 03 ; Increment memory $03.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	stz $FA9D.w		; 9C 9D FA ; Store zero to $FA9D.w
	lda [$24.b]		; A7 24 ; Load accumulator (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc #$FC09.w		; E9 09 FC ; Subtract #$FC09.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and ($0D.b)		; 32 0D ; AND accumulator with memory (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc #$A7FD.w		; 69 FD A7 ; Add #$A7FD.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $089F9E.l,X		; 9F 9E 9F 08 ; Store accumulator (long,X) $089F9E.l,X [Reads: Accumulator, X Index]
	and $E9.b		; 25 E9 ; Logical AND $E9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$4002.w		; 09 02 40 ; Logical OR #$4002.w with accumulator [Writes: Accumulator] [Flags: NZ]
	stz $0403.w		; 9C 03 04 ; Store zero to $0403.w
	cmp ($05.b,X)		; C1 05 ; Compare accumulator ($05.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rol $2274.w,X		; 3E 74 22 ; Rotate left $2274.w,X [Reads: X Index] [Flags: NCZ]
	sbc #$C002.w		; E9 02 C0 ; Subtract #$C002.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp ($32.b,X)		; C1 32 ; Compare accumulator ($32.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $62, $07, $06		; 62 07 06 ; Push effective relative address $62, $07, $06 [Writes: Stack Pointer]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $E922BA.l,X		; 1F BA 22 E9 ; Logical OR long $E922BA.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	cmp $53.b		; C5 53 ; Compare $53.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $DA46.w,X		; 3D 46 DA ; AND accumulator with memory $DA46.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $62, $1F, $61		; 62 1F 61 ; Push effective relative address $62, $1F, $61 [Writes: Stack Pointer]
	.db $62, $74, $99		; 62 74 99 ; Push effective relative address $62, $74, $99 [Writes: Stack Pointer]
	asl $5655.w,X		; 1E 55 56 ; Arithmetic shift left $5655.w,X [Reads: X Index] [Flags: NCZ]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $4E.b		; 46 4E ; Logical shift right $4E.b [Reads: Direct Page] [Flags: NCZ]
	lda ($4C.b,X)		; A1 4C ; Load accumulator ($4C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $0B, $00		; 62 0B 00 ; Push effective relative address $62, $0B, $00 [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $62, $0E, $05		; 62 0E 05 ; Push effective relative address $62, $0E, $05 [Writes: Stack Pointer]
	asl $4E0D.w		; 0E 0D 4E ; Arithmetic shift left $4E0D.w [Flags: NCZ]
	lda ($4C.b,X)		; A1 4C ; Load accumulator ($4C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $0083.w		; 4E 83 00 ; Logical shift right $0083.w [Flags: NCZ]
	cpy $A700.w		; CC 00 A7 ; Compare $A700.w with Y register [Reads: Y Index] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	wai		; CB ; Wait for interrupt
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	sbc ($FF.b),Y		; F1 FF ; Subtract with carry ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora [$17.b]		; 07 17 ; OR accumulator with memory (long) [$17.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $4317.w,Y		; 19 17 43 ; OR accumulator with memory $4317.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$19.b],Y		; 17 19 ; OR accumulator with memory (long indexed) [$19.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $19.b		; 24 19 ; Test bits $19.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1702.w,Y		; 19 02 17 ; OR accumulator with memory $1702.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $19.b		; 45 19 ; Exclusive OR $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b],Y		; 17 06 ; OR accumulator with memory (long indexed) [$06.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$19.b],Y		; 17 19 ; OR accumulator with memory (long indexed) [$19.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $19.b,X		; 15 19 ; OR accumulator with memory $19.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $19.b,S		; 43 19 ; Exclusive OR accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora $0505.w,Y		; 19 05 05 ; OR accumulator with memory $0505.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: NCZ]
	ora $0623.w,Y		; 19 23 06 ; OR accumulator with memory $0623.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $008506.l		; 22 06 85 00 ; Jump to subroutine long $008506.l [Writes: Stack Pointer] [Flow: call]
	rol $0601.w		; 2E 01 06 ; Rotate left $0601.w [Flags: NCZ]
	ora #$0624.w		; 09 24 06 ; Logical OR #$0624.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $17.b,S		; 43 17 ; Exclusive OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0083.w,Y		; 19 83 00 ; OR accumulator with memory $0083.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $050519.l		; 22 19 05 05 ; Jump to subroutine long $050519.l [Writes: Stack Pointer] [Flow: call]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0001.w,Y		; 19 01 00 ; OR accumulator with memory $0001.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	bit $01.b,X		; 34 01 ; Test bits $01.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ora #$8307.w		; 09 07 83 ; Logical OR #$8307.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $19.b		; 05 19 ; Logical OR $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0C2B.w,Y		; 19 2B 0C ; OR accumulator with memory $0C2B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $070005.l		; 22 05 00 07 ; Jump to subroutine long $070005.l [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $3C.b		; 05 3C ; Logical OR $3C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $072E.w,Y		; 19 2E 07 ; OR accumulator with memory $072E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $060C.w		; 2D 0C 06 ; Logical AND $060C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0404.w,Y		; 19 04 04 ; OR accumulator with memory $0404.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	tsb $190F.w		; 0C 0F 19 ; Test and set bits $190F.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $040C.w		; 0C 0C 04 ; Test and set bits $040C.w [Reads: Accumulator] [Flags: Z]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $75E50C.l,X		; FF 0C E5 75 ; Subtract with carry (long,X) $75E50C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $A0, $7F		; 82 A0 7F ; Branch always long to $82, $A0, $7F [Flow: branch]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda ($95.b,X)		; A1 95 ; Load accumulator ($95.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$A3.b		; A2 A3 ; Load #$A3.b into X register [Writes: X Index] [Flags: NZ]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $62.b,S		; A3 62 ; Load accumulator (stack relative) $62.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $07.b		; A5 07 ; Load $07.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $75.b		; E5 75 ; Subtract $75.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$9CA3.w		; A9 A3 9C ; Load #$9CA3.w into accumulator [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $B5.b,S		; A3 B5 ; Load accumulator (stack relative) $B5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $81.b		; 06 81 ; Arithmetic shift left $81.b [Reads: Direct Page] [Flags: NCZ]
	lda [$E5.b]		; A7 E5 ; Load accumulator (long) [$E5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $FD.b,X		; 75 FD ; Add $FD.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $8023AA.l,X		; FF AA 23 80 ; Subtract with carry (long,X) $8023AA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	mvp $80,$AB		; 44 AB 80 ; Move block positive $80,$AB [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora [$AC.b]		; 07 AC ; OR accumulator with memory (long) [$AC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $75E5.w		; AD E5 75 ; Load $75E5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $AE74.w,X		; FD 74 AE ; Subtract with carry $AE74.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and $80.b,S		; 23 80 ; AND accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $2D.b		; 04 2D ; Test and set bits $2D.b [Reads: Accumulator] [Flags: Z]
	sta $94.b,X		; 95 94 ; Store accumulator to $94.b,X [Reads: Accumulator, X Index]
	.db $80, $AD		; 80 AD ; Branch always to $80, $AD [Flow: branch]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $6A6A02.l		; 2F 02 6A 6A ; AND accumulator with memory (long) $6A6A02.l [Writes: Accumulator] [Flags: NZ]
	bit $23.b		; 24 23 ; Test bits $23.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $80, $0C		; 80 0C ; Branch always to $80, $0C [Flow: branch]
	cmp ($0C.b),Y		; D1 0C ; Compare accumulator ($0C.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora $B5AF.w		; 0D AF B5 ; Logical OR $B5AF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $75E5.w		; AD E5 75 ; Load $75E5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $B0, $B1		; B0 B1 ; Branch if carry set to $B0, $B1 [Flow: branch]
	stz $2C.b,X		; 74 2C ; Store zero to $2C.b,X [Reads: X Index]
	jmp ($8023.w)		; 6C 23 80 ; Jump indirect to ($8023.w) [Flow: jump]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $B3B210.l		; 0F 10 B2 B3 ; OR accumulator with memory (long) $B3B210.l [Writes: Accumulator] [Flags: NZ]
	lda $3CE5.w		; AD E5 3C ; Load $3CE5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $AA1EB4.l,X		; 1F B4 1E AA ; Logical OR long $AA1EB4.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	bit $02.b,X		; 34 02 ; Test bits $02.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $B554.w		; 2D 54 B5 ; Logical AND $B554.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $AF02.w,X		; 3D 02 AF ; AND accumulator with memory $AF02.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $B7.b,Y		; B6 B7 ; Load X register $B7.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and $E503.w,Y		; 39 03 E5 ; AND accumulator with memory $E503.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $AF.b		; E5 AF ; Subtract $AF.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $2B.b		; 45 2B ; Exclusive OR $2B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	jsl $4A00E5.l		; 22 E5 00 4A ; Jump to subroutine long $4A00E5.l [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $80, $2F		; 80 2F ; Branch always to $80, $2F [Flow: branch]
	rol $00.b		; 26 00 ; Rotate left $00.b [Reads: Direct Page] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	rol $002C.w		; 2E 2C 00 ; Rotate left $002C.w [Flags: NCZ]
	rol $4062.w,X		; 3E 62 40 ; Rotate left $4062.w,X [Reads: X Index] [Flags: NCZ]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$0643.w		; 29 43 06 ; Logical AND #$0643.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $4847.w,Y		; B9 47 48 ; Load $4847.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $BA, $B7		; 62 BA B7 ; Push effective relative address $62, $BA, $B7 [Writes: Stack Pointer]
	sty $63.b,X		; 94 63 ; Store Y register $63.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	eor $62.b		; 45 62 ; Exclusive OR $62.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $E0.b		; 46 E0 ; Logical shift right $E0.b [Reads: Direct Page] [Flags: NCZ]
	jsl $BB4946.l		; 22 46 49 BB ; Jump to subroutine long $BB4946.l [Writes: Stack Pointer] [Flow: call]
	lda ($4B.b,X)		; A1 4B ; Load accumulator ($4B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and ($1D.b,S),Y		; 33 1D ; AND accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($C5.b),Y		; 31 C5 ; AND accumulator with memory ($C5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($3D.b,S),Y		; 53 3D ; XOR accumulator (stack relative indirect indexed) ($3D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $A7A7.w,X		; 3D A7 A7 ; AND accumulator with memory $A7A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($3D.b,S),Y		; 53 3D ; XOR accumulator (stack relative indirect indexed) ($3D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $42A5.w,X		; 3E A5 42 ; Rotate left $42A5.w,X [Reads: X Index] [Flags: NCZ]
	eor $DA46DB.l		; 4F DB 46 DA ; Exclusive OR accumulator with memory (long) $DA46DB.l [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	sbc $05192B.l,X		; FF 2B 19 05 ; Subtract with carry (long,X) $05192B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$03.b],Y		; 17 03 ; OR accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $2419.w,Y		; 19 19 24 ; OR accumulator with memory $2419.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b],Y		; 17 01 ; OR accumulator with memory (long indexed) [$01.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $2319.w,Y		; 19 19 23 ; OR accumulator with memory $2319.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$02.b],Y		; 17 02 ; OR accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0605.w,Y		; 19 05 06 ; OR accumulator with memory $0605.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1900.w,Y		; 19 00 19 ; OR accumulator with memory $1900.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $2207.w,Y		; 19 07 22 ; OR accumulator with memory $2207.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	ora $0908.w,Y		; 19 08 09 ; OR accumulator with memory $0908.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $19.b,S		; 43 19 ; Exclusive OR accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: NCZ]
	jsl $190206.l		; 22 06 02 19 ; Jump to subroutine long $190206.l [Writes: Stack Pointer] [Flow: call]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $19040C.l		; 22 0C 04 19 ; Jump to subroutine long $19040C.l [Writes: Stack Pointer] [Flow: call]
	ora [$06.b],Y		; 17 06 ; OR accumulator with memory (long indexed) [$06.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$17.b],Y		; 17 17 ; OR accumulator with memory (long indexed) [$17.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $191006.l		; 22 06 10 19 ; Jump to subroutine long $191006.l [Writes: Stack Pointer] [Flow: call]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: NCZ]
	tsb $1901.w		; 0C 01 19 ; Test and set bits $1901.w [Reads: Accumulator] [Flags: Z]
	ora $1706.w,Y		; 19 06 17 ; OR accumulator with memory $1706.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$19.b],Y		; 17 19 ; OR accumulator with memory (long indexed) [$19.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: NCZ]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4D.b		; 00 4D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0319.w,Y		; 19 19 03 ; OR accumulator with memory $0319.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $2B.b,S		; 03 2B ; OR accumulator with stack relative $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $1903.w		; 0C 03 19 ; Test and set bits $1903.w [Reads: Accumulator] [Flags: Z]
	tsb $0606.w		; 0C 06 06 ; Test and set bits $0606.w [Reads: Accumulator] [Flags: Z]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb DMALEN0B.w		; 0C 07 43 ; Test and set bits DMALEN0B.w [Reads: Accumulator] [Flags: Z]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $0C0607.l		; 22 07 06 0C ; Jump to subroutine long $0C0607.l [Writes: Stack Pointer] [Flow: call]
	tsb $0707.w		; 0C 07 07 ; Test and set bits $0707.w [Reads: Accumulator] [Flags: Z]
	ora ($05.b),Y		; 11 05 ; OR accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $2C.b		; 05 2C ; Logical OR $2C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($29.b),Y		; 11 29 ; OR accumulator with memory ($29.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $190C.w		; 0C 0C 19 ; Test and set bits $190C.w [Reads: Accumulator] [Flags: Z]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0C27.w,Y		; 19 27 0C ; OR accumulator with memory $0C27.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$11.b]		; 07 11 ; OR accumulator with memory (long) [$11.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $0C.b		; 24 0C ; Test bits $0C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0C0E.w		; 0C 0E 0C ; Test and set bits $0C0E.w [Reads: Accumulator] [Flags: Z]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $0819.w,Y		; 19 19 08 ; OR accumulator with memory $0819.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0604.w		; 0C 04 06 ; Test and set bits $0604.w [Reads: Accumulator] [Flags: Z]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cpx #$0B.b		; E0 0B ; Compare #$0B.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0005.w		; 0C 05 00 ; Test and set bits $0005.w [Reads: Accumulator] [Flags: Z]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $A7.b		; 00 A7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $BC.b		; 64 BC ; Store zero to $BC.b
	.db $62, $BE, $62		; 62 BE 62 ; Push effective relative address $62, $BE, $62 [Writes: Stack Pointer]
	cpy #$05.b		; C0 05 ; Compare #$05.b with Y register [Reads: Y Index] [Flags: NCZ]
	sbc [$32.b]		; E7 32 ; Subtract with carry (long) [$32.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp #$A7E5.w		; C9 E5 A7 ; Compare #$A7E5.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	cmp $44.b,S		; C3 44 ; Compare accumulator (stack relative) $44.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	lda $98.b,X		; B5 98 ; Load $98.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($C4.b,X)		; 01 C4 ; Logical OR ($C4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $0C9822.l,X		; BF 22 98 0C ; Load long $0C9822.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and ($C9.b)		; 32 C9 ; AND accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $ABC5.w		; AD C5 AB ; Load $ABC5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $C6		; 80 C6 ; Branch always to $80, $C6 [Flow: branch]
	ora $C8C7.w,X		; 1D C7 C8 ; OR accumulator with memory $C8C7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $0A8022.l,X		; 3F 22 80 0A ; AND accumulator with memory (long,X) $0A8022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$4E71.w		; C9 71 4E ; Compare #$4E71.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	rol $AD.b		; 26 AD ; Rotate left $AD.b [Reads: Direct Page] [Flags: NCZ]
	lda $CA80.w		; AD 80 CA ; Load $CA80.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $78.b,X		; 95 78 ; Store accumulator to $78.b,X [Reads: Accumulator, X Index]
	wai		; CB ; Wait for interrupt
	jsl $CC0280.l		; 22 80 02 CC ; Jump to subroutine long $CC0280.l [Writes: Stack Pointer] [Flow: call]
	trb $62CD.w		; 1C CD 62 ; Test and reset bits $62CD.w [Reads: Accumulator] [Flags: Z]
	lsr $AD04.w,X		; 5E 04 AD ; Logical shift right $AD04.w,X [Reads: X Index] [Flags: NCZ]
	lda $80.b,X		; B5 80 ; Load $80.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $220D.w		; 0C 0D 22 ; Test and set bits $220D.w [Reads: Accumulator] [Flags: Z]
	.db $80, $11		; 80 11 ; Branch always to $80, $11 [Flow: branch]
	cpy $1DA5.w		; CC A5 1D ; Compare $1DA5.w with Y register [Reads: Y Index] [Flags: NCZ]
	and ($6A.b)		; 32 6A ; AND accumulator with memory (indirect) ($6A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec $8B66.w		; CE 66 8B ; Decrement $8B66.w [Flags: NZ]
	lda $87B3.w		; AD B3 87 ; Load $87B3.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $80CF10.l		; 0F 10 CF 80 ; OR accumulator with memory (long) $80CF10.l [Writes: Accumulator] [Flags: NZ]
	cpy $A5E6.w		; CC E6 A5 ; Compare $A5E6.w with Y register [Reads: Y Index] [Flags: NCZ]
	jsl $D0081D.l		; 22 1D 08 D0 ; Jump to subroutine long $D0081D.l [Writes: Stack Pointer] [Flow: call]
	ror $ADAB.w		; 6E AB AD ; Rotate right $ADAB.w [Flags: NCZ]
	lda $DF1D.w		; AD 1D DF ; Load $DF1D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$431D.w		; 29 1D 43 ; Logical AND #$431D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	stx $058F.w		; 8E 8F 05 ; Store X register to $058F.w [Reads: X Index]
	ora $D11D.w,X		; 1D 1D D1 ; OR accumulator with memory $D11D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($C9.b)		; D2 C9 ; Compare accumulator (indirect) ($C9.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp #$7A2B.w		; C9 2B 7A ; Compare #$7A2B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $D3.b,S		; 03 D3 ; OR accumulator with stack relative $D3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($A4A4.w,X)		; 7C A4 A4 ; Jump indirect indexed to ($A4A4.w,X) [Reads: X Index] [Flow: jump]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $E5.b,S		; A3 E5 ; Load accumulator (stack relative) $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $4380.w,X		; 7E 80 43 ; Rotate right $4380.w,X [Reads: X Index] [Flags: NCZ]
	.db $80, $7E		; 80 7E ; Branch always to $80, $7E [Flow: branch]
	jsl $7E0680.l		; 22 80 06 7E ; Jump to subroutine long $7E0680.l [Writes: Stack Pointer] [Flow: call]
	ror $3680.w,X		; 7E 80 36 ; Rotate right $3680.w,X [Reads: X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	rol $03.b		; 26 03 ; Rotate left $03.b [Reads: Direct Page] [Flags: NCZ]
	eor $E5.b,S		; 43 E5 ; Exclusive OR accumulator with stack relative $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0A.b		; E5 0A ; Subtract $0A.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and #$082C.w		; 29 2C 08 ; Logical AND #$082C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $81		; 80 81 ; Branch always to $80, $81 [Flow: branch]
	pei ($49.b)		; D4 49 ; Push effective indirect address ($49.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sty $D5.b		; 84 D5 ; Store Y register to $D5.b [Reads: Y Index]
	sta $25.b,S		; 83 25 ; Store accumulator (stack relative) $25.b,S [Reads: Stack Pointer, Accumulator]
	sty $06.b		; 84 06 ; Store Y register to $06.b [Reads: Y Index]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	stz $D6.b,X		; 74 D6 ; Store zero to $D6.b,X [Reads: X Index]
	adc ($49.b,S),Y		; 73 49 ; Add with carry (stack relative indirect indexed) ($49.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $62, $88, $01		; 62 88 01 ; Push effective relative address $62, $88, $01 [Writes: Stack Pointer]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	eor $5B.b,S		; 43 5B ; Exclusive OR accumulator with stack relative $5B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $8D0E.w		; 8C 0E 8D ; Store Y register to $8D0E.w [Reads: Y Index]
	and ($34.b,S),Y		; 33 34 ; AND accumulator (stack relative indirect indexed) ($34.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp [$D8.b],Y		; D7 D8 ; Compare accumulator (long indexed) [$D8.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc [$5A.b],Y		; 77 5A ; Add with carry (long indexed) [$5A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($3D.b,S),Y		; 53 3D ; XOR accumulator (stack relative indirect indexed) ($3D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $1ECC.w,X		; 1D CC 1E ; OR accumulator with memory $1ECC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $91, $14		; 62 91 14 ; Push effective relative address $62, $91, $14 [Writes: Stack Pointer]
	stx $1E6A.w		; 8E 6A 1E ; Store X register to $1E6A.w [Reads: X Index]
	and ($C9.b)		; 32 C9 ; AND accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $62, $1D, $1D		; 62 1D 1D ; Push effective relative address $62, $1D, $1D [Writes: Stack Pointer]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lsr $5394.w,X		; 5E 94 53 ; Logical shift right $5394.w,X [Reads: X Index] [Flags: NCZ]
	ora $32FB.w,X		; 1D FB 32 ; OR accumulator with memory $32FB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$03FF.w		; C9 FF 03 ; Compare #$03FF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0B4302.l		; 0F 02 43 0B ; OR accumulator with memory (long) $0B4302.l [Writes: Accumulator] [Flags: NZ]
	ora $060B.w,Y		; 19 0B 06 ; OR accumulator with memory $060B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $19.b		; 25 19 ; Logical AND $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $000419.l		; 0F 19 04 00 ; OR accumulator with memory (long) $000419.l [Writes: Accumulator] [Flags: NZ]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0207.w,Y		; 19 07 02 ; OR accumulator with memory $0207.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $19.b		; 24 19 ; Test bits $19.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F0F.w,Y		; 19 0F 0F ; OR accumulator with memory $0F0F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $2403.w,Y		; 19 03 24 ; OR accumulator with memory $2403.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1000.w,Y		; 19 00 10 ; OR accumulator with memory $1000.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $192201.l		; 22 01 22 19 ; Jump to subroutine long $192201.l [Writes: Stack Pointer] [Flow: call]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $1903.w,Y		; 19 03 19 ; OR accumulator with memory $1903.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1001.w,Y		; 19 01 10 ; OR accumulator with memory $1001.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $1924.w		; 0C 24 19 ; Test and set bits $1924.w [Reads: Accumulator] [Flags: Z]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1000.w,Y		; 19 00 10 ; OR accumulator with memory $1000.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $19.b		; 26 19 ; Rotate left $19.b [Reads: Direct Page] [Flags: NCZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($1A.b,X)		; 01 1A ; Logical OR ($1A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $19.b		; 24 19 ; Test bits $19.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $070201.l		; 22 01 02 07 ; Jump to subroutine long $070201.l [Writes: Stack Pointer] [Flow: call]
	ora [$1A.b]		; 07 1A ; OR accumulator with memory (long) [$1A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $83		; 10 83 ; Branch if plus to $10, $83 [Flow: branch]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0119.w,Y		; 19 19 01 ; OR accumulator with memory $0119.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	ora $0403.w,Y		; 19 03 04 ; OR accumulator with memory $0403.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $86.b		; 02 86 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $100619.l		; 22 19 06 10 ; Jump to subroutine long $100619.l [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $1A.b		; 04 1A ; Test and set bits $1A.b [Reads: Accumulator] [Flags: Z]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $010019.l		; 22 19 00 01 ; Jump to subroutine long $010019.l [Writes: Stack Pointer] [Flow: call]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $0104.w,Y		; 19 04 01 ; OR accumulator with memory $0104.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$84.b]		; 07 84 ; OR accumulator with memory (long) [$84.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $B1.b		; 00 B1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	stx $85.b		; 86 85 ; Store X register to $85.b [Reads: X Index]
	brk $CC.b		; 00 CC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1A.b		; 05 1A ; Logical OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0D0E.w		; 0E 0E 0D ; Arithmetic shift left $0D0E.w [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $0123.w		; 0D 23 01 ; Logical OR $0123.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $0B0301.l		; 22 01 03 0B ; Jump to subroutine long $0B0301.l [Writes: Stack Pointer] [Flow: call]
	ora $0104.w,Y		; 19 04 01 ; OR accumulator with memory $0104.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $935213.l,X		; FF 13 52 93 ; Subtract with carry (long,X) $935213.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($4F.b,X)		; 21 4F ; Logical AND ($4F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr $5ED9.w,X		; 5E D9 5E ; Logical shift right $5ED9.w,X [Reads: X Index] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	sta ($91.b,S),Y		; 93 91 ; Store accumulator (stack relative indirect indexed) ($91.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	and $D9C6.w,X		; 3D C6 D9 ; AND accumulator with memory $D9C6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $2E.b		; A5 2E ; Load $2E.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jmp $4FAA93.l		; 5C 93 AA 4F ; Jump long to $4FAA93.l [Flow: jump]
	adc $DB.b,S		; 63 DB ; Add with carry (stack relative) $DB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cmp $C8E04A.l,X		; DF 4A E0 C8 ; Compare accumulator (long,X) $C8E04A.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	ora $E12E.w,X		; 1D 2E E1 ; OR accumulator with memory $E12E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$64		; E2 64
	adc $0FE364.l		; 6F 64 E3 0F ; Add with carry (long) $0FE364.l [Writes: Accumulator] [Flags: NCVZ]
	asl $E8.b		; 06 E8 ; Arithmetic shift left $E8.b [Reads: Direct Page] [Flags: NCZ]
	lda $EAE9AC.l		; AF AC E9 EA ; Load long $EAE9AC.l into accumulator [Writes: Accumulator] [Flags: NZ]
	rol $ECEB.w		; 2E EB EC ; Rotate left $ECEB.w [Flags: NCZ]
	eor #$ED.b		; 49 ED ; Exclusive OR #$ED.b with accumulator [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	inc $E8EF.w		; EE EF E8 ; Increment $E8EF.w [Flags: NZ]
	cpy $0622.w		; CC 22 06 ; Compare $0622.w with Y register [Reads: Y Index] [Flags: NCZ]
	tsb $F0E8.w		; 0C E8 F0 ; Test and set bits $F0E8.w [Reads: Accumulator] [Flags: Z]
	sbc ($08.b),Y		; F1 08 ; Subtract with carry ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($5E.b)		; F2 5E ; Subtract with carry (indirect) ($5E.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($4F.b,S),Y		; F3 4F ; Subtract with carry (stack relative indirect indexed) ($4F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx $E5.b		; E4 E5 ; Compare $E5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	pea $F5C1.w		; F4 C1 F5 ; Push absolute address $F5C1.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	eor $F5.b,S		; 43 F5 ; Exclusive OR accumulator with stack relative $F5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $06.b,X		; F6 06 ; Increment memory $06.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc [$8A.b],Y		; F7 8A ; Subtract with carry (long indexed) [$8A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $03.b		; E4 03 ; Compare $03.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $4F1D.w,Y		; 99 1D 4F ; Store accumulator to $4F1D.w,Y [Reads: Y Index, Accumulator]
	.db $62, $F8, $01		; 62 F8 01 ; Push effective relative address $62, $F8, $01 [Writes: Stack Pointer]
	cpy $FB.b		; C4 FB ; Compare $FB.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	eor $FC.b,S		; 43 FC ; Exclusive OR accumulator with stack relative $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $F706.w,X		; FD 06 F7 ; Subtract with carry $F706.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $E4DB.w,X		; FE DB E4 ; Increment memory $E4DB.w,X [Reads: X Index] [Flags: NZ]
	sbc $8300A0.l,X		; FF A0 00 83 ; Subtract with carry (long,X) $8300A0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	trb $06.b		; 14 06 ; Test and reset bits $06.b [Reads: Accumulator] [Flags: Z]
	jsr ($E603.w,X)		; FC 03 E6 ; Jump to subroutine indirect indexed ($E603.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jsr $0173.w		; 20 73 01 ; Jump to subroutine at $0173.w [Writes: Stack Pointer] [Flow: call]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	bit $83.b		; 24 83 ; Test bits $83.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $A6.b		; 05 A6 ; Logical OR $A6.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $52.b		; 84 52 ; Store Y register to $52.b [Reads: Y Index]
	sta ($62.b,S),Y		; 93 62 ; Store accumulator (stack relative indirect indexed) ($62.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora ($12.b,X)		; 01 12 ; Logical OR ($12.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpy $0206.w		; CC 06 02 ; Compare $0206.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $DDCCE8.l		; EF E8 CC DD ; Subtract with carry (long) $DDCCE8.l [Writes: Accumulator] [Flags: NCVZ]
	dec $8A0D.w,X		; DE 0D 8A ; Decrement memory $8A0D.w,X [Reads: X Index] [Flags: NZ]
	sbc $93.b,S		; E3 93 ; Subtract stack-relative $93.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $82, $F4, $C1		; 82 F4 C1 ; Branch always long to $82, $F4, $C1 [Flow: branch]
	sbc $F6.b,X		; F5 F6 ; Subtract $F6.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $83.b		; 06 83 ; Arithmetic shift left $83.b [Reads: Direct Page] [Flags: NCZ]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc $E7.b		; E6 E7 ; Increment $E7.b [Reads: Direct Page] [Flags: NZ]
	sbc [$8A.b],Y		; F7 8A ; Subtract with carry (long indexed) [$8A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $FA4F93.l		; 5C 93 4F FA ; Jump long to $FA4F93.l [Flow: jump]
	cpy $FC.b		; C4 FC ; Compare $FC.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	sbc $8306.w,X		; FD 06 83 ; Subtract with carry $8306.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $A3.b		; 00 A3 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$E8.b]		; 07 E8 ; OR accumulator with memory (long) [$E8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $8A04.w		; CC 04 8A ; Compare $8A04.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora $93.b		; 05 93 ; Logical OR $93.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	asl $87.b		; 06 87 ; Arithmetic shift left $87.b [Reads: Direct Page] [Flags: NCZ]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $06, $03		; 62 06 03 ; Push effective relative address $62, $06, $03 [Writes: Stack Pointer]
	dec $93E3.w		; CE E3 93 ; Decrement $93E3.w [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $73.b		; 00 73 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc [$8A.b],Y		; F7 8A ; Subtract with carry (long indexed) [$8A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($52.b)		; 52 52 ; Exclusive OR accumulator with memory (indirect) ($52.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($C9.b,S),Y		; 93 C9 ; Store accumulator (stack relative indirect indexed) ($C9.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora #$83.b		; 09 83 ; Logical OR #$83.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $F7.b		; 06 F7 ; Arithmetic shift left $F7.b [Reads: Direct Page] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$52.b],Y		; 77 52 ; Add with carry (long indexed) [$52.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($0A.b,S),Y		; 93 0A ; Store accumulator (stack relative indirect indexed) ($0A.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	bit $543D.w,X		; 3C 3D 54 ; Test bits $543D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $D9.b		; 00 D9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	cmp $1D06.w,X		; DD 06 1D ; Compare accumulator $1D06.w,X [Reads: X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr $FB06.w,X		; 5E 06 FB ; Logical shift right $FB06.w,X [Reads: X Index] [Flags: NCZ]
	lsr $0622.w,X		; 5E 22 06 ; Logical shift right $0622.w,X [Reads: X Index] [Flags: NCZ]
	ora $5E.b,S		; 03 5E ; OR accumulator with stack relative $5E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$8A.b],Y		; F7 8A ; Subtract with carry (long indexed) [$8A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$FF.b],Y		; 77 FF ; Add with carry (long indexed) [$FF.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	bit $1A.b		; 24 1A ; Test bits $1A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $001A.w		; 2D 1A 00 ; Logical AND $001A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and #$1A.b		; 29 1A ; Logical AND #$1A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvp $1A,$18		; 44 18 1A ; Move block positive $1A,$18 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $1A.b,S		; 43 1A ; Exclusive OR accumulator with stack relative $1A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $1A24.w,Y		; 19 24 1A ; OR accumulator with memory $1A24.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $18241A.l		; 22 1A 24 18 ; Jump to subroutine long $18241A.l [Writes: Stack Pointer] [Flow: call]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	asl $0B04.w		; 0E 04 0B ; Arithmetic shift left $0B04.w [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$26.b]		; 07 26 ; OR accumulator with memory (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	adc $021A23.l,X		; 7F 23 1A 02 ; Add long $021A23.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $1A.b,S		; 23 1A ; AND accumulator with stack relative $1A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $1A24.w		; 0C 24 1A ; Test and set bits $1A24.w [Reads: Accumulator] [Flags: Z]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $1A.b,S		; 23 1A ; AND accumulator with stack relative $1A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $84.b,S		; 03 84 ; OR accumulator with stack relative $84.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $52.b		; 00 52 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $1A24.w		; 0C 24 1A ; Test and set bits $1A24.w [Reads: Accumulator] [Flags: Z]
	jsl $1A010B.l		; 22 0B 01 1A ; Jump to subroutine long $1A010B.l [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $1A0F0B.l		; 22 0B 0F 1A ; Jump to subroutine long $1A0F0B.l [Writes: Stack Pointer] [Flow: call]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1A1A.w		; 0C 1A 1A ; Test and set bits $1A1A.w [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0C.b		; 06 0C ; Arithmetic shift left $0C.b [Reads: Direct Page] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $001A.w		; 0C 1A 00 ; Test and set bits $001A.w [Reads: Accumulator] [Flags: Z]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $1A02.w		; 0C 02 1A ; Test and set bits $1A02.w [Reads: Accumulator] [Flags: Z]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $02.b,S		; 43 02 ; Exclusive OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0C0903.l		; 22 03 09 0C ; Jump to subroutine long $0C0903.l [Writes: Stack Pointer] [Flow: call]
	tsb $0200.w		; 0C 00 02 ; Test and set bits $0200.w [Reads: Accumulator] [Flags: Z]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $2206.w		; 0C 06 22 ; Test and set bits $2206.w [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01FF.w		; 0C FF 01 ; Test and set bits $01FF.w [Reads: Accumulator] [Flags: Z]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $3E25.w,X		; BD 25 3E ; Load $3E25.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$0C.b		; 09 0C ; Logical OR #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0ED6.w		; 0D D6 0E ; Logical OR $0ED6.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $11100E.l		; 0F 0E 10 11 ; OR accumulator with memory (long) $11100E.l [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $12.b,S		; 63 12 ; Add with carry (stack relative) $12.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cop $13.b		; 02 13 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $15.b,X		; 16 15 ; Arithmetic shift left $15.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $17.b,S		; 63 17 ; Add with carry (stack relative) $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $19.b,S		; 03 19 ; OR accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $6960.w		; 1C 60 69 ; Test and reset bits $6960.w [Reads: Accumulator] [Flags: Z]
	ora $7905.w,X		; 1D 05 79 ; OR accumulator with memory $7905.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $5727.w,X		; FD 27 57 ; Subtract with carry $5727.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and #$06.b		; 29 06 ; Logical AND #$06.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $3283.w		; 4E 83 32 ; Logical shift right $3283.w [Flags: NCZ]
	and ($53.b,S),Y		; 33 53 ; AND accumulator (stack relative indirect indexed) ($53.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $60.b,X		; 34 60 ; Test bits $60.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and $0F.b,X		; 35 0F ; Logical AND $0F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $3E53.w		; 4E 53 3E ; Logical shift right $3E53.w [Flags: NCZ]
	and $607E53.l,X		; 3F 53 7E 60 ; AND accumulator with memory (long,X) $607E53.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($40.b,S),Y		; 53 40 ; XOR accumulator (stack relative indirect indexed) ($40.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($2B.b,X)		; 41 2B ; Exclusive OR accumulator with memory ($2B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $41		; 42 41 ; Reserved instruction
	eor $42.b,S		; 43 42 ; Exclusive OR accumulator with stack relative $42.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $00,$83		; 44 83 00 ; Move block positive $00,$83 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $45.b		; 06 45 ; Arithmetic shift left $45.b [Reads: Direct Page] [Flags: NCZ]
	lsr $8C66.w		; 4E 66 8C ; Logical shift right $8C66.w [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sbc $2414.w,X		; FD 14 24 ; Subtract with carry $2414.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ora $33.b,S		; 03 33 ; OR accumulator with stack relative $33.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc [$3E.b]		; 67 3E ; Add with carry (long) [$3E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and $624663.l,X		; 3F 63 46 62 ; AND accumulator with memory (long,X) $624663.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$02.b		; 49 02 ; Exclusive OR #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$49.b		; 49 49 ; Exclusive OR #$49.b with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $9722.w		; 4C 22 97 ; Jump to $9722.w [Flow: jump]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda #$3E.b		; A9 3E ; Load #$3E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and $4D3E5F.l,X		; 3F 5F 3E 4D ; AND accumulator with memory (long,X) $4D3E5F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $4FF8.w		; 4E F8 4F ; Logical shift right $4FF8.w [Flags: NCZ]
	.db $50, $F8		; 50 F8 ; Branch if overflow clear to $50, $F8 [Flow: branch]
	tsb $66.b		; 04 66 ; Test and set bits $66.b [Reads: Accumulator] [Flags: Z]
	eor ($0A.b),Y		; 51 0A ; Exclusive OR accumulator with memory ($0A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($58.b,S),Y		; 53 58 ; XOR accumulator (stack relative indirect indexed) ($58.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $5A4E.w,Y		; 59 4E 5A ; Exclusive OR accumulator with memory $5A4E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp $535D27.l		; 5C 27 5D 53 ; Jump long to $535D27.l [Flow: jump]
	adc $5E.b,S		; 63 5E ; Add with carry (stack relative) $5E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $C7.b,S		; 03 C7 ; OR accumulator with stack relative $C7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($62.b,S),Y		; 53 62 ; XOR accumulator (stack relative indirect indexed) ($62.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $6364.w		; EE 64 63 ; Increment $6364.w [Flags: NZ]
	cop $27.b		; 02 27 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	adc [$62.b]		; 67 62 ; Add with carry (long) [$62.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $690A.w,X		; 5E 0A 69 ; Logical shift right $690A.w,X [Reads: X Index] [Flags: NCZ]
	and $6A3F.w,X		; 3D 3F 6A ; AND accumulator with memory $6A3F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $6C6B.w,Y		; D9 6B 6C ; Compare accumulator $6C6B.w,Y [Reads: Y Index] [Flags: NCZ]
	and ($6D.b,X)		; 21 6D ; Logical AND ($6D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $6827.w		; 6E 27 68 ; Rotate right $6827.w [Flags: NCZ]
	adc $DFD901.l		; 6F 01 D9 DF ; Add with carry (long) $DFD901.l [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $78, $01		; 62 78 01 ; Push effective relative address $62, $78, $01 [Writes: Stack Pointer]
	adc [$7B.b]		; 67 7B ; Add with carry (long) [$7B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $4F01F8.l		; 22 F8 01 4F ; Jump to subroutine long $4F01F8.l [Writes: Stack Pointer] [Flow: call]
	.db $50, $22		; 50 22 ; Branch if overflow clear to $50, $22 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $E51D7C.l		; 0F 7C 1D E5 ; OR accumulator with memory (long) $E51D7C.l [Writes: Accumulator] [Flags: NZ]
	inc $7D.b		; E6 7D ; Increment $7D.b [Reads: Direct Page] [Flags: NZ]
	ror $B21D.w,X		; 7E 1D B2 ; Rotate right $B21D.w,X [Reads: X Index] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	mvp $EC,$44		; 44 44 EC ; Move block positive $EC,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc $62961D.l,X		; 7F 1D 96 62 ; Add long $62961D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $8019.w		; EC 19 80 ; Compare $8019.w with X register [Reads: X Index] [Flags: NCZ]
	cmp ($6A.b,S),Y		; D3 6A ; Compare accumulator (stack relative indirect indexed) ($6A.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	sta $4C5B.w		; 8D 5B 4C ; Store accumulator to $4C5B.w [Reads: Accumulator]
	jmp $4B4B81.l		; 5C 81 4B 4B ; Jump long to $4B4B81.l [Flow: jump]
	.db $82, $4C, $83		; 82 4C 83 ; Branch always long to $82, $4C, $83 [Flow: branch]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sta $E5D9.w		; 8D D9 E5 ; Store accumulator to $E5D9.w [Reads: Accumulator]
	sbc ($B2.b,S),Y		; F3 B2 ; Subtract with carry (stack relative indirect indexed) ($B2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta [$EA.b],Y		; 97 EA ; Store accumulator (long indexed) [$EA.b],Y [Reads: Direct Page, Y Index, Accumulator]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	pea $A7F5.w		; F4 F5 A7 ; Push absolute address $A7F5.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $62, $EA, $00		; 62 EA 00 ; Push effective relative address $62, $EA, $00 [Writes: Stack Pointer]
	inc $FF.b,X		; F6 FF ; Increment memory $FF.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	asl $05.b,X		; 16 05 ; Arithmetic shift left $05.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $181A.w,Y		; 19 1A 18 ; OR accumulator with memory $181A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $19.b		; 05 19 ; Logical OR $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $1A.b		; 05 1A ; Logical OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $1A.b		; 05 1A ; Logical OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $1818.w,Y		; 19 18 18 ; OR accumulator with memory $1818.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1A.b		; 05 1A ; Logical OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $1A.b		; 25 1A ; Logical AND $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $18001A.l		; 22 1A 00 18 ; Jump to subroutine long $18001A.l [Writes: Stack Pointer] [Flow: call]
	rol $1A.b		; 26 1A ; Rotate left $1A.b [Reads: Direct Page] [Flags: NCZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($28.b,X)		; 01 28 ; Logical OR ($28.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	jsl $01001A.l		; 22 1A 00 01 ; Jump to subroutine long $01001A.l [Writes: Stack Pointer] [Flow: call]
	bit $18.b		; 24 18 ; Test bits $18.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($1A.b,X)		; 01 1A ; Logical OR ($1A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $12.b		; 00 12 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1A.b,S		; 23 1A ; AND accumulator with stack relative $1A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $1A.b		; 26 1A ; Rotate left $1A.b [Reads: Direct Page] [Flags: NCZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: NCZ]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	jsl $020B1A.l		; 22 1A 0B 02 ; Jump to subroutine long $020B1A.l [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0D07.w		; 0D 07 0D ; Logical OR $0D07.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2301.w,Y		; 19 01 23 ; OR accumulator with memory $2301.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2306.w		; 0D 06 23 ; Logical OR $2306.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $0D.b,S		; 23 0D ; AND accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2206.w		; 0D 06 22 ; Logical OR $2206.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0602.w		; 0D 02 06 ; Logical OR $0602.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $2602.w		; 0D 02 26 ; Logical OR $2602.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0D2206.l		; 22 06 22 0D ; Jump to subroutine long $0D2206.l [Writes: Stack Pointer] [Flow: call]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($24.b)		; 12 24 ; OR accumulator with memory (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0D2206.l		; 22 06 22 0D ; Jump to subroutine long $0D2206.l [Writes: Stack Pointer] [Flow: call]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $020B1A.l		; 22 1A 0B 02 ; Jump to subroutine long $020B1A.l [Writes: Stack Pointer] [Flow: call]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $E0FF.w,X		; 3D FF E0 ; AND accumulator with memory $E0FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sbc $C7841F.l,X		; FF 1F 84 C7 ; Subtract with carry (long,X) $C7841F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $FFC80A.l,X		; FF 0A C8 FF ; Subtract with carry (long,X) $FFC80A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $86.b		; 85 86 ; Store accumulator to $86.b [Reads: Accumulator]
	sbc $884887.l,X		; FF 87 48 88 ; Subtract with carry (long,X) $884887.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($29.b),Y		; 71 29 ; Add with carry ($29.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$C7.b		; 29 C7 ; Logical AND #$C7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $8A1089.l,X		; FF 89 10 8A ; Subtract with carry (long,X) $8A1089.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $A9.b		; A6 A9 ; Load $A9.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sbc $8B3E3D.l,X		; FF 3D 3E 8B ; Subtract with carry (long,X) $8B3E3D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $2AFF.w		; 8C FF 2A ; Store Y register to $2AFF.w [Reads: Y Index]
	trb $0A.b		; 14 0A ; Test and reset bits $0A.b [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $E8978D.l,X		; FF 8D 97 E8 ; Subtract with carry (long,X) $E8978D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	stx $6275.w		; 8E 75 62 ; Store X register to $6275.w [Reads: X Index]
	sta $477101.l		; 8F 01 71 47 ; Store accumulator (long) $477101.l [Reads: Accumulator]
	.db $62, $92, $03		; 62 92 03 ; Push effective relative address $62, $92, $03 [Writes: Stack Pointer]
	lda $95.b,X		; B5 95 ; Load $95.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stx $86.b,Y		; 96 86 ; Store X register $86.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	adc $97.b,S		; 63 97 ; Add with carry (stack relative) $97.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	stz $6671.w		; 9C 71 66 ; Store zero to $6671.w
	sta $700F.w,X		; 9D 0F 70 ; Store accumulator to $700F.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	stx $92.b,Y		; 96 92 ; Store X register $92.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ora $51A4.w,X		; 1D A4 51 ; OR accumulator with memory $51A4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc ($5F.b),Y		; 71 5F ; Add with carry ($5F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $50, $51		; 50 51 ; Branch if overflow clear to $50, $51 [Flow: branch]
	rol $A53E.w,X		; 3E 3E A5 ; Rotate left $A53E.w,X [Reads: X Index] [Flags: NCZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $F6.b		; 00 F6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $A6.b,S		; 63 A6 ; Add with carry (stack relative) $A6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $71.b		; 00 71 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $AA, $07		; 62 AA 07 ; Push effective relative address $62, $AA, $07 [Writes: Stack Pointer]
	.db $90, $90		; 90 90 ; Branch if carry clear to $90, $90 [Flow: branch]
	lda $1DAE.w		; AD AE 1D ; Load $1DAE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lsr $AF63.w,X		; 5E 63 AF ; Logical shift right $AF63.w,X [Reads: X Index] [Flags: NCZ]
	ora ($71.b,X)		; 01 71 ; Logical OR ($71.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $0FB362.l,X		; 3F 62 B3 0F ; AND accumulator with memory (long,X) $0FB362.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ldx $45.b,Y		; B6 45 ; Load X register $45.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	trb $1DAC.w		; 1C AC 1D ; Test and reset bits $1DAC.w [Reads: Accumulator] [Flags: Z]
	adc $68.b		; 65 68 ; Add $68.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $42, $B7		; 42 B7 ; Reserved instruction
	asl $9071.w		; 0E 71 90 ; Arithmetic shift left $9071.w [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldy $B9.b,X		; B4 B9 ; Load Y register $B9.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	adc $23.b,S		; 63 23 ; Add with carry (stack relative) $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lda ($27.b,S),Y		; B3 27 ; Load accumulator (stack relative indirect indexed) ($27.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $51BBBA.l		; 6F BA BB 51 ; Add with carry (long) $51BBBA.l [Writes: Accumulator] [Flags: NCVZ]
	ldy $F871.w,X		; BC 71 F8 ; Load Y register $F871.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda $BE5B.w,X		; BD 5B BE ; Load $BE5B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $2B.b,S		; 63 2B ; Add with carry (stack relative) $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($58.b,X)		; 01 58 ; Logical OR ($58.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $62.b		; 65 62 ; Add $62.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $C25D04.l,X		; BF 04 5D C2 ; Load long $C25D04.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($18.b),Y		; 71 18 ; Add with carry ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $3162.w,X		; 5E 62 31 ; Logical shift right $3162.w,X [Reads: X Index] [Flags: NCZ]
	cop $65.b		; 02 65 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $6F.b,X		; 34 6F ; Test bits $6F.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	ror $C3.b		; 66 C3 ; Rotate right $C3.b [Reads: Direct Page] [Flags: NCZ]
	ora $71.b,S		; 03 71 ; OR accumulator with stack relative $71.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $65.b		; 64 65 ; Store zero to $65.b
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	.db $62, $3B, $0C		; 62 3B 0C ; Push effective relative address $62, $3B, $0C [Writes: Stack Pointer]
	adc ($4F.b)		; 72 4F ; Add with carry (indirect) ($4F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stx $96.b,Y		; 96 96 ; Store X register $96.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	adc $A3.b,X		; 75 A3 ; Add $A3.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpy $6E71.w		; CC 71 6E ; Compare $6E71.w with Y register [Reads: Y Index] [Flags: NCZ]
	adc $456272.l		; 6F 72 62 45 ; Add with carry (long) $456272.l [Writes: Accumulator] [Flags: NCVZ]
	ora ($6A.b)		; 12 6A ; OR accumulator with memory (indirect) ($6A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $CE4E.w		; CD 4E CE ; Compare $CE4E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	lsr $F8F8.w		; 4E F8 F8 ; Logical shift right $F8F8.w [Flags: NCZ]
	cmp $C24471.l		; CF 71 44 C2 ; Compare accumulator (long) $C24471.l [Reads: Accumulator] [Flags: NCZ]
	trb $371D.w		; 1C 1D 37 ; Test and reset bits $371D.w [Reads: Accumulator] [Flags: Z]
	and #$1C.b		; 29 1C ; Logical AND #$1C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $249F.w,X		; 1D 9F 24 ; OR accumulator with memory $249F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $D003.w,X		; 1D 03 D0 ; OR accumulator with memory $D003.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($4B.b),Y		; 71 4B ; Add with carry ($4B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $27, $4C		; 82 27 4C ; Branch always long to $82, $27, $4C [Flow: branch]
	ora $CC.b,S		; 03 CC ; OR accumulator with stack relative $CC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($FC.b,S),Y		; D3 FC ; Compare accumulator (stack relative indirect indexed) ($FC.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	.db $62, $D1, $01		; 62 D1 01 ; Push effective relative address $62, $D1, $01 [Writes: Stack Pointer]
	nop		; EA ; No operation
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $62, $D4, $09		; 62 D4 09 ; Push effective relative address $62, $D4, $09 [Writes: Stack Pointer]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $EB.b,X		; D5 EB ; Compare accumulator $EB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cmp [$55.b],Y		; D7 55 ; Compare accumulator (long indexed) [$55.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp $DAEB.w,Y		; D9 EB DA ; Compare accumulator $DAEB.w,Y [Reads: Y Index] [Flags: NCZ]
	sbc $0D0D0A.l,X		; FF 0A 0D 0D ; Subtract with carry (long,X) $0D0D0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $84.b		; 04 84 ; Test and set bits $84.b [Reads: Accumulator] [Flags: Z]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0D.b		; 24 0D ; Test bits $0D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0B0A.w		; 0D 0A 0B ; Logical OR $0B0A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0A.b,S		; 03 0A ; OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $2801.w		; 0D 01 28 ; Logical OR $2801.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	rol $1A03.w		; 2E 03 1A ; Rotate left $1A03.w [Flags: NCZ]
	tsb $1A0C.w		; 0C 0C 1A ; Test and set bits $1A0C.w [Reads: Accumulator] [Flags: Z]
	jsl $1A220C.l		; 22 0C 22 1A ; Jump to subroutine long $1A220C.l [Writes: Stack Pointer] [Flow: call]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $01090D.l		; 22 0D 09 01 ; Jump to subroutine long $01090D.l [Writes: Stack Pointer] [Flow: call]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	jsl $1A0A00.l		; 22 00 0A 1A ; Jump to subroutine long $1A0A00.l [Writes: Stack Pointer] [Flow: call]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0808.w		; 0D 08 08 ; Logical OR $0808.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $1A1A.w		; 0C 1A 1A ; Test and set bits $1A1A.w [Reads: Accumulator] [Flags: Z]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $1A0300.l		; 22 00 03 1A ; Jump to subroutine long $1A0300.l [Writes: Stack Pointer] [Flow: call]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $4C.b		; 00 4C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1A.b		; 05 1A ; Logical OR $1A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $030D.w		; 0D 0D 03 ; Logical OR $030D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $251A.w		; 0D 1A 25 ; Logical OR $251A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0083.w		; 0D 83 00 ; Logical OR $0083.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp ($0104.w)		; 6C 04 01 ; Jump indirect to ($0104.w) [Flow: jump]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $1A010D.l		; 22 0D 01 1A ; Jump to subroutine long $1A010D.l [Writes: Stack Pointer] [Flow: call]
	ora $0022.w		; 0D 22 00 ; Logical OR $0022.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$21.b		; E0 21 ; Compare #$21.b with X register [Reads: X Index] [Flags: NCZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0101.w		; 0D 01 01 ; Logical OR $0101.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1A1A.w		; 0D 1A 1A ; Logical OR $1A1A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0C19.w		; 0D 19 0C ; Logical OR $0C19.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $020D.w		; 0D 0D 02 ; Logical OR $020D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $010D.w		; 0D 0D 01 ; Logical OR $010D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0702.w		; 0D 02 07 ; Logical OR $0702.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $070D.w		; 0D 0D 07 ; Logical OR $070D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $240D.w		; 0D 0D 24 ; Logical OR $240D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $2401.w		; 0D 01 24 ; Logical OR $2401.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0324.w		; 0D 24 03 ; Logical OR $0324.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $58570A.l,X		; FF 0A 57 58 ; Subtract with carry (long,X) $58570A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($E3.b,X)		; 41 E3 ; Exclusive OR accumulator with memory ($E3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $DBDA.w,Y		; 59 DA DB ; Exclusive OR accumulator with memory $DBDA.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $84.b		; 46 84 ; Logical shift right $84.b [Reads: Direct Page] [Flags: NCZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($5A.b,X)		; 01 5A ; Logical OR ($5A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor [$62.b],Y		; 57 62 ; Exclusive OR accumulator with memory (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora $A1.b		; 05 A1 ; Logical OR $A1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp $A14E.w		; 4C 4E A1 ; Jump to $A14E.w [Flow: jump]
	jmp $844E.w		; 4C 4E 84 ; Jump to $844E.w [Flow: jump]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$55.b		; 09 55 ; Logical OR #$55.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $6041.w,X		; 5E 41 60 ; Logical shift right $6041.w,X [Reads: X Index] [Flags: NCZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	bit $0F.b		; 24 0F ; Test bits $0F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	adc $11.b,S		; 63 11 ; Add with carry (stack relative) $11.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sbc $A4.b,S		; E3 A4 ; Subtract stack-relative $A4.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda $A4AE.w		; AD AE A4 ; Load $A4AE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $A4AE.w		; AD AE A4 ; Load $A4AE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $59AE.w		; AD AE 59 ; Load $59AE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $30, $03		; 30 03 ; Branch if minus to $30, $03 [Flow: branch]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $42, $42		; 42 42 ; Reserved instruction
	jmp.w [$4222]		; DC 22 42 ; Jump long indirect [$4222] [Flow: jump]
	.db $62, $DD, $18		; 62 DD 18 ; Push effective relative address $62, $DD, $18 [Writes: Stack Pointer]
	lda ($4C.b,X)		; A1 4C ; Load accumulator ($4C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $65.b		; 64 65 ; Store zero to $65.b
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sbc $74.b,S		; E3 74 ; Subtract stack-relative $74.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp $E01D.w,Y		; D9 1D E0 ; Compare accumulator $E01D.w,Y [Reads: Y Index] [Flags: NCZ]
	dec $1DE1.w,X		; DE E1 1D ; Decrement memory $1DE1.w,X [Reads: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit $A73D.w,X		; 3C 3D A7 ; Test bits $A73D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	eor ($9C.b,S),Y		; 53 9C ; XOR accumulator (stack relative indirect indexed) ($9C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp ($E341.w)		; 6C 41 E3 ; Jump indirect to ($E341.w) [Flow: jump]
	stz $03.b,X		; 74 03 ; Store zero to $03.b,X [Reads: X Index]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $E2011D.l		; 22 1D 01 E2 ; Jump to subroutine long $E2011D.l [Writes: Stack Pointer] [Flow: call]
	ora $0083.w,X		; 1D 83 00 ; OR accumulator with memory $0083.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpx $E5.b		; E4 E5 ; Compare $E5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $74.b,X		; 95 74 ; Store accumulator to $74.b,X [Reads: Accumulator, X Index]
	jsl $E20F1D.l		; 22 1D 0F E2 ; Jump to subroutine long $E20F1D.l [Writes: Stack Pointer] [Flow: call]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $E7E6DE.l,X		; BF DE E6 E7 ; Load long $E7E6DE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $80E8.w		; 4C E8 80 ; Jump to $80E8.w [Flow: jump]
	adc [$9D.b],Y		; 77 9D ; Add with carry (long indexed) [$9D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $E9, $60		; 82 E9 60 ; Branch always long to $82, $E9, $60 [Flow: branch]
	adc ($22.b),Y		; 71 22 ; Add with carry ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $09.b,X		; [PATTERN: Memory clearing operation] 74 09 ; Store zero to $09.b,X [Reads: X Index]
	sty $EA.b		; 84 EA ; Store Y register to $EA.b [Reads: Y Index]
	bit #$52.b		; 89 52 ; Test bits #$52.b with accumulator [Reads: Accumulator] [Flags: Z]
	eor ($F8.b,S),Y		; 53 F8 ; XOR accumulator (stack relative indirect indexed) ($F8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $A888.w		; 9C 88 A8 ; Store zero to $A888.w
	sta [$62.b],Y		; 97 62 ; Store accumulator (long indexed) [$62.b],Y [Reads: Direct Page, Y Index, Accumulator]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ora ($EB.b,X)		; 01 EB ; Logical OR ($EB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	stx $1D22.w		; 8E 22 1D ; Store X register to $1D22.w [Reads: X Index]
	cpx #$3E.b		; E0 3E ; Compare #$3E.b with X register [Reads: X Index] [Flags: NCZ]
	.db $42, $4F		; 42 4F ; Reserved instruction
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	sbc $BB.b		; E5 BB ; Subtract $BB.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx $6161.w		; EC 61 61 ; Compare $6161.w with X register [Reads: X Index] [Flags: NCZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($61.b,X)		; 61 61 ; Add with carry ($61.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$B2ED]		; DC ED B2 ; Jump long indirect [$B2ED] [Flow: jump]
	.db $50, $EE		; 50 EE ; Branch if overflow clear to $50, $EE [Flow: branch]
	lsr $5C49.w		; 4E 49 5C ; Logical shift right $5C49.w [Flags: NCZ]
	sta $229A.w,Y		; 99 9A 22 ; Store accumulator to $229A.w,Y [Reads: Y Index, Accumulator]
	jsl $226160.l		; 22 60 61 22 ; Jump to subroutine long $226160.l [Writes: Stack Pointer] [Flow: call]
	jsl $8EDCB1.l		; 22 B1 DC 8E ; Jump to subroutine long $8EDCB1.l [Writes: Stack Pointer] [Flow: call]
	sbc $B758F0.l		; EF F0 58 B7 ; Subtract with carry (long) $B758F0.l [Writes: Accumulator] [Flags: NCVZ]
	sta $60E6A0.l,X		; 9F A0 E6 60 ; Store accumulator (long,X) $60E6A0.l,X [Reads: Accumulator, X Index]
	and $1E.b,X		; 35 1E ; Logical AND $1E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1D6A.w,Y		; D9 6A 1D ; Compare accumulator $1D6A.w,Y [Reads: Y Index] [Flags: NCZ]
	lsr $B1.b,X		; 56 B1 ; Logical shift right $B1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda ($A5.b,X)		; A1 A5 ; Load accumulator ($A5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda $A5.b		; A5 A5 ; Load $A5.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $A6.b		; 06 A6 ; Arithmetic shift left $A6.b [Reads: Direct Page] [Flags: NCZ]
	cmp ($C6.b)		; D2 C6 ; Compare accumulator (indirect) ($C6.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda [$A8.b]		; A7 A8 ; Load accumulator (long) [$A8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta [$44.b],Y		; 97 44 ; Store accumulator (long indexed) [$44.b],Y [Reads: Direct Page, Y Index, Accumulator]
	mvp $56,$C2		; 44 C2 56 ; Move block positive $56,$C2 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	and $E5.b,S		; 23 E5 ; AND accumulator with stack relative $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $A6.b		; 06 A6 ; Arithmetic shift left $A6.b [Reads: Direct Page] [Flags: NCZ]
	lda #$24.b		; A9 24 ; Load #$24.b into accumulator [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora ($4D.b,X)		; 01 4D ; Logical OR ($4D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	dec $24.b		; C6 24 ; Decrement $24.b [Reads: Direct Page] [Flags: NZ]
	mvp $06,$02		; 44 02 06 ; Move block positive $06,$02 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor ($06.b,S),Y		; 53 06 ; XOR accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $06.b,S		; 43 06 ; Exclusive OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ora $AB.b,S		; 03 AB ; OR accumulator with stack relative $AB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($A6.b,S),Y		; 53 A6 ; XOR accumulator (stack relative indirect indexed) ($A6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$24.b		; A9 24 ; Load #$24.b into accumulator [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc $080406.l,X		; FF 06 04 08 ; Subtract with carry (long,X) $080406.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $00870D.l		; 22 0D 87 00 ; Jump to subroutine long $00870D.l [Writes: Stack Pointer] [Flow: call]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0112.w		; 0D 12 01 ; Logical OR $0112.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($88.b,X)		; 01 88 ; Logical OR ($88.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0D.b		; 04 0D ; Test and set bits $0D.b [Reads: Accumulator] [Flags: Z]
	tsb $06.b		; 04 06 ; Test and set bits $06.b [Reads: Accumulator] [Flags: Z]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	jsl $08250D.l		; 22 0D 25 08 ; Jump to subroutine long $08250D.l [Writes: Stack Pointer] [Flow: call]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0103.w		; 0C 03 01 ; Test and set bits $0103.w [Reads: Accumulator] [Flags: Z]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $010D.w		; 0D 0D 01 ; Logical OR $010D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $16.b		; 05 16 ; Logical OR $16.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1A4301.l		; 22 01 43 1A ; Jump to subroutine long $1A4301.l [Writes: Stack Pointer] [Flow: call]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0402.w		; 0D 02 04 ; Logical OR $0402.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora ($1A.b),Y		; 11 1A ; OR accumulator with memory ($1A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1A.b,S		; 03 1A ; OR accumulator with stack relative $1A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $01230D.l		; 22 0D 23 01 ; Jump to subroutine long $01230D.l [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $230D.w		; 0D 0D 23 ; Logical OR $230D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b),Y		; 11 0D ; OR accumulator with memory ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $040C.w		; 0D 0C 04 ; Logical OR $040C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1A.b,X)		; 01 1A ; Logical OR ($1A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $0D.b		; 06 0D ; Arithmetic shift left $0D.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl $000504.l		; 22 04 05 00 ; Jump to subroutine long $000504.l [Writes: Stack Pointer] [Flow: call]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	eor $1B.b		; 45 1B ; Exclusive OR $1B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0408.w		; 0E 08 04 ; Arithmetic shift left $0408.w [Flags: NCZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1B08.w		; 0D 08 1B ; Logical OR $1B08.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0822.w		; 0D 22 08 ; Logical OR $0822.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	jsl $0D0E0C.l		; 22 0C 0E 0D ; Jump to subroutine long $0D0E0C.l [Writes: Stack Pointer] [Flow: call]
	ora $0D1B.w		; 0D 1B 0D ; Logical OR $0D1B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0405.w		; 0C 05 04 ; Test and set bits $0405.w [Reads: Accumulator] [Flags: Z]
	cop $62.b		; 02 62 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1B08.w		; 0D 08 1B ; Logical OR $1B08.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $03.b		; 25 03 ; Logical AND $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $06010D.l		; 22 0D 01 06 ; Jump to subroutine long $06010D.l [Writes: Stack Pointer] [Flow: call]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$2F.b		; E0 2F ; Compare #$2F.b with X register [Reads: X Index] [Flags: NCZ]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ldy $ACA5.w		; AC A5 AC ; Load $ACA5.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $DA59.w		; AD 59 DA ; Load $DA59.w into accumulator [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $4CA1.w		; 4E A1 4C ; Logical shift right $4CA1.w [Flags: NCZ]
	lsr $4CA1.w		; 4E A1 4C ; Logical shift right $4CA1.w [Flags: NCZ]
	sbc ($4E.b),Y		; F1 4E ; Subtract with carry ($4E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor #$68.b		; 49 68 ; Exclusive OR #$68.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $F6AF.w		; AE AF F6 ; Load $F6AF.w into X register [Writes: X Index] [Flags: NZ]
	eor $494E.w		; 4D 4E 49 ; Exclusive OR $494E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($58.b)		; F2 58 ; Subtract with carry (indirect) ($58.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda [$29.b],Y		; B7 29 ; Load accumulator (long indexed) [$29.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $61.b		; 85 61 ; Store accumulator to $61.b [Reads: Accumulator]
	dec $BCBB.w		; CE BB BC ; Decrement $BCBB.w [Flags: NZ]
	.db $62, $AC, $04		; 62 AC 04 ; Push effective relative address $62, $AC, $04 [Writes: Stack Pointer]
	ldy $AD.b		; A4 AD ; Load $AD.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldx $60F3.w		; AE F3 60 ; Load $60F3.w into X register [Writes: X Index] [Flags: NZ]
	jsl $B40C61.l		; 22 61 0C B4 ; Jump to subroutine long $B40C61.l [Writes: Stack Pointer] [Flow: call]
	jsl $C5C4F4.l		; 22 F4 C4 C5 ; Jump to subroutine long $C5C4F4.l [Writes: Stack Pointer] [Flow: call]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $F6F5.w,Y		; 99 F5 F6 ; Store accumulator to $F6F5.w,Y [Reads: Y Index, Accumulator]
	lsr $40.b,X		; 56 40 ; Logical shift right $40.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $2202.w,Y		; 79 02 22 ; Add $2202.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $ABF71E.l		; 22 1E F7 AB ; Jump to subroutine long $ABF71E.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	lsr $CC49.w		; 4E 49 CC ; Logical shift right $CC49.w [Flags: NCZ]
	adc ($80.b,X)		; 61 80 ; Add with carry ($80.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $481D.w,Y		; F9 1D 48 ; Subtract with carry $481D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $61.b		; 85 61 ; Store accumulator to $61.b [Reads: Accumulator]
	cop $FA.b		; 02 FA ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$FB.b		; C9 FB ; Compare #$FB.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $22CF.w,X		; BC CF 22 ; Load Y register $22CF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and $E6.b,S		; 23 E6 ; AND accumulator with stack relative $E6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	ora $F5FB.w,X		; 1D FB F5 ; OR accumulator with memory $F5FB.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	cmp ($62.b),Y		; D1 62 ; Compare accumulator ($62.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jsr ($37E0.w,X)		; FC E0 37 ; Jump to subroutine indirect indexed ($37E0.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	pea $C5C4.w		; F4 C4 C5 ; Push absolute address $C5C4.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and ($1D.b,S),Y		; 33 1D ; AND accumulator (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $E6.b		; E4 E6 ; Compare $E6.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $00ABED.l,X		; FF ED AB 00 ; Subtract with carry (long,X) $00ABED.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $D5		; 80 D5 ; Branch always to $80, $D5 [Flow: branch]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $4C4B.w		; 4D 4B 4C ; Exclusive OR $4C4B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $033E.w,X		; 3D 3E 03 ; AND accumulator with memory $033E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $5EE4.w,X		; 1D E4 5E ; OR accumulator with memory $5EE4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($B4.b,X)		; 61 B4 ; Add with carry ($B4.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b],Y		; 17 05 ; OR accumulator with memory (long indexed) [$05.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $5206.w,Y		; 19 06 52 ; OR accumulator with memory $5206.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($46.b,S),Y		; 53 46 ; XOR accumulator (stack relative indirect indexed) ($46.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$44.b]		; 47 44 ; Exclusive OR accumulator with memory (long) [$44.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $1F6A.w,Y		; BE 6A 1F ; Load X register $1F6A.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	jsl $DFDEA8.l		; 22 A8 DE DF ; Jump to subroutine long $DFDEA8.l [Writes: Stack Pointer] [Flow: call]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $E0.b		; 25 E0 ; Logical AND $E0.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $56.b,X		; 55 56 ; Exclusive OR accumulator with memory $56.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $0908.w		; 4E 08 09 ; Logical shift right $0908.w [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	jsl $E51742.l		; 22 42 17 E5 ; Jump to subroutine long $E51742.l [Writes: Stack Pointer] [Flow: call]
	inc $0A.b		; E6 0A ; Increment $0A.b [Reads: Direct Page] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ldx $676A.w,Y		; BE 6A 67 ; Load X register $676A.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor ($58.b),Y		; 51 58 ; Exclusive OR accumulator with memory ($58.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $42.b		; 65 42 ; Add $42.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $81		; 10 81 ; Branch if plus to $10, $81 [Flow: branch]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda ($86.b,S),Y		; B3 86 ; Load accumulator (stack relative indirect indexed) ($86.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $F9.b		; E5 F9 ; Subtract $F9.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C0.b		; E5 C0 ; Subtract $C0.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $22DF.w,X		; 1E DF 22 ; Arithmetic shift left $22DF.w,X [Reads: X Index] [Flags: NCZ]
	lda $08.b		; A5 08 ; Load $08.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stx $E5.b		; 86 E5 ; Store X register to $E5.b [Reads: X Index]
	sbc $BB.b		; E5 BB ; Subtract $BB.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $23EC.w,X		; 1D EC 23 ; OR accumulator with memory $23EC.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$23.b		; A0 23 ; Load #$23.b into Y register [Writes: Y Index] [Flags: NZ]
	sbc $0B.b		; E5 0B ; Subtract $0B.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cop $A8.b		; 02 A8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($44.b,X)		; 41 44 ; Exclusive OR accumulator with memory ($44.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $A9,$F0		; 44 F0 A9 ; Move block positive $A9,$F0 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ldx $B7.b,Y		; B6 B7 ; Load X register $B7.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	and $25B7B6.l,X		; 3F B6 B7 25 ; AND accumulator with memory (long,X) $25B7B6.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $48,$04		; 44 04 48 ; Move block positive $48,$04 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $F0, $8C		; F0 8C ; Branch if equal to $F0, $8C [Flow: branch]
	sta $62EE.w		; 8D EE 62 ; Store accumulator to $62EE.w [Reads: Accumulator]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0A.b		; 09 0A ; Logical OR #$0A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $4B.b		; 25 4B ; Logical AND $4B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $F1, $03		; 62 F1 03 ; Push effective relative address $62, $F1, $03 [Writes: Stack Pointer]
	eor $0749.w		; 4D 49 07 ; Exclusive OR $0749.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $62, $06, $FF		; 62 06 FF ; Push effective relative address $62, $06, $FF [Writes: Stack Pointer]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit #$00.b		; 89 00 ; Test bits #$00.b with accumulator [Reads: Accumulator] [Flags: Z]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta [$00.b],Y		; 97 00 ; Store accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora #$24.b		; 09 24 ; Logical OR #$24.b with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $0D0008.l		; 22 08 00 0D ; Jump to subroutine long $0D0008.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $0822.w		; 0D 22 08 ; Logical OR $0822.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($85.b,X)		; 01 85 ; Logical OR ($85.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$1B.b		; 09 1B ; Logical OR #$1B.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $1605.w		; 0D 05 16 ; Logical OR $1605.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($09.b)		; 12 09 ; OR accumulator with memory (indirect) ($09.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $010100.l		; 22 00 01 01 ; Jump to subroutine long $010100.l [Writes: Stack Pointer] [Flow: call]
	asl $84.b		; 06 84 ; Arithmetic shift left $84.b [Reads: Direct Page] [Flags: NCZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $060201.l		; 22 01 02 06 ; Jump to subroutine long $060201.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $1B010B.l		; 0F 0B 01 1B ; OR accumulator with memory (long) $1B010B.l [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: NCZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $240422.l		; 0F 22 04 24 ; OR accumulator with memory (long) $240422.l [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $50, $02		; 50 02 ; Branch if overflow clear to $50, $02 [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $2204.w		; 0C 04 22 ; Test and set bits $2204.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0309.w		; 0D 09 03 ; Logical OR $0309.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $061101.l		; 22 01 11 06 ; Jump to subroutine long $061101.l [Writes: Stack Pointer] [Flow: call]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $040308.l		; 22 08 03 04 ; Jump to subroutine long $040308.l [Writes: Stack Pointer] [Flow: call]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $04.b,S		; 23 04 ; AND accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($84.b,X)		; 01 84 ; Logical OR ($84.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $9D.b		; 00 9D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $46.b		; 05 46 ; Logical OR $46.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	bit #$00.b		; 89 00 ; Test bits #$00.b with accumulator [Reads: Accumulator] [Flags: Z]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $4CA1.w		; 4E A1 4C ; Logical shift right $4CA1.w [Flags: NCZ]
	lsr $4CA1.w		; 4E A1 4C ; Logical shift right $4CA1.w [Flags: NCZ]
	sbc ($4E.b),Y		; F1 4E ; Subtract with carry ($4E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $0085.w		; 0C 85 00 ; Test and set bits $0085.w [Reads: Accumulator] [Flags: Z]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	lsr $A73D.w		; 4E 3D A7 ; Logical shift right $A73D.w [Flags: NCZ]
	eor ($3D.b,S),Y		; 53 3D ; XOR accumulator (stack relative indirect indexed) ($3D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($58.b)		; F2 58 ; Subtract with carry (indirect) ($58.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $0085.w		; 0D 85 00 ; Logical OR $0085.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $3D03.w		; 20 03 3D ; Jump to subroutine at $3D03.w [Writes: Stack Pointer] [Flow: call]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $62, $AC, $06		; 62 AC 06 ; Push effective relative address $62, $AC, $06 [Writes: Stack Pointer]
	asl $0F43.w		; 0E 43 0F ; Arithmetic shift left $0F43.w [Flags: NCZ]
	ldy $AD.b		; A4 AD ; Load $AD.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldx $8559.w		; AE 59 85 ; Load $8559.w into X register [Writes: X Index] [Flags: NZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $A2.b		; 02 A2 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $1E.b,X		; 74 1E ; Store zero to $1E.b,X [Reads: X Index]
	.db $62, $4D, $04		; 62 4D 04 ; Push effective relative address $62, $4D, $04 [Writes: Stack Pointer]
	ora $1E74.w,X		; 1D 74 1E ; OR accumulator with memory $1E74.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $844B.w		; 4D 4B 84 ; Exclusive OR $844B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $B6		; 10 B6 ; Branch if plus to $10, $B6 [Flow: branch]
	rol $57.b		; 26 57 ; Rotate left $57.b [Reads: Direct Page] [Flags: NCZ]
	ora ($65.b),Y		; 11 65 ; OR accumulator with memory ($65.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ldx $12.b,Y		; B6 12 ; Load X register $12.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ora ($52.b,S),Y		; 13 52 ; OR accumulator (stack relative indirect indexed) ($52.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	rol $30E0.w		; 2E E0 30 ; Rotate left $30E0.w [Flags: NCZ]
	ora #$14.b		; 09 14 ; Logical OR #$14.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$2F.b		; 09 2F ; Logical OR #$2F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($BC.b),Y		; 31 BC ; AND accumulator with memory ($BC.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $09EE.w,X		; 1D EE 09 ; OR accumulator with memory $09EE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $565574.l		; 2F 74 55 56 ; AND accumulator with memory (long) $565574.l [Writes: Accumulator] [Flags: NZ]
	lsr $4E.b		; 46 4E ; Logical shift right $4E.b [Reads: Direct Page] [Flags: NCZ]
	cmp $4F.b,S		; C3 4F ; Compare accumulator (stack relative) $4F.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	.db $30, $0E		; 30 0E ; Branch if minus to $30, $0E [Flow: branch]
	and $1E9915.l		; 2F 15 99 1E ; AND accumulator with memory (long) $1E9915.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $0E		; 30 0E ; Branch if minus to $30, $0E [Flow: branch]
	and $FF1E35.l		; 2F 35 1E FF ; AND accumulator with memory (long) $FF1E35.l [Writes: Accumulator] [Flags: NZ]
	lsr $C63D.w		; [PATTERN: Memory clearing operation] 4E 3D C6 ; Logical shift right $C63D.w [Flags: NCZ]
	.db $D0, $1E		; D0 1E ; Branch if not equal to $D0, $1E [Flow: branch]
	asl $9F.b,X		; 16 9F ; Arithmetic shift left $9F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	stz $35.b,X		; 74 35 ; Store zero to $35.b,X [Reads: X Index]
	stz $17.b,X		; 74 17 ; Store zero to $17.b,X [Reads: X Index]
	inc $6A.b		; E6 6A ; Increment $6A.b [Reads: Direct Page] [Flags: NZ]
	bit $0018.w,X		; 3C 18 00 ; Test bits $0018.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and $4746.w,X		; 3D 46 47 ; AND accumulator with memory $4746.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $42,$62		; 44 62 42 ; Move block positive $42,$62 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $743C.w,Y		; 19 3C 74 ; OR accumulator with memory $743C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	dec $6261.w,X		; DE 61 62 ; Decrement memory $6261.w,X [Reads: X Index] [Flags: NZ]
	lda $1D.b		; A5 1D ; Load $1D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($46.b,X)		; 61 46 ; Add with carry ($46.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $4E1A.w,Y		; 19 1A 4E ; OR accumulator with memory $4E1A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $B21C1C.l		; 4F 1C 1C B2 ; Exclusive OR accumulator with memory (long) $B21C1C.l [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	adc [$68.b]		; 67 68 ; Add with carry (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $C0.b		; A5 C0 ; Load $C0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $624E.w		; 0D 4E 62 ; Logical OR $624E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($E0.b),Y		; 51 E0 ; Exclusive OR accumulator with memory ($E0.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $D0581B.l		; 2F 1B 58 D0 ; AND accumulator with memory (long) $D0581B.l [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc ($62.b,X)		; 61 62 ; Add with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $29DF.w,X		; BC DF 29 ; Load Y register $29DF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cmp $53C5.w,Y		; D9 C5 53 ; Compare accumulator $53C5.w,Y [Reads: Y Index] [Flags: NCZ]
	and $55ED.w,X		; 3D ED 55 ; AND accumulator with memory $55ED.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $49.b,X		; 56 49 ; Logical shift right $49.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $44.b,S		; 43 44 ; Exclusive OR accumulator with stack relative $44.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $6867.w,X		; 1D 67 68 ; OR accumulator with memory $6867.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $6A74.w,X		; 3C 74 6A ; Test bits $6A74.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $42, $4F		; 42 4F ; Reserved instruction
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: NCZ]
	ora $4A67.w,X		; 1D 67 4A ; OR accumulator with memory $4A67.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	trb $DFD4.w		; 1C D4 DF ; Test and reset bits $DFD4.w [Reads: Accumulator] [Flags: Z]
	ora $0732.w,X		; 1D 32 07 ; OR accumulator with memory $0732.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $A1C2.w,X		; 1E C2 A1 ; Arithmetic shift left $A1C2.w,X [Reads: X Index] [Flags: NCZ]
	jmp $744E.w		; 4C 4E 74 ; Jump to $744E.w [Flow: jump]
	ora $62DF.w,X		; 1D DF 62 ; OR accumulator with memory $62DF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($02.b),Y		; 51 02 ; Exclusive OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora $863C.w,X		; 1D 3C 86 ; OR accumulator with memory $863C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	stz $30.b		; 64 30 ; Store zero to $30.b
	.db $42, $4F		; 42 4F ; Reserved instruction
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $62, $AA, $61		; 62 AA 61 ; Push effective relative address $62, $AA, $61 [Writes: Stack Pointer]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $23.b		; 04 23 ; Test and set bits $23.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	jsl L00081B.l		; 22 1B 88 00 ; Jump to subroutine long L00081B.l [Writes: Stack Pointer] [Flow: call]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($27.b,X)		; 01 27 ; Logical OR ($27.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $010C08.l		; 22 08 0C 01 ; Jump to subroutine long $010C08.l [Writes: Stack Pointer] [Flow: call]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0C.b		; 04 0C ; Test and set bits $0C.b [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $01.b,X		; 16 01 ; Arithmetic shift left $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $2204.w		; 0E 04 22 ; Arithmetic shift left $2204.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cop $0C.b		; 02 0C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $1B.b		; 04 1B ; Test and set bits $1B.b [Reads: Accumulator] [Flags: Z]
	ora $0084.w		; 0D 84 00 ; Logical OR $0084.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $50, $02		; 50 02 ; Branch if overflow clear to $50, $02 [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $08.b		; 25 08 ; Logical AND $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $040708.l		; 22 08 07 04 ; Jump to subroutine long $040708.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $000008.l		; 22 08 00 00 ; Jump to subroutine long $000008.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor $0403.w		; 4D 03 04 ; Exclusive OR $0403.w with accumulator [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $000808.l		; 22 08 08 00 ; Jump to subroutine long $000808.l [Writes: Stack Pointer] [Flow: call]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $08.b,X		; 16 08 ; Arithmetic shift left $08.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $06101B.l		; 22 1B 10 06 ; Jump to subroutine long $06101B.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0804.w		; 0C 04 08 ; Test and set bits $0804.w [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	bit $08.b		; 24 08 ; Test bits $08.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $62, $03, $00		; 62 03 00 ; Push effective relative address $62, $03, $00 [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and [$08.b]		; 27 08 ; AND accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $15.b,X		; 16 15 ; Arithmetic shift left $15.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	eor $04.b,S		; 43 04 ; Exclusive OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1B.b,S		; 23 1B ; AND accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b,X		; 15 23 ; OR accumulator with memory $23.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	lsr $0A.b		; 46 0A ; Logical shift right $0A.b [Reads: Direct Page] [Flags: NCZ]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($1A.b,X)		; 01 1A ; Logical OR ($1A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $0C01.w		; 0D 01 0C ; Logical OR $0C01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $1A0001.l		; 22 01 00 1A ; Jump to subroutine long $1A0001.l [Writes: Stack Pointer] [Flow: call]
	sbc $DBDA09.l,X		; FF 09 DA DB ; Subtract with carry (long,X) $DBDA09.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $6AA5.w		; AC A5 6A ; Load $6AA5.w into Y register [Writes: Y Index] [Flags: NZ]
	eor $4C4B.w		; 4D 4B 4C ; Exclusive OR $4C4B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $85A1.w		; 4E A1 85 ; Logical shift right $85A1.w [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $A1.b		; 02 A1 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $62A2.w		; 4C A2 62 ; Jump to $62A2.w [Flow: jump]
	ora $535203.l,X		; 1F 03 52 53 ; Logical OR long $535203.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $85A7.w,X		; 3D A7 85 ; AND accumulator with memory $85A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $53A7.w,X		; 1D A7 53 ; OR accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	stz $35.b,X		; 74 35 ; Store zero to $35.b,X [Reads: X Index]
	asl $AE55.w,X		; 1E 55 AE ; Arithmetic shift left $AE55.w,X [Reads: X Index] [Flags: NCZ]
	ldy $AD.b		; A4 AD ; Load $AD.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lsr $AC.b,X		; 56 AC ; Logical shift right $AC.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $4656.w		; AD 56 46 ; Load $4656.w into accumulator [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $62, $1E, $31		; 62 1E 31 ; Push effective relative address $62, $1E, $31 [Writes: Stack Pointer]
	and ($07.b)		; 32 07 ; AND accumulator with memory (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $42, $22		; 42 22 ; Reserved instruction
	and $67.b		; 25 67 ; Logical AND $67.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $0083FF.l,X		; 5F FF 83 00 ; Exclusive OR accumulator with memory (long,X) $0083FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0B02.w		; 0E 02 0B ; Arithmetic shift left $0B02.w [Flags: NCZ]
	and $3C.b,S		; 23 3C ; AND accumulator with stack relative $3C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $3E.b		; 04 3E ; Test and set bits $3E.b [Reads: Accumulator] [Flags: Z]
	cmp $251E24.l,X		; DF 24 1E 25 ; Compare accumulator (long,X) $251E24.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $3D0D.w,X		; 1E 0D 3D ; Arithmetic shift left $3D0D.w,X [Reads: X Index] [Flags: NCZ]
	rol $5926.w,X		; 3E 26 59 ; Rotate left $5926.w,X [Reads: X Index] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lsr $47.b		; 46 47 ; Logical shift right $47.b [Reads: Direct Page] [Flags: NCZ]
	and [$28.b]		; 27 28 ; AND accumulator with memory (long) [$28.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $29.b		; 26 29 ; Rotate left $29.b [Reads: Direct Page] [Flags: NCZ]
	ldy $AD.b		; A4 AD ; Load $AD.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
.ACCU 16
	rep #$A1		; C2 A1
	jmp $C34E.w		; 4C 4E C3 ; Jump to $C34E.w [Flow: jump]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora #$6A2F.w		; 09 2F 6A ; Logical OR #$6A2F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $4CA12C.l,X		; 9F 2C A1 4C ; Store accumulator (long,X) $4CA12C.l,X [Reads: Accumulator, X Index]
	ldx #$AA.b		; A2 AA ; Load #$AA.b into X register [Writes: X Index] [Flags: NZ]
	and $0083.w		; 2D 83 00 ; Logical AND $0083.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	cop $C6.b		; 02 C6 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $630E.w		; 2E 0E 63 ; Rotate left $630E.w [Flags: NCZ]
	and $53A70B.l		; 2F 0B A7 53 ; AND accumulator with memory (long) $53A70B.l [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($61.b)		; B2 61 ; Load accumulator (indirect) ($61.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $DA.b		; 46 DA ; Logical shift right $DA.b [Reads: Direct Page] [Flags: NCZ]
	ora #$A5A4.w		; 09 A4 A5 ; Logical OR #$A5A4.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldx $62.b		; A6 62 ; Load $62.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	and ($14.b,S),Y		; 33 14 ; AND accumulator (stack relative indirect indexed) ($14.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $62, $C0, $0D		; 62 C0 0D ; Push effective relative address $62, $C0, $0D [Writes: Stack Pointer]
	lsr $19A1.w		; 4E A1 19 ; Logical shift right $19A1.w [Flags: NCZ]
	pei ($6A.b)		; D4 6A ; Push effective indirect address ($6A.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	stx $3736.w		; 8E 36 37 ; Store X register to $3736.w [Reads: X Index]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $4CA1.w,Y		; BE A1 4C ; Load X register $4CA1.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldx #$C5.b		; A2 C5 ; Load #$C5.b into X register [Writes: X Index] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora [$0A.b],Y		; 17 0A ; OR accumulator with memory (long indexed) [$0A.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $BEB239.l,X		; 9F 39 B2 BE ; Store accumulator (long,X) $BEB239.l,X [Reads: Accumulator, X Index]
	eor $A73A.w,Y		; 59 3A A7 ; Exclusive OR accumulator with memory $A73A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($A8.b,S),Y		; 53 A8 ; XOR accumulator (stack relative indirect indexed) ($A8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	rol $0B.b		; 26 0B ; Rotate left $0B.b [Reads: Direct Page] [Flags: NCZ]
	ldx $A13B.w		; AE 3B A1 ; Load $A13B.w into X register [Writes: X Index] [Flags: NZ]
	.db $10, $56		; 10 56 ; Branch if plus to $10, $56 [Flow: branch]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	bit $E55D.w,X		; 3C 5D E5 ; Test bits $E55D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ora #$430B.w		; 09 0B 43 ; Logical OR #$430B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $1F.b		; 24 1F ; Test bits $1F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $F9.b		; 00 F9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $3D, $01		; 62 3D 01 ; Push effective relative address $62, $3D, $01 [Writes: Stack Pointer]
	sbc #$6257.w		; E9 57 62 ; Subtract #$6257.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora $A1.b		; 05 A1 ; Logical OR $A1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $3332.w,Y		; 19 32 33 ; OR accumulator with memory $3332.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$A2.b		; A0 A2 ; Load #$A2.b into Y register [Writes: Y Index] [Flags: NZ]
	adc $43.b,S		; 63 43 ; Add with carry (stack relative) $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda [$63.b],Y		; B7 63 ; Load accumulator (long indexed) [$63.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$83.b]		; 47 83 ; Exclusive OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $46.b		; 00 46 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	eor $014C4B.l		; 4F 4B 4C 01 ; Exclusive OR accumulator with memory (long) $014C4B.l [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $9F06.w		; 4D 06 9F ; Exclusive OR $9F06.w with accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $EB.b,X		; D5 EB ; Compare accumulator $EB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	lsr $07.b,X		; 56 07 ; Logical shift right $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $92.b,X		; 56 92 ; Logical shift right $92.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $544E.w,Y		; 79 4E 54 ; Add $544E.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $F5.b		; 06 F5 ; Arithmetic shift left $F5.b [Reads: Direct Page] [Flags: NCZ]
	lsr $0622.w,X		; 5E 22 06 ; Logical shift right $0622.w,X [Reads: X Index] [Flags: NCZ]
	brk $0B.b		; 00 0B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $040801.l,X		; FF 01 08 04 ; Subtract with carry (long,X) $040801.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $000C08.l		; 22 08 0C 00 ; Jump to subroutine long $000C08.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0406.w		; 0C 06 04 ; Test and set bits $0406.w [Reads: Accumulator] [Flags: Z]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	ora #$0823.w		; 09 23 08 ; Logical OR #$0823.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $1B.b,S		; 23 1B ; AND accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $04071B.l		; 22 1B 07 04 ; Jump to subroutine long $04071B.l [Writes: Stack Pointer] [Flow: call]
	tsb $0C16.w		; 0C 16 0C ; Test and set bits $0C16.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1B2303.l		; 22 03 23 1B ; Jump to subroutine long $1B2303.l [Writes: Stack Pointer] [Flow: call]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($07.b),Y		; 11 07 ; OR accumulator with memory ($07.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	jsl $0B0A22.l		; 22 22 0A 0B ; Jump to subroutine long $0B0A22.l [Writes: Stack Pointer] [Flow: call]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $0306.w		; 0E 06 03 ; Arithmetic shift left $0306.w [Flags: NCZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $150A1B.l		; 22 1B 0A 15 ; Jump to subroutine long $150A1B.l [Writes: Stack Pointer] [Flow: call]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $15.b,S		; 23 15 ; AND accumulator with stack relative $15.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $0D041B.l		; 22 1B 04 0D ; Jump to subroutine long $0D041B.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $16.b,X		; 16 16 ; Arithmetic shift left $16.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $1B23.w		; 0D 23 1B ; Logical OR $1B23.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $1B23.w		; 0D 23 1B ; Logical OR $1B23.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1B.b]		; 07 1B ; OR accumulator with memory (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $008305.l		; 0F 05 83 00 ; OR accumulator with memory (long) $008305.l [Writes: Accumulator] [Flags: NZ]
	adc ($07.b),Y		; 71 07 ; Add with carry ($07.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$1B.b]		; 07 1B ; OR accumulator with memory (long) [$1B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: NCZ]
	ora [$0B.b]		; 07 0B ; OR accumulator with memory (long) [$0B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $1B.b		; 24 1B ; Test bits $1B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $1B030F.l		; 22 0F 03 1B ; Jump to subroutine long $1B030F.l [Writes: Stack Pointer] [Flow: call]
	ora $0106.w,Y		; 19 06 01 ; OR accumulator with memory $0106.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $0B091B.l		; 22 1B 09 0B ; Jump to subroutine long $0B091B.l [Writes: Stack Pointer] [Flow: call]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $1B0606.l		; 0F 06 06 1B ; OR accumulator with memory (long) $1B0606.l [Writes: Accumulator] [Flags: NZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $02.b,S		; 23 02 ; AND accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $030306.l		; 22 06 03 03 ; Jump to subroutine long $030306.l [Writes: Stack Pointer] [Flow: call]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	rol $02.b		; 26 02 ; Rotate left $02.b [Reads: Direct Page] [Flags: NCZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1511.w		; 0D 11 15 ; Logical OR $1511.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $0A0001.l		; 22 01 00 0A ; Jump to subroutine long $0A0001.l [Writes: Stack Pointer] [Flow: call]
	jsl $0E0801.l		; 22 01 08 0E ; Jump to subroutine long $0E0801.l [Writes: Stack Pointer] [Flow: call]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03010D.l		; 0F 0D 01 03 ; OR accumulator with memory (long) $03010D.l [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	sbc $0D02.w		; ED 02 0D ; Subtract $0D02.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $4C20E0.l,X		; FF E0 20 4C ; Subtract with carry (long,X) $4C20E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $4CA1.w		; 4E A1 4C ; Logical shift right $4CA1.w [Flags: NCZ]
	ldx #$1C.b		; A2 1C ; Load #$1C.b into X register [Writes: X Index] [Flags: NZ]
	eor $1D1D8E.l		; 4F 8E 1D 1D ; Exclusive OR accumulator with memory (long) $1D1D8E.l [Writes: Accumulator] [Flags: NZ]
	eor [$1D.b]		; 47 1D ; Exclusive OR accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stx $0D32.w		; 8E 32 0D ; Store X register to $0D32.w [Reads: X Index]
	eor ($3D.b,S),Y		; 53 3D ; XOR accumulator (stack relative indirect indexed) ($3D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	rol $504F.w,X		; 3E 4F 50 ; Rotate left $504F.w,X [Reads: X Index] [Flags: NCZ]
	rol $921D.w,X		; 3E 1D 92 ; Rotate left $921D.w,X [Reads: X Index] [Flags: NCZ]
	sta ($8E.b,S),Y		; 93 8E ; Store accumulator (stack relative indirect indexed) ($8E.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ldx $8B90.w		; AE 90 8B ; Load $8B90.w into X register [Writes: X Index] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $62, $AC, $63		; 62 AC 63 ; Push effective relative address $62, $AC, $63 [Writes: Stack Pointer]
	eor ($0B.b),Y		; 51 0B ; Exclusive OR accumulator with memory ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $55		; 90 55 ; Branch if carry clear to $90, $55 [Flow: branch]
	lsr $4B.b,X		; 56 4B ; Logical shift right $4B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $BA7C.w		; AE 7C BA ; Load $BA7C.w into X register [Writes: X Index] [Flags: NZ]
	mvn $A2,$4C		; 54 4C A2 ; Move block negative $A2,$4C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $2262.w,X		; 1D 62 22 ; OR accumulator with memory $2262.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $57.b,S		; 63 57 ; Add with carry (stack relative) $57.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	eor ($5B.b,S),Y		; 53 5B ; XOR accumulator (stack relative indirect indexed) ($5B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta [$04.b],Y		; 97 04 ; Store accumulator (long indexed) [$04.b],Y [Reads: Direct Page, Y Index, Accumulator]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($A8.b,S),Y		; 53 A8 ; XOR accumulator (stack relative indirect indexed) ($A8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp $092234.l		; 5C 34 22 09 ; Jump long to $092234.l [Flow: jump]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	eor $6A45.w,X		; 5D 45 6A ; Exclusive OR accumulator with memory $6A45.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($C9.b)		; 32 C9 ; AND accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($3B.b)		; B2 3B ; Load accumulator (indirect) ($3B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $770B.w		; AE 0B 77 ; Load $770B.w into X register [Writes: X Index] [Flags: NZ]
	.db $62, $5E, $0A		; 62 5E 0A ; Push effective relative address $62, $5E, $0A [Writes: Stack Pointer]
	dec $98A7.w,X		; DE A7 98 ; Decrement memory $98A7.w,X [Reads: X Index] [Flags: NZ]
	sta $1E47.w,Y		; 99 47 1E ; Store accumulator to $1E47.w,Y [Reads: Y Index, Accumulator]
	adc ($72.b),Y		; 71 72 ; Add with carry ($72.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1D.b		; E5 1D ; Subtract $1D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $6162.w,X		; 1D 62 61 ; OR accumulator with memory $6162.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $E1.b,S		; 63 E1 ; Add with carry (stack relative) $E1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $47DDA1.l		; 0F A1 DD 47 ; OR accumulator with memory (long) $47DDA1.l [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	rol $5A77.w,X		; 3E 77 5A ; Rotate left $5A77.w,X [Reads: X Index] [Flags: NCZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($64.b)		; 32 64 ; AND accumulator with memory (indirect) ($64.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $E5.b		; 65 E5 ; Add $E5.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $AC.b		; 66 AC ; Rotate right $AC.b [Reads: Direct Page] [Flags: NCZ]
	lda $63C0.w		; AD C0 63 ; Load $63C0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc [$06.b]		; 67 06 ; Add with carry (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and ($C9.b)		; 32 C9 ; AND accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $DE		; 90 DE ; Branch if carry clear to $90, $DE [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $63.b		; E5 63 ; Subtract $63.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($28E0.w)		; 6C E0 28 ; Jump indirect to ($28E0.w) [Flow: jump]
	adc [$A1.b]		; 67 A1 ; Add with carry (long) [$A1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $70, $06		; 70 06 ; Branch if overflow set to $70, $06 [Flow: branch]
	adc ($1E.b),Y		; 71 1E ; Add with carry ($1E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($C9.b)		; 32 C9 ; AND accumulator with memory (indirect) ($C9.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $A5.b		; E5 A5 ; Subtract $A5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $CC4B6A.l,X		; 1F 6A 4B CC ; Logical OR long $CC4B6A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($ED.b)		; 72 ED ; Add with carry (indirect) ($ED.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpy $CEA1.w		; CC A1 CE ; Compare $CEA1.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldx $3B.b		; A6 3B ; Load $3B.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda #$4140.w		; A9 40 41 ; Load #$4140.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($08.b,S),Y		; 73 08 ; Add with carry (stack relative indirect indexed) ($08.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	stz $9B.b,X		; 74 9B ; Store zero to $9B.b,X [Reads: X Index]
	eor $7675.w,Y		; 59 75 76 ; Exclusive OR accumulator with memory $7675.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc #$2B75.w		; E9 75 2B ; Subtract #$2B75.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc [$53.b],Y		; 77 53 ; Add with carry (long indexed) [$53.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stx $4079.w		; 8E 79 40 ; Store X register to $4079.w [Reads: X Index]
	stz $7A63.w		; 9C 63 7A ; Store zero to $7A63.w
	brk $7A.b		; 00 7A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $7E104C.l		; 22 4C 10 7E ; Jump to subroutine long $7E104C.l [Writes: Stack Pointer] [Flow: call]
	sbc $7F06A7.l		; EF A7 06 7F ; Subtract with carry (long) $7F06A7.l [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $79		; 80 79 ; Branch always to $80, $79 [Flow: branch]
	lda [$A0.b]		; A7 A0 ; Load accumulator (long) [$A0.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$18.b		; A0 18 ; Load #$18.b into Y register [Writes: Y Index] [Flags: NZ]
	sta [$A0.b],Y		; 97 A0 ; Store accumulator (long indexed) [$A0.b],Y [Reads: Direct Page, Y Index, Accumulator]
	sta ($06.b,X)		; 81 06 ; Store accumulator ($06.b,X) [Reads: Direct Page, Accumulator, X Index]
	cmp $2382.w,X		; DD 82 23 ; Compare accumulator $2382.w,X [Reads: X Index] [Flags: NCZ]
	eor $9706.w,Y		; 59 06 97 ; Exclusive OR accumulator with memory $9706.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$A0.b		; A0 A0 ; Load #$A0.b into Y register [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta $5C.b,S		; 83 5C ; Store accumulator (stack relative) $5C.b,S [Reads: Stack Pointer, Accumulator]
	.db $62, $84, $02		; 62 84 02 ; Push effective relative address $62, $84, $02 [Writes: Stack Pointer]
	stx $87.b		; 86 87 ; Store X register to $87.b [Reads: X Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $4C.b		; 25 4C ; Logical AND $4C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lsr $EB.b		; 46 EB ; Logical shift right $EB.b [Reads: Direct Page] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sta $5DB72F.l,X		; 9F 2F B7 5D ; Store accumulator (long,X) $5DB72F.l,X [Reads: Accumulator, X Index]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$81EB.w		; 49 EB 81 ; Exclusive OR #$81EB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $4310EB.l		; 22 EB 10 43 ; Jump to subroutine long $4310EB.l [Writes: Stack Pointer] [Flow: call]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor ($06.b,S),Y		; 53 06 ; XOR accumulator (stack relative indirect indexed) ($06.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $DD.b,S		; 63 DD ; Add with carry (stack relative) $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $002E.w,X		; 1D 2E 00 ; OR accumulator with memory $002E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	sbc $010704.l,X		; FF 04 07 01 ; Subtract with carry (long,X) $010704.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	eor $1B.b,S		; 43 1B ; Exclusive OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($18.b)		; 12 18 ; OR accumulator with memory (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora ($1B.b)		; 12 1B ; OR accumulator with memory (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0701.w		; 0D 01 07 ; Logical OR $0701.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($07.b)		; 12 07 ; OR accumulator with memory (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $0204.w		; 0D 04 02 ; Logical OR $0204.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $12431B.l		; 22 1B 43 12 ; Jump to subroutine long $12431B.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $03080E.l		; 22 0E 08 03 ; Jump to subroutine long $03080E.l [Writes: Stack Pointer] [Flow: call]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $1B		; 10 1B ; Branch if plus to $10, $1B [Flow: branch]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $0E.b,S		; 23 0E ; AND accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $070E.w		; 0E 0E 07 ; Arithmetic shift left $070E.w [Flags: NCZ]
	and $1B.b,S		; 23 1B ; AND accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	asl $020E.w		; 0E 0E 02 ; Arithmetic shift left $020E.w [Flags: NCZ]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $020B.w		; 0E 0B 02 ; Arithmetic shift left $020B.w [Flags: NCZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0600.w		; 0E 00 06 ; Arithmetic shift left $0600.w [Flags: NCZ]
	and $0E.b,S		; 23 0E ; AND accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$24.b		; E0 24 ; Compare #$24.b with X register [Reads: X Index] [Flags: NCZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $03.b,X		; 16 03 ; Arithmetic shift left $03.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02020F.l		; 0F 0F 02 02 ; OR accumulator with memory (long) $02020F.l [Writes: Accumulator] [Flags: NZ]
	asl $0C05.w		; 0E 05 0C ; Arithmetic shift left $0C05.w [Flags: NCZ]
	jsl $1B1007.l		; 22 07 10 1B ; Jump to subroutine long $1B1007.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C071B.l		; 0F 1B 07 0C ; OR accumulator with memory (long) $0C071B.l [Writes: Accumulator] [Flags: NZ]
	ora #$0507.w		; 09 07 05 ; Logical OR #$0507.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $03051B.l		; 22 1B 05 03 ; Jump to subroutine long $03051B.l [Writes: Stack Pointer] [Flow: call]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $830725.l		; 0F 25 07 83 ; OR accumulator with memory (long) $830725.l [Writes: Accumulator] [Flags: NZ]
	brk $76.b		; 00 76 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $05271B.l		; 22 1B 27 05 ; Jump to subroutine long $05271B.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ror $01.b,X		; 76 01 ; Rotate right $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $0743.w		; 0E 43 07 ; Arithmetic shift left $0743.w [Flags: NCZ]
	ora #$0622.w		; 09 22 06 ; Logical OR #$0622.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1B.b,S		; 23 1B ; AND accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $001B06.l		; 0F 06 1B 00 ; OR accumulator with memory (long) $001B06.l [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $121B.w		; 0E 1B 12 ; Arithmetic shift left $121B.w [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and [$08.b],Y		; 37 08 ; AND accumulator with memory (long indexed) [$08.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0E0601.l		; 22 01 06 0E ; Jump to subroutine long $0E0601.l [Writes: Stack Pointer] [Flow: call]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0B01.w		; 0D 01 0B ; Logical OR $0B01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0E0B.w		; 0E 0B 0E ; Arithmetic shift left $0E0B.w [Flags: NCZ]
	sbc $5221E0.l,X		; FF E0 21 52 ; Subtract with carry (long,X) $5221E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($1C.b,S),Y		; 93 1C ; Store accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora $8A89.w,X		; 1D 89 8A ; OR accumulator with memory $8A89.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $8B.b,Y		; 96 8B ; Store X register $8B.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	stx $2F.b,Y		; 96 2F ; Store X register $2F.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sty $962F.w		; 8C 2F 96 ; Store Y register to $962F.w [Reads: Y Index]
	sta $FCF7.w		; 8D F7 FC ; Store accumulator to $FCF7.w [Reads: Accumulator]
	eor ($93.b)		; 52 93 ; Exclusive OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda #$8EF8.w		; A9 F8 8E ; Load #$8EF8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $05.b,Y		; 96 05 ; Store X register $05.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sta $BDF890.l		; 8F 90 F8 BD ; Store accumulator (long) $BDF890.l [Reads: Accumulator]
	sbc $6192.w,Y		; F9 92 61 ; Subtract with carry $6192.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($93.b)		; 52 93 ; Exclusive OR accumulator with memory (indirect) ($93.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $91, $04		; 62 91 04 ; Push effective relative address $62, $91, $04 [Writes: Stack Pointer]
	sta $968A.w		; 8D 8A 96 ; Store accumulator to $968A.w [Reads: Accumulator]
	sty $92.b,X		; 94 92 ; Store Y register $92.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	.db $62, $00, $0B		; 62 00 0B ; Push effective relative address $62, $00, $0B [Writes: Stack Pointer]
	lsr $57.b,X		; 56 57 ; Logical shift right $57.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $5C.b,X		; 15 5C ; OR accumulator with memory $5C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($95.b,S),Y		; 93 95 ; Store accumulator (stack relative indirect indexed) ($95.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	clv		; B8 ; Clear overflow flag [Flags: V]
	stx $5E.b,Y		; 96 5E ; Store X register $5E.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sta [$98.b],Y		; 97 98 ; Store accumulator (long indexed) [$98.b],Y [Reads: Direct Page, Y Index, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $09.b,S		; 63 09 ; Add with carry (stack relative) $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $A1.b,S		; 03 A1 ; OR accumulator with stack relative $A1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $520E.w		; 0D 0E 52 ; Logical OR $520E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $99.b,S		; 63 99 ; Add with carry (stack relative) $99.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	ora ($14.b,S),Y		; 13 14 ; OR accumulator (stack relative indirect indexed) ($14.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	.db $62, $15, $0D		; 62 15 0D ; Push effective relative address $62, $15, $0D [Writes: Stack Pointer]
	ora $5B.b,X		; 15 5B ; OR accumulator with memory $5B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $6AA0.w,Y		; D9 A0 6A ; Compare accumulator $6AA0.w,Y [Reads: Y Index] [Flags: NCZ]
	ora $1918.w,X		; 1D 18 19 ; OR accumulator with memory $1918.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($6A.b)		; B2 6A ; Load accumulator (indirect) ($6A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $62, $18, $E0		; 62 18 E0 ; Push effective relative address $62, $18, $E0 [Writes: Stack Pointer]
	eor ($FB.b,X)		; 41 FB ; Exclusive OR accumulator with memory ($FB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $18.b		; E5 18 ; Subtract $18.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp $C2C2.w,Y		; D9 C2 C2 ; Compare accumulator $C2C2.w,Y [Reads: Y Index] [Flags: NCZ]
	sta $1D9E.w,X		; 9D 9E 1D ; Store accumulator to $1D9E.w,X [Reads: Accumulator, X Index]
	sta $03C2A0.l,X		; 9F A0 C2 03 ; Store accumulator (long,X) $03C2A0.l,X [Reads: Accumulator, X Index]
	tsb $C2.b		; 04 C2 ; Test and set bits $C2.b [Reads: Accumulator] [Flags: Z]
.ACCU 16
	rep #$E4		; C2 E4
	sbc $BD.b		; E5 BD ; Subtract $BD.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	lda ($A2.b,X)		; A1 A2 ; Load accumulator ($A2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9A72.w,X		; 1D 72 9A ; OR accumulator with memory $9A72.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	adc [$68.b]		; 67 68 ; Add with carry (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	mvn $80,$18		; 54 18 80 ; Move block negative $80,$18 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $80, $A3		; 80 A3 ; Branch always to $80, $A3 [Flow: branch]
	ldy $DA.b		; A4 DA ; Load $DA.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda $32.b		; A5 32 ; Load $32.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $72.b		; A6 72 ; Load $72.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda [$80.b]		; A7 80 ; Load accumulator (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $243E.w,X		; 7E 3E 24 ; Rotate right $243E.w,X [Reads: X Index] [Flags: NCZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($E5.b)		; B2 E5 ; Load accumulator (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $A4.b,X		; 75 A4 ; Add $A4.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$6232.w		; A9 32 62 ; Load #$6232.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($AA.b)		; B2 AA ; Load accumulator (indirect) ($AA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	dec $8B25.w,X		; DE 25 8B ; Decrement memory $8B25.w,X [Reads: X Index] [Flags: NZ]
	tsb $AC.b		; 04 AC ; Test and set bits $AC.b [Reads: Accumulator] [Flags: Z]
	lda $721D.w		; AD 1D 72 ; Load $721D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($62.b),Y		; 71 62 ; Add with carry ($62.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $D901.w		; AE 01 D9 ; Load $D901.w into X register [Writes: X Index] [Flags: NZ]
	sbc $25.b		; E5 25 ; Subtract $25.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($09.b),Y		; 71 09 ; Add with carry ($09.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($B2.b),Y		; B1 B2 ; Load accumulator ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $B379.w,X		; 1D 79 B3 ; OR accumulator with memory $B379.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$41.b],Y		; 37 41 ; AND accumulator with memory (long indexed) [$41.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $B4.b,S		; 63 B4 ; Add with carry (stack relative) $B4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$37.b		; E0 37 ; Compare #$37.b with X register [Reads: X Index] [Flags: NCZ]
	ldy #$B8.b		; A0 B8 ; Load #$B8.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $30.b		; A5 30 ; Load $30.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	stz $8B8B.w		; 9C 8B 8B ; Store zero to $8B8B.w
	jmp $3B4C.w		; 4C 4C 3B ; Jump to $3B4C.w [Flow: jump]
	lda $BA8D.w,Y		; B9 8D BA ; Load $BA8D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	eor ($FB.b,S),Y		; 53 FB ; XOR accumulator (stack relative indirect indexed) ($FB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $41B2.w,X		; 1E B2 41 ; Arithmetic shift left $41B2.w,X [Reads: X Index] [Flags: NCZ]
	and $42BDBC.l,X		; 3F BC BD 42 ; AND accumulator with memory (long,X) $42BDBC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $EB.b,S		; 43 EB ; Exclusive OR accumulator with stack relative $EB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $5E,$8D		; 44 8D 5E ; Move block positive $5E,$8D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	stx $53.b		; 86 53 ; Store X register to $53.b [Reads: X Index]
	ora $DEAA.w,X		; 1D AA DE ; OR accumulator with memory $DEAA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($48.b,X)		; 41 48 ; Exclusive OR accumulator with memory ($48.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor #$4A43.w		; 49 43 4A ; Exclusive OR #$4A43.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $FF.b		; 46 FF ; Logical shift right $FF.b [Reads: Direct Page] [Flags: NCZ]
	asl $5F.b		; 06 5F ; Arithmetic shift left $5F.b [Reads: Direct Page] [Flags: NCZ]
	sbc $1D.b,S		; E3 1D ; Subtract stack-relative $1D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda #$1C1D.w		; A9 1D 1C ; Load #$1C1D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $521D.w,X		; 1D 1D 52 ; OR accumulator with memory $521D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($6A.b,S),Y		; 53 6A ; XOR accumulator (stack relative indirect indexed) ($6A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$5E.b]		; 47 5E ; Exclusive OR accumulator with memory (long) [$5E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $1B0206.l,X		; FF 06 02 1B ; Subtract with carry (long,X) $1B0206.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $02.b,X		; 16 02 ; Arithmetic shift left $02.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $0D0501.l		; 22 01 05 0D ; Jump to subroutine long $0D0501.l [Writes: Stack Pointer] [Flow: call]
	ora #$0201.w		; 09 01 02 ; Logical OR #$0201.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	jsl $1B030F.l		; 22 0F 03 1B ; Jump to subroutine long $1B030F.l [Writes: Stack Pointer] [Flow: call]
	ora $220F01.l		; 0F 01 0F 22 ; OR accumulator with memory (long) $220F01.l [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1B22.w		; 0E 22 1B ; Arithmetic shift left $1B22.w [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1B.b,S		; 23 1B ; AND accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1B22.w		; 0E 22 1B ; Arithmetic shift left $1B22.w [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $08051B.l		; 22 1B 05 08 ; Jump to subroutine long $08051B.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora #$0101.w		; 09 01 01 ; Logical OR #$0101.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $04.b		; 02 04 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($45.b,X)		; 01 45 ; Logical OR ($45.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $02011B.l		; 22 1B 01 02 ; Jump to subroutine long $02011B.l [Writes: Stack Pointer] [Flow: call]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	jsl $010A1B.l		; 22 1B 0A 01 ; Jump to subroutine long $010A1B.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1B0E.w		; 0E 0E 1B ; Arithmetic shift left $1B0E.w [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $1B.b,S		; 23 1B ; AND accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $060107.l		; 22 07 01 06 ; Jump to subroutine long $060107.l [Writes: Stack Pointer] [Flow: call]
	ora #$1B24.w		; 09 24 1B ; Logical OR #$1B24.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0301.w,Y		; 19 01 03 ; OR accumulator with memory $0301.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1B0507.l		; 0F 07 05 1B ; OR accumulator with memory (long) $1B0507.l [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $0107.w,Y		; 19 07 01 ; OR accumulator with memory $0107.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$0707.w		; 09 07 07 ; Logical OR #$0707.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0809.w		; 09 09 08 ; Logical OR #$0809.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and ($03.b,S),Y		; 33 03 ; AND accumulator (stack relative indirect indexed) ($03.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0C050F.l		; 0F 0F 05 0C ; OR accumulator with memory (long) $0C050F.l [Writes: Accumulator] [Flags: NZ]
	jsl $02011B.l		; 22 1B 01 02 ; Jump to subroutine long $02011B.l [Writes: Stack Pointer] [Flow: call]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1B07.w		; 0E 07 1B ; Arithmetic shift left $1B07.w [Flags: NCZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $830807.l		; 0F 07 08 83 ; OR accumulator with memory (long) $830807.l [Writes: Accumulator] [Flags: NZ]
	brk $49.b		; 00 49 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1B040E.l		; 22 0E 04 1B ; Jump to subroutine long $1B040E.l [Writes: Stack Pointer] [Flow: call]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8F.b		; 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	sbc [$03.b]		; E7 03 ; Subtract with carry (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $FF.b		; 02 FF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $7A.b		; 06 7A ; Arithmetic shift left $7A.b [Reads: Direct Page] [Flags: NCZ]
	ldx $DDD3.w,Y		; BE D3 DD ; Load X register $DDD3.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta ($65.b),Y		; 91 65 ; Store accumulator ($65.b),Y [Reads: Direct Page, Y Index, Accumulator]
	jsl $BF0220.l		; 22 20 02 BF ; Jump to subroutine long $BF0220.l [Writes: Stack Pointer] [Flow: call]
	ora $4B.b,S		; 03 4B ; OR accumulator with stack relative $4B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $FA0C03.l		; 22 03 0C FA ; Jump to subroutine long $FA0C03.l [Writes: Stack Pointer] [Flow: call]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sbc $7491.w		; ED 91 74 ; Subtract $7491.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta [$4A.b],Y		; 97 4A ; Store accumulator (long indexed) [$4A.b],Y [Reads: Direct Page, Y Index, Accumulator]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	cpy #$4B.b		; C0 4B ; Compare #$4B.b with Y register [Reads: Y Index] [Flags: NCZ]
	ora $4B.b,S		; 03 4B ; OR accumulator with stack relative $4B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $C1, $06		; 62 C1 06 ; Push effective relative address $62, $C1, $06 [Writes: Stack Pointer]
	and $C4.b,X		; 35 C4 ; Logical AND $C4.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $7A.b		; C5 7A ; Compare $7A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($75.b,X)		; 01 75 ; Logical OR ($75.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $C662.w		; 0E 62 C6 ; Arithmetic shift left $C662.w [Flags: NCZ]
	brk $43.b		; 00 43 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $C9, $E0		; 62 C9 E0 ; Push effective relative address $62, $C9, $E0 [Writes: Stack Pointer]
	jsl $1E3535.l		; 22 35 35 1E ; Jump to subroutine long $1E3535.l [Writes: Stack Pointer] [Flow: call]
	cpx $7A.b		; E4 7A ; Compare $7A.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $75.b,S		; 03 75 ; OR accumulator with stack relative $75.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $82, $5B, $CC		; 82 5B CC ; Branch always long to $82, $5B, $CC [Flow: branch]
	sbc $4D.b		; E5 4D ; Subtract $4D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $092B.w		; 4E 2B 09 ; Logical shift right $092B.w [Flags: NCZ]
	cmp $2743.w		; CD 43 27 ; Compare $2743.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	dec $DE26.w		; CE 26 DE ; Decrement $DE26.w [Flags: NZ]
	sbc ($82.b,S),Y		; F3 82 ; Subtract with carry (stack relative indirect indexed) ($82.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $7E, $A5		; 82 7E A5 ; Branch always long to $82, $7E, $A5 [Flow: branch]
	trb $5857.w		; 1C 57 58 ; Test and reset bits $5857.w [Reads: Accumulator] [Flags: Z]
	rol $CF0E.w		; 2E 0E CF ; Rotate left $CF0E.w [Flags: NCZ]
	lsr $092B.w		; 4E 2B 09 ; Logical shift right $092B.w [Flags: NCZ]
	.db $62, $D0, $01		; 62 D0 01 ; Push effective relative address $62, $D0, $01 [Writes: Stack Pointer]
	.db $82, $82, $22		; 82 82 22 ; Branch always long to $82, $82, $22 [Flow: branch]
.INDEX 16
	rep #$1C		; C2 1C
	ldy #$80D3.w		; A0 D3 80 ; Load #$80D3.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $D4		; 80 D4 ; Branch always to $80, $D4 [Flow: branch]
	cmp $2E.b,X		; D5 2E ; Compare accumulator $2E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $1BD6.w		; 0E D6 1B ; Arithmetic shift left $1BD6.w [Flags: NCZ]
	lda #$6482.w		; A9 82 64 ; Load #$6482.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $D9D71F.l,X		; 1F 1F D7 D9 ; Logical OR long $D9D71F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	cmp $DAD9.w,Y		; D9 D9 DA ; Compare accumulator $DAD9.w,Y [Reads: Y Index] [Flags: NCZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sta $37D9.w,Y		; 99 D9 37 ; Store accumulator to $37D9.w,Y [Reads: Y Index, Accumulator]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	stz $67.b		; 64 67 ; Store zero to $67.b
	jsl $1A0180.l		; 22 80 01 1A ; Jump to subroutine long $1A0180.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit $DC.b		; 24 DC ; Test bits $DC.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $50E6A0.l,X		; FF A0 E6 50 ; Subtract with carry (long,X) $50E6A0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$C3.b]		; 67 C3 ; Add with carry (long) [$C3.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $DD.b		; E5 DD ; Subtract $DD.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $1AA424.l,X		; FF 24 A4 1A ; Subtract with carry (long,X) $1AA424.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $BBD9.w		; 20 D9 BB ; Jump to subroutine at $BBD9.w [Writes: Stack Pointer] [Flow: call]
	lsr $76.b,X		; 56 76 ; Logical shift right $76.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $A5E5.w,X		; DE E5 A5 ; Decrement memory $A5E5.w,X [Reads: X Index] [Flags: NZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $26264F.l,X		; DF 4F 26 26 ; Compare accumulator (long,X) $26264F.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	eor ($98.b),Y		; 51 98 ; Exclusive OR accumulator with memory ($98.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $E0DF.w,X		; BD DF E0 ; Load $E0DF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $77.b		; C5 77 ; Compare $77.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $82, $3B, $E5		; 82 3B E5 ; Branch always long to $82, $3B, $E5 [Flow: branch]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $22E1.w		; 6E E1 22 ; Rotate right $22E1.w [Flags: NCZ]
	sep #$02		; E2 02 ; Set processor status bits #$02 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	sbc $5A.b,S		; E3 5A ; Subtract stack-relative $5A.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	sbc $62.b		; E5 62 ; Subtract $62.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx $11.b		; E4 11 ; Compare $11.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sbc [$8B.b]		; E7 8B ; Subtract with carry (long) [$8B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	tsb $E8.b		; 04 E8 ; Test and set bits $E8.b [Reads: Accumulator] [Flags: Z]
	mvn $EA,$E9		; 54 E9 EA ; Move block negative $EA,$E9 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rol $E3D3.w,X		; 3E D3 E3 ; Rotate left $E3D3.w,X [Reads: X Index] [Flags: NCZ]
	mvn $E5,$E4		; 54 E4 E5 ; Move block negative $E5,$E4 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $EC0C42.l		; 22 42 0C EC ; Jump to subroutine long $EC0C42.l [Writes: Stack Pointer] [Flow: call]
	eor $01.b,X		; 55 01 ; Exclusive OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($ED.b),Y		; D1 ED ; Compare accumulator ($ED.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	eor $E4B295.l,X		; 5F 95 B2 E4 ; Exclusive OR accumulator with memory (long,X) $E4B295.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $8277.w		; EE 77 82 ; Increment $8277.w [Flags: NZ]
	.db $82, $22, $46		; 82 22 46 ; Branch always long to $82, $22, $46 [Flow: branch]
	ora $06A1EF.l		; 0F EF A1 06 ; OR accumulator with memory (long) $06A1EF.l [Writes: Accumulator] [Flags: NZ]
	eor ($DC.b,S),Y		; 53 DC ; XOR accumulator (stack relative indirect indexed) ($DC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	cpx $B9.b		; E4 B9 ; Compare $B9.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$82.b],Y		; 77 82 ; Add with carry (long indexed) [$82.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $06, $A6		; 82 06 A6 ; Branch always long to $82, $06, $A6 [Flow: branch]
	asl $43.b		; 06 43 ; Arithmetic shift left $43.b [Reads: Direct Page] [Flags: NCZ]
	asl $53.b		; 06 53 ; Arithmetic shift left $53.b [Reads: Direct Page] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	sbc [$03.b]		; E7 03 ; Subtract with carry (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $828277.l,X		; BF 77 82 82 ; Load long $828277.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $220322.l,X		; FF 22 03 22 ; Subtract with carry (long,X) $220322.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1B.b		; 05 1B ; Logical OR $1B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $010403.l		; 22 03 04 01 ; Jump to subroutine long $010403.l [Writes: Stack Pointer] [Flow: call]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $1B1E01.l		; 22 01 1E 1B ; Jump to subroutine long $1B1E01.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $1B1805.l		; 22 05 18 1B ; Jump to subroutine long $1B1805.l [Writes: Stack Pointer] [Flow: call]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $05.b,X		; 16 05 ; Arithmetic shift left $05.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $0E01.w		; 1C 01 0E ; Test and reset bits $0E01.w [Reads: Accumulator] [Flags: Z]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $0101.w		; 1C 01 01 ; Test and reset bits $0101.w [Reads: Accumulator] [Flags: Z]
	trb $0522.w		; 1C 22 05 ; Test and reset bits $0522.w [Reads: Accumulator] [Flags: Z]
	ora $10100A.l		; 0F 0A 10 10 ; OR accumulator with memory (long) $10100A.l [Writes: Accumulator] [Flags: NZ]
	trb $0101.w		; 1C 01 01 ; Test and reset bits $0101.w [Reads: Accumulator] [Flags: Z]
	ora $1C01.w,Y		; 19 01 1C ; OR accumulator with memory $1C01.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $0110.w		; 1C 10 01 ; Test and reset bits $0110.w [Reads: Accumulator] [Flags: Z]
	trb $050C.w		; 1C 0C 05 ; Test and reset bits $050C.w [Reads: Accumulator] [Flags: Z]
	asl $24.b		; 06 24 ; Arithmetic shift left $24.b [Reads: Direct Page] [Flags: NCZ]
	trb $010D.w		; 1C 0D 01 ; Test and reset bits $010D.w [Reads: Accumulator] [Flags: Z]
	tsb $0201.w		; 0C 01 02 ; Test and set bits $0201.w [Reads: Accumulator] [Flags: Z]
	trb $1C16.w		; 1C 16 1C ; Test and reset bits $1C16.w [Reads: Accumulator] [Flags: Z]
	trb $1C11.w		; 1C 11 1C ; Test and reset bits $1C11.w [Reads: Accumulator] [Flags: Z]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: NCZ]
	trb $2203.w		; 1C 03 22 ; Test and reset bits $2203.w [Reads: Accumulator] [Flags: Z]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $0C01.w		; 1C 01 0C ; Test and reset bits $0C01.w [Reads: Accumulator] [Flags: Z]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1C.b)		; 12 1C ; OR accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $2216.w		; 1C 16 22 ; Test and reset bits $2216.w [Reads: Accumulator] [Flags: Z]
	trb $0343.w		; 1C 43 03 ; Test and reset bits $0343.w [Reads: Accumulator] [Flags: Z]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $0D1C.w		; 1C 1C 0D ; Test and reset bits $0D1C.w [Reads: Accumulator] [Flags: Z]
	jsl $05061C.l		; 22 1C 06 05 ; Jump to subroutine long $05061C.l [Writes: Stack Pointer] [Flow: call]
	trb $121C.w		; 1C 1C 12 ; Test and reset bits $121C.w [Reads: Accumulator] [Flags: Z]
	ora $231C01.l		; 0F 01 1C 23 ; OR accumulator with memory (long) $231C01.l [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	bit $1C.b		; 24 1C ; Test bits $1C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $0202.w		; 1C 02 02 ; Test and reset bits $0202.w [Reads: Accumulator] [Flags: Z]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $041C.w		; 0C 1C 04 ; Test and set bits $041C.w [Reads: Accumulator] [Flags: Z]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	cop $1C.b		; 02 1C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0006.w		; 1C 06 00 ; Test and reset bits $0006.w [Reads: Accumulator] [Flags: Z]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $020001.l		; 22 01 00 02 ; Jump to subroutine long $020001.l [Writes: Stack Pointer] [Flow: call]
	and $00.b,S		; 23 00 ; AND accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1C22.w		; 0E 22 1C ; Arithmetic shift left $1C22.w [Flags: NCZ]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0101.w		; 1C 01 01 ; Test and reset bits $0101.w [Reads: Accumulator] [Flags: Z]
	tsb $0200.w		; 0C 00 02 ; Test and set bits $0200.w [Reads: Accumulator] [Flags: Z]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0207.w		; 0E 07 02 ; Arithmetic shift left $0207.w [Flags: NCZ]
	cop $1C.b		; 02 1C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0702.w		; 1C 02 07 ; Test and reset bits $0702.w [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $1C0101.l		; 22 01 01 1C ; Jump to subroutine long $1C0101.l [Writes: Stack Pointer] [Flow: call]
	trb $0123.w		; 1C 23 01 ; Test and reset bits $0123.w [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	trb $101C.w		; 1C 1C 10 ; Test and reset bits $101C.w [Reads: Accumulator] [Flags: Z]
	trb $030D.w		; 1C 0D 03 ; Test and reset bits $030D.w [Reads: Accumulator] [Flags: Z]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $0F02.w		; 1C 02 0F ; Test and reset bits $0F02.w [Reads: Accumulator] [Flags: Z]
	trb $FF1C.w		; 1C 1C FF ; Test and reset bits $FF1C.w [Reads: Accumulator] [Flags: Z]
	jsl $15226C.l		; 22 6C 22 15 ; Jump to subroutine long $15226C.l [Writes: Stack Pointer] [Flow: call]
	ora #$AAB5.w		; 09 B5 AA ; Logical OR #$AAB5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $F0.b		; 06 F0 ; Arithmetic shift left $F0.b [Reads: Direct Page] [Flags: NCZ]
	sta $F2F1.w		; 8D F1 F2 ; Store accumulator to $F2F1.w [Reads: Accumulator]
	adc ($06.b),Y		; 71 06 ; Add with carry ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($22.b,S),Y		; F3 22 ; Subtract with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($42E0.w)		; 6C E0 42 ; Jump indirect to ($42E0.w) [Flow: jump]
	ora $B1.b,X		; 15 B1 ; OR accumulator with memory $B1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $D4.b		; 25 D4 ; Logical AND $D4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $0A.b,X		; B5 0A ; Load $0A.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F4ED.w,X		; FD ED F4 ; Subtract with carry $F4ED.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $16.b,X		; F5 16 ; Subtract $16.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $F7F6.w		; 0C F6 F7 ; Test and set bits $F7F6.w [Reads: Accumulator] [Flags: Z]
	jmp ($2288.w)		; 6C 88 22 ; Jump indirect to ($2288.w) [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $D4E0.w,Y		; F9 E0 D4 ; Subtract with carry $D4E0.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stx $FF.b,Y		; 96 FF ; Store X register $FF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc #$FCFB.w		; 69 FB FC ; Add #$FCFB.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc [$D7.b],Y		; 77 D7 ; Add with carry (long indexed) [$D7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $E0.b		; 14 E0 ; Test and reset bits $E0.b [Reads: Accumulator] [Flags: Z]
	and $FD.b		; 25 FD ; Logical AND $FD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $FDECFF.l,X		; FF FF EC FD ; Subtract with carry (long,X) $FDECFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($69.b),Y		; 71 69 ; Add with carry ($69.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $FE.b,X		; D6 FE ; Decrement memory $FE.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda $74.b		; A5 74 ; Load $74.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$D7.b],Y		; 77 D7 ; Add with carry (long indexed) [$D7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $ECFF.w,X		; BD FF EC ; Load $ECFF.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$F9EC.w		; 09 EC F9 ; Logical OR #$F9EC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $E15C00.l,X		; FF 00 5C E1 ; Subtract with carry (long,X) $E15C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $01.b,X		; D6 01 ; Decrement memory $01.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc [$03.b],Y		; 77 03 ; Add with carry (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $140FFF.l		; 22 FF 0F 14 ; Jump to subroutine long $140FFF.l [Writes: Stack Pointer] [Flow: call]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	eor #$E86A.w		; 49 6A E8 ; Exclusive OR #$E86A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec $05.b,X		; [PATTERN: Memory clearing operation] D6 05 ; Decrement memory $05.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	asl $7F.b		; 06 7F ; Arithmetic shift left $7F.b [Reads: Direct Page] [Flags: NCZ]
	adc [$07.b],Y		; 77 07 ; Add with carry (long indexed) [$07.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $01EC.w,X		; 9E EC 01 ; Store zero to $01EC.w,X [Reads: X Index]
	stz $08.b		; 64 08 ; Store zero to $08.b
	ora $F50C.w,Y		; 19 0C F5 ; OR accumulator with memory $F50C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $DD.b,X		; D6 DD ; Decrement memory $DD.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	ora $0E1B.w		; 0D 1B 0E ; Logical OR $0E1B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0A1021.l		; 0F 21 10 0A ; OR accumulator with memory (long) $0A1021.l [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$13.b],Y		; 17 13 ; OR accumulator with memory (long indexed) [$13.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	dec $E6.b,X		; D6 E6 ; Decrement memory $E6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $42, $05		; 42 05 ; Reserved instruction
	stx $1514.w		; 8E 14 15 ; Store X register to $1514.w [Reads: X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $62, $16, $08		; 62 16 08 ; Push effective relative address $62, $16, $08 [Writes: Stack Pointer]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $19.b,X		; D6 19 ; Decrement memory $19.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc $1B62.w,X		; FE 62 1B ; Increment memory $1B62.w,X [Reads: X Index] [Flags: NZ]
	ora $1EEC.w		; 0D EC 1E ; Logical OR $1EEC.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $E5AF8E.l,X		; 1F 8E AF E5 ; Logical OR long $E5AF8E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $0303.w		; 20 03 03 ; Jump to subroutine at $0303.w [Writes: Stack Pointer] [Flow: call]
	dec $D6.b,X		; D6 D6 ; Decrement memory $D6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp $4E5E.w,X		; DD 5E 4E ; Compare accumulator $4E5E.w,X [Reads: X Index] [Flags: NCZ]
	stz $21.b		; 64 21 ; Store zero to $21.b
	cpx #$F820.w		; E0 20 F8 ; Compare #$F820.w with X register [Reads: X Index] [Flags: NCZ]
	rol $DA.b		; 26 DA ; Rotate left $DA.b [Reads: Direct Page] [Flags: NCZ]
	pei ($E4.b)		; D4 E4 ; Push effective indirect address ($E4.b) [Reads: Direct Page] [Writes: Stack Pointer]
	bit $D6.b		; 24 D6 ; Test bits $D6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	dec $27.b,X		; D6 27 ; Decrement memory $27.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda $5B5E6A.l,X		; BF 6A 5E 5B ; Load long $5B5E6A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and #$1D6A.w		; 29 6A 1D ; Logical AND #$1D6A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $0A.b		; E6 0A ; Increment $0A.b [Reads: Direct Page] [Flags: NZ]
	inc $1D.b		; E6 1D ; Increment $1D.b [Reads: Direct Page] [Flags: NZ]
	rol $D6D6.w		; 2E D6 D6 ; Rotate left $D6D6.w [Flags: NCZ]
	cmp $FB1D.w,X		; DD 1D FB ; Compare accumulator $FB1D.w,X [Reads: X Index] [Flags: NCZ]
	ora $41AA.w,X		; 1D AA 41 ; OR accumulator with memory $41AA.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $623B.w		; 4C 3B 62 ; Jump to $623B.w [Flow: jump]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	trb $2D8D.w		; 1C 8D 2D ; Test and reset bits $2D8D.w [Reads: Accumulator] [Flags: Z]
	dec $D6.b,X		; D6 D6 ; Decrement memory $D6.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $1D.b		; E6 1D ; Increment $1D.b [Reads: Direct Page] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $41.b		; 84 41 ; Store Y register to $41.b [Reads: Y Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$44EB.w		; 49 EB 44 ; Exclusive OR #$44EB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec $4C.b,X		; D6 4C ; Decrement memory $4C.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	jmp $A12E.w		; 4C 2E A1 ; Jump to $A12E.w [Flow: jump]
	dec $2F.b,X		; D6 2F ; Decrement memory $2F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp ($C6.b)		; D2 C6 ; Compare accumulator (indirect) ($C6.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	mvp $48,$44		; 44 44 48 ; Move block positive $48,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor #$306A.w		; 49 6A 30 ; Exclusive OR #$306A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and ($22.b),Y		; 31 22 ; AND accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cpx $3230.w		; EC 30 32 ; Compare $3230.w with X register [Reads: X Index] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($A9.b,S),Y		; 33 A9 ; AND accumulator (stack relative indirect indexed) ($A9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc ($6A.b),Y		; F1 6A ; Subtract with carry ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $30, $63		; 30 63 ; Branch if minus to $30, $63 [Flow: branch]
	bit $02.b,X		; 34 02 ; Test bits $02.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	bit $38.b,X		; 34 38 ; Test bits $38.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $02FF.w,Y		; 39 FF 02 ; AND accumulator with memory $02FF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $0403.w		; 1C 03 04 ; Test and reset bits $0403.w [Reads: Accumulator] [Flags: Z]
	jsl $030001.l		; 22 01 00 03 ; Jump to subroutine long $030001.l [Writes: Stack Pointer] [Flow: call]
	and $01.b		; 25 01 ; Logical AND $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0122.w		; 0E 22 01 ; Arithmetic shift left $0122.w [Flags: NCZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $190E.w		; 1C 0E 19 ; Test and reset bits $190E.w [Reads: Accumulator] [Flags: Z]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $0A28.w		; 0C 28 0A ; Test and set bits $0A28.w [Reads: Accumulator] [Flags: Z]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $101C.w,Y		; 19 1C 10 ; OR accumulator with memory $101C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	bit $021C.w		; 2C 1C 02 ; Test bits $021C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $25.b,S		; 03 25 ; OR accumulator with stack relative $25.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $0502.w		; 1C 02 05 ; Test and reset bits $0502.w [Reads: Accumulator] [Flags: Z]
	trb $2205.w		; 1C 05 22 ; Test and reset bits $2205.w [Reads: Accumulator] [Flags: Z]
	trb $0503.w		; 1C 03 05 ; Test and reset bits $0503.w [Reads: Accumulator] [Flags: Z]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $1100.w		; 1C 00 11 ; Test and reset bits $1100.w [Reads: Accumulator] [Flags: Z]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	trb $0206.w		; 1C 06 02 ; Test and reset bits $0206.w [Reads: Accumulator] [Flags: Z]
	tsb $1C10.w		; 0C 10 1C ; Test and set bits $1C10.w [Reads: Accumulator] [Flags: Z]
	trb $0710.w		; 1C 10 07 ; Test and reset bits $0710.w [Reads: Accumulator] [Flags: Z]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $0510.w		; 1C 10 05 ; Test and reset bits $0510.w [Reads: Accumulator] [Flags: Z]
	ora [$25.b]		; 07 25 ; OR accumulator with memory (long) [$25.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0504.w		; 1C 04 05 ; Test and reset bits $0504.w [Reads: Accumulator] [Flags: Z]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	trb $0509.w		; 1C 09 05 ; Test and reset bits $0509.w [Reads: Accumulator] [Flags: Z]
	ora ($05.b),Y		; 11 05 ; OR accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1C06.w		; 0D 06 1C ; Logical OR $1C06.w with accumulator [Writes: Accumulator] [Flags: NZ]
	trb $2405.w		; 1C 05 24 ; Test and reset bits $2405.w [Reads: Accumulator] [Flags: Z]
	trb $0504.w		; 1C 04 05 ; Test and reset bits $0504.w [Reads: Accumulator] [Flags: Z]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	ora $1C240F.l		; 0F 0F 24 1C ; OR accumulator with memory (long) $1C240F.l [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1C.b		; 24 1C ; Test bits $1C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	asl $0D1C.w		; 0E 1C 0D ; Arithmetic shift left $0D1C.w [Flags: NCZ]
	trb $0E1C.w		; 1C 1C 0E ; Test and reset bits $0E1C.w [Reads: Accumulator] [Flags: Z]
	trb $051C.w		; 1C 1C 05 ; Test and reset bits $051C.w [Reads: Accumulator] [Flags: Z]
	bit $1C.b		; 24 1C ; Test bits $1C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($07.b),Y		; 11 07 ; OR accumulator with memory ($07.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $0C1C.w		; 1C 1C 0C ; Test and reset bits $0C1C.w [Reads: Accumulator] [Flags: Z]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1C06.w		; 0E 06 1C ; Arithmetic shift left $1C06.w [Flags: NCZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $110A.w		; 1C 0A 11 ; Test and reset bits $110A.w [Reads: Accumulator] [Flags: Z]
	trb $0511.w		; 1C 11 05 ; Test and reset bits $0511.w [Reads: Accumulator] [Flags: Z]
	trb $061C.w		; 1C 1C 06 ; Test and reset bits $061C.w [Reads: Accumulator] [Flags: Z]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $461C.w		; 0E 1C 46 ; Arithmetic shift left $461C.w [Flags: NCZ]
	trb $0505.w		; 1C 05 05 ; Test and reset bits $0505.w [Reads: Accumulator] [Flags: Z]
	ora ($15.b),Y		; 11 15 ; OR accumulator with memory ($15.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $191C.w		; 1C 1C 19 ; Test and reset bits $191C.w [Reads: Accumulator] [Flags: Z]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $0500.w		; 1C 00 05 ; Test and reset bits $0500.w [Reads: Accumulator] [Flags: Z]
	bit $1C.b		; 24 1C ; Test bits $1C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cpx $02FF.w		; EC FF 02 ; Compare $02FF.w with X register [Reads: X Index] [Flags: NCZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stx $22.b,Y		; 96 22 ; Store X register $22.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	sed		; F8 ; Set decimal flag [Flags: D]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $15.b		; 25 15 ; Logical AND $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0A3B.w		; 09 3B 0A ; Logical OR #$0A3B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor [$02.b],Y		; 57 02 ; Exclusive OR accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $F8.b		; 02 F8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $1528.w		; 9C 28 15 ; Store zero to $1528.w
	asl $3C.b		; 06 3C ; Arithmetic shift left $3C.b [Reads: Direct Page] [Flags: NCZ]
	lsr $6AEF.w,X		; 5E EF 6A ; Logical shift right $6AEF.w,X [Reads: X Index] [Flags: NCZ]
	and $9810.w,X		; 3D 10 98 ; AND accumulator with memory $9810.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and $07.b		; 25 07 ; Logical AND $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $3FEF.w,X		; 3E EF 3F ; Rotate left $3FEF.w,X [Reads: X Index] [Flags: NCZ]
	pei ($40.b)		; D4 40 ; Push effective indirect address ($40.b) [Reads: Direct Page] [Writes: Stack Pointer]
	eor ($41.b,X)		; 41 41 ; Exclusive OR accumulator with memory ($41.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $23		; 42 23 ; Reserved instruction
	sbc $224300.l,X		; FF 00 43 22 ; Subtract with carry (long,X) $224300.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($02.b,X)		; 41 02 ; Exclusive OR accumulator with memory ($02.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$63A6]		; DC A6 63 ; Jump long indirect [$63A6] [Flow: jump]
	stz $44.b		; 64 44 ; Store zero to $44.b
	and $41.b,S		; 23 41 ; AND accumulator with stack relative $41.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $49.b		; 06 49 ; Arithmetic shift left $49.b [Reads: Direct Page] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $4B.b		; 46 4B ; Logical shift right $4B.b [Reads: Direct Page] [Flags: NCZ]
	jmp.w [$6306]		; DC 06 63 ; Jump long indirect [$6306] [Flow: jump]
	adc $4C.b		; 65 4C ; Add $4C.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $A8.b		; 06 A8 ; Arithmetic shift left $A8.b [Reads: Direct Page] [Flags: NCZ]
	eor ($A8.b)		; 52 A8 ; Exclusive OR accumulator with memory (indirect) ($A8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($4D.b,S),Y		; 53 4D ; XOR accumulator (stack relative indirect indexed) ($4D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $83A8.w		; 4E A8 83 ; Logical shift right $83A8.w [Flags: NCZ]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $54.b		; 02 54 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0C.b,X		; 55 0C ; Exclusive OR accumulator with memory $0C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $56.b,S		; 63 56 ; Add with carry (stack relative) $56.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($56.b,X)		; 01 56 ; Logical OR ($56.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr $62.b,X		; 56 62 ; Logical shift right $62.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	mvn $DC,$06		; 54 06 DC ; Move block negative $DC,$06 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $6E.b,X		; F5 6E ; Subtract $6E.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	lda $6390.w,Y		; B9 90 63 ; Load $6390.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $5F.b,S		; 63 5F ; Add with carry (stack relative) $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $DC.b		; 06 DC ; Arithmetic shift left $DC.b [Reads: Direct Page] [Flags: NCZ]
	asl $2C.b		; 06 2C ; Arithmetic shift left $2C.b [Reads: Direct Page] [Flags: NCZ]
	adc $C6.b,S		; 63 C6 ; Add with carry (stack relative) $C6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3B.b		; E5 3B ; Subtract $3B.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $64.b		; 65 64 ; Add $64.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $A8.b		; 04 A8 ; Test and set bits $A8.b [Reads: Accumulator] [Flags: Z]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lsr $DC.b,X		; 56 DC ; Logical shift right $DC.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $69.b		; A6 69 ; Load $69.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($A8.b)		; 52 A8 ; Exclusive OR accumulator with memory (indirect) ($A8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $DCCD.w		; 0C CD DC ; Test and set bits $DCCD.w [Reads: Accumulator] [Flags: Z]
	asl $9F.b		; 06 9F ; Arithmetic shift left $9F.b [Reads: Direct Page] [Flags: NCZ]
	ora ($74.b)		; 12 74 ; OR accumulator with memory (indirect) ($74.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $A8.b,X		; 75 A8 ; Add $A8.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $76.b,S		; 63 76 ; Add with carry (stack relative) $76.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $73.b		; 05 73 ; Logical OR $73.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $793B.w,Y		; B9 3B 79 ; Load $793B.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($62.b)		; 12 62 ; OR accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $4C.b,S		; 03 4C ; OR accumulator with stack relative $4C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ror $62.b,X		; 76 62 ; Rotate right $62.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $730B.w,X		; 7D 0B 73 ; Add $730B.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $E5.b		; C6 E5 ; Decrement $E5.b [Reads: Direct Page] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	.db $80, $9F		; 80 9F ; Branch always to $80, $9F [Flow: branch]
	sta ($82.b,X)		; 81 82 ; Store accumulator ($82.b,X) [Reads: Direct Page, Accumulator, X Index]
	ldx #$8483.w		; A2 83 84 ; Load #$8483.w into X register [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	stz $85.b		; 64 85 ; Store zero to $85.b
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $90.b,X		; 15 90 ; OR accumulator with memory $90.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sbc $63.b,X		; F5 63 ; Subtract $63.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $24A2.w		; 8C A2 24 ; Store Y register to $24A2.w [Reads: Y Index]
	sta $62A8.w		; 8D A8 62 ; Store accumulator to $62A8.w [Reads: Accumulator]
	stx $161C.w		; 8E 1C 16 ; Store X register to $161C.w [Reads: X Index]
	stx $E515.w		; 8E 15 E5 ; Store X register to $E515.w [Reads: X Index]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	ldx $63.b		; A6 63 ; Load $63.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldx $A2.b,Y		; B6 A2 ; Load X register $A2.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	sta ($94.b,S),Y		; 93 94 ; Store accumulator (stack relative indirect indexed) ($94.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lsr $A8.b,X		; 56 A8 ; Logical shift right $A8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $A8.b,X		; 95 A8 ; Store accumulator to $A8.b,X [Reads: Accumulator, X Index]
	lsr $15.b,X		; 56 15 ; Logical shift right $15.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	bit #$9796.w		; 89 96 97 ; Test bits #$9796.w with accumulator [Reads: Accumulator] [Flags: Z]
	cmp $9863.w,Y		; D9 63 98 ; Compare accumulator $9863.w,Y [Reads: Y Index] [Flags: NCZ]
	sta $504C.w,Y		; 99 4C 50 ; Store accumulator to $504C.w,Y [Reads: Y Index, Accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc $9A.b,S		; 63 9A ; Add with carry (stack relative) $9A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	tsb $9B.b		; 04 9B ; Test and set bits $9B.b [Reads: Accumulator] [Flags: Z]
	ora $A2.b,X		; 15 A2 ; OR accumulator with memory $A2.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	stz $26FF.w,X		; 9E FF 26 ; Store zero to $26FF.w,X [Reads: X Index]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $2E.b		; 05 2E ; Logical OR $2E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $01.b		; 26 01 ; Rotate left $01.b [Reads: Direct Page] [Flags: NCZ]
	rol $0A.b		; 26 0A ; Rotate left $0A.b [Reads: Direct Page] [Flags: NCZ]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0126.w		; 0E 26 01 ; Arithmetic shift left $0126.w [Flags: NCZ]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $1C.b		; 02 1C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $2210.w		; 1C 10 22 ; Test and reset bits $2210.w [Reads: Accumulator] [Flags: Z]
	trb $1001.w		; 1C 01 10 ; Test and reset bits $1001.w [Reads: Accumulator] [Flags: Z]
	ora $0127.w		; 0D 27 01 ; Logical OR $0127.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	trb $1C15.w		; 1C 15 1C ; Test and reset bits $1C15.w [Reads: Accumulator] [Flags: Z]
	trb $012A.w		; 1C 2A 01 ; Test and reset bits $012A.w [Reads: Accumulator] [Flags: Z]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $012A.w		; 1C 2A 01 ; Test and reset bits $012A.w [Reads: Accumulator] [Flags: Z]
	ora ($15.b,X)		; 01 15 ; Logical OR ($15.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b,X		; 15 22 ; OR accumulator with memory $22.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $0326.w		; 1C 26 03 ; Test and reset bits $0326.w [Reads: Accumulator] [Flags: Z]
	and $01.b,S		; 23 01 ; AND accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $1C05.w		; 1C 05 1C ; Test and reset bits $1C05.w [Reads: Accumulator] [Flags: Z]
	trb $0305.w		; 1C 05 03 ; Test and reset bits $0305.w [Reads: Accumulator] [Flags: Z]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1C2201.l		; 22 01 22 1C ; Jump to subroutine long $1C2201.l [Writes: Stack Pointer] [Flow: call]
	eor $05.b,S		; 43 05 ; Exclusive OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $0A00.w		; 1C 00 0A ; Test and reset bits $0A00.w [Reads: Accumulator] [Flags: Z]
	eor $0A.b,S		; 43 0A ; Exclusive OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0083.w		; 0E 83 00 ; Arithmetic shift left $0083.w [Flags: NCZ]
	ora [$22.b],Y		; 17 22 ; OR accumulator with memory (long indexed) [$22.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $1003.w		; 1C 03 10 ; Test and reset bits $1003.w [Reads: Accumulator] [Flags: Z]
	trb $051C.w		; 1C 1C 05 ; Test and reset bits $051C.w [Reads: Accumulator] [Flags: Z]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and [$00.b]		; 27 00 ; AND accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $1C43.w		; 1C 43 1C ; Test and reset bits $1C43.w [Reads: Accumulator] [Flags: Z]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0083.w		; 1C 83 00 ; Test and reset bits $0083.w [Reads: Accumulator] [Flags: Z]
	.db $82, $03, $05		; 82 03 05 ; Branch always long to $82, $03, $05 [Flow: branch]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $021C23.l		; 0F 23 1C 02 ; OR accumulator with memory (long) $021C23.l [Writes: Accumulator] [Flags: NZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $25.b		; 05 25 ; Logical OR $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0122.w		; 1C 22 01 ; Test and reset bits $0122.w [Reads: Accumulator] [Flags: Z]
	jsl $10041C.l		; 22 1C 04 10 ; Jump to subroutine long $10041C.l [Writes: Stack Pointer] [Flow: call]
	trb $0511.w		; 1C 11 05 ; Test and reset bits $0511.w [Reads: Accumulator] [Flags: Z]
	ora ($84.b),Y		; 11 84 ; OR accumulator with memory ($84.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ldx $1C23.w		; AE 23 1C ; Load $1C23.w into X register [Writes: X Index] [Flags: NZ]
	cop $15.b		; 02 15 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $2305.w		; 1C 05 23 ; Test and reset bits $2305.w [Reads: Accumulator] [Flags: Z]
	trb $0D01.w		; 1C 01 0D ; Test and reset bits $0D01.w [Reads: Accumulator] [Flags: Z]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $0F01.w		; 1C 01 0F ; Test and reset bits $0F01.w [Reads: Accumulator] [Flags: Z]
	trb $1C43.w		; 1C 43 1C ; Test and reset bits $1C43.w [Reads: Accumulator] [Flags: Z]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $1C0D.w		; 1C 0D 1C ; Test and reset bits $1C0D.w [Reads: Accumulator] [Flags: Z]
	sbc $000A26.l,X		; FF 26 0A 00 ; Subtract with carry (long,X) $000A26.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and [$06.b]		; 27 06 ; AND accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $15.b		; 26 15 ; Rotate left $15.b [Reads: Direct Page] [Flags: NCZ]
	ora ($B5.b,X)		; 01 B5 ; Logical OR ($B5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	rol $06.b		; 26 06 ; Rotate left $06.b [Reads: Direct Page] [Flags: NCZ]
	rol $25.b		; 26 25 ; Rotate left $25.b [Reads: Direct Page] [Flags: NCZ]
	ora ($9F.b,X)		; 01 9F ; Logical OR ($9F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc $26.b,X		; F6 26 ; Increment memory $26.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	eor ($05.b,X)		; 41 05 ; Exclusive OR accumulator with memory ($05.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $FF		; 42 FF ; Reserved instruction
	sbc $5C00F7.l,X		; FF F7 00 5C ; Subtract with carry (long,X) $5C00F7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $06.b		; 26 06 ; Rotate left $06.b [Reads: Direct Page] [Flags: NCZ]
	cop $69.b		; 02 69 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	lda $A062.w,Y		; B9 62 A0 ; Load $A062.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $5F.b		; 02 5F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($6A.b),Y		; F1 6A ; Subtract with carry ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol $06.b		; 26 06 ; Rotate left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $A8.b		; 05 A8 ; Logical OR $A8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $86.b,S		; A3 86 ; Load accumulator (stack relative) $86.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $A5.b		; A4 A5 ; Load $A5.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	eor ($29.b,S),Y		; 53 29 ; XOR accumulator (stack relative indirect indexed) ($29.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	lda $56A2.w,Y		; B9 A2 56 ; Load $56A2.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc #$71A6.w		; 69 A6 71 ; Add #$71A6.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and #$0106.w		; 29 06 01 ; Logical AND #$0106.w with accumulator [Writes: Accumulator] [Flags: NZ]
	stx $86.b		; 86 86 ; Store X register to $86.b [Reads: X Index]
	.db $62, $A7, $01		; 62 A7 01 ; Push effective relative address $62, $A7, $01 [Writes: Stack Pointer]
	eor ($52.b),Y		; 51 52 ; Exclusive OR accumulator with memory ($52.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $AA8F.w		; 0C 8F AA ; Test and set bits $AA8F.w [Reads: Accumulator] [Flags: Z]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	pei ($5A.b)		; D4 5A ; Push effective indirect address ($5A.b) [Reads: Direct Page] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sed		; F8 ; Set decimal flag [Flags: D]
	cpx $EDF8.w		; EC F8 ED ; Compare $EDF8.w with X register [Reads: X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsl $AC0B06.l		; 22 06 0B AC ; Jump to subroutine long $AC0B06.l [Writes: Stack Pointer] [Flow: call]
	ldy $95.b		; A4 95 ; Load $95.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $AEE0.w		; AD E0 AE ; Load $AEE0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	sbc ($10.b),Y		; F1 10 ; Subtract with carry ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora [$0B.b],Y		; 17 0B ; OR accumulator with memory (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $B8694B.l		; AF 4B 69 B8 ; Load long $B8694B.l into accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $42, $FF		; 42 FF ; Reserved instruction
	eor $41.b,S		; 43 41 ; Exclusive OR accumulator with stack relative $41.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($B0.b,X)		; 41 B0 ; Exclusive OR accumulator with memory ($B0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx #$0083.w		; E0 83 00 ; Compare #$0083.w with X register [Reads: X Index] [Flags: NCZ]
	and [$01.b]		; 27 01 ; AND accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($53.b),Y		; B1 53 ; Load accumulator ($53.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $B214A8.l		; 22 A8 14 B2 ; Jump to subroutine long $B214A8.l [Writes: Stack Pointer] [Flow: call]
	eor ($49.b,X)		; 41 49 ; Exclusive OR accumulator with memory ($49.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($B4.b,S),Y		; B3 B4 ; Load accumulator (stack relative indirect indexed) ($B4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $0C16ED.l,X		; FF ED 16 0C ; Subtract with carry (long,X) $0C16ED.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $B6.b,X		; B5 B6 ; Load $B6.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $A8B7.w		; 9C B7 A8 ; Store zero to $A8B7.w
	eor ($A8.b,S),Y		; 53 A8 ; XOR accumulator (stack relative indirect indexed) ($A8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	clv		; B8 ; Clear overflow flag [Flags: V]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	.db $62, $B9, $E0		; 62 B9 E0 ; Push effective relative address $62, $B9, $E0 [Writes: Stack Pointer]
	and ($03.b)		; 32 03 ; AND accumulator with memory (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0C.b],Y		; 17 0C ; OR accumulator with memory (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy $69BD.w,X		; BC BD 69 ; Load Y register $69BD.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	ldx $CD0C.w,Y		; BE 0C CD ; Load X register $CD0C.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ora $69BF.w		; 0D BF 69 ; Logical OR $69BF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cpy #$96BA.w		; C0 BA 96 ; Compare #$96BA.w with Y register [Reads: Y Index] [Flags: NCZ]
	bit $00.b		; 24 00 ; Test bits $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cmp ($5A.b,X)		; C1 5A ; Compare accumulator ($5A.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor ($C2.b,S),Y		; 53 C2 ; XOR accumulator (stack relative indirect indexed) ($C2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $A2.b,S		; C3 A2 ; Compare accumulator (stack relative) $A2.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	cpy $A8.b		; C4 A8 ; Compare $A8.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	cpy #$09BA.w		; C0 BA 09 ; Compare #$09BA.w with Y register [Reads: Y Index] [Flags: NCZ]
	brk $C5.b		; 00 C5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $4B.b		; C6 4B ; Decrement $4B.b [Reads: Direct Page] [Flags: NZ]
	adc #$A7A8.w		; 69 A8 A7 ; Add #$A7A8.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $A8A4.w		; 6D A4 A8 ; Add $A8A4.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp [$A8.b]		; C7 A8 ; Compare accumulator (long) [$A8.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$CA09.w		; C9 09 CA ; Compare #$CA09.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sbc $010003.l,X		; FF 03 00 01 ; Subtract with carry (long,X) $010003.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $020808.l		; 22 08 08 02 ; Jump to subroutine long $020808.l [Writes: Stack Pointer] [Flow: call]
	asl $0804.w		; 0E 04 08 ; Arithmetic shift left $0804.w [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $83.b		; 04 83 ; Test and set bits $83.b [Reads: Accumulator] [Flags: Z]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $060108.l		; 22 08 01 06 ; Jump to subroutine long $060108.l [Writes: Stack Pointer] [Flow: call]
	ora $090085.l		; 0F 85 00 09 ; OR accumulator with memory (long) $090085.l [Writes: Accumulator] [Flags: NZ]
	jsl $070604.l		; 22 04 06 07 ; Jump to subroutine long $070604.l [Writes: Stack Pointer] [Flow: call]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0006.w		; 0C 06 00 ; Test and set bits $0006.w [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	asl $0300.w		; 0E 00 03 ; Arithmetic shift left $0300.w [Flags: NCZ]
	and $0F.b,S		; 23 0F ; AND accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0306.w		; 0E 06 03 ; Arithmetic shift left $0306.w [Flags: NCZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $000001.l		; 0F 01 00 00 ; OR accumulator with memory (long) $000001.l [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $22.b		; 02 22 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $000C0D.l		; 0F 0D 0C 00 ; OR accumulator with memory (long) $000C0D.l [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $0F.b		; 26 0F ; Rotate left $0F.b [Reads: Direct Page] [Flags: NCZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $030022.l		; 0F 22 00 03 ; OR accumulator with memory (long) $030022.l [Writes: Accumulator] [Flags: NZ]
	asl $0206.w		; 0E 06 02 ; Arithmetic shift left $0206.w [Flags: NCZ]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $021C.w		; 1C 1C 02 ; Test and reset bits $021C.w [Reads: Accumulator] [Flags: Z]
	ora $0F060F.l		; 0F 0F 06 0F ; OR accumulator with memory (long) $0F060F.l [Writes: Accumulator] [Flags: NZ]
	ora $010202.l		; 0F 02 02 01 ; OR accumulator with memory (long) $010202.l [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1B.b,S		; 03 1B ; OR accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($15.b),Y		; 11 15 ; OR accumulator with memory ($15.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $010000.l		; 0F 00 00 01 ; OR accumulator with memory (long) $010000.l [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $070203.l		; 22 03 02 07 ; Jump to subroutine long $070203.l [Writes: Stack Pointer] [Flow: call]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	ora #$0F02.w		; 09 02 0F ; Logical OR #$0F02.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1B.b,X)		; 01 1B ; Logical OR ($1B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $0D1C.w		; 1C 1C 0D ; Test and reset bits $0D1C.w [Reads: Accumulator] [Flags: Z]
	and $03.b,S		; 23 03 ; AND accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $000701.l		; 22 01 07 00 ; Jump to subroutine long $000701.l [Writes: Stack Pointer] [Flow: call]
	ora #$0510.w		; 09 10 05 ; Logical OR #$0510.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $030E.w		; 0D 0E 03 ; Logical OR $030E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $83.b,S		; 03 83 ; OR accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0C.b,X		; 15 0C ; OR accumulator with memory $0C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora #$0C01.w		; 09 01 0C ; Logical OR #$0C01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0703.w		; 1C 03 07 ; Test and reset bits $0703.w [Reads: Accumulator] [Flags: Z]
	.db $10, $24		; 10 24 ; Branch if plus to $10, $24 [Flow: branch]
	ora $030B0B.l		; 0F 0B 0B 03 ; OR accumulator with memory (long) $030B0B.l [Writes: Accumulator] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $030D0F.l		; 0F 0F 0D 03 ; OR accumulator with memory (long) $030D0F.l [Writes: Accumulator] [Flags: NZ]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0F2201.l		; 0F 01 22 0F ; OR accumulator with memory (long) $0F2201.l [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $080222.l		; 0F 22 02 08 ; OR accumulator with memory (long) $080222.l [Writes: Accumulator] [Flags: NZ]
	asl $0F0F.w		; 0E 0F 0F ; Arithmetic shift left $0F0F.w [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $0F01.w		; 0E 01 0F ; Arithmetic shift left $0F01.w [Flags: NCZ]
	ora $0B4301.l		; 0F 01 43 0B ; OR accumulator with memory (long) $0B4301.l [Writes: Accumulator] [Flags: NZ]
	ora $010F02.l		; 0F 02 0F 01 ; OR accumulator with memory (long) $010F02.l [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $8328E0.l,X		; FF E0 28 83 ; Subtract with carry (long,X) $8328E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $4D47.w		; 1C 47 4D ; Test and reset bits $4D47.w [Reads: Accumulator] [Flags: Z]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	jmp $DEA2.w		; 4C A2 DE ; Jump to $DEA2.w [Flow: jump]
	sbc $4CA14E.l,X		; FF 4E A1 4C ; Subtract with carry (long,X) $4CA14E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $4CA1.w		; 4E A1 4C ; Logical shift right $4CA1.w [Flags: NCZ]
	lsr $298C.w		; 4E 8C 29 ; Logical shift right $298C.w [Flags: NCZ]
	eor [$57.b]		; 47 57 ; Exclusive OR accumulator with memory (long) [$57.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($53.b)		; 52 53 ; Exclusive OR accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $3D.b		; 00 3D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$53.b]		; A7 53 ; Load accumulator (long) [$53.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $53A7.w,X		; 3D A7 53 ; AND accumulator with memory $53A7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $640B.w,X		; 3D 0B 64 ; AND accumulator with memory $640B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$6A.b]		; 47 6A ; Exclusive OR accumulator with memory (long) [$6A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $56.b,X		; 55 56 ; Exclusive OR accumulator with memory $56.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $1D, $61		; 62 1D 61 ; Push effective relative address $62, $1D, $61 [Writes: Stack Pointer]
	.db $62, $AC, $13		; 62 AC 13 ; Push effective relative address $62, $AC, $13 [Writes: Stack Pointer]
	ldy $AD.b		; A4 AD ; Load $AD.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ldx $1BA4.w		; AE A4 1B ; Load $1BA4.w into X register [Writes: X Index] [Flags: NZ]
	trb $9392.w		; 1C 92 93 ; Test and reset bits $9392.w [Reads: Accumulator] [Flags: Z]
	ora $6867.w,X		; 1D 67 68 ; OR accumulator with memory $6867.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$67.b],Y		; B7 67 ; Load accumulator (long indexed) [$67.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	stz $35.b,X		; 74 35 ; Store zero to $35.b,X [Reads: X Index]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ldx $26.b,Y		; B6 26 ; Load X register $26.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	cmp $0163.w,Y		; D9 63 01 ; Compare accumulator $0163.w,Y [Reads: Y Index] [Flags: NCZ]
	asl $DF93.w		; 0E 93 DF ; Arithmetic shift left $DF93.w [Flags: NCZ]
	and #$DF1F.w		; 29 1F DF ; Logical AND #$DF1F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and #$1E05.w		; 29 05 1E ; Logical AND #$1E05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	inc $2F09.w		; EE 09 2F ; Increment $2F09.w [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp ($D2.b),Y		; D1 D2 ; Compare accumulator ($D2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $62, $06, $0D		; 62 06 0D ; Push effective relative address $62, $06, $0D [Writes: Stack Pointer]
	and ($1F.b),Y		; 31 1F ; AND accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp $CC1C.w		; 4C 1C CC ; Jump to $CC1C.w [Flow: jump]
	ora $31.b,S		; 03 31 ; OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $302F.w		; 0E 2F 30 ; Arithmetic shift left $302F.w [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	jmp.w [$66DD]		; DC DD 66 ; Jump long indirect [$66DD] [Flow: jump]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($CC.b,X)		; 01 CC ; Logical OR ($CC.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($03.b,X)		; A1 03 ; Load accumulator ($03.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda [$DC.b]		; A7 DC ; Load accumulator (long) [$DC.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $CB63.w,X		; DD 63 CB ; Compare accumulator $CB63.w,X [Reads: X Index] [Flags: NCZ]
	cpx #$5B5E.w		; E0 5E 5B ; Compare #$5B5E.w with X register [Reads: X Index] [Flags: NCZ]
	asl $17.b,X		; 16 17 ; Arithmetic shift left $17.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldy #$1918.w		; A0 18 19 ; Load #$1918.w into Y register [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	asl $6A.b		; 06 6A ; Arithmetic shift left $6A.b [Reads: Direct Page] [Flags: NCZ]
	ldx $4CAC.w		; AE AC 4C ; Load $4CAC.w into X register [Writes: X Index] [Flags: NZ]
	ora ($B7.b,X)		; 01 B7 ; Logical OR ($B7.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $216A.w,X		; 5D 6A 21 ; Exclusive OR accumulator with memory $216A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $1D.b		; A5 1D ; Load $1D.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($62.b,X)		; 61 62 ; Add with carry ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda ($6A.b)		; B2 6A ; Load accumulator (indirect) ($6A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cmp $AC9420.l		; CF 20 94 AC ; Compare accumulator (long) $AC9420.l [Reads: Accumulator] [Flags: NCZ]
	stx $44.b,Y		; 96 44 ; Store X register $44.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	stx $1D.b		; 86 1D ; Store X register to $1D.b [Reads: X Index]
	adc [$68.b]		; 67 68 ; Add with carry (long) [$68.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $F8DE.w,X		; 1D DE F8 ; OR accumulator with memory $F8DE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr ($2DA8.w,X)		; FC A8 2D ; Jump to subroutine indirect indexed ($2DA8.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpx $7A.b		; E4 7A ; Compare $7A.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $D0, $D1		; D0 D1 ; Branch if not equal to $D0, $D1 [Flow: branch]
	.db $50, $8C		; 50 8C ; Branch if overflow clear to $50, $8C [Flow: branch]
	sta $DF86.w		; 8D 86 DF ; Store accumulator to $DF86.w [Reads: Accumulator]
	and #$1D6A.w		; 29 6A 1D ; Logical AND #$1D6A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jmp.w [$6DDD]		; DC DD 6D ; Jump long indirect [$6DDD] [Flow: jump]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	and $FC1D.w		; 2D 1D FC ; Logical AND $FC1D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($9F.b,X)		; A1 9F ; Load accumulator ($9F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	mvp $E6,$8D		; 44 8D E6 ; Move block positive $E6,$8D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	asl $DCDE.w,X		; 1E DE DC ; Arithmetic shift left $DCDE.w,X [Reads: X Index] [Flags: NCZ]
	inc $3D.b		; E6 3D ; Increment $3D.b [Reads: Direct Page] [Flags: NZ]
	jmp ($E603.w)		; 6C 03 E6 ; Jump indirect to ($E603.w) [Flow: jump]
	sbc ($71.b,S),Y		; F3 71 ; Subtract with carry (stack relative indirect indexed) ($71.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $06.b,X		; F5 06 ; Subtract $06.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $E3.b,S		; 63 E3 ; Add with carry (stack relative) $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $0303.w,X		; 1D 03 03 ; OR accumulator with memory $0303.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $D231.w		; 1C 31 D2 ; Test and reset bits $D231.w [Reads: Accumulator] [Flags: Z]
	dec $D2.b		; C6 D2 ; Decrement $D2.b [Reads: Direct Page] [Flags: NZ]
	mvp $98,$C7		; 44 C7 98 ; Move block positive $98,$C7 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	stz $33.b		; 64 33 ; Store zero to $33.b
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lsr $1DE6.w		; 4E E6 1D ; Logical shift right $1DE6.w [Flags: NCZ]
	cmp $3138.w,Y		; D9 38 31 ; Compare accumulator $3138.w,Y [Reads: Y Index] [Flags: NCZ]
	lda #$4B4B.w		; A9 4B 4B ; Load #$4B4B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($33.b,S),Y		; D3 33 ; Compare accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	adc #$3C62.w		; 69 62 3C ; Add #$3C62.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora ($A6.b,X)		; 01 A6 ; Logical OR ($A6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsl $440F4C.l		; 22 4C 0F 44 ; Jump to subroutine long $440F4C.l [Writes: Stack Pointer] [Flow: call]
	sec		; 38 ; Set carry flag [Flags: C]
	eor ($53.b,X)		; 41 53 ; Exclusive OR accumulator with memory ($53.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl $42.b		; 06 42 ; Arithmetic shift left $42.b [Reads: Direct Page] [Flags: NCZ]
	eor $6A.b,S		; 43 6A ; Exclusive OR accumulator with stack relative $6A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $44.b,X		; 55 44 ; Exclusive OR accumulator with memory $44.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($45.b,S),Y		; 53 45 ; XOR accumulator (stack relative indirect indexed) ($45.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $EB.b		; 46 EB ; Logical shift right $EB.b [Reads: Direct Page] [Flags: NCZ]
	sta ($FF.b,X)		; 81 FF ; Store accumulator ($FF.b,X) [Reads: Direct Page, Accumulator, X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	tsb $08.b		; 04 08 ; Test and set bits $08.b [Reads: Accumulator] [Flags: Z]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $2303.w		; 1C 03 23 ; Test and reset bits $2303.w [Reads: Accumulator] [Flags: Z]
	ora ($87.b,X)		; 01 87 ; Logical OR ($87.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $0125.w		; 1C 25 01 ; Test and reset bits $0125.w [Reads: Accumulator] [Flags: Z]
	and $08.b,S		; 23 08 ; AND accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b),Y		; 11 06 ; OR accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $0305.w		; 1C 05 03 ; Test and reset bits $0305.w [Reads: Accumulator] [Flags: Z]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: NCZ]
	asl $1C.b,X		; 16 1C ; Arithmetic shift left $1C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $0D071B.l		; 22 1B 07 0D ; Jump to subroutine long $0D071B.l [Writes: Stack Pointer] [Flow: call]
	trb $0D09.w		; 1C 09 0D ; Test and reset bits $0D09.w [Reads: Accumulator] [Flags: Z]
	trb $1005.w		; 1C 05 10 ; Test and reset bits $1005.w [Reads: Accumulator] [Flags: Z]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $1605.w		; 1C 05 16 ; Test and reset bits $1605.w [Reads: Accumulator] [Flags: Z]
	trb $061B.w		; 1C 1B 06 ; Test and reset bits $061B.w [Reads: Accumulator] [Flags: Z]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $01021C.l		; 22 1C 02 01 ; Jump to subroutine long $01021C.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	trb $0006.w		; 1C 06 00 ; Test and reset bits $0006.w [Reads: Accumulator] [Flags: Z]
	ora $1C1B.w,Y		; 19 1B 1C ; OR accumulator with memory $1C1B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $1206.w		; 1C 06 12 ; Test and reset bits $1206.w [Reads: Accumulator] [Flags: Z]
	asl $091B.w		; 0E 1B 09 ; Arithmetic shift left $091B.w [Flags: NCZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $0E09.w		; 1C 09 0E ; Test and reset bits $0E09.w [Reads: Accumulator] [Flags: Z]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $001C.w		; 1C 1C 00 ; Test and reset bits $001C.w [Reads: Accumulator] [Flags: Z]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $1C.b,S		; 23 1C ; AND accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1D051D.l,X		; 1F 1D 05 1D ; Logical OR long $1D051D.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $1D02.w		; 0C 02 1D ; Test and set bits $1D02.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1D101D.l		; 0F 1D 10 1D ; OR accumulator with memory (long) $1D101D.l [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $050C.w,X		; 1D 0C 05 ; OR accumulator with memory $050C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $16.b		; 02 16 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1000.w,X		; 1D 00 10 ; OR accumulator with memory $1000.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1D.b,S		; 03 1D ; OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1C05.w,X		; 1D 05 1C ; OR accumulator with memory $1C05.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($16.b,X)		; 01 16 ; Logical OR ($16.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	rol $1D.b		; 26 1D ; Rotate left $1D.b [Reads: Direct Page] [Flags: NCZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $011601.l		; 0F 01 16 01 ; OR accumulator with memory (long) $011601.l [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $27.b,S		; 03 27 ; OR accumulator with stack relative $27.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0084.w,X		; 1D 84 00 ; OR accumulator with memory $0084.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $1D.b		; 26 1D ; Rotate left $1D.b [Reads: Direct Page] [Flags: NCZ]
	ora $010502.l		; 0F 02 05 01 ; OR accumulator with memory (long) $010502.l [Writes: Accumulator] [Flags: NZ]
	ora $0601.w,X		; 1D 01 06 ; OR accumulator with memory $0601.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0607.w,X		; 1D 07 06 ; OR accumulator with memory $0607.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $071D.w,X		; 1D 1D 07 ; OR accumulator with memory $071D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $221D.w,X		; 1D 1D 22 ; OR accumulator with memory $221D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $2407.w,X		; 1D 07 24 ; OR accumulator with memory $2407.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	asl $1D.b		; 06 1D ; Arithmetic shift left $1D.b [Reads: Direct Page] [Flags: NCZ]
	ora $0CFF.w,X		; 1D FF 0C ; OR accumulator with memory $0CFF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($4C.b,X)		; A1 4C ; Load accumulator ($4C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $5FC3.w		; 4E C3 5F ; Logical shift right $5FC3.w [Flags: NCZ]
	sta ($79.b)		; 92 79 ; Store accumulator (indirect) ($79.b) [Reads: Direct Page, Accumulator]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	cmp #$20D4.w		; C9 D4 20 ; Compare #$20D4.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsb $0622.w		; 0C 22 06 ; Test and set bits $0622.w [Reads: Accumulator] [Flags: Z]
	ora [$A7.b],Y		; 17 A7 ; OR accumulator with memory (long indexed) [$A7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($3D.b,S),Y		; 53 3D ; XOR accumulator (stack relative indirect indexed) ($3D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $6A.b		; C6 6A ; Decrement $6A.b [Reads: Direct Page] [Flags: NZ]
	sta ($79.b)		; 92 79 ; Store accumulator (indirect) ($79.b) [Reads: Direct Page, Accumulator]
	asl $D5.b		; 06 D5 ; Arithmetic shift left $D5.b [Reads: Direct Page] [Flags: NCZ]
	dec $E5.b,X		; D6 E5 ; Decrement memory $E5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $17.b		; E5 17 ; Subtract $17.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $0606.w		; 0C 06 06 ; Test and set bits $0606.w [Reads: Accumulator] [Flags: Z]
	lda $A4AE.w		; AD AE A4 ; Load $A4AE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $4F.b		; A5 4F ; Load $4F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta ($79.b)		; 92 79 ; Store accumulator (indirect) ($79.b) [Reads: Direct Page, Accumulator]
	and $E0D762.l,X		; 3F 62 D7 E0 ; AND accumulator with memory (long,X) $E0D762.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $D1.b		; 26 D1 ; Rotate left $D1.b [Reads: Direct Page] [Flags: NCZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc $20.b		; 65 20 ; Add $20.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $E41D.w		; 20 1D E4 ; Jump to subroutine at $E41D.w [Writes: Stack Pointer] [Flow: call]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy #$92E3.w		; A0 E3 92 ; Load #$92E3.w into Y register [Writes: Y Index] [Flags: NZ]
	adc $0163.w,Y		; 79 63 01 ; Add $0163.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $DB		; 80 DB ; Branch always to $80, $DB [Flow: branch]
	adc ($DC.b)		; 72 DC ; Add with carry (indirect) ($DC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $7A.b		; C5 7A ; Compare $7A.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ldx $F1DD.w		; AE DD F1 ; Load $F1DD.w into X register [Writes: X Index] [Flags: NZ]
	ldy $53DE.w		; AC DE 53 ; Load $53DE.w into Y register [Writes: Y Index] [Flags: NZ]
	adc $0163.w,Y		; 79 63 01 ; Add $0163.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	cmp $E172E0.l,X		; DF E0 72 E1 ; Compare accumulator (long,X) $E172E0.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	cmp ($80.b,S),Y		; D3 80 ; Compare accumulator (stack relative indirect indexed) ($80.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	lda ($EC.b)		; B2 EC ; Load accumulator (indirect) ($EC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $E2, $07		; 62 E2 07 ; Push effective relative address $62, $E2, $07 [Writes: Stack Pointer]
	cmp ($79.b)		; D2 79 ; Compare accumulator (indirect) ($79.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc $E5.b,S		; 63 E5 ; Add with carry (stack relative) $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $E0E7E6.l,X		; DF E6 E7 E0 ; Compare accumulator (long,X) $E0E7E6.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	adc $E8.b,S		; 63 E8 ; Add with carry (stack relative) $E8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $A1.b		; 06 A1 ; Arithmetic shift left $A1.b [Reads: Direct Page] [Flags: NCZ]
	sbc $82.b,S		; E3 82 ; Subtract stack-relative $82.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cpx $5E96.w		; EC 96 5E ; Compare $5E96.w with X register [Reads: X Index] [Flags: NCZ]
	adc $62.b		; 65 62 ; Add $62.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $EF64.w		; ED 64 EF ; Subtract $EF64.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	asl $98.b		; 06 98 ; Arithmetic shift left $98.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $82, $E5, $1D		; 82 E5 1D ; Branch always long to $82, $E5, $1D [Flow: branch]
	lda [$00.b],Y		; B7 00 ; Load accumulator (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $F4.b,S		; 63 F4 ; Add with carry (stack relative) $F4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $F7, $09		; 62 F7 09 ; Push effective relative address $62, $F7, $09 [Writes: Stack Pointer]
	and ($CD.b),Y		; 31 CD ; AND accumulator with memory ($CD.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	trb $B76A.w		; 1C 6A B7 ; Test and reset bits $B76A.w [Reads: Accumulator] [Flags: Z]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $FC.b,S		; 63 FC ; Add with carry (stack relative) $FC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$0020.w		; E0 20 00 ; Compare #$0020.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $01.b		; E5 01 ; Subtract $01.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $02A5.w,X		; 1D A5 02 ; OR accumulator with memory $02A5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $4E02.w		; 8D 02 4E ; Store accumulator to $4E02.w [Reads: Accumulator]
	jsr ($D372.w,X)		; FC 72 D3 ; Jump to subroutine indirect indexed ($D372.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $C2.b,S		; 03 C2 ; OR accumulator with stack relative $C2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $E5.b		; 04 E5 ; Test and set bits $E5.b [Reads: Accumulator] [Flags: Z]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	mvn $E6,$E5		; 54 E5 E6 ; Move block negative $E6,$E5 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	sta [$D8.b],Y		; 97 D8 ; Store accumulator (long indexed) [$D8.b],Y [Reads: Direct Page, Y Index, Accumulator]
	asl $1D.b		; 06 1D ; Arithmetic shift left $1D.b [Reads: Direct Page] [Flags: NCZ]
	adc $0763.w,Y		; 79 63 07 ; Add $0763.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp $00FF.w,Y		; D9 FF 00 ; Compare accumulator $00FF.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $62, $09, $08		; 62 09 08 ; Push effective relative address $62, $09, $08 [Writes: Stack Pointer]
	lda #$2E1E.w		; A9 1E 2E ; Load #$2E1E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($E3.b,X)		; E1 E3 ; Subtract with carry ($E3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $79.b,Y		; B6 79 ; Load X register $79.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	adc $FE.b,S		; 63 FE ; Add with carry (stack relative) $FE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $0C, $63		; 62 0C 63 ; Push effective relative address $62, $0C, $63 [Writes: Stack Pointer]
	asl $1D07.w		; 0E 07 1D ; Arithmetic shift left $1D07.w [Flags: NCZ]
	ora $2E.b		; 05 2E ; Logical OR $2E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($E3.b,X)		; E1 E3 ; Subtract with carry ($E3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $6379.w,X		; 1D 79 63 ; OR accumulator with memory $6379.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$12.b]		; 67 12 ; Add with carry (long) [$12.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($9F.b,X)		; 01 9F ; Logical OR ($9F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor ($83.b,X)		; 41 83 ; Exclusive OR accumulator with memory ($83.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $82.b		; 02 82 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $6691.w,X		; FD 91 66 ; Subtract with carry $6691.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl $4C.b,X		; 16 4C ; Arithmetic shift left $4C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp $E32149.l		; 5C 49 21 E3 ; Jump long to $E32149.l [Flow: jump]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $04.b,X		; 56 04 ; Logical shift right $04.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $23D13F.l		; 22 3F D1 23 ; Jump to subroutine long $23D13F.l [Writes: Stack Pointer] [Flow: call]
	bit $3F.b		; 24 3F ; Test bits $3F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $26.b		; 25 26 ; Logical AND $26.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $E3.b,S		; 63 E3 ; Add with carry (stack relative) $E3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and [$3F.b]		; 27 3F ; AND accumulator with memory (long) [$3F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $80.b,S		; 23 80 ; AND accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $D3.b		; 04 D3 ; Test and set bits $D3.b [Reads: Accumulator] [Flags: Z]
	cmp ($80.b,S),Y		; D3 80 ; Compare accumulator (stack relative indirect indexed) ($80.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and #$0AFF.w		; 29 FF 0A ; Logical AND #$0AFF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0C0C.w,Y		; 19 0C 0C ; OR accumulator with memory $0C0C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0203.w,Y		; 19 03 02 ; OR accumulator with memory $0203.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $0E.b,S		; 43 0E ; Exclusive OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $190D.w		; 20 0D 19 ; Jump to subroutine at $190D.w [Writes: Stack Pointer] [Flow: call]
	ora $0906.w,X		; 1D 06 09 ; OR accumulator with memory $0906.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0408.w,X		; 1D 08 04 ; OR accumulator with memory $0408.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b),Y		; 11 0E ; OR accumulator with memory ($0E.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1C031D.l		; 0F 1D 03 1C ; OR accumulator with memory (long) $1C031D.l [Writes: Accumulator] [Flags: NZ]
	asl $1D03.w		; 0E 03 1D ; Arithmetic shift left $1D03.w [Flags: NCZ]
	ora $1D03.w,X		; 1D 03 1D ; OR accumulator with memory $1D03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0103.w,X		; 1D 03 01 ; OR accumulator with memory $0103.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora $0F1B1D.l		; 0F 1D 1B 0F ; OR accumulator with memory (long) $0F1B1D.l [Writes: Accumulator] [Flags: NZ]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $1B.b,S		; 23 1B ; AND accumulator with stack relative $1B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1D.b,S		; 03 1D ; OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	eor $1D.b,S		; 43 1D ; Exclusive OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0A.b,X)		; 01 0A ; Logical OR ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: NCZ]
	ora $061D01.l		; 0F 01 1D 06 ; OR accumulator with memory (long) $061D01.l [Writes: Accumulator] [Flags: NZ]
	ora $061D.w,X		; 1D 1D 06 ; OR accumulator with memory $061D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $01001D.l		; 22 1D 00 01 ; Jump to subroutine long $01001D.l [Writes: Stack Pointer] [Flow: call]
	jsl $19011D.l		; 22 1D 01 19 ; Jump to subroutine long $19011D.l [Writes: Stack Pointer] [Flow: call]
	asl $23.b		; 06 23 ; Arithmetic shift left $23.b [Reads: Direct Page] [Flags: NCZ]
	ora $0700.w,X		; 1D 00 07 ; OR accumulator with memory $0700.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $830E.w,X		; 1D 0E 83 ; OR accumulator with memory $830E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $45.b		; 00 45 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0706.w		; 09 06 07 ; Logical OR #$0706.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	asl $0606.w		; 0E 06 06 ; Arithmetic shift left $0606.w [Flags: NCZ]
	ora $0501.w,X		; 1D 01 05 ; OR accumulator with memory $0501.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $0E051D.l		; 22 1D 05 0E ; Jump to subroutine long $0E051D.l [Writes: Stack Pointer] [Flow: call]
	ora $161C.w,X		; 1D 1C 16 ; OR accumulator with memory $161C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	stz $05.b		; 64 05 ; Store zero to $05.b
	ora $0701.w,X		; 1D 01 07 ; OR accumulator with memory $0701.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0606.w,X		; 1D 06 06 ; OR accumulator with memory $0606.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $1D.b		; 25 1D ; Logical AND $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $1D2506.l		; 22 06 25 1D ; Jump to subroutine long $1D2506.l [Writes: Stack Pointer] [Flow: call]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1D.b		; 25 1D ; Logical AND $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$1B1D.w		; 09 1D 1B ; Logical OR #$1B1D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $1D.b		; 25 1D ; Logical AND $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0E.b		; 00 0E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $0E.b		; 04 0E ; Test and set bits $0E.b [Reads: Accumulator] [Flags: Z]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $1D.b		; 25 1D ; Logical AND $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $1D0506.l		; 22 06 05 1D ; Jump to subroutine long $1D0506.l [Writes: Stack Pointer] [Flow: call]
	ora ($19.b),Y		; 11 19 ; OR accumulator with memory ($19.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ora [$87.b]		; 07 87 ; OR accumulator with memory (long) [$87.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $72.b		; 00 72 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $0606.w		; 0C 06 06 ; Test and set bits $0606.w [Reads: Accumulator] [Flags: Z]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0E06.w,X		; 1D 06 0E ; OR accumulator with memory $0E06.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $1D.b		; 06 1D ; Arithmetic shift left $1D.b [Reads: Direct Page] [Flags: NCZ]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: NCZ]
	eor $1D.b,S		; 43 1D ; Exclusive OR accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	asl $031D.w		; 0E 1D 03 ; Arithmetic shift left $031D.w [Flags: NCZ]
	bit $1D.b		; 24 1D ; Test bits $1D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and [$06.b]		; 27 06 ; AND accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1D.b		; 06 1D ; Arithmetic shift left $1D.b [Reads: Direct Page] [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora $2B1D.w,X		; 1D 1D 2B ; OR accumulator with memory $2B1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $0E		; 10 0E ; Branch if plus to $10, $0E [Flow: branch]
	sbc $D95E0A.l,X		; FF 0A 5E D9 ; Subtract with carry (long,X) $D95E0A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F5.b,X		; F5 F5 ; Subtract $F5.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $E863.w,Y		; D9 63 E8 ; Compare accumulator $E863.w,Y [Reads: Y Index] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol $5400.w		; 2E 00 54 ; Rotate left $5400.w [Flags: NCZ]
	eor $48.b,S		; 43 48 ; Exclusive OR accumulator with stack relative $48.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $E0.b		; 06 E0 ; Arithmetic shift left $E0.b [Reads: Direct Page] [Flags: NCZ]
	jsr $FB54.w		; 20 54 FB ; Jump to subroutine at $FB54.w [Writes: Stack Pointer] [Flow: call]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda [$DD.b]		; A7 DD ; Load accumulator (long) [$DD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $65.b		; 06 65 ; Arithmetic shift left $65.b [Reads: Direct Page] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and $91.b,X		; 35 91 ; Logical AND $91.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $48		; 10 48 ; Branch if plus to $10, $48 [Flow: branch]
	mvn $20,$2C		; 54 2C 20 ; Move block negative $20,$2C [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora ($48.b,S),Y		; 13 48 ; OR accumulator (stack relative indirect indexed) ($48.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $2D2C.w		; 20 2C 2D ; Jump to subroutine at $2D2C.w [Writes: Stack Pointer] [Flow: call]
	jsr $2F2E.w		; 20 2E 2F ; Jump to subroutine at $2F2E.w [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	asl $B597.w,X		; 1E 97 B5 ; Arithmetic shift left $B597.w,X [Reads: X Index] [Flags: NCZ]
	eor [$30.b]		; 47 30 ; Exclusive OR accumulator with memory (long) [$30.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy #$174C.w		; C0 4C 17 ; Compare #$174C.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($23.b,S),Y		; 13 23 ; OR accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	asl $D0.b,X		; 16 D0 ; Arithmetic shift left $D0.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsl $57DC3F.l		; 22 3F DC 57 ; Jump to subroutine long $57DC3F.l [Writes: Stack Pointer] [Flow: call]
	ora $C1.b,S		; 03 C1 ; OR accumulator with stack relative $C1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($17.b),Y		; 31 17 ; AND accumulator with memory ($17.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($17.b)		; 32 17 ; AND accumulator with memory (indirect) ($17.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $CC		; 80 CC ; Branch always to $80, $CC [Flow: branch]
	ora #$224C.w		; 09 4C 22 ; Logical OR #$224C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $13.b		; C5 13 ; Compare $13.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and ($80.b,S),Y		; 33 80 ; AND accumulator (stack relative indirect indexed) ($80.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $22.b,X		; 56 22 ; Logical shift right $22.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $62, $34, $00		; 62 34 00 ; Push effective relative address $62, $34, $00 [Writes: Stack Pointer]
	ora [$62.b],Y		; 17 62 ; OR accumulator with memory (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$02.b],Y		; 37 02 ; AND accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($80.b)		; B2 80 ; Load accumulator (indirect) ($80.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $62, $3A, $00		; 62 3A 00 ; Push effective relative address $62, $3A, $00 [Writes: Stack Pointer]
	jmp ($8023.w)		; 6C 23 80 ; Jump indirect to ($8023.w) [Flow: jump]
	ora ($D1.b,S),Y		; 13 D1 ; OR accumulator (stack relative indirect indexed) ($D1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvn $3D,$25		; 54 25 3D ; Move block negative $3D,$25 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	rol $8000.w,X		; 3E 00 80 ; Rotate left $8000.w,X [Reads: X Index] [Flags: NCZ]
	and $D1803F.l,X		; 3F 3F 80 D1 ; AND accumulator with memory (long,X) $D1803F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $008080.l,X		; 3F 80 80 00 ; AND accumulator with memory (long,X) $008080.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $CD.b		; 25 CD ; Logical AND $CD.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $41, $07		; 62 41 07 ; Push effective relative address $62, $41, $07 [Writes: Stack Pointer]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	adc ($80.b)		; 72 80 ; Add with carry (indirect) ($80.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	brk $3F.b		; 00 3F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $83		; 42 83 ; Reserved instruction
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $3B.b		; 04 3B ; Test and set bits $3B.b [Reads: Accumulator] [Flags: Z]
	eor $80.b		; 45 80 ; Exclusive OR $80.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $42		; 80 42 ; Branch always to $80, $42 [Flow: branch]
	adc $46.b,S		; 63 46 ; Add with carry (stack relative) $46.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $4A6380.l		; 22 80 63 4A ; Jump to subroutine long $4A6380.l [Writes: Stack Pointer] [Flow: call]
	cop $45.b		; 02 45 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr $6480.w		; 4E 80 64 ; Logical shift right $6480.w [Flags: NCZ]
	eor $804F04.l		; 4F 04 4F 80 ; Exclusive OR accumulator with memory (long) $804F04.l [Writes: Accumulator] [Flags: NZ]
	and $4C54.w		; 2D 54 4C ; Logical AND $4C54.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $55.b		; 65 55 ; Add $55.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($1A.b,X)		; 01 1A ; Logical OR ($1A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $50, $62		; 50 62 ; Branch if overflow clear to $50, $62 [Flow: branch]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tsb $1A.b		; 04 1A ; Test and set bits $1A.b [Reads: Accumulator] [Flags: Z]
	.db $80, $D1		; 80 D1 ; Branch always to $80, $D1 [Flow: branch]
	stx $5E.b,Y		; 96 5E ; Store X register $5E.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	adc $5E.b,S		; 63 5E ; Add with carry (stack relative) $5E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cop $50.b		; 02 50 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $80, $63		; 62 80 63 ; Push effective relative address $62, $80, $63 [Writes: Stack Pointer]
	adc $22.b,S		; 63 22 ; Add with carry (stack relative) $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $09		; 80 09 ; Branch always to $80, $09 [Flow: branch]
	adc [$10.b]		; 67 10 ; Add with carry (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr ($1D72.w,X)		; FC 72 1D ; Jump to subroutine indirect indexed ($1D72.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	and $006968.l,X		; 3F 68 69 00 ; AND accumulator with memory (long,X) $006968.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ror $18.b,X		; 76 18 ; Rotate right $18.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	lsr $C8.b,X		; 56 C8 ; Logical shift right $C8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	adc #$806A.w		; 69 6A 80 ; Add #$806A.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $80, $E7		; 80 E7 ; Branch always to $80, $E7 [Flow: branch]
	jmp ($4280.w)		; 6C 80 42 ; Jump indirect to ($4280.w) [Flow: jump]
	.db $80, $00		; 80 00 ; Branch always to $80, $00 [Flow: branch]
	adc $6E56.w		; 6D 56 6E ; Add $6E56.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $427026.l		; 6F 26 70 42 ; Add with carry (long) $427026.l [Writes: Accumulator] [Flags: NCVZ]
	and [$80.b]		; 27 80 ; AND accumulator with memory (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $42.b		; 06 42 ; Arithmetic shift left $42.b [Reads: Direct Page] [Flags: NCZ]
	.db $80, $C5		; 80 C5 ; Branch always to $80, $C5 [Flow: branch]
	adc $7101.w,Y		; 79 01 71 ; Add $7101.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($2A.b)		; 72 2A ; Add with carry (indirect) ($2A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	cmp ($79.b),Y		; D1 79 ; Compare accumulator ($79.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $0B0D03.l,X		; FF 03 0D 0B ; Subtract with carry (long,X) $0B0D03.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $00.b		; 25 00 ; Logical AND $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($25.b,X)		; 01 25 ; Logical OR ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $030A01.l		; 22 01 0A 03 ; Jump to subroutine long $030A01.l [Writes: Stack Pointer] [Flow: call]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $02000F.l		; 0F 0F 00 02 ; OR accumulator with memory (long) $02000F.l [Writes: Accumulator] [Flags: NZ]
	ora $1D0300.l		; 0F 00 03 1D ; OR accumulator with memory (long) $1D0300.l [Writes: Accumulator] [Flags: NZ]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $030718.l		; 0F 18 07 03 ; OR accumulator with memory (long) $030718.l [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F0907.l		; 0F 07 09 0F ; OR accumulator with memory (long) $0F0907.l [Writes: Accumulator] [Flags: NZ]
	ora $1D0405.l		; 0F 05 04 1D ; OR accumulator with memory (long) $1D0405.l [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $010222.l		; 0F 22 02 01 ; OR accumulator with memory (long) $010222.l [Writes: Accumulator] [Flags: NZ]
	ora $1D220C.l		; 0F 0C 22 1D ; OR accumulator with memory (long) $1D220C.l [Writes: Accumulator] [Flags: NZ]
	jsl $040401.l		; 22 01 04 04 ; Jump to subroutine long $040401.l [Writes: Stack Pointer] [Flow: call]
	ora $0F030F.l		; 0F 0F 03 0F ; OR accumulator with memory (long) $0F030F.l [Writes: Accumulator] [Flags: NZ]
	jsl $070302.l		; 22 02 03 07 ; Jump to subroutine long $070302.l [Writes: Stack Pointer] [Flow: call]
	ora $1D.b		; 05 1D ; Logical OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $051D22.l		; 0F 22 1D 05 ; OR accumulator with memory (long) $051D22.l [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0F0702.l		; 0F 02 07 0F ; OR accumulator with memory (long) $0F0702.l [Writes: Accumulator] [Flags: NZ]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1D1D.w		; 0D 1D 1D ; Logical OR $1D1D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0B0B02.l		; 0F 02 0B 0B ; OR accumulator with memory (long) $0B0B02.l [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1D.b,X		; 15 1D ; OR accumulator with memory $1D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $05.b,S		; 43 05 ; Exclusive OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $08010F.l		; 0F 0F 01 08 ; OR accumulator with memory (long) $08010F.l [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $010722.l		; 0F 22 07 01 ; OR accumulator with memory (long) $010722.l [Writes: Accumulator] [Flags: NZ]
	ora $4308.w,X		; 1D 08 43 ; OR accumulator with memory $4308.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0205.w,X		; 1D 05 02 ; OR accumulator with memory $0205.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	lsr $03.b		; 46 03 ; Logical shift right $03.b [Reads: Direct Page] [Flags: NCZ]
	ora [$0C.b]		; 07 0C ; OR accumulator with memory (long) [$0C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $0F051D.l		; 22 1D 05 0F ; Jump to subroutine long $0F051D.l [Writes: Stack Pointer] [Flow: call]
	ora $0F05.w,X		; 1D 05 0F ; OR accumulator with memory $0F05.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $830083.l		; 0F 83 00 83 ; OR accumulator with memory (long) $830083.l [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $051D.w,X		; 1D 1D 05 ; OR accumulator with memory $051D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	ora ($07.b),Y		; 11 07 ; OR accumulator with memory ($07.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $00130F.l		; 22 0F 13 00 ; Jump to subroutine long $00130F.l [Writes: Stack Pointer] [Flow: call]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora #$1D07.w		; 09 07 1D ; Logical OR #$1D07.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $051D05.l		; 0F 05 1D 05 ; OR accumulator with memory (long) $051D05.l [Writes: Accumulator] [Flags: NZ]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	ora $000207.l		; 0F 07 02 00 ; OR accumulator with memory (long) $000207.l [Writes: Accumulator] [Flags: NZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora $83.b		; 05 83 ; Logical OR $83.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $B9.b		; 00 B9 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $071D.w		; 0C 1D 07 ; Test and set bits $071D.w [Reads: Accumulator] [Flags: Z]
	ora $010502.l		; 0F 02 05 01 ; OR accumulator with memory (long) $010502.l [Writes: Accumulator] [Flags: NZ]
	ora $050F.w,X		; 1D 0F 05 ; OR accumulator with memory $050F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1D4315.l		; 0F 15 43 1D ; OR accumulator with memory (long) $1D4315.l [Writes: Accumulator] [Flags: NZ]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $0F0F1D.l		; 0F 1D 0F 0F ; OR accumulator with memory (long) $0F0F1D.l [Writes: Accumulator] [Flags: NZ]
	ora $0500.w		; 0D 00 05 ; Logical OR $0500.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F1D.w,X		; 1D 1D 0F ; OR accumulator with memory $0F1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	cmp $0E.b,X		; D5 0E ; Compare accumulator $0E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $031D02.l		; 0F 02 1D 03 ; OR accumulator with memory (long) $031D02.l [Writes: Accumulator] [Flags: NZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$10.b]		; 07 10 ; OR accumulator with memory (long) [$10.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1D		; 10 1D ; Branch if plus to $10, $1D [Flow: branch]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $53.b		; 05 53 ; Logical OR $53.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr $E363.w,X		; 5E 63 E3 ; Logical shift right $E363.w,X [Reads: X Index] [Flags: NCZ]
	ora $231C.w,X		; 1D 1C 23 ; OR accumulator with memory $231C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $5004.w,X		; 1D 04 50 ; OR accumulator with memory $5004.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($0A.b),Y		; 51 0A ; Exclusive OR accumulator with memory ($0A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor ($22.b)		; 52 22 ; Exclusive OR accumulator with memory (indirect) ($22.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $37E0.w		; 20 E0 37 ; Jump to subroutine at $37E0.w [Writes: Stack Pointer] [Flow: call]
	sty $95.b,X		; 94 95 ; Store Y register $95.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	ora $098F.w,X		; 1D 8F 09 ; OR accumulator with memory $098F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$9308.w		; A0 08 93 ; Load #$9308.w into Y register [Writes: Y Index] [Flags: NZ]
	lsr $57.b,X		; 56 57 ; Logical shift right $57.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stz $1D9D.w		; 9C 9D 1D ; Store zero to $1D9D.w
	lsr $1D4F.w		; 4E 4F 1D ; Logical shift right $1D4F.w [Flags: NCZ]
	lsr $1D50.w,X		; 5E 50 1D ; Logical shift right $1D50.w,X [Reads: X Index] [Flags: NCZ]
	lsr $73.b,X		; 56 73 ; Logical shift right $73.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $540253.l		; 22 53 02 54 ; Jump to subroutine long $540253.l [Writes: Stack Pointer] [Flow: call]
	ror $BB.b,X		; 76 BB ; Rotate right $BB.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor $47.b,X		; 55 47 ; Exclusive OR accumulator with memory $47.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $57.b,X		; 56 57 ; Logical shift right $57.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $58BA.w		; 0D BA 58 ; Logical OR $58BA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	.db $10, $8E		; 10 8E ; Branch if plus to $10, $8E [Flow: branch]
	stz $0A.b,X		; 74 0A ; Store zero to $0A.b,X [Reads: X Index]
	adc $86.b,S		; 63 86 ; Add with carry (stack relative) $86.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $551D.w,X		; 1D 1D 55 ; OR accumulator with memory $551D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor [$56.b]		; 47 56 ; Exclusive OR accumulator with memory (long) [$56.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $5B1D.w,X		; 1D 1D 5B ; OR accumulator with memory $5B1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $5E0108.l		; 22 08 01 5E ; Jump to subroutine long $5E0108.l [Writes: Stack Pointer] [Flow: call]
	jmp ($7562.w,X)		; 7C 62 75 ; Jump indirect indexed to ($7562.w,X) [Reads: X Index] [Flow: jump]
	ora [$2B.b]		; 07 2B ; OR accumulator with memory (long) [$2B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	bit $643B.w		; 2C 3B 64 ; Test bits $643B.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	adc $B3.b		; 65 B3 ; Add $B3.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $22.b		; 66 22 ; Rotate right $22.b [Reads: Direct Page] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $78.b,S		; A3 78 ; Load accumulator (stack relative) $78.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $62, $79, $05		; 62 79 05 ; Push effective relative address $62, $79, $05 [Writes: Stack Pointer]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	stz $6F.b		; 64 6F ; Store zero to $6F.b
	adc $711F.w,Y		; 79 1F 71 ; Add $711F.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	jsl $92E080.l		; 22 80 E0 92 ; Jump to subroutine long $92E080.l [Writes: Stack Pointer] [Flow: call]
	rol $7C.b,X		; 36 7C ; Rotate left $7C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc $DD6A.w,X		; 7D 6A DD ; Add $DD6A.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $47.b		; 46 47 ; Logical shift right $47.b [Reads: Direct Page] [Flags: NCZ]
	ora $796F.w,X		; 1D 6F 79 ; OR accumulator with memory $796F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $E536.w,X		; 9D 36 E5 ; Store accumulator to $E536.w,X [Reads: Accumulator, X Index]
	sta [$7E.b]		; 87 7E ; Store accumulator (long) [$7E.b] [Reads: Direct Page, Accumulator]
	sbc $1D.b		; E5 1D ; Subtract $1D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $3B.b		; E5 3B ; Subtract $3B.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($D57D.w,X)		; 7C 7D D5 ; Jump indirect indexed to ($D57D.w,X) [Reads: X Index] [Flow: jump]
	and $35.b,X		; 35 35 ; Logical AND $35.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $902322.l,X		; 7F 22 23 90 ; Add long $902322.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $E580B2.l,X		; 7F B2 80 E5 ; Add long $E580B2.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($E4.b,X)		; 81 E4 ; Store accumulator ($E4.b,X) [Reads: Direct Page, Accumulator, X Index]
	lda ($7B.b)		; B2 7B ; Load accumulator (indirect) ($7B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $83.b		; A6 83 ; Load $83.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ora $841D.w,X		; 1D 1D 84 ; OR accumulator with memory $841D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $54.b,X		; 95 54 ; Store accumulator to $54.b,X [Reads: Accumulator, X Index]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $9F0B82.l,X		; 7F 82 0B 9F ; Add long $9F0B82.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $E5		; 80 E5 ; Branch always to $80, $E5 [Flow: branch]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	lsr $358C.w,X		; 5E 8C 35 ; Logical shift right $358C.w,X [Reads: X Index] [Flags: NCZ]
	and $8D.b,X		; 35 8D ; Logical AND $8D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	lda ($83.b)		; B2 83 ; Load accumulator (indirect) ($83.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $C1.b		; 84 C1 ; Store Y register to $C1.b [Reads: Y Index]
	clv		; B8 ; Clear overflow flag [Flags: V]
	cmp ($0E.b,X)		; C1 0E ; Compare accumulator ($0E.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	eor ($93.b),Y		; 51 93 ; Exclusive OR accumulator with memory ($93.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	mvn $1D,$94		; 54 94 1D ; Move block negative $1D,$94 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda $95.b		; A5 95 ; Load $95.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	bit $78.b		; 24 78 ; Test bits $78.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	stx $85A8.w		; 8E A8 85 ; Store X register to $85A8.w [Reads: X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($5B.b),Y		; B1 5B ; Load accumulator ($5B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ror $7A.b,X		; 76 7A ; Rotate right $7A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $3003.w,X		; 1D 03 30 ; OR accumulator with memory $3003.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc [$E3.b],Y		; F7 E3 ; Subtract with carry (long indexed) [$E3.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $86CD7B.l,X		; 7F 7B CD 86 ; Add long $86CD7B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $24		; 80 24 ; Branch always to $80, $24 [Flow: branch]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	stx $4A.b		; 86 4A ; Store X register to $4A.b [Reads: X Index]
	sbc ($87.b)		; F2 87 ; Subtract with carry (indirect) ($87.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	adc ($95.b,S),Y		; 73 95 ; Add with carry (stack relative indirect indexed) ($95.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	bit $79.b		; 24 79 ; Test bits $79.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	stx $88.b		; 86 88 ; Store X register to $88.b [Reads: X Index]
	sbc $7F.b		; E5 7F ; Subtract $7F.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B2.b		; E5 B2 ; Subtract $B2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	bit #$9E9D.w		; 89 9D 9E ; Test bits #$9E9D.w with accumulator [Reads: Accumulator] [Flags: Z]
	cmp ($1D.b,X)		; C1 1D ; Compare accumulator ($1D.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	adc ($95.b,S),Y		; 73 95 ; Add with carry (stack relative indirect indexed) ($95.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	lda [$A8.b]		; A7 A8 ; Load accumulator (long) [$A8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $1D.b		; E5 1D ; Subtract $1D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $6A		; 90 6A ; Branch if carry clear to $90, $6A [Flow: branch]
	lda ($02.b,X)		; A1 02 ; Load accumulator ($02.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $1CA8.w		; 8C A8 1C ; Store Y register to $1CA8.w [Reads: Y Index]
	ldx #$E395.w		; A2 95 E3 ; Load #$E395.w into X register [Writes: X Index] [Flags: NZ]
	lda [$8D.b],Y		; B7 8D ; Load accumulator (long indexed) [$8D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $3B.b,X		; 15 3B ; OR accumulator with memory $3B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $FF.b		; E5 FF ; Subtract $FF.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($03.b)		; 12 03 ; OR accumulator with memory (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0F.b		; 02 0F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$08.b]		; 07 08 ; OR accumulator with memory (long) [$08.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $070101.l		; 22 01 01 07 ; Jump to subroutine long $070101.l [Writes: Stack Pointer] [Flow: call]
	asl $87.b		; 06 87 ; Arithmetic shift left $87.b [Reads: Direct Page] [Flags: NCZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $090507.l		; 0F 07 05 09 ; OR accumulator with memory (long) $090507.l [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F0F.w,X		; 1D 0F 0F ; OR accumulator with memory $0F0F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $05140F.l		; 22 0F 14 05 ; Jump to subroutine long $05140F.l [Writes: Stack Pointer] [Flow: call]
	ora $0F0905.l		; 0F 05 09 0F ; OR accumulator with memory (long) $0F0905.l [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $070501.l		; 0F 01 05 07 ; OR accumulator with memory (long) $070501.l [Writes: Accumulator] [Flags: NZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $0900.w,X		; 3D 00 09 ; AND accumulator with memory $0900.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsl $090207.l		; 22 07 02 09 ; Jump to subroutine long $090207.l [Writes: Stack Pointer] [Flow: call]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $0702.w,X		; 3D 02 07 ; AND accumulator with memory $0702.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $05.b		; 24 05 ; Test bits $05.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $1D220F.l		; 0F 0F 22 1D ; OR accumulator with memory (long) $1D220F.l [Writes: Accumulator] [Flags: NZ]
	tsb $0F05.w		; 0C 05 0F ; Test and set bits $0F05.w [Reads: Accumulator] [Flags: Z]
	ora $0911.w,X		; 1D 11 09 ; OR accumulator with memory $0911.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F05.w,X		; 1D 05 0F ; OR accumulator with memory $0F05.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rol $1D.b		; 26 1D ; Rotate left $1D.b [Reads: Direct Page] [Flags: NCZ]
	ora #$0F1C.w		; 09 1C 0F ; Logical OR #$0F1C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	trb $071D.w		; 1C 1D 07 ; Test and reset bits $071D.w [Reads: Accumulator] [Flags: Z]
	ora $0F0F05.l		; 0F 05 0F 0F ; OR accumulator with memory (long) $0F0F05.l [Writes: Accumulator] [Flags: NZ]
	ora $28.b		; 05 28 ; Logical OR $28.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F22.w,X		; 1D 22 0F ; OR accumulator with memory $0F22.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $0B.b		; 02 0B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1D2C02.l		; 0F 02 2C 1D ; OR accumulator with memory (long) $1D2C02.l [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1D2C02.l		; 0F 02 2C 1D ; OR accumulator with memory (long) $1D2C02.l [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1D2B0F.l		; 0F 0F 2B 1D ; OR accumulator with memory (long) $1D2B0F.l [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $031D.w		; 2C 1D 03 ; Test bits $031D.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	ora $1C03.w,X		; 1D 03 1C ; OR accumulator with memory $1C03.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $021D2C.l		; 0F 2C 1D 02 ; OR accumulator with memory (long) $021D2C.l [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $18FF01.l		; 0F 01 FF 18 ; OR accumulator with memory (long) $18FF01.l [Writes: Accumulator] [Flags: NZ]
	and ($A6.b,X)		; 21 A6 ; Logical AND ($A6.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvn $20,$20		; 54 20 20 ; Move block negative $20,$20 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tsb $DC53.w		; 0C 53 DC ; Test and set bits $DC53.w [Reads: Accumulator] [Flags: Z]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	adc $BF.b,X		; 75 BF ; Add $BF.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$82.b],Y		; 77 82 ; Add with carry (long indexed) [$82.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $ED, $52		; 82 ED 52 ; Branch always long to $82, $ED, $52 [Flow: branch]
	ror $F8.b,X		; 76 F8 ; Rotate right $F8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora [$12.b],Y		; 17 12 ; OR accumulator with memory (long indexed) [$12.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $86AB.w		; AE AB 86 ; Load $86AB.w into X register [Writes: X Index] [Flags: NZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$AC43.w		; E0 43 AC ; Compare #$AC43.w with X register [Reads: X Index] [Flags: NCZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sbc $0202.w		; ED 02 02 ; Subtract $0202.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	ora $9C.b,S		; 03 9C ; OR accumulator with stack relative $9C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $17AD.w,X		; 5E AD 17 ; Logical shift right $17AD.w,X [Reads: X Index] [Flags: NCZ]
	inc $1D.b		; E6 1D ; Increment $1D.b [Reads: Direct Page] [Flags: NZ]
	eor ($77.b,X)		; 41 77 ; Exclusive OR accumulator with memory ($77.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $82, $82, $8E		; 82 82 8E ; Branch always long to $82, $82, $8E [Flow: branch]
	lda $0A0AB0.l		; AF B0 0A 0A ; Load long $0A0AB0.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($B2.b),Y		; B1 B2 ; Load accumulator ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $B39D.w		; AD 9D B3 ; Load $B39D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($23.b)		; F2 23 ; Subtract with carry (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldy $77.b,X		; B4 77 ; Load Y register $77.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	.db $82, $82, $20		; 82 82 20 ; Branch always long to $82, $82, $20 [Flow: branch]
	ora #$A4B5.w		; 09 B5 A4 ; Logical OR #$A4B5.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $B6.b		; A4 B6 ; Load $B6.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sbc $239D.w,X		; FD 9D 23 ; Subtract with carry $239D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$FE.b],Y		; 37 FE ; AND accumulator with memory (long indexed) [$FE.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy $776A.w		; CC 6A 77 ; Compare $776A.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $82, $82, $18		; 82 82 18 ; Branch always long to $82, $82, $18 [Flow: branch]
	sbc $E5E5A3.l,X		; FF A3 E5 E5 ; Subtract with carry (long,X) $E5E5A3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $3B1CB0.l		; AF B0 1C 3B ; Load long $3B1CB0.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $BF.b,X		; 75 BF ; Add $BF.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda #$8277.w		; A9 77 82 ; Load #$8277.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $82, $90, $24		; 82 90 24 ; Branch always long to $82, $90, $24 [Flow: branch]
	sbc $44.b		; E5 44 ; Subtract $44.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl $3C.b		; 06 3C ; Arithmetic shift left $3C.b [Reads: Direct Page] [Flags: NCZ]
	and $C6F0.w,X		; 3D F0 C6 ; AND accumulator with memory $C6F0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$B8.b],Y		; 77 B8 ; Add with carry (long indexed) [$B8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $8F62.w,X		; BC 62 8F ; Load Y register $8F62.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tsb $79E5.w		; 0C E5 79 ; Test and set bits $79E5.w [Reads: Accumulator] [Flags: Z]
	sta ($0E.b)		; 92 0E ; Store accumulator (indirect) ($0E.b) [Reads: Direct Page, Accumulator]
	lda $E8.b		; A5 E8 ; Load $E8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $BE2D45.l		; AF 45 2D BE ; Load long $BE2D45.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($67.b,S),Y		; 93 67 ; Store accumulator (stack relative indirect indexed) ($67.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	cpy #$9466.w		; C0 66 94 ; Compare #$9466.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora #$696D.w		; 09 6D 69 ; Logical OR #$696D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $359B.w		; 6D 9B 35 ; Add $359B.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
.ACCU 16
	rep #$A6		; C2 A6
	cmp $C4.b,S		; C3 C4 ; Compare accumulator (stack relative) $C4.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	sbc $68.b		; E5 68 ; Subtract $68.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	stz $A705.w		; 9C 05 A7 ; Store zero to $A705.w
	sta $C7E1A0.l,X		; 9F A0 E1 C7 ; Store accumulator (long,X) $C7E1A0.l,X [Reads: Accumulator, X Index]
	.db $82, $63, $A5		; 82 63 A5 ; Branch always long to $82, $63, $A5 [Flow: branch]
	cop $A8.b		; 02 A8 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$65A8.w		; A9 A8 65 ; Load #$65A8.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cop $52.b		; 02 52 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $6682.w		; CC 82 66 ; Compare $6682.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $B0, $01		; B0 01 ; Branch if carry set to $B0, $01 [Flow: branch]
	ldy $B4.b,X		; B4 B4 ; Load Y register $B4.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	adc $B7.b,S		; 63 B7 ; Add with carry (stack relative) $B7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora [$52.b]		; 07 52 ; OR accumulator with memory (long) [$52.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpy $BBD0.w		; CC D0 BB ; Compare $BBD0.w with Y register [Reads: Y Index] [Flags: NCZ]
	ldy $BDB2.w,X		; BC B2 BD ; Load Y register $BDB2.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx $62.b,Y		; B6 62 ; Load X register $62.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	ldx $B609.w,Y		; BE 09 B6 ; Load X register $B609.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	lda [$C1.b],Y		; B7 C1 ; Load accumulator (long indexed) [$C1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$3B		; C2 3B
	eor ($CC.b)		; 52 CC ; Exclusive OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $C4.b,S		; C3 C4 ; Compare accumulator (stack relative) $C4.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	lda ($64.b),Y		; B1 64 ; Load accumulator ($64.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $00.b		; C5 00 ; Compare $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	dec $63.b		; C6 63 ; Decrement $63.b [Reads: Direct Page] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $E5.b,S		; 03 E5 ; OR accumulator with stack relative $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$53.b],Y		; 37 53 ; AND accumulator with memory (long indexed) [$53.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $C206.w		; CE 06 C2 ; Decrement $C206.w [Flags: NZ]
	bit $DDDC.w,X		; 3C DC DD ; Test bits $DDDC.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	.db $D0, $62		; D0 62 ; Branch if not equal to $D0, $62 [Flow: branch]
	jmp.w [$DE62]		; DC 62 DE ; Jump long indirect [$DE62] [Flow: jump]
	asl $D0.b		; 06 D0 ; Arithmetic shift left $D0.b [Reads: Direct Page] [Flags: NCZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	sbc ($E2.b,X)		; E1 E2 ; Subtract with carry ($E2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($C7.b,X)		; E1 C7 ; Subtract with carry ($C7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $FF.b		; 25 FF ; Logical AND $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($24.b,X)		; 01 24 ; Logical OR ($24.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0E1D03.l		; 0F 03 1D 0E ; OR accumulator with memory (long) $0E1D03.l [Writes: Accumulator] [Flags: NZ]
	ora $0E.b,S		; 03 0E ; OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $24E001.l		; 22 01 E0 24 ; Jump to subroutine long $24E001.l [Writes: Stack Pointer] [Flow: call]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $0F1D1D.l		; 0F 1D 1D 0F ; OR accumulator with memory (long) $0F1D1D.l [Writes: Accumulator] [Flags: NZ]
	ora $040E.w,X		; 1D 0E 04 ; OR accumulator with memory $040E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1D.b		; 05 1D ; Logical OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1D01.w,X		; 1D 01 1D ; OR accumulator with memory $1D01.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $1B1D.w,X		; 1D 1D 1B ; OR accumulator with memory $1B1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1D.b		; 05 1D ; Logical OR $1D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0623.w,Y		; 19 23 06 ; OR accumulator with memory $0623.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1D.b),Y		; 11 1D ; OR accumulator with memory ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0F.b		; 04 0F ; Test and set bits $0F.b [Reads: Accumulator] [Flags: Z]
	tsb $1D.b		; 04 1D ; Test and set bits $1D.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0700.w,X		; 1D 00 07 ; OR accumulator with memory $0700.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $09.b		; 06 09 ; Arithmetic shift left $09.b [Reads: Direct Page] [Flags: NCZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1B0315.l		; 0F 15 03 1B ; OR accumulator with memory (long) $1B0315.l [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0101.w,X		; 1D 01 01 ; OR accumulator with memory $0101.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $021D.w,X		; 1D 1D 02 ; OR accumulator with memory $021D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $1D.b,S		; 23 1D ; AND accumulator with stack relative $1D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	ora $2205.w,X		; 1D 05 22 ; OR accumulator with memory $2205.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora $1C11.w,X		; 1D 11 1C ; OR accumulator with memory $1C11.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0101.w,Y		; 19 01 01 ; OR accumulator with memory $0101.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1D.b,X		; 15 1D ; OR accumulator with memory $1D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$0507.w		; 09 07 05 ; Logical OR #$0507.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1E10.w,X		; 1E 10 1E ; Arithmetic shift left $1E10.w,X [Reads: X Index] [Flags: NCZ]
	ora #$2206.w		; 09 06 22 ; Logical OR #$2206.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0D.b,X)		; 01 0D ; Logical OR ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $051E.w,X		; 1E 1E 05 ; Arithmetic shift left $051E.w,X [Reads: X Index] [Flags: NCZ]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0509.w		; 0E 09 05 ; Arithmetic shift left $0509.w [Flags: NCZ]
	ora $1E1E06.l		; 0F 06 1E 1E ; OR accumulator with memory (long) $1E1E06.l [Writes: Accumulator] [Flags: NZ]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $072201.l		; 22 01 22 07 ; Jump to subroutine long $072201.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $0F0F.w,X		; 1E 0F 0F ; Arithmetic shift left $0F0F.w,X [Reads: X Index] [Flags: NCZ]
	ora #$1E05.w		; 09 05 1E ; Logical OR #$1E05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: NCZ]
	asl $0123.w,X		; 1E 23 01 ; Arithmetic shift left $0123.w,X [Reads: X Index] [Flags: NCZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $1E.b,S		; 43 1E ; Exclusive OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$85.b]		; 07 85 ; OR accumulator with memory (long) [$85.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0B.b		; 06 0B ; Arithmetic shift left $0B.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	ora #$0B07.w		; 09 07 0B ; Logical OR #$0B07.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $1E16.w,X		; 1E 16 1E ; Arithmetic shift left $1E16.w,X [Reads: X Index] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $830F.w,X		; 1E 0F 83 ; Arithmetic shift left $830F.w,X [Reads: X Index] [Flags: NCZ]
	brk $C1.b		; 00 C1 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $0710.w,X		; 1E 10 07 ; Arithmetic shift left $0710.w,X [Reads: X Index] [Flags: NCZ]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0C05.w,X		; 1E 05 0C ; Arithmetic shift left $0C05.w,X [Reads: X Index] [Flags: NCZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cmp ($0C.b),Y		; D1 0C ; Compare accumulator ($0C.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	asl $1010.w,X		; 1E 10 10 ; Arithmetic shift left $1010.w,X [Reads: X Index] [Flags: NCZ]
	asl $051E.w,X		; 1E 1E 05 ; Arithmetic shift left $051E.w,X [Reads: X Index] [Flags: NCZ]
	asl $1B1E.w,X		; 1E 1E 1B ; Arithmetic shift left $1B1E.w,X [Reads: X Index] [Flags: NCZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $0A091E.l		; 22 1E 09 0A ; Jump to subroutine long $0A091E.l [Writes: Stack Pointer] [Flow: call]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1E.b		; 05 1E ; Logical OR $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0105.w,X		; 1E 05 01 ; Arithmetic shift left $0105.w,X [Reads: X Index] [Flags: NCZ]
	sbc $EDED01.l,X		; FF 01 ED ED ; Subtract with carry (long,X) $EDED01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $4B.b		; 24 4B ; Test bits $4B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cpx #$E32B.w		; E0 2B E3 ; Compare #$E32B.w with X register [Reads: X Index] [Flags: NCZ]
	ora $6C.b,S		; 03 6C ; OR accumulator with stack relative $6C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $24.b,S		; 03 24 ; OR accumulator with stack relative $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $82, $64, $ED		; 82 64 ED ; Branch always long to $82, $64, $ED [Flow: branch]
	sbc $4BC0.w		; ED C0 4B ; Subtract $4BC0.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cpx $E5.b		; E4 E5 ; Compare $E5.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc $03.b,S		; E3 03 ; Subtract stack-relative $03.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	jsl $827523.l		; 22 23 75 82 ; Jump to subroutine long $827523.l [Writes: Stack Pointer] [Flow: call]
	stz $E6.b		; 64 E6 ; Store zero to $E6.b
	sbc [$ED.b]		; E7 ED ; Subtract with carry (long) [$ED.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and ($7A.b),Y		; 31 7A ; AND accumulator with memory ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc #$027A.w		; E9 7A 02 ; Subtract #$027A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	jsl $1E6AA8.l		; 22 A8 6A 1E ; Jump to subroutine long $1E6AA8.l [Writes: Stack Pointer] [Flow: call]
	rol $E664.w		; 2E 64 E6 ; Rotate left $E664.w [Flags: NCZ]
	dec $86D6.w,X		; DE D6 86 ; Decrement memory $86D6.w,X [Reads: X Index] [Flags: NZ]
	cmp $118023.l		; CF 23 80 11 ; Compare accumulator (long) $118023.l [Reads: Accumulator] [Flags: NCZ]
	nop		; EA ; No operation
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $05C2.w,Y		; 99 C2 05 ; Store accumulator to $05C2.w,Y [Reads: Y Index, Accumulator]
	sta ($E6.b),Y		; 91 E6 ; Store accumulator ($E6.b),Y [Reads: Direct Page, Y Index, Accumulator]
	dec $8782.w,X		; DE 82 87 ; Decrement memory $8782.w,X [Reads: X Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $80B6.w,X		; 1D B6 80 ; OR accumulator with memory $80B6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $6087.w		; 2D 87 60 ; Logical AND $6087.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $63.b,X		; 35 63 ; Logical AND $63.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $DE0B.w		; EC 0B DE ; Compare $DE0B.w with X register [Reads: X Index] [Flags: NCZ]
	.db $82, $E2, $93		; 82 E2 93 ; Branch always long to $82, $E2, $93 [Flow: branch]
	lda [$5D.b],Y		; B7 5D ; Load accumulator (long indexed) [$5D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $F008.w,Y		; BE 08 F0 ; Load X register $F008.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	.db $F0, $DB		; F0 DB ; Branch if equal to $F0, $DB [Flow: branch]
	adc $63.b,X		; 75 63 ; Add $63.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($0B.b),Y		; F1 0B ; Subtract with carry ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $E2, $03		; 82 E2 03 ; Branch always long to $82, $E2, $03 [Flow: branch]
	dec $F6F5.w		; CE F5 F6 ; Decrement $F6F5.w [Flags: NZ]
	adc $2DD7.w,Y		; 79 D7 2D ; Add $2DD7.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $DB.b		; E6 DB ; Increment $DB.b [Reads: Direct Page] [Flags: NZ]
	adc $F7.b,S		; 63 F7 ; Add with carry (stack relative) $F7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sep #$03		; E2 03 ; Set processor status bits #$03 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora $CE.b,S		; 03 CE ; OR accumulator with stack relative $CE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $FB.b		; 65 FB ; Add $FB.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $3580.w,X		; 9D 80 35 ; Store accumulator to $3580.w,X [Reads: Accumulator, X Index]
	.db $80, $1A		; 80 1A ; Branch always to $80, $1A [Flow: branch]
	.db $62, $FC, $E0		; 62 FC E0 ; Push effective relative address $62, $FC, $E0 [Writes: Stack Pointer]
	and $FCE3.w,X		; 3D E3 FC ; AND accumulator with memory $FCE3.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora [$8B.b],Y		; 17 8B ; OR accumulator with memory (long indexed) [$8B.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $E5.b		; 24 E5 ; Test bits $E5.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor ($00.b)		; 52 00 ; Exclusive OR accumulator with memory (indirect) ($00.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $01.b		; E5 01 ; Subtract $01.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $01A6.w,X		; DD A6 01 ; Compare accumulator $01A6.w,X [Reads: X Index] [Flags: NCZ]
	bit $73.b		; 24 73 ; Test bits $73.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $3A.b,S		; A3 3A ; Load accumulator (stack relative) $3A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $2F.b		; 04 2F ; Test and set bits $2F.b [Reads: Accumulator] [Flags: Z]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sta [$0B.b],Y		; 97 0B ; Store accumulator (long indexed) [$0B.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $37.b		; 06 37 ; Arithmetic shift left $37.b [Reads: Direct Page] [Flags: NCZ]
	adc ($73.b,S),Y		; 73 73 ; Add with carry (stack relative indirect indexed) ($73.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	dec $95.b,X		; D6 95 ; Decrement memory $95.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	bit $6E.b		; 24 6E ; Test bits $6E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$89.b]		; 07 89 ; OR accumulator with memory (long) [$89.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $090B08.l		; AF 08 0B 09 ; Load long $090B08.l into accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$7349.w		; 69 49 73 ; Add #$7349.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	dec $95.b,X		; D6 95 ; Decrement memory $95.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $75.b		; E5 75 ; Subtract $75.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $3AC90C.l,X		; FF 0C C9 3A ; Subtract with carry (long,X) $3AC90C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cpx #$0D35.w		; E0 35 0D ; Compare #$0D35.w with X register [Reads: X Index] [Flags: NCZ]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $95.b,X		; D6 95 ; Decrement memory $95.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl $050F.w		; 0E 0F 05 ; Arithmetic shift left $050F.w [Flags: NCZ]
	sbc $245A41.l		; EF 41 5A 24 ; Subtract with carry (long) $245A41.l [Writes: Accumulator] [Flags: NCVZ]
	sbc ($0E.b,X)		; E1 0E ; Subtract with carry ($0E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $170F.w,X		; BD 0F 17 ; Load $170F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cmp $1A1849.l		; CF 49 18 1A ; Compare accumulator (long) $1A1849.l [Reads: Accumulator] [Flags: NCZ]
	ora $41EF11.l		; 0F 11 EF 41 ; OR accumulator with memory (long) $41EF11.l [Writes: Accumulator] [Flags: NZ]
	.db $42, $E2		; 42 E2 ; Reserved instruction
	ora ($FF.b)		; 12 FF ; OR accumulator with memory (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	stx $03.b,Y		; 96 03 ; Store X register $03.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ora $D4D306.l,X		; 1F 06 D3 D4 ; Logical OR long $D4D306.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($EE.b,S),Y		; 13 EE ; OR accumulator (stack relative indirect indexed) ($EE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $F81514.l		; EF 14 15 F8 ; Subtract with carry (long) $F81514.l [Writes: Accumulator] [Flags: NCVZ]
	asl $17.b,X		; 16 17 ; Arithmetic shift left $17.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $F571.w,X		; FD 71 F5 ; Subtract with carry $F571.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $8E.b,S		; 63 8E ; Add with carry (stack relative) $8E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $18, $09		; 62 18 09 ; Push effective relative address $62, $18, $09 [Writes: Stack Pointer]
	tsb $EEFF.w		; 0C FF EE ; Test and set bits $EEFF.w [Reads: Accumulator] [Flags: Z]
	inc $FF00.w,X		; FE 00 FF ; Increment memory $FF00.w,X [Reads: X Index] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $71ED.w		; 1C ED 71 ; Test and reset bits $71ED.w [Reads: Accumulator] [Flags: Z]
	sbc $030D07.l,X		; FF 07 0D 03 ; Subtract with carry (long,X) $030D07.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	trb $1C05.w		; 1C 05 1C ; Test and reset bits $1C05.w [Reads: Accumulator] [Flags: Z]
	ora $081E22.l		; 0F 22 1E 08 ; OR accumulator with memory (long) $081E22.l [Writes: Accumulator] [Flags: NZ]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b,X		; 15 05 ; OR accumulator with memory $05.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0B		; 10 0B ; Branch if plus to $10, $0B [Flow: branch]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1D1C22.l		; 0F 22 1C 1D ; OR accumulator with memory (long) $1D1C22.l [Writes: Accumulator] [Flags: NZ]
	ora ($05.b),Y		; 11 05 ; OR accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0505.w		; 1C 05 05 ; Test and reset bits $0505.w [Reads: Accumulator] [Flags: Z]
	asl $1E10.w,X		; 1E 10 1E ; Arithmetic shift left $1E10.w,X [Reads: X Index] [Flags: NCZ]
	asl $1C1C.w,X		; 1E 1C 1C ; Arithmetic shift left $1C1C.w,X [Reads: X Index] [Flags: NCZ]
	asl $0F1E.w,X		; 1E 1E 0F ; Arithmetic shift left $0F1E.w,X [Reads: X Index] [Flags: NCZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1111.w,X		; 1D 11 11 ; OR accumulator with memory $1111.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $061E.w,X		; 1E 1E 06 ; Arithmetic shift left $061E.w,X [Reads: X Index] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $0D.b		; 25 0D ; Logical AND $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0F1C.w,X		; 1D 1C 0F ; OR accumulator with memory $0F1C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $050F.w,X		; 1E 0F 05 ; Arithmetic shift left $050F.w,X [Reads: X Index] [Flags: NCZ]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $06031E.l		; 0F 1E 03 06 ; OR accumulator with memory (long) $06031E.l [Writes: Accumulator] [Flags: NZ]
	trb $2311.w		; 1C 11 23 ; Test and reset bits $2311.w [Reads: Accumulator] [Flags: Z]
	asl $20E0.w,X		; 1E E0 20 ; Arithmetic shift left $20E0.w,X [Reads: X Index] [Flags: NCZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora $03.b		; 05 03 ; Logical OR $03.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $031E.w,X		; 1E 1E 03 ; Arithmetic shift left $031E.w,X [Reads: X Index] [Flags: NCZ]
	asl $1E.b,X		; 16 1E ; Arithmetic shift left $1E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $15.b		; 05 15 ; Logical OR $15.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0511.w,X		; 1E 11 05 ; Arithmetic shift left $0511.w,X [Reads: X Index] [Flags: NCZ]
	ora $1E.b		; 05 1E ; Logical OR $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0F1E.w		; 1C 1E 0F ; Test and reset bits $0F1E.w [Reads: Accumulator] [Flags: Z]
	ora $16.b,S		; 03 16 ; OR accumulator with stack relative $16.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $151E.w,X		; 1E 1E 15 ; Arithmetic shift left $151E.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora $22051E.l		; 0F 1E 05 22 ; OR accumulator with memory (long) $22051E.l [Writes: Accumulator] [Flags: NZ]
	asl $050A.w,X		; 1E 0A 05 ; Arithmetic shift left $050A.w,X [Reads: X Index] [Flags: NCZ]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1E.b,X		; 16 1E ; Arithmetic shift left $1E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $151D.w		; 1C 1D 15 ; Test and reset bits $151D.w [Reads: Accumulator] [Flags: Z]
	trb $051E.w		; 1C 1E 05 ; Test and reset bits $051E.w [Reads: Accumulator] [Flags: Z]
	jsl $05221C.l		; 22 1C 22 05 ; Jump to subroutine long $05221C.l [Writes: Stack Pointer] [Flow: call]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	asl $1E0C.w,X		; 1E 0C 1E ; Arithmetic shift left $1E0C.w,X [Reads: X Index] [Flags: NCZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $44.b,X		; 15 44 ; OR accumulator with memory $44.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0A1C.w,X		; 1E 1C 0A ; Arithmetic shift left $0A1C.w,X [Reads: X Index] [Flags: NCZ]
	asl $1C05.w,X		; 1E 05 1C ; Arithmetic shift left $1C05.w,X [Reads: X Index] [Flags: NCZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: NCZ]
	asl $1C10.w,X		; 1E 10 1C ; Arithmetic shift left $1C10.w,X [Reads: X Index] [Flags: NCZ]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0D1E.w		; 1C 1E 0D ; Test and reset bits $0D1E.w [Reads: Accumulator] [Flags: Z]
	asl $1E1C.w,X		; 1E 1C 1E ; Arithmetic shift left $1E1C.w,X [Reads: X Index] [Flags: NCZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $1C10.w,X		; 1E 10 1C ; Arithmetic shift left $1C10.w,X [Reads: X Index] [Flags: NCZ]
	trb $1C10.w		; 1C 10 1C ; Test and reset bits $1C10.w [Reads: Accumulator] [Flags: Z]
	trb $1E2D.w		; 1C 2D 1E ; Test and reset bits $1E2D.w [Reads: Accumulator] [Flags: Z]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	trb $1E23.w		; 1C 23 1E ; Test and reset bits $1E23.w [Reads: Accumulator] [Flags: Z]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0F1E.w,X		; 1E 1E 0F ; Arithmetic shift left $0F1E.w,X [Reads: X Index] [Flags: NCZ]
	tsb $220F.w		; 0C 0F 22 ; Test and set bits $220F.w [Reads: Accumulator] [Flags: Z]
	.db $10, $84		; 10 84 ; Branch if plus to $10, $84 [Flow: branch]
	brk $9A.b		; 00 9A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1E.b		; 24 1E ; Test bits $1E.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($23.b,X)		; 01 23 ; Logical OR ($23.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $1E24.w		; 0C 24 1E ; Test and set bits $1E24.w [Reads: Accumulator] [Flags: Z]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0D.b,S		; 03 0D ; OR accumulator with stack relative $0D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $220601.l		; 0F 01 06 22 ; OR accumulator with memory (long) $220601.l [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $221E.w		; 0C 1E 22 ; Test and set bits $221E.w [Reads: Accumulator] [Flags: Z]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	ora ($01.b),Y		; 11 01 ; OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	asl $251E.w,X		; 1E 1E 25 ; Arithmetic shift left $251E.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	asl $1010.w,X		; 1E 10 10 ; Arithmetic shift left $1010.w,X [Reads: X Index] [Flags: NCZ]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $635407.l,X		; FF 07 54 63 ; Subtract with carry (long,X) $635407.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $4C63.w		; CE 63 4C ; Decrement $4C63.w [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor ($8F.b,S),Y		; 53 8F ; XOR accumulator (stack relative indirect indexed) ($8F.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $1D, $E0		; 62 1D E0 ; Push effective relative address $62, $1D, $E0 [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $A2.b,X		; 15 A2 ; OR accumulator with memory $A2.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lsr $E765.w,X		; 5E 65 E7 ; Logical shift right $E765.w,X [Reads: X Index] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	jmp $B79C.w		; 4C 9C B7 ; Jump to $B79C.w [Flow: jump]
	ora $E5.b,X		; 15 E5 ; OR accumulator with memory $E5.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($20.b),Y		; 51 20 ; Exclusive OR accumulator with memory ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $A4D7.w		; CD D7 A4 ; Compare $A4D7.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	and ($D4.b,X)		; 21 D4 ; Logical AND ($D4.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $848323.l		; 22 23 83 84 ; Jump to subroutine long $848323.l [Writes: Stack Pointer] [Flow: call]
	bit $25.b		; 24 25 ; Test bits $25.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	sbc $80.b		; E5 80 ; Subtract $80.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	adc $24.b,S		; 63 24 ; Add with carry (stack relative) $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	rol $27.b		; 26 27 ; Rotate left $27.b [Reads: Direct Page] [Flags: NCZ]
	bit $8D.b		; 24 8D ; Test bits $8D.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and #$0BA7.w		; 29 A7 0B ; Logical AND #$0BA7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $2A69.w		; 6D 69 2A ; Add $2A69.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $A8		; 80 A8 ; Branch always to $80, $A8 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc $F1.b,S		; 63 F1 ; Add with carry (stack relative) $F1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	adc $24.b,S		; 63 24 ; Add with carry (stack relative) $24.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sta $630C.w		; 8D 0C 63 ; Store accumulator to $630C.w [Reads: Accumulator]
	bit $20E0.w		; 2C E0 20 ; Test bits $20E0.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor ($B8.b,S),Y		; 53 B8 ; XOR accumulator (stack relative indirect indexed) ($B8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$A8.b],Y		; 17 A8 ; OR accumulator with memory (long indexed) [$A8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $30.b,S		; 63 30 ; Add with carry (stack relative) $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($65.b),Y		; 31 65 ; AND accumulator with memory ($65.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $32.b,X		; B5 32 ; Load $32.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $86.b		; E5 86 ; Subtract $86.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $A812.w		; 20 12 A8 ; Jump to subroutine at $A812.w [Writes: Stack Pointer] [Flow: call]
	cmp ($33.b,X)		; C1 33 ; Compare accumulator ($33.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	lsr $34.b,X		; 56 34 ; Logical shift right $34.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc $6A.b,X		; F5 6A ; Subtract $6A.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $3635.w,X		; BC 35 36 ; Load Y register $3635.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	ldx #$0EB8.w		; A2 B8 0E ; Load #$0EB8.w into X register [Writes: X Index] [Flags: NZ]
	.db $80, $37		; 80 37 ; Branch always to $80, $37 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $62, $38, $E0		; 62 38 E0 ; Push effective relative address $62, $38, $E0 [Writes: Stack Pointer]
	and $65A8.w,X		; 3D A8 65 ; AND accumulator with memory $65A8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $C635.w,X		; BC 35 C6 ; Load Y register $C635.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	ldx #$3C95.w		; A2 95 3C ; Load #$3C95.w into X register [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	stz $56B7.w		; 9C B7 56 ; Store zero to $56B7.w
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cmp ($F8.b,X)		; C1 F8 ; Compare accumulator ($F8.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	and $3E99.w,X		; 3D 99 3E ; AND accumulator with memory $3E99.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ldx $3F86.w		; AE 86 3F ; Load $3F86.w into X register [Writes: X Index] [Flags: NZ]
	ldy $40.b		; A4 40 ; Load $40.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	eor ($33.b,X)		; 41 33 ; Exclusive OR accumulator with memory ($33.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sta $C1.b,X		; 95 C1 ; Store accumulator to $C1.b,X [Reads: Accumulator, X Index]
	jmp.w [$4224]		; DC 24 42 ; Jump long indirect [$4224] [Flow: jump]
	eor $B8.b,S		; 43 B8 ; Exclusive OR accumulator with stack relative $B8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc ($2E.b,X)		; 61 2E ; Add with carry ($2E.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($41.b,S),Y		; 53 41 ; XOR accumulator (stack relative indirect indexed) ($41.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $33,$53		; 44 53 33 ; Move block positive $33,$53 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $24DC.w,Y		; B9 DC 24 ; Load $24DC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $56B8.w,X		; 3E B8 56 ; Rotate left $56B8.w,X [Reads: X Index] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	clv		; B8 ; Clear overflow flag [Flags: V]
	eor ($95.b,S),Y		; 53 95 ; XOR accumulator (stack relative indirect indexed) ($95.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($41.b,X)		; 41 41 ; Exclusive OR accumulator with memory ($41.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $45.b		; 45 45 ; Exclusive OR $45.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $62, $38, $62		; 62 38 62 ; Push effective relative address $62, $38, $62 [Writes: Stack Pointer]
	lsr $23.b		; 46 23 ; Logical shift right $23.b [Reads: Direct Page] [Flags: NCZ]
	eor #$840B.w		; 49 0B 84 ; Exclusive OR #$840B.w with accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($41.b,S),Y		; 53 41 ; XOR accumulator (stack relative indirect indexed) ($41.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($4A.b,S),Y		; 33 4A ; AND accumulator (stack relative indirect indexed) ($4A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	and $EE8C.w,Y		; 39 8C EE ; AND accumulator with memory $EE8C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $100022.l,X		; FF 22 00 10 ; Subtract with carry (long,X) $100022.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sty $44.b		; 84 44 ; Store Y register to $44.b [Reads: Y Index]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jmp $494D.w		; 4C 4D 49 ; Jump to $494D.w [Flow: jump]
	lsr $8C4F.w		; 4E 4F 8C ; Logical shift right $8C4F.w [Flags: NCZ]
	cmp $9F.b,X		; D5 9F ; Compare accumulator $9F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	ora $EE9F.w,X		; 1D 9F EE ; OR accumulator with memory $EE9F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $50, $02		; 62 50 02 ; Push effective relative address $62, $50, $02 [Writes: Stack Pointer]
	eor ($53.b)		; 52 53 ; Exclusive OR accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	ora [$12.b]		; 07 12 ; OR accumulator with memory (long) [$12.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $83.b		; A6 83 ; Load $83.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cmp $6A.b,X		; D5 6A ; Compare accumulator $6A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $1D1D.w		; 1C 1D 1D ; Test and reset bits $1D1D.w [Reads: Accumulator] [Flags: Z]
	inc $F754.w		; EE 54 F7 ; Increment $F754.w [Flags: NZ]
	ldy $0E.b		; A4 0E ; Load $0E.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	ora ($EB.b,X)		; 01 EB ; Logical OR ($EB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta ($D4.b,X)		; 81 D4 ; Store accumulator ($D4.b,X) [Reads: Direct Page, Accumulator, X Index]
	eor $56.b,X		; 55 56 ; Exclusive OR accumulator with memory $56.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($24.b),Y		; 11 24 ; OR accumulator with memory ($24.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b)		; 12 07 ; OR accumulator with memory (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor [$14.b],Y		; 57 14 ; Exclusive OR accumulator with memory (long indexed) [$14.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $A1.b,X		; 15 A1 ; OR accumulator with memory $A1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($53.b,S),Y		; 53 53 ; XOR accumulator (stack relative indirect indexed) ($53.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $DD.b		; 06 DD ; Arithmetic shift left $DD.b [Reads: Direct Page] [Flags: NCZ]
	sbc $051C08.l,X		; FF 08 1C 05 ; Subtract with carry (long,X) $051C08.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1E.b		; 05 1E ; Logical OR $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $051C.w,X		; 1E 1C 05 ; Arithmetic shift left $051C.w,X [Reads: X Index] [Flags: NCZ]
	asl $2405.w,X		; 1E 05 24 ; Arithmetic shift left $2405.w,X [Reads: X Index] [Flags: NCZ]
	asl $0100.w,X		; 1E 00 01 ; Arithmetic shift left $0100.w,X [Reads: X Index] [Flags: NCZ]
	and $1E.b,S		; 23 1E ; AND accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0501.w		; 1C 01 05 ; Test and reset bits $0501.w [Reads: Accumulator] [Flags: Z]
	asl $1022.w,X		; 1E 22 10 ; Arithmetic shift left $1022.w,X [Reads: X Index] [Flags: NCZ]
	cop $0D.b		; 02 0D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1E.b		; 05 1E ; Logical OR $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $101E.w,X		; 1E 1E 10 ; Arithmetic shift left $101E.w,X [Reads: X Index] [Flags: NCZ]
	asl $0123.w,X		; 1E 23 01 ; Arithmetic shift left $0123.w,X [Reads: X Index] [Flags: NCZ]
	and $1E.b,S		; 23 1E ; AND accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1E10.w,X		; 1E 10 1E ; Arithmetic shift left $1E10.w,X [Reads: X Index] [Flags: NCZ]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $191E.w,X		; 1E 1E 19 ; Arithmetic shift left $191E.w,X [Reads: X Index] [Flags: NCZ]
	and $1E.b		; 25 1E ; Logical AND $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0083.w,X		; 1E 83 00 ; Arithmetic shift left $0083.w,X [Reads: X Index] [Flags: NCZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora [$1D.b]		; 07 1D ; OR accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	asl $1C10.w,X		; 1E 10 1C ; Arithmetic shift left $1C10.w,X [Reads: X Index] [Flags: NCZ]
	ora $008405.l		; 0F 05 84 00 ; OR accumulator with memory (long) $008405.l [Writes: Accumulator] [Flags: NZ]
	jsl $0D050B.l		; 22 0B 05 0D ; Jump to subroutine long $0D050B.l [Writes: Stack Pointer] [Flow: call]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	trb $1C15.w		; 1C 15 1C ; Test and reset bits $1C15.w [Reads: Accumulator] [Flags: Z]
	ora $550084.l		; 0F 84 00 55 ; OR accumulator with memory (long) $550084.l [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	ora $011E.w,Y		; 19 1E 01 ; OR accumulator with memory $011E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	ora $1E.b		; 05 1E ; Logical OR $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $1C0005.l		; 22 05 00 1C ; Jump to subroutine long $1C0005.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	mvn $1A,$09		; 54 09 1A ; Move block negative $1A,$09 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0510.w		; 1C 10 05 ; Test and reset bits $0510.w [Reads: Accumulator] [Flags: Z]
	asl $231C.w,X		; 1E 1C 23 ; Arithmetic shift left $231C.w,X [Reads: X Index] [Flags: NCZ]
	asl $0522.w,X		; 1E 22 05 ; Arithmetic shift left $0522.w,X [Reads: X Index] [Flags: NCZ]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1C.b,X)		; 01 1C ; Logical OR ($1C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1C22.w,X		; 1E 22 1C ; Arithmetic shift left $1C22.w,X [Reads: X Index] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $1C.b,S		; 43 1C ; Exclusive OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1E02.w,X		; 1E 02 1E ; Arithmetic shift left $1E02.w,X [Reads: X Index] [Flags: NCZ]
	trb $840F.w		; 1C 0F 84 ; Test and reset bits $840F.w [Reads: Accumulator] [Flags: Z]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and $22.b		; 25 22 ; Logical AND $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0504.w		; 1C 04 05 ; Test and reset bits $0504.w [Reads: Accumulator] [Flags: Z]
	asl $1E15.w,X		; 1E 15 1E ; Arithmetic shift left $1E15.w,X [Reads: X Index] [Flags: NCZ]
	ora $83.b		; 05 83 ; Logical OR $83.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $0D.b		; 00 0D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	lda ($83.b)		; B2 83 ; Load accumulator (indirect) ($83.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	eor [$00.b]		; 47 00 ; Exclusive OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $25		; 10 25 ; Branch if plus to $10, $25 [Flow: branch]
	asl $1C22.w,X		; 1E 22 1C ; Arithmetic shift left $1C22.w,X [Reads: X Index] [Flags: NCZ]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2210.w,X		; 1E 10 22 ; Arithmetic shift left $2210.w,X [Reads: X Index] [Flags: NCZ]
	asl $0202.w,X		; 1E 02 02 ; Arithmetic shift left $0202.w,X [Reads: X Index] [Flags: NCZ]
	ora $2211.w		; 0D 11 22 ; Logical OR $2211.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $23		; 10 23 ; Branch if plus to $10, $23 [Flow: branch]
	asl $1023.w,X		; 1E 23 10 ; Arithmetic shift left $1023.w,X [Reads: X Index] [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1028.w		; 0D 28 10 ; Logical OR $1028.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	asl $010D.w,X		; 1E 0D 01 ; Arithmetic shift left $010D.w,X [Reads: X Index] [Flags: NCZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $A8.b,X		; 56 A8 ; Logical shift right $A8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	eor $A859A8.l		; 4F A8 59 A8 ; Exclusive OR accumulator with memory (long) $A859A8.l [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	eor ($62.b)		; 52 62 ; Exclusive OR accumulator with memory (indirect) ($62.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	ora ($49.b,X)		; 01 49 ; Logical OR ($49.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lsr $3862.w,X		; 5E 62 38 ; Logical shift right $3862.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor ($A8.b)		; 52 A8 ; Exclusive OR accumulator with memory (indirect) ($A8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $4F52.w,Y		; BE 52 4F ; Load X register $4F52.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor $141B9A.l,X		; 5F 9A 1B 14 ; Exclusive OR accumulator with memory (long,X) $141B9A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($6A.b),Y		; F1 6A ; Subtract with carry ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $60.b		; 06 60 ; Arithmetic shift left $60.b [Reads: Direct Page] [Flags: NCZ]
	adc ($84.b,X)		; 61 84 ; Add with carry ($84.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	.db $62, $A8, $52		; 62 A8 52 ; Push effective relative address $62, $A8, $52 [Writes: Stack Pointer]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	adc $1F.b,S		; 63 1F ; Add with carry (stack relative) $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	stz $23.b		; 64 23 ; Store zero to $23.b
	asl $63.b		; 06 63 ; Arithmetic shift left $63.b [Reads: Direct Page] [Flags: NCZ]
	adc $0B.b		; 65 0B ; Add $0B.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc #$5FC5.w		; 69 C5 5F ; Add #$5FC5.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sbc $DD0009.l,X		; FF 09 00 DD ; Subtract with carry (long,X) $DD0009.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jmp.w [$6C62]		; DC 62 6C ; Jump long indirect [$6C62] [Flow: jump]
	cpx #$1D21.w		; E0 21 1D ; Compare #$1D21.w with X register [Reads: X Index] [Flags: NCZ]
	adc $5AA870.l		; 6F 70 A8 5A ; Add with carry (long) $5AA870.l [Writes: Accumulator] [Flags: NCVZ]
	adc $FF.b,S		; 63 FF ; Add with carry (stack relative) $FF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora #$5E00.w		; 09 00 5E ; Logical OR #$5E00.w with accumulator [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	adc ($72.b),Y		; 71 72 ; Add with carry ($72.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	dec $F7.b		; C6 F7 ; Decrement $F7.b [Reads: Direct Page] [Flags: NZ]
	stx $E5.b,Y		; 96 E5 ; Store X register $E5.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	adc ($FF.b,S),Y		; 73 FF ; Add with carry (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $740009.l,X		; FF 09 00 74 ; Subtract with carry (long,X) $740009.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $63.b		; 00 63 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $6DA7.w		; CE A7 6D ; Decrement $6DA7.w [Flags: NZ]
	stx $6E.b		; 86 6E ; Store X register to $6E.b [Reads: X Index]
	.db $80, $84		; 80 84 ; Branch always to $80, $84 [Flow: branch]
	brk $55.b		; 00 55 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	bit $10.b		; 24 10 ; Test bits $10.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	jsr ($FD75.w,X)		; FC 75 FD ; Jump to subroutine indirect indexed ($FD75.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	cpy $52.b		; C4 52 ; Compare $52.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	jsl $4711A8.l		; 22 A8 11 47 ; Jump to subroutine long $4711A8.l [Writes: Stack Pointer] [Flow: call]
	lda $FFFF.w,Y		; B9 FF FF ; Load $FFFF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ror $B5.b,X		; 76 B5 ; Rotate right $B5.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	cop $CC.b		; 02 CC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $A8.b		; 06 A8 ; Arithmetic shift left $A8.b [Reads: Direct Page] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	eor ($B8.b,S),Y		; 53 B8 ; XOR accumulator (stack relative indirect indexed) ($B8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	eor ($62.b,X)		; 41 62 ; Exclusive OR accumulator with memory ($62.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc [$10.b],Y		; 77 10 ; Add with carry (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	pei ($B5.b)		; D4 B5 ; Push effective indirect address ($B5.b) [Reads: Direct Page] [Writes: Stack Pointer]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	eor $587AA8.l		; 4F A8 7A 58 ; Exclusive OR accumulator with memory (long) $587AA8.l [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lsr $53.b,X		; 56 53 ; Logical shift right $53.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lsr $7B.b,X		; 56 7B ; Logical shift right $7B.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jmp ($837D.w,X)		; 7C 7D 83 ; Jump indirect indexed to ($837D.w,X) [Reads: X Index] [Flow: jump]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx #$A83C.w		; E0 3C A8 ; Compare #$A83C.w with X register [Reads: X Index] [Flags: NCZ]
	ror $56A8.w,X		; 7E A8 56 ; Rotate right $56A8.w,X [Reads: X Index] [Flags: NCZ]
	lda [$7F.b],Y		; B7 7F ; Load accumulator (long indexed) [$7F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $8180.w,X		; 9D 80 81 ; Store accumulator to $8180.w,X [Reads: Accumulator, X Index]
	lsr $8F.b,X		; 56 8F ; Logical shift right $8F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $82, $83, $D4		; 82 83 D4 ; Branch always long to $82, $83, $D4 [Flow: branch]
	sty $85.b		; 84 85 ; Store Y register to $85.b [Reads: Y Index]
	lda [$86.b],Y		; B7 86 ; Load accumulator (long indexed) [$86.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($87.b,S),Y		; B3 87 ; Load accumulator (stack relative indirect indexed) ($87.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	eor [$A8.b]		; 47 A8 ; Exclusive OR accumulator with memory (long) [$A8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	bit #$8AA2.w		; 89 A2 8A ; Test bits #$8AA2.w with accumulator [Reads: Accumulator] [Flags: Z]
	cpx #$008B.w		; E0 8B 00 ; Compare #$008B.w with X register [Reads: X Index] [Flags: NCZ]
	eor #$A88C.w		; 49 8C A8 ; Exclusive OR #$A88C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $8D.b,X		; 95 8D ; Store accumulator to $8D.b,X [Reads: Accumulator, X Index]
	and $8E56.w,Y		; 39 56 8E ; AND accumulator with memory $8E56.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $B795.w		; 8D 95 B7 ; Store accumulator to $B795.w [Reads: Accumulator]
	sta $09FF90.l		; 8F 90 FF 09 ; Store accumulator (long) $09FF90.l [Reads: Accumulator]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($92.b),Y		; 91 92 ; Store accumulator ($92.b),Y [Reads: Direct Page, Y Index, Accumulator]
	eor #$4D93.w		; 49 93 4D ; Exclusive OR #$4D93.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sty $B79C.w		; 8C 9C B7 ; Store Y register to $B79C.w [Reads: Y Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sty $5C.b,X		; 94 5C ; Store Y register $5C.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sbc [$62.b],Y		; F7 62 ; Subtract with carry (long indexed) [$62.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b,X		; 95 02 ; Store accumulator to $02.b,X [Reads: Accumulator, X Index]
	cmp ($5A.b),Y		; D1 5A ; Compare accumulator ($5A.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	brk $22.b		; 00 22 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$0C.b],Y		; F7 0C ; Subtract with carry (long indexed) [$0C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $5C99.w,Y		; 99 99 5C ; Store accumulator to $5C99.w,Y [Reads: Y Index, Accumulator]
	lsr $145F.w,X		; 5E 5F 14 ; Logical shift right $145F.w,X [Reads: X Index] [Flags: NCZ]
	ora $A1.b,X		; 15 A1 ; OR accumulator with memory $A1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ldx $61.b		; A6 61 ; Load $61.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	rol $14.b		; 26 14 ; Rotate left $14.b [Reads: Direct Page] [Flags: NCZ]
	ora $62.b		; 05 62 ; Logical OR $62.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $9A.b		; 06 9A ; Arithmetic shift left $9A.b [Reads: Direct Page] [Flags: NCZ]
	mvn $06,$06		; 54 06 06 ; Move block negative $06,$06 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	sbc $010102.l,X		; FF 02 01 01 ; Subtract with carry (long,X) $010102.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $29.b,S		; 03 29 ; OR accumulator with stack relative $29.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1E.b		; 05 1E ; Logical OR $1E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	asl $101E.w,X		; 1E 1E 10 ; Arithmetic shift left $101E.w,X [Reads: X Index] [Flags: NCZ]
	jsl $050401.l		; 22 01 04 05 ; Jump to subroutine long $050401.l [Writes: Stack Pointer] [Flow: call]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $26E01E.l		; 22 1E E0 26 ; Jump to subroutine long $26E01E.l [Writes: Stack Pointer] [Flow: call]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $010E.w		; 0E 0E 01 ; Arithmetic shift left $010E.w [Flags: NCZ]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0B10.w		; 0C 10 0B ; Test and set bits $0B10.w [Reads: Accumulator] [Flags: Z]
	ora $000601.l		; 0F 01 06 00 ; OR accumulator with memory (long) $000601.l [Writes: Accumulator] [Flags: NZ]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0E1E05.l		; 0F 05 1E 0E ; OR accumulator with memory (long) $0E1E05.l [Writes: Accumulator] [Flags: NZ]
	asl $1010.w,X		; 1E 10 10 ; Arithmetic shift left $1010.w,X [Reads: X Index] [Flags: NCZ]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	cop $23.b		; 02 23 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($0B.b,X)		; 01 0B ; Logical OR ($0B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $021E.w		; 0C 1E 02 ; Test and set bits $021E.w [Reads: Accumulator] [Flags: Z]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $03.b		; 06 03 ; Arithmetic shift left $03.b [Reads: Direct Page] [Flags: NCZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b,S		; 03 0B ; OR accumulator with stack relative $0B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $0F		; 10 0F ; Branch if plus to $10, $0F [Flow: branch]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $19021E.l		; 22 1E 02 19 ; Jump to subroutine long $19021E.l [Writes: Stack Pointer] [Flow: call]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $0F0E10.l		; 22 10 0E 0F ; Jump to subroutine long $0F0E10.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora #$0103.w		; 09 03 01 ; Logical OR #$0103.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $830006.l		; 0F 06 00 83 ; OR accumulator with memory (long) $830006.l [Writes: Accumulator] [Flags: NZ]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $05.b		; 02 05 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0201.w,Y		; 19 01 02 ; OR accumulator with memory $0201.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $008300.l		; 0F 00 83 00 ; OR accumulator with memory (long) $008300.l [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $111009.l		; 0F 09 10 11 ; OR accumulator with memory (long) $111009.l [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1C01.w,Y		; 19 01 1C ; OR accumulator with memory $1C01.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $0B10.w,X		; 1E 10 0B ; Arithmetic shift left $0B10.w,X [Reads: X Index] [Flags: NCZ]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $014310.l		; 0F 10 43 01 ; OR accumulator with memory (long) $014310.l [Writes: Accumulator] [Flags: NZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $43		; 10 43 ; Branch if plus to $10, $43 [Flow: branch]
	trb $0701.w		; 1C 01 07 ; Test and reset bits $0701.w [Reads: Accumulator] [Flags: Z]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	ora $101005.l		; 0F 05 10 10 ; OR accumulator with memory (long) $101005.l [Writes: Accumulator] [Flags: NZ]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $0E0601.l		; 22 01 06 0E ; Jump to subroutine long $0E0601.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $0D0101.l		; 22 01 01 0D ; Jump to subroutine long $0D0101.l [Writes: Stack Pointer] [Flow: call]
	asl $0083.w		; 0E 83 00 ; Arithmetic shift left $0083.w [Flags: NCZ]
	wai		; CB ; Wait for interrupt
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $1B03.w		; 0D 03 1B ; Logical OR $1B03.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $0083.w		; 0D 83 00 ; Logical OR $0083.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $01.b		; 24 01 ; Test bits $01.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	ora $0C06.w		; 0D 06 0C ; Logical OR $0C06.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $02FF03.l		; 22 03 FF 02 ; Jump to subroutine long $02FF03.l [Writes: Stack Pointer] [Flow: call]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$0C0A.w		; 29 0A 0C ; Logical AND #$0C0A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda [$06.b]		; A7 06 ; Load accumulator (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $15.b,X		; 15 15 ; OR accumulator with memory $15.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $699D.w		; 9C 9D 69 ; Store zero to $699D.w
	jsl $B50415.l		; 22 15 04 B5 ; Jump to subroutine long $B50415.l [Writes: Stack Pointer] [Flow: call]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	jmp.w [$9E62]		; DC 62 9E ; Jump long indirect [$9E62] [Flow: jump]
	cpx #$2346.w		; E0 46 23 ; Compare #$2346.w with X register [Reads: X Index] [Flags: NCZ]
	adc ($0B.b)		; 72 0B ; Add with carry (indirect) ($0B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $7402.w		; 6E 02 74 ; Rotate right $7402.w [Flags: NCZ]
	jsl $F67622.l		; 22 22 76 F6 ; Jump to subroutine long $F67622.l [Writes: Stack Pointer] [Flow: call]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl $DC.b		; 06 DC ; Arithmetic shift left $DC.b [Reads: Direct Page] [Flags: NCZ]
	dec $7806.w		; CE 06 78 ; Decrement $7806.w [Flags: NZ]
	cop $79.b		; 02 79 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($8C.b,S),Y		; 53 8C ; XOR accumulator (stack relative indirect indexed) ($8C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1D6A.w,X		; 1E 6A 1D ; Arithmetic shift left $1D6A.w,X [Reads: X Index] [Flags: NCZ]
	lda $A67177.l,X		; BF 77 71 A6 ; Load long $A67177.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	mvn $A1,$8D		; 54 8D A1 ; Move block negative $A1,$8D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	and $7EA2.w,X		; 3D A2 7E ; AND accumulator with memory $7EA2.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $8CA6.w,Y		; 79 A6 8C ; Add $8CA6.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $418A1D.l,X		; 7F 1D 8A 41 ; Add long $418A1D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp $ED7606.l		; 5C 06 76 ED ; Jump long to $ED7606.l [Flow: jump]
	sta ($A3.b),Y		; 91 A3 ; Store accumulator ($A3.b),Y [Reads: Direct Page, Y Index, Accumulator]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	inc $82.b		; E6 82 ; Increment $82.b [Reads: Direct Page] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $8A.b,S		; 83 8A ; Store accumulator (stack relative) $8A.b,S [Reads: Stack Pointer, Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $52.b		; 84 52 ; Store Y register to $52.b [Reads: Y Index]
	eor ($6A.b,S),Y		; 53 6A ; XOR accumulator (stack relative indirect indexed) ($6A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $A4.b,X		; F5 A4 ; Subtract $A4.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $3BA5.w,X		; 1D A5 3B ; OR accumulator with memory $3BA5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr $22.b,X		; 56 22 ; Logical shift right $22.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit #$621D.w		; 89 1D 62 ; Test bits #$621D.w with accumulator [Reads: Accumulator] [Flags: Z]
	.db $50, $E0		; 50 E0 ; Branch if overflow clear to $50, $E0 [Flow: branch]
	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	sbc $A6.b,S		; E3 A6 ; Subtract stack-relative $A6.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora $3BA5.w,X		; 1D A5 3B ; OR accumulator with memory $3BA5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	bit #$1D8B.w		; 89 8B 1D ; Test bits #$1D8B.w with accumulator [Reads: Accumulator] [Flags: Z]
	adc $C58C.w,Y		; 79 8C C5 ; Add $C58C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $57.b,X		; 56 57 ; Logical shift right $57.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $A7.b,S		; E3 A7 ; Subtract stack-relative $A7.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda [$A5.b]		; A7 A5 ; Load accumulator (long) [$A5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	cop $8C.b		; 02 8C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $798F.w		; 8E 8F 79 ; Store X register to $798F.w [Reads: X Index]
	sty $8F8E.w		; 8C 8E 8F ; Store Y register to $8F8E.w [Reads: Y Index]
	cmp $E5BA.w,Y		; D9 BA E5 ; Compare accumulator $E5BA.w,Y [Reads: Y Index] [Flags: NCZ]
	sbc $1D.b,S		; E3 1D ; Subtract stack-relative $1D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	ora $06A5.w,X		; 1D A5 06 ; OR accumulator with memory $06A5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc #$6A8C.w		; 69 8C 6A ; Add #$6A8C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora $8C79.w,X		; 1D 79 8C ; OR accumulator with memory $8C79.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($94.b,S),Y		; 93 94 ; Store accumulator (stack relative indirect indexed) ($94.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	sta $4C5B.w		; 8D 5B 4C ; Store accumulator to $4C5B.w [Reads: Accumulator]
	sbc $D4.b,S		; E3 D4 ; Subtract stack-relative $D4.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sbc $06.b,S		; E3 06 ; Subtract stack-relative $06.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	adc #$1D8C.w		; 69 8C 1D ; Add #$1D8C.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora $8C79.w,X		; 1D 79 8C ; OR accumulator with memory $8C79.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $0198FC.l,X		; BF FC 98 01 ; Load long $0198FC.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($E3.b,X)		; 81 E3 ; Store accumulator ($E3.b,X) [Reads: Direct Page, Accumulator, X Index]
	lda ($E3.b,X)		; A1 E3 ; Load accumulator ($E3.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $30.b		; 06 30 ; Arithmetic shift left $30.b [Reads: Direct Page] [Flags: NCZ]
	lda #$4E9C.w		; A9 9C 4E ; Load #$4E9C.w into accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($79.b,X)		; 41 79 ; Exclusive OR accumulator with memory ($79.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $779D.w		; 8C 9D 77 ; Store Y register to $779D.w [Reads: Y Index]
	asl $0C.b,X		; 16 0C ; Arithmetic shift left $0C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $87.b		; A6 87 ; Load $87.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	asl $30.b		; 06 30 ; Arithmetic shift left $30.b [Reads: Direct Page] [Flags: NCZ]
	eor $9F.b,X		; 55 9F ; Exclusive OR accumulator with memory $9F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp ($40.b),Y		; D1 40 ; Compare accumulator ($40.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	jmp $8DA1A0.l		; 5C A0 A1 8D ; Jump long to $8DA1A0.l [Flow: jump]
	ldx #$0903.w		; A2 03 09 ; Load #$0903.w into X register [Writes: X Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	mvp $AA,$81		; 44 81 AA ; Move block positive $AA,$81 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor $A1.b,X		; 55 A1 ; Exclusive OR accumulator with memory $A1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $48.b		; 06 48 ; Arithmetic shift left $48.b [Reads: Direct Page] [Flags: NCZ]
	nop		; EA ; No operation
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $A68D44.l,X		; 9F 44 8D A6 ; Store accumulator (long,X) $A68D44.l,X [Reads: Accumulator, X Index]
	ora ($15.b,S),Y		; 13 15 ; OR accumulator (stack relative indirect indexed) ($15.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $A1EF4A.l,X		; 9F 4A EF A1 ; Store accumulator (long,X) $A1EF4A.l,X [Reads: Accumulator, X Index]
	asl $53.b		; 06 53 ; Arithmetic shift left $53.b [Reads: Direct Page] [Flags: NCZ]
	asl $A6.b		; 06 A6 ; Arithmetic shift left $A6.b [Reads: Direct Page] [Flags: NCZ]
	lda [$06.b]		; A7 06 ; Load accumulator (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sta $A98D44.l,X		; 9F 44 8D A9 ; Store accumulator (long,X) $A98D44.l,X [Reads: Accumulator, X Index]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	eor [$A6.b]		; 47 A6 ; Exclusive OR accumulator with memory (long) [$A6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $AA.b		; 06 AA ; Arithmetic shift left $AA.b [Reads: Direct Page] [Flags: NCZ]
	ldx $F5.b		; A6 F5 ; Load $F5.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	asl $AB.b		; 06 AB ; Arithmetic shift left $AB.b [Reads: Direct Page] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc $010606.l,X		; FF 06 06 01 ; Subtract with carry (long,X) $010606.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $0103.w,X		; 1E 03 01 ; Arithmetic shift left $0103.w,X [Reads: X Index] [Flags: NCZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0C1D.w,X		; 1E 1D 0C ; Arithmetic shift left $0C1D.w,X [Reads: X Index] [Flags: NCZ]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $09.b		; 04 09 ; Test and set bits $09.b [Reads: Accumulator] [Flags: Z]
	bit $06.b		; 24 06 ; Test bits $06.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: NCZ]
	asl $0F06.w,X		; 1E 06 0F ; Arithmetic shift left $0F06.w,X [Reads: X Index] [Flags: NCZ]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $2307.w,X		; 1E 07 23 ; Arithmetic shift left $2307.w,X [Reads: X Index] [Flags: NCZ]
	asl $1B.b		; 06 1B ; Arithmetic shift left $1B.b [Reads: Direct Page] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$0106.w		; 09 06 01 ; Logical OR #$0106.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1E.b,S		; 03 1E ; OR accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $000B.w,X		; 1E 0B 00 ; Arithmetic shift left $000B.w,X [Reads: X Index] [Flags: NCZ]
	ora $0606.w,Y		; 19 06 06 ; OR accumulator with memory $0606.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $0005.w,X		; 1E 05 00 ; Arithmetic shift left $0005.w,X [Reads: X Index] [Flags: NCZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: NCZ]
	ora $000B.w,Y		; 19 0B 00 ; OR accumulator with memory $000B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $1E.b		; 26 1E ; Rotate left $1E.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	asl $0001.w,X		; 1E 01 00 ; Arithmetic shift left $0001.w,X [Reads: X Index] [Flags: NCZ]
	ora #$0902.w		; 09 02 09 ; Logical OR #$0902.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $051E.w,X		; 1E 1E 05 ; Arithmetic shift left $051E.w,X [Reads: X Index] [Flags: NCZ]
	and $1E.b,S		; 23 1E ; AND accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0306.w,X		; 1D 06 03 ; OR accumulator with memory $0306.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $1E01.w,Y		; 19 01 1E ; OR accumulator with memory $1E01.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $2311.w,X		; 1E 11 23 ; Arithmetic shift left $2311.w,X [Reads: X Index] [Flags: NCZ]
	asl $1D0C.w,X		; 1E 0C 1D ; Arithmetic shift left $1D0C.w,X [Reads: X Index] [Flags: NCZ]
	asl $0F.b		; 06 0F ; Arithmetic shift left $0F.b [Reads: Direct Page] [Flags: NCZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$0C1E.w		; 09 1E 0C ; Logical OR #$0C1E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $051C.w,X		; 1E 1C 05 ; Arithmetic shift left $051C.w,X [Reads: X Index] [Flags: NCZ]
	and $1E.b,S		; 23 1E ; AND accumulator with stack relative $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $021B.w,Y		; 19 1B 02 ; OR accumulator with memory $021B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $1E.b		; 26 1E ; Rotate left $1E.b [Reads: Direct Page] [Flags: NCZ]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: NCZ]
	cop $0E.b		; 02 0E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	jsl $1E2406.l		; 22 06 24 1E ; Jump to subroutine long $1E2406.l [Writes: Stack Pointer] [Flow: call]
	ora [$1D.b]		; 07 1D ; OR accumulator with memory (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	asl $0003.w		; 0E 03 00 ; Arithmetic shift left $0003.w [Flags: NCZ]
	cop $19.b		; 02 19 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx #$1D2F.w		; E0 2F 1D ; Compare #$1D2F.w with X register [Reads: X Index] [Flags: NCZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	asl $0606.w,X		; 1E 06 06 ; Arithmetic shift left $0606.w,X [Reads: X Index] [Flags: NCZ]
	ora $031E.w,Y		; 19 1E 03 ; OR accumulator with memory $031E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: NCZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	asl $0606.w		; 0E 06 06 ; Arithmetic shift left $0606.w [Flags: NCZ]
	ora $000303.l		; 0F 03 03 00 ; OR accumulator with memory (long) $000303.l [Writes: Accumulator] [Flags: NZ]
	brk $1E.b		; 00 1E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0303.w,X		; 1E 03 03 ; Arithmetic shift left $0303.w,X [Reads: X Index] [Flags: NCZ]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0E.b		; 06 0E ; Arithmetic shift left $0E.b [Reads: Direct Page] [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	asl $00.b		; 06 00 ; Arithmetic shift left $00.b [Reads: Direct Page] [Flags: NCZ]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	ora [$0D.b]		; 07 0D ; OR accumulator with memory (long) [$0D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $03.b		; 24 03 ; Test bits $03.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	.db $10, $1E		; 10 1E ; Branch if plus to $10, $1E [Flow: branch]
	tsb $0303.w		; 0C 03 03 ; Test and set bits $0303.w [Reads: Accumulator] [Flags: Z]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1C.b,S		; 03 1C ; OR accumulator with stack relative $1C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1E1B17.l		; 0F 17 1B 1E ; OR accumulator with memory (long) $1E1B17.l [Writes: Accumulator] [Flags: NZ]
	asl $0207.w		; 0E 07 02 ; Arithmetic shift left $0207.w [Flags: NCZ]
	bit $03.b		; 24 03 ; Test bits $03.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $1701.w		; 0D 01 17 ; Logical OR $1701.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $011E.w,X		; 1E 1E 01 ; Arithmetic shift left $011E.w,X [Reads: X Index] [Flags: NCZ]
	cop $1B.b		; 02 1B ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $0101.w,X		; 1E 01 01 ; Arithmetic shift left $0101.w,X [Reads: X Index] [Flags: NCZ]
	sbc $06A606.l,X		; FF 06 A6 06 ; Subtract with carry (long,X) $06A606.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $E363.w		; AC 63 E3 ; Load $E363.w into Y register [Writes: Y Index] [Flags: NZ]
	sty $6C.b,X		; 94 6C ; Store Y register $6C.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	and $80.b,S		; 23 80 ; AND accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	cmp ($39.b),Y		; D1 39 ; Compare accumulator ($39.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	.db $80, $AD		; 80 AD ; Branch always to $80, $AD [Flow: branch]
	adc ($F5.b),Y		; 71 F5 ; Add with carry ($F5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda [$54.b]		; A7 54 ; Load accumulator (long) [$54.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror $AE.b,X		; 76 AE ; Rotate right $AE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $30, $24		; 30 24 ; Branch if minus to $30, $24 [Flow: branch]
	bit $80.b		; 24 80 ; Test bits $80.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and ($6A.b)		; 32 6A ; AND accumulator with memory (indirect) ($6A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $54A6B0.l		; AF B0 A6 54 ; Load long $54A6B0.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ror $ED.b,X		; 76 ED ; Rotate right $ED.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	lda ($B2.b),Y		; B1 B2 ; Load accumulator ($B2.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($8023.w)		; 6C 23 80 ; Jump indirect to ($8023.w) [Flow: jump]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	sta $80241D.l,X		; 9F 1D 24 80 ; Store accumulator (long,X) $80241D.l,X [Reads: Accumulator, X Index]
	asl $63.b		; 06 63 ; Arithmetic shift left $63.b [Reads: Direct Page] [Flags: NCZ]
	lda ($7A.b,S),Y		; B3 7A ; Load accumulator (stack relative indirect indexed) ($7A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $3BB4.w,X		; 1D B4 3B ; OR accumulator with memory $3BB4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $8080CF.l,X		; 9F CF 80 80 ; Store accumulator (long,X) $8080CF.l,X [Reads: Accumulator, X Index]
	lda $CF.b,X		; B5 CF ; Load $CF.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $6C39.w		; 1C 39 6C ; Test and reset bits $6C39.w [Reads: Accumulator] [Flags: Z]
	lsr $E363.w,X		; 5E 63 E3 ; Logical shift right $E363.w,X [Reads: X Index] [Flags: NCZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $E3.b,Y		; B6 E3 ; Load X register $E3.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $B766.w,X		; 1D 66 B7 ; OR accumulator with memory $B766.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$78.b]		; 07 78 ; OR accumulator with memory (long) [$78.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldx $BE.b		; A6 BE ; Load $BE.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sbc $A9.b,S		; E3 A9 ; Subtract stack-relative $A9.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	cmp #$E559.w		; C9 59 E5 ; Compare #$E559.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $62, $BF, $63		; 62 BF 63 ; Push effective relative address $62, $BF, $63 [Writes: Stack Pointer]
	cmp ($0B.b,X)		; C1 0B ; Compare accumulator ($0B.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	.db $62, $80, $20		; 62 80 20 ; Push effective relative address $62, $80, $20 [Writes: Stack Pointer]
	ror $AE.b,X		; 76 AE ; Rotate right $AE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $BA42.w,X		; 1D 42 BA ; OR accumulator with memory $BA42.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	cmp $C6.b		; C5 C6 ; Compare $C6.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	tsb $C763.w		; 0C 63 C7 ; Test and set bits $C763.w [Reads: Accumulator] [Flags: Z]
	tsb $8053.w		; 0C 53 80 ; Test and set bits $8053.w [Reads: Accumulator] [Flags: Z]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sbc $1E7A.w		; ED 7A 1E ; Subtract $1E7A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	wai		; CB ; Wait for interrupt
	cop $1D.b		; 02 1D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpy $8FCD.w		; CC CD 8F ; Compare $8FCD.w with Y register [Reads: Y Index] [Flags: NCZ]
	sbc $63.b		; E5 63 ; Subtract $63.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	dec $AF07.w		; CE 07 AF ; Decrement $AF07.w [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	dec $803F.w,X		; DE 3F 80 ; Decrement memory $803F.w,X [Reads: X Index] [Flags: NZ]
	lda ($3F.b)		; B2 3F ; Load accumulator (indirect) ($3F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc [$D1.b]		; 67 D1 ; Add with carry (long) [$D1.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora #$4CB2.w		; 09 B2 4C ; Logical OR #$4CB2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stx $94.b		; 86 94 ; Store X register to $94.b [Reads: X Index]
	sta [$31.b]		; 87 31 ; Store accumulator (long) [$31.b] [Reads: Direct Page, Accumulator]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	sbc ($64.b),Y		; F1 64 ; Subtract with carry ($64.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $6107.w,Y		; D9 07 61 ; Compare accumulator $6107.w,Y [Reads: Y Index] [Flags: NCZ]
	.db $80, $EB		; 80 EB ; Branch always to $80, $EB [Flow: branch]
	mvp $1D,$8D		; 44 8D 1D ; Move block positive $1D,$8D [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($23.b)		; B2 23 ; Load accumulator (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	eor $4F.b		; 45 4F ; Exclusive OR $4F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $DE1D.w		; 8D 1D DE ; Store accumulator to $DE1D.w [Reads: Accumulator]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	cmp $1DA595.l,X		; DF 95 A5 1D ; Compare accumulator (long,X) $1DA595.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $80, $CA		; 80 CA ; Branch always to $80, $CA [Flow: branch]
	jmp ($8080.w)		; 6C 80 80 ; Jump indirect to ($8080.w) [Flow: jump]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $1D.b,X		; 95 1D ; Store accumulator to $1D.b,X [Reads: Accumulator, X Index]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	eor [$6B.b]		; 47 6B ; Exclusive OR accumulator with memory (long) [$6B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $1C1D.w,X		; 9D 1D 1C ; Store accumulator to $1C1D.w,X [Reads: Accumulator, X Index]
	cpx #$A59F.w		; E0 9F A5 ; Compare #$A59F.w with X register [Reads: X Index] [Flags: NCZ]
	and $E2E1.w,Y		; 39 E1 E2 ; AND accumulator with memory $E2E1.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $D9,$44		; 44 44 D9 ; Move block positive $D9,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lda $880380.l		; AF 80 03 88 ; Load long $880380.l into accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	mvp $C7,$44		; 44 44 C7 ; Move block positive $C7,$44 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	.db $50, $4B		; 50 4B ; Branch if overflow clear to $50, $4B [Flow: branch]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	sty $868D.w		; 8C 8D 86 ; Store Y register to $868D.w [Reads: Y Index]
	jmp ($E3AA.w)		; 6C AA E3 ; Jump indirect to ($E3AA.w) [Flow: jump]
	cpx $4444.w		; EC 44 44 ; Compare $4444.w with X register [Reads: X Index] [Flags: NCZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $F0, $4B		; F0 4B ; Branch if equal to $F0, $4B [Flow: branch]
	cmp ($33.b,S),Y		; D3 33 ; Compare accumulator (stack relative indirect indexed) ($33.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	nop		; EA ; No operation
	cpx $44.b		; E4 44 ; Compare $44.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $4C.b,X		; D6 4C ; Decrement memory $4C.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	bit $4B.b		; 24 4B ; Test bits $4B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc ($63.b),Y		; F1 63 ; Subtract with carry ($63.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $E6.b		; E5 E6 ; Subtract $E6.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor #$EDD1.w		; 49 D1 ED ; Exclusive OR #$EDD1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $EB.b		; E4 EB ; Compare $EB.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $1D1D01.l,X		; FF 01 1D 1D ; Subtract with carry (long,X) $1D1D01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora $0D10.w,X		; 1D 10 0D ; OR accumulator with memory $0D10.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $061E.w,X		; 1E 1E 06 ; Arithmetic shift left $061E.w,X [Reads: X Index] [Flags: NCZ]
	ora $431E.w,X		; 1D 1E 43 ; OR accumulator with memory $431E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $1D.b		; 06 1D ; Arithmetic shift left $1D.b [Reads: Direct Page] [Flags: NCZ]
	and $06.b,S		; 23 06 ; AND accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $1E.b		; 02 1E ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $1E0206.l		; 22 06 02 1E ; Jump to subroutine long $1E0206.l [Writes: Stack Pointer] [Flow: call]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $060B0E.l		; 22 0E 0B 06 ; Jump to subroutine long $060B0E.l [Writes: Stack Pointer] [Flow: call]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0004.w,X		; 1E 04 00 ; Arithmetic shift left $0004.w,X [Reads: X Index] [Flags: NCZ]
	ora $1E22.w,X		; 1D 22 1E ; OR accumulator with memory $1E22.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00.b,X		; 15 00 ; OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	ora $011E.w,Y		; 19 1E 01 ; OR accumulator with memory $011E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $1D.b		; 04 1D ; Test and set bits $1D.b [Reads: Accumulator] [Flags: Z]
	ora [$1E.b]		; 07 1E ; OR accumulator with memory (long) [$1E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1E1D.w,X		; 1D 1D 1E ; OR accumulator with memory $1E1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tsb $1E.b		; 04 1E ; Test and set bits $1E.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $2201.w,X		; 1E 01 22 ; Arithmetic shift left $2201.w,X [Reads: X Index] [Flags: NCZ]
	asl $1D.b		; 06 1D ; Arithmetic shift left $1D.b [Reads: Direct Page] [Flags: NCZ]
	asl $0606.w,X		; 1E 06 06 ; Arithmetic shift left $0606.w,X [Reads: X Index] [Flags: NCZ]
	asl $1E1D.w,X		; 1E 1D 1E ; Arithmetic shift left $1E1D.w,X [Reads: X Index] [Flags: NCZ]
	ora #$0C1E.w		; 09 1E 0C ; Logical OR #$0C1E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $1E.b,X		; 16 1E ; Arithmetic shift left $1E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1E.b		; 06 1E ; Arithmetic shift left $1E.b [Reads: Direct Page] [Flags: NCZ]
	asl $0609.w,X		; 1E 09 06 ; Arithmetic shift left $0609.w,X [Reads: X Index] [Flags: NCZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0084.w		; 0E 84 00 ; Arithmetic shift left $0084.w [Flags: NCZ]
	eor $1E060B.l,X		; 5F 0B 06 1E ; Exclusive OR accumulator with memory (long,X) $1E060B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: NCZ]
	asl $1816.w,X		; 1E 16 18 ; Arithmetic shift left $1816.w,X [Reads: X Index] [Flags: NCZ]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	jsl $041106.l		; 22 06 11 04 ; Jump to subroutine long $041106.l [Writes: Stack Pointer] [Flow: call]
	tsb $1F.b		; 04 1F ; Test and set bits $1F.b [Reads: Accumulator] [Flags: Z]
	asl $04.b,X		; 16 04 ; Arithmetic shift left $04.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $1F0A05.l,X		; 1F 05 0A 1F ; Logical OR long $1F0A05.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $06.b,S		; 03 06 ; OR accumulator with stack relative $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $041F.w,Y		; 19 1F 04 ; OR accumulator with memory $041F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	ora $220500.l,X		; 1F 00 05 22 ; Logical OR long $220500.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($06.b),Y		; 11 06 ; OR accumulator with memory ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $071D10.l,X		; 1F 10 1D 07 ; Logical OR long $071D10.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $24.b		; 02 24 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $180C01.l,X		; 1F 01 0C 18 ; Logical OR long $180C01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $1E0411.l		; 22 11 04 1E ; Jump to subroutine long $1E0411.l [Writes: Stack Pointer] [Flow: call]
	ora $00060C.l,X		; 1F 0C 06 00 ; Logical OR long $00060C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $1F.b		; 25 1F ; Logical AND $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05050A.l,X		; 1F 0A 05 05 ; Logical OR long $05050A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $06.b,X		; 16 06 ; Arithmetic shift left $06.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	asl $1F.b		; 06 1F ; Arithmetic shift left $1F.b [Reads: Direct Page] [Flags: NCZ]
	ora $051F05.l		; 0F 05 1F 05 ; OR accumulator with memory (long) $051F05.l [Writes: Accumulator] [Flags: NZ]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $0A1F.w,X		; 1E 1F 0A ; Arithmetic shift left $0A1F.w,X [Reads: X Index] [Flags: NCZ]
	ora $060505.l,X		; 1F 05 05 06 ; Logical OR long $060505.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$1F07.w		; 09 07 1F ; Logical OR #$1F07.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1B0A0A.l		; 0F 0A 0A 1B ; OR accumulator with memory (long) $1B0A0A.l [Writes: Accumulator] [Flags: NZ]
	jsl $1F0610.l		; 22 10 06 1F ; Jump to subroutine long $1F0610.l [Writes: Stack Pointer] [Flow: call]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $10251F.l		; 22 1F 25 10 ; Jump to subroutine long $10251F.l [Writes: Stack Pointer] [Flow: call]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $10.b,S		; 23 10 ; AND accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $011A1A.l		; 0F 1A 1A 01 ; OR accumulator with memory (long) $011A1A.l [Writes: Accumulator] [Flags: NZ]
	asl $101F.w,X		; 1E 1F 10 ; Arithmetic shift left $101F.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0E01.w,Y		; 19 01 0E ; OR accumulator with memory $0E01.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $01FF.w		; 0E FF 01 ; Arithmetic shift left $01FF.w [Flags: NCZ]
	adc ($72.b),Y		; 71 72 ; Add with carry ($72.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $80, $07		; 80 07 ; Branch always to $80, $07 [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $B0AA.w,Y		; 79 AA B0 ; Add $B0AA.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$80.b]		; E7 80 ; Subtract with carry (long) [$80.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor $43E8.w,Y		; 59 E8 43 ; Exclusive OR accumulator with memory $43E8.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $4F		; 80 4F ; Branch always to $80, $4F [Flow: branch]
	and $80.b,S		; 23 80 ; AND accumulator with stack relative $80.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $E9.b		; 02 E9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($53.b,X)		; A1 53 ; Load accumulator ($53.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $EA1080.l		; 22 80 10 EA ; Jump to subroutine long $EA1080.l [Writes: Stack Pointer] [Flow: call]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	.db $80, $1A		; 80 1A ; Branch always to $80, $1A [Flow: branch]
	brk $1A.b		; 00 1A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta [$BF.b]		; 87 BF ; Store accumulator (long) [$BF.b] [Reads: Direct Page, Accumulator]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	adc $06AA.w,Y		; 79 AA 06 ; Add $06AA.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $EC		; 80 EC ; Branch always to $80, $EC [Flow: branch]
.INDEX 16
	rep #$1D		; C2 1D
	adc $EC.b,S		; 63 EC ; Add with carry (stack relative) $EC.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpx #$1D5C.w		; E0 5C 1D ; Compare #$1D5C.w with X register [Reads: X Index] [Flags: NCZ]
	sta $61.b		; 85 61 ; Store accumulator to $61.b [Reads: Accumulator]
	sta [$F0.b],Y		; 97 F0 ; Store accumulator (long indexed) [$F0.b],Y [Reads: Direct Page, Y Index, Accumulator]
	adc ($53.b),Y		; 71 53 ; Add with carry ($53.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $CB.b		; 06 CB ; Arithmetic shift left $CB.b [Reads: Direct Page] [Flags: NCZ]
.ACCU 16
	rep #$22		; C2 22
	and $F371F1.l,X		; 3F F1 71 F3 ; AND accumulator with memory (long,X) $F371F1.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($85.b)		; F2 85 ; Subtract with carry (indirect) ($85.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($25.b,S),Y		; F3 25 ; Subtract with carry (stack relative indirect indexed) ($25.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $F4.b		; 25 F4 ; Logical AND $F4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc ($A6.b),Y		; 71 A6 ; Add with carry ($A6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx $80.b		; A6 80 ; Load $80.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	sbc $80.b,X		; F5 80 ; Subtract $80.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $F6		; 80 F6 ; Branch always to $80, $F6 [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc [$F5.b],Y		; F7 F5 ; Subtract with carry (long indexed) [$F5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sta $BD15.w,Y		; 99 15 BD ; Store accumulator to $BD15.w,Y [Reads: Y Index, Accumulator]
	sbc $AA51.w,Y		; F9 51 AA ; Subtract with carry $AA51.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $80.b		; 06 80 ; Arithmetic shift left $80.b [Reads: Direct Page] [Flags: NCZ]
	.db $80, $FA		; 80 FA ; Branch always to $80, $FA [Flow: branch]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	and $BF3D.w		; 2D 3D BF ; Logical AND $BF3D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($24.b,X)		; A1 24 ; Load accumulator ($24.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $5A.b,X		; 15 5A ; OR accumulator with memory $5A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	cpx #$F69F.w		; E0 9F F6 ; Compare #$F69F.w with X register [Reads: X Index] [Flags: NCZ]
	asl $80.b		; 06 80 ; Arithmetic shift left $80.b [Reads: Direct Page] [Flags: NCZ]
	.db $80, $FC		; 80 FC ; Branch always to $80, $FC [Flow: branch]
	sbc $FE3D.w,X		; FD 3D FE ; Subtract with carry $FE3D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	lda ($24.b,X)		; A1 24 ; Load accumulator ($24.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $5ACCFF.l,X		; 9F FF CC 5A ; Store accumulator (long,X) $5ACCFF.l,X [Reads: Accumulator, X Index]
	sbc $5371.w		; ED 71 53 ; Subtract $5371.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $80		; 80 80 ; Branch always to $80, $80 [Flow: branch]
	cmp ($B9.b),Y		; D1 B9 ; Compare accumulator ($B9.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	brk $11.b		; 00 11 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$FF01.w		; C9 01 FF ; Compare #$FF01.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sta $ED1302.l,X		; 9F 02 13 ED ; Store accumulator (long,X) $ED1302.l,X [Reads: Accumulator, X Index]
	asl $20.b,X		; 16 20 ; Arithmetic shift left $20.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $80, $CA		; 80 CA ; Branch always to $80, $CA [Flow: branch]
	ora $BB.b,S		; 03 BB ; OR accumulator with stack relative $BB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $0462.w,X		; BC 62 04 ; Load Y register $0462.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $2C2C2E.l,X		; FF 2E 2C 2C ; Subtract with carry (long,X) $2C2C2E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $07ED.w		; EC ED 07 ; Compare $07ED.w with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $43		; D0 43 ; Branch if not equal to $D0, $43 [Flow: branch]
	ldx $65.b,Y		; B6 65 ; Load X register $65.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	stz $08.b		; 64 08 ; Store zero to $08.b
	ora #$5A9E.w		; 09 9E 5A ; Logical OR #$5A9E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $2C2C.w		; 2E 2C 2C ; Rotate left $2C2C.w [Flags: NCZ]
	sbc $B50D.w,Y		; F9 0D B5 ; Subtract with carry $B50D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $1D		; 80 1D ; Branch always to $80, $1D [Flow: branch]
	adc $0E.b		; 65 0E ; Add $0E.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $ECFFF0.l,X		; 1F F0 FF EC ; Logical OR long $ECFFF0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda $E009.w,X		; BD 09 E0 ; Load $E009.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $D0.b		; 14 D0 ; Test and reset bits $D0.b [Reads: Accumulator] [Flags: Z]
	.db $80, $D1		; 80 D1 ; Branch always to $80, $D1 [Flow: branch]
	ora $2F.b,X		; 15 2F ; OR accumulator with memory $2F.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FFFF16.l,X		; FF 16 FF FF ; Subtract with carry (long,X) $FFFF16.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$15.b],Y		; 17 15 ; OR accumulator with memory (long indexed) [$15.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $191518.l,X		; FF 18 15 19 ; Subtract with carry (long,X) $191518.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $80FF.w		; EC FF 80 ; Compare $80FF.w with X register [Reads: X Index] [Flags: NCZ]
	and $1A40.w		; 2D 40 1A ; Logical AND $1A40.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $FF1313.l		; 2F 13 13 FF ; AND accumulator with memory (long) $FF1313.l [Writes: Accumulator] [Flags: NZ]
	jsl $1B06F7.l		; 22 F7 06 1B ; Jump to subroutine long $1B06F7.l [Writes: Stack Pointer] [Flow: call]
	sbc $09FF14.l,X		; FF 14 FF 09 ; Subtract with carry (long,X) $09FF14.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $624C.w		; 4C 4C 62 ; Jump to $624C.w [Flow: jump]
	trb $F706.w		; 1C 06 F7 ; Test and reset bits $F706.w [Reads: Accumulator] [Flags: Z]
	sbc [$5E.b],Y		; F7 5E ; Subtract with carry (long indexed) [$5E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $1F1414.l,X		; 5F 14 14 1F ; Exclusive OR accumulator with memory (long,X) $1F1414.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $07.b,S		; 23 07 ; AND accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $EBD5D5.l		; 0F D5 D5 EB ; OR accumulator with memory (long) $EBD5D5.l [Writes: Accumulator] [Flags: NZ]
	adc ($20.b),Y		; 71 20 ; Add with carry ($20.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	sbc ($6A.b),Y		; F1 6A ; Subtract with carry ($6A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $FB.b		; 06 FB ; Arithmetic shift left $FB.b [Reads: Direct Page] [Flags: NCZ]
	nop		; EA ; No operation
	eor $2F.b,S		; 43 2F ; Exclusive OR accumulator with stack relative $2F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($43.b,X)		; 21 43 ; Logical AND ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $0F0F15.l,X		; FF 15 0F 0F ; Subtract with carry (long,X) $0F0F15.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $10.b,S		; 03 10 ; OR accumulator with stack relative $10.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $10111E.l,X		; 1F 1E 11 10 ; Logical OR long $10111E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $070910.l		; 0F 10 09 07 ; OR accumulator with memory (long) $070910.l [Writes: Accumulator] [Flags: NZ]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	ora [$03.b]		; 07 03 ; OR accumulator with memory (long) [$03.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $22.b,S		; 03 22 ; OR accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1B27E0.l,X		; 1F E0 27 1B ; Logical OR long $1B27E0.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05090F.l,X		; 1F 0F 09 05 ; Logical OR long $05090F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0D10.w		; 0D 10 0D ; Logical OR $0D10.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0303.w		; 0D 03 03 ; Logical OR $0303.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $090705.l,X		; 1F 05 07 09 ; Logical OR long $090705.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1010.w		; 0E 10 10 ; Arithmetic shift left $1010.w [Flags: NCZ]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $050F0F.l,X		; 1F 0F 0F 05 ; Logical OR long $050F0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $10090F.l		; 0F 0F 09 10 ; OR accumulator with memory (long) $10090F.l [Writes: Accumulator] [Flags: NZ]
	eor $0E.b,S		; 43 0E ; Exclusive OR accumulator with stack relative $0E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($04.b,X)		; 01 04 ; Logical OR ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $0A.b		; 02 0A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $0083.w		; 1C 83 00 ; Test and reset bits $0083.w [Reads: Accumulator] [Flags: Z]
	and $0500.w,Y		; 39 00 05 ; AND accumulator with memory $0500.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $10.b		; 26 10 ; Rotate left $10.b [Reads: Direct Page] [Flags: NCZ]
	trb $0F.b		; 14 0F ; Test and reset bits $0F.b [Reads: Accumulator] [Flags: Z]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1F111C.l,X		; 1F 1C 11 1F ; Logical OR long $1F111C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $1F1F.w,X		; 1E 1F 1F ; Arithmetic shift left $1F1F.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	trb $1F0A.w		; 1C 0A 1F ; Test and reset bits $1F0A.w [Reads: Accumulator] [Flags: Z]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1F050A.l,X		; 1F 0A 05 1F ; Logical OR long $1F050A.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $1C061E.l		; 22 1E 06 1C ; Jump to subroutine long $1C061E.l [Writes: Stack Pointer] [Flow: call]
	ora $0D1010.l,X		; 1F 10 10 0D ; Logical OR long $0D1010.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	and $0A.b,S		; 23 0A ; AND accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $050A1F.l,X		; 1F 1F 0A 05 ; Logical OR long $050A1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b),Y		; 11 03 ; OR accumulator with memory ($03.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $1F		; 10 1F ; Branch if plus to $10, $1F [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $1C1306.l		; 22 06 13 1C ; Jump to subroutine long $1C1306.l [Writes: Stack Pointer] [Flow: call]
	ora $1C1C1F.l,X		; 1F 1F 1C 1C ; Logical OR long $1C1C1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $100C10.l,X		; 1F 10 0C 10 ; Logical OR long $100C10.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $150507.l,X		; 1F 07 05 15 ; Logical OR long $150507.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $11081C.l		; 22 1C 08 11 ; Jump to subroutine long $11081C.l [Writes: Stack Pointer] [Flow: call]
	ora $0C.b		; 05 0C ; Logical OR $0C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $06051F.l		; 0F 1F 05 06 ; OR accumulator with memory (long) $06051F.l [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sta [$0F.b],Y		; 97 0F ; Store accumulator (long indexed) [$0F.b],Y [Reads: Direct Page, Y Index, Accumulator]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora [$0A.b]		; 07 0A ; OR accumulator with memory (long) [$0A.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0A		; 10 0A ; Branch if plus to $10, $0A [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $0A.b		; 06 0A ; Arithmetic shift left $0A.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $08		; 10 08 ; Branch if plus to $10, $08 [Flow: branch]
	ora #$220F.w		; 09 0F 22 ; Logical OR #$220F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $04		; 10 04 ; Branch if plus to $10, $04 [Flow: branch]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	jsl $102205.l		; 22 05 22 10 ; Jump to subroutine long $102205.l [Writes: Stack Pointer] [Flow: call]
	ora #$1B07.w		; 09 07 1B ; Logical OR #$1B07.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$1C.b]		; 07 1C ; OR accumulator with memory (long) [$1C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0605.w		; 09 05 06 ; Logical OR #$0605.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $22.b		; 06 22 ; Arithmetic shift left $22.b [Reads: Direct Page] [Flags: NCZ]
	.db $10, $83		; 10 83 ; Branch if plus to $10, $83 [Flow: branch]
	brk $4D.b		; 00 4D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $09.b,S		; 43 09 ; Exclusive OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$26.b]		; 07 26 ; OR accumulator with memory (long) [$26.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	ora $1F1F10.l,X		; 1F 10 1F 1F ; Logical OR long $1F1F10.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $01231F.l		; 22 1F 23 01 ; Jump to subroutine long $01231F.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $1003.w		; 0D 03 10 ; Logical OR $1003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1003.w		; 0D 03 10 ; Logical OR $1003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $01111F.l		; 0F 1F 11 01 ; OR accumulator with memory (long) $01111F.l [Writes: Accumulator] [Flags: NZ]
	sbc $377C15.l,X		; FF 15 7C 37 ; Subtract with carry (long,X) $377C15.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $6AB2.w		; 4E B2 6A ; Logical shift right $6AB2.w [Flags: NCZ]
	ldx $AF.b,Y		; B6 AF ; Load X register $AF.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	jsl $B81220.l		; 22 20 12 B8 ; Jump to subroutine long $B81220.l [Writes: Stack Pointer] [Flow: call]
	sta $2498D7.l		; 8F D7 98 24 ; Store accumulator (long) $2498D7.l [Reads: Accumulator]
	sbc $B2.b		; E5 B2 ; Subtract $B2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda ($D2.b,S),Y		; B3 D2 ; Load accumulator (stack relative indirect indexed) ($D2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $44.b		; C6 44 ; Decrement $44.b [Reads: Direct Page] [Flags: NZ]
	mvp $23,$62		; 44 62 23 ; Move block positive $23,$62 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cpx #$B036.w		; E0 36 B0 ; Compare #$B036.w with X register [Reads: X Index] [Flags: NCZ]
	rol $96.b		; 26 96 ; Rotate left $96.b [Reads: Direct Page] [Flags: NCZ]
	rol $E5E5.w,X		; 3E E5 E5 ; Rotate left $E5E5.w,X [Reads: X Index] [Flags: NCZ]
	ora $BAA6.w,X		; 1D A6 BA ; OR accumulator with memory $BAA6.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $A9.b		; A6 A9 ; Load $A9.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $69D7.w,X		; BC D7 69 ; Load Y register $69D7.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	and [$E5.b]		; 27 E5 ; AND accumulator with memory (long) [$E5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $3E		; 90 3E ; Branch if carry clear to $90, $3E [Flow: branch]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $F2.b		; 06 F2 ; Arithmetic shift left $F2.b [Reads: Direct Page] [Flags: NCZ]
	asl $BF.b		; 06 BF ; Arithmetic shift left $BF.b [Reads: Direct Page] [Flags: NCZ]
	dec $C0.b,X		; D6 C0 ; Decrement memory $C0.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	cmp ($DC.b,X)		; C1 DC ; Compare accumulator ($DC.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	ora ($28.b),Y		; 11 28 ; OR accumulator with memory ($28.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda [$A8.b]		; A7 A8 ; Load accumulator (long) [$A8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $69.b		; E5 69 ; Subtract $69.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7CC352.l,X		; 9F 52 C3 7C ; Store accumulator (long,X) $7CC352.l,X [Reads: Accumulator, X Index]
	asl $E1.b		; 06 E1 ; Arithmetic shift left $E1.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $DCC4.w,X		; FD C4 DC ; Subtract with carry $DCC4.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($8D.b),Y		; 11 8D ; OR accumulator with memory ($8D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$A6A7.w		; 29 A7 A6 ; Logical AND #$A6A7.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
.ACCU 16
	rep #$65		; C2 65
	cmp [$E0.b]		; C7 E0 ; Compare accumulator (long) [$E0.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc $118D54.l		; 6F 54 8D 11 ; Add with carry (long) $118D54.l [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sty $17.b		; 84 17 ; Store Y register to $17.b [Reads: Y Index]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	adc ($2C.b,X)		; 61 2C ; Add with carry ($2C.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $6ACE.w		; 2D CE 6A ; Logical AND $6ACE.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $2E10.w,X		; 3D 10 2E ; AND accumulator with memory $2E10.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $112F.w,X		; FD 2F 11 ; Subtract with carry $112F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $934D30.l,X		; FF 30 4D 93 ; Subtract with carry (long,X) $934D30.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $43.b,S		; 63 43 ; Add with carry (stack relative) $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($D3.b),Y		; 31 D3 ; AND accumulator with memory ($D3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	pei ($76.b)		; D4 76 ; Push effective indirect address ($76.b) [Reads: Direct Page] [Writes: Stack Pointer]
	lda $25D6.w,Y		; B9 D6 25 ; Load $25D6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1141.w,X		; FD 41 11 ; Subtract with carry $1141.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($33.b)		; 32 33 ; AND accumulator with memory (indirect) ($33.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $FF.b		; 14 FF ; Test and reset bits $FF.b [Reads: Accumulator] [Flags: Z]
	sbc $941534.l,X		; FF 34 15 94 ; Subtract with carry (long,X) $941534.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	and $25.b,X		; 35 25 ; Logical AND $25.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $B9.b		; 14 B9 ; Test and reset bits $B9.b [Reads: Accumulator] [Flags: Z]
	lda $36C1.w,Y		; B9 C1 36 ; Load $36C1.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and [$A0.b],Y		; 37 A0 ; AND accumulator with memory (long indexed) [$A0.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $FF		; 42 FF ; Reserved instruction
	eor $38.b,S		; 43 38 ; Exclusive OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp [$98.b],Y		; D7 98 ; Compare accumulator (long indexed) [$98.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	dec $0924.w,X		; DE 24 09 ; Decrement memory $0924.w,X [Reads: X Index] [Flags: NZ]
	cpx #$2525.w		; E0 25 25 ; Compare #$2525.w with X register [Reads: X Index] [Flags: NCZ]
	and $E522.w,Y		; 39 22 E5 ; AND accumulator with memory $E522.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$4148.w		; A2 48 41 ; Load #$4148.w into X register [Writes: X Index] [Flags: NZ]
	eor #$E515.w		; 49 15 E5 ; Exclusive OR #$E515.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $EC.b,X		; B5 EC ; Load $EC.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora #$ECFF.w		; 09 FF EC ; Logical OR #$ECFF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $E5.b,X		; 95 E5 ; Store accumulator to $E5.b,X [Reads: Accumulator, X Index]
	ldx #$17A8.w		; A2 A8 17 ; Load #$17A8.w into X register [Writes: X Index] [Flags: NZ]
	cmp $B1.b		; C5 B1 ; Compare $B1.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora $9610.w,X		; 1D 10 96 ; OR accumulator with memory $9610.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $14.b		; 14 14 ; Test and reset bits $14.b [Reads: Accumulator] [Flags: Z]
	ora #$14F0.w		; 09 F0 14 ; Logical OR #$14F0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldx $C5.b,Y		; B6 C5 ; Load X register $C5.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	lda $52E5.w,Y		; B9 E5 52 ; Load $52E5.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $FF14EC.l,X		; FF EC 14 FF ; Subtract with carry (long,X) $FF14EC.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cpx $62FF.w		; EC FF 62 ; Compare $62FF.w with X register [Reads: X Index] [Flags: NCZ]
	sbc $4109.w		; ED 09 41 ; Subtract $4109.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	adc ($90.b,S),Y		; 73 90 ; Add with carry (stack relative indirect indexed) ($90.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc [$E5.b],Y		; F7 E5 ; Subtract with carry (long indexed) [$E5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $A5.b		; E5 A5 ; Subtract $A5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $620909.l,X		; FF 09 09 62 ; Subtract with carry (long,X) $620909.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $09.b,X		; F6 09 ; Increment memory $09.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc $EFEEFF.l,X		; FF FF EE EF ; Subtract with carry (long,X) $EFEEFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($5A.b,X)		; 41 5A ; Exclusive OR accumulator with memory ($5A.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $13.b		; E5 13 ; Subtract $13.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1D.b		; E5 1D ; Subtract $1D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $FB6207.l		; 22 07 62 FB ; Jump to subroutine long $FB6207.l [Writes: Stack Pointer] [Flow: call]
	asl $F7.b		; 06 F7 ; Arithmetic shift left $F7.b [Reads: Direct Page] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $D73D3C.l,X		; FF 3C 3D D7 ; Subtract with carry (long,X) $D73D3C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $62.b		; C5 62 ; Compare $62.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rol $EB22.w,X		; 3E 22 EB ; Rotate left $EB22.w,X [Reads: X Index] [Flags: NCZ]
	tsb $9FEC.w		; 0C EC 9F ; Test and set bits $9FEC.w [Reads: Accumulator] [Flags: Z]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	trb $F1.b		; 14 F1 ; Test and reset bits $F1.b [Reads: Accumulator] [Flags: Z]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($CA.b,X)		; 41 CA ; Exclusive OR accumulator with memory ($CA.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $01		; 42 01 ; Reserved instruction
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $1D1F05.l,X		; FF 05 1F 1D ; Subtract with carry (long,X) $1D1F05.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1F1D1F.l,X		; 1F 1F 1D 1F ; Logical OR long $1F1D1F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$0F.b]		; 07 0F ; OR accumulator with memory (long) [$0F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1D.b,X)		; 01 1D ; Logical OR ($1D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1F2A.w,X		; 1D 2A 1F ; OR accumulator with memory $1F2A.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1F2A.w,X		; 1E 2A 1F ; Arithmetic shift left $1F2A.w,X [Reads: X Index] [Flags: NCZ]
	ora $0F.b		; 05 0F ; Logical OR $0F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($07.b),Y		; 11 07 ; OR accumulator with memory ($07.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $28		; 10 28 ; Branch if plus to $10, $28 [Flow: branch]
	ora $0F0701.l,X		; 1F 01 07 0F ; Logical OR long $0F0701.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $01.b,S		; 43 01 ; Exclusive OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $1D02.w		; 0E 02 1D ; Arithmetic shift left $1D02.w [Flags: NCZ]
	ora $1F2405.l,X		; 1F 05 24 1F ; Logical OR long $1F2405.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $1F1F.w,X		; 1D 1F 1F ; OR accumulator with memory $1F1F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0C.b,X)		; 01 0C ; Logical OR ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0F1F1F.l		; 0F 1F 1F 0F ; OR accumulator with memory (long) $0F1F1F.l [Writes: Accumulator] [Flags: NZ]
	and $1F.b		; 25 1F ; Logical AND $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0B0522.l,X		; 1F 22 05 0B ; Logical OR long $0B0522.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0F07.w		; 0E 07 0F ; Arithmetic shift left $0F07.w [Flags: NCZ]
	ora ($10.b),Y		; 11 10 ; OR accumulator with memory ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $1F11.w,X		; 1E 11 1F ; Arithmetic shift left $1F11.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $11		; 10 11 ; Branch if plus to $10, $11 [Flow: branch]
	and $05.b,S		; 23 05 ; AND accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b)		; 12 03 ; OR accumulator with memory (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0905.w		; 09 05 09 ; Logical OR #$0905.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1F1009.l,X		; 1F 09 10 1F ; Logical OR long $1F1009.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1F1C0F.l,X		; 1F 0F 1C 1F ; Logical OR long $1F1C0F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$23.b]		; 07 23 ; OR accumulator with memory (long) [$23.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1E1001.l,X		; 1F 01 10 1E ; Logical OR long $1E1001.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $071F.w,X		; 1D 1F 07 ; OR accumulator with memory $071F.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$05.b]		; 07 05 ; OR accumulator with memory (long) [$05.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $05221F.l		; 22 1F 22 05 ; Jump to subroutine long $05221F.l [Writes: Stack Pointer] [Flow: call]
	ora #$051E.w		; 09 1E 05 ; Logical OR #$051E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $07101F.l,X		; 1F 1F 10 07 ; Logical OR long $07101F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $1F.b,S		; 23 1F ; AND accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $1B.b		; 05 1B ; Logical OR $1B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $07000F.l		; 22 0F 00 07 ; Jump to subroutine long $07000F.l [Writes: Stack Pointer] [Flow: call]
	jsl $090605.l		; 22 05 06 09 ; Jump to subroutine long $090605.l [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$24.b]		; 07 24 ; OR accumulator with memory (long) [$24.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($05.b),Y		; 11 05 ; OR accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0708.w		; 09 08 07 ; Logical OR #$0708.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0522.w,X		; 1D 22 05 ; OR accumulator with memory $0522.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $050111.l		; 22 11 01 05 ; Jump to subroutine long $050111.l [Writes: Stack Pointer] [Flow: call]
	ora $051F43.l,X		; 1F 43 1F 05 ; Logical OR long $051F43.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0C05.w,X		; 1D 05 0C ; OR accumulator with memory $0C05.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $10031F.l		; 22 1F 03 10 ; Jump to subroutine long $10031F.l [Writes: Stack Pointer] [Flow: call]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($23.b),Y		; 11 23 ; OR accumulator with memory ($23.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $040F22.l,X		; 1F 22 0F 04 ; Logical OR long $040F22.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $11051F.l,X		; 1F 1F 05 11 ; Logical OR long $11051F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $1023.w		; 0E 23 10 ; Arithmetic shift left $1023.w [Flags: NCZ]
	ora $0F.b,S		; 03 0F ; OR accumulator with stack relative $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $080F22.l,X		; 1F 22 0F 08 ; Logical OR long $080F22.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $060505.l,X		; 1F 05 05 06 ; Logical OR long $060505.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1003.w		; 0D 03 10 ; Logical OR $1003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $FF01.w		; 0D 01 FF ; Logical OR $FF01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($43.b,S),Y		; 13 43 ; OR accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stp		; DB ; Stop processor (halt CPU clock) [SNES: SNES: Stops CPU until reset] [Flow: halt]
	mvp $A8,$45		; 44 45 A8 ; Move block positive $A8,$45 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	lsr $47.b		; 46 47 ; Logical shift right $47.b [Reads: Direct Page] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	eor #$4AC1.w		; 49 C1 4A ; Exclusive OR #$4AC1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	eor ($CC.b)		; 52 CC ; Exclusive OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $C4.b		; 25 C4 ; Logical AND $C4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($4C.b),Y		; B1 4C ; Load accumulator ($4C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $4D62.w		; 4D 62 4D ; Exclusive OR $4D62.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($4D.b,X)		; 01 4D ; Logical OR ($4D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	eor $5063.w		; 4D 63 50 ; Exclusive OR $5063.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $C8.b,S		; 03 C8 ; OR accumulator with stack relative $C8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor #$2005.w		; 49 05 20 ; Exclusive OR #$2005.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	mvn $C8,$05		; 54 05 C8 ; Move block negative $C8,$05 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor #$076A.w		; 49 6A 07 ; Exclusive OR #$076A.w with accumulator [Writes: Accumulator] [Flags: NZ]
	bit $E3.b		; 24 E3 ; Test bits $E3.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $CC5208.l,X		; 5F 08 52 CC ; Exclusive OR accumulator with memory (long,X) $CC5208.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($2B.b,X)		; 01 2B ; Logical OR ($2B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	stz $69.b		; 64 69 ; Store zero to $69.b
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $6F6E.w,Y		; D9 6E 6F ; Compare accumulator $6F6E.w,Y [Reads: Y Index] [Flags: NCZ]
	ora $F50610.l		; 0F 10 06 F5 ; OR accumulator with memory (long) $F50610.l [Writes: Accumulator] [Flags: NZ]
	stx $7170.w		; 8E 70 71 ; Store X register to $7170.w [Reads: X Index]
	sta $E07265.l		; 8F 65 72 E0 ; Store accumulator (long) $E07265.l [Reads: Accumulator]
	and [$15.b],Y		; 37 15 ; AND accumulator with memory (long indexed) [$15.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	stz $AAB5.w		; 9C B5 AA ; Store zero to $AAB5.w
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	bit $7B.b		; 24 7B ; Test bits $7B.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $E5B1.w		; 0D B1 E5 ; Logical OR $E5B1.w with accumulator [Writes: Accumulator] [Flags: NZ]
	rol $1220.w,X		; 3E 20 12 ; Rotate left $1220.w,X [Reads: X Index] [Flags: NCZ]
	adc $15B8.w,Y		; 79 B8 15 ; Add $15B8.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $AF.b		; E5 AF ; Subtract $AF.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ldx $B5.b		; A6 B5 ; Load $B5.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	eor ($E5.b)		; 52 E5 ; Exclusive OR accumulator with memory (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $90, $52		; 90 52 ; Branch if carry clear to $90, $52 [Flow: branch]
	sbc $52.b		; E5 52 ; Subtract $52.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	rol $7BE3.w,X		; 3E E3 7B ; Rotate left $7BE3.w,X [Reads: X Index] [Flags: NCZ]
	jmp ($6DA7.w,X)		; 7C A7 6D ; Jump indirect indexed to ($6DA7.w,X) [Reads: X Index] [Flow: jump]
	adc $A6AF.w,X		; 7D AF A6 ; Add $A6AF.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	.db $90, $24		; 90 24 ; Branch if carry clear to $90, $24 [Flow: branch]
	ror $7F7D.w,X		; 7E 7D 7F ; Rotate right $7F7D.w,X [Reads: X Index] [Flags: NCZ]
	.db $80, $E9		; 80 E9 ; Branch always to $80, $E9 [Flow: branch]
	jsr $6512.w		; 20 12 65 ; Jump to subroutine at $6512.w [Writes: Stack Pointer] [Flow: call]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sta ($0B.b,X)		; 81 0B ; Store accumulator ($0B.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $82, $45, $24		; 82 45 24 ; Branch always long to $82, $45, $24 [Flow: branch]
	sbc $62.b		; E5 62 ; Subtract $62.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $22.b,S		; 83 22 ; Store accumulator (stack relative) $22.b,S [Reads: Stack Pointer, Accumulator]
	sbc $09.b		; E5 09 ; Subtract $09.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsr $B7CD.w		; 20 CD B7 ; Jump to subroutine at $B7CD.w [Writes: Stack Pointer] [Flow: call]
	cmp $86.b		; C5 86 ; Compare $86.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	sta [$B1.b]		; 87 B1 ; Store accumulator (long) [$B1.b] [Reads: Direct Page, Accumulator]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $B2.b		; E5 B2 ; Subtract $B2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $88.b,S		; 63 88 ; Add with carry (stack relative) $88.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $E4.b		; 06 E4 ; Arithmetic shift left $E4.b [Reads: Direct Page] [Flags: NCZ]
	sbc $24.b		; E5 24 ; Subtract $24.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B0.b		; E5 B0 ; Subtract $B0.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sty $C522.w		; 8C 22 C5 ; Store Y register to $C522.w [Reads: Y Index]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $A508E5.l		; 22 E5 08 A5 ; Jump to subroutine long $A508E5.l [Writes: Stack Pointer] [Flow: call]
	cmp $B2E5.w,X		; DD E5 B2 ; Compare accumulator $B2E5.w,X [Reads: X Index] [Flags: NCZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $1A19.w		; 6E 19 1A ; Rotate right $1A19.w [Flags: NCZ]
	jsl $E5051B.l		; 22 1B 05 E5 ; Jump to subroutine long $E5051B.l [Writes: Stack Pointer] [Flow: call]
	.db $90, $98		; 90 98 ; Branch if carry clear to $90, $98 [Flow: branch]
	lda ($24.b)		; B2 24 ; Load accumulator (indirect) ($24.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $22		; 80 22 ; Branch always to $80, $22 [Flow: branch]
	sbc $00.b		; E5 00 ; Subtract $00.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $1D62.w		; 8D 62 1D ; Store accumulator to $1D62.w [Reads: Accumulator]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $E58F8E.l,X		; FF 8E 8F E5 ; Subtract with carry (long,X) $E58F8E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $90, $E5		; 90 E5 ; Branch if carry clear to $90, $E5 [Flow: branch]
	sbc $7F.b		; E5 7F ; Subtract $7F.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $54.b		; E5 54 ; Subtract $54.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $6E.b		; E5 6E ; Subtract $6E.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $91, $04		; 62 91 04 ; Push effective relative address $62, $91, $04 [Writes: Stack Pointer]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $402C94.l,X		; FF 94 2C 40 ; Subtract with carry (long,X) $402C94.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $95, $22		; 62 95 22 ; Push effective relative address $62, $95, $22 [Writes: Stack Pointer]
	cmp $0C.b		; C5 0C ; Compare $0C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	rol $A091.w,X		; 3E 91 A0 ; Rotate left $A091.w,X [Reads: X Index] [Flags: NCZ]
	ora ($44.b,X)		; 01 44 ; Logical OR ($44.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $FEF7.w,X		; FD F7 FE ; Subtract with carry $FEF7.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$46.b]		; 07 46 ; OR accumulator with memory (long) [$46.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $229830.l		; 2F 30 98 22 ; AND accumulator with memory (long) $229830.l [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $A1A0.w,Y		; 99 A0 A1 ; Store accumulator to $A1A0.w,Y [Reads: Y Index, Accumulator]
	lda [$9F.b]		; A7 9F ; Load accumulator (long) [$9F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	trb $F1.b		; 14 F1 ; Test and reset bits $F1.b [Reads: Accumulator] [Flags: Z]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc $0141E0.l,X		; FF E0 41 01 ; Subtract with carry (long,X) $0141E0.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $0A1F15.l,X		; 1F 15 1F 0A ; Logical OR long $0A1F15.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $11.b		; 05 11 ; Logical OR $11.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $05.b,X		; 16 05 ; Arithmetic shift left $05.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $01.b,S		; 03 01 ; OR accumulator with stack relative $01.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $110A11.l,X		; 1F 11 0A 11 ; Logical OR long $110A11.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1C1B05.l,X		; 1F 05 1B 1C ; Logical OR long $1C1B05.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$01.b]		; 07 01 ; OR accumulator with memory (long) [$01.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $111F07.l,X		; 1F 07 1F 11 ; Logical OR long $111F07.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($11.b),Y		; 11 11 ; OR accumulator with memory ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $01101B.l,X		; 1F 1B 10 01 ; Logical OR long $01101B.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($0F.b,X)		; 01 0F ; Logical OR ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $050701.l,X		; 1F 01 07 05 ; Logical OR long $050701.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$06.b]		; 07 06 ; OR accumulator with memory (long) [$06.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora $1F111E.l,X		; 1F 1E 11 1F ; Logical OR long $1F111E.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $0201.w		; 0C 01 02 ; Test and set bits $0201.w [Reads: Accumulator] [Flags: Z]
	jsl $060D07.l		; 22 07 0D 06 ; Jump to subroutine long $060D07.l [Writes: Stack Pointer] [Flow: call]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $1F.b		; 05 1F ; Logical OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	ora $06.b		; 05 06 ; Logical OR $06.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($0E.b,X)		; 01 0E ; Logical OR ($0E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $830702.l,X		; 1F 02 07 83 ; Logical OR long $830702.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $33.b		; 00 33 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $060201.l		; 22 01 02 06 ; Jump to subroutine long $060201.l [Writes: Stack Pointer] [Flow: call]
	ora $01221C.l,X		; 1F 1C 22 01 ; Logical OR long $01221C.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor #$080C.w		; 49 0C 08 ; Exclusive OR #$080C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$0907.w		; 09 07 09 ; Logical OR #$0907.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1C0107.l,X		; 1F 07 01 1C ; Logical OR long $1C0107.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $0C.b,X		; 16 0C ; Arithmetic shift left $0C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $000523.l		; 0F 23 05 00 ; OR accumulator with memory (long) $000523.l [Writes: Accumulator] [Flags: NZ]
	ora $220F22.l,X		; 1F 22 0F 22 ; Logical OR long $220F22.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $100508.l,X		; 1F 08 05 10 ; Logical OR long $100508.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $071E.w,X		; 1E 1E 07 ; Arithmetic shift left $071E.w,X [Reads: X Index] [Flags: NCZ]
	asl $07.b,X		; 16 07 ; Arithmetic shift left $07.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $1F0711.l		; 22 11 07 1F ; Jump to subroutine long $1F0711.l [Writes: Stack Pointer] [Flow: call]
	ora $100511.l,X		; 1F 11 05 10 ; Logical OR long $100511.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $05		; 10 05 ; Branch if plus to $10, $05 [Flow: branch]
	trb $0722.w		; 1C 22 07 ; Test and reset bits $0722.w [Reads: Accumulator] [Flags: Z]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	tsb $0A.b		; 04 0A ; Test and set bits $0A.b [Reads: Accumulator] [Flags: Z]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $051F26.l		; 0F 26 1F 05 ; OR accumulator with memory (long) $051F26.l [Writes: Accumulator] [Flags: NZ]
	ora ($05.b),Y		; 11 05 ; OR accumulator with memory ($05.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1901.w		; 0D 01 19 ; Logical OR $1901.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $220511.l,X		; 1F 11 05 22 ; Logical OR long $220511.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $051109.l,X		; 1F 09 11 05 ; Logical OR long $051109.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $1F01.w		; 0D 01 1F ; Logical OR $1F01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($1F.b),Y		; 11 1F ; OR accumulator with memory ($1F.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $1E0805.l		; 22 05 08 1E ; Jump to subroutine long $1E0805.l [Writes: Stack Pointer] [Flow: call]
	ora $1F051F.l,X		; 1F 1F 05 1F ; Logical OR long $1F051F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $1A01.w		; 0D 01 1A ; Logical OR $1A01.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	lsr $05.b		; 46 05 ; Logical shift right $05.b [Reads: Direct Page] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	ora $1B05.w		; 0D 05 1B ; Logical OR $1B05.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $012210.l		; 22 10 22 01 ; Jump to subroutine long $012210.l [Writes: Stack Pointer] [Flow: call]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $1C1C10.l		; 22 10 1C 1C ; Jump to subroutine long $1C1C10.l [Writes: Stack Pointer] [Flow: call]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $101C10.l,X		; 1F 10 1C 10 ; Logical OR long $101C10.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $1F1A.w		; 0E 1A 1F ; Arithmetic shift left $1F1A.w [Flags: NCZ]
	ora $110106.l,X		; 1F 06 01 11 ; Logical OR long $110106.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $1C.b		; 06 1C ; Arithmetic shift left $1C.b [Reads: Direct Page] [Flags: NCZ]
	ora ($11.b,X)		; 01 11 ; Logical OR ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $FF0D.w		; 0D 0D FF ; Logical OR $FF0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$0641.w		; E0 41 06 ; Compare #$0641.w with X register [Reads: X Index] [Flags: NCZ]
	adc $8E.b,S		; 63 8E ; Add with carry (stack relative) $8E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sta [$9B.b]		; 87 9B ; Store accumulator (long) [$9B.b] [Reads: Direct Page, Accumulator]
	tsb $23FF.w		; 0C FF 23 ; Test and set bits $23FF.w [Reads: Accumulator] [Flags: Z]
	bit $FF02.w		; 2C 02 FF ; Test bits $FF02.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $71EDBD.l,X		; FF BD ED 71 ; Subtract with carry (long,X) $71EDBD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $63.b		; 06 63 ; Arithmetic shift left $63.b [Reads: Direct Page] [Flags: NCZ]
	dec $0F.b,X		; D6 0F ; Decrement memory $0F.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	.db $10, $9C		; 10 9C ; Branch if plus to $10, $9C [Flow: branch]
	jsr $2C13.w		; 20 13 2C ; Jump to subroutine at $2C13.w [Writes: Stack Pointer] [Flow: call]
	bit $029D.w		; 2C 9D 02 ; Test bits $029D.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $5C00FF.l,X		; FF FF 00 5C ; Subtract with carry (long,X) $5C00FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jsr $E276.w		; 20 76 E2 ; Jump to subroutine at $E276.w [Writes: Stack Pointer] [Flow: call]
	stz $9F81.w,X		; 9E 81 9F ; Store zero to $9F81.w,X [Reads: X Index]
	jsr $9DFF.w		; 20 FF 9D ; Jump to subroutine at $9DFF.w [Writes: Stack Pointer] [Flow: call]
	bit $9D2C.w		; 2C 2C 9D ; Test bits $9D2C.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $6A495E.l,X		; FF 5E 49 6A ; Subtract with carry (long,X) $6A495E.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp $EDA0.w		; 4C A0 ED ; Jump to $EDA0.w [Flow: jump]
	ora [$E5.b],Y		; 17 E5 ; OR accumulator with memory (long indexed) [$E5.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $04.b,X		; 75 04 ; Add $04.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($1B.b,X)		; A1 1B ; Load accumulator ($1B.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $53A2.w		; 2C A2 53 ; Test bits $53A2.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc $06.b,X		; F5 06 ; Subtract $06.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$2262]		; DC 62 22 ; Jump long indirect [$2262] [Flow: jump]
	cpx #$0E30.w		; E0 30 0E ; Compare #$0E30.w with X register [Reads: X Index] [Flags: NCZ]
	ora $A3.b,S		; 03 A3 ; OR accumulator with stack relative $A3.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp ($A4.b),Y		; D1 A4 ; Compare accumulator ($A4.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	ora $FF.b		; 05 FF ; Logical OR $FF.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $0C16.w		; ED 16 0C ; Subtract $0C16.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	eor [$A5.b]		; 47 A5 ; Exclusive OR accumulator with memory (long) [$A5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$2495]		; DC 95 24 ; Jump long indirect [$2495] [Flow: jump]
	sbc $18.b		; E5 18 ; Subtract $18.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora ($F9.b,S),Y		; 13 F9 ; OR accumulator (stack relative indirect indexed) ($F9.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $0F.b,X		; 16 0F ; Arithmetic shift left $0F.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldx $BB.b		; A6 BB ; Load $BB.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ora $17.b,S		; 03 17 ; OR accumulator with stack relative $17.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $AEA7.w		; 0C A7 AE ; Test and set bits $AEA7.w [Reads: Accumulator] [Flags: Z]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	sbc $B2.b		; E5 B2 ; Subtract $B2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $FF18.w,X		; 3E 18 FF ; Rotate left $FF18.w,X [Reads: X Index] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsr $0724.w		; 20 24 07 ; Jump to subroutine at $0724.w [Writes: Stack Pointer] [Flow: call]
	lda $2496.w,X		; BD 96 24 ; Load $2496.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $4D.b		; 00 4D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldx #$E5A3.w		; A2 A3 E5 ; Load #$E5A3.w into X register [Writes: X Index] [Flags: NZ]
	sbc $A9.b		; E5 A9 ; Subtract $A9.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jsl $AA62C5.l		; 22 C5 62 AA ; Jump to subroutine long $AA62C5.l [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc $97969A.l,X		; FF 9A 96 97 ; Subtract with carry (long,X) $97969A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $E524BA.l,X		; 1F BA 24 E5 ; Logical OR long $E524BA.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror $1962.w		; 6E 62 19 ; Rotate right $1962.w [Flags: NCZ]
	ora [$AD.b],Y		; 17 AD ; OR accumulator with memory (long indexed) [$AD.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $FE1E.w		; AE 1E FE ; Load $FE1E.w into X register [Writes: X Index] [Flags: NZ]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	asl $30A1.w		; 0E A1 30 ; Arithmetic shift left $30A1.w [Flags: NCZ]
	rol $24.b,X		; 36 24 ; Rotate left $24.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp #$B0AF.w		; C9 AF B0 ; Compare #$B0AF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $F9EEFF.l,X		; 1F FF EE F9 ; Logical OR long $F9EEFF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc $1F15.w,X		; FE 15 1F ; Increment memory $1F15.w,X [Reads: X Index] [Flags: NZ]
	lsr $5507.w,X		; 5E 07 55 ; Logical shift right $5507.w,X [Reads: X Index] [Flags: NCZ]
	jsl $AA62C5.l		; 22 C5 62 AA ; Jump to subroutine long $AA62C5.l [Writes: Stack Pointer] [Flow: call]
	adc $B1.b,S		; 63 B1 ; Add with carry (stack relative) $B1.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $2B.b		; 05 2B ; Logical OR $2B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $F70009.l,X		; FF 09 00 F7 ; Subtract with carry (long,X) $F70009.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($22.b),Y		; 71 22 ; Add with carry ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $1EB5.w		; 1C B5 1E ; Test and reset bits $1EB5.w [Reads: Accumulator] [Flags: Z]
	inc $0BB6.w,X		; FE B6 0B ; Increment memory $0BB6.w,X [Reads: X Index] [Flags: NZ]
	lda [$24.b],Y		; B7 24 ; Load accumulator (long indexed) [$24.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $000915.l,X		; FF 15 09 00 ; Subtract with carry (long,X) $000915.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	adc ($2C.b),Y		; 71 2C ; Add with carry ($2C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $C602.w		; 2C 02 C6 ; Test bits $C602.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	inc $09FF.w,X		; FE FF 09 ; Increment memory $09FF.w,X [Reads: X Index] [Flags: NZ]
	lda $FFBA.w,Y		; B9 BA FF ; Load $FFBA.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sbc $040009.l,X		; FF 09 00 04 ; Subtract with carry (long,X) $040009.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($43.b),Y		; 71 43 ; Add with carry ($43.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $0BFF.w,X		; BC FF 0B ; Load Y register $0BFF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	inc $5750.w,X		; FE 50 57 ; Increment memory $5750.w,X [Reads: X Index] [Flags: NZ]
	sbc $F7F7FF.l,X		; FF FF F7 F7 ; Subtract with carry (long,X) $F7F7FF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $5449.w,X		; 5E 49 54 ; Logical shift right $5449.w,X [Reads: X Index] [Flags: NCZ]
	eor $A1.b,X		; 55 A1 ; Exclusive OR accumulator with memory $A1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $041C07.l		; 22 07 1C 04 ; Jump to subroutine long $041C07.l [Writes: Stack Pointer] [Flow: call]
	eor #$BD30.w		; 49 30 BD ; Exclusive OR #$BD30.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$04.b]		; 07 04 ; OR accumulator with memory (long) [$04.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $54F114.l,X		; 5F 14 F1 54 ; Exclusive OR accumulator with memory (long,X) $54F114.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $A1.b,X		; 55 A1 ; Exclusive OR accumulator with memory $A1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($81.b,S),Y		; 53 81 ; XOR accumulator (stack relative indirect indexed) ($81.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $D4.b,S		; 43 D4 ; Exclusive OR accumulator with stack relative $D4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($BE.b,X)		; 21 BE ; Logical AND ($BE.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda [$EA.b]		; A7 EA ; Load accumulator (long) [$EA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $A7BEEB.l		; 2F EB BE A7 ; AND accumulator with memory (long) $A7BEEB.l [Writes: Accumulator] [Flags: NZ]
	.db $30, $55		; 30 55 ; Branch if minus to $30, $55 [Flow: branch]
	and ($53.b),Y		; 31 53 ; AND accumulator with memory ($53.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($FF.b,S),Y		; 53 FF ; XOR accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $FF.b		; E4 FF ; Compare $FF.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $D822FF.l,X		; 1F FF 22 D8 ; Logical OR long $D822FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($D9.b,X)		; 01 D9 ; Logical OR ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $D8.b		; 25 D8 ; Logical AND $D8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($D9.b,X)		; 01 D9 ; Logical OR ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $D8.b		; 25 D8 ; Logical AND $D8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $DB.b,S		; 63 DB ; Add with carry (stack relative) $DB.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $D8.b,S		; 23 D8 ; AND accumulator with stack relative $D8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora ($01.b,S),Y		; 13 01 ; OR accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $22DA.w,Y		; D9 DA 22 ; Compare accumulator $22DA.w,Y [Reads: Y Index] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora ($DB.b,X)		; 01 DB ; Logical OR ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$D862]		; DC 62 D8 ; Jump long indirect [$D862] [Flow: jump]
	jsl $DB04D8.l		; 22 D8 04 DB ; Jump to subroutine long $DB04D8.l [Writes: Stack Pointer] [Flow: call]
	jmp.w [$DBD8]		; DC D8 DB ; Jump long indirect [$DBD8] [Flow: jump]
	jmp.w [$D823]		; DC 23 D8 ; Jump long indirect [$D823] [Flow: jump]
	ora $DD.b,S		; 03 DD ; OR accumulator with stack relative $DD.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $DCDB.w,X		; DE DB DC ; Decrement memory $DCDB.w,X [Reads: X Index] [Flags: NZ]
	and $D8.b,S		; 23 D8 ; AND accumulator with stack relative $D8.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $D822.w,X		; 1D 22 D8 ; OR accumulator with memory $D822.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($DF.b,X)		; 01 DF ; Logical OR ($DF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpx #$D862.w		; E0 62 D8 ; Compare #$D862.w with X register [Reads: X Index] [Flags: NCZ]
	jsl $DF04D8.l		; 22 D8 04 DF ; Jump to subroutine long $DF04D8.l [Writes: Stack Pointer] [Flow: call]
	cpx #$DBD8.w		; E0 D8 DB ; Compare #$DBD8.w with X register [Reads: X Index] [Flags: NCZ]
	jmp.w [$D822]		; DC 22 D8 ; Jump long indirect [$D822] [Flow: jump]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and $D822.w		; 2D 22 D8 ; Logical AND $D822.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($DB.b,X)		; 01 DB ; Logical OR ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$D823]		; DC 23 D8 ; Jump long indirect [$D823] [Flow: jump]
	ora ($D9.b,X)		; 01 D9 ; Logical OR ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $D8.b		; 25 D8 ; Logical AND $D8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($D9.b,X)		; 01 D9 ; Logical OR ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $D8.b		; 25 D8 ; Logical AND $D8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($DB.b,X)		; 01 DB ; Logical OR ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$D825]		; DC 25 D8 ; Jump long indirect [$D825] [Flow: jump]
	ora ($DB.b,X)		; 01 DB ; Logical OR ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$D824]		; DC 24 D8 ; Jump long indirect [$D824] [Flow: jump]
	ora ($D9.b,X)		; 01 D9 ; Logical OR ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $D8.b		; 25 D8 ; Logical AND $D8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($D9.b,X)		; 01 D9 ; Logical OR ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $D8.b		; 25 D8 ; Logical AND $D8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora ($23.b,S),Y		; 13 23 ; OR accumulator (stack relative indirect indexed) ($23.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jsl $0084D8.l		; 22 D8 84 00 ; Jump to subroutine long $0084D8.l [Writes: Stack Pointer] [Flow: call]
	and $22.b		; 25 22 ; Logical AND $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and $D823.w		; 2D 23 D8 ; Logical AND $D823.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	rol $23.b,X		; 36 23 ; Rotate left $23.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	ora $D822.w,X		; 1D 22 D8 ; OR accumulator with memory $D822.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	lsr $22.b		; 46 22 ; Logical shift right $22.b [Reads: Direct Page] [Flags: NCZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	lsr $D822.w		; 4E 22 D8 ; Logical shift right $D822.w [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	and $D822.w		; 2D 22 D8 ; Logical AND $D822.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($DB.b,X)		; 01 DB ; Logical OR ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$D823]		; DC 23 D8 ; Jump long indirect [$D823] [Flow: jump]
	ora ($D9.b,X)		; 01 D9 ; Logical OR ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $D8.b		; 25 D8 ; Logical AND $D8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($D9.b,X)		; 01 D9 ; Logical OR ($D9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	and $D8.b		; 25 D8 ; Logical AND $D8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($DB.b,X)		; 01 DB ; Logical OR ($DB.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jmp.w [$D825]		; DC 25 D8 ; Jump long indirect [$D825] [Flow: jump]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $30, $FF		; 30 FF ; Branch if minus to $30, $FF [Flow: branch]
	cpx $FF.b		; E4 FF ; Compare $FF.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $BF67FF.l,X		; 1F FF 67 BF ; Logical OR long $BF67FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	brk $66.b		; 00 66 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$00.b]		; C7 00 ; Compare accumulator (long) [$00.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $0087.w		; CD 87 00 ; Compare $0087.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $10, $62		; 10 62 ; Branch if plus to $10, $62 [Flow: branch]
	dec $CD01.w		; CE 01 CD ; Decrement $CD01.w [Flags: NZ]
	lda $87D162.l,X		; BF 62 D1 87 ; Load long $87D162.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$D4.b]		; 07 D4 ; OR accumulator with memory (long) [$D4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp $C6.b,X		; D5 C6 ; Compare accumulator $C6.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $D7D6C0.l,X		; BF C0 D6 D7 ; Load long $D7D6C0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$0087.w		; C0 87 00 ; Compare #$0087.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $30, $8B		; 30 8B ; Branch if minus to $30, $8B [Flow: branch]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $14.b		; 00 14 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	.db $10, $8B		; 10 8B ; Branch if plus to $10, $8B [Flow: branch]
	brk $24.b		; 00 24 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	jsr $008B.w		; 20 8B 00 ; Jump to subroutine at $008B.w [Writes: Stack Pointer] [Flow: call]
	bit $83.b,X		; 34 83 ; Test bits $83.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $7F		; F0 7F ; Branch if equal to $F0, $7F [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $1F38E4.l,X		; FF E4 38 1F ; Subtract with carry (long,X) $1F38E4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $20031F.l		; 22 1F 03 20 ; Jump to subroutine long $20031F.l [Writes: Stack Pointer] [Flow: call]
	jsr $1F1F.w		; 20 1F 1F ; Jump to subroutine at $1F1F.w [Writes: Stack Pointer] [Flow: call]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $2044.w		; 20 44 20 ; Jump to subroutine at $2044.w [Writes: Stack Pointer] [Flow: call]
	ora $1F2043.l,X		; 1F 43 20 1F ; Logical OR long $1F2043.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $2045.w		; 20 45 20 ; Jump to subroutine at $2045.w [Writes: Stack Pointer] [Flow: call]
	ora $201F01.l,X		; 1F 01 1F 20 ; Logical OR long $201F01.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $20.b,S		; 43 20 ; Exclusive OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $452022.l,X		; 1F 22 20 45 ; Logical OR long $452022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1F2220.l,X		; 1F 20 22 1F ; Logical OR long $1F2220.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	eor $43.b,S		; 43 43 ; Exclusive OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $011F.w		; 20 1F 01 ; Jump to subroutine at $011F.w [Writes: Stack Pointer] [Flow: call]
	ora $1F2320.l,X		; 1F 20 23 1F ; Logical OR long $1F2320.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	rol $1F34.w,X		; 3E 34 1F ; Rotate left $1F34.w,X [Reads: X Index] [Flags: NCZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $1F.b		; 24 1F ; Test bits $1F.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $00841F.l		; 22 1F 84 00 ; Jump to subroutine long $00841F.l [Writes: Stack Pointer] [Flow: call]
	and $1F22.w,X		; 3D 22 1F ; AND accumulator with memory $1F22.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $1F24.w		; 20 24 1F ; Jump to subroutine at $1F24.w [Writes: Stack Pointer] [Flow: call]
	jsl $008320.l		; 22 20 83 00 ; Jump to subroutine long $008320.l [Writes: Stack Pointer] [Flow: call]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $1F.b		; 26 1F ; Rotate left $1F.b [Reads: Direct Page] [Flags: NCZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and $2022.w,X		; 3D 22 20 ; AND accumulator with memory $2022.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($1F.b,X)		; 01 1F ; Logical OR ($1F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $232023.l,X		; 1F 23 20 23 ; Logical OR long $232023.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $482000.l,X		; 1F 00 20 48 ; Logical OR long $482000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $221F.w		; 20 1F 22 ; Jump to subroutine at $221F.w [Writes: Stack Pointer] [Flow: call]
	ora $202001.l,X		; 1F 01 20 20 ; Logical OR long $202001.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $20021F.l		; 22 1F 02 20 ; Jump to subroutine long $20021F.l [Writes: Stack Pointer] [Flow: call]
	ora $1F2320.l,X		; 1F 20 23 1F ; Logical OR long $1F2320.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $832022.l,X		; 1F 22 20 83 ; Logical OR long $832022.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $3C.b		; 00 3C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $008520.l		; 22 20 85 00 ; Jump to subroutine long $008520.l [Writes: Stack Pointer] [Flow: call]
	ror $26.b,X		; 76 26 ; Rotate right $26.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $232000.l,X		; 1F 00 20 23 ; Logical OR long $232000.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $E166FF.l,X		; 1F FF 66 E1 ; Logical OR long $E166FF.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl $E4.b		; 06 E4 ; Arithmetic shift left $E4.b [Reads: Direct Page] [Flags: NCZ]
	inc $E8.b		; E6 E8 ; Increment $E8.b [Reads: Direct Page] [Flags: NZ]
	sbc #$E6E7.w		; E9 E7 E6 ; Subtract #$E6E7.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	eor $E5.b,S		; 43 E5 ; Exclusive OR accumulator with stack relative $E5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc [$00.b]		; E7 00 ; Subtract with carry (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cpx $64.b		; E4 64 ; Compare $64.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $E6.b,X		; 15 E6 ; OR accumulator with memory $E6.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $E5		; F0 E5 ; Branch if equal to $F0, $E5 [Flow: branch]
	sbc ($E7.b),Y		; F1 E7 ; Subtract with carry ($E7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($E5.b)		; F2 E5 ; Subtract with carry (indirect) ($E5.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($E2.b,S),Y		; F3 E2 ; Subtract with carry (stack relative indirect indexed) ($E2.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E3.b,S		; E3 E3 ; Subtract stack-relative $E3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	pea $E7F5.w		; F4 F5 E7 ; Push absolute address $E7F5.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	cpx $E4.b		; E4 E4 ; Compare $E4.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc #$F6EE.w		; E9 EE F6 ; Subtract #$F6EE.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc [$E1.b],Y		; F7 E1 ; Subtract with carry (long indexed) [$E1.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $F8.b		; 65 F8 ; Add $F8.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $FEED.w		; 0C ED FE ; Test and set bits $FEED.w [Reads: Accumulator] [Flags: Z]
	sbc $00F0EA.l,X		; FF EA F0 00 ; Subtract with carry (long,X) $00F0EA.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($E6.b),Y		; F1 E6 ; Subtract with carry ($E6.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $01.b		; E6 01 ; Increment $01.b [Reads: Direct Page] [Flags: NZ]
	cop $E4.b		; 02 E4 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $63.b		; E4 63 ; Compare $63.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $07.b		; E4 07 ; Compare $07.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sbc [$09.b]		; E7 09 ; Subtract with carry (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $0A.b,X		; F6 0A ; Increment memory $0A.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tsb $FAE7.w		; 0C E7 FA ; Test and set bits $FAE7.w [Reads: Accumulator] [Flags: Z]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0EE8.w		; 0D E8 0E ; Logical OR $0EE8.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc ($0F.b)		; F2 0F ; Subtract with carry (indirect) ($0F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $F9.b		; E6 F9 ; Increment $F9.b [Reads: Direct Page] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $10, $EB		; 10 EB ; Branch if plus to $10, $EB [Flow: branch]
	ora ($EE.b),Y		; 11 EE ; OR accumulator with memory ($EE.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $12, $E0		; 62 12 E0 ; Push effective relative address $62, $12, $E0 [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sbc $00.b		; E5 00 ; Subtract $00.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	ora $EB.b,X		; 15 EB ; OR accumulator with memory $EB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $E4.b,X		; 16 E4 ; Arithmetic shift left $E4.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc [$E6.b]		; E7 E6 ; Subtract with carry (long) [$E6.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc $FF1817.l,X		; FF 17 18 FF ; Subtract with carry (long,X) $FF1817.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora $E1E7.w,Y		; 19 E7 E1 ; OR accumulator with memory $E1E7.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $E7.b		; E6 E7 ; Increment $E7.b [Reads: Direct Page] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sbc [$EB.b]		; E7 EB ; Subtract with carry (long) [$EB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sbc [$E7.b]		; E7 E7 ; Subtract with carry (long) [$E7.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $E7		; F0 E7 ; Branch if equal to $F0, $E7 [Flow: branch]
	sbc [$FF.b]		; E7 FF ; Subtract with carry (long) [$FF.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inc $E7.b		; E6 E7 ; Increment $E7.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
	sep #$EE		; E2 EE
	inc $E5.b		; E6 E5 ; Increment $E5.b [Reads: Direct Page] [Flags: NZ]
	sbc [$E4.b]		; E7 E4 ; Subtract with carry (long) [$E4.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	sbc $E7E5E8.l,X		; FF E8 E5 E7 ; Subtract with carry (long,X) $E7E5E8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($FF.b)		; F2 FF ; Subtract with carry (indirect) ($FF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	inc $F0.b		; E6 F0 ; Increment $F0.b [Reads: Direct Page] [Flags: NZ]
	sbc $1CE6E4.l,X		; FF E4 E6 1C ; Subtract with carry (long,X) $1CE6E4.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $FFE6.w		; EE E6 FF ; Increment $FFE6.w [Flags: NZ]
	trb $F81D.w		; 1C 1D F8 ; Test and reset bits $F81D.w [Reads: Accumulator] [Flags: Z]
	sbc $E6FF0B.l,X		; FF 0B FF E6 ; Subtract with carry (long,X) $E6FF0B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $1E.b		; E5 1E ; Subtract $1E.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	trb $F2.b		; 14 F2 ; Test and reset bits $F2.b [Reads: Accumulator] [Flags: Z]
	sbc $E4E7.w		; ED E7 E4 ; Subtract $E4E7.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	nop		; EA ; No operation
	.db $62, $1F, $E0		; 62 1F E0 ; Push effective relative address $62, $1F, $E0 [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	cpx $F2.b		; E4 F2 ; Compare $F2.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $F8E523.l		; 22 23 E5 F8 ; Jump to subroutine long $F8E523.l [Writes: Stack Pointer] [Flow: call]
	sbc $E6E6E7.l,X		; FF E7 E6 E6 ; Subtract with carry (long,X) $E6E6E7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
	sep #$24		; E2 24
	and $E8.b		; 25 E8 ; Logical AND $E8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($0A.b,S),Y		; F3 0A ; Subtract with carry (stack relative indirect indexed) ($0A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	rol $0B.b		; 26 0B ; Rotate left $0B.b [Reads: Direct Page] [Flags: NCZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc [$27.b]		; E7 27 ; Subtract with carry (long) [$27.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	asl $2603.w,X		; 1E 03 26 ; Arithmetic shift left $2603.w,X [Reads: X Index] [Flags: NCZ]
	sbc #$F0.b		; E9 F0 ; Subtract #$F0.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sbc [$EA.b]		; E7 EA ; Subtract with carry (long) [$EA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jsr $29E4.w		; 20 E4 29 ; Jump to subroutine at $29E4.w [Writes: Stack Pointer] [Flow: call]
	sbc ($2A.b)		; F2 2A ; Subtract with carry (indirect) ($2A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	bit $E6F1.w		; 2C F1 E6 ; Test bits $E6F1.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	sbc $1E.b		; E5 1E ; Subtract $1E.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	trb $E7F5.w		; 1C F5 E7 ; Test and reset bits $E7F5.w [Reads: Accumulator] [Flags: Z]
	sbc ($0A.b,S),Y		; F3 0A ; Subtract with carry (stack relative indirect indexed) ($0A.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2D.b		; E5 2D ; Subtract $2D.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc $F8.b		; E5 F8 ; Subtract $F8.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E72E.w,Y		; F9 2E E7 ; Subtract with carry $E72E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $E4301D.l		; 2F 1D 30 E4 ; AND accumulator with memory (long) $E4301D.l [Writes: Accumulator] [Flags: NZ]
	and ($0B.b),Y		; 31 0B ; AND accumulator with memory ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	asl $3332.w,X		; 1E 32 33 ; Arithmetic shift left $3332.w,X [Reads: X Index] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	nop		; EA ; No operation
	jsr $E7FF.w		; 20 FF E7 ; Jump to subroutine at $E7FF.w [Writes: Stack Pointer] [Flow: call]
	bit $E7.b,X		; 34 E7 ; Test bits $E7.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	sed		; F8 ; Set decimal flag [Flags: D]
	jsl $F806E7.l		; 22 E7 06 F8 ; Jump to subroutine long $F806E7.l [Writes: Stack Pointer] [Flow: call]
	sed		; F8 ; Set decimal flag [Flags: D]
	and $E5.b,X		; 35 E5 ; Logical AND $E5.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sbc ($E7.b,X)		; E1 E7 ; Subtract with carry ($E7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $072027.l,X		; FF 27 20 07 ; Subtract with carry (long,X) $072027.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $0101.w		; 20 01 01 ; Jump to subroutine at $0101.w [Writes: Stack Pointer] [Flow: call]
	jsr $0120.w		; 20 20 01 ; Jump to subroutine at $0120.w [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	bit $20.b		; 24 20 ; Test bits $20.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2300.w		; 20 00 23 ; Jump to subroutine at $2300.w [Writes: Stack Pointer] [Flow: call]
	jsr $0506.w		; 20 06 05 ; Jump to subroutine at $0506.w [Writes: Stack Pointer] [Flow: call]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	jsr $0204.w		; 20 04 02 ; Jump to subroutine at $0204.w [Writes: Stack Pointer] [Flow: call]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	jsr $0905.w		; 20 05 09 ; Jump to subroutine at $0905.w [Writes: Stack Pointer] [Flow: call]
	tsb $1111.w		; 0C 11 11 ; Test and set bits $1111.w [Reads: Accumulator] [Flags: Z]
	ora $202905.l		; 0F 05 29 20 ; OR accumulator with memory (long) $202905.l [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $0A.b		; 05 0A ; Logical OR $0A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $202907.l		; 0F 07 29 20 ; OR accumulator with memory (long) $202907.l [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $08.b		; 05 08 ; Logical OR $08.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $29.b		; 05 29 ; Logical OR $29.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0705.w		; 20 05 07 ; Jump to subroutine at $0705.w [Writes: Stack Pointer] [Flow: call]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	jsr $231F.w		; 20 1F 23 ; Jump to subroutine at $231F.w [Writes: Stack Pointer] [Flow: call]
	jsr $0022.w		; 20 22 00 ; Jump to subroutine at $0022.w [Writes: Stack Pointer] [Flow: call]
	bit $0220.w		; 2C 20 02 ; Test bits $0220.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	ora $2B.b,S		; 03 2B ; OR accumulator with stack relative $2B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr $0603.w		; 20 03 06 ; Jump to subroutine at $0603.w [Writes: Stack Pointer] [Flow: call]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jsr $0E02.w		; 20 02 0E ; Jump to subroutine at $0E02.w [Writes: Stack Pointer] [Flow: call]
	jsr $2C06.w		; 20 06 2C ; Jump to subroutine at $2C06.w [Writes: Stack Pointer] [Flow: call]
	jsr $0003.w		; 20 03 00 ; Jump to subroutine at $0003.w [Writes: Stack Pointer] [Flow: call]
	cop $1A.b		; 02 1A ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1B01.w		; 20 01 1B ; Jump to subroutine at $1B01.w [Writes: Stack Pointer] [Flow: call]
	brk $2C.b		; 00 2C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0E02.w		; 20 02 0E ; Jump to subroutine at $0E02.w [Writes: Stack Pointer] [Flow: call]
	ora ($03.b)		; 12 03 ; OR accumulator with memory (indirect) ($03.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cpx $29.b		; E4 29 ; Compare $29.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $01FF.w		; 20 FF 01 ; Jump to subroutine at $01FF.w [Writes: Stack Pointer] [Flow: call]
	rol $37.b,X		; 36 37 ; Rotate left $37.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $390C38.l		; 22 38 0C 39 ; Jump to subroutine long $390C38.l [Writes: Stack Pointer] [Flow: call]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $3A.b,X		; 15 3A ; OR accumulator with memory $3A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	bit $153D.w,X		; 3C 3D 15 ; Test bits $153D.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	and [$3E.b],Y		; 37 3E ; AND accumulator with memory (long indexed) [$3E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $40023F.l		; 22 3F 02 40 ; Jump to subroutine long $40023F.l [Writes: Stack Pointer] [Flow: call]
	and $6336.w,Y		; 39 36 63 ; AND accumulator with memory $6336.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($00.b,X)		; 41 00 ; Exclusive OR accumulator with memory ($00.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4564.w,X		; 1D 64 45 ; OR accumulator with memory $4564.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $4AAA.w		; 0D AA 4A ; Logical OR $4AAA.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $404B.w,X		; 1D 4B 40 ; OR accumulator with memory $404B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $5E4C.w,Y		; 39 4C 5E ; AND accumulator with memory $5E4C.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $814D.w,X		; 1D 4D 81 ; OR accumulator with memory $814D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $656B.w,Y		; 79 6B 65 ; Add $656B.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lsr $4B08.w		; 4E 08 4B ; Logical shift right $4B08.w [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	mvn $37,$FF		; 54 FF 37 ; Move block negative $37,$FF [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cop $03.b		; 02 03 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $9D.b		; 66 9D ; Rotate right $9D.b [Reads: Direct Page] [Flags: NCZ]
	adc #$55.b		; 69 55 ; Add #$55.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora [$E5.b]		; 07 E5 ; OR accumulator with memory (long) [$E5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $710100.l		; AF 00 01 71 ; Load long $710100.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and $5F.b,S		; 23 5F ; AND accumulator with stack relative $5F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $6067.w		; 4E 67 60 ; Logical shift right $6067.w [Flags: NCZ]
	ora [$E5.b]		; 07 E5 ; OR accumulator with memory (long) [$E5.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $DF.b		; E5 DF ; Subtract $DF.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $43.b		; 26 43 ; Rotate left $43.b [Reads: Direct Page] [Flags: NCZ]
	sbc $5F.b		; E5 5F ; Subtract $5F.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lsr $67.b,X		; 56 67 ; Logical shift right $67.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora $8A.b		; 05 8A ; Logical OR $8A.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $E1.b		; 04 E1 ; Test and set bits $E1.b [Reads: Accumulator] [Flags: Z]
.ACCU 8
.INDEX 8
	sep #$70		; E2 70
	sta [$63.b],Y		; 97 63 ; Store accumulator (long indexed) [$63.b],Y [Reads: Direct Page, Y Index, Accumulator]
	adc ($22.b),Y		; 71 22 ; Add with carry ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $7568.w,X		; 1D 68 75 ; OR accumulator with memory $7568.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $77.b		; 00 77 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $7E, $06		; 62 7E 06 ; Push effective relative address $62, $7E, $06 [Writes: Stack Pointer]
	.db $30, $1D		; 30 1D ; Branch if minus to $30, $1D [Flow: branch]
	cmp $5D5C.w,Y		; D9 5C 5D ; Compare accumulator $5D5C.w,Y [Reads: Y Index] [Flags: NCZ]
	sta ($82.b,X)		; 81 82 ; Store accumulator ($82.b,X) [Reads: Direct Page, Accumulator, X Index]
	and $83.b,S		; 23 83 ; AND accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sty $81.b		; 84 81 ; Store Y register to $81.b [Reads: Y Index]
	sta $86.b		; 85 86 ; Store accumulator to $86.b [Reads: Accumulator]
	sta $1D1D87.l		; 8F 87 1D 1D ; Store accumulator (long) $1D1D87.l [Reads: Accumulator]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	bit #$81.b		; 89 81 ; Test bits #$81.b with accumulator [Reads: Accumulator] [Flags: Z]
	sta ($24.b,X)		; 81 24 ; Store accumulator ($24.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta $0B.b,S		; 83 0B ; Store accumulator (stack relative) $0B.b,S [Reads: Stack Pointer, Accumulator]
	sta ($8A.b,X)		; 81 8A ; Store accumulator ($8A.b,X) [Reads: Direct Page, Accumulator, X Index]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	bit $938C.w,X		; 3C 8C 93 ; Test bits $938C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $816E.w		; 8D 6E 81 ; Store accumulator to $816E.w [Reads: Accumulator]
	sta ($8E.b,X)		; 81 8E ; Store accumulator ($8E.b,X) [Reads: Direct Page, Accumulator, X Index]
	and $83.b,S		; 23 83 ; AND accumulator with stack relative $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $8F, $09		; 62 8F 09 ; Push effective relative address $62, $8F, $09 [Writes: Stack Pointer]
	ora $AE27.w,X		; 1D 27 AE ; OR accumulator with memory $AE27.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $7675.w,X		; 1D 75 76 ; OR accumulator with memory $7675.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta ($93.b)		; 92 93 ; Store accumulator (indirect) ($93.b) [Reads: Direct Page, Accumulator]
	jsl $946483.l		; 22 83 64 94 ; Jump to subroutine long $946483.l [Writes: Stack Pointer] [Flow: call]
	ora $4B.b,S		; 03 4B ; OR accumulator with stack relative $4B.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $5D5C.w,X		; 1D 5C 5D ; OR accumulator with memory $5D5C.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $990081.l		; 22 81 00 99 ; Jump to subroutine long $990081.l [Writes: Stack Pointer] [Flow: call]
	jsl $940083.l		; 22 83 00 94 ; Jump to subroutine long $940083.l [Writes: Stack Pointer] [Flow: call]
	.db $62, $9A, $04		; 62 9A 04 ; Push effective relative address $62, $9A, $04 [Writes: Stack Pointer]
	bit $D9F6.w,X		; 3C F6 D9 ; Test bits $D9F6.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sta $2289.w,X		; 9D 89 22 ; Store accumulator to $2289.w,X [Reads: Accumulator, X Index]
	sta ($00.b,X)		; 81 00 ; Store accumulator ($00.b,X) [Reads: Direct Page, Accumulator, X Index]
	stz $8322.w,X		; 9E 22 83 ; Store zero to $8322.w,X [Reads: X Index]
	brk $94.b		; 00 94 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $9F.b,S		; 63 9F ; Add with carry (stack relative) $9F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $A2.b,S		; 63 A2 ; Add with carry (stack relative) $A2.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $81.b,S		; 03 81 ; OR accumulator with stack relative $81.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta ($A6.b,X)		; 81 A6 ; Store accumulator ($A6.b,X) [Reads: Direct Page, Accumulator, X Index]
	lda [$22.b]		; A7 22 ; Load accumulator (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $68.b,S		; 83 68 ; Store accumulator (stack relative) $68.b,S [Reads: Stack Pointer, Accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	cop $81.b		; 02 81 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($B1.b,X)		; 81 B1 ; Store accumulator ($B1.b,X) [Reads: Direct Page, Accumulator, X Index]
	jsl $B20183.l		; 22 83 01 B2 ; Jump to subroutine long $B20183.l [Writes: Stack Pointer] [Flow: call]
	lda ($FF.b,S),Y		; B3 FF ; Load accumulator (stack relative indirect indexed) ($FF.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cpx $2B.b		; E4 2B ; Compare $2B.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $0600.w		; 20 00 06 ; Jump to subroutine at $0600.w [Writes: Stack Pointer] [Flow: call]
	bit $0020.w		; 2C 20 00 ; Test bits $0020.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	trb $202A.w		; 1C 2A 20 ; Test and reset bits $202A.w [Reads: Accumulator] [Flags: Z]
	cop $06.b		; 02 06 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	jsl $1C0220.l		; 22 20 02 1C ; Jump to subroutine long $1C0220.l [Writes: Stack Pointer] [Flow: call]
	jsr $2505.w		; 20 05 25 ; Jump to subroutine at $2505.w [Writes: Stack Pointer] [Flow: call]
	jsr $0704.w		; 20 04 07 ; Jump to subroutine at $0704.w [Writes: Stack Pointer] [Flow: call]
	jsr $0520.w		; 20 20 05 ; Jump to subroutine at $0520.w [Writes: Stack Pointer] [Flow: call]
	ora $83.b		; 05 83 ; Logical OR $83.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $4B.b		; 00 4B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $20.b		; 26 20 ; Rotate left $20.b [Reads: Direct Page] [Flags: NCZ]
	ora #$07.b		; 09 07 ; Logical OR #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $09.b,S		; 03 09 ; OR accumulator with stack relative $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	asl $2020.w		; 0E 20 20 ; Arithmetic shift left $2020.w [Flags: NCZ]
	ora $250520.l		; 0F 20 05 25 ; OR accumulator with memory (long) $250520.l [Writes: Accumulator] [Flags: NZ]
	jsr $0604.w		; 20 04 06 ; Jump to subroutine at $0604.w [Writes: Stack Pointer] [Flow: call]
	tsb $20.b		; 04 20 ; Test and set bits $20.b [Reads: Accumulator] [Flags: Z]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $20.b,S		; 23 20 ; AND accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0707.w		; 20 07 07 ; Jump to subroutine at $0707.w [Writes: Stack Pointer] [Flow: call]
	jsr $2207.w		; 20 07 22 ; Jump to subroutine at $2207.w [Writes: Stack Pointer] [Flow: call]
	jsr $0500.w		; 20 00 05 ; Jump to subroutine at $0500.w [Writes: Stack Pointer] [Flow: call]
	and [$20.b]		; 27 20 ; AND accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	ora $20.b		; 05 20 ; Logical OR $20.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $051C.w		; 20 1C 05 ; Jump to subroutine at $051C.w [Writes: Stack Pointer] [Flow: call]
	ora $25.b		; 05 25 ; Logical OR $25.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $0701.w		; 20 01 07 ; Jump to subroutine at $0701.w [Writes: Stack Pointer] [Flow: call]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $93.b		; 00 93 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $050020.l		; 22 20 00 05 ; Jump to subroutine long $050020.l [Writes: Stack Pointer] [Flow: call]
	and $20.b		; 25 20 ; Logical AND $20.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $2220.w		; 0C 20 22 ; Test and set bits $2220.w [Reads: Accumulator] [Flags: Z]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$21.b		; 09 21 ; Logical OR #$21.b with accumulator [Writes: Accumulator] [Flags: NZ]
	trb CGDATA.w		; 1C 22 21 ; Test and reset bits CGDATA.w [Reads: Accumulator] [Flags: Z]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	sta $28.b,S		; 83 28 ; Store accumulator (stack relative) $28.b,S [Reads: Stack Pointer, Accumulator]
	and ($05.b,X)		; 21 05 ; Logical AND ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $2005.w		; 20 05 20 ; Jump to subroutine at $2005.w [Writes: Stack Pointer] [Flow: call]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $27.b		; 02 27 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($0A.b,X)		; 21 0A ; Logical AND ($0A.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($05.b,X)		; 21 05 ; Logical AND ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $21.b		; 05 21 ; Logical OR $21.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $02.b		; 06 02 ; Arithmetic shift left $02.b [Reads: Direct Page] [Flags: NCZ]
	ora ($21.b,X)		; 01 21 ; Logical OR ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $2125.w		; 20 25 21 ; Jump to subroutine at $2125.w [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $10, $1C		; 10 1C ; Branch if plus to $10, $1C [Flow: branch]
	ora $20.b		; 05 20 ; Logical OR $20.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($07.b,X)		; 21 07 ; Logical AND ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $2122.w		; 20 22 21 ; Jump to subroutine at $2122.w [Writes: Stack Pointer] [Flow: call]
	sbc $623662.l,X		; FF 62 36 62 ; Subtract with carry (long,X) $623662.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $62.b,X		; B4 62 ; Load Y register $62.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ldy $85.b,X		; B4 85 ; Load Y register $85.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $38.b,S		; 03 38 ; OR accumulator with stack relative $38.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and [$3E.b],Y		; 37 3E ; AND accumulator with memory (long indexed) [$3E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and $62B762.l,X		; 3F 62 B7 62 ; AND accumulator with memory (long,X) $62B762.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda [$85.b],Y		; B7 85 ; Load accumulator (long indexed) [$85.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($3F.b,X)		; 01 3F ; Logical OR ($3F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol $BA64.w,X		; 3E 64 BA ; Rotate left $BA64.w,X [Reads: X Index] [Flags: NCZ]
	jsl $BF62BC.l		; 22 BC 62 BF ; Jump to subroutine long $BF62BC.l [Writes: Stack Pointer] [Flow: call]
	ora $3D.b,S		; 03 3D ; OR accumulator with stack relative $3D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$BE		; C2 BE
	ldy $C369.w,X		; BC 69 C3 ; Load Y register $C369.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	brk $51.b		; 00 51 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $CD, $00		; 62 CD 00 ; Push effective relative address $62, $CD, $00 [Writes: Stack Pointer]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ror $D0.b		; 66 D0 ; Rotate right $D0.b [Reads: Direct Page] [Flags: NCZ]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $D76249.l		; 22 49 62 D7 ; Jump to subroutine long $D76249.l [Writes: Stack Pointer] [Flow: call]
	cop $51.b		; 02 51 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc $63.b		; E5 63 ; Subtract $63.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cmp $C8.b		; C5 C8 ; Compare $C8.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	adc $DE.b,S		; 63 DE ; Add with carry (stack relative) $DE.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cmp $E0E59A.l,X		; DF 9A E5 E0 ; Compare accumulator (long,X) $E0E59A.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	eor ($E1.b),Y		; 51 E1 ; Exclusive OR accumulator with memory ($E1.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $66.b		; E5 66 ; Subtract $66.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
	sep #$E0		; E2 E0
	rol $A075.w		; 2E 75 A0 ; Rotate left $A075.w [Flags: NCZ]
	sta ($97.b,S),Y		; 93 97 ; Store accumulator (stack relative indirect indexed) ($97.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sbc #$E3.b		; E9 E3 ; Subtract #$E3.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lda [$EA.b]		; A7 EA ; Load accumulator (long) [$EA.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	cmp ($D2.b),Y		; D1 D2 ; Compare accumulator ($D2.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cpx $E8D9.w		; EC D9 E8 ; Compare $E8D9.w with X register [Reads: X Index] [Flags: NCZ]
	asl $ED84.w		; 0E 84 ED ; Arithmetic shift left $ED84.w [Flags: NCZ]
	sbc $E3.b,S		; E3 E3 ; Subtract stack-relative $E3.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	dec $C7.b		; C6 C7 ; Decrement $C7.b [Reads: Direct Page] [Flags: NZ]
	inc $A8EF.w		; EE EF A8 ; Increment $A8EF.w [Flags: NZ]
	.db $F0, $DB		; F0 DB ; Branch if equal to $F0, $DB [Flow: branch]
	jmp.w [$51D3]		; DC D3 51 ; Jump long indirect [$51D3] [Flow: jump]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	eor ($53.b)		; 52 53 ; Exclusive OR accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc ($95.b),Y		; F1 95 ; Subtract with carry ($95.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($D4.b)		; F2 D4 ; Subtract with carry (indirect) ($D4.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	cmp $AE.b,X		; D5 AE ; Compare accumulator $AE.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sbc ($F4.b,S),Y		; F3 F4 ; Subtract with carry (stack relative indirect indexed) ($F4.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cpy $E5E4.w		; CC E4 E5 ; Compare $E5E4.w with Y register [Reads: Y Index] [Flags: NCZ]
	cmp $84C5.w,X		; DD C5 84 ; Compare accumulator $84C5.w,X [Reads: X Index] [Flags: NCZ]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($E5.b),Y		; 11 E5 ; OR accumulator with memory ($E5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $E3.b,X		; F5 E3 ; Subtract $E3.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($A8.b),Y		; 51 A8 ; Exclusive OR accumulator with memory ($A8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $D1F6.w		; AE F6 D1 ; Load $D1F6.w into X register [Writes: X Index] [Flags: NZ]
	cmp ($4A.b)		; D2 4A ; Compare accumulator (indirect) ($4A.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cpx $52E8.w		; EC E8 52 ; Compare $52E8.w with X register [Reads: X Index] [Flags: NCZ]
	eor ($F7.b,S),Y		; 53 F7 ; XOR accumulator (stack relative indirect indexed) ($F7.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	.db $42, $26		; 42 26 ; Reserved instruction
	.db $62, $F9, $0B		; 62 F9 0B ; Push effective relative address $62, $F9, $0B [Writes: Stack Pointer]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsr ($DCDB.w,X)		; FC DB DC ; Jump to subroutine indirect indexed ($DCDB.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $E8FE.w,X		; FD FE E8 ; Subtract with carry $E8FE.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($53.b)		; 52 53 ; Exclusive OR accumulator with memory (indirect) ($53.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc $22FF.w		; EE FF 22 ; Increment $22FF.w [Flags: NZ]
	bit $5902.w		; 2C 02 59 ; Test bits $5902.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	brk $51.b		; 00 51 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $01, $83		; 62 01 83 ; Push effective relative address $62, $01, $83 [Writes: Stack Pointer]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $4A.b,S		; 03 4A ; OR accumulator with stack relative $4A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $66.b		; 05 66 ; Logical OR $66.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $A8.b,S		; E3 A8 ; Subtract stack-relative $A8.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	eor ($0C.b)		; 52 0C ; Exclusive OR accumulator with memory (indirect) ($0C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $0D.b		; 65 0D ; Add $0D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $1307.w		; 0C 07 13 ; Test and set bits $1307.w [Reads: Accumulator] [Flags: Z]
	adc ($14.b,X)		; 61 14 ; Add with carry ($14.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $A8.b,X		; 15 A8 ; OR accumulator with memory $A8.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $1A16.w		; AE 16 1A ; Load $1A16.w into X register [Writes: X Index] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	inc $17.b		; E6 17 ; Increment $17.b [Reads: Direct Page] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $62, $18, $11		; 62 18 11 ; Push effective relative address $62, $18, $11 [Writes: Stack Pointer]
	ora ($1B.b)		; 12 1B ; OR accumulator with memory (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $E372.w		; 1C 72 E3 ; Test and reset bits $E372.w [Reads: Accumulator] [Flags: Z]
	eor ($A8.b),Y		; 51 A8 ; Exclusive OR accumulator with memory ($A8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1D.b,S		; E3 1D ; Subtract stack-relative $1D.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	.db $80, $1A		; 80 1A ; Branch always to $80, $1A [Flow: branch]
	inc $17.b		; E6 17 ; Increment $17.b [Reads: Direct Page] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $1A19.w,Y		; 39 19 1A ; AND accumulator with memory $1A19.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $25FF.w,X		; 1E FF 25 ; Arithmetic shift left $25FF.w,X [Reads: X Index] [Flags: NCZ]
	jsr $2105.w		; 20 05 21 ; Jump to subroutine at $2105.w [Writes: Stack Pointer] [Flow: call]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($03.b,X)		; 21 03 ; Logical AND ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $852025.l,X		; 1F 25 20 85 ; Logical OR long $852025.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $21.b		; 00 21 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $0100.w		; 0D 00 01 ; Logical OR $0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $210020.l		; 22 20 00 21 ; Jump to subroutine long $210020.l [Writes: Stack Pointer] [Flow: call]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	tsb $01.b		; 04 01 ; Test and set bits $01.b [Reads: Accumulator] [Flags: Z]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $070005.l		; 22 05 00 07 ; Jump to subroutine long $070005.l [Writes: Stack Pointer] [Flow: call]
	jsl $202521.l		; 22 21 25 20 ; Jump to subroutine long $202521.l [Writes: Stack Pointer] [Flow: call]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $070421.l		; 22 21 04 07 ; Jump to subroutine long $070421.l [Writes: Stack Pointer] [Flow: call]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $0E.b		; 05 0E ; Logical OR $0E.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	and ($07.b),Y		; 31 07 ; AND accumulator with memory ($07.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$05.b		; 09 05 ; Logical OR #$05.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $21.b,X		; 15 21 ; OR accumulator with memory $21.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($07.b,X)		; 21 07 ; Logical AND ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $0F,$21		; 44 21 0F ; Move block positive $0F,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $20.b		; 05 20 ; Logical OR $20.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $2005.w		; 20 05 20 ; Jump to subroutine at $2005.w [Writes: Stack Pointer] [Flow: call]
	and ($05.b,X)		; 21 05 ; Logical AND ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $20.b,X		; 15 20 ; OR accumulator with memory $20.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and ($07.b,X)		; 21 07 ; Logical AND ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $2123.w		; 20 23 21 ; Jump to subroutine at $2123.w [Writes: Stack Pointer] [Flow: call]
	eor $20.b,S		; 43 20 ; Exclusive OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($03.b,X)		; 21 03 ; Logical AND ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $008305.l		; 0F 05 83 00 ; OR accumulator with memory (long) $008305.l [Writes: Accumulator] [Flags: NZ]
	and $2001.w,X		; 3D 01 20 ; AND accumulator with memory $2001.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $0522.w		; 20 22 05 ; Jump to subroutine at $0522.w [Writes: Stack Pointer] [Flow: call]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora $01.b		; 05 01 ; Logical OR $01.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $8321.w		; 20 21 83 ; Jump to subroutine at $8321.w [Writes: Stack Pointer] [Flow: call]
	brk $6C.b		; 00 6C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $212A.w		; 20 2A 21 ; Jump to subroutine at $212A.w [Writes: Stack Pointer] [Flow: call]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ror OBJSEL.w		; 6E 01 21 ; Rotate right OBJSEL.w [Flags: NCZ]
	trb $0083.w		; 1C 83 00 ; Test and reset bits $0083.w [Reads: Accumulator] [Flags: Z]
	ror $23.b		; 66 23 ; Rotate right $23.b [Reads: Direct Page] [Flags: NCZ]
	jsr $2101.w		; 20 01 21 ; Jump to subroutine at $2101.w [Writes: Stack Pointer] [Flow: call]
	jsr $0083.w		; 20 83 00 ; Jump to subroutine at $0083.w [Writes: Stack Pointer] [Flow: call]
	ror $1C05.w		; 6E 05 1C ; Rotate right $1C05.w [Flags: NCZ]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $0E07.w,X		; 1E 07 0E ; Arithmetic shift left $0E07.w,X [Reads: X Index] [Flags: NCZ]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	adc $0083.w		; 6D 83 00 ; Add $0083.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $2122.w,X		; 7D 22 21 ; Add $2122.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $07.b		; 04 07 ; Test and set bits $07.b [Reads: Accumulator] [Flags: Z]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($15.b,X)		; 21 15 ; Logical AND ($15.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	bit $21.b		; 24 21 ; Test bits $21.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $21.b		; 24 21 ; Test bits $21.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $07.b		; 02 07 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($0C.b,X)		; 21 0C ; Logical AND ($0C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	ora ($07.b,X)		; 01 07 ; Logical OR ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $20.b,S		; 03 20 ; OR accumulator with stack relative $20.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($05.b,X)		; 21 05 ; Logical AND ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $43.b,S		; 03 43 ; OR accumulator with stack relative $43.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($07.b,X)		; 21 07 ; Logical AND ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($83.b,X)		; 21 83 ; Logical AND ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($21.b,X)		; 01 21 ; Logical OR ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$2B.b]		; 07 2B ; OR accumulator with memory (long) [$2B.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($83.b,X)		; 21 83 ; Logical AND ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $62B462.l,X		; FF 62 B4 62 ; Subtract with carry (long,X) $62B462.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $05.b,X		; B4 05 ; Load Y register $05.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora $20B41F.l,X		; 1F 1F B4 20 ; Logical OR long $20B41F.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$2221.w		; A0 21 22 ; Load #$2221.w into Y register [Writes: Y Index] [Flags: NZ]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	stz $B762.w		; 9C 62 B7 ; Store zero to $B762.w
	.db $62, $B7, $19		; 62 B7 19 ; Push effective relative address $62, $B7, $19 [Writes: Stack Pointer]
	jsl $23B722.l		; 22 22 B7 23 ; Jump to subroutine long $23B722.l [Writes: Stack Pointer] [Flow: call]
	ldy #$2524.w		; A0 24 25 ; Load #$2524.w into Y register [Writes: Y Index] [Flags: NZ]
	sta ($81.b,X)		; 81 81 ; Store accumulator ($81.b,X) [Reads: Direct Page, Accumulator, X Index]
	sta $FD4BC1.l,X		; 9F C1 4B FD ; Store accumulator (long,X) $FD4BC1.l,X [Reads: Accumulator, X Index]
	ldy $26BF.w,X		; BC BF 26 ; Load Y register $26BF.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	cpy #$27BF.w		; C0 BF 27 ; Compare #$27BF.w with Y register [Reads: Y Index] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ldy #$C961.w		; A0 61 C9 ; Load #$C961.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $E5.b		; E5 E5 ; Subtract $E5.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc $62.b,X		; 75 62 ; Add $62.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and #$25.b		; 29 25 ; Logical AND #$25.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	bit $8A5E.w		; 2C 5E 8A ; Test bits $8A5E.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	.db $62, $2D, $E0		; 62 2D E0 ; Push effective relative address $62, $2D, $E0 [Writes: Stack Pointer]
	and ($75.b,X)		; 21 75 ; Logical AND ($75.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $30, $A8		; 30 A8 ; Branch if minus to $30, $A8 [Flow: branch]
	cmp $302B.w,Y		; D9 2B 30 ; Compare accumulator $302B.w,Y [Reads: Y Index] [Flags: NCZ]
	and ($F3.b),Y		; 31 F3 ; AND accumulator with memory ($F3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc ($E5.b,S),Y		; F3 E5 ; Subtract with carry (stack relative indirect indexed) ($E5.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $32A2A3.l,X		; FF A3 A2 32 ; Subtract with carry (long,X) $32A2A3.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($75.b,S),Y		; 33 75 ; AND accumulator (stack relative indirect indexed) ($75.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $A7.b,X		; 34 A7 ; Test bits $A7.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $80.b,X		; 35 80 ; Logical AND $80.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $A8.b,X		; 36 A8 ; Rotate left $A8.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	dec $C7.b		; C6 C7 ; Decrement $C7.b [Reads: Direct Page] [Flags: NZ]
	ldx $37F3.w		; AE F3 37 ; Load $37F3.w into X register [Writes: X Index] [Flags: NZ]
	sbc $A2.b		; E5 A2 ; Subtract $A2.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $38.b,S		; E3 38 ; Subtract stack-relative $38.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	adc $CB.b,X		; 75 CB ; Add $CB.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $39.b,S		; 63 39 ; Add with carry (stack relative) $39.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $3DCB.w		; 0D CB 3D ; Logical OR $3DCB.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $3E.b,X		; D5 3E ; Compare accumulator $3E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and $E5A8A7.l,X		; 3F A7 A8 E5 ; AND accumulator with memory (long,X) $E5A8A7.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor ($75.b,X)		; 41 75 ; Exclusive OR accumulator with memory ($75.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $F3		; 42 F3 ; Reserved instruction
	sbc ($22.b,S),Y		; F3 22 ; Subtract with carry (stack relative indirect indexed) ($22.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E0.b		; E5 E0 ; Subtract $E0.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol $43F6.w,X		; 3E F6 43 ; Rotate left $43F6.w,X [Reads: X Index] [Flags: NCZ]
	bit $F5D0.w,X		; 3C D0 F5 ; Test bits $F5D0.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	mvp $45,$E5		; 44 E5 45 ; Move block positive $45,$E5 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	eor ($75.b,X)		; 41 75 ; Exclusive OR accumulator with memory ($75.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $C7.b		; C6 C7 ; Decrement $C7.b [Reads: Direct Page] [Flags: NZ]
	lsr $47.b		; 46 47 ; Logical shift right $47.b [Reads: Direct Page] [Flags: NCZ]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	.db $30, $30		; 30 30 ; Branch if minus to $30, $30 [Flow: branch]
	and ($49.b),Y		; 31 49 ; AND accumulator with memory ($49.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $80, $4B		; 80 4B ; Branch always to $80, $4B [Flow: branch]
	adc $3D.b,X		; 75 3D ; Add $3D.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $4C.b,X		; D5 4C ; Compare accumulator $4C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ldy $32.b		; A4 32 ; Load $32.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	inc $3B4D.w		; EE 4D 3B ; Increment $3B4D.w [Flags: NZ]
	cpy $EEE3.w		; CC E3 EE ; Compare $EEE3.w with Y register [Reads: Y Index] [Flags: NCZ]
	cpy $E332.w		; CC 32 E3 ; Compare $E332.w with Y register [Reads: Y Index] [Flags: NCZ]
	eor ($75.b,X)		; 41 75 ; Exclusive OR accumulator with memory ($75.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $A4D0.w		; 4E D0 A4 ; Logical shift right $A4D0.w [Flags: NCZ]
	eor $8B04C8.l		; 4F C8 04 8B ; Exclusive OR accumulator with memory (long) $8B04C8.l [Writes: Accumulator] [Flags: NZ]
	and $8A5150.l		; 2F 50 51 8A ; AND accumulator with memory (long) $8A5150.l [Writes: Accumulator] [Flags: NZ]
	eor ($D0.b)		; 52 D0 ; Exclusive OR accumulator with memory (indirect) ($D0.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($54.b,S),Y		; 53 54 ; XOR accumulator (stack relative indirect indexed) ($54.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $E3.b,X		; 75 E3 ; Add $E3.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $32.b,X		; 55 32 ; Exclusive OR accumulator with memory $32.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $6E.b,X		; 56 6E ; Logical shift right $6E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $62, $57, $0C		; 62 57 0C ; Push effective relative address $62, $57, $0C [Writes: Stack Pointer]
	ora ($9D.b,S),Y		; 13 9D ; OR accumulator (stack relative indirect indexed) ($9D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $7E5A59.l		; 8F 59 5A 7E ; Store accumulator (long) $7E5A59.l [Reads: Accumulator]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	jmp $5D3B3B.l		; 5C 3B 3B 5D ; Jump long to $5D3B3B.l [Flow: jump]
	ror $6357.w		; 6E 57 63 ; Rotate right $6357.w [Flags: NCZ]
	lsr $A416.w,X		; 5E 16 A4 ; Logical shift right $A416.w,X [Reads: X Index] [Flags: NCZ]
	.db $62, $E5, $93		; 62 E5 93 ; Push effective relative address $62, $E5, $93 [Writes: Stack Pointer]
	.db $80, $63		; 80 63 ; Branch always to $80, $63 [Flow: branch]
	stz $8B.b		; 64 8B ; Store zero to $8B.b
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	tsb $57.b		; 04 57 ; Test and set bits $57.b [Reads: Accumulator] [Flags: Z]
	lsr $6665.w,X		; 5E 65 66 ; Logical shift right $6665.w,X [Reads: X Index] [Flags: NCZ]
	cmp $60.b,S		; C3 60 ; Compare accumulator (stack relative) $60.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	eor $67B3.w,Y		; 59 B3 67 ; Exclusive OR accumulator with memory $67B3.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $68.b,X		; 95 68 ; Store accumulator to $68.b,X [Reads: Accumulator, X Index]
	eor ($69.b)		; 52 69 ; Exclusive OR accumulator with memory (indirect) ($69.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $6B016A.l		; 22 6A 01 6B ; Jump to subroutine long $6B016A.l [Writes: Stack Pointer] [Flow: call]
	adc $64.b		; 65 64 ; Add $64.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	jmp ($BB0C.w)		; 6C 0C BB ; Jump indirect to ($BB0C.w) [Flow: jump]
	adc ($95.b),Y		; 71 95 ; Add with carry ($95.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($73.b)		; 72 73 ; Add with carry (indirect) ($73.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor ($1E.b,S),Y		; 53 1E ; XOR accumulator (stack relative indirect indexed) ($1E.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $7574.w,X		; 1E 74 75 ; Arithmetic shift left $7574.w,X [Reads: X Index] [Flags: NCZ]
	jmp ($6D6D.w)		; 6C 6D 6D ; Jump indirect to ($6D6D.w) [Flow: jump]
	stz $76.b		; 64 76 ; Store zero to $76.b
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	cpx $01FF.w		; EC FF 01 ; Compare $01FF.w with X register [Reads: X Index] [Flags: NCZ]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($21.b,X)		; 21 21 ; Logical AND ($21.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $01.b		; 06 01 ; Arithmetic shift left $01.b [Reads: Direct Page] [Flags: NCZ]
	and ($20.b,X)		; 21 20 ; Logical AND ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $2123.w		; 20 23 21 ; Jump to subroutine at $2123.w [Writes: Stack Pointer] [Flow: call]
	asl $20.b		; 06 20 ; Arithmetic shift left $20.b [Reads: Direct Page] [Flags: NCZ]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$0E.b]		; 07 0E ; OR accumulator with memory (long) [$0E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($03.b,X)		; 21 03 ; Logical AND ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $040621.l		; 0F 21 06 04 ; OR accumulator with memory (long) $040621.l [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($05.b,X)		; 21 05 ; Logical AND ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $20.b		; 05 20 ; Logical OR $20.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $070721.l		; 0F 21 07 07 ; OR accumulator with memory (long) $070721.l [Writes: Accumulator] [Flags: NZ]
	and #$21.b		; 29 21 ; Logical AND #$21.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $05.b		; 04 05 ; Test and set bits $05.b [Reads: Accumulator] [Flags: Z]
	trb CGADD.w		; 1C 21 21 ; Test and reset bits CGADD.w [Reads: Accumulator] [Flags: Z]
	jsr $212A.w		; 20 2A 21 ; Jump to subroutine at $212A.w [Writes: Stack Pointer] [Flow: call]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$21.b		; 29 21 ; Logical AND #$21.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $050521.l		; 22 21 05 05 ; Jump to subroutine long $050521.l [Writes: Stack Pointer] [Flow: call]
	ora $2120.w,X		; 1D 20 21 ; OR accumulator with memory $2120.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	mvp $20,$21		; 44 21 20 ; Move block positive $20,$21 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora [$02.b]		; 07 02 ; OR accumulator with memory (long) [$02.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $21.b		; 05 21 ; Logical OR $21.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $21241C.l		; 0F 1C 24 21 ; OR accumulator with memory (long) $21241C.l [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $050321.l		; 22 21 03 05 ; Jump to subroutine long $050321.l [Writes: Stack Pointer] [Flow: call]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $2022.w		; 1C 22 20 ; Test and reset bits $2022.w [Reads: Accumulator] [Flags: Z]
	ora $05.b,S		; 03 05 ; OR accumulator with stack relative $05.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $07.b		; 05 07 ; Logical OR $07.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cop $83.b		; 02 83 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1B.b		; 00 1B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $1C.b		; 04 1C ; Test and set bits $1C.b [Reads: Accumulator] [Flags: Z]
	jsr $2120.w		; 20 20 21 ; Jump to subroutine at $2120.w [Writes: Stack Pointer] [Flow: call]
	asl $2122.w,X		; 1E 22 21 ; Arithmetic shift left $2122.w,X [Reads: X Index] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	asl $05.b		; 06 05 ; Arithmetic shift left $05.b [Reads: Direct Page] [Flags: NCZ]
	jsr $0721.w		; 20 21 07 ; Jump to subroutine at $0721.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $20		; 10 20 ; Branch if plus to $10, $20 [Flow: branch]
	trb M7Y.w		; 1C 20 21 ; Test and reset bits M7Y.w [Reads: Accumulator] [Flags: Z]
	trb $2220.w		; 1C 20 22 ; Test and reset bits $2220.w [Reads: Accumulator] [Flags: Z]
	and ($0D.b,X)		; 21 0D ; Logical AND ($0D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $210921.l		; 0F 21 09 21 ; OR accumulator with memory (long) $210921.l [Writes: Accumulator] [Flags: NZ]
	and ($07.b,X)		; 21 07 ; Logical AND ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($11.b,X)		; 21 11 ; Logical AND ($11.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and ($1E.b,X)		; 21 1E ; Logical AND ($1E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $2121.w		; 0E 21 21 ; Arithmetic shift left $2121.w [Flags: NCZ]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($08.b,X)		; 01 08 ; Logical OR ($08.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $22		; 10 22 ; Branch if plus to $10, $22 [Flow: branch]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $2707.w		; 20 07 27 ; Jump to subroutine at $2707.w [Writes: Stack Pointer] [Flow: call]
	and ($01.b,X)		; 21 01 ; Logical AND ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $07.b,S		; 03 07 ; OR accumulator with stack relative $07.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$83.b]		; 07 83 ; OR accumulator with memory (long) [$83.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $0021.w		; 2C 21 00 ; Test bits $0021.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	ora $2C.b,S		; 03 2C ; OR accumulator with stack relative $2C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($FF.b,X)		; 21 FF ; Logical AND ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($7B.b,X)		; 01 7B ; Logical OR ($7B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sed		; F8 ; Set decimal flag [Flags: D]
	adc $7C.b,S		; 63 7C ; Add with carry (stack relative) $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora ($EF.b)		; 12 EF ; OR accumulator with memory (indirect) ($EF.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $1A80.w		; 2E 80 1A ; Rotate left $1A80.w [Flags: NCZ]
	inc $17.b		; E6 17 ; Increment $17.b [Reads: Direct Page] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and $8119.w,Y		; 39 19 81 ; AND accumulator with memory $8119.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($07.b)		; 12 07 ; OR accumulator with memory (indirect) ($07.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $8B822C.l,X		; FF 2C 82 8B ; Subtract with carry (long,X) $8B822C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $84A783.l		; 2F 83 A7 84 ; AND accumulator with memory (long) $84A783.l [Writes: Accumulator] [Flags: NZ]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $84.b		; 02 84 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $1A.b		; 85 1A ; Store accumulator to $1A.b [Reads: Accumulator]
	.db $62, $86, $03		; 62 86 03 ; Push effective relative address $62, $86, $03 [Writes: Stack Pointer]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	bit #$8A.b		; 89 8A ; Test bits #$8A.b with accumulator [Reads: Accumulator] [Flags: Z]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ora [$00.b],Y		; 17 00 ; OR accumulator with memory (long indexed) [$00.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sty $62.b		; 84 62 ; Store Y register to $62.b [Reads: Y Index]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $8E, $00		; 62 8E 00 ; Push effective relative address $62, $8E, $00 [Writes: Stack Pointer]
	stz $62.b,X		; 74 62 ; Store zero to $62.b,X [Reads: X Index]
	sta ($05.b),Y		; 91 05 ; Store accumulator ($05.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sbc $F5.b,S		; E3 F5 ; Subtract stack-relative $F5.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	lda [$94.b]		; A7 94 ; Load accumulator (long) [$94.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor ($74.b,S),Y		; 53 74 ; XOR accumulator (stack relative indirect indexed) ($74.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc #$95.b		; 69 95 ; Add #$95.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tsb $9A.b		; 04 9A ; Test and set bits $9A.b [Reads: Accumulator] [Flags: Z]
	ldy $46.b		; A4 46 ; Load $46.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	sta $A067DE.l,X		; 9F DE 67 A0 ; Store accumulator (long,X) $A067DE.l,X [Reads: Accumulator, X Index]
	ora $9D.b,S		; 03 9D ; OR accumulator with stack relative $9D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$A3.b		; A9 A3 ; Load #$A3.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $AA, $00		; 62 AA 00 ; Push effective relative address $62, $AA, $00 [Writes: Stack Pointer]
	lsr $AD63.w,X		; 5E 63 AD ; Logical shift right $AD63.w,X [Reads: X Index] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $B1.b		; A5 B1 ; Load $B1.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda ($B3.b)		; B2 B3 ; Load accumulator (indirect) ($B3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$A3.b		; A9 A3 ; Load #$A3.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sty $E3.b		; 84 E3 ; Store Y register to $E3.b [Reads: Y Index]
	adc ($53.b,S),Y		; 73 53 ; Add with carry (stack relative indirect indexed) ($53.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $B4, $10		; 62 B4 10 ; Push effective relative address $62, $B4, $10 [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $65B6.w,X		; 3E B6 65 ; Rotate left $65B6.w,X [Reads: X Index] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	eor $1F.b		; 45 1F ; Exclusive OR $1F.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $B7.b,S		; A3 B7 ; Load accumulator (stack relative) $B7.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $80, $51		; 80 51 ; Branch always to $80, $51 [Flow: branch]
	clv		; B8 ; Clear overflow flag [Flags: V]
	lda $BAB2.w,Y		; B9 B2 BA ; Load $BAB2.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $62, $BC, $03		; 62 BC 03 ; Push effective relative address $62, $BC, $03 [Writes: Stack Pointer]
	cmp #$4A.b		; C9 4A ; Compare #$4A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	lda $C662A4.l,X		; BF A4 62 C6 ; Load long $C662A4.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $E5		; 10 E5 ; Branch if plus to $10, $E5 [Flow: branch]
	lda $E6FB45.l		; AF 45 FB E6 ; Load long $E6FB45.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$56.b],Y		; 17 56 ; OR accumulator with memory (long indexed) [$56.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$C122.w		; C0 22 C1 ; Compare #$C122.w with Y register [Reads: Y Index] [Flags: NCZ]
.ACCU 16
	rep #$E3		; C2 E3
	eor ($D4.b),Y		; 51 D4 ; Exclusive OR accumulator with memory ($D4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp $2E.b,X		; D5 2E ; Compare accumulator $2E.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $62, $C3, $E0		; 62 C3 E0 ; Push effective relative address $62, $C3, $E0 [Writes: Stack Pointer]
	and $1A.b,X		; 35 1A ; Logical AND $1A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $C04E.w,X		; 5E 4E C0 ; Logical shift right $C04E.w,X [Reads: X Index] [Flags: NCZ]
	sta $E3.b,X		; 95 E3 ; Store accumulator to $E3.b,X [Reads: Accumulator, X Index]
	sbc $51.b,S		; E3 51 ; Subtract stack-relative $51.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	inc $51C6.w		; EE C6 51 ; Increment $51C6.w [Flags: NZ]
	sbc $C7.b,S		; E3 C7 ; Subtract stack-relative $C7.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	dec $A7.b		; C6 A7 ; Decrement $A7.b [Reads: Direct Page] [Flags: NZ]
	.db $80, $FF		; 80 FF ; Branch always to $80, $FF [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$1459.w		; C9 59 14 ; Compare #$1459.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($CA.b)		; 12 CA ; OR accumulator with memory (indirect) ($CA.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $2F.b		; 04 2F ; Test and set bits $2F.b [Reads: Accumulator] [Flags: Z]
	wai		; CB ; Wait for interrupt
	cpy $8B8A.w		; CC 8A 8B ; Compare $8B8A.w with Y register [Reads: Y Index] [Flags: NCZ]
	and $31A7CD.l		; 2F CD A7 31 ; AND accumulator with memory (long) $31A7CD.l [Writes: Accumulator] [Flags: NZ]
	dec $1CCF.w		; CE CF 1C ; Decrement $1CCF.w [Flags: NZ]
	adc ($E3.b)		; 72 E3 ; Add with carry (indirect) ($E3.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	.db $D0, $AC		; D0 AC ; Branch if not equal to $D0, $AC [Flow: branch]
	cmp ($FF.b),Y		; D1 FF ; Compare accumulator ($FF.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sta ($D2.b)		; 92 D2 ; Store accumulator (indirect) ($D2.b) [Reads: Direct Page, Accumulator]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	cmp ($3B.b,S),Y		; D3 3B ; Compare accumulator (stack relative indirect indexed) ($3B.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	pei ($D5.b)		; D4 D5 ; Push effective indirect address ($D5.b) [Reads: Direct Page] [Writes: Stack Pointer]
	lda ($95.b,X)		; A1 95 ; Load accumulator ($95.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $D6.b		; 64 D6 ; Store zero to $D6.b
	tsb $DB79.w		; 0C 79 DB ; Test and set bits $DB79.w [Reads: Accumulator] [Flags: Z]
	asl $0712.w,X		; 1E 12 07 ; Arithmetic shift left $0712.w,X [Reads: X Index] [Flags: NCZ]
	ora ($8B.b,S),Y		; 13 8B ; OR accumulator (stack relative indirect indexed) ($8B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jmp.w [$A1DD]		; DC DD A1 ; Jump long indirect [$A1DD] [Flow: jump]
	sta $E3.b,X		; 95 E3 ; Store accumulator to $E3.b,X [Reads: Accumulator, X Index]
	cmp [$65.b],Y		; D7 65 ; Compare accumulator (long indexed) [$65.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	dec $1A06.w,X		; DE 06 1A ; Decrement memory $1A06.w,X [Reads: X Index] [Flags: NZ]
	ora ($1B.b)		; 12 1B ; OR accumulator with memory (indirect) ($1B.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	dec $A1CF.w		; CE CF A1 ; Decrement $A1CF.w [Flags: NZ]
	stz $E4.b		; 64 E4 ; Store zero to $E4.b
	brk $DB.b		; 00 DB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $E9, $03		; 62 E9 03 ; Push effective relative address $62, $E9, $03 [Writes: Stack Pointer]
	ora $1E1A.w,Y		; 19 1A 1E ; OR accumulator with memory $1E1A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $2BFF.w,X		; 1E FF 2B ; Arithmetic shift left $2BFF.w,X [Reads: X Index] [Flags: NCZ]
	and ($03.b,X)		; 21 03 ; Logical AND ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$21.b]		; 07 21 ; OR accumulator with memory (long) [$21.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($07.b,X)		; 21 07 ; Logical AND ($07.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	and ($00.b,X)		; 21 00 ; Logical AND ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $2101.w		; 20 01 21 ; Jump to subroutine at $2101.w [Writes: Stack Pointer] [Flow: call]
	and ($25.b,X)		; 21 25 ; Logical AND ($25.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $052104.l		; 22 04 21 05 ; Jump to subroutine long $052104.l [Writes: Stack Pointer] [Flow: call]
	jsl $220721.l		; 22 21 07 22 ; Jump to subroutine long $220721.l [Writes: Stack Pointer] [Flow: call]
	jsr $2215.w		; 20 15 22 ; Jump to subroutine at $2215.w [Writes: Stack Pointer] [Flow: call]
	tsb $22.b		; 04 22 ; Test and set bits $22.b [Reads: Accumulator] [Flags: Z]
	jsl $020302.l		; 22 02 03 02 ; Jump to subroutine long $020302.l [Writes: Stack Pointer] [Flow: call]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $072122.l		; 22 22 21 07 ; Jump to subroutine long $072122.l [Writes: Stack Pointer] [Flow: call]
	jsl $220D22.l		; 22 22 0D 22 ; Jump to subroutine long $220D22.l [Writes: Stack Pointer] [Flow: call]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl $01.b,X		; 16 01 ; Arithmetic shift left $01.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $23.b,S		; 03 23 ; OR accumulator with stack relative $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $212102.l		; 22 02 21 21 ; Jump to subroutine long $212102.l [Writes: Stack Pointer] [Flow: call]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $220200.l		; 22 00 02 22 ; Jump to subroutine long $220200.l [Writes: Stack Pointer] [Flow: call]
	jsl $202101.l		; 22 01 21 20 ; Jump to subroutine long $202101.l [Writes: Stack Pointer] [Flow: call]
	bit $22.b		; 24 22 ; Test bits $22.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	cop $21.b		; 02 21 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$20.b]		; 07 20 ; OR accumulator with memory (long) [$20.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $22.b,S		; 23 22 ; AND accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $21.b,S		; 23 21 ; AND accumulator with stack relative $21.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $0521.w		; 0E 21 05 ; Arithmetic shift left $0521.w [Flags: NCZ]
	jsr $0705.w		; 20 05 07 ; Jump to subroutine at $0705.w [Writes: Stack Pointer] [Flow: call]
	jsr $2223.w		; 20 23 22 ; Jump to subroutine at $2223.w [Writes: Stack Pointer] [Flow: call]
	jsl $220115.l		; 22 15 01 22 ; Jump to subroutine long $220115.l [Writes: Stack Pointer] [Flow: call]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $770083.l		; 22 83 00 77 ; Jump to subroutine long $770083.l [Writes: Stack Pointer] [Flow: call]
	ora $1F.b,S		; 03 1F ; OR accumulator with stack relative $1F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $220622.l		; 22 22 06 22 ; Jump to subroutine long $220622.l [Writes: Stack Pointer] [Flow: call]
	ora $E0.b,X		; 15 E0 ; OR accumulator with memory $E0.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: NCZ]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $15.b		; 06 15 ; Arithmetic shift left $15.b [Reads: Direct Page] [Flags: NCZ]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $02.b		; 04 02 ; Test and set bits $02.b [Reads: Accumulator] [Flags: Z]
	jsl $210522.l		; 22 22 05 21 ; Jump to subroutine long $210522.l [Writes: Stack Pointer] [Flow: call]
	jsr $0621.w		; 20 21 06 ; Jump to subroutine at $0621.w [Writes: Stack Pointer] [Flow: call]
	ora ($03.b,X)		; 01 03 ; Logical OR ($03.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $071F09.l		; 22 09 1F 07 ; Jump to subroutine long $071F09.l [Writes: Stack Pointer] [Flow: call]
	ora $020207.l		; 0F 07 02 02 ; OR accumulator with memory (long) $020207.l [Writes: Accumulator] [Flags: NZ]
	ora $22.b		; 05 22 ; Logical OR $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $21221C.l		; 0F 1C 22 21 ; OR accumulator with memory (long) $21221C.l [Writes: Accumulator] [Flags: NZ]
	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	ora $1C.b		; 05 1C ; Logical OR $1C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $0F21.w		; 1C 21 0F ; Test and reset bits $0F21.w [Reads: Accumulator] [Flags: Z]
	and ($22.b,X)		; 21 22 ; Logical AND ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $050F01.l		; 22 01 0F 05 ; Jump to subroutine long $050F01.l [Writes: Stack Pointer] [Flow: call]
	and $22.b,S		; 23 22 ; AND accumulator with stack relative $22.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $21.b		; 05 21 ; Logical OR $21.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $201C.w		; 1C 1C 20 ; Test and reset bits $201C.w [Reads: Accumulator] [Flags: Z]
	and ($0F.b,X)		; 21 0F ; Logical AND ($0F.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and ($04.b,X)		; 21 04 ; Logical AND ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $2220.w		; 20 20 22 ; Jump to subroutine at $2220.w [Writes: Stack Pointer] [Flow: call]
	ora [$22.b]		; 07 22 ; OR accumulator with memory (long) [$22.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $0107.w		; 2D 07 01 ; Logical AND $0107.w with accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $212C22.l		; 22 22 2C 21 ; Jump to subroutine long $212C22.l [Writes: Stack Pointer] [Flow: call]
	ora ($22.b,X)		; 01 22 ; Logical OR ($22.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $02212D.l		; 22 2D 21 02 ; Jump to subroutine long $02212D.l [Writes: Stack Pointer] [Flow: call]
	jsl $FF2121.l		; 22 21 21 FF ; Jump to subroutine long $FF2121.l [Writes: Stack Pointer] [Flow: call]
	brk $EC.b		; 00 EC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $62, $EC, $22		; 62 EC 22 ; Push effective relative address $62, $EC, $22 [Writes: Stack Pointer]
	adc $EF00.w		; 6D 00 EF ; Add $EF00.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $EF.b,S		; 63 EF ; Add with carry (stack relative) $EF.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $95.b,S		; 03 95 ; OR accumulator with stack relative $95.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($73.b)		; 72 73 ; Add with carry (indirect) ($73.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	eor ($62.b,S),Y		; 53 62 ; XOR accumulator (stack relative indirect indexed) ($62.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc ($00.b,S),Y		; F3 00 ; Subtract with carry (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($66.b,S),Y		; F3 66 ; Subtract with carry (stack relative indirect indexed) ($66.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	inc $09.b,X		; F6 09 ; Increment memory $09.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	sbc ($95.b)		; F2 95 ; Subtract with carry (indirect) ($95.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($B8.b)		; 72 B8 ; Add with carry (indirect) ($B8.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc $B6B5.w,X		; FD B5 B6 ; Subtract with carry $B6B5.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $FE.b,X		; B4 FE ; Load Y register $FE.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	sbc $1D0065.l,X		; FF 65 00 1D ; Subtract with carry (long,X) $1D0065.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $069A.w,X		; 9E 9A 06 ; Store zero to $069A.w,X [Reads: X Index]
	sec		; 38 ; Set carry flag [Flags: C]
	adc $B8.b,X		; 75 B8 ; Add $B8.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $07B7.w,Y		; B9 B7 07 ; Load $07B7.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $0908.w,Y		; B9 08 09 ; Load $0908.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lda ($61.b,S),Y		; B3 61 ; Load accumulator (stack relative indirect indexed) ($61.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc ($A9.b,X)		; 61 A9 ; Add with carry ($A9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	adc $0C.b,X		; 75 0C ; Add $0C.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $0E71.w		; 0D 71 0E ; Logical OR $0E71.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ldy $E548.w,X		; BC 48 E5 ; Load Y register $E548.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	adc $0F.b,S		; 63 0F ; Add with carry (stack relative) $0F.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	cop $4F.b		; 02 4F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	adc $62.b,X		; 75 62 ; Add $62.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($00.b,S),Y		; 13 00 ; OR accumulator (stack relative indirect indexed) ($00.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $1662.w,Y		; 79 62 16 ; Add $1662.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy #$1964.w		; C0 64 19 ; Compare #$1964.w with Y register [Reads: Y Index] [Flags: NCZ]
	cop $4C.b		; 02 4C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $95.b,X		; 75 95 ; Add $95.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $1E.b,S		; 63 1E ; Add with carry (stack relative) $1E.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $7F53.w,X		; 3C 53 7F ; Test bits $7F53.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	jsl $E5502F.l		; 22 2F 50 E5 ; Jump to subroutine long $E5502F.l [Writes: Stack Pointer] [Flow: call]
	cmp [$E5.b],Y		; D7 E5 ; Compare accumulator (long indexed) [$E5.b],Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	adc $3E.b,X		; 75 3E ; Add $3E.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $23.b,S		; 63 23 ; Add with carry (stack relative) $23.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	jsl $27017E.l		; 22 7E 01 27 ; Jump to subroutine long $27017E.l [Writes: Stack Pointer] [Flow: call]
	ldy $2862.w		; AC 62 28 ; Load $2862.w into Y register [Writes: Y Index] [Flags: NZ]
	ora [$7E.b]		; 07 7E ; OR accumulator with memory (long) [$7E.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	jmp $2D002C.l		; 5C 2C 00 2D ; Jump long to $2D002C.l [Flow: jump]
	rol $2202.w		; 2E 02 22 ; Rotate left $2202.w [Flags: NCZ]
	.db $80, $E0		; 80 E0 ; Branch always to $80, $E0 [Flow: branch]
	and [$03.b],Y		; 37 03 ; AND accumulator with memory (long indexed) [$03.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	inc $2F2B.w,X		; FE 2B 2F ; Increment memory $2F2B.w,X [Reads: X Index] [Flags: NZ]
	cop $80.b		; 02 80 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $30.b,S		; 63 30 ; Add with carry (stack relative) $30.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	and ($32.b),Y		; 31 32 ; AND accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$F368.w		; C9 68 F3 ; Compare #$F368.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and [$0E.b],Y		; 37 0E ; AND accumulator with memory (long indexed) [$0E.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,S		; 03 9C ; OR accumulator with stack relative $9C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($8B.b,S),Y		; 33 8B ; AND accumulator (stack relative indirect indexed) ($8B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	eor ($CC.b)		; 52 CC ; Exclusive OR accumulator with memory (indirect) ($CC.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $FBFB.w		; 20 FB FB ; Jump to subroutine at $FBFB.w [Writes: Stack Pointer] [Flow: call]
	sta $8034.w,X		; 9D 34 80 ; Store accumulator to $8034.w,X [Reads: Accumulator, X Index]
	eor ($35.b),Y		; 51 35 ; Exclusive OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $1A		; 80 1A ; Branch always to $80, $1A [Flow: branch]
	ora $51A4A3.l,X		; 1F A3 A4 51 ; Logical OR long $51A4A3.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($CC.b,S),Y		; 73 CC ; Add with carry (stack relative indirect indexed) ($CC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	asl $36.b,X		; 16 36 ; Arithmetic shift left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $37.b,X		; 36 37 ; Rotate left $37.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $80, $A8		; 80 A8 ; Branch always to $80, $A8 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	and $3A35.w,Y		; 39 35 3A ; AND accumulator with memory $3A35.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $E351A4.l,X		; BF A4 51 E3 ; Load long $E351A4.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($CC.b,S),Y		; 73 CC ; Add with carry (stack relative indirect indexed) ($CC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	rol $3B.b		; 26 3B ; Rotate left $3B.b [Reads: Direct Page] [Flags: NCZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	adc $7F7F3B.l,X		; 7F 3B 7F 7F ; Add long $7F7F3B.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $2E3BEE.l		; EF EE 3B 2E ; Subtract with carry (long) $2E3BEE.l [Writes: Accumulator] [Flags: NCVZ]
	bit $8B2C.w,X		; 3C 2C 8B ; Test bits $8B2C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	cop $9D.b		; 02 9D ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $2C3E.w,X		; 3D 3E 2C ; AND accumulator with memory $2C3E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	cop $3F.b		; 02 3F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	eor $021E2C.l,X		; 5F 2C 1E 02 ; Exclusive OR accumulator with memory (long,X) $021E2C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($65.b,X)		; 41 65 ; Exclusive OR accumulator with memory ($65.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $E4FF.w		; EC FF E4 ; Compare $E4FF.w with X register [Reads: X Index] [Flags: NCZ]
	eor $9FE422.l,X		; 5F 22 E4 9F ; Exclusive OR accumulator with memory (long,X) $9FE422.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$42.b]		; 27 42 ; AND accumulator with memory (long) [$42.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($43.b,X)		; 01 43 ; Logical OR ($43.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	mvp $42,$25		; 44 25 42 ; Move block positive $42,$25 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ror $45.b		; 66 45 ; Rotate right $45.b [Reads: Direct Page] [Flags: NCZ]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc $4C.b,S		; 63 4C ; Add with carry (stack relative) $4C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora $47.b,S		; 03 47 ; OR accumulator with stack relative $47.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor [$50.b]		; 47 50 ; Exclusive OR accumulator with memory (long) [$50.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $512F.w		; 4D 2F 51 ; Exclusive OR $512F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $532F52.l,X		; 3F 52 2F 53 ; AND accumulator with memory (long,X) $532F52.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cpx $9F.b		; E4 9F ; Compare $9F.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $E4FF.w,X		; 1D FF E4 ; OR accumulator with memory $E4FF.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsr $0122.w		; 20 22 01 ; Jump to subroutine at $0122.w [Writes: Stack Pointer] [Flow: call]
	ora ($12.b,S),Y		; 13 12 ; OR accumulator (stack relative indirect indexed) ($12.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and $22.b		; 25 22 ; Logical AND $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($25.b)		; 12 25 ; OR accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $261300.l		; 22 00 13 26 ; Jump to subroutine long $261300.l [Writes: Stack Pointer] [Flow: call]
	jsl $261300.l		; 22 00 13 26 ; Jump to subroutine long $261300.l [Writes: Stack Pointer] [Flow: call]
	jsl $261300.l		; 22 00 13 26 ; Jump to subroutine long $261300.l [Writes: Stack Pointer] [Flow: call]
	jsl $261300.l		; 22 00 13 26 ; Jump to subroutine long $261300.l [Writes: Stack Pointer] [Flow: call]
	jsl $261300.l		; 22 00 13 26 ; Jump to subroutine long $261300.l [Writes: Stack Pointer] [Flow: call]
	jsl $E41300.l		; 22 00 13 E4 ; Jump to subroutine long $E41300.l [Writes: Stack Pointer] [Flow: call]
	lsr $22.b		; 46 22 ; Logical shift right $22.b [Reads: Direct Page] [Flags: NCZ]
	ora ($13.b,X)		; 01 13 ; Logical OR ($13.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($25.b)		; 12 25 ; OR accumulator with memory (indirect) ($25.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $121301.l		; 22 01 13 12 ; Jump to subroutine long $121301.l [Writes: Stack Pointer] [Flow: call]
	and $22.b		; 25 22 ; Logical AND $22.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $22.b		; 26 22 ; Rotate left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $22.b		; 26 22 ; Rotate left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $22.b		; 26 22 ; Rotate left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $22.b		; 26 22 ; Rotate left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $22.b		; 26 22 ; Rotate left $22.b [Reads: Direct Page] [Flags: NCZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cpx $25.b		; E4 25 ; Compare $25.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $5467FF.l		; 22 FF 67 54 ; Jump to subroutine long $5467FF.l [Writes: Stack Pointer] [Flow: call]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	brk $64.b		; 00 64 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp $615402.l		; 5C 02 54 61 ; Jump long to $615402.l [Flow: jump]
	.db $62, $87, $00		; 62 87 00 ; Push effective relative address $62, $87, $00 [Writes: Stack Pointer]
	.db $10, $07		; 10 07 ; Branch if plus to $10, $07 [Flow: branch]
	eor $6364F2.l,X		; 5F F2 64 63 ; Exclusive OR accumulator with memory (long,X) $6364F2.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $64, $65		; 62 64 65 ; Push effective relative address $62, $64, $65 [Writes: Stack Pointer]
	eor $200087.l,X		; 5F 87 00 20 ; Exclusive OR accumulator with memory (long,X) $200087.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$66.b]		; 07 66 ; OR accumulator with memory (long) [$66.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($67.b,S),Y		; 33 67 ; AND accumulator (stack relative indirect indexed) ($67.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	eor $6A695B.l,X		; 5F 5B 69 6A ; Exclusive OR accumulator with memory (long,X) $6A695B.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	.db $30, $07		; 30 07 ; Branch if minus to $30, $07 [Flow: branch]
	adc ($F2.b,X)		; 61 F2 ; Add with carry ($F2.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	jmp ($5C62.w)		; 6C 62 5C ; Jump indirect to ($5C62.w) [Flow: jump]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	ora [$65.b]		; 07 65 ; OR accumulator with memory (long) [$65.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($6D.b,S),Y		; 33 6D ; AND accumulator (stack relative indirect indexed) ($6D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ror $5F5F.w		; 6E 5F 5F ; Rotate right $5F5F.w [Flags: NCZ]
	adc $500087.l		; 6F 87 00 50 ; Add with carry (long) $500087.l [Writes: Accumulator] [Flags: NCVZ]
	ora [$5F.b]		; 07 5F ; OR accumulator with memory (long) [$5F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $697170.l,X		; 5F 70 71 69 ; Exclusive OR accumulator with memory (long,X) $697170.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ror $6C.b		; 66 6C ; Rotate right $6C.b [Reads: Direct Page] [Flags: NCZ]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($72.b,X)		; 01 72 ; Logical OR ($72.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc #$5423.w		; 69 23 54 ; Add #$5423.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ora $61.b,S		; 03 61 ; OR accumulator with stack relative $61.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ror $6972.w		; 6E 72 69 ; Rotate right $6972.w [Flags: NCZ]
	and $54.b,S		; 23 54 ; AND accumulator with stack relative $54.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($61.b,X)		; 01 61 ; Logical OR ($61.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ror $71F0.w		; 6E F0 71 ; Rotate right $71F0.w [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $54.b,S		; 23 54 ; AND accumulator with stack relative $54.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,S		; 83 00 ; Store accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator]
	ror $23.b,X		; 76 23 ; Rotate right $23.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	mvn $61,$01		; 54 01 61 ; Move block negative $61,$01 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ror $E4FF.w		; 6E FF E4 ; Rotate right $E4FF.w [Flags: NCZ]
	sbc $E4FF22.l,X		; [PATTERN: Memory clearing operation] FF 22 FF E4 ; Subtract with carry (long,X) $E4FF22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $E4FF73.l,X		; FF 73 FF E4 ; Subtract with carry (long,X) $E4FF73.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00FF22.l,X		; FF 22 FF 00 ; Subtract with carry (long,X) $00FF22.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $64.b,X		; 74 64 ; Store zero to $64.b,X [Reads: X Index]
	stz $01.b,X		; 74 01 ; Store zero to $01.b,X [Reads: X Index]
	stz $74.b,X		; 74 74 ; Store zero to $74.b,X [Reads: X Index]
	adc $79.b,S		; 63 79 ; Add with carry (stack relative) $79.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	adc $7C.b,S		; 63 7C ; Add with carry (stack relative) $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	ora #$7474.w		; 09 74 74 ; Logical OR #$7474.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $7C		; 80 7C ; Branch always to $80, $7C [Flow: branch]
	jmp ($7481.w,X)		; 7C 81 74 ; Jump indirect indexed to ($7481.w,X) [Reads: X Index] [Flow: jump]
	stz $79.b,X		; [PATTERN: Memory clearing operation] 74 79 ; Store zero to $79.b,X [Reads: X Index]
	.db $82, $23, $7C		; 82 23 7C ; Branch always long to $82, $23, $7C [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	sta $7F.b,S		; 83 7F ; Store accumulator (stack relative) $7F.b,S [Reads: Stack Pointer, Accumulator]
	stz $84.b,X		; 74 84 ; Store zero to $84.b,X [Reads: X Index]
	sta $7C.b		; 85 7C ; Store accumulator to $7C.b [Reads: Accumulator]
	jmp ($8486.w,X)		; 7C 86 84 ; Jump indirect indexed to ($8486.w,X) [Reads: X Index] [Flow: jump]
	stz $87.b,X		; 74 87 ; Store zero to $87.b,X [Reads: X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	and $7C.b,S		; 23 7C ; AND accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	adc $89.b,S		; 63 89 ; Add with carry (stack relative) $89.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $7C.b,S		; 23 7C ; AND accumulator with stack relative $7C.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $8C.b		; 02 8C ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	.db $82, $25, $7C		; 82 25 7C ; Branch always long to $82, $25, $7C [Flow: branch]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$7C.b]		; 27 7C ; AND accumulator with memory (long) [$7C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $88.b		; 00 88 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $7C.b		; 25 7C ; Logical AND $7C.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $89.b		; 00 89 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ror $8D.b		; 66 8D ; Rotate right $8D.b [Reads: Direct Page] [Flags: NCZ]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$7C.b]		; 27 7C ; AND accumulator with memory (long) [$7C.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $94.b		; 65 94 ; Add $94.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($95.b,X)		; 01 95 ; Logical OR ($95.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $27.b,X		; 94 27 ; Store Y register $27.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	jmp ($9401.w,X)		; 7C 01 94 ; Jump indirect indexed to ($9401.w,X) [Reads: X Index] [Flow: jump]
	sty $63.b,X		; 94 63 ; Store Y register $63.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	ora ($94.b,X)		; 01 94 ; Logical OR ($94.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sty $E4.b,X		; 94 E4 ; Store Y register $E4.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	sta [$7C.b]		; 87 7C ; Store accumulator (long) [$7C.b] [Reads: Direct Page, Accumulator]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $C911A5.l,X		; FF A5 11 C9 ; Subtract with carry (long,X) $C911A5.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	.db $90, $0D		; 90 0D ; Branch if carry clear to $90, $0D [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$05C0.w		; 29 C0 05 ; Logical AND #$05C0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pea $D029.w		; F4 29 D0 ; Push absolute address $D029.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $C2F0.w		; 4C F0 C2 ; Jump to $C2F0.w [Flow: jump]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $00879C.l		; 22 9C 87 00 ; Jump to subroutine long $00879C.l [Writes: Stack Pointer] [Flow: call]
	eor $0CC1.w,X		; 5D C1 0C ; Exclusive OR accumulator with memory $0CC1.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $C1		; 70 C1 ; Branch if overflow set to $70, $C1 [Flow: branch]
	tsb $C33C.w		; 0C 3C C3 ; Test and set bits $C33C.w [Reads: Accumulator] [Flags: Z]
	tsb $C404.w		; 0C 04 C4 ; Test and set bits $C404.w [Reads: Accumulator] [Flags: Z]
	tsb $C404.w		; 0C 04 C4 ; Test and set bits $C404.w [Reads: Accumulator] [Flags: Z]
	tsb $C25C.w		; 0C 5C C2 ; Test and set bits $C25C.w [Reads: Accumulator] [Flags: Z]
	tsb $C2AE.w		; 0C AE C2 ; Test and set bits $C2AE.w [Reads: Accumulator] [Flags: Z]
	tsb $C284.w		; 0C 84 C2 ; Test and set bits $C284.w [Reads: Accumulator] [Flags: Z]
	tsb $C2D4.w		; 0C D4 C2 ; Test and set bits $C2D4.w [Reads: Accumulator] [Flags: Z]
	tsb $C404.w		; 0C 04 C4 ; Test and set bits $C404.w [Reads: Accumulator] [Flags: Z]
	tsb $C33C.w		; 0C 3C C3 ; Test and set bits $C33C.w [Reads: Accumulator] [Flags: Z]
	tsb $C404.w		; 0C 04 C4 ; Test and set bits $C404.w [Reads: Accumulator] [Flags: Z]
	tsb $0022.w		; 0C 22 00 ; Test and set bits $0022.w [Reads: Accumulator] [Flags: Z]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	lda #$850F.w		; A9 0F 85 ; Load #$850F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($64.b,S),Y		; 13 64 ; OR accumulator (stack relative indirect indexed) ($64.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $E6		; B0 E6 ; Branch if carry set to $B0, $E6 [Flow: branch]
	ora $E6.b,X		; 15 E6 ; OR accumulator with memory $E6.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($A9.b),Y		; 11 A9 ; OR accumulator with memory ($A9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	jsr $ED82.w		; 20 82 ED ; Jump to subroutine at $ED82.w [Writes: Stack Pointer] [Flow: call]
	lda $B0.b		; A5 B0 ; Load $B0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	inc $B0.b		; E6 B0 ; Increment $B0.b [Reads: Direct Page] [Flags: NZ]
	cmp #$B00B.w		; C9 0B B0 ; Compare #$B00B.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	jsl $00879C.l		; 22 9C 87 00 ; Jump to subroutine long $00879C.l [Writes: Stack Pointer] [Flow: call]
	ldy #$0CC1.w		; A0 C1 0C ; Load #$0CC1.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$0CC1.w		; A0 C1 0C ; Load #$0CC1.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$0CC1.w		; A0 C1 0C ; Load #$0CC1.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$0CC1.w		; A0 C1 0C ; Load #$0CC1.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$0CC1.w		; A0 C1 0C ; Load #$0CC1.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$0CC1.w		; A0 C1 0C ; Load #$0CC1.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$0CC1.w		; A0 C1 0C ; Load #$0CC1.w into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$0CC1.w		; A0 C1 0C ; Load #$0CC1.w into Y register [Writes: Y Index] [Flags: NZ]
	asl $81.b,X		; 16 81 ; Arithmetic shift left $81.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	cop $31.b		; 02 31 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp ($00.b)		; D2 00 ; Compare accumulator (indirect) ($00.b) [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and $D4.b,S		; 23 D4 ; AND accumulator with stack relative $D4.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $A6		; 30 A6 ; Branch if minus to $30, $A6 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda #$0000.w		; A9 00 00 ; Load #$0000.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7E2000.l,X		; 9F 00 20 7E ; Store accumulator (long,X) $7E2000.l,X [Reads: Accumulator, X Index]
	sta $7E4000.l,X		; 9F 00 40 7E ; Store accumulator (long,X) $7E4000.l,X [Reads: Accumulator, X Index]
	sta $7E6000.l,X		; 9F 00 60 7E ; Store accumulator (long,X) $7E6000.l,X [Reads: Accumulator, X Index]
	sta $7E8000.l,X		; 9F 00 80 7E ; Store accumulator (long,X) $7E8000.l,X [Reads: Accumulator, X Index]
	sta $7EA000.l,X		; 9F 00 A0 7E ; Store accumulator (long,X) $7EA000.l,X [Reads: Accumulator, X Index]
	sta $7EC000.l,X		; 9F 00 C0 7E ; Store accumulator (long,X) $7EC000.l,X [Reads: Accumulator, X Index]
	sta $7EE000.l,X		; 9F 00 E0 7E ; Store accumulator (long,X) $7EE000.l,X [Reads: Accumulator, X Index]
	sta $7F0000.l,X		; 9F 00 00 7F ; Store accumulator (long,X) $7F0000.l,X [Reads: Accumulator, X Index]
	sta $7F2000.l,X		; 9F 00 20 7F ; Store accumulator (long,X) $7F2000.l,X [Reads: Accumulator, X Index]
	sta $7F4000.l,X		; 9F 00 40 7F ; Store accumulator (long,X) $7F4000.l,X [Reads: Accumulator, X Index]
	sta $7F6000.l,X		; 9F 00 60 7F ; Store accumulator (long,X) $7F6000.l,X [Reads: Accumulator, X Index]
	sta $7F8000.l,X		; 9F 00 80 7F ; Store accumulator (long,X) $7F8000.l,X [Reads: Accumulator, X Index]
	sta $7FA000.l,X		; 9F 00 A0 7F ; Store accumulator (long,X) $7FA000.l,X [Reads: Accumulator, X Index]
	sta $7FC000.l,X		; 9F 00 C0 7F ; Store accumulator (long,X) $7FC000.l,X [Reads: Accumulator, X Index]
	sta $7FE000.l,X		; 9F 00 E0 7F ; Store accumulator (long,X) $7FE000.l,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx $CA.b		; E4 CA ; Compare $CA.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $D0, $BE		; D0 BE ; Branch if not equal to $D0, $BE [Flow: branch]
	stx $C8.b		; 86 C8 ; Store X register to $C8.b [Reads: X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0400.w		; E9 00 04 ; Subtract #$0400.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $CA.b		; 85 CA ; Store accumulator to $CA.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $13.b		; C6 13 ; Decrement $13.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $62		; D0 62 ; Branch if not equal to $D0, $62 [Flow: branch]
	jsl $00893D.l		; 22 3D 89 00 ; Jump to subroutine long $00893D.l [Writes: Stack Pointer] [Flow: call]
	jsl $00834B.l		; 22 4B 83 00 ; Jump to subroutine long $00834B.l [Writes: Stack Pointer] [Flow: call]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta OBJSEL.w		; 8D 01 21 ; Store accumulator to OBJSEL.w [Reads: Accumulator]
	lda #$23.b		; A9 23 ; Load #$23.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA1.w		; 8D A1 0A ; Store accumulator to $0AA1.w [Reads: Accumulator]
	lda #$7D.b		; A9 7D ; Load #$7D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA3.w		; 8D A3 0A ; Store accumulator to $0AA3.w [Reads: Accumulator]
	lda #$51.b		; A9 51 ; Load #$51.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA2.w		; 8D A2 0A ; Store accumulator to $0AA2.w [Reads: Accumulator]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA4.w		; 8D A4 0A ; Store accumulator to $0AA4.w [Reads: Accumulator]
	jsl $00E2D0.l		; 22 D0 E2 00 ; Jump to subroutine long $00E2D0.l [Writes: Stack Pointer] [Flow: call]
	jsl $00E19B.l		; 22 9B E1 00 ; Jump to subroutine long $00E19B.l [Writes: Stack Pointer] [Flow: call]
	ldy #$5D.b		; A0 5D ; Load #$5D.b into Y register [Writes: Y Index] [Flags: NZ]
	jsl $00D337.l		; 22 37 D3 00 ; Jump to subroutine long $00D337.l [Writes: Stack Pointer] [Flow: call]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC00D.l		; [PATTERN: Memory clearing operation] 8F 0D C0 7E ; Store accumulator (long) $7EC00D.l [Reads: Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC00E.l		; 8F 0E C0 7E ; Store accumulator (long) $7EC00E.l [Reads: Accumulator]
	stz $8A.b		; 64 8A ; Store zero to $8A.b
	stz $0AB6.w		; 9C B6 0A ; Store zero to $0AB6.w
	stz $0AB8.w		; [PATTERN: Memory clearing operation] 9C B8 0A ; Store zero to $0AB8.w
	stz $C8.b		; 64 C8 ; Store zero to $C8.b
	stz $C9.b		; 64 C9 ; Store zero to $C9.b
	stz $CA.b		; 64 CA ; Store zero to $CA.b
	stz $CB.b		; 64 CB ; Store zero to $CB.b
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC009.l		; 8F 09 C0 7E ; Store accumulator (long) $7EC009.l [Reads: Accumulator]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC007.l		; 8F 07 C0 7E ; Store accumulator (long) $7EC007.l [Reads: Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC00B.l		; 8F 0B C0 7E ; Store accumulator (long) $7EC00B.l [Reads: Accumulator]
	stz $0AA6.w		; 9C A6 0A ; Store zero to $0AA6.w
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0CC404.l		; 22 04 C4 0C ; Jump to subroutine long $0CC404.l [Writes: Stack Pointer] [Flow: call]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $90, $13		; 90 13 ; Branch if carry clear to $90, $13 [Flow: branch]
	jsl $00ED7C.l		; 22 7C ED 00 ; Jump to subroutine long $00ED7C.l [Writes: Stack Pointer] [Flow: call]
	lda $7EC007.l		; AF 07 C0 7E ; Load long $7EC007.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda #$2A.b		; A9 2A ; Load #$2A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $B0.b		; 85 B0 ; Store accumulator to $B0.b [Reads: Accumulator]
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	jsr $FE45.w		; 20 45 FE ; Jump to subroutine at $FE45.w [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cmp #$0D.b		; C9 0D ; Compare #$0D.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$15.b		; A9 15 ; Load #$15.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1C.b		; 85 1C ; Store accumulator to $1C.b [Reads: Accumulator]
	stz $1D.b		; 64 1D ; Store zero to $1D.b
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $FE56.w		; 20 56 FE ; Jump to subroutine at $FE56.w [Writes: Stack Pointer] [Flow: call]
	jsl $0CC404.l		; 22 04 C4 0C ; Jump to subroutine long $0CC404.l [Writes: Stack Pointer] [Flow: call]
	lda $7EC007.l		; AF 07 C0 7E ; Load long $7EC007.l into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	.db $90, $17		; 90 17 ; Branch if carry clear to $90, $17 [Flow: branch]
	jmp $00ED8F.l		; 5C 8F ED 00 ; Jump long to $00ED8F.l [Flow: jump]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$C0.b		; 29 C0 ; Logical AND #$C0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F4.b		; 05 F4 ; Logical OR $F4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$D0.b		; 29 D0 ; Logical AND #$D0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $C2F0.w		; 4C F0 C2 ; Jump to $C2F0.w [Flow: jump]
	dec $B0.b		; C6 B0 ; Decrement $B0.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	inc $11.b		; [PATTERN: Memory clearing operation] E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0CC404.l		; 22 04 C4 0C ; Jump to subroutine long $0CC404.l [Writes: Stack Pointer] [Flow: call]
	stz $1F00.w		; 9C 00 1F ; Store zero to $1F00.w
	stz $012A.w		; 9C 2A 01 ; Store zero to $012A.w
	jsr $FE56.w		; 20 56 FE ; Jump to subroutine at $FE56.w [Writes: Stack Pointer] [Flow: call]
	dec $B0.b		; C6 B0 ; Decrement $B0.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $14		; D0 14 ; Branch if not equal to $D0, $14 [Flow: branch]
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $99.b		; 85 99 ; Store accumulator to $99.b [Reads: Accumulator]
	lda #$22.b		; A9 22 ; Load #$22.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9A.b		; 85 9A ; Store accumulator to $9A.b [Reads: Accumulator]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC007.l		; 8F 07 C0 7E ; Store accumulator (long) $7EC007.l [Reads: Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1D.b		; [PATTERN: Memory clearing operation] 85 1D ; Store accumulator to $1D.b [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $0CC404.l		; 22 04 C4 0C ; Jump to subroutine long $0CC404.l [Writes: Stack Pointer] [Flow: call]
	stz $1F00.w		; 9C 00 1F ; Store zero to $1F00.w
	stz $012A.w		; 9C 2A 01 ; Store zero to $012A.w
	jsr $FE56.w		; 20 56 FE ; Jump to subroutine at $FE56.w [Writes: Stack Pointer] [Flow: call]
	dec $B0.b		; C6 B0 ; Decrement $B0.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	inc $11.b		; [PATTERN: Memory clearing operation] E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $10.b		; 85 10 ; Store accumulator to $10.b [Reads: Accumulator]
	stz $11.b		; 64 11 ; Store zero to $11.b
	stz $22.b		; 64 22 ; Store zero to $22.b
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0128.w		; [PATTERN: Memory clearing operation] 8D 28 01 ; Store accumulator to $0128.w [Reads: Accumulator]
	lda #$15.b		; A9 15 ; Load #$15.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1C.b		; 85 1C ; Store accumulator to $1C.b [Reads: Accumulator]
	stz $1D.b		; 64 1D ; Store zero to $1D.b
	stz $1B.b		; 64 1B ; Store zero to $1B.b
	lda #$F1.b		; A9 F1 ; Load #$F1.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	jsl $0ED60B.l		; 22 0B D6 0E ; Jump to subroutine long $0ED60B.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	ldx #$006E.w		; A2 6E 00 ; Load #$006E.w into X register [Writes: X Index] [Flags: NZ]
	stz $20.b,X		; 74 20 ; Store zero to $20.b,X [Reads: X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $FA		; 10 FA ; Branch if plus to $10, $FA [Flow: branch]
	ldx #$0000.w		; A2 00 00 ; Load #$0000.w into X register [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $7EF000.l,X		; 9F 00 F0 7E ; Store accumulator (long,X) $7EF000.l,X [Reads: Accumulator, X Index]
	sta $7EF100.l,X		; 9F 00 F1 7E ; Store accumulator (long,X) $7EF100.l,X [Reads: Accumulator, X Index]
	sta $7EF200.l,X		; 9F 00 F2 7E ; Store accumulator (long,X) $7EF200.l,X [Reads: Accumulator, X Index]
	sta $7EF300.l,X		; 9F 00 F3 7E ; Store accumulator (long,X) $7EF300.l,X [Reads: Accumulator, X Index]
	sta $7EF400.l,X		; 9F 00 F4 7E ; Store accumulator (long,X) $7EF400.l,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$0100.w		; E0 00 01 ; Compare #$0100.w with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $E5		; D0 E5 ; Branch if not equal to $D0, $E5 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $10.b		; 85 10 ; Store accumulator to $10.b [Reads: Accumulator]
	sta $04AA.w		; 8D AA 04 ; Store accumulator to $04AA.w [Reads: Accumulator]
	stz $11.b		; 64 11 ; Store zero to $11.b
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA4.w		; 8D A4 0A ; Store accumulator to $0AA4.w [Reads: Accumulator]
	jsl $00E384.l		; 22 84 E3 00 ; Jump to subroutine long $00E384.l [Writes: Stack Pointer] [Flow: call]
	jsr $C36F.w		; 20 6F C3 ; Jump to subroutine at $C36F.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E10.w		; 8D 10 1E ; Store accumulator to $1E10.w [Reads: Accumulator]
	sta $1E11.w		; 8D 11 1E ; Store accumulator to $1E11.w [Reads: Accumulator]
	sta $1E12.w		; 8D 12 1E ; Store accumulator to $1E12.w [Reads: Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E18.w		; 8D 18 1E ; Store accumulator to $1E18.w [Reads: Accumulator]
	sta $1E19.w		; 8D 19 1E ; Store accumulator to $1E19.w [Reads: Accumulator]
	sta $1E1A.w		; 8D 1A 1E ; Store accumulator to $1E1A.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E14.w		; 8D 14 1E ; Store accumulator to $1E14.w [Reads: Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E1C.w		; 8D 1C 1E ; Store accumulator to $1E1C.w [Reads: Accumulator]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $13.b		; 85 13 ; Store accumulator to $13.b [Reads: Accumulator]
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $09F7DE.l		; 22 DE F7 09 ; Jump to subroutine long $09F7DE.l [Writes: Stack Pointer] [Flow: call]
	jsr $C3BD.w		; 20 BD C3 ; Jump to subroutine at $C3BD.w [Writes: Stack Pointer] [Flow: call]
	lda #$90.b		; A9 90 ; Load #$90.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $FF.b		; 85 FF ; Store accumulator to $FF.b [Reads: Accumulator]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F02.w		; 8D 02 1F ; Store accumulator to $1F02.w [Reads: Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F06.w		; 8D 06 1F ; Store accumulator to $1F06.w [Reads: Accumulator]
	sta $1F07.w		; 8D 07 1F ; Store accumulator to $1F07.w [Reads: Accumulator]
	sta $1F08.w		; 8D 08 1F ; Store accumulator to $1F08.w [Reads: Accumulator]
	lda #$A0.b		; A9 A0 ; Load #$A0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F04.w		; 8D 04 1F ; Store accumulator to $1F04.w [Reads: Accumulator]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F05.w		; 8D 05 1F ; Store accumulator to $1F05.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F01.w		; 8D 01 1F ; Store accumulator to $1F01.w [Reads: Accumulator]
	sta $1F03.w		; 8D 03 1F ; Store accumulator to $1F03.w [Reads: Accumulator]
	sta $012A.w		; [PATTERN: Memory clearing operation] 8D 2A 01 ; Store accumulator to $012A.w [Reads: Accumulator]
	sta $1F00.w		; 8D 00 1F ; Store accumulator to $1F00.w [Reads: Accumulator]
	ldx #$0F.b		; A2 0F ; Load #$0F.b into X register [Writes: X Index] [Flags: NZ]
	stz $1E00.w,X		; 9E 00 1E ; Store zero to $1E00.w,X [Reads: X Index]
	stz $1E10.w,X		; 9E 10 1E ; Store zero to $1E10.w,X [Reads: X Index]
	stz $1E20.w,X		; [PATTERN: Memory clearing operation] 9E 20 1E ; Store zero to $1E20.w,X [Reads: X Index]
	stz $1E30.w,X		; 9E 30 1E ; Store zero to $1E30.w,X [Reads: X Index]
	stz $1E40.w,X		; 9E 40 1E ; Store zero to $1E40.w,X [Reads: X Index]
	stz $1E50.w,X		; 9E 50 1E ; Store zero to $1E50.w,X [Reads: X Index]
	stz $1E60.w,X		; 9E 60 1E ; Store zero to $1E60.w,X [Reads: X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $E8		; 10 E8 ; Branch if plus to $10, $E8 [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 16
	rep #$20		; C2 20
	lda $0CC425.l		; AF 25 C4 0C ; Load long $0CC425.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6A0.l		; 8F A0 C6 7E ; Store accumulator (long) $7EC6A0.l [Reads: Accumulator]
	lda $0CC427.l		; AF 27 C4 0C ; Load long $0CC427.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6A2.l		; 8F A2 C6 7E ; Store accumulator (long) $7EC6A2.l [Reads: Accumulator]
	lda $0CC429.l		; AF 29 C4 0C ; Load long $0CC429.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6A4.l		; 8F A4 C6 7E ; Store accumulator (long) $7EC6A4.l [Reads: Accumulator]
	lda $0CC42B.l		; AF 2B C4 0C ; Load long $0CC42B.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6A6.l		; 8F A6 C6 7E ; Store accumulator (long) $7EC6A6.l [Reads: Accumulator]
	lda $0CC42D.l		; AF 2D C4 0C ; Load long $0CC42D.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6A8.l		; 8F A8 C6 7E ; Store accumulator (long) $7EC6A8.l [Reads: Accumulator]
	lda $0CC42F.l		; AF 2F C4 0C ; Load long $0CC42F.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6AA.l		; 8F AA C6 7E ; Store accumulator (long) $7EC6AA.l [Reads: Accumulator]
	lda $0CC431.l		; AF 31 C4 0C ; Load long $0CC431.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6AC.l		; 8F AC C6 7E ; Store accumulator (long) $7EC6AC.l [Reads: Accumulator]
	lda $0CC433.l		; AF 33 C4 0C ; Load long $0CC433.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6AE.l		; 8F AE C6 7E ; Store accumulator (long) $7EC6AE.l [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	inc $15.b		; E6 15 ; Increment $15.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	inc $1E0A.w		; EE 0A 1E ; Increment $1E0A.w [Flags: NZ]
	jsr $C435.w		; 20 35 C4 ; Jump to subroutine at $C435.w [Writes: Stack Pointer] [Flow: call]
	jsr $C412.w		; 20 12 C4 ; Jump to subroutine at $C412.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E08.w		; 8D 08 1E ; Store accumulator to $1E08.w [Reads: Accumulator]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E09.w		; 8D 09 1E ; Store accumulator to $1E09.w [Reads: Accumulator]
	ldx #$07.b		; A2 07 ; Load #$07.b into X register [Writes: X Index] [Flags: NZ]
	jsr $C534.w		; 20 34 C5 ; Jump to subroutine at $C534.w [Writes: Stack Pointer] [Flow: call]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $FA		; 10 FA ; Branch if plus to $10, $FA [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $B001.w		; 4D 01 B0 ; Exclusive OR $B001.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($F3.b,X)		; 01 F3 ; Logical OR ($F3.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($56.b,X)		; 01 56 ; Logical OR ($56.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $79.b		; 02 79 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $FD.b		; 02 FD ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $5F.b		; 02 5F ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $A9.b,S		; 03 A9 ; OR accumulator with stack relative $A9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($8D.b,X)		; 01 8D ; Logical OR ($8D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora ($AD.b,X)		; 01 AD ; Logical OR ($AD.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	jsr $C448.w		; 20 48 C4 ; Jump to subroutine at $C448.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F00.w		; 8D 00 1F ; Store accumulator to $1F00.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1E00.w		; AD 00 1E ; Load $1E00.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	cpy $7B.b		; C4 7B ; Compare $7B.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $BA.b		; C4 BA ; Compare $BA.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $D6.b		; C4 D6 ; Compare $D6.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	cmp $33.b		; C5 33 ; Compare $33.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	cmp $EE.b		; C5 EE ; Compare $EE.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	ora ($1E.b,X)		; 01 1E ; Logical OR ($1E.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $1E01.w		; AD 01 1E ; Load $1E01.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	inc $1E00.w		; EE 00 1E ; Increment $1E00.w [Flags: NZ]
	lda $1F05.w		; AD 05 1F ; Load $1F05.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$05.b		; 69 05 ; Add #$05.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F05.w		; 8D 05 1F ; Store accumulator to $1F05.w [Reads: Accumulator]
	lda $1F04.w		; AD 04 1F ; Load $1F04.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F04.w		; 8D 04 1F ; Store accumulator to $1F04.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1F02.w		; AD 02 1F ; Load $1F02.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0C		; B0 0C ; Branch if carry set to $B0, $0C [Flow: branch]
	stz $1F02.w		; 9C 02 1F ; Store zero to $1F02.w
	inc $1E00.w		; EE 00 1E ; Increment $1E00.w [Flags: NZ]
	lda #$40.b		; A9 40 ; Load #$40.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E01.w		; 8D 01 1E ; Store accumulator to $1E01.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $1F02.w		; 8D 02 1F ; Store accumulator to $1F02.w [Reads: Accumulator]
	lda $1F05.w		; AD 05 1F ; Load $1F05.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$05.b		; 69 05 ; Add #$05.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F05.w		; 8D 05 1F ; Store accumulator to $1F05.w [Reads: Accumulator]
	lda $1F04.w		; AD 04 1F ; Load $1F04.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F04.w		; 8D 04 1F ; Store accumulator to $1F04.w [Reads: Accumulator]
	lda $1F02.w		; AD 02 1F ; Load $1F02.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$E1.b		; C9 E1 ; Compare #$E1.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $04		; B0 04 ; Branch if carry set to $B0, $04 [Flow: branch]
	ldx #$04.b		; A2 04 ; Load #$04.b into X register [Writes: X Index] [Flags: NZ]
	stx $11.b		; 86 11 ; Store X register to $11.b [Reads: X Index]
	cmp #$71.b		; C9 71 ; Compare #$71.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $1E01.w		; CE 01 1E ; Decrement $1E01.w [Flags: NZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	inc $1E00.w		; EE 00 1E ; Increment $1E00.w [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1F05.w		; AD 05 1F ; Load $1F05.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$05.b		; 69 05 ; Add #$05.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F05.w		; 8D 05 1F ; Store accumulator to $1F05.w [Reads: Accumulator]
	lda $1F04.w		; AD 04 1F ; Load $1F04.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F04.w		; 8D 04 1F ; Store accumulator to $1F04.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1F05.w		; AD 05 1F ; Load $1F05.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$FA.b		; C9 FA ; Compare #$FA.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $10		; 90 10 ; Branch if carry clear to $90, $10 [Flow: branch]
	lda $1F04.w		; AD 04 1F ; Load $1F04.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$FC.b		; C9 FC ; Compare #$FC.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $09		; 90 09 ; Branch if carry clear to $90, $09 [Flow: branch]
	inc $1E00.w		; EE 00 1E ; Increment $1E00.w [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E01.w		; 8D 01 1E ; Store accumulator to $1E01.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1F05.w		; AD 05 1F ; Load $1F05.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$05.b		; 69 05 ; Add #$05.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F05.w		; 8D 05 1F ; Store accumulator to $1F05.w [Reads: Accumulator]
	lda $1F04.w		; AD 04 1F ; Load $1F04.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$03.b		; [PATTERN: Memory clearing operation] 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F04.w		; 8D 04 1F ; Store accumulator to $1F04.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $1F05.w		; 9C 05 1F ; Store zero to $1F05.w
	stz $1F04.w		; 9C 04 1F ; Store zero to $1F04.w
	dec $1E01.w		; CE 01 1E ; Decrement $1E01.w [Flags: NZ]
	.db $D0, $27		; D0 27 ; Branch if not equal to $D0, $27 [Flow: branch]
	inc $1E00.w		; EE 00 1E ; Increment $1E00.w [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E15.w		; 8D 15 1E ; Store accumulator to $1E15.w [Reads: Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E1D.w		; 8D 1D 1E ; Store accumulator to $1E1D.w [Reads: Accumulator]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1C.b		; 85 1C ; Store accumulator to $1C.b [Reads: Accumulator]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1D.b		; 85 1D ; Store accumulator to $1D.b [Reads: Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $99.b		; 85 99 ; Store accumulator to $99.b [Reads: Accumulator]
	lda #$31.b		; A9 31 ; Load #$31.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9A.b		; 85 9A ; Store accumulator to $9A.b [Reads: Accumulator]
	stz $B0.b		; 64 B0 ; Store zero to $B0.b
	inc $15.b		; E6 15 ; Increment $15.b [Reads: Direct Page] [Flags: NZ]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $14.b		; 85 14 ; Store accumulator to $14.b [Reads: Accumulator]
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1E10.w,X		; BD 10 1E ; Load $1E10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	eor $C5.b,S		; 43 C5 ; Exclusive OR accumulator with stack relative $C5.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $5B,$C5		; 44 C5 5B ; Move block positive $5B,$C5 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	cmp $60.b		; C5 60 ; Compare $60.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	lda $1E18.w,X		; BD 18 1E ; Load $1E18.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	ror $4FC5.w,X		; 7E C5 4F ; Rotate right $4FC5.w,X [Reads: X Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $50, $C8		; 50 C8 ; Branch if overflow clear to $50, $C8 [Flow: branch]
	sep #$C8		; E2 C8 ; Set processor status bits #$C8 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	ora $BDCD.w,Y		; 19 CD BD ; OR accumulator with memory $BDCD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $8122.w,X		; 1E 22 81 ; Arithmetic shift left $8122.w,X [Reads: X Index] [Flags: NCZ]
	sta [$00.b]		; 87 00 ; Store accumulator (long) [$00.b] [Reads: Direct Page, Accumulator]
	lda ($C5.b),Y		; B1 C5 ; Load accumulator ($C5.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $C864C8.l		; 4F C8 64 C8 ; Exclusive OR accumulator with memory (long) $C864C8.l [Writes: Accumulator] [Flags: NZ]
	ora $13C9.w		; 0D C9 13 ; Logical OR $13C9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy $CC13.w		; CC 13 CC ; Compare $CC13.w with Y register [Reads: Y Index] [Flags: NCZ]
	ora ($CC.b,S),Y		; 13 CC ; OR accumulator (stack relative indirect indexed) ($CC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rol $DACD.w,X		; 3E CD DA ; Rotate left $DACD.w,X [Reads: X Index] [Flags: NCZ]
	sbc $E6005F.l,X		; FF 5F 00 E6 ; Subtract with carry (long,X) $E6005F.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $C8.b		; 00 C8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BD.b		; 00 BD ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $8A00C8.l,X		; FF C8 00 8A ; Subtract with carry (long,X) $8A00C8.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C572.w,Y		; B9 72 C5 ; Load $C572.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E30.w,X		; 9D 30 1E ; Store accumulator to $1E30.w,X [Reads: Accumulator, X Index]
	lda $C573.w,Y		; B9 73 C5 ; Load $C573.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E38.w,X		; 9D 38 1E ; Store accumulator to $1E38.w,X [Reads: Accumulator, X Index]
	lda $C578.w,Y		; B9 78 C5 ; Load $C578.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E48.w,X		; 9D 48 1E ; Store accumulator to $1E48.w,X [Reads: Accumulator, X Index]
	lda $C579.w,Y		; B9 79 C5 ; Load $C579.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E50.w,X		; 9D 50 1E ; Store accumulator to $1E50.w,X [Reads: Accumulator, X Index]
	lda $C5CA.w,X		; BD CA C5 ; Load $C5CA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E58.w,X		; 7D 58 1E ; Add $1E58.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E58.w,X		; 9D 58 1E ; Store accumulator to $1E58.w,X [Reads: Accumulator, X Index]
	lda $C5CD.w,X		; BD CD C5 ; Load $C5CD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E60.w,X		; 7D 60 1E ; Add $1E60.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E60.w,X		; 9D 60 1E ; Store accumulator to $1E60.w,X [Reads: Accumulator, X Index]
	inc $1E10.w,X		; FE 10 1E ; Increment memory $1E10.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C70F.w		; 20 0F C7 ; Jump to subroutine at $C70F.w [Writes: Stack Pointer] [Flow: call]
	jsr $C9F1.w		; 20 F1 C9 ; Jump to subroutine at $C9F1.w [Writes: Stack Pointer] [Flow: call]
	lda $1E00.w		; AD 00 1E ; Load $1E00.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	dec $C5.b,X		; D6 C5 ; Decrement memory $C5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	dec $C5.b,X		; D6 C5 ; Decrement memory $C5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	dec $C5.b,X		; D6 C5 ; Decrement memory $C5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	dec $C5.b,X		; D6 C5 ; Decrement memory $C5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	dec $C5.b,X		; D6 C5 ; Decrement memory $C5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	dec $01.b		; C6 01 ; Decrement $01.b [Reads: Direct Page] [Flags: NZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $4BFF01.l,X		; FF 01 FF 4B ; Subtract with carry (long,X) $4BFF01.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $305875.l,X		; 5F 75 58 30 ; Exclusive OR accumulator with memory (long,X) $305875.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	lda $1E0A.w		; AD 0A 1E ; Load $1E0A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$1F.b		; 29 1F ; Logical AND #$1F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $14		; D0 14 ; Branch if not equal to $D0, $14 [Flow: branch]
	lda $C5CA.w,X		; BD CA C5 ; Load $C5CA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E58.w,X		; 7D 58 1E ; Add $1E58.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E58.w,X		; 9D 58 1E ; Store accumulator to $1E58.w,X [Reads: Accumulator, X Index]
	lda $C5CD.w,X		; BD CD C5 ; Load $C5CD.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E60.w,X		; 7D 60 1E ; Add $1E60.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E60.w,X		; 9D 60 1E ; Store accumulator to $1E60.w,X [Reads: Accumulator, X Index]
	lda $C5D0.w,X		; BD D0 C5 ; Load $C5D0.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1E30.w,X		; DD 30 1E ; Compare accumulator $1E30.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $1E58.w,X		; [PATTERN: Memory clearing operation] 9E 58 1E ; Store zero to $1E58.w,X [Reads: X Index]
	lda $C5D3.w,X		; BD D3 C5 ; Load $C5D3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1E48.w,X		; DD 48 1E ; Compare accumulator $1E48.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $1E60.w,X		; 9E 60 1E ; Store zero to $1E60.w,X [Reads: X Index]
	rts		; [PATTERN: Memory clearing operation] 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $1E58.w,X		; 9E 58 1E ; Store zero to $1E58.w,X [Reads: X Index]
	stz $1E60.w,X		; 9E 60 1E ; Store zero to $1E60.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $1B		; 80 1B ; Branch always to $80, $1B [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $1B, $00		; 82 1B 00 ; Branch always long to $82, $1B, $00 [Flow: branch]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $1B.b		; 86 1B ; Store X register to $1B.b [Reads: X Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldy #$1B.b		; A0 1B ; Load #$1B.b into Y register [Writes: Y Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldx #$1B.b		; A2 1B ; Load #$1B.b into X register [Writes: X Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1000.w		; 20 00 10 ; Jump to subroutine at $1000.w [Writes: Stack Pointer] [Flow: call]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldx $1B.b		; A6 1B ; Load $1B.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8800.w		; 20 00 88 ; Jump to subroutine at $8800.w [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	jsr $8A00.w		; 20 00 8A ; Jump to subroutine at $8A00.w [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2000.w		; 20 00 20 ; Jump to subroutine at $2000.w [Writes: Stack Pointer] [Flow: call]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	jsr $8E00.w		; 20 00 8E ; Jump to subroutine at $8E00.w [Writes: Stack Pointer] [Flow: call]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3000.w		; 20 00 30 ; Jump to subroutine at $3000.w [Writes: Stack Pointer] [Flow: call]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	ldx $001B.w		; AE 1B 00 ; Load $001B.w into X register [Writes: X Index] [Flags: NZ]
	cop $30.b		; 02 30 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $5B.b		; 84 5B ; Store Y register to $5B.b [Reads: Y Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $5B.b		; 86 5B ; Store X register to $5B.b [Reads: X Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldy #$5B.b		; A0 5B ; Load #$5B.b into Y register [Writes: Y Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1000.w		; 20 00 10 ; Jump to subroutine at $1000.w [Writes: Stack Pointer] [Flow: call]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldy $5B.b		; A4 5B ; Load $5B.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldx $5B.b		; A6 5B ; Load $5B.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	jsr $8800.w		; 20 00 88 ; Jump to subroutine at $8800.w [Writes: Stack Pointer] [Flow: call]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2000.w		; 20 00 20 ; Jump to subroutine at $2000.w [Writes: Stack Pointer] [Flow: call]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	jsr $8C00.w		; 20 00 8C ; Jump to subroutine at $8C00.w [Writes: Stack Pointer] [Flow: call]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8E00.w		; 20 00 8E ; Jump to subroutine at $8E00.w [Writes: Stack Pointer] [Flow: call]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3000.w		; 20 00 30 ; Jump to subroutine at $3000.w [Writes: Stack Pointer] [Flow: call]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	ldy $005B.w		; AC 5B 00 ; Load $005B.w into Y register [Writes: Y Index] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$C6.b		; A9 C6 ; Load #$C6.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	lda #$8F.b		; A9 8F ; Load #$8F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$C6.b		; A9 C6 ; Load #$C6.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsr $C972.w		; 20 72 C9 ; Jump to subroutine at $C972.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $2B		; 80 2B ; Branch always to $80, $2B [Flow: branch]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $82, $2B, $00		; 82 2B 00 ; Branch always long to $82, $2B, $00 [Flow: branch]
	cop $20.b		; 02 20 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $2B.b		; 86 2B ; Store X register to $2B.b [Reads: X Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldy #$2B.b		; A0 2B ; Load #$2B.b into Y register [Writes: Y Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldx #$2B.b		; A2 2B ; Load #$2B.b into X register [Writes: X Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1000.w		; 20 00 10 ; Jump to subroutine at $1000.w [Writes: Stack Pointer] [Flow: call]
	brk $A4.b		; 00 A4 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldx $2B.b		; A6 2B ; Load $2B.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8800.w		; 20 00 88 ; Jump to subroutine at $8800.w [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	jsr $8A00.w		; 20 00 8A ; Jump to subroutine at $8A00.w [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2000.w		; 20 00 20 ; Jump to subroutine at $2000.w [Writes: Stack Pointer] [Flow: call]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	jsr $8E00.w		; 20 00 8E ; Jump to subroutine at $8E00.w [Writes: Stack Pointer] [Flow: call]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3000.w		; 20 00 30 ; Jump to subroutine at $3000.w [Writes: Stack Pointer] [Flow: call]
	brk $AC.b		; 00 AC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	ldx $002B.w		; AE 2B 00 ; Load $002B.w into X register [Writes: X Index] [Flags: NZ]
	cop $30.b		; 02 30 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $82.b		; 00 82 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sty $6B.b		; 84 6B ; Store Y register to $6B.b [Reads: Y Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	stx $6B.b		; 86 6B ; Store X register to $6B.b [Reads: X Index]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldy #$6B.b		; A0 6B ; Load #$6B.b into Y register [Writes: Y Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1000.w		; 20 00 10 ; Jump to subroutine at $1000.w [Writes: Stack Pointer] [Flow: call]
	brk $A2.b		; 00 A2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldy $6B.b		; A4 6B ; Load $6B.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	ldx $6B.b		; A6 6B ; Load $6B.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	jsr $8800.w		; 20 00 88 ; Jump to subroutine at $8800.w [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2000.w		; 20 00 20 ; Jump to subroutine at $2000.w [Writes: Stack Pointer] [Flow: call]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	jsr $8C00.w		; 20 00 8C ; Jump to subroutine at $8C00.w [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $8E00.w		; 20 00 8E ; Jump to subroutine at $8E00.w [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $3000.w		; 20 00 30 ; Jump to subroutine at $3000.w [Writes: Stack Pointer] [Flow: call]
	brk $AA.b		; 00 AA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	ldy $006B.w		; AC 6B 00 ; Load $006B.w into Y register [Writes: Y Index] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $AE.b		; 00 AE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda #$2F.b		; A9 2F ; Load #$2F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$C7.b		; A9 C7 ; Load #$C7.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	lda #$AF.b		; A9 AF ; Load #$AF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$C7.b		; A9 C7 ; Load #$C7.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsr $C972.w		; 20 72 C9 ; Jump to subroutine at $C972.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$4C.b		; A9 4C ; Load #$4C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E30.w,X		; [PATTERN: Memory clearing operation] 9D 30 1E ; Store accumulator to $1E30.w,X [Reads: Accumulator, X Index]
	stz $1E38.w,X		; 9E 38 1E ; Store zero to $1E38.w,X [Reads: X Index]
	lda #$B8.b		; A9 B8 ; Load #$B8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E48.w,X		; 9D 48 1E ; Store accumulator to $1E48.w,X [Reads: Accumulator, X Index]
	stz $1E50.w,X		; 9E 50 1E ; Store zero to $1E50.w,X [Reads: X Index]
	inc $1E10.w,X		; FE 10 1E ; Increment memory $1E10.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C8D0.w		; 20 D0 C8 ; Jump to subroutine at $C8D0.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $42, $0A		; 42 0A ; Reserved instruction
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $68.b		; 00 68 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $41.b		; 00 41 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $42.b		; 00 42 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $00		; 30 00 ; Branch if minus to $30, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor $0A.b,S		; 43 0A ; Exclusive OR accumulator with stack relative $0A.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $44.b		; 00 44 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $51.b		; 00 51 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $50, $00		; 50 00 ; Branch if overflow clear to $50, $00 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor ($0A.b)		; 52 0A ; Exclusive OR accumulator with memory (indirect) ($0A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $53.b		; 00 53 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $54.b		; 00 54 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$0D.b		; A9 0D ; Load #$0D.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	stz $07.b		; 64 07 ; Store zero to $07.b
	lda #$68.b		; A9 68 ; Load #$68.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$C8.b		; A9 C8 ; Load #$C8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsr $C972.w		; 20 72 C9 ; Jump to subroutine at $C972.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1E0A.w		; AD 0A 1E ; Load $1E0A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C8FD.w,Y		; B9 FD C8 ; Load $C8FD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E30.w,X		; 9D 30 1E ; Store accumulator to $1E30.w,X [Reads: Accumulator, X Index]
	lda $C901.w,Y		; B9 01 C9 ; Load $C901.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E48.w,X		; 9D 48 1E ; Store accumulator to $1E48.w,X [Reads: Accumulator, X Index]
	inc $1E10.w,X		; FE 10 1E ; Increment memory $1E10.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.INDEX 16
	rep #$98		; C2 98
	adc $547C34.l		; 6F 34 7C 54 ; Add with carry (long) $547C34.l [Writes: Accumulator] [Flags: NCVZ]
	jmp ($0057.w,X)		; 7C 57 00 ; Jump indirect indexed to ($0057.w,X) [Reads: X Index] [Flow: jump]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $C95620.l,X		; FF 20 56 C9 ; Subtract with carry (long,X) $C95620.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $1E0A.w		; AD 0A 1E ; Load $1E0A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C905.w,Y		; B9 05 C9 ; Load $C905.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E20.w,X		; 9D 20 1E ; Store accumulator to $1E20.w,X [Reads: Accumulator, X Index]
	lda $1E0A.w		; AD 0A 1E ; Load $1E0A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $C8FD.w,Y		; B9 FD C8 ; Load $C8FD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E30.w,X		; 9D 30 1E ; Store accumulator to $1E30.w,X [Reads: Accumulator, X Index]
	lda $C901.w,Y		; B9 01 C9 ; Load $C901.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E48.w,X		; 9D 48 1E ; Store accumulator to $1E48.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $80, $34		; 80 34 ; Branch always to $80, $34 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda [$34.b],Y		; B7 34 ; Load accumulator (long indexed) [$34.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr ($FDFF.w,X)		; FC FF FD ; Jump to subroutine indirect indexed ($FDFF.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	sbc $003864.l,X		; FF 64 38 00 ; Subtract with carry (long,X) $003864.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $FC.b		; 02 FC ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $62FFFD.l,X		; FF FD FF 62 ; Subtract with carry (long,X) $62FFFD.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $00.b,X		; 34 00 ; Test bits $00.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	cop $A9.b		; 02 A9 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($85.b,X)		; 01 85 ; Logical OR ($85.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	asl $64.b		; 06 64 ; Arithmetic shift left $64.b [Reads: Direct Page] [Flags: NCZ]
	ora [$BD.b]		; 07 BD ; OR accumulator with memory (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsr $301E.w		; 20 1E 30 ; Jump to subroutine at $301E.w [Writes: Stack Pointer] [Flow: call]
	.db $10, $0A		; 10 0A ; Branch if plus to $10, $0A [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc #$36.b		; 69 36 ; Add #$36.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda #$C9.b		; A9 C9 ; Load #$C9.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $09.b		; 85 09 ; Store accumulator to $09.b [Reads: Accumulator]
	jsr $C972.w		; 20 72 C9 ; Jump to subroutine at $C972.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1E30.w,X		; BD 30 1E ; Load $1E30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $1E38.w,X		; BD 38 1E ; Load $1E38.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	lda $1E48.w,X		; BD 48 1E ; Load $1E48.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; [PATTERN: Memory clearing operation] 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $1E50.w,X		; BD 50 1E ; Load $1E50.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $03.b		; 85 03 ; Store accumulator to $03.b [Reads: Accumulator]
	stz $04.b		; 64 04 ; Store zero to $04.b
	stz $05.b		; 64 05 ; Store zero to $05.b
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	ldy #$0000.w		; A0 00 00 ; Load #$0000.w into Y register [Writes: Y Index] [Flags: NZ]
	ldx $1E08.w		; AE 08 1E ; Load $1E08.w into X register [Writes: X Index] [Flags: NZ]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $1E08.w		; 6D 08 1E ; Add $1E08.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1E08.w		; 8D 08 1E ; Store accumulator to $1E08.w [Reads: Accumulator]
	lda ($08.b),Y		; B1 08 ; Load accumulator ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0000.w,X		; 9D 00 00 ; Store accumulator to $0000.w,X [Reads: Accumulator, X Index]
	and #$0100.w		; 29 00 01 ; Logical AND #$0100.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0C.b		; 85 0C ; Store accumulator to $0C.b [Reads: Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda ($08.b),Y		; B1 08 ; Load accumulator ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0001.w,X		; 9D 01 00 ; Store accumulator to $0001.w,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	cmp #$0100.w		; C9 00 01 ; Compare #$0100.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $06		; 90 06 ; Branch if carry clear to $90, $06 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0001.w,X		; 9D 01 00 ; Store accumulator to $0001.w,X [Reads: Accumulator, X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda ($08.b),Y		; B1 08 ; Load accumulator ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $04.b		; 45 04 ; Exclusive OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0002.w,X		; 9D 02 00 ; Store accumulator to $0002.w,X [Reads: Accumulator, X Index]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0800.w		; E9 00 08 ; Subtract #$0800.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda ($08.b),Y		; B1 08 ; Load accumulator ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $0D.b		; 05 0D ; Logical OR $0D.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0A20.w,X		; 9D 20 0A ; Store accumulator to $0A20.w,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $06.b		; C6 06 ; Decrement $06.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $B0		; D0 B0 ; Branch if not equal to $D0, $B0 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1E58.w,X		; BD 58 1E ; Load $1E58.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E28.w,X		; 7D 28 1E ; Add $1E28.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E28.w,X		; 9D 28 1E ; Store accumulator to $1E28.w,X [Reads: Accumulator, X Index]
	lda $1E58.w,X		; BD 58 1E ; Load $1E58.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	ora #$F0.b		; 09 F0 ; Logical OR #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $1E30.w,X		; 7D 30 1E ; Add $1E30.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E30.w,X		; 9D 30 1E ; Store accumulator to $1E30.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $1E38.w,X		; 7D 38 1E ; Add $1E38.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E38.w,X		; 9D 38 1E ; Store accumulator to $1E38.w,X [Reads: Accumulator, X Index]
	lda $1E60.w,X		; BD 60 1E ; Load $1E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E40.w,X		; 7D 40 1E ; Add $1E40.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E40.w,X		; 9D 40 1E ; Store accumulator to $1E40.w,X [Reads: Accumulator, X Index]
	lda $1E60.w,X		; BD 60 1E ; Load $1E60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $03		; 10 03 ; Branch if plus to $10, $03 [Flow: branch]
	ora #$F0.b		; 09 F0 ; Logical OR #$F0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc $1E48.w,X		; 7D 48 1E ; Add $1E48.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E48.w,X		; 9D 48 1E ; Store accumulator to $1E48.w,X [Reads: Accumulator, X Index]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $1E50.w,X		; 7D 50 1E ; Add $1E50.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E50.w,X		; 9D 50 1E ; Store accumulator to $1E50.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1E02.w		; AD 02 1E ; Load $1E02.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA4.w		; 8D A4 0A ; Store accumulator to $0AA4.w [Reads: Accumulator]
	jsl $00E384.l		; 22 84 E3 00 ; Jump to subroutine long $00E384.l [Writes: Stack Pointer] [Flow: call]
	jsr $C36F.w		; 20 6F C3 ; Jump to subroutine at $C36F.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E10.w		; 8D 10 1E ; Store accumulator to $1E10.w [Reads: Accumulator]
	sta $1E11.w		; 8D 11 1E ; Store accumulator to $1E11.w [Reads: Accumulator]
	sta $1E12.w		; 8D 12 1E ; Store accumulator to $1E12.w [Reads: Accumulator]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E18.w		; 8D 18 1E ; Store accumulator to $1E18.w [Reads: Accumulator]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E19.w		; 8D 19 1E ; Store accumulator to $1E19.w [Reads: Accumulator]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E1A.w		; 8D 1A 1E ; Store accumulator to $1E1A.w [Reads: Accumulator]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $13.b		; 85 13 ; Store accumulator to $13.b [Reads: Accumulator]
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA4.w		; 8D A4 0A ; Store accumulator to $0AA4.w [Reads: Accumulator]
	jsl $00E384.l		; 22 84 E3 00 ; Jump to subroutine long $00E384.l [Writes: Stack Pointer] [Flow: call]
	jsr $C36F.w		; 20 6F C3 ; Jump to subroutine at $C36F.w [Writes: Stack Pointer] [Flow: call]
	stz $1F02.w		; 9C 02 1F ; Store zero to $1F02.w
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E10.w		; 8D 10 1E ; Store accumulator to $1E10.w [Reads: Accumulator]
	sta $1E11.w		; 8D 11 1E ; Store accumulator to $1E11.w [Reads: Accumulator]
	sta $1E12.w		; 8D 12 1E ; Store accumulator to $1E12.w [Reads: Accumulator]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E18.w		; 8D 18 1E ; Store accumulator to $1E18.w [Reads: Accumulator]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E19.w		; 8D 19 1E ; Store accumulator to $1E19.w [Reads: Accumulator]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E1A.w		; 8D 1A 1E ; Store accumulator to $1E1A.w [Reads: Accumulator]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $13.b		; 85 13 ; Store accumulator to $13.b [Reads: Accumulator]
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $CABC.w		; 20 BC CA ; Jump to subroutine at $CABC.w [Writes: Stack Pointer] [Flow: call]
	jsr $C412.w		; 20 12 C4 ; Jump to subroutine at $C412.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012A.w		; 8D 2A 01 ; Store accumulator to $012A.w [Reads: Accumulator]
	sta $1E02.w		; 8D 02 1E ; Store accumulator to $1E02.w [Reads: Accumulator]
	lda $1F00.w		; AD 00 1F ; Load $1F00.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	jsr $CAD8.w		; 20 D8 CA ; Jump to subroutine at $CAD8.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F00.w		; 8D 00 1F ; Store accumulator to $1F00.w [Reads: Accumulator]
	stz $1E02.w		; 9C 02 1E ; Store zero to $1E02.w
	inc $1E0A.w		; EE 0A 1E ; Increment $1E0A.w [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1E00.w		; AD 00 1E ; Load $1E00.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	sbc #$CA.b		; E9 CA ; Subtract #$CA.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	inc $1FCA.w,X		; FE CA 1F ; Increment memory $1FCA.w,X [Reads: X Index] [Flags: NZ]
	wai		; CB ; Wait for interrupt
	sty $CB.b		; 84 CB ; Store Y register to $CB.b [Reads: Y Index]
	lda ($CB.b,X)		; A1 CB ; Load accumulator ($CB.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $1F02.w		; AD 02 1F ; Load $1F02.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$02.b		; E9 02 ; Subtract #$02.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $1F02.w		; 8D 02 1F ; Store accumulator to $1F02.w [Reads: Accumulator]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $08		; B0 08 ; Branch if carry set to $B0, $08 [Flow: branch]
	stz $1F02.w		; 9C 02 1F ; Store zero to $1F02.w
	inc $1E00.w		; EE 00 1E ; Increment $1E00.w [Flags: NZ]
	inc $B0.b		; E6 B0 ; Increment $B0.b [Reads: Direct Page] [Flags: NZ]
	lda $B0.b		; A5 B0 ; Load $B0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$0A.b		; C9 0A ; Compare #$0A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $08		; 90 08 ; Branch if carry clear to $90, $08 [Flow: branch]
	inc $1E00.w		; EE 00 1E ; Increment $1E00.w [Flags: NZ]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E61.w		; 8D 61 1E ; Store accumulator to $1E61.w [Reads: Accumulator]
	lda $1F05.w		; AD 05 1F ; Load $1F05.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$02.b		; 69 02 ; Add #$02.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F05.w		; 8D 05 1F ; Store accumulator to $1F05.w [Reads: Accumulator]
	lda $1F04.w		; AD 04 1F ; Load $1F04.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$01.b		; 69 01 ; Add #$01.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F04.w		; 8D 04 1F ; Store accumulator to $1F04.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$C0.b		; A9 C0 ; Load #$C0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E0C.w		; 8D 0C 1E ; Store accumulator to $1E0C.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E0D.w		; 8D 0D 1E ; Store accumulator to $1E0D.w [Reads: Accumulator]
	lda $1F02.w		; AD 02 1F ; Load $1F02.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $07		; B0 07 ; Branch if carry set to $B0, $07 [Flow: branch]
	adc #$01.b		; 69 01 ; Add #$01.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F02.w		; 8D 02 1F ; Store accumulator to $1F02.w [Reads: Accumulator]
	.db $80, $3A		; 80 3A ; Branch always to $80, $3A [Flow: branch]
	lda $1F05.w		; AD 05 1F ; Load $1F05.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0A.b		; E9 0A ; Subtract #$0A.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	and #$7F.b		; 29 7F ; Logical AND #$7F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$5C.b		; C9 5C ; Compare #$5C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $2E		; 90 2E ; Branch if carry clear to $90, $2E [Flow: branch]
	lda $1F04.w		; AD 04 1F ; Load $1F04.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$0B.b		; [PATTERN: Memory clearing operation] E9 0B ; Subtract #$0B.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	cmp #$DC.b		; C9 DC ; Compare #$DC.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $24		; 90 24 ; Branch if carry clear to $90, $24 [Flow: branch]
	stz $1F04.w		; 9C 04 1F ; Store zero to $1F04.w
	stz $1F05.w		; 9C 05 1F ; Store zero to $1F05.w
	inc $B0.b		; E6 B0 ; Increment $B0.b [Reads: Direct Page] [Flags: NZ]
	inc $1E00.w		; EE 00 1E ; Increment $1E00.w [Flags: NZ]
	lda #$2C.b		; A9 2C ; Load #$2C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6AE.l		; 8F AE C6 7E ; Store accumulator (long) $7EC6AE.l [Reads: Accumulator]
	lda #$7F.b		; A9 7F ; Load #$7F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6AF.l		; 8F AF C6 7E ; Store accumulator (long) $7EC6AF.l [Reads: Accumulator]
	inc $15.b		; E6 15 ; Increment $15.b [Reads: Direct Page] [Flags: NZ]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E01.w		; 8D 01 1E ; Store accumulator to $1E01.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1F05.w		; AD 05 1F ; Load $1F05.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$05.b		; 69 05 ; Add #$05.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F05.w		; 8D 05 1F ; Store accumulator to $1F05.w [Reads: Accumulator]
	lda $1F04.w		; AD 04 1F ; Load $1F04.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F04.w		; 8D 04 1F ; Store accumulator to $1F04.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $1E01.w		; CE 01 1E ; Decrement $1E01.w [Flags: NZ]
	lda $1E01.w		; AD 01 1E ; Load $1E01.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	lda $0CC433.l		; AF 33 C4 0C ; Load long $0CC433.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6AE.l		; 8F AE C6 7E ; Store accumulator (long) $7EC6AE.l [Reads: Accumulator]
	lda $0CC434.l		; AF 34 C4 0C ; Load long $0CC434.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC6AF.l		; 8F AF C6 7E ; Store accumulator (long) $7EC6AF.l [Reads: Accumulator]
	inc $15.b		; E6 15 ; Increment $15.b [Reads: Direct Page] [Flags: NZ]
	inc $1E00.w		; EE 00 1E ; Increment $1E00.w [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	inc $1E0A.w		; EE 0A 1E ; Increment $1E0A.w [Flags: NZ]
	jsr $CBB0.w		; 20 B0 CB ; Jump to subroutine at $CBB0.w [Writes: Stack Pointer] [Flow: call]
	jsr $C412.w		; 20 12 C4 ; Jump to subroutine at $C412.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012A.w		; 8D 2A 01 ; Store accumulator to $012A.w [Reads: Accumulator]
	lda $1F00.w		; AD 00 1F ; Load $1F00.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	jsr $CBC3.w		; 20 C3 CB ; Jump to subroutine at $CBC3.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1F00.w		; 8D 00 1F ; Store accumulator to $1F00.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $1F05.w		; AD 05 1F ; Load $1F05.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$03.b		; 69 03 ; Add #$03.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F05.w		; 8D 05 1F ; Store accumulator to $1F05.w [Reads: Accumulator]
	lda $1F04.w		; AD 04 1F ; Load $1F04.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$01.b		; 69 01 ; Add #$01.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1F04.w		; 8D 04 1F ; Store accumulator to $1F04.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lsr $5F00.w		; 4E 00 5F ; Logical shift right $5F00.w [Flags: NCZ]
	brk $72.b		; 00 72 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $9C.b		; 00 9C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FE.b		; 00 FE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $FC.b		; 04 FC ; Test and set bits $FC.b [Reads: Accumulator] [Flags: Z]
	tsb $8A.b		; 04 8A ; Test and set bits $8A.b [Reads: Accumulator] [Flags: Z]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $CBD6.w,Y		; B9 D6 CB ; Load $CBD6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E30.w,X		; 9D 30 1E ; Store accumulator to $1E30.w,X [Reads: Accumulator, X Index]
	lda $CBD7.w,Y		; B9 D7 CB ; Load $CBD7.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E38.w,X		; 9D 38 1E ; Store accumulator to $1E38.w,X [Reads: Accumulator, X Index]
	lda $CBDC.w,Y		; B9 DC CB ; Load $CBDC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E48.w,X		; 9D 48 1E ; Store accumulator to $1E48.w,X [Reads: Accumulator, X Index]
	lda $CBDD.w,Y		; B9 DD CB ; Load $CBDD.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E50.w,X		; 9D 50 1E ; Store accumulator to $1E50.w,X [Reads: Accumulator, X Index]
	lda $CBE2.w,X		; BD E2 CB ; Load $CBE2.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E58.w,X		; 9D 58 1E ; Store accumulator to $1E58.w,X [Reads: Accumulator, X Index]
	lda $CBE5.w,X		; BD E5 CB ; Load $CBE5.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E60.w,X		; 9D 60 1E ; Store accumulator to $1E60.w,X [Reads: Accumulator, X Index]
	inc $1E10.w,X		; FE 10 1E ; Increment memory $1E10.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $C82F.w		; 20 2F C8 ; Jump to subroutine at $C82F.w [Writes: Stack Pointer] [Flow: call]
	jsr $CA4C.w		; 20 4C CA ; Jump to subroutine at $CA4C.w [Writes: Stack Pointer] [Flow: call]
	jsr $C9F1.w		; 20 F1 C9 ; Jump to subroutine at $C9F1.w [Writes: Stack Pointer] [Flow: call]
	lda $1E00.w		; AD 00 1E ; Load $1E00.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $008781.l		; 22 81 87 00 ; Jump to subroutine long $008781.l [Writes: Stack Pointer] [Flow: call]
	and ($CC.b,S),Y		; 33 CC ; AND accumulator (stack relative indirect indexed) ($CC.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lsr $CC.b,X		; 56 CC ; Logical shift right $CC.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy $CC8F.w		; CC 8F CC ; Compare $CC8F.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $00FFCC.l		; 8F CC FF 00 ; Store accumulator (long) $00FFCC.l [Reads: Accumulator]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $0AADFF.l,X		; FF FF AD 0A ; Subtract with carry (long,X) $0AADFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	asl $0729.w,X		; 1E 29 07 ; Arithmetic shift left $0729.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $CC2D.w,X		; BD 2D CC ; Load $CC2D.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E58.w,X		; 7D 58 1E ; Add $1E58.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E58.w,X		; 9D 58 1E ; Store accumulator to $1E58.w,X [Reads: Accumulator, X Index]
	lda $1E0A.w		; AD 0A 1E ; Load $1E0A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	lda $CC30.w,X		; BD 30 CC ; Load $CC30.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E60.w,X		; [PATTERN: Memory clearing operation] 7D 60 1E ; Add $1E60.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E60.w,X		; 9D 60 1E ; Store accumulator to $1E60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $1E58.w,X		; 9E 58 1E ; Store zero to $1E58.w,X [Reads: X Index]
	stz $1E60.w,X		; 9E 60 1E ; Store zero to $1E60.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $01FFFF.l,X		; FF FF FF 01 ; Subtract with carry (long,X) $01FFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sbc $5F5911.l		; EF 11 59 5F ; Subtract with carry (long) $5F5911.l [Writes: Accumulator] [Flags: NCVZ]
	adc [$74.b]		; 67 74 ; Add with carry (long) [$74.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	stz $AD.b,X		; 74 AD ; Store zero to $AD.b,X [Reads: X Index]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl $0329.w,X		; 1E 29 03 ; Arithmetic shift left $0329.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $CCB0.w		; 20 B0 CC ; Jump to subroutine at $CCB0.w [Writes: Stack Pointer] [Flow: call]
	lda $CC65.w,X		; BD 65 CC ; Load $CC65.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1E30.w,X		; DD 30 1E ; Compare accumulator $1E30.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $1E58.w,X		; [PATTERN: Memory clearing operation] 9E 58 1E ; Store zero to $1E58.w,X [Reads: X Index]
	lda $CC68.w,X		; BD 68 CC ; Load $CC68.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1E48.w,X		; DD 48 1E ; Compare accumulator $1E48.w,X [Reads: X Index] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $1E60.w,X		; 9E 60 1E ; Store zero to $1E60.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($66.b)		; 72 66 ; Add with carry (indirect) ($66.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($AD.b)		; 72 AD ; Add with carry (indirect) ($AD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $0D1E.w		; 0C 1E 0D ; Test and set bits $0D1E.w [Reads: Accumulator] [Flags: Z]
	ora $D01E.w		; 0D 1E D0 ; Logical OR $D01E.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$BD.b]		; 07 BD ; OR accumulator with memory (long) [$BD.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sty $9DCC.w		; 8C CC 9D ; Store Y register to $9DCC.w [Reads: Y Index]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	asl $AD60.w,X		; 1E 60 AD ; Arithmetic shift left $AD60.w,X [Reads: X Index] [Flags: NCZ]
	tsb $381E.w		; 0C 1E 38 ; Test and set bits $381E.w [Reads: Accumulator] [Flags: Z]
	sbc #$01.b		; E9 01 ; Subtract #$01.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $1E0C.w		; 8D 0C 1E ; Store accumulator to $1E0C.w [Reads: Accumulator]
	lda $1E0D.w		; AD 0D 1E ; Load $1E0D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc #$00.b		; E9 00 ; Subtract #$00.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $1E0D.w		; 8D 0D 1E ; Store accumulator to $1E0D.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $CC65.w,X		; BD 65 CC ; Load $CC65.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1E30.w,X		; DD 30 1E ; Compare accumulator $1E30.w,X [Reads: X Index] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda $CC60.w,X		; BD 60 CC ; Load $CC60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	lda $CC5D.w,X		; BD 5D CC ; Load $CC5D.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E58.w,X		; 7D 58 1E ; Add $1E58.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E58.w,X		; 9D 58 1E ; Store accumulator to $1E58.w,X [Reads: Accumulator, X Index]
	cmp $CC63.w		; CD 63 CC ; Compare $CC63.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda $CC63.w		; AD 63 CC ; Load $CC63.w into accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $80, $09		; 80 09 ; Branch always to $80, $09 [Flow: branch]
	cmp $CC64.w		; CD 64 CC ; Compare $CC64.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	lda $CC64.w		; AD 64 CC ; Load $CC64.w into accumulator [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $1E58.w,X		; 9D 58 1E ; Store accumulator to $1E58.w,X [Reads: Accumulator, X Index]
	lda $CC68.w,X		; BD 68 CC ; Load $CC68.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $1E48.w,X		; DD 48 1E ; Compare accumulator $1E48.w,X [Reads: X Index] [Flags: NCZ]
	.db $90, $05		; 90 05 ; Branch if carry clear to $90, $05 [Flow: branch]
	lda $CC60.w,X		; BD 60 CC ; Load $CC60.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	lda $CC5D.w,X		; BD 5D CC ; Load $CC5D.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E60.w,X		; 7D 60 1E ; Add $1E60.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E60.w,X		; 9D 60 1E ; Store accumulator to $1E60.w,X [Reads: Accumulator, X Index]
	cmp $CC63.w		; CD 63 CC ; Compare $CC63.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda $CC63.w		; AD 63 CC ; Load $CC63.w into accumulator [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $80, $09		; 80 09 ; Branch always to $80, $09 [Flow: branch]
	cmp $CC64.w		; CD 64 CC ; Compare $CC64.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	lda $CC64.w		; AD 64 CC ; Load $CC64.w into accumulator [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $1E60.w,X		; 9D 60 1E ; Store accumulator to $1E60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and #$00.b		; 29 00 ; Logical AND #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	eor $009700.l,X		; 5F 00 97 00 ; Exclusive OR accumulator with memory (long,X) $009700.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $00		; 70 00 ; Branch if overflow set to $70, $00 [Flow: branch]
	jsr $7000.w		; 20 00 70 ; Jump to subroutine at $7000.w [Writes: Stack Pointer] [Flow: call]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $CD0D.w,Y		; B9 0D CD ; Load $CD0D.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E30.w,X		; 9D 30 1E ; Store accumulator to $1E30.w,X [Reads: Accumulator, X Index]
	lda $CD0E.w,Y		; B9 0E CD ; Load $CD0E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E38.w,X		; 9D 38 1E ; Store accumulator to $1E38.w,X [Reads: Accumulator, X Index]
	lda $CD13.w,Y		; B9 13 CD ; Load $CD13.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E48.w,X		; 9D 48 1E ; Store accumulator to $1E48.w,X [Reads: Accumulator, X Index]
	lda $CD14.w,Y		; B9 14 CD ; Load $CD14.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1E50.w,X		; 9D 50 1E ; Store accumulator to $1E50.w,X [Reads: Accumulator, X Index]
	inc $1E10.w,X		; FE 10 1E ; Increment memory $1E10.w,X [Reads: X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $010100.l,X		; FF 00 01 01 ; Subtract with carry (long,X) $010100.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $BD2001.l,X		; FF 01 20 BD ; Subtract with carry (long,X) $BD2001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $20.b,S		; C3 20 ; Compare accumulator (stack relative) $20.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and $F120C8.l		; 2F C8 20 F1 ; AND accumulator with memory (long) $F120C8.l [Writes: Accumulator] [Flags: NZ]
	cmp #$A5.b		; C9 A5 ; Compare #$A5.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($C9.b),Y		; 11 C9 ; OR accumulator with memory ($C9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $D0.b		; 24 D0 ; Test bits $D0.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	ora $1E20BD.l,X		; 1F BD 20 1E ; Logical OR long $1E20BD.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$50.b		; C9 50 ; Compare #$50.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $17		; F0 17 ; Branch if equal to $F0, $17 [Flow: branch]
	inc $1E20.w,X		; FE 20 1E ; Increment memory $1E20.w,X [Reads: X Index] [Flags: NZ]
	lda $CD38.w,X		; BD 38 CD ; Load $CD38.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E58.w,X		; 7D 58 1E ; Add $1E58.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E58.w,X		; 9D 58 1E ; Store accumulator to $1E58.w,X [Reads: Accumulator, X Index]
	lda $CD3B.w,X		; BD 3B CD ; Load $CD3B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $1E60.w,X		; 7D 60 1E ; Add $1E60.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $1E60.w,X		; 9D 60 1E ; Store accumulator to $1E60.w,X [Reads: Accumulator, X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $1E20.w,X		; 9E 20 1E ; Store zero to $1E20.w,X [Reads: X Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	mvn $A8,$00		; 54 00 A8 ; Move block negative $A8,$00 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	brk $8F.b		; [PATTERN: Memory clearing operation] 00 8F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $8A6A4A.l,X		; FF 4A 6A 8A ; Subtract with carry (long,X) $8A6A4A.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $E464BF.l		; AF BF 64 E4 ; Load long $E464BF.l into accumulator [Writes: Accumulator] [Flags: NZ]
	stz $E5.b		; 64 E5 ; Store zero to $E5.b
	stz $EA.b		; 64 EA ; Store zero to $EA.b
	stz $EB.b		; 64 EB ; Store zero to $EB.b
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $00879C.l		; 22 9C 87 00 ; Jump to subroutine long $00879C.l [Writes: Stack Pointer] [Flow: call]
	sta $0CCD.w,X		; 9D CD 0C ; Store accumulator to $0CCD.w,X [Reads: Accumulator, X Index]
	sbc ($CD.b)		; F2 CD ; Subtract with carry (indirect) ($CD.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tsb $CE53.w		; 0C 53 CE ; Test and set bits $CE53.w [Reads: Accumulator] [Flags: Z]
	tsb $CEA5.w		; 0C A5 CE ; Test and set bits $CEA5.w [Reads: Accumulator] [Flags: Z]
	tsb $CEB1.w		; 0C B1 CE ; Test and set bits $CEB1.w [Reads: Accumulator] [Flags: Z]
	tsb $CEBD.w		; [PATTERN: Memory clearing operation] 0C BD CE ; Test and set bits $CEBD.w [Reads: Accumulator] [Flags: Z]
	tsb $3D22.w		; 0C 22 3D ; Test and set bits $3D22.w [Reads: Accumulator] [Flags: Z]
	bit #$00.b		; 89 00 ; Test bits #$00.b with accumulator [Reads: Accumulator] [Flags: Z]
	stz $012A.w		; 9C 2A 01 ; Store zero to $012A.w
	stz $1F0C.w		; 9C 0C 1F ; Store zero to $1F0C.w
	lda #$0B.b		; A9 0B ; Load #$0B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA9.w		; 8D A9 0A ; Store accumulator to $0AA9.w [Reads: Accumulator]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AB6.w		; 8D B6 0A ; Store accumulator to $0AB6.w [Reads: Accumulator]
	sta $0710.w		; 8D 10 07 ; Store accumulator to $0710.w [Reads: Accumulator]
	jsl $1BEE74.l		; 22 74 EE 1B ; Jump to subroutine long $1BEE74.l [Writes: Stack Pointer] [Flow: call]
	jsl $1BEEA8.l		; 22 A8 EE 1B ; Jump to subroutine long $1BEEA8.l [Writes: Stack Pointer] [Flow: call]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AB2.w		; 8D B2 0A ; Store accumulator to $0AB2.w [Reads: Accumulator]
	jsl $1BEE52.l		; 22 52 EE 1B ; Jump to subroutine long $1BEE52.l [Writes: Stack Pointer] [Flow: call]
	stz $0202.w		; 9C 02 02 ; Store zero to $0202.w
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA4.w		; 8D A4 0A ; Store accumulator to $0AA4.w [Reads: Accumulator]
	lda #$23.b		; A9 23 ; Load #$23.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA1.w		; 8D A1 0A ; Store accumulator to $0AA1.w [Reads: Accumulator]
	lda #$51.b		; A9 51 ; Load #$51.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA2.w		; 8D A2 0A ; Store accumulator to $0AA2.w [Reads: Accumulator]
	jsl $00E2D0.l		; 22 D0 E2 00 ; Jump to subroutine long $00E2D0.l [Writes: Stack Pointer] [Flow: call]
	jsl $00E19B.l		; 22 9B E1 00 ; Jump to subroutine long $00E19B.l [Writes: Stack Pointer] [Flow: call]
	jsl $00E4E9.l		; 22 E9 E4 00 ; Jump to subroutine long $00E4E9.l [Writes: Stack Pointer] [Flow: call]
	jsl $028054.l		; 22 54 80 02 ; Jump to subroutine long $028054.l [Writes: Stack Pointer] [Flow: call]
	jmp $02FE71.l		; 5C 71 FE 02 ; Jump long to $02FE71.l [Flow: jump]
	ldx #$05.b		; A2 05 ; Load #$05.b into X register [Writes: X Index] [Flags: NZ]
	stz $BF.b,X		; 74 BF ; Store zero to $BF.b,X [Reads: X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $FB		; 10 FB ; Branch if plus to $10, $FB [Flow: branch]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0710.w		; 8D 10 07 ; Store accumulator to $0710.w [Reads: Accumulator]
	jsl $00893D.l		; 22 3D 89 00 ; Jump to subroutine long $00893D.l [Writes: Stack Pointer] [Flow: call]
	jsl $008333.l		; 22 33 83 00 ; Jump to subroutine long $008333.l [Writes: Stack Pointer] [Flow: call]
	jsl $1BEF96.l		; 22 96 EF 1B ; Jump to subroutine long $1BEF96.l [Writes: Stack Pointer] [Flow: call]
	inc $15.b		; E6 15 ; Increment $15.b [Reads: Direct Page] [Flags: NZ]
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta ($35.b,X)		; 81 35 ; Store accumulator ($35.b,X) [Reads: Direct Page, Accumulator, X Index]
	.db $82, $35, $91		; 82 35 91 ; Branch always long to $82, $35, $91 [Flow: branch]
	and $92.b,X		; 35 92 ; Logical AND $92.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $0F.b,X		; 35 0F ; Logical AND $0F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dec $CE13.w		; CE 13 CE ; Decrement $CE13.w [Flags: NZ]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $10048D.l,X		; FF 8D 04 10 ; Subtract with carry (long,X) $10048D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	stz $00.b		; 64 00 ; Store zero to $00.b
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	brk $A5.b		; 00 A5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $48.b		; 00 48 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$20.b		; 29 20 ; Logical AND #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $CE17.w,Y		; B9 17 CE ; Load $CE17.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($02.b),Y		; B1 02 ; Load accumulator ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1006.w,X		; 9D 06 10 ; Store accumulator to $1006.w,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inc $00.b		; E6 00 ; Increment $00.b [Reads: Direct Page] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	tsb $D0.b		; 04 D0 ; Test and set bits $D0.b [Reads: Accumulator] [Flags: Z]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	jsr $CE1B.w		; 20 1B CE ; Jump to subroutine at $CE1B.w [Writes: Stack Pointer] [Flow: call]
	ldy #$00DE.w		; A0 DE 00 ; Load #$00DE.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $E1C8.w,Y		; B9 C8 E1 ; Load $E1C8.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1806.w,Y		; 99 06 18 ; Store accumulator to $1806.w,Y [Reads: Y Index, Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $F4		; 10 F4 ; Branch if plus to $10, $F4 [Flow: branch]
	lda #$1103.w		; A9 03 11 ; Load #$1103.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda #$0011.w		; A9 11 00 ; Load #$0011.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $1006.w,X		; 9D 06 10 ; Store accumulator to $1006.w,X [Reads: Accumulator, X Index]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0020.w		; 69 20 00 ; Add #$0020.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda #$3240.w		; A9 40 32 ; Load #$3240.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1006.w,X		; 9D 06 10 ; Store accumulator to $1006.w,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda #$347F.w		; A9 7F 34 ; Load #$347F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1006.w,X		; 9D 06 10 ; Store accumulator to $1006.w,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $02.b		; C6 02 ; Decrement $02.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $DD		; 10 DD ; Branch if plus to $10, $DD [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1006.w,X		; 9D 06 10 ; Store accumulator to $1006.w,X [Reads: Accumulator, X Index]
.INDEX 8
	sep #$10		; E2 10
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	jmp $D09C.w		; 4C 9C D0 ; Jump to $D09C.w [Flow: jump]
	lda $0B9D.w		; AD 9D 0B ; Load $0B9D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $C8.b		; 85 C8 ; Store accumulator to $C8.b [Reads: Accumulator]
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $14.b		; 85 14 ; Store accumulator to $14.b [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $CEC7.w		; 20 C7 CE ; Jump to subroutine at $CEC7.w [Writes: Stack Pointer] [Flow: call]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $13.b		; 85 13 ; Store accumulator to $13.b [Reads: Accumulator]
	stz $0710.w		; 9C 10 07 ; Store zero to $0710.w
	.db $80, $ED		; 80 ED ; Branch always to $80, $ED [Flow: branch]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsl $0CCEDC.l		; 22 DC CE 0C ; Jump to subroutine long $0CCEDC.l [Writes: Stack Pointer] [Flow: call]
	jmp $D09C.w		; 4C 9C D0 ; Jump to $D09C.w [Flow: jump]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
.INDEX 16
	rep #$10		; C2 10
	ldx #$00FD.w		; A2 FD 00 ; Load #$00FD.w into X register [Writes: X Index] [Flags: NZ]
	lda $E358.w,X		; BD 58 E3 ; Load $E358.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1001.w,X		; 9D 01 10 ; Store accumulator to $1001.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $F7		; D0 F7 ; Branch if not equal to $D0, $F7 [Flow: branch]
.INDEX 8
	sep #$10		; E2 10
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	sta $0B9D.w		; 8D 9D 0B ; Store accumulator to $0B9D.w [Reads: Accumulator]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	ldx #$0000.w		; A2 00 00 ; Load #$0000.w into X register [Writes: X Index] [Flags: NZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	lda $00848C.l,X		; BF 8C 84 00 ; Load long $00848C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $7003E5.l,X		; BF E5 03 70 ; Load long $7003E5.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$55AA.w		; C9 AA 55 ; Compare #$55AA.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $1E		; D0 1E ; Branch if not equal to $D0, $1E [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda #$0001.w		; A9 01 00 ; Load #$0001.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $BF.b,X		; 95 BF ; Store accumulator to $BF.b,X [Reads: Accumulator, X Index]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$D698.w		; A9 98 D6 ; Load #$D698.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda #$D699.w		; A9 99 D6 ; Load #$D699.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsr $D6AF.w		; 20 AF D6 ; Jump to subroutine at $D6AF.w [Writes: Stack Pointer] [Flow: call]
	jsr $D7DB.w		; 20 DB D7 ; Jump to subroutine at $D7DB.w [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	jsr $D63C.w		; 20 3C D6 ; Jump to subroutine at $D63C.w [Writes: Stack Pointer] [Flow: call]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$0006.w		; E0 06 00 ; Compare #$0006.w with X register [Reads: X Index] [Flags: NCZ]
	.db $90, $C9		; 90 C9 ; Branch if carry clear to $90, $C9 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda #$1C.b		; A9 1C ; Load #$1C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $CD78.w,X		; BD 78 CD ; Load $CD78.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	jsr $D7A5.w		; 20 A5 D7 ; Jump to subroutine at $D7A5.w [Writes: Stack Pointer] [Flow: call]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$C0.b		; 29 C0 ; Logical AND #$C0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F4.b		; 05 F4 ; Logical OR $F4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$FC.b		; 29 FC ; Logical AND #$FC.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $7D		; F0 7D ; Branch if equal to $F0, $7D [Flow: branch]
	and #$2C.b		; 29 2C ; Logical AND #$2C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0F		; F0 0F ; Branch if equal to $F0, $0F [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	dec $C8.b		; C6 C8 ; Decrement $C8.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $15		; 10 15 ; Branch if plus to $10, $15 [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $C8.b		; 85 C8 ; Store accumulator to $C8.b [Reads: Accumulator]
	.db $80, $0F		; 80 0F ; Branch always to $80, $0F [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	inc $C8.b		; E6 C8 ; Increment $C8.b [Reads: Direct Page] [Flags: NZ]
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$05.b		; C9 05 ; Compare #$05.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	stz $C8.b		; 64 C8 ; Store zero to $C8.b
	.db $80, $55		; 80 55 ; Branch always to $80, $55 [Flow: branch]
	lda #$2C.b		; A9 2C ; Load #$2C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $2D		; F0 2D ; Branch if equal to $F0, $2D [Flow: branch]
	.db $B0, $2F		; B0 2F ; Branch if carry set to $B0, $2F [Flow: branch]
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $BF.b,X		; B5 BF ; Load $BF.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1D		; F0 1D ; Branch if equal to $F0, $1D [Flow: branch]
	lda #$F1.b		; A9 F1 ; Load #$F1.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	stz $C9.b		; 64 C9 ; Store zero to $C9.b
.ACCU 16
	rep #$20		; C2 20
	lda $00848C.l,X		; BF 8C 84 00 ; Load long $00848C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $701FFE.l		; 8F FE 1F 70 ; Store accumulator (long) $701FFE.l [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	.db $82, $24, $00		; 82 24 00 ; Branch always long to $82, $24, $00 [Flow: branch]
	stz $C9.b		; 64 C9 ; Store zero to $C9.b
	ldy #$04.b		; A0 04 ; Load #$04.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $17		; 80 17 ; Branch always to $80, $17 [Flow: branch]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	ldy #$03.b		; A0 03 ; Load #$03.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $BF.b		; A5 BF ; Load $BF.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $C1.b		; 05 C1 ; Logical OR $C1.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $C3.b		; 05 C3 ; Logical OR $C3.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	lda #$3C.b		; A9 3C ; Load #$3C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; [PATTERN: Memory clearing operation] 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	stz $C8.b		; 64 C8 ; Store zero to $C8.b
	sty $10.b		; 84 10 ; Store Y register to $10.b [Reads: Y Index]
	stz $11.b		; 64 11 ; Store zero to $11.b
	stz $B0.b		; 64 B0 ; Store zero to $B0.b
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx #$0F.b		; A2 0F ; Load #$0F.b into X register [Writes: X Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $001AC0.l,X		; 9F C0 1A 00 ; Store accumulator (long,X) $001AC0.l,X [Reads: Accumulator, X Index]
	sta $001AE0.l,X		; 9F E0 1A 00 ; Store accumulator (long,X) $001AE0.l,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $001AB0.l,X		; 9F B0 1A 00 ; Store accumulator (long,X) $001AB0.l,X [Reads: Accumulator, X Index]
	sta $001AD0.l,X		; 9F D0 1A 00 ; Store accumulator (long,X) $001AD0.l,X [Reads: Accumulator, X Index]
	sta $001AF0.l,X		; 9F F0 1A 00 ; Store accumulator (long,X) $001AF0.l,X [Reads: Accumulator, X Index]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	lda #$7E.b		; A9 7E ; Load #$7E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	ldy #$0000.w		; A0 00 00 ; Load #$0000.w into Y register [Writes: Y Index] [Flags: NZ]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $700000.l,X		; BF 00 00 70 ; Load long $700000.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $F000.w,Y		; 99 00 F0 ; Store accumulator to $F000.w,Y [Reads: Y Index, Accumulator]
	lda $700100.l,X		; BF 00 01 70 ; Load long $700100.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $F100.w,Y		; 99 00 F1 ; Store accumulator to $F100.w,Y [Reads: Y Index, Accumulator]
	lda $700200.l,X		; BF 00 02 70 ; Load long $700200.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $F200.w,Y		; 99 00 F2 ; Store accumulator to $F200.w,Y [Reads: Y Index, Accumulator]
	lda $700300.l,X		; BF 00 03 70 ; Load long $700300.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $F300.w,Y		; 99 00 F3 ; Store accumulator to $F300.w,Y [Reads: Y Index, Accumulator]
	lda $700400.l,X		; BF 00 04 70 ; Load long $700400.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $F400.w,Y		; 99 00 F4 ; Store accumulator to $F400.w,Y [Reads: Y Index, Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy #$0100.w		; C0 00 01 ; Compare #$0100.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $D4		; D0 D4 ; Branch if not equal to $D0, $D4 [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$0007.w		; A9 07 00 ; Load #$0007.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC00D.l		; 8F 0D C0 7E ; Store accumulator (long) $7EC00D.l [Reads: Accumulator]
	sta $7EC013.l		; 8F 13 C0 7E ; Store accumulator (long) $7EC013.l [Reads: Accumulator]
	lda #$0000.w		; A9 00 00 ; Load #$0000.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC00F.l		; 8F 0F C0 7E ; Store accumulator (long) $7EC00F.l [Reads: Accumulator]
	sta $7EC015.l		; 8F 15 C0 7E ; Store accumulator (long) $7EC015.l [Reads: Accumulator]
	lda #$6040.w		; A9 40 60 ; Load #$6040.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0219.w		; 8D 19 02 ; Store accumulator to $0219.w [Reads: Accumulator]
	lda #$4841.w		; A9 41 48 ; Load #$4841.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $021D.w		; 8D 1D 02 ; Store accumulator to $021D.w [Reads: Accumulator]
	lda #$007F.w		; A9 7F 00 ; Load #$007F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $021F.w		; 8D 1F 02 ; Store accumulator to $021F.w [Reads: Accumulator]
	lda #$FFFF.w		; A9 FF FF ; Load #$FFFF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0221.w		; 8D 21 02 ; Store accumulator to $0221.w [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0204.w		; [PATTERN: Memory clearing operation] 8D 04 02 ; Store accumulator to $0204.w [Reads: Accumulator]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $10.b		; 85 10 ; Store accumulator to $10.b [Reads: Accumulator]
	stz $11.b		; 64 11 ; Store zero to $11.b
	stz $010E.w		; 9C 0E 01 ; Store zero to $010E.w
	stz $0710.w		; [PATTERN: Memory clearing operation] 9C 10 07 ; Store zero to $0710.w
	stz $0AB2.w		; 9C B2 0A ; Store zero to $0AB2.w
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $0B9D.w		; 9C 9D 0B ; Store zero to $0B9D.w
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $00879C.l		; 22 9C 87 00 ; Jump to subroutine long $00879C.l [Writes: Stack Pointer] [Flow: call]
	sbc $0CCD.w,Y		; F9 CD 0C ; Subtract with carry $0CCD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($CE.b,S),Y		; 53 CE ; XOR accumulator (stack relative indirect indexed) ($CE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $D06E.w		; 0C 6E D0 ; Test and set bits $D06E.w [Reads: Accumulator] [Flags: Z]
	tsb $D087.w		; 0C 87 D0 ; Test and set bits $D087.w [Reads: Accumulator] [Flags: Z]
	tsb $D0A2.w		; 0C A2 D0 ; Test and set bits $D0A2.w [Reads: Accumulator] [Flags: Z]
	tsb $D0B9.w		; 0C B9 D0 ; Test and set bits $D0B9.w [Reads: Accumulator] [Flags: Z]
	tsb $07A9.w		; 0C A9 07 ; Test and set bits $07A9.w [Reads: Accumulator] [Flags: Z]
	jsr $C52E.w		; 20 2E C5 ; Jump to subroutine at $C52E.w [Writes: Stack Pointer] [Flow: call]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $13.b		; 85 13 ; Store accumulator to $13.b [Reads: Accumulator]
	stz $0710.w		; 9C 10 07 ; Store zero to $0710.w
	ldx #$FE.b		; A2 FE ; Load #$FE.b into X register [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda $BF.b,X		; B5 BF ; Load $BF.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $FA		; F0 FA ; Branch if equal to $F0, $FA [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $C8.b		; 85 C8 ; Store accumulator to $C8.b [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $D13F.w		; 20 3F D1 ; Jump to subroutine at $D13F.w [Writes: Stack Pointer] [Flow: call]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$30.b		; 29 30 ; Logical AND #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $D0C6.w		; 20 C6 D0 ; Jump to subroutine at $D0C6.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $14.b		; 85 14 ; Store accumulator to $14.b [Reads: Accumulator]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $D27B.w		; 20 7B D2 ; Jump to subroutine at $D27B.w [Writes: Stack Pointer] [Flow: call]
	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$30.b		; 29 30 ; Logical AND #$30.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $E8		; D0 E8 ; Branch if not equal to $D0, $E8 [Flow: branch]
	jsr $D0C6.w		; 20 C6 D0 ; Jump to subroutine at $D0C6.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $E3		; 80 E3 ; Branch always to $80, $E3 [Flow: branch]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $D371.w		; 20 71 D3 ; Jump to subroutine at $D371.w [Writes: Stack Pointer] [Flow: call]
	jmp $D09C.w		; 4C 9C D0 ; Jump to $D09C.w [Flow: jump]
	tsb $00.b		; 04 00 ; Test and set bits $00.b [Reads: Accumulator] [Flags: Z]
	asl $C200.w,X		; 1E 00 C2 ; Arithmetic shift left $C200.w,X [Reads: X Index] [Flags: NCZ]
	.db $30, $A2		; 30 A2 ; Branch if minus to $30, $A2 [Flow: branch]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$A9.b		; A9 A9 ; Load #$A9.b into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	brk $84.b		; 00 84 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BC.b		; 00 BC ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
.INDEX 16
	rep #$D0		; C2 D0
	sta $1002.w,Y		; 99 02 10 ; Store accumulator to $1002.w,Y [Reads: Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $F7		; D0 F7 ; Branch if not equal to $D0, $F7 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $EB		; 10 EB ; Branch if plus to $10, $EB [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $1C.b		; 24 1C ; Test bits $1C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	eor [$6F.b],Y		; 57 6F ; Exclusive OR accumulator with memory (long indexed) [$6F.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta [$BF.b]		; 87 BF ; Store accumulator (long) [$BF.b] [Reads: Direct Page, Accumulator]
	adc ($67.b,X)		; 61 67 ; Add with carry ($67.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	asl $00A9.w		; 0E A9 00 ; Arithmetic shift left $00A9.w [Flags: NCZ]
	adc ($87.b,X)		; 61 87 ; Add with carry ($87.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	asl $00A9.w		; 0E A9 00 ; Arithmetic shift left $00A9.w [Flags: NCZ]
	adc ($C7.b,X)		; 61 C7 ; Add with carry ($C7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	asl $00A9.w		; 0E A9 00 ; Arithmetic shift left $00A9.w [Flags: NCZ]
	adc ($E7.b,X)		; 61 E7 ; Add with carry ($E7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	asl $00A9.w		; 0E A9 00 ; Arithmetic shift left $00A9.w [Flags: NCZ]
	ora ($30.b),Y		; 11 30 ; OR accumulator with memory ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $35.b,S		; 83 35 ; Store accumulator (stack relative) $35.b,S [Reads: Stack Pointer, Accumulator]
	ora ($31.b),Y		; 11 31 ; OR accumulator with memory ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	trb $85.b		; 14 85 ; Test and reset bits $85.b [Reads: Accumulator] [Flags: Z]
	and $11.b,X		; 35 11 ; Logical AND $11.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $0100.w,X		; 3C 00 01 ; Test bits $0100.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sty $35.b		; 84 35 ; Store Y register to $35.b [Reads: Y Index]
	ora ($50.b),Y		; 11 50 ; OR accumulator with memory ($50.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: NCZ]
	stx $35.b		; 86 35 ; Store X register to $35.b [Reads: X Index]
	ora ($5C.b),Y		; 11 5C ; OR accumulator with memory ($5C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$0E.b		; C0 0E ; Compare #$0E.b with Y register [Reads: Y Index] [Flags: NCZ]
	stx $35.b,Y		; 96 35 ; Store X register $35.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ora ($50.b)		; 12 50 ; OR accumulator with memory (indirect) ($50.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($35.b,S),Y		; 93 35 ; Store accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora ($51.b)		; 12 51 ; OR accumulator with memory (indirect) ($51.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	trb $95.b		; 14 95 ; Test and reset bits $95.b [Reads: Accumulator] [Flags: Z]
	and $12.b,X		; 35 12 ; Logical AND $12.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $940100.l		; 5C 00 01 94 ; Jump long to $940100.l [Flow: jump]
	and $FF.b,X		; 35 FF ; Logical AND $FF.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $0C.b		; 00 0C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $6400.w,X		; 3C 00 64 ; Test bits $6400.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C2.b		; 00 C2 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $A2		; 10 A2 ; Branch if plus to $10, $A2 [Flow: branch]
	ldy $8E00.w		; AC 00 8E ; Load $8E00.w into Y register [Writes: Y Index] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $E68D.w,X		; BD 8D E6 ; Load $E68D.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1002.w,X		; 9D 02 10 ; Store accumulator to $1002.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	brk $86.b		; 00 86 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B5.b		; 00 B5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $000129.l,X		; BF 29 01 00 ; Load long $000129.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $29		; F0 29 ; Branch if equal to $F0, $29 [Flow: branch]
	lda $00848C.l,X		; BF 8C 84 00 ; Load long $00848C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $D139.w,Y		; B9 39 D1 ; Load $D139.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$0006.w		; A9 06 00 ; Load #$0006.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $7003D9.l,X		; BF D9 03 70 ; Load long $7003D9.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$1800.w		; 69 00 18 ; Add #$1800.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1002.w,Y		; 99 02 10 ; Store accumulator to $1002.w,Y [Reads: Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1016.w,Y		; 99 16 10 ; Store accumulator to $1016.w,Y [Reads: Y Index, Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $02.b		; C6 02 ; Decrement $02.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $E6		; D0 E6 ; Branch if not equal to $D0, $E6 [Flow: branch]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$06.b		; E0 06 ; Compare #$06.b with X register [Reads: X Index] [Flags: NCZ]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $E2.b		; C5 E2 ; Compare $E2.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	.db $30, $A6		; 30 A6 ; Branch if minus to $30, $A6 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $D0E6.w,X		; BD E6 D0 ; Load $D0E6.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $D0EA.w,X		; BD EA D0 ; Load $D0EA.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	jsr $D7A5.w		; 20 A5 D7 ; Jump to subroutine at $D7A5.w [Writes: Stack Pointer] [Flow: call]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$05C0.w		; 29 C0 05 ; Logical AND #$05C0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	pea $FC29.w		; F4 29 FC ; Push absolute address $FC29.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	.db $82, $8B, $00		; 82 8B 00 ; Branch always long to $82, $8B, $00 [Flow: branch]
	and #$F02C.w		; 29 2C F0 ; Logical AND #$F02C.w with accumulator [Writes: Accumulator] [Flags: NZ]
	and $F00829.l,X		; 3F 29 08 F0 ; AND accumulator with memory (long,X) $F00829.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $A6.b		; 14 A6 ; Test and reset bits $A6.b [Reads: Accumulator] [Flags: Z]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $30, $0B		; 30 0B ; Branch if minus to $30, $0B [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $00BF.w,Y		; B9 BF 00 ; Load $00BF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $25		; D0 25 ; Branch if not equal to $D0, $25 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F5		; 10 F5 ; Branch if plus to $10, $F5 [Flow: branch]
	ldx #$03.b		; A2 03 ; Load #$03.b into X register [Writes: X Index] [Flags: NZ]
	.db $80, $1E		; 80 1E ; Branch always to $80, $1E [Flow: branch]
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $00BF.w,Y		; B9 BF 00 ; Load $00BF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $F3		; D0 F3 ; Branch if not equal to $D0, $F3 [Flow: branch]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	.db $80, $E9		; 80 E9 ; Branch always to $80, $E9 [Flow: branch]
	lda #$8D20.w		; A9 20 8D ; Load #$8D20.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and $C88601.l		; 2F 01 86 C8 ; AND accumulator with memory (long) $C88601.l [Writes: Accumulator] [Flags: NZ]
	.db $80, $48		; 80 48 ; Branch always to $80, $48 [Flow: branch]
	lda #$8D2C.w		; A9 2C 8D ; Load #$8D2C.w into accumulator [Writes: Accumulator] [Flags: NZ]
	rol $A501.w		; 2E 01 A5 ; Rotate left $A501.w [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cmp #$F003.w		; C9 03 F0 ; Compare #$F003.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	and ($0A.b),Y		; 31 0A ; AND accumulator with memory ($0A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $CC.b		; 85 CC ; Store accumulator to $CC.b [Reads: Accumulator]
	stz $CD.b		; 64 CD ; Store zero to $CD.b
	ldx #$49.b		; A2 49 ; Load #$49.b into X register [Writes: X Index] [Flags: NZ]
	lda $D0ED.w,X		; BD ED D0 ; Load $D0ED.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1035.w,X		; 9D 35 10 ; Store accumulator to $1035.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $F7		; D0 F7 ; Branch if not equal to $D0, $F7 [Flow: branch]
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $17		; F0 17 ; Branch if equal to $F0, $17 [Flow: branch]
	lda $D137.w,X		; BD 37 D1 ; Load $D137.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$9D62.w		; A9 62 9D ; Load #$9D62.w into accumulator [Writes: Accumulator] [Flags: NZ]
	rol $10.b,X		; 36 10 ; Rotate left $10.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	sta $103C.w,X		; 9D 3C 10 ; Store accumulator to $103C.w,X [Reads: Accumulator, X Index]
	lda #$9D27.w		; A9 27 9D ; Load #$9D27.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and [$10.b],Y		; 37 10 ; AND accumulator with memory (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$9D20.w		; 69 20 9D ; Add #$9D20.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and $E610.w,X		; 3D 10 E6 ; AND accumulator with memory $E610.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($80.b),Y		; 11 80 ; OR accumulator with memory ($80.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda #$8501.w		; A9 01 85 ; Load #$8501.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $A9		; 10 A9 ; Branch if plus to $10, $A9 [Flow: branch]
	ora ($85.b,X)		; 01 85 ; Logical OR ($85.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($64.b),Y		; 11 64 ; OR accumulator with memory ($64.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $B0, $64		; B0 64 ; Branch if carry set to $B0, $64 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($B4.b,X)		; 61 B4 ; Add with carry ($B4.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	asl $00A9.w		; 0E A9 00 ; Arithmetic shift left $00A9.w [Flags: NCZ]
	adc ($D4.b,X)		; 61 D4 ; Add with carry ($D4.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	asl $00A9.w		; 0E A9 00 ; Arithmetic shift left $00A9.w [Flags: NCZ]
	.db $62, $C6, $00		; 62 C6 00 ; Push effective relative address $62, $C6, $00 [Writes: Stack Pointer]
	ora $1802.w		; 0D 02 18 ; Logical OR $1802.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $0F18.w		; 0E 18 0F ; Arithmetic shift left $0F18.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$0E18.w		; A9 18 0E ; Load #$0E18.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $62, $E6, $00		; 62 E6 00 ; Push effective relative address $62, $E6, $00 [Writes: Stack Pointer]
	ora $1812.w		; 0D 12 18 ; Logical OR $1812.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl $1F18.w,X		; 1E 18 1F ; Arithmetic shift left $1F18.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$1E18.w		; A9 18 1E ; Load #$1E18.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $1C8C8C.l,X		; FF 8C 8C 1C ; Subtract with carry (long,X) $1C8C8C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$7F.b]		; 67 7F ; Add with carry (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda $600038.l,X		; BF 38 00 60 ; Load long $600038.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $E7.b		; 00 E7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	clc		; 18 ; Clear carry flag [Flags: C]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc #$A918.w		; E9 18 A9 ; Subtract #$A918.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	tsb $A2.b		; 04 A2 ; Test and set bits $A2.b [Reads: Accumulator] [Flags: Z]
	ora ($C5.b,X)		; 01 C5 ; Logical OR ($C5.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cpy $03F0.w		; CC F0 03 ; Compare $03F0.w with Y register [Reads: Y Index] [Flags: NCZ]
	sta $CA.b,X		; 95 CA ; Store accumulator to $CA.b,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $10, $F5		; 10 F5 ; Branch if plus to $10, $F5 [Flow: branch]
.INDEX 16
	rep #$10		; C2 10
	ldx #$0084.w		; A2 84 00 ; Load #$0084.w into X register [Writes: X Index] [Flags: NZ]
	stx $0E.b		; 86 0E ; Store X register to $0E.b [Reads: X Index]
	lda $E73A.w,X		; BD 3A E7 ; Load $E73A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1002.w,X		; 9D 02 10 ; Store accumulator to $1002.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	ldx #$0000.w		; A2 00 00 ; Load #$0000.w into X register [Writes: X Index] [Flags: NZ]
	stx $04.b		; 86 04 ; Store X register to $04.b [Reads: X Index]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	cpx $CC.b		; E4 CC ; Compare $CC.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $F0, $3F		; F0 3F ; Branch if equal to $F0, $3F [Flow: branch]
	ldy $04.b		; A4 04 ; Load $04.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda $D271.w,Y		; B9 71 D2 ; Load $D271.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	inc $04.b		; E6 04 ; Increment $04.b [Reads: Direct Page] [Flags: NZ]
	inc $04.b		; E6 04 ; Increment $04.b [Reads: Direct Page] [Flags: NZ]
	lda $D275.w,X		; BD 75 D2 ; Load $D275.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1002.w,Y		; 99 02 10 ; Store accumulator to $1002.w,Y [Reads: Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1016.w,Y		; 99 16 10 ; Store accumulator to $1016.w,Y [Reads: Y Index, Accumulator]
	lda $BF.b,X		; B5 BF ; Load $BF.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	lda #$0006.w		; A9 06 00 ; Load #$0006.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $00848C.l,X		; BF 8C 84 00 ; Load long $00848C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $7003D9.l,X		; BF D9 03 70 ; Load long $7003D9.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$1800.w		; 69 00 18 ; Add #$1800.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1006.w,Y		; 99 06 10 ; Store accumulator to $1006.w,Y [Reads: Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $101A.w,Y		; 99 1A 10 ; Store accumulator to $101A.w,Y [Reads: Y Index, Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $02.b		; C6 02 ; Decrement $02.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $E6		; D0 E6 ; Branch if not equal to $D0, $E6 [Flow: branch]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$0006.w		; E0 06 00 ; Compare #$0006.w with X register [Reads: X Index] [Flags: NCZ]
	.db $90, $B2		; 90 B2 ; Branch if carry clear to $90, $B2 [Flow: branch]
	ldx $0E.b		; A6 0E ; Load $0E.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	stx $1000.w		; 8E 00 10 ; Store X register to $1000.w [Reads: X Index]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $D26B.w,X		; BD 6B D2 ; Load $D26B.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $D26E.w,X		; BD 6E D2 ; Load $D26E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	jsr $D7A5.w		; 20 A5 D7 ; Jump to subroutine at $D7A5.w [Writes: Stack Pointer] [Flow: call]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$C0.b		; 29 C0 ; Logical AND #$C0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F4.b		; 05 F4 ; Logical OR $F4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$FC.b		; 29 FC ; Logical AND #$FC.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $5F		; F0 5F ; Branch if equal to $F0, $5F [Flow: branch]
	and #$2C.b		; 29 2C ; Logical AND #$2C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1F		; F0 1F ; Branch if equal to $F0, $1F [Flow: branch]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $0D		; 10 0D ; Branch if plus to $10, $0D [Flow: branch]
	ldx #$02.b		; A2 02 ; Load #$02.b into X register [Writes: X Index] [Flags: NZ]
	.db $80, $09		; 80 09 ; Branch always to $80, $09 [Flow: branch]
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: NCZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	stx $C8.b		; 86 C8 ; Store X register to $C8.b [Reads: X Index]
	.db $80, $3C		; 80 3C ; Branch always to $80, $3C [Flow: branch]
	lda #$2C.b		; A9 2C ; Load #$2C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $2C		; F0 2C ; Branch if equal to $F0, $2C [Flow: branch]
	lda $CA.b,X		; B5 CA ; Load $CA.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $CA.b		; 85 CA ; Store accumulator to $CA.b [Reads: Accumulator]
	stz $CB.b		; 64 CB ; Store zero to $CB.b
	ldx #$30.b		; A2 30 ; Load #$30.b into X register [Writes: X Index] [Flags: NZ]
	lda $D23A.w,X		; BD 3A D2 ; Load $D23A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1036.w,X		; 9D 36 10 ; Store accumulator to $1036.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $13		; D0 13 ; Branch if not equal to $D0, $13 [Flow: branch]
	lda #$62.b		; A9 62 ; Load #$62.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1036.w		; 8D 36 10 ; Store accumulator to $1036.w [Reads: Accumulator]
	sta $103C.w		; 8D 3C 10 ; Store accumulator to $103C.w [Reads: Accumulator]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1037.w		; 8D 37 10 ; Store accumulator to $1037.w [Reads: Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $103D.w		; 8D 3D 10 ; Store accumulator to $103D.w [Reads: Accumulator]
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $D22D.w		; 20 2D D2 ; Jump to subroutine at $D22D.w [Writes: Stack Pointer] [Flow: call]
	stz $C8.b		; 64 C8 ; Store zero to $C8.b
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $C8A6BF.l		; AF BF A6 C8 ; Load long $C8A6BF.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$1C.b		; A9 1C ; Load #$1C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $D36F.w,X		; BD 6F D3 ; Load $D36F.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	jsr $D7A5.w		; 20 A5 D7 ; Jump to subroutine at $D7A5.w [Writes: Stack Pointer] [Flow: call]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$C0.b		; 29 C0 ; Logical AND #$C0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F4.b		; 05 F4 ; Logical OR $F4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$FC.b		; 29 FC ; Logical AND #$FC.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $52		; F0 52 ; Branch if equal to $F0, $52 [Flow: branch]
	and #$2C.b		; 29 2C ; Logical AND #$2C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	and #$24.b		; 29 24 ; Logical AND #$24.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	inc $C8.b		; E6 C8 ; Increment $C8.b [Reads: Direct Page] [Flags: NZ]
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $3D		; 90 3D ; Branch if carry clear to $90, $3D [Flow: branch]
	stz $C8.b		; 64 C8 ; Store zero to $C8.b
	.db $80, $39		; 80 39 ; Branch always to $80, $39 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	dec $C8.b		; C6 C8 ; Decrement $C8.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $30		; 10 30 ; Branch if plus to $10, $30 [Flow: branch]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $C8.b		; 85 C8 ; Store accumulator to $C8.b [Reads: Accumulator]
	.db $80, $2A		; 80 2A ; Branch always to $80, $2A [Flow: branch]
	lda #$2C.b		; A9 2C ; Load #$2C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1C		; D0 1C ; Branch if not equal to $D0, $1C [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	ldx $CA.b		; A6 CA ; Load $CA.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $00848C.l,X		; BF 8C 84 00 ; Load long $00848C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ldx $CC.b		; A6 CC ; Load $CC.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $00848C.l,X		; BF 8C 84 00 ; Load long $00848C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsr $D3DC.w		; 20 DC D3 ; Jump to subroutine at $D3DC.w [Writes: Stack Pointer] [Flow: call]
	ldx $CA.b		; A6 CA ; Load $CA.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda #$0001.w		; A9 01 00 ; Load #$0001.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $BF.b,X		; 95 BF ; Store accumulator to $BF.b,X [Reads: Accumulator, X Index]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	jsr $D22D.w		; 20 2D D2 ; Jump to subroutine at $D22D.w [Writes: Stack Pointer] [Flow: call]
	stz $C8.b		; 64 C8 ; Store zero to $C8.b
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 8
	sep #$20		; E2 20
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	lda #$70.b		; A9 70 ; Load #$70.b into accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda #$0080.w		; A9 80 00 ; Load #$0080.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0000.w,X		; BD 00 00 ; Load $0000.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0000.w,Y		; 99 00 00 ; Store accumulator to $0000.w,Y [Reads: Y Index, Accumulator]
	lda $0100.w,X		; BD 00 01 ; Load $0100.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0100.w,Y		; 99 00 01 ; Store accumulator to $0100.w,Y [Reads: Y Index, Accumulator]
	lda $0200.w,X		; BD 00 02 ; Load $0200.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0200.w,Y		; 99 00 02 ; Store accumulator to $0200.w,Y [Reads: Y Index, Accumulator]
	lda $0300.w,X		; BD 00 03 ; Load $0300.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0300.w,Y		; 99 00 03 ; Store accumulator to $0300.w,Y [Reads: Y Index, Accumulator]
	lda $0400.w,X		; BD 00 04 ; Load $0400.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0400.w,Y		; 99 00 04 ; Store accumulator to $0400.w,Y [Reads: Y Index, Accumulator]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $DA		; D0 DA ; Branch if not equal to $D0, $DA [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	bit $1C.b		; 24 1C ; Test bits $1C.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	adc [$7F.b]		; 67 7F ; Add with carry (long) [$7F.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta [$BF.b],Y		; 97 BF ; Store accumulator (long indexed) [$BF.b],Y [Reads: Direct Page, Y Index, Accumulator]
	adc ($A7.b,X)		; 61 A7 ; Add with carry ($A7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $A9.b		; 24 A9 ; Test bits $A9.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $61.b		; 00 61 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp [$40.b]		; C7 40 ; Compare accumulator (long) [$40.b] [Reads: Direct Page, Accumulator] [Flags: NCZ]
	bit $A9.b		; 24 A9 ; Test bits $A9.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora [$40.b]		; 07 40 ; OR accumulator with memory (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $A9.b		; 24 A9 ; Test bits $A9.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and [$40.b]		; 27 40 ; AND accumulator with memory (long) [$40.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	bit $A9.b		; 24 A9 ; Test bits $A9.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	brk $62.b		; 00 62 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $00.b		; C6 00 ; Decrement $00.b [Reads: Direct Page] [Flags: NZ]
	and ($04.b,X)		; 21 04 ; Logical AND ($04.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $180418.l		; 22 18 04 18 ; Jump to subroutine long $180418.l [Writes: Stack Pointer] [Flow: call]
	lda #$2318.w		; A9 18 23 ; Load #$2318.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $182218.l		; AF 18 22 18 ; Load long $182218.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$0F18.w		; A9 18 0F ; Load #$0F18.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $62, $E6, $00		; 62 E6 00 ; Push effective relative address $62, $E6, $00 [Writes: Stack Pointer]
	and ($14.b,X)		; 21 14 ; Logical AND ($14.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	and ($18.b)		; 32 18 ; AND accumulator with memory (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	lda #$3318.w		; A9 18 33 ; Load #$3318.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $183218.l,X		; BF 18 32 18 ; Load long $183218.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lda #$1F18.w		; A9 18 1F ; Load #$1F18.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $A50C00.l,X		; FF 00 0C A5 ; Subtract with carry (long,X) $A50C00.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($22.b),Y		; 11 22 ; OR accumulator with memory ($22.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	stz $0087.w		; 9C 87 00 ; Store zero to $0087.w
	sbc $0CCD.w,Y		; F9 CD 0C ; Subtract with carry $0CCD.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($CE.b,S),Y		; 53 CE ; XOR accumulator (stack relative indirect indexed) ($CE.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $D49A.w		; 0C 9A D4 ; Test and set bits $D49A.w [Reads: Accumulator] [Flags: Z]
	tsb $D49F.w		; 0C 9F D4 ; Test and set bits $D49F.w [Reads: Accumulator] [Flags: Z]
	tsb $D4B1.w		; 0C B1 D4 ; Test and set bits $D4B1.w [Reads: Accumulator] [Flags: Z]
	tsb $08A9.w		; 0C A9 08 ; Test and set bits $08A9.w [Reads: Accumulator] [Flags: Z]
	jmp $D070.w		; 4C 70 D0 ; Jump to $D070.w [Flow: jump]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$B003.w		; C9 03 B0 ; Compare #$B003.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora $8D.b,S		; 03 8D ; OR accumulator with stack relative $8D.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sta $200B.w,X		; 9D 0B 20 ; Store accumulator to $200B.w,X [Reads: Accumulator, X Index]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	pei ($4C.b)		; D4 4C ; Push effective indirect address ($4C.b) [Reads: Direct Page] [Writes: Stack Pointer]
	stz $8BD0.w		; 9C D0 8B ; Store zero to $8BD0.w
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $D599.w		; 20 99 D5 ; Jump to subroutine at $D599.w [Writes: Stack Pointer] [Flow: call]
	jmp $D09C.w		; 4C 9C D0 ; Jump to $D09C.w [Flow: jump]
.INDEX 16
	rep #$10		; C2 10
	ldx #$00FD.w		; A2 FD 00 ; Load #$00FD.w into X register [Writes: X Index] [Flags: NZ]
	lda $E53E.w,X		; BD 3E E5 ; Load $E53E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1001.w,X		; 9D 01 10 ; Store accumulator to $1001.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $F7		; D0 F7 ; Branch if not equal to $D0, $F7 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	ldx #$0000.w		; A2 00 00 ; Load #$0000.w into X register [Writes: X Index] [Flags: NZ]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	lda $BF.b,X		; B5 BF ; Load $BF.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0001.w		; 29 01 00 ; Logical AND #$0001.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	lda $00848C.l,X		; BF 8C 84 00 ; Load long $00848C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsr $D63C.w		; 20 3C D6 ; Jump to subroutine at $D63C.w [Writes: Stack Pointer] [Flow: call]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$0006.w		; E0 06 00 ; Compare #$0006.w with X register [Reads: X Index] [Flags: NCZ]
	.db $90, $E6		; 90 E6 ; Branch if carry clear to $90, $E6 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $D416.w,X		; BD 16 D4 ; Load $D416.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $D41A.w,X		; BD 1A D4 ; Load $D41A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	jsr $D7A5.w		; 20 A5 D7 ; Jump to subroutine at $D7A5.w [Writes: Stack Pointer] [Flow: call]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $F4.b		; A5 F4 ; Load $F4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$20.b		; 29 20 ; Logical AND #$20.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $25		; D0 25 ; Branch if not equal to $D0, $25 [Flow: branch]
	lda $F4.b		; A5 F4 ; Load $F4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0C.b		; 29 0C ; Logical AND #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $42		; F0 42 ; Branch if equal to $F0, $42 [Flow: branch]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	ldy #$FE.b		; A0 FE ; Load #$FE.b into Y register [Writes: Y Index] [Flags: NZ]
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $30, $0B		; 30 0B ; Branch if minus to $30, $0B [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $00BF.w,Y		; B9 BF 00 ; Load $00BF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $2A		; D0 2A ; Branch if not equal to $D0, $2A [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F5		; 10 F5 ; Branch if plus to $10, $F5 [Flow: branch]
	ldx #$03.b		; A2 03 ; Load #$03.b into X register [Writes: X Index] [Flags: NZ]
	.db $80, $23		; 80 23 ; Branch always to $80, $23 [Flow: branch]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $00BF.w,Y		; B9 BF 00 ; Load $00BF.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $F3		; D0 F3 ; Branch if not equal to $D0, $F3 [Flow: branch]
	.db $80, $08		; 80 08 ; Branch always to $80, $08 [Flow: branch]
	cpx #$04.b		; E0 04 ; Compare #$04.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	.db $80, $E9		; 80 E9 ; Branch always to $80, $E9 [Flow: branch]
	stx $C8.b		; 86 C8 ; Store X register to $C8.b [Reads: X Index]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$C0.b		; 29 C0 ; Logical AND #$C0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F4.b		; 05 F4 ; Logical OR $F4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$D0.b		; 29 D0 ; Logical AND #$D0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $42		; F0 42 ; Branch if equal to $F0, $42 [Flow: branch]
	lda #$2C.b		; A9 2C ; Load #$2C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$03.b		; C9 03 ; Compare #$03.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $32		; F0 32 ; Branch if equal to $F0, $32 [Flow: branch]
	ldx #$64.b		; A2 64 ; Load #$64.b into X register [Writes: X Index] [Flags: NZ]
	lda $D41E.w,X		; BD 1E D4 ; Load $D41E.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $1002.w,X		; 9D 02 10 ; Store accumulator to $1002.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
	inc $11.b		; E6 11 ; Increment $11.b [Reads: Direct Page] [Flags: NZ]
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cpx #$02.b		; E0 02 ; Compare #$02.b with X register [Reads: X Index] [Flags: NCZ]
	.db $F0, $17		; F0 17 ; Branch if equal to $F0, $17 [Flow: branch]
	lda $D483.w,X		; BD 83 D4 ; Load $D483.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$62.b		; A9 62 ; Load #$62.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1002.w,X		; 9D 02 10 ; Store accumulator to $1002.w,X [Reads: Accumulator, X Index]
	sta $1008.w,X		; 9D 08 10 ; Store accumulator to $1008.w,X [Reads: Accumulator, X Index]
	lda #$67.b		; A9 67 ; Load #$67.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1003.w,X		; 9D 03 10 ; Store accumulator to $1003.w,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1009.w,X		; 9D 09 10 ; Store accumulator to $1009.w,X [Reads: Accumulator, X Index]
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $B0.b		; 85 B0 ; Store accumulator to $B0.b [Reads: Accumulator]
	stz $C8.b		; 64 C8 ; Store zero to $C8.b
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	jsr $D22D.w		; 20 2D D2 ; Jump to subroutine at $D22D.w [Writes: Stack Pointer] [Flow: call]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $B0A5BF.l		; AF BF A5 B0 ; Load long $B0A5BF.l into accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	ldx $C8.b		; A6 C8 ; Load $C8.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda #$1C.b		; A9 1C ; Load #$1C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $D597.w,X		; BD 97 D5 ; Load $D597.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $01.b		; 85 01 ; Store accumulator to $01.b [Reads: Accumulator]
	jsr $D7A5.w		; 20 A5 D7 ; Jump to subroutine at $D7A5.w [Writes: Stack Pointer] [Flow: call]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $F4.b		; A5 F4 ; Load $F4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$2C.b		; 29 2C ; Logical AND #$2C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	and #$24.b		; 29 24 ; Logical AND #$24.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $80, $01		; 80 01 ; Branch always to $80, $01 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $C8.b		; 85 C8 ; Store accumulator to $C8.b [Reads: Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$C0.b		; 29 C0 ; Logical AND #$C0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F4.b		; 05 F4 ; Logical OR $F4.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$D0.b		; 29 D0 ; Logical AND #$D0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $5D		; F0 5D ; Branch if equal to $F0, $5D [Flow: branch]
	lda #$2C.b		; A9 2C ; Load #$2C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $4F		; D0 4F ; Branch if not equal to $D0, $4F [Flow: branch]
	lda #$22.b		; A9 22 ; Load #$22.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	stz $012E.w		; 9C 2E 01 ; Store zero to $012E.w
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda $B0.b		; A5 B0 ; Load $B0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	stz $BF.b,X		; 74 BF ; Store zero to $BF.b,X [Reads: X Index]
	lda $00848C.l,X		; BF 8C 84 00 ; Load long $00848C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy #$0000.w		; A0 00 00 ; Load #$0000.w into Y register [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $700000.l,X		; 9F 00 00 70 ; Store accumulator (long,X) $700000.l,X [Reads: Accumulator, X Index]
	sta $700100.l,X		; 9F 00 01 70 ; Store accumulator (long,X) $700100.l,X [Reads: Accumulator, X Index]
	sta $700200.l,X		; 9F 00 02 70 ; Store accumulator (long,X) $700200.l,X [Reads: Accumulator, X Index]
	sta $700300.l,X		; 9F 00 03 70 ; Store accumulator (long,X) $700300.l,X [Reads: Accumulator, X Index]
	sta $700400.l,X		; 9F 00 04 70 ; Store accumulator (long,X) $700400.l,X [Reads: Accumulator, X Index]
	sta $700F00.l,X		; 9F 00 0F 70 ; Store accumulator (long,X) $700F00.l,X [Reads: Accumulator, X Index]
	sta $701000.l,X		; 9F 00 10 70 ; Store accumulator (long,X) $701000.l,X [Reads: Accumulator, X Index]
	sta $701100.l,X		; 9F 00 11 70 ; Store accumulator (long,X) $701100.l,X [Reads: Accumulator, X Index]
	sta $701200.l,X		; 9F 00 12 70 ; Store accumulator (long,X) $701200.l,X [Reads: Accumulator, X Index]
	sta $701300.l,X		; 9F 00 13 70 ; Store accumulator (long,X) $701300.l,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy #$0100.w		; C0 00 01 ; Compare #$0100.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $CF		; D0 CF ; Branch if not equal to $D0, $CF [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	jsr $D22D.w		; 20 2D D2 ; Jump to subroutine at $D22D.w [Writes: Stack Pointer] [Flow: call]
	stz $B0.b		; 64 B0 ; Store zero to $B0.b
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $5C.b		; 00 5C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $16.b		; 00 16 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $6A.b		; 00 6A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $BE.b		; 00 BE ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $DA.b		; 00 DA ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy $00.b		; A4 00 ; Load $00.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda $D630.w,Y		; B9 30 D6 ; Load $D630.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	brk $85.b		; 00 85 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $BF.b		; 02 BF ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp $7003.w,Y		; D9 03 70 ; Compare accumulator $7003.w,Y [Reads: Y Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $1002.w,Y		; 99 02 10 ; Store accumulator to $1002.w,Y [Reads: Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $E810.w		; 2C 10 E8 ; Test bits $E810.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $02.b		; C6 02 ; Decrement $02.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $E6		; D0 E6 ; Branch if not equal to $D0, $E6 [Flow: branch]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	brk $BF.b		; 00 BF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($7003.w)		; 6C 03 70 ; Jump indirect to ($7003.w) [Flow: jump]
	and #$FF.b		; 29 FF ; Logical AND #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $4A.b		; 00 4A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldy $D636.w,X		; BC 36 D6 ; Load Y register $D636.w,X [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	sty $04.b		; 84 04 ; Store Y register to $04.b [Reads: Y Index]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $A2.b		; 05 A2 ; Logical OR $A2.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $99.b		; 00 99 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$2A.b		; 69 2A ; Add #$2A.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $A8.b		; 00 A8 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	dec $02.b		; C6 02 ; Decrement $02.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $EB		; D0 EB ; Branch if not equal to $D0, $EB [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($06.b,X)		; 01 06 ; Logical OR ($06.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	bit $43.b,X		; 34 43 ; Test bits $43.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	adc $83.b,S		; 63 83 ; Add with carry (stack relative) $83.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	bit $8550.w,X		; 3C 50 85 ; Test bits $8550.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	lda ($A1.b,X)		; A1 A1 ; Load accumulator ($A1.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda ($C4.b,X)		; A1 C4 ; Load accumulator ($C4.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$72.b		; E0 72 ; Compare #$72.b with X register [Reads: X Index] [Flags: NCZ]
	ror $7A.b,X		; 76 7A ; Rotate right $7A.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and ($36.b)		; 32 36 ; AND accumulator with memory (indirect) ($36.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $30, $34		; 30 34 ; Branch if minus to $30, $34 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda #$0116.w		; A9 16 01 ; Load #$0116.w into accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	sta $0100.w		; 8D 00 01 ; Store accumulator to $0100.w [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00848C.l,X		; BF 8C 84 00 ; Load long $00848C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0E.b		; 85 0E ; Store accumulator to $0E.b [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D69C.w,Y		; B9 9C D6 ; Load $D69C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda ($04.b)		; B2 04 ; Load accumulator (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0C.b		; 69 0C ; Add #$0C.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0800.w,X		; 9D 00 08 ; Store accumulator to $0800.w,X [Reads: Accumulator, X Index]
	sta $0804.w,X		; 9D 04 08 ; Store accumulator to $0804.w,X [Reads: Accumulator, X Index]
	lda ($02.b),Y		; B1 02 ; Load accumulator ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$FB.b		; 69 FB ; Add #$FB.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0801.w,X		; 9D 01 08 ; Store accumulator to $0801.w,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0805.w,X		; 9D 05 08 ; Store accumulator to $0805.w,X [Reads: Accumulator, X Index]
	lda $D6A6.w,Y		; B9 A6 D6 ; Load $D6A6.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0803.w,X		; 9D 03 08 ; Store accumulator to $0803.w,X [Reads: Accumulator, X Index]
	sta $0807.w,X		; 9D 07 08 ; Store accumulator to $0807.w,X [Reads: Accumulator, X Index]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.INDEX 16
	rep #$10		; C2 10
	ldx $0E.b		; A6 0E ; Load $0E.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $700359.l,X		; BF 59 03 70 ; Load long $700359.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.INDEX 8
	sep #$10		; E2 10
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $09		; 10 09 ; Branch if plus to $10, $09 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0801.w,X		; 9D 01 08 ; Store accumulator to $0801.w,X [Reads: Accumulator, X Index]
	sta $0805.w,X		; 9D 05 08 ; Store accumulator to $0805.w,X [Reads: Accumulator, X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $D69F.w,Y		; B9 9F D6 ; Load $D69F.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0802.w,X		; 9D 02 08 ; Store accumulator to $0802.w,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0806.w,X		; 9D 06 08 ; Store accumulator to $0806.w,X [Reads: Accumulator, X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0A20.w,X		; 9D 20 0A ; Store accumulator to $0A20.w,X [Reads: Accumulator, X Index]
	sta $0A21.w,X		; 9D 21 0A ; Store accumulator to $0A21.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda ($04.b)		; B2 04 ; Load accumulator (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$FB.b		; 69 FB ; Add #$FB.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0800.w,X		; 9D 00 08 ; Store accumulator to $0800.w,X [Reads: Accumulator, X Index]
	lda ($02.b),Y		; B1 02 ; Load accumulator ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0A.b		; 69 0A ; Add #$0A.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0801.w,X		; 9D 01 08 ; Store accumulator to $0801.w,X [Reads: Accumulator, X Index]
	lda $D6A9.w,Y		; B9 A9 D6 ; Load $D6A9.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0803.w,X		; 9D 03 08 ; Store accumulator to $0803.w,X [Reads: Accumulator, X Index]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.INDEX 16
	rep #$10		; C2 10
	ldx $0E.b		; A6 0E ; Load $0E.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $70035A.l,X		; BF 5A 03 70 ; Load long $70035A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.INDEX 8
	sep #$10		; E2 10
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	lda #$F0.b		; A9 F0 ; Load #$F0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0801.w,X		; 9D 01 08 ; Store accumulator to $0801.w,X [Reads: Accumulator, X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $D6A3.w,Y		; B9 A3 D6 ; Load $D6A3.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0802.w,X		; 9D 02 08 ; Store accumulator to $0802.w,X [Reads: Accumulator, X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0A20.w,X		; 9D 20 0A ; Store accumulator to $0A20.w,X [Reads: Accumulator, X Index]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda ($04.b)		; B2 04 ; Load accumulator (indirect) ($04.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0800.w,X		; 9D 00 08 ; Store accumulator to $0800.w,X [Reads: Accumulator, X Index]
	sta $0804.w,X		; 9D 04 08 ; Store accumulator to $0804.w,X [Reads: Accumulator, X Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0802.w,X		; 9D 02 08 ; Store accumulator to $0802.w,X [Reads: Accumulator, X Index]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0806.w,X		; 9D 06 08 ; Store accumulator to $0806.w,X [Reads: Accumulator, X Index]
	lda $D6AC.w,Y		; B9 AC D6 ; Load $D6AC.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0803.w,X		; 9D 03 08 ; Store accumulator to $0803.w,X [Reads: Accumulator, X Index]
	ora #$40.b		; 09 40 ; Logical OR #$40.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0807.w,X		; 9D 07 08 ; Store accumulator to $0807.w,X [Reads: Accumulator, X Index]
	lda ($02.b),Y		; B1 02 ; Load accumulator ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0801.w,X		; 9D 01 08 ; Store accumulator to $0801.w,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0805.w,X		; 9D 05 08 ; Store accumulator to $0805.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0A20.w,X		; 9D 20 0A ; Store accumulator to $0A20.w,X [Reads: Accumulator, X Index]
	sta $0A21.w,X		; 9D 21 0A ; Store accumulator to $0A21.w,X [Reads: Accumulator, X Index]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0800.w		; 8D 00 08 ; Store accumulator to $0800.w [Reads: Accumulator]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0801.w		; 8D 01 08 ; Store accumulator to $0801.w [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx #$A500.w		; A2 00 A5 ; Load #$A500.w into X register [Writes: X Index] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	and #$F008.w		; 29 08 F0 ; Logical AND #$F008.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($E8.b,X)		; 01 E8 ; Logical OR ($E8.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda $D7A3.w,X		; BD A3 D7 ; Load $D7A3.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0802.w		; 8D 02 08 ; Store accumulator to $0802.w [Reads: Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$8D7E.w		; A9 7E 8D ; Load #$8D7E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $08.b,S		; 03 08 ; OR accumulator with stack relative $08.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$8D02.w		; A9 02 8D ; Load #$8D02.w into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $600A.w		; 20 0A 60 ; Jump to subroutine at $600A.w [Writes: Stack Pointer] [Flow: call]
	.db $D0, $AC		; D0 AC ; Branch if not equal to $D0, $AC [Flow: branch]
	lda $BDBC.w		; AD BC BD ; Load $BDBC.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $BEAF.w		; AE AF BE ; Load $BEAF.w into X register [Writes: X Index] [Flags: NZ]
	lda $1004C0.l,X		; BF C0 04 10 ; Load long $1004C0.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $040C.w		; 1C 0C 04 ; Test and reset bits $040C.w [Reads: Accumulator] [Flags: Z]
	jsr ($30C2.w,X)		; FC C2 30 ; Jump to subroutine indirect indexed ($30C2.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	sta $0A.b		; 85 0A ; Store accumulator to $0A.b [Reads: Accumulator]
	ldx $0E.b		; A6 0E ; Load $0E.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $700405.l,X		; BF 05 04 70 ; Load long $700405.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$FFFF.w		; C9 FF FF ; Compare #$FFFF.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $D883.w		; 4C 83 D8 ; Jump to $D883.w [Flow: jump]
	cmp #$03E8.w		; C9 E8 03 ; Compare #$03E8.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $0B		; 90 0B ; Branch if carry clear to $90, $0B [Flow: branch]
	lda #$0009.w		; A9 09 00 ; Load #$0009.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	.db $80, $25		; 80 25 ; Branch always to $80, $25 [Flow: branch]
	ldy #$0000.w		; A0 00 00 ; Load #$0000.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp #$000A.w		; C9 0A 00 ; Compare #$000A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $07		; 90 07 ; Branch if carry clear to $90, $07 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$000A.w		; E9 0A 00 ; Subtract #$000A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $80, $F4		; 80 F4 ; Branch always to $80, $F4 [Flow: branch]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ldy #$0000.w		; A0 00 00 ; Load #$0000.w into Y register [Writes: Y Index] [Flags: NZ]
	cmp #$000A.w		; C9 0A 00 ; Compare #$000A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $07		; 90 07 ; Branch if carry clear to $90, $07 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$000A.w		; E9 0A 00 ; Subtract #$000A.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $80, $F4		; 80 F4 ; Branch always to $80, $F4 [Flow: branch]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	sty $06.b		; 84 06 ; Store Y register to $06.b [Reads: Y Index]
	ldx #$0004.w		; A2 04 00 ; Load #$0004.w into X register [Writes: X Index] [Flags: NZ]
	lda $06.b		; A5 06 ; Load $06.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda $04.b		; A5 04 ; Load $04.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $D7D5.w,Y		; B9 D5 D7 ; Load $D7D5.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	lda $02.b,X		; B5 02 ; Load $02.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $D7CB.w,X		; BD CB D7 ; Load $D7CB.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0802.w,Y		; 99 02 08 ; Store accumulator to $0802.w,Y [Reads: Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($08.b),Y		; B1 08 ; Load accumulator ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	sta $0801.w,Y		; 99 01 08 ; Store accumulator to $0801.w,Y [Reads: Y Index, Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda ($0A.b)		; B2 0A ; Load accumulator (indirect) ($0A.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $D7D8.w,X		; 7D D8 D7 ; Add $D7D8.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0800.w,Y		; 99 00 08 ; Store accumulator to $0800.w,Y [Reads: Y Index, Accumulator]
	lda #$3C.b		; A9 3C ; Load #$3C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0803.w,Y		; 99 03 08 ; Store accumulator to $0803.w,Y [Reads: Y Index, Accumulator]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0A20.w,Y		; 99 20 0A ; Store accumulator to $0A20.w,Y [Reads: Y Index, Accumulator]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $C2		; 10 C2 ; Branch if plus to $10, $C2 [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $11.b		; A5 11 ; Load $11.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	jsl $00879C.l		; 22 9C 87 00 ; Jump to subroutine long $00879C.l [Writes: Stack Pointer] [Flow: call]
	stz $0CD8.w		; 9C D8 0C ; Store zero to $0CD8.w
	ora ($D9.b),Y		; 11 D9 ; OR accumulator with memory ($D9.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $D928.w		; 0C 28 D9 ; Test and set bits $D928.w [Reads: Accumulator] [Flags: Z]
	tsb $DA4D.w		; 0C 4D DA ; Test and set bits $DA4D.w [Reads: Accumulator] [Flags: Z]
	tsb $F922.w		; 0C 22 F9 ; Test and set bits $F922.w [Reads: Accumulator] [Flags: Z]
	cmp $A90C.w		; CD 0C A9 ; Compare $A90C.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	ora ($8D.b,X)		; 01 8D ; Logical OR ($8D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	plp		; [PATTERN: Memory clearing operation] 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora ($9C.b,X)		; 01 9C ; Logical OR ($9C.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $10, $0B		; 10 0B ; Branch if plus to $10, $0B [Flow: branch]
	stz $0B12.w		; 9C 12 0B ; Store zero to $0B12.w
	stz $0B15.w		; 9C 15 0B ; Store zero to $0B15.w
	stz $00CA.w		; [PATTERN: Memory clearing operation] 9C CA 00 ; Store zero to $00CA.w
	stz $00CC.w		; 9C CC 00 ; Store zero to $00CC.w
	lda #$8D83.w		; A9 83 8D ; Load #$8D83.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($0B.b),Y		; 11 0B ; OR accumulator with memory ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda #$01F0.w		; A9 F0 01 ; Load #$01F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0630.w		; 8D 30 06 ; Store accumulator to $0630.w [Reads: Accumulator]
	stz $E4.b		; 64 E4 ; Store zero to $E4.b
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00848C.l,X		; BF 8C 84 00 ; Load long $00848C.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0200.w		; 8D 00 02 ; Store accumulator to $0200.w [Reads: Accumulator]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	ldy #$0000.w		; A0 00 00 ; Load #$0000.w into Y register [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $700000.l,X		; 9F 00 00 70 ; Store accumulator (long,X) $700000.l,X [Reads: Accumulator, X Index]
	sta $700100.l,X		; 9F 00 01 70 ; Store accumulator (long,X) $700100.l,X [Reads: Accumulator, X Index]
	sta $700200.l,X		; 9F 00 02 70 ; Store accumulator (long,X) $700200.l,X [Reads: Accumulator, X Index]
	sta $700300.l,X		; 9F 00 03 70 ; Store accumulator (long,X) $700300.l,X [Reads: Accumulator, X Index]
	sta $700400.l,X		; 9F 00 04 70 ; Store accumulator (long,X) $700400.l,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy #$0100.w		; C0 00 01 ; Compare #$0100.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $E3		; D0 E3 ; Branch if not equal to $D0, $E3 [Flow: branch]
	ldx $0200.w		; AE 00 02 ; Load $0200.w into X register [Writes: X Index] [Flags: NZ]
	lda #$00A9.w		; A9 A9 00 ; Load #$00A9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7003D9.l,X		; 9F D9 03 70 ; Store accumulator (long,X) $7003D9.l,X [Reads: Accumulator, X Index]
	sta $7003DB.l,X		; 9F DB 03 70 ; Store accumulator (long,X) $7003DB.l,X [Reads: Accumulator, X Index]
	sta $7003DD.l,X		; 9F DD 03 70 ; Store accumulator (long,X) $7003DD.l,X [Reads: Accumulator, X Index]
	sta $7003DF.l,X		; 9F DF 03 70 ; Store accumulator (long,X) $7003DF.l,X [Reads: Accumulator, X Index]
	sta $7003E1.l,X		; 9F E1 03 70 ; Store accumulator (long,X) $7003E1.l,X [Reads: Accumulator, X Index]
	sta $7003E3.l,X		; 9F E3 03 70 ; Store accumulator (long,X) $7003E3.l,X [Reads: Accumulator, X Index]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	jsr $CE1B.w		; 20 1B CE ; Jump to subroutine at $CE1B.w [Writes: Stack Pointer] [Flow: call]
	lda #$FFFF.w		; A9 FF FF ; Load #$FFFF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1006.w,X		; 9D 06 10 ; Store accumulator to $1006.w,X [Reads: Accumulator, X Index]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $C52E.w		; 20 2E C5 ; Jump to subroutine at $C52E.w [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr $C52E.w		; 20 2E C5 ; Jump to subroutine at $C52E.w [Writes: Stack Pointer] [Flow: call]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $13.b		; 85 13 ; Store accumulator to $13.b [Reads: Accumulator]
	stz $0710.w		; 9C 10 07 ; Store zero to $0710.w
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $07.b		; 06 07 ; Arithmetic shift left $07.b [Reads: Direct Page] [Flags: NCZ]
	eor $595909.l,X		; 5F 09 59 59 ; Exclusive OR accumulator with memory (long,X) $595909.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	trb $1E1D.w		; 1C 1D 1E ; Test and reset bits $1E1D.w [Reads: Accumulator] [Flags: Z]
	ora $602120.l,X		; 1F 20 21 60 ; Logical OR long $602120.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $59.b,S		; 23 59 ; AND accumulator with stack relative $59.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $7776.w,Y		; 59 76 77 ; Exclusive OR accumulator with memory $7776.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	adc $597A.w,Y		; 79 7A 59 ; Add $597A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $0059.w,Y		; 59 59 00 ; Exclusive OR accumulator with memory $0059.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $10.b		; 05 10 ; Logical OR $10.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($12.b),Y		; 11 12 ; OR accumulator with memory ($12.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($59.b,S),Y		; 13 59 ; OR accumulator (stack relative indirect indexed) ($59.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor $5F24.w,Y		; 59 24 5F ; Exclusive OR accumulator with memory $5F24.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $27.b		; 26 27 ; Rotate left $27.b [Reads: Direct Page] [Flags: NCZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	and #$2A.b		; 29 2A ; Logical AND #$2A.b with accumulator [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	bit $592D.w		; 2C 2D 59 ; Test bits $592D.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	eor $7C7B.w,Y		; 59 7B 7C ; Exclusive OR accumulator with memory $7C7B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $7F7E.w,X		; 7D 7E 7F ; Add $7F7E.w,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $5959.w,Y		; 59 59 59 ; Exclusive OR accumulator with memory $5959.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	tsb $0E0D.w		; 0C 0D 0E ; Test and set bits $0E0D.w [Reads: Accumulator] [Flags: Z]
	ora $424140.l		; 0F 40 41 42 ; OR accumulator with memory (long) $424140.l [Writes: Accumulator] [Flags: NZ]
	eor $5959.w,Y		; 59 59 59 ; Exclusive OR accumulator with memory $5959.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $302F.w		; 2E 2F 30 ; Rotate left $302F.w [Flags: NCZ]
	and ($32.b),Y		; 31 32 ; AND accumulator with memory ($32.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($40.b,S),Y		; 33 40 ; AND accumulator (stack relative indirect indexed) ($40.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	eor ($42.b,X)		; 41 42 ; Exclusive OR accumulator with memory ($42.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $5959.w,Y		; 59 59 59 ; Exclusive OR accumulator with memory $5959.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($3F.b,X)		; 61 3F ; Add with carry ($3F.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor $46.b		; 45 46 ; Exclusive OR $46.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	eor $5959.w,Y		; 59 59 59 ; Exclusive OR accumulator with memory $5959.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $1514.w,Y		; 59 14 15 ; Exclusive OR accumulator with memory $1514.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $17.b,X		; 16 17 ; Arithmetic shift left $17.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $5944.w,Y		; 19 44 59 ; OR accumulator with memory $5944.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $59596F.l		; 6F 6F 59 59 ; Add with carry (long) $59596F.l [Writes: Accumulator] [Flags: NCVZ]
	eor $5959.w,Y		; 59 59 59 ; Exclusive OR accumulator with memory $5959.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $5A59.w,Y		; 59 59 5A ; Exclusive OR accumulator with memory $5A59.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvp $6F,$59		; 44 59 6F ; Move block positive $6F,$59 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc $5A5959.l		; 6F 59 59 5A ; Add with carry (long) $5A5959.l [Writes: Accumulator] [Flags: NCVZ]
	mvp $6F,$59		; 44 59 6F ; Move block positive $6F,$59 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	adc $595959.l		; 6F 59 59 59 ; Add with carry (long) $595959.l [Writes: Accumulator] [Flags: NCVZ]
	eor $5959.w,Y		; 59 59 59 ; Exclusive OR accumulator with memory $5959.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $5A59.w,Y		; 59 59 5A ; Exclusive OR accumulator with memory $5A59.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $01		; F0 01 ; Branch if equal to $F0, $01 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	jsr $3000.w		; 20 00 30 ; Jump to subroutine at $3000.w [Writes: Stack Pointer] [Flow: call]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $90.b		; 00 90 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $A0.b		; 00 A0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $C0.b		; 00 C0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $D0.b		; 00 D0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $E0.b		; 00 E0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $F0.b		; 00 F0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($10.b,X)		; 01 10 ; Logical OR ($10.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($20.b,X)		; 01 20 ; Logical OR ($20.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($30.b,X)		; 01 30 ; Logical OR ($30.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($40.b,X)		; 01 40 ; Logical OR ($40.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($50.b,X)		; 01 50 ; Logical OR ($50.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($60.b,X)		; 01 60 ; Logical OR ($60.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($70.b,X)		; 01 70 ; Logical OR ($70.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($90.b,X)		; 01 90 ; Logical OR ($90.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($A0.b,X)		; 01 A0 ; Logical OR ($A0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($B0.b,X)		; 01 B0 ; Logical OR ($B0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($C0.b,X)		; 01 C0 ; Logical OR ($C0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($D0.b,X)		; 01 D0 ; Logical OR ($D0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($E0.b,X)		; 01 E0 ; Logical OR ($E0.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $83.b		; 00 83 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($A3.b,S),Y		; 93 A3 ; Store accumulator (stack relative indirect indexed) ($A3.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	lda ($01.b,S),Y		; B3 01 ; Load accumulator (stack relative indirect indexed) ($01.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $00FF04.l,X		; FF 04 FF 00 ; Subtract with carry (long,X) $00FF04.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b,S		; 03 00 ; OR accumulator with stack relative $00.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $20.b		; 00 20 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $5F4F3F.l		; 2F 3F 4F 5F ; AND accumulator with memory (long) $5F4F3F.l [Writes: Accumulator] [Flags: NZ]
	adc $01FFFF.l		; 6F FF FF 01 ; Add with carry (long) $01FFFF.l [Writes: Accumulator] [Flags: NCVZ]
	brk $FF.b		; 00 FF ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $FF0001.l,X		; FF 01 00 FF ; Subtract with carry (long,X) $FF0001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF0001.l,X		; FF 01 00 FF ; Subtract with carry (long,X) $FF0001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF0001.l,X		; FF 01 00 FF ; Subtract with carry (long,X) $FF0001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF0001.l,X		; FF 01 00 FF ; Subtract with carry (long,X) $FF0001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF0001.l,X		; FF 01 00 FF ; Subtract with carry (long,X) $FF0001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FF0001.l,X		; FF 01 00 FF ; Subtract with carry (long,X) $FF0001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FE0001.l,X		; FF 01 00 FE ; Subtract with carry (long,X) $FE0001.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FE0002.l,X		; FF 02 00 FE ; Subtract with carry (long,X) $FE0002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FE0002.l,X		; FF 02 00 FE ; Subtract with carry (long,X) $FE0002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FE0002.l,X		; FF 02 00 FE ; Subtract with carry (long,X) $FE0002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FC0002.l,X		; FF 02 00 FC ; Subtract with carry (long,X) $FC0002.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $AC0004.l,X		; FF 04 00 AC ; Subtract with carry (long,X) $AC0004.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($0B.b,S),Y		; 13 0B ; OR accumulator (stack relative indirect indexed) ($0B.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $4D		; F0 4D ; Branch if equal to $F0, $4D [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$31.b		; C9 31 ; Compare #$31.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0B13.w		; 8D 13 0B ; Store accumulator to $0B13.w [Reads: Accumulator]
	lda $0B10.w		; AD 10 0B ; Load $0B10.w into accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $0630.w		; AD 30 06 ; Load $0630.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $0CD9B5.l,X		; DF B5 D9 0C ; Compare accumulator (long,X) $0CD9B5.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	lda #$30.b		; A9 30 ; Load #$30.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B13.w		; 8D 13 0B ; Store accumulator to $0B13.w [Reads: Accumulator]
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0B13.w		; 9C 13 0B ; Store zero to $0B13.w
	jsr $DC8C.w		; 20 8C DC ; Jump to subroutine at $DC8C.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $CA		; 80 CA ; Branch always to $80, $CA [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	ldx $0B16.w		; AE 16 0B ; Load $0B16.w into X register [Writes: X Index] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	lda $0630.w		; AD 30 06 ; Load $0630.w into accumulator [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0CDA19.l,X		; 7F 19 DA 0C ; Add long $0CDA19.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and #$01FF.w		; 29 FF 01 ; Logical AND #$01FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0630.w		; 8D 30 06 ; Store accumulator to $0630.w [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $DC8C.w		; 20 8C DC ; Jump to subroutine at $DC8C.w [Writes: Stack Pointer] [Flow: call]
	lda $0B14.w		; AD 14 0B ; Load $0B14.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $24		; F0 24 ; Branch if equal to $F0, $24 [Flow: branch]
	ldx $0B15.w		; AE 15 0B ; Load $0B15.w into X register [Writes: X Index] [Flags: NZ]
	ldy #$02.b		; A0 02 ; Load #$02.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $0B11.w		; AD 11 0B ; Load $0B11.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp $0CDA01.l,X		; DF 01 DA 0C ; Compare accumulator (long,X) $0CDA01.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $D0, $08		; D0 08 ; Branch if not equal to $D0, $08 [Flow: branch]
	stz $0B14.w		; 9C 14 0B ; Store zero to $0B14.w
	jsr $DCBF.w		; 20 BF DC ; Jump to subroutine at $DCBF.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $E5		; 80 E5 ; Branch always to $80, $E5 [Flow: branch]
	.db $30, $02		; 30 02 ; Branch if minus to $30, $02 [Flow: branch]
	ldy #$FE.b		; A0 FE ; Load #$FE.b into Y register [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B11.w		; 6D 11 0B ; Add $0B11.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0B11.w		; 8D 11 0B ; Store accumulator to $0B11.w [Reads: Accumulator]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	jsr $DCBF.w		; 20 BF DC ; Jump to subroutine at $DCBF.w [Writes: Stack Pointer] [Flow: call]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	txy		; 9B ; Transfer X to Y [Reads: X Index] [Writes: Y Index] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0800.w,Y		; 99 00 08 ; Store accumulator to $0800.w,Y [Reads: Y Index, Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0B11.w		; AD 11 0B ; Load $0B11.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0801.w,Y		; 99 01 08 ; Store accumulator to $0801.w,Y [Reads: Y Index, Accumulator]
	lda #$2E.b		; A9 2E ; Load #$2E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0802.w,Y		; 99 02 08 ; Store accumulator to $0802.w,Y [Reads: Y Index, Accumulator]
	lda #$3C.b		; A9 3C ; Load #$3C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0803.w,Y		; 99 03 08 ; Store accumulator to $0803.w,Y [Reads: Y Index, Accumulator]
	stz $0A20.w,X		; 9E 20 0A ; Store zero to $0A20.w,X [Reads: X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$1A.b		; E0 1A ; Compare #$1A.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $DA		; D0 DA ; Branch if not equal to $D0, $DA [Flow: branch]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	ldx $0B12.w		; AE 12 0B ; Load $0B12.w into X register [Writes: X Index] [Flags: NZ]
	lda $0CDA13.l,X		; BF 13 DA 0C ; Load long $0CDA13.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0800.w,Y		; 99 00 08 ; Store accumulator to $0800.w,Y [Reads: Y Index, Accumulator]
	lda #$58.b		; A9 58 ; Load #$58.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0801.w,Y		; 99 01 08 ; Store accumulator to $0801.w,Y [Reads: Y Index, Accumulator]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	lda #$29.b		; A9 29 ; Load #$29.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0802.w,Y		; 99 02 08 ; Store accumulator to $0802.w,Y [Reads: Y Index, Accumulator]
	lda #$0C.b		; A9 0C ; Load #$0C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0803.w,Y		; 99 03 08 ; Store accumulator to $0803.w,Y [Reads: Y Index, Accumulator]
	stz $0A20.w,X		; 9E 20 0A ; Store zero to $0A20.w,X [Reads: X Index]
	lda $0B13.w		; AD 13 0B ; Load $0B13.w into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0B14.w		; 0D 14 0B ; Logical OR $0B14.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $15		; D0 15 ; Branch if not equal to $D0, $15 [Flow: branch]
	lda $F4.b		; A5 F4 ; Load $F4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$10.b		; 29 10 ; Logical AND #$10.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	jmp $DBB1.w		; 4C B1 DB ; Jump to $DBB1.w [Flow: jump]
	lda $F4.b		; A5 F4 ; Load $F4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$C0.b		; 29 C0 ; Logical AND #$C0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $09		; D0 09 ; Branch if not equal to $D0, $09 [Flow: branch]
	lda $F6.b		; A5 F6 ; Load $F6.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$C0.b		; 29 C0 ; Logical AND #$C0.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $DBD9.w		; 4C D9 DB ; Jump to $DBD9.w [Flow: jump]
	lda #$2B.b		; A9 2B ; Load #$2B.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda $0B15.w		; AD 15 0B ; Load $0B15.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0CDA0B.l,X		; BF 0B DA 0C ; Load long $0CDA0B.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B10.w		; 6D 10 0B ; Add $0B10.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	lda $0CD935.l,X		; BF 35 D9 0C ; Load long $0CD935.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$5A.b		; C9 5A ; Compare #$5A.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	cmp #$44.b		; C9 44 ; Compare #$44.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $1B		; F0 1B ; Branch if equal to $F0, $1B [Flow: branch]
	cmp #$6F.b		; C9 6F ; Compare #$6F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $4B		; F0 4B ; Branch if equal to $F0, $4B [Flow: branch]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	stz $01.b		; 64 01 ; Store zero to $01.b
	.db $80, $20		; 80 20 ; Branch always to $80, $20 [Flow: branch]
	lda $0B12.w		; AD 12 0B ; Load $0B12.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	lda #$05.b		; A9 05 ; Load #$05.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0B12.w		; 8D 12 0B ; Store accumulator to $0B12.w [Reads: Accumulator]
	.db $80, $61		; 80 61 ; Branch always to $80, $61 [Flow: branch]
	dec $0B12.w		; CE 12 0B ; Decrement $0B12.w [Flags: NZ]
	.db $80, $5C		; 80 5C ; Branch always to $80, $5C [Flow: branch]
	inc $0B12.w		; EE 12 0B ; Increment $0B12.w [Flags: NZ]
	lda $0B12.w		; AD 12 0B ; Load $0B12.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	stz $0B12.w		; 9C 12 0B ; Store zero to $0B12.w
	.db $80, $4D		; 80 4D ; Branch always to $80, $4D [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	and #$000F.w		; 29 0F 00 ; Logical AND #$000F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0B12.w		; AD 12 0B ; Load $0B12.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0200.w		; 6D 00 02 ; Add $0200.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$FFF0.w		; 29 F0 FF ; Logical AND #$FFF0.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $02.b		; 05 02 ; Logical OR $02.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $7003D9.l,X		; 9F D9 03 70 ; Store accumulator (long,X) $7003D9.l,X [Reads: Accumulator, X Index]
	jsr $DD30.w		; 20 30 DD ; Jump to subroutine at $DD30.w [Writes: Stack Pointer] [Flow: call]
	.db $80, $CC		; 80 CC ; Branch always to $80, $CC [Flow: branch]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	stz $02.b		; 64 02 ; Store zero to $02.b
	lda $0200.w		; AD 00 02 ; Load $0200.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $02.b		; 65 02 ; Add $02.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $7003D9.l,X		; BF D9 03 70 ; Load long $7003D9.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$00A9.w		; C9 A9 00 ; Compare #$00A9.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $17		; D0 17 ; Branch if not equal to $D0, $17 [Flow: branch]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$000A.w		; C9 0A 00 ; Compare #$000A.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $06		; F0 06 ; Branch if equal to $F0, $06 [Flow: branch]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	.db $80, $E3		; 80 E3 ; Branch always to $80, $E3 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	lda #$3C.b		; A9 3C ; Load #$3C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $701FFE.l		; 8F FE 1F 70 ; Store accumulator (long) $701FFE.l [Reads: Accumulator]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $00848A.l,X		; BF 8A 84 00 ; Load long $00848A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$55AA.w		; A9 AA 55 ; Load #$55AA.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7003E5.l,X		; 9F E5 03 70 ; Store accumulator (long,X) $7003E5.l,X [Reads: Accumulator, X Index]
	lda #$F000.w		; A9 00 F0 ; Load #$F000.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $70020C.l,X		; 9F 0C 02 70 ; Store accumulator (long,X) $70020C.l,X [Reads: Accumulator, X Index]
	sta $70020E.l,X		; 9F 0E 02 70 ; Store accumulator (long,X) $70020E.l,X [Reads: Accumulator, X Index]
	lda #$FFFF.w		; A9 FF FF ; Load #$FFFF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $700405.l,X		; 9F 05 04 70 ; Store accumulator (long,X) $700405.l,X [Reads: Accumulator, X Index]
	lda #$001D.w		; A9 1D 00 ; Load #$001D.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	ldy #$003C.w		; A0 3C 00 ; Load #$003C.w into Y register [Writes: Y Index] [Flags: NZ]
	cpx #$0000.w		; E0 00 00 ; Compare #$0000.w with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $2D		; D0 2D ; Branch if not equal to $D0, $2D [Flow: branch]
	lda $0083F8.l		; AF F8 83 00 ; Load long $0083F8.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0060.w		; C9 60 00 ; Compare #$0060.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $21		; F0 21 ; Branch if equal to $F0, $21 [Flow: branch]
	lda $7003D9.l		; AF D9 03 70 ; Load long $7003D9.l into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0001.w		; C9 01 00 ; Compare #$0001.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $18		; D0 18 ; Branch if not equal to $D0, $18 [Flow: branch]
	lda #$00F0.w		; A9 F0 00 ; Load #$00F0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $700212.l,X		; 9F 12 02 70 ; Store accumulator (long,X) $700212.l,X [Reads: Accumulator, X Index]
	lda #$1502.w		; A9 02 15 ; Load #$1502.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7003C5.l,X		; 9F C5 03 70 ; Store accumulator (long,X) $7003C5.l,X [Reads: Accumulator, X Index]
	lda #$0100.w		; A9 00 01 ; Load #$0100.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7003C7.l,X		; 9F C7 03 70 ; Store accumulator (long,X) $7003C7.l,X [Reads: Accumulator, X Index]
	ldy #$0000.w		; A0 00 00 ; Load #$0000.w into Y register [Writes: Y Index] [Flags: NZ]
	lda $F48A.w,Y		; B9 8A F4 ; Load $F48A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $700340.l,X		; 9F 40 03 70 ; Store accumulator (long,X) $700340.l,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dec $02.b		; C6 02 ; Decrement $02.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $F1		; 10 F1 ; Branch if plus to $10, $F1 [Flow: branch]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	ldy #$0000.w		; A0 00 00 ; Load #$0000.w into Y register [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $700000.l,X		; 7F 00 00 70 ; Add long $700000.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	cpy #$027F.w		; C0 7F 02 ; Compare #$027F.w with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $F3		; D0 F3 ; Branch if not equal to $D0, $F3 [Flow: branch]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda #$5A5A.w		; A9 5A 5A ; Load #$5A5A.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $02.b		; E5 02 ; Subtract $02.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $7004FE.l,X		; 9F FE 04 70 ; Store accumulator (long,X) $7004FE.l,X [Reads: Accumulator, X Index]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	jsr $D22D.w		; 20 2D D2 ; Jump to subroutine at $D22D.w [Writes: Stack Pointer] [Flow: call]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0128.w		; 8D 28 01 ; Store accumulator to $0128.w [Reads: Accumulator]
	lda #$2C.b		; A9 2C ; Load #$2C.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $28		; F0 28 ; Branch if equal to $F0, $28 [Flow: branch]
	inc $0B13.w		; EE 13 0B ; Increment $0B13.w [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $0B16.w		; 8D 16 0B ; Store accumulator to $0B16.w [Reads: Accumulator]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0B10.w		; AD 10 0B ; Load $0B10.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0CD9F5.l,X		; 7F F5 D9 0C ; Add long $0CD9F5.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $0CD9F9.l,X		; DF F9 D9 0C ; Compare accumulator (long,X) $0CD9F9.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	lda $0CD9FD.l,X		; BF FD D9 0C ; Load long $0CD9FD.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	sta $0B10.w		; 8D 10 0B ; Store accumulator to $0B10.w [Reads: Accumulator]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $F0.b		; A5 F0 ; Load $F0.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0C.b		; 29 0C ; Logical AND #$0C.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $55		; F0 55 ; Branch if equal to $F0, $55 [Flow: branch]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0B15.w		; 0D 15 0B ; Logical OR $0B15.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$10.b		; C9 10 ; Compare #$10.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $4E		; F0 4E ; Branch if equal to $F0, $4E [Flow: branch]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $0B15.w		; 0D 15 0B ; Logical OR $0B15.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $0B10.w		; AE 10 0B ; Load $0B10.w into X register [Writes: X Index] [Flags: NZ]
	cmp #$13.b		; C9 13 ; Compare #$13.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $40		; F0 40 ; Branch if equal to $F0, $40 [Flow: branch]
	lda $02.b		; A5 02 ; Load $02.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0B15.w		; AD 15 0B ; Load $0B15.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0CDA04.l,X		; 7F 04 DA 0C ; Add long $0CDA04.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $0CDA06.l,X		; DF 06 DA 0C ; Compare accumulator (long,X) $0CDA06.l,X [Reads: Accumulator, X Index] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	lda $0CDA08.l,X		; BF 08 DA 0C ; Load long $0CDA08.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0B15.w		; 8D 15 0B ; Store accumulator to $0B15.w [Reads: Accumulator]
	.db $80, $1C		; 80 1C ; Branch always to $80, $1C [Flow: branch]
	stx $01.b		; 86 01 ; Store X register to $01.b [Reads: X Index]
	ldx $0B15.w		; AE 15 0B ; Load $0B15.w into X register [Writes: X Index] [Flags: NZ]
	lda $0CDA0B.l,X		; BF 0B DA 0C ; Load long $0CDA0B.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0B10.w		; 6D 10 0B ; Add $0B10.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	and #$FF.b		; 29 FF ; Logical AND #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0CD935.l,X		; BF 35 D9 0C ; Load long $0CD935.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cmp #$59.b		; C9 59 ; Compare #$59.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	lda $01.b		; A5 01 ; Load $01.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $80, $CC		; 80 CC ; Branch always to $80, $CC [Flow: branch]
	inc $0B14.w		; EE 14 0B ; Increment $0B14.w [Flags: NZ]
	.db $80, $03		; 80 03 ; Branch always to $80, $03 [Flow: branch]
	stz $00CA.w		; 9C CA 00 ; Store zero to $00CA.w
	lda $0002.w		; AD 02 00 ; Load $0002.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00CB.w		; 8D CB 00 ; Store accumulator to $00CB.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sty $00.b		; 84 00 ; Store Y register to $00.b [Reads: Y Index]
	stx $00.b		; 86 00 ; Store X register to $00.b [Reads: X Index]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	brk $8A.b		; 00 8A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8C.b		; 00 8C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8E.b		; 00 8E ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($19.b,X)		; 61 19 ; Add with carry ($19.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	bit $DD.b		; 24 DD ; Test bits $DD.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sta $1002.w		; 8D 02 10 ; Store accumulator to $1002.w [Reads: Accumulator]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$20.b		; 69 20 ; Add #$20.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $EB.b		; 00 EB ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $1008.w		; 8D 08 10 ; Store accumulator to $1008.w [Reads: Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($8D.b,X)		; 01 8D ; Logical OR ($8D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $10.b		; 04 10 ; Test and set bits $10.b [Reads: Accumulator] [Flags: Z]
	sta $100A.w		; 8D 0A 10 ; Store accumulator to $100A.w [Reads: Accumulator]
	lda $7003D9.l,X		; BF D9 03 70 ; Load long $7003D9.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$00.b		; 09 00 ; Logical OR #$00.b with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta $1006.w		; 8D 06 10 ; Store accumulator to $1006.w [Reads: Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$10.b		; 69 10 ; Add #$10.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	brk $8D.b		; 00 8D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $E210.w		; 0C 10 E2 ; Test and set bits $E210.w [Reads: Accumulator] [Flags: Z]
	.db $30, $A9		; 30 A9 ; Branch if minus to $30, $A9 [Flow: branch]
	sbc $100E8D.l,X		; FF 8D 0E 10 ; Subtract with carry (long,X) $100E8D.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $14.b		; 85 14 ; Store accumulator to $14.b [Reads: Accumulator]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora ($0B.b),Y		; 11 0B ; OR accumulator with memory ($0B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora $1D69.w,X		; 1D 69 1D ; OR accumulator with memory $1D69.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $1D6B.w,X		; 1D 6B 1D ; OR accumulator with memory $1D6B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $5E1D.w,X		; 5D 1D 5E ; Exclusive OR accumulator with memory $5E1D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $1C30.w,X		; 1D 30 1C ; OR accumulator with memory $1C30.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($1C.b),Y		; 31 1C ; AND accumulator with memory ($1C.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	and ($1C.b)		; 32 1C ; AND accumulator with memory (indirect) ($1C.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($1C.b,S),Y		; 33 1C ; AND accumulator (stack relative indirect indexed) ($1C.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $1C.b,X		; 34 1C ; Test bits $1C.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	and $1C.b,X		; 35 1C ; Logical AND $1C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rol $1C.b,X		; 36 1C ; Rotate left $1C.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora ($2B.b),Y		; 11 2B ; OR accumulator with memory ($2B.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $1D79.w,X		; 1D 79 1D ; OR accumulator with memory $1D79.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $1D7B.w,X		; 1D 7B 1D ; OR accumulator with memory $1D7B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$1C.b],Y		; 37 1C ; AND accumulator with memory (long indexed) [$1C.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	trb $1C39.w		; 1C 39 1C ; Test and reset bits $1C39.w [Reads: Accumulator] [Flags: Z]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	trb $1C3B.w		; 1C 3B 1C ; Test and reset bits $1C3B.w [Reads: Accumulator] [Flags: Z]
	bit $3D1C.w,X		; 3C 1C 3D ; Test bits $3D1C.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	trb $1C3E.w		; 1C 3E 1C ; Test and reset bits $1C3E.w [Reads: Accumulator] [Flags: Z]
	and $46111C.l,X		; 3F 1C 11 46 ; AND accumulator with memory (long,X) $46111C.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$18.b],Y		; F7 18 ; Subtract with carry (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $19.b		; 00 19 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($19.b,X)		; 01 19 ; Logical OR ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $19.b		; 02 19 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $19.b,S		; 03 19 ; OR accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $19.b		; 04 19 ; Test and set bits $19.b [Reads: Accumulator] [Flags: Z]
	ora $19.b		; 05 19 ; Logical OR $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $19.b		; 05 19 ; Logical OR $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $19.b		; 06 19 ; Arithmetic shift left $19.b [Reads: Direct Page] [Flags: NCZ]
	ora $19.b		; 05 19 ; Logical OR $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$19.b]		; 07 19 ; OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora [$59.b]		; 07 59 ; OR accumulator with memory (long) [$59.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $19.b		; 05 19 ; Logical OR $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	ora $1909.w,Y		; 19 09 19 ; OR accumulator with memory $1909.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $190B.w,Y		; 19 0B 19 ; OR accumulator with memory $190B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tsb $F019.w		; 0C 19 F0 ; Test and set bits $F019.w [Reads: Accumulator] [Flags: Z]
	trb $6611.w		; 1C 11 66 ; Test and reset bits $6611.w [Reads: Accumulator] [Flags: Z]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0E19.w		; 0D 19 0E ; Logical OR $0E19.w with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $18F9.w,Y		; 19 F9 18 ; OR accumulator with memory $18F9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $191039.l		; 0F 39 10 19 ; OR accumulator with memory (long) $191039.l [Writes: Accumulator] [Flags: NZ]
	ora ($19.b),Y		; 11 19 ; OR accumulator with memory ($19.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b)		; 12 19 ; OR accumulator with memory (indirect) ($19.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($19.b,S),Y		; 13 19 ; OR accumulator (stack relative indirect indexed) ($19.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $19.b		; 14 19 ; Test and reset bits $19.b [Reads: Accumulator] [Flags: Z]
	ora $19.b,X		; 15 19 ; OR accumulator with memory $19.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	asl $19.b,X		; 16 19 ; Arithmetic shift left $19.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora [$19.b],Y		; 17 19 ; OR accumulator with memory (long indexed) [$19.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $18FB.w,Y		; 19 FB 18 ; OR accumulator with memory $18FB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $1A19.w,Y		; 19 19 1A ; OR accumulator with memory $1A19.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $8611.w,Y		; 19 11 86 ; OR accumulator with memory $8611.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $391B19.l,X		; 5F 19 1B 39 ; Exclusive OR accumulator with memory (long,X) $391B19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	trb $1D39.w		; 1C 39 1D ; Test and reset bits $1D39.w [Reads: Accumulator] [Flags: Z]
	ora $191E.w,Y		; 19 1E 19 ; OR accumulator with memory $191E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $192019.l,X		; 1F 19 20 19 ; Logical OR long $192019.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($19.b,X)		; 21 19 ; Logical AND ($19.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsl $195F19.l		; 22 19 5F 19 ; Jump to subroutine long $195F19.l [Writes: Stack Pointer] [Flow: call]
	eor $192319.l,X		; 5F 19 23 19 ; Exclusive OR accumulator with memory (long,X) $192319.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	bit $19.b		; 24 19 ; Test bits $19.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $19.b		; 25 19 ; Logical AND $19.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol $19.b		; 26 19 ; Rotate left $19.b [Reads: Direct Page] [Flags: NCZ]
	and [$19.b]		; 27 19 ; AND accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	ora $A811.w,Y		; 19 11 A8 ; OR accumulator with memory $A811.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and #$39.b		; 29 39 ; Logical AND #$39.b with accumulator [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and $192B.w,Y		; 39 2B 19 ; AND accumulator with memory $192B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl $2C19.w,X		; 1E 19 2C ; Arithmetic shift left $2C19.w,X [Reads: X Index] [Flags: NCZ]
	ora $192D.w,Y		; 19 2D 19 ; OR accumulator with memory $192D.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	ora $1922.w,Y		; 19 22 19 ; OR accumulator with memory $1922.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $195F19.l,X		; 5F 19 5F 19 ; Exclusive OR accumulator with memory (long,X) $195F19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $19.b,S		; 23 19 ; AND accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsr ($2E18.w,X)		; FC 18 2E ; Jump to subroutine indirect indexed ($2E18.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ora $192F.w,Y		; 19 2F 19 ; OR accumulator with memory $192F.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $19		; 30 19 ; Branch if minus to $30, $19 [Flow: branch]
	and ($19.b),Y		; 31 19 ; AND accumulator with memory ($19.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($C7.b),Y		; 11 C7 ; OR accumulator with memory ($C7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($19.b)		; 32 19 ; AND accumulator with memory (indirect) ($19.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($39.b,S),Y		; 33 39 ; AND accumulator (stack relative indirect indexed) ($39.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	bit $39.b,X		; 34 39 ; Test bits $39.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	eor $191E19.l,X		; 5F 19 1E 19 ; Exclusive OR accumulator with memory (long,X) $191E19.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $193619.l,X		; 1F 19 36 19 ; Logical OR long $193619.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and [$19.b],Y		; 37 19 ; AND accumulator with memory (long indexed) [$19.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	jsl $195F19.l		; 22 19 5F 19 ; Jump to subroutine long $195F19.l [Writes: Stack Pointer] [Flow: call]
	and $2319.w,Y		; 39 19 23 ; AND accumulator with memory $2319.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $9924.w,Y		; 19 24 99 ; OR accumulator with memory $9924.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	ora $193B.w,Y		; 19 3B 19 ; OR accumulator with memory $193B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	bit $3D19.w,X		; 3C 19 3D ; Test bits $3D19.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	ora $193E.w,Y		; 19 3E 19 ; OR accumulator with memory $193E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($E7.b),Y		; 11 E7 ; OR accumulator with memory ($E7.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $23.b		; 00 23 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $394019.l,X		; 3F 19 40 39 ; AND accumulator with memory (long,X) $394019.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor ($39.b,X)		; 41 39 ; Exclusive OR accumulator with memory ($39.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $194219.l,X		; 5F 19 42 19 ; Exclusive OR accumulator with memory (long,X) $194219.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	eor $19.b,S		; 43 19 ; Exclusive OR accumulator with stack relative $19.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	mvp $45,$19		; 44 19 45 ; Move block positive $45,$19 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $1946.w,Y		; 19 46 19 ; OR accumulator with memory $1946.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor [$19.b]		; 47 19 ; Exclusive OR accumulator with memory (long) [$19.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	ora $1949.w,Y		; 19 49 19 ; OR accumulator with memory $1949.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $194B.w,Y		; 19 4B 19 ; OR accumulator with memory $194B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp $4D19.w		; 4C 19 4D ; Jump to $4D19.w [Flow: jump]
	ora $194E.w,Y		; 19 4E 19 ; OR accumulator with memory $194E.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $061219.l		; 4F 19 12 06 ; Exclusive OR accumulator with memory (long) $061219.l [Writes: Accumulator] [Flags: NZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $5018.w,X		; FD 18 50 ; Subtract with carry $5018.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $3951.w,Y		; 19 51 39 ; OR accumulator with memory $3951.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $5298.w,Y		; F9 98 52 ; Subtract with carry $5298.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $1953.w,Y		; 19 53 19 ; OR accumulator with memory $1953.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvn $54,$19		; 54 19 54 ; Move block negative $54,$19 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $1955.w,Y		; 19 55 19 ; OR accumulator with memory $1955.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvn $54,$19		; 54 19 54 ; Move block negative $54,$19 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $1956.w,Y		; 19 56 19 ; OR accumulator with memory $1956.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	mvn $57,$19		; 54 19 57 ; Move block negative $57,$19 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	ora $1958.w,Y		; 19 58 19 ; OR accumulator with memory $1958.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	eor $5A19.w,Y		; 59 19 5A ; Exclusive OR accumulator with memory $5A19.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	ora $195B.w,Y		; 19 5B 19 ; OR accumulator with memory $195B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	jmp $261219.l		; 5C 19 12 26 ; Jump long to $261219.l [Flow: jump]
	brk $2B.b		; 00 2B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($18.b),Y		; F1 18 ; Subtract with carry ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($18.b)		; F2 18 ; Subtract with carry (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($18.b,S),Y		; F3 18 ; Subtract with carry (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	pea $F518.w		; F4 18 F5 ; Push absolute address $F518.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $18.b,X		; F6 18 ; Increment memory $18.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $1D61.w,X		; 1D 61 1D ; OR accumulator with memory $1D61.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $1D, $63		; 62 1D 63 ; Push effective relative address $62, $1D, $63 [Writes: Stack Pointer]
	ora $1D64.w,X		; 1D 64 1D ; OR accumulator with memory $1D64.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $1D.b		; 65 1D ; Add $1D.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ror $1D.b		; 66 1D ; Rotate right $1D.b [Reads: Direct Page] [Flags: NCZ]
	adc [$1D.b]		; 67 1D ; Add with carry (long) [$1D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	ora $1D69.w,X		; 1D 69 1D ; OR accumulator with memory $1D69.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora $1D6B.w,X		; 1D 6B 1D ; OR accumulator with memory $1D6B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($6D1D.w)		; 6C 1D 6D ; Jump indirect to ($6D1D.w) [Flow: jump]
	ora $1D6E.w,X		; 1D 6E 1D ; OR accumulator with memory $1D6E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $4C121D.l		; 6F 1D 12 4C ; Add with carry (long) $4C121D.l [Writes: Accumulator] [Flags: NCVZ]
	brk $1F.b		; 00 1F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $70, $1D		; 70 1D ; Branch if overflow set to $70, $1D [Flow: branch]
	adc ($1D.b),Y		; 71 1D ; Add with carry ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($1D.b)		; 72 1D ; Add with carry (indirect) ($1D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	adc ($1D.b,S),Y		; 73 1D ; Add with carry (stack relative indirect indexed) ($1D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	stz $1D.b,X		; 74 1D ; Store zero to $1D.b,X [Reads: X Index]
	adc $1D.b,X		; 75 1D ; Add $1D.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ror $1D.b,X		; 76 1D ; Rotate right $1D.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	adc [$1D.b],Y		; 77 1D ; Add with carry (long indexed) [$1D.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	ora $1D79.w,X		; 1D 79 1D ; OR accumulator with memory $1D79.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	ora $1D7B.w,X		; 1D 7B 1D ; OR accumulator with memory $1D7B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp ($7D1D.w,X)		; 7C 1D 7D ; Jump indirect indexed to ($7D1D.w,X) [Reads: X Index] [Flow: jump]
	ora $1D7E.w,X		; 1D 7E 1D ; OR accumulator with memory $1D7E.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $80001D.l,X		; 7F 1D 00 80 ; Add long $80001D.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	eor ($BE.b,X)		; 41 BE ; Exclusive OR accumulator with memory ($BE.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $0110.w,X		; BD 10 01 ; Load $0110.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	adc $40.b		; 65 40 ; Add $40.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $0110.w,Y		; BE 10 01 ; Load X register $0110.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $BF.b		; 24 BF ; Test bits $BF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $10, $02		; 10 02 ; Branch if plus to $10, $02 [Flow: branch]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	bit $BF.b		; 24 BF ; Test bits $BF.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	eor $40.b		; 45 40 ; Exclusive OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ldx $0290.w,Y		; BE 90 02 ; Load X register $0290.w,Y [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	ror A		; 6A ; Rotate right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	inc A		; 1A ; Increment accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	lda $0190.w,X		; BD 90 01 ; Load $0190.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($11.b,S),Y		; B3 11 ; Load accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $11.b,X		; B4 11 ; Load Y register $11.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ldy $51.b,X		; B4 51 ; Load Y register $51.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	lda ($51.b,S),Y		; B3 51 ; Load accumulator (stack relative indirect indexed) ($51.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $BD10.w,X		; BD 10 BD ; Load $BD10.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $B3		; 10 B3 ; Branch if plus to $10, $B3 [Flow: branch]
	ora ($B4.b),Y		; 11 B4 ; OR accumulator with memory ($B4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($B4.b),Y		; 11 B4 ; OR accumulator with memory ($B4.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($B3.b),Y		; 51 B3 ; Exclusive OR accumulator with memory ($B3.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	eor ($01.b),Y		; 51 01 ; Exclusive OR accumulator with memory ($01.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($11.b,S),Y		; B3 11 ; Load accumulator (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $11.b,X		; B4 11 ; Load Y register $11.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ldy $51.b,X		; B4 51 ; Load Y register $51.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora ($60.b,X)		; 01 60 ; Logical OR ($60.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $10		; B0 10 ; Branch if carry set to $B0, $10 [Flow: branch]
	lda ($10.b),Y		; B1 10 ; Load accumulator ($10.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($10.b)		; B2 10 ; Load accumulator (indirect) ($10.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($10.b,S),Y		; B3 10 ; Load accumulator (stack relative indirect indexed) ($10.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $10.b,X		; B4 10 ; Load Y register $10.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ora ($80.b,X)		; 01 80 ; Logical OR ($80.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $10.b,X		; B5 10 ; Load $10.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $10.b,Y		; B6 10 ; Load X register $10.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	lda [$10.b],Y		; B7 10 ; Load accumulator (long indexed) [$10.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $10, $B9		; 10 B9 ; Branch if plus to $10, $B9 [Flow: branch]
	.db $10, $BA		; 10 BA ; Branch if plus to $10, $BA [Flow: branch]
	.db $10, $BB		; 10 BB ; Branch if plus to $10, $BB [Flow: branch]
	.db $10, $BC		; 10 BC ; Branch if plus to $10, $BC [Flow: branch]
	.db $10, $01		; 10 01 ; Branch if plus to $10, $01 [Flow: branch]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	and $C9.b,X		; 35 C9 ; Logical AND $C9.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$CA.b		; 09 CA ; Logical OR #$CA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$C9.b		; 09 C9 ; Logical OR #$C9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$CA.b		; 09 CA ; Logical OR #$CA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$C9.b		; 09 C9 ; Logical OR #$C9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$CA.b		; 09 CA ; Logical OR #$CA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$C9.b		; 09 C9 ; Logical OR #$C9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$CA.b		; 09 CA ; Logical OR #$CA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$FF.b		; 09 FF ; Logical OR #$FF.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E7.b		; 09 E7 ; Logical OR #$E7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E8.b		; 09 E8 ; Logical OR #$E8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E7.b		; 09 E7 ; Logical OR #$E7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E8.b		; 09 E8 ; Logical OR #$E8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E7.b		; 09 E7 ; Logical OR #$E7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E8.b		; 09 E8 ; Logical OR #$E8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E7.b		; 09 E7 ; Logical OR #$E7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E8.b		; 09 E8 ; Logical OR #$E8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E7.b		; 09 E7 ; Logical OR #$E7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E8.b		; 09 E8 ; Logical OR #$E8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E7.b		; 09 E7 ; Logical OR #$E7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E8.b		; 09 E8 ; Logical OR #$E8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E7.b		; 09 E7 ; Logical OR #$E7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E8.b		; 09 E8 ; Logical OR #$E8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E7.b		; 09 E7 ; Logical OR #$E7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E8.b		; 09 E8 ; Logical OR #$E8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E7.b		; 09 E7 ; Logical OR #$E7.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$E8.b		; 09 E8 ; Logical OR #$E8.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$00.b		; C0 00 ; Compare #$00.b with Y register [Reads: Y Index] [Flags: NCZ]
	and $D9.b,X		; 35 D9 ; Logical AND $D9.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$DA.b		; 09 DA ; Logical OR #$DA.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$D9.b		; 09 D9 ; Logical OR #$D9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	cpx #$00.b		; E0 00 ; Compare #$00.b with X register [Reads: X Index] [Flags: NCZ]
	and $B1.b,X		; 35 B1 ; Logical AND $B1.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $0DB2.w		; 0D B2 0D ; Logical OR $0DB2.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b)		; B2 0D ; Load accumulator (indirect) ($0D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($0D.b),Y		; B1 0D ; Load accumulator ($0D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cmp #$8D.b		; C9 8D ; Compare #$8D.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DC9.w		; 8D C9 8D ; Store accumulator to $8DC9.w [Reads: Accumulator]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DC9.w		; 8D C9 8D ; Store accumulator to $8DC9.w [Reads: Accumulator]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DC9.w		; 8D C9 8D ; Store accumulator to $8DC9.w [Reads: Accumulator]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DFF.w		; 8D FF 8D ; Store accumulator to $8DFF.w [Reads: Accumulator]
	sbc [$8D.b]		; E7 8D ; Subtract with carry (long) [$8D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DE7.w		; 8D E7 8D ; Store accumulator to $8DE7.w [Reads: Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DE7.w		; 8D E7 8D ; Store accumulator to $8DE7.w [Reads: Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DE7.w		; 8D E7 8D ; Store accumulator to $8DE7.w [Reads: Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DE7.w		; 8D E7 8D ; Store accumulator to $8DE7.w [Reads: Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DE7.w		; 8D E7 8D ; Store accumulator to $8DE7.w [Reads: Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DE7.w		; 8D E7 8D ; Store accumulator to $8DE7.w [Reads: Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DE7.w		; 8D E7 8D ; Store accumulator to $8DE7.w [Reads: Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $8DE7.w		; 8D E7 8D ; Store accumulator to $8DE7.w [Reads: Accumulator]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	sta $2002.w		; 8D 02 20 ; Store accumulator to $2002.w [Reads: Accumulator]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $90.b,X		; B5 90 ; Load $90.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $90.b,Y		; B6 90 ; Load X register $90.b,Y [Reads: Direct Page, Y Index] [Writes: X Index] [Flags: NZ]
	lda [$90.b],Y		; B7 90 ; Load accumulator (long indexed) [$90.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	.db $90, $B9		; 90 B9 ; Branch if carry clear to $90, $B9 [Flow: branch]
	.db $90, $BA		; 90 BA ; Branch if carry clear to $90, $BA [Flow: branch]
	.db $90, $BB		; 90 BB ; Branch if carry clear to $90, $BB [Flow: branch]
	.db $90, $BC		; 90 BC ; Branch if carry clear to $90, $BC [Flow: branch]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $B0, $90		; B0 90 ; Branch if carry set to $B0, $90 [Flow: branch]
	lda ($90.b),Y		; B1 90 ; Load accumulator ($90.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda ($90.b)		; B2 90 ; Load accumulator (indirect) ($90.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda ($90.b,S),Y		; B3 90 ; Load accumulator (stack relative indirect indexed) ($90.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $90.b,X		; B4 90 ; Load Y register $90.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cop $60.b		; 02 60 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($91.b,S),Y		; B3 91 ; Load accumulator (stack relative indirect indexed) ($91.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $91.b,X		; B4 91 ; Load Y register $91.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ldy $D1.b,X		; B4 D1 ; Load Y register $D1.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	lda ($D1.b,S),Y		; B3 D1 ; Load accumulator (stack relative indirect indexed) ($D1.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda $BD90.w,X		; BD 90 BD ; Load $BD90.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $90, $B3		; 90 B3 ; Branch if carry clear to $90, $B3 [Flow: branch]
	sta ($B4.b),Y		; 91 B4 ; Store accumulator ($B4.b),Y [Reads: Direct Page, Y Index, Accumulator]
	sta ($B4.b),Y		; 91 B4 ; Store accumulator ($B4.b),Y [Reads: Direct Page, Y Index, Accumulator]
	cmp ($B3.b),Y		; D1 B3 ; Compare accumulator ($B3.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	cmp ($02.b),Y		; D1 02 ; Compare accumulator ($02.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	sei		; 78 ; Set interrupt disable flag [Flags: I]
	brk $05.b		; 00 05 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda ($91.b,S),Y		; B3 91 ; Load accumulator (stack relative indirect indexed) ($91.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $91.b,X		; B4 91 ; Load Y register $91.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	ldy $D1.b,X		; B4 D1 ; Load Y register $D1.b,X [Reads: Direct Page, X Index] [Writes: Y Index] [Flags: NZ]
	cop $80.b		; 02 80 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	sbc ($11.b),Y		; F1 11 ; Subtract with carry ($11.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	cop $A0.b		; 02 A0 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b,S),Y		; F3 11 ; Subtract with carry (stack relative indirect indexed) ($11.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($11.b)		; F2 11 ; Subtract with carry (indirect) ($11.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	ora ($3B.b,X)		; 01 3B ; Logical OR ($3B.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $80, $19		; 80 19 ; Branch always to $80, $19 [Flow: branch]
	inc $15.b,X		; F6 15 ; Increment memory $15.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	pea $CB15.w		; F4 15 CB ; Push absolute address $CB15.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $DB.b,X		; 15 DB ; OR accumulator with memory $DB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DB.b,X		; 15 DB ; OR accumulator with memory $DB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DB.b,X		; 15 DB ; OR accumulator with memory $DB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DB.b,X		; 15 DB ; OR accumulator with memory $DB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DB.b,X		; 15 DB ; OR accumulator with memory $DB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $EB.b,X		; 15 EB ; OR accumulator with memory $EB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FB.b,X		; 15 FB ; OR accumulator with memory $FB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FD.b,X		; 15 FD ; OR accumulator with memory $FD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FD.b,X		; 15 FD ; OR accumulator with memory $FD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FD.b,X		; 15 FD ; OR accumulator with memory $FD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	bit $1980.w,X		; 3C 80 19 ; Test bits $1980.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	sbc [$15.b],Y		; F7 15 ; Subtract with carry (long indexed) [$15.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $15.b,X		; F5 15 ; Subtract $15.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	jmp.w [$DC15]		; DC 15 DC ; Jump long indirect [$DC15] [Flow: jump]
	ora $DC.b,X		; 15 DC ; OR accumulator with memory $DC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DC.b,X		; 15 DC ; OR accumulator with memory $DC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DC.b,X		; 15 DC ; OR accumulator with memory $DC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DC.b,X		; 15 DC ; OR accumulator with memory $DC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $B0.b,X		; 15 B0 ; OR accumulator with memory $B0.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FC.b,X		; 15 FC ; OR accumulator with memory $FC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,X		; 15 FE ; OR accumulator with memory $FE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,X		; 15 FE ; OR accumulator with memory $FE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FE.b,X		; 15 FE ; OR accumulator with memory $FE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $01.b,X		; 15 01 ; OR accumulator with memory $01.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $1980.w,X		; 3D 80 19 ; AND accumulator with memory $1980.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	ora $CD.b,X		; 15 CD ; OR accumulator with memory $CD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DD.b,X		; 15 DD ; OR accumulator with memory $DD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DD.b,X		; 15 DD ; OR accumulator with memory $DD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DD.b,X		; 15 DD ; OR accumulator with memory $DD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DD.b,X		; 15 DD ; OR accumulator with memory $DD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DD.b,X		; 15 DD ; OR accumulator with memory $DD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DD.b,X		; 15 DD ; OR accumulator with memory $DD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $CC.b,X		; 15 CC ; OR accumulator with memory $CC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $ED.b,X		; 15 ED ; OR accumulator with memory $ED.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $BD.b,X		; 15 BD ; OR accumulator with memory $BD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $BD.b		; 14 BD ; Test and reset bits $BD.b [Reads: Accumulator] [Flags: Z]
	trb $FE.b		; 14 FE ; Test and reset bits $FE.b [Reads: Accumulator] [Flags: Z]
	ora $00.b,X		; 15 00 ; OR accumulator with memory $00.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $2380.w,X		; 9E 80 23 ; Store zero to $2380.w,X [Reads: X Index]
	inc $15.b,X		; F6 15 ; Increment memory $15.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	pea $CB15.w		; F4 15 CB ; Push absolute address $CB15.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	ora $DB.b,X		; 15 DB ; OR accumulator with memory $DB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $E9.b,X		; 15 E9 ; OR accumulator with memory $E9.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $F9.b,X		; 15 F9 ; OR accumulator with memory $F9.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $CE.b,X		; 15 CE ; OR accumulator with memory $CE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DE.b,X		; 15 DE ; OR accumulator with memory $DE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DE.b,X		; 15 DE ; OR accumulator with memory $DE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DE.b,X		; 15 DE ; OR accumulator with memory $DE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DE.b,X		; 15 DE ; OR accumulator with memory $DE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DE.b,X		; 15 DE ; OR accumulator with memory $DE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DE.b,X		; 15 DE ; OR accumulator with memory $DE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $CC.b,X		; 15 CC ; OR accumulator with memory $CC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $EE.b,X		; 15 EE ; OR accumulator with memory $EE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $BD.b,X		; 15 BD ; OR accumulator with memory $BD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $BD.b		; 14 BD ; Test and reset bits $BD.b [Reads: Accumulator] [Flags: Z]
	trb $BD.b		; 14 BD ; Test and reset bits $BD.b [Reads: Accumulator] [Flags: Z]
	trb $00.b		; 14 00 ; Test and reset bits $00.b [Reads: Accumulator] [Flags: Z]
	sta $F72380.l,X		; 9F 80 23 F7 ; Store accumulator (long,X) $F72380.l,X [Reads: Accumulator, X Index]
	ora $F5.b,X		; 15 F5 ; OR accumulator with memory $F5.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DC.b,X		; 15 DC ; OR accumulator with memory $DC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DC.b,X		; 15 DC ; OR accumulator with memory $DC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $EA.b,X		; 15 EA ; OR accumulator with memory $EA.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $FA.b,X		; 15 FA ; OR accumulator with memory $FA.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $CF.b,X		; 15 CF ; OR accumulator with memory $CF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DF.b,X		; 15 DF ; OR accumulator with memory $DF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DF.b,X		; 15 DF ; OR accumulator with memory $DF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DF.b,X		; 15 DF ; OR accumulator with memory $DF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DF.b,X		; 15 DF ; OR accumulator with memory $DF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DF.b,X		; 15 DF ; OR accumulator with memory $DF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $DF.b,X		; 15 DF ; OR accumulator with memory $DF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $CC.b,X		; 15 CC ; OR accumulator with memory $CC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $EF.b,X		; 15 EF ; OR accumulator with memory $EF.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $BD.b,X		; 15 BD ; OR accumulator with memory $BD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $BD.b		; 14 BD ; Test and reset bits $BD.b [Reads: Accumulator] [Flags: Z]
	trb $BD.b		; 14 BD ; Test and reset bits $BD.b [Reads: Accumulator] [Flags: Z]
	trb $FF.b		; 14 FF ; Test and reset bits $FF.b [Reads: Accumulator] [Flags: Z]
	.db $10, $42		; 10 42 ; Branch if plus to $10, $42 [Flow: branch]
	brk $27.b		; 00 27 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit #$35.b		; 89 35 ; Test bits #$35.b with accumulator [Reads: Accumulator] [Flags: Z]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and $8B.b,X		; 35 8B ; Logical AND $8B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8C.b,X		; 35 8C ; Logical AND $8C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8B.b,X		; 35 8B ; Logical AND $8B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8C.b,X		; 35 8C ; Logical AND $8C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8B.b,X		; 35 8B ; Logical AND $8B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8C.b,X		; 35 8C ; Logical AND $8C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8B.b,X		; 35 8B ; Logical AND $8B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8C.b,X		; 35 8C ; Logical AND $8C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8B.b,X		; 35 8B ; Logical AND $8B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8C.b,X		; 35 8C ; Logical AND $8C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8B.b,X		; 35 8B ; Logical AND $8B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8C.b,X		; 35 8C ; Logical AND $8C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8B.b,X		; 35 8B ; Logical AND $8B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8C.b,X		; 35 8C ; Logical AND $8C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8B.b,X		; 35 8B ; Logical AND $8B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8C.b,X		; 35 8C ; Logical AND $8C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $8A.b,X		; 35 8A ; Logical AND $8A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $89.b,X		; 75 89 ; Add $89.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $10.b,X		; 75 10 ; Add $10.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $62, $00, $03		; 62 00 03 ; Push effective relative address $62, $00, $03 [Writes: Stack Pointer]
	sta $9A35.w,Y		; 99 35 9A ; Store accumulator to $9A35.w,Y [Reads: Y Index, Accumulator]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	stz $40.b		; 64 40 ; Store zero to $40.b
	asl $347F.w,X		; 1E 7F 34 ; Arithmetic shift left $347F.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $74		; 10 74 ; Branch if plus to $10, $74 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	adc $99.b,X		; 75 99 ; Add $99.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $10.b,X		; 75 10 ; Add $10.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $82, $00, $03		; 82 00 03 ; Branch always long to $82, $00, $03 [Flow: branch]
	lda #$35.b		; A9 35 ; Load #$35.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $40.b		; 84 40 ; Store Y register to $40.b [Reads: Y Index]
	asl $347F.w,X		; 1E 7F 34 ; Arithmetic shift left $347F.w,X [Reads: X Index] [Flags: NCZ]
	.db $10, $94		; 10 94 ; Branch if plus to $10, $94 [Flow: branch]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	adc $A9.b,X		; 75 A9 ; Add $A9.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $10.b,X		; 75 10 ; Add $10.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	and [$9D.b]		; 27 9D ; AND accumulator with memory (long) [$9D.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $AD.b,X		; 35 AD ; Logical AND $AD.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9B.b,X		; 35 9B ; Logical AND $9B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9C.b,X		; 35 9C ; Logical AND $9C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9B.b,X		; 35 9B ; Logical AND $9B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9C.b,X		; 35 9C ; Logical AND $9C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9B.b,X		; 35 9B ; Logical AND $9B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9C.b,X		; 35 9C ; Logical AND $9C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9B.b,X		; 35 9B ; Logical AND $9B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9C.b,X		; 35 9C ; Logical AND $9C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9B.b,X		; 35 9B ; Logical AND $9B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9C.b,X		; 35 9C ; Logical AND $9C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9B.b,X		; 35 9B ; Logical AND $9B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9C.b,X		; 35 9C ; Logical AND $9C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9B.b,X		; 35 9B ; Logical AND $9B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9C.b,X		; 35 9C ; Logical AND $9C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9B.b,X		; 35 9B ; Logical AND $9B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $9C.b,X		; 35 9C ; Logical AND $9C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AD.b,X		; 35 AD ; Logical AND $AD.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $9D.b,X		; 75 9D ; Add $9D.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $10.b,X		; 75 10 ; Add $10.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rep #$00		; C2 00 ; Reset processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and [$AB.b]		; 27 AB ; AND accumulator with memory (long) [$AB.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $AC.b,X		; 35 AC ; Logical AND $AC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AB.b,X		; 35 AB ; Logical AND $AB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AC.b,X		; 35 AC ; Logical AND $AC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AB.b,X		; 35 AB ; Logical AND $AB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AC.b,X		; 35 AC ; Logical AND $AC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AB.b,X		; 35 AB ; Logical AND $AB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AC.b,X		; 35 AC ; Logical AND $AC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AB.b,X		; 35 AB ; Logical AND $AB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AC.b,X		; 35 AC ; Logical AND $AC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AB.b,X		; 35 AB ; Logical AND $AB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AC.b,X		; 35 AC ; Logical AND $AC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AB.b,X		; 35 AB ; Logical AND $AB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AC.b,X		; 35 AC ; Logical AND $AC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AB.b,X		; 35 AB ; Logical AND $AB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AC.b,X		; 35 AC ; Logical AND $AC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AB.b,X		; 35 AB ; Logical AND $AB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AC.b,X		; 35 AC ; Logical AND $AC.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $AB.b,X		; 35 AB ; Logical AND $AB.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $AC.b,X		; 75 AC ; Add $AC.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $10.b,X		; 75 10 ; Add $10.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sep #$00		; E2 00 ; Set processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora ($83.b,X)		; 01 83 ; Logical OR ($83.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $40.b,S		; E3 40 ; Subtract stack-relative $40.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and ($85.b)		; 32 85 ; AND accumulator with memory (indirect) ($85.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $0100.w,X		; FD 00 01 ; Subtract with carry $0100.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sty $35.b		; 84 35 ; Store Y register to $35.b [Reads: Y Index]
	ora ($02.b),Y		; 11 02 ; OR accumulator with memory ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: NCZ]
	stx $35.b		; 86 35 ; Store X register to $35.b [Reads: X Index]
	ora ($1D.b),Y		; 11 1D ; OR accumulator with memory ($1D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$22.b		; C0 22 ; Compare #$22.b with Y register [Reads: Y Index] [Flags: NCZ]
	stx $35.b,Y		; 96 35 ; Store X register $35.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ora ($42.b,S),Y		; 13 42 ; OR accumulator (stack relative indirect indexed) ($42.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta ($35.b,S),Y		; 93 35 ; Store accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator]
	ora ($43.b,S),Y		; 13 43 ; OR accumulator (stack relative indirect indexed) ($43.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and ($95.b)		; 32 95 ; AND accumulator with memory (indirect) ($95.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $13.b,X		; 35 13 ; Logical AND $13.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $0100.w,X		; 5D 00 01 ; Exclusive OR accumulator with memory $0100.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sty $35.b,X		; 94 35 ; Store Y register $35.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $00.b		; 65 00 ; Add $00.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $180B18.l		; 0F 18 0B 18 ; OR accumulator with memory (long) $180B18.l [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $180418.l		; 22 18 04 18 ; Jump to subroutine long $180418.l [Writes: Stack Pointer] [Flow: call]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	ora $181B18.l,X		; 1F 18 1B 18 ; Logical OR long $181B18.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $B918.w,Y		; B9 18 B9 ; Load $B918.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($18.b)		; 32 18 ; AND accumulator with memory (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	ora ($18.b)		; 12 18 ; OR accumulator with memory (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and ($18.b,S),Y		; 33 18 ; AND accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	.db $62, $C6, $00		; 62 C6 00 ; Push effective relative address $62, $C6, $00 [Writes: Stack Pointer]
	ora [$02.b],Y		; 17 02 ; OR accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $0F18.w		; 0E 18 0F ; Arithmetic shift left $0F18.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $180B18.l		; 0F 18 0B 18 ; OR accumulator with memory (long) $180B18.l [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $62, $E6, $00		; 62 E6 00 ; Push effective relative address $62, $E6, $00 [Writes: Stack Pointer]
	ora [$12.b],Y		; 17 12 ; OR accumulator with memory (long indexed) [$12.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $1F18.w,X		; 1E 18 1F ; Arithmetic shift left $1F18.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $181B18.l,X		; 1F 18 1B 18 ; Logical OR long $181B18.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $06.b,S		; 63 06 ; Add with carry (stack relative) $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $180418.l		; 22 18 04 18 ; Jump to subroutine long $180418.l [Writes: Stack Pointer] [Flow: call]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $180B18.l		; 0F 18 0B 18 ; OR accumulator with memory (long) $180B18.l [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc $26.b,S		; 63 26 ; Add with carry (stack relative) $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $17.b		; 00 17 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	and ($18.b)		; 32 18 ; AND accumulator with memory (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $181B18.l,X		; 1F 18 1B 18 ; Logical OR long $181B18.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $002961.l,X		; FF 61 29 00 ; Subtract with carry (long,X) $002961.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $E7.b		; 25 E7 ; Logical AND $E7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($49.b,X)		; 61 49 ; Add with carry ($49.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$18.b],Y		; F7 18 ; Subtract with carry (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($18.b),Y		; 91 18 ; Store accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($A9.b,X)		; 61 A9 ; Add with carry ($A9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($C9.b,X)		; 61 C9 ; Add with carry ($C9.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta ($18.b),Y		; 91 18 ; Store accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $29, $00		; 62 29 00 ; Push effective relative address $62, $29, $00 [Writes: Stack Pointer]
	and $E9.b		; 25 E9 ; Logical AND $E9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $49, $00		; 62 49 00 ; Push effective relative address $62, $49, $00 [Writes: Stack Pointer]
	and $F9.b		; 25 F9 ; Logical AND $F9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta ($18.b),Y		; 91 18 ; Store accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $006560.l,X		; FF 60 65 00 ; Subtract with carry (long,X) $006560.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$04.b],Y		; 17 04 ; OR accumulator with memory (long indexed) [$04.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $180418.l		; 22 18 04 18 ; Jump to subroutine long $180418.l [Writes: Stack Pointer] [Flow: call]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $180B18.l		; 0F 18 0B 18 ; OR accumulator with memory (long) $180B18.l [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	ora [$14.b],Y		; 17 14 ; OR accumulator with memory (long indexed) [$14.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	and ($18.b)		; 32 18 ; AND accumulator with memory (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $181B18.l,X		; 1F 18 1B 18 ; Logical OR long $181B18.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($04.b,X)		; 61 04 ; Add with carry ($04.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: NCZ]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $180218.l		; AF 18 02 18 ; Load long $180218.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $180B18.l		; 0F 18 0B 18 ; OR accumulator with memory (long) $180B18.l [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $A918.w		; 0E 18 A9 ; Arithmetic shift left $A918.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $2418.w		; 0E 18 24 ; Arithmetic shift left $2418.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: NCZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $2318.w		; 0D 18 23 ; Logical OR $2318.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($24.b,X)		; 61 24 ; Add with carry ($24.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $2F.b		; 00 2F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol $18.b,X		; 36 18 ; Rotate left $18.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $181218.l,X		; BF 18 12 18 ; Load long $181218.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $181B18.l,X		; 1F 18 1B 18 ; Logical OR long $181B18.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($18.b,S),Y		; 13 18 ; OR accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $A918.w,X		; 1E 18 A9 ; Arithmetic shift left $A918.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $3418.w,X		; 1E 18 34 ; Arithmetic shift left $3418.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	rol $18.b,X		; 36 18 ; Rotate left $18.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	ora $3318.w,X		; 1D 18 33 ; OR accumulator with memory $3318.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc ($44.b,X)		; 61 44 ; Add with carry ($44.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $A918.w		; 0E 18 A9 ; Arithmetic shift left $A918.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $180418.l		; 22 18 04 18 ; Jump to subroutine long $180418.l [Writes: Stack Pointer] [Flow: call]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $646118.l		; 6F 18 61 64 ; Add with carry (long) $646118.l [Writes: Accumulator] [Flags: NCVZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($18.b,S),Y		; 33 18 ; AND accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $A918.w,X		; 1E 18 A9 ; Arithmetic shift left $A918.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	and ($18.b)		; 32 18 ; AND accumulator with memory (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $066318.l,X		; 7F 18 63 06 ; Add long $066318.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2418.w		; 20 18 24 ; Jump to subroutine at $2418.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda $182318.l		; AF 18 23 18 ; Load long $182318.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $26.b,S		; 63 26 ; Add with carry (stack relative) $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $183318.l,X		; BF 18 33 18 ; Load long $183318.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $00A761.l,X		; FF 61 A7 00 ; Subtract with carry (long,X) $00A761.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $E7.b		; 25 E7 ; Logical AND $E7.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($C7.b,X)		; 61 C7 ; Add with carry ($C7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $25.b		; 00 25 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$18.b],Y		; F7 18 ; Subtract with carry (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($18.b),Y		; 91 18 ; Store accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $07, $00		; 62 07 00 ; Push effective relative address $62, $07, $00 [Writes: Stack Pointer]
	and $E8.b		; 25 E8 ; Logical AND $E8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $27, $00		; 62 27 00 ; Push effective relative address $62, $27, $00 [Writes: Stack Pointer]
	and $F8.b		; 25 F8 ; Logical AND $F8.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta ($18.b),Y		; 91 18 ; Store accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $67, $00		; 62 67 00 ; Push effective relative address $62, $67, $00 [Writes: Stack Pointer]
	and $E9.b		; 25 E9 ; Logical AND $E9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $87, $00		; 62 87 00 ; Push effective relative address $62, $87, $00 [Writes: Stack Pointer]
	and $F9.b		; 25 F9 ; Logical AND $F9.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta ($18.b),Y		; 91 18 ; Store accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $006560.l,X		; FF 60 65 00 ; Subtract with carry (long,X) $006560.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora [$02.b],Y		; 17 02 ; OR accumulator with memory (long indexed) [$02.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $0F18.w		; 0E 18 0F ; Arithmetic shift left $0F18.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $180B18.l		; 0F 18 0B 18 ; OR accumulator with memory (long) $180B18.l [Writes: Accumulator] [Flags: NZ]
	brk $18.b		; 00 18 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	ora [$12.b],Y		; 17 12 ; OR accumulator with memory (long indexed) [$12.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $1F18.w,X		; 1E 18 1F ; Arithmetic shift left $1F18.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $181B18.l,X		; 1F 18 1B 18 ; Logical OR long $181B18.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $10, $18		; 10 18 ; Branch if plus to $10, $18 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $06.b,S		; 63 06 ; Add with carry (stack relative) $06.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2418.w		; 20 18 24 ; Jump to subroutine at $2418.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda $182318.l		; AF 18 23 18 ; Load long $182318.l into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $26.b,S		; 63 26 ; Add with carry (stack relative) $26.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	brk $07.b		; 00 07 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	bit $18.b,X		; 34 18 ; Test bits $18.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	lda $183318.l,X		; BF 18 33 18 ; Load long $183318.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $000461.l,X		; FF 61 04 00 ; Subtract with carry (long,X) $000461.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $85.b,X		; 15 85 ; OR accumulator with memory $85.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: NCZ]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $180218.l		; AF 18 02 18 ; Load long $180218.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $188618.l		; 6F 18 86 18 ; Add with carry (long) $188618.l [Writes: Accumulator] [Flags: NCVZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($24.b,X)		; 61 24 ; Add with carry ($24.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $18.b,X		; 95 18 ; Store accumulator to $18.b,X [Reads: Accumulator, X Index]
	rol $18.b,X		; 36 18 ; Rotate left $18.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $181218.l,X		; BF 18 12 18 ; Load long $181218.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $189618.l,X		; 7F 18 96 18 ; Add long $189618.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($67.b,X)		; 61 67 ; Add with carry ($67.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($87.b,X)		; 61 87 ; Add with carry ($87.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc [$18.b],Y		; F7 18 ; Subtract with carry (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta ($18.b),Y		; 91 18 ; Store accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($C7.b,X)		; 61 C7 ; Add with carry ($C7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($E7.b,X)		; 61 E7 ; Add with carry ($E7.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta ($18.b),Y		; 91 18 ; Store accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $27, $00		; 62 27 00 ; Push effective relative address $62, $27, $00 [Writes: Stack Pointer]
	ora $A918E9.l		; 0F E9 18 A9 ; OR accumulator with memory (long) $A918E9.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $47, $00		; 62 47 00 ; Push effective relative address $62, $47, $00 [Writes: Stack Pointer]
	ora $9118F9.l		; 0F F9 18 91 ; OR accumulator with memory (long) $9118F9.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $005161.l,X		; FF 61 51 00 ; Subtract with carry (long,X) $005161.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $85.b,X		; 15 85 ; OR accumulator with memory $85.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $A918.w		; 0E 18 A9 ; Arithmetic shift left $A918.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: NCZ]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $180218.l		; AF 18 02 18 ; Load long $180218.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	adc $188618.l		; 6F 18 86 18 ; Add with carry (long) $188618.l [Writes: Accumulator] [Flags: NCVZ]
	adc ($71.b,X)		; 61 71 ; Add with carry ($71.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $15.b		; 00 15 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sta $18.b,X		; 95 18 ; Store accumulator to $18.b,X [Reads: Accumulator, X Index]
	and ($18.b,S),Y		; 33 18 ; AND accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	asl $B918.w,X		; 1E 18 B9 ; Arithmetic shift left $B918.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $18.b,X		; 36 18 ; Rotate left $18.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $181218.l,X		; BF 18 12 18 ; Load long $181218.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc $189618.l,X		; 7F 18 96 18 ; Add long $189618.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($B4.b,X)		; 61 B4 ; Add with carry ($B4.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($D4.b,X)		; 61 D4 ; Add with carry ($D4.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $0F.b		; 00 0F ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($18.b),Y		; 91 18 ; Store accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $14, $00		; 62 14 00 ; Push effective relative address $62, $14, $00 [Writes: Stack Pointer]
	ora $A918A9.l		; 0F A9 18 A9 ; OR accumulator with memory (long) $A918A9.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $34, $00		; 62 34 00 ; Push effective relative address $62, $34, $00 [Writes: Stack Pointer]
	ora $9118A9.l		; 0F A9 18 91 ; OR accumulator with memory (long) $9118A9.l [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $40A410.l,X		; FF 10 A4 40 ; Subtract with carry (long,X) $40A410.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $C41014.l,X		; 7F 14 10 C4 ; Add long $C41014.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	adc $631114.l,X		; 7F 14 11 63 ; Add long $631114.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	adc $831114.l,X		; 7F 14 11 83 ; Add long $831114.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	adc $A31114.l,X		; 7F 14 11 A3 ; Add long $A31114.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	adc $E31114.l,X		; 7F 14 11 E3 ; Add long $E31114.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	ora $40.b,S		; 03 40 ; OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	and $40.b,S		; 23 40 ; AND accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	eor $40.b,S		; 43 40 ; Exclusive OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	adc $40.b,S		; 63 40 ; Add with carry (stack relative) $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	sta $40.b,S		; 83 40 ; Store accumulator (stack relative) $40.b,S [Reads: Stack Pointer, Accumulator]
	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	lda $40.b,S		; A3 40 ; Load accumulator (stack relative) $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	cmp $40.b,S		; C3 40 ; Compare accumulator (stack relative) $40.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $12.b		; 14 12 ; Test and reset bits $12.b [Reads: Accumulator] [Flags: Z]
	sbc $40.b,S		; E3 40 ; Subtract stack-relative $40.b,S from accumulator with borrow [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ] [SNES: Stack-relative addressing]
	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $13.b		; 14 13 ; Test and reset bits $13.b [Reads: Accumulator] [Flags: Z]
	ora $40.b,S		; 03 40 ; OR accumulator with stack relative $40.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	and ($7F.b)		; 32 7F ; AND accumulator with memory (indirect) ($7F.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	trb $10.b		; 14 10 ; Test and reset bits $10.b [Reads: Accumulator] [Flags: Z]
	.db $82, $00, $33		; 82 00 33 ; Branch always long to $82, $00, $33 [Flow: branch]
	bit #$15.b		; 89 15 ; Test bits #$15.b with accumulator [Reads: Accumulator] [Flags: Z]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,X		; 15 8B ; OR accumulator with memory $8B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,X		; 15 8B ; OR accumulator with memory $8B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,X		; 15 8B ; OR accumulator with memory $8B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,X		; 15 8B ; OR accumulator with memory $8B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,X		; 15 8B ; OR accumulator with memory $8B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,X		; 15 8B ; OR accumulator with memory $8B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,X		; 15 8B ; OR accumulator with memory $8B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,X		; 15 8B ; OR accumulator with memory $8B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,X		; 15 8B ; OR accumulator with memory $8B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,X		; 15 8B ; OR accumulator with memory $8B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8B.b,X		; 15 8B ; OR accumulator with memory $8B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8C.b,X		; 15 8C ; OR accumulator with memory $8C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $8A.b,X		; 15 8A ; OR accumulator with memory $8A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $89.b,X		; 55 89 ; Exclusive OR accumulator with memory $89.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $10.b,X		; 55 10 ; Exclusive OR accumulator with memory $10.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	ora $99.b,S		; 03 99 ; OR accumulator with stack relative $99.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $9A.b,X		; 15 9A ; OR accumulator with memory $9A.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $10.b,X		; 15 10 ; OR accumulator with memory $10.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	eor $99.b,X		; 55 99 ; Exclusive OR accumulator with memory $99.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $10.b,X		; 55 10 ; Exclusive OR accumulator with memory $10.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	rep #$00		; C2 00 ; Reset processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	ora $A9.b,S		; 03 A9 ; OR accumulator with stack relative $A9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $AA.b,X		; 15 AA ; OR accumulator with memory $AA.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $10.b,X		; 15 10 ; OR accumulator with memory $10.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	txs		; 9A ; Transfer X to stack pointer [Reads: X Index] [Writes: Stack Pointer]
	eor $99.b,X		; 55 99 ; Exclusive OR accumulator with memory $99.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $10.b,X		; 55 10 ; Exclusive OR accumulator with memory $10.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sep #$00		; E2 00 ; Set processor status bits #$00 [Writes: Processor Status] [SNES: Configures CPU mode (8/16-bit registers)]
	and ($9D.b,S),Y		; 33 9D ; AND accumulator (stack relative indirect indexed) ($9D.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $AD.b,X		; 15 AD ; OR accumulator with memory $AD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9B.b,X		; 15 9B ; OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9B.b,X		; 15 9B ; OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9B.b,X		; 15 9B ; OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9B.b,X		; 15 9B ; OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9B.b,X		; 15 9B ; OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9B.b,X		; 15 9B ; OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9B.b,X		; 15 9B ; OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9B.b,X		; 15 9B ; OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9B.b,X		; 15 9B ; OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9B.b,X		; 15 9B ; OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9B.b,X		; 15 9B ; OR accumulator with memory $9B.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AD.b,X		; 15 AD ; OR accumulator with memory $AD.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $9D.b,X		; 55 9D ; Exclusive OR accumulator with memory $9D.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	eor $11.b,X		; 55 11 ; Exclusive OR accumulator with memory $11.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and ($AB.b,S),Y		; 33 AB ; AND accumulator (stack relative indirect indexed) ($AB.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AB.b,X		; 15 AB ; OR accumulator with memory $AB.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AC.b,X		; 15 AC ; OR accumulator with memory $AC.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $42, $00		; 42 00 ; Reserved instruction
	ora $1587.w,X		; 1D 87 15 ; OR accumulator with memory $1587.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $62, $80, $1B		; 62 80 1B ; Push effective relative address $62, $80, $1B [Writes: Stack Pointer]
	lda $15A715.l		; AF 15 A7 15 ; Load long $15A715.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $15A715.l		; AF 15 A7 15 ; Load long $15A715.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $15A715.l		; AF 15 A7 15 ; Load long $15A715.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $15A715.l		; AF 15 A7 15 ; Load long $15A715.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $15A715.l		; AF 15 A7 15 ; Load long $15A715.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $15A715.l		; AF 15 A7 15 ; Load long $15A715.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $15A715.l		; AF 15 A7 15 ; Load long $15A715.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($70.b),Y		; 11 70 ; OR accumulator with memory ($70.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	.db $80, $05		; 80 05 ; Branch always to $80, $05 [Flow: branch]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $AE.b,X		; 15 AE ; OR accumulator with memory $AE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $A8.b,X		; 15 A8 ; OR accumulator with memory $A8.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $00.b,S		; C3 00 ; Compare accumulator (stack relative) $00.b,S [Reads: Stack Pointer, Accumulator] [Flags: NCZ]
	and $88.b,X		; 35 88 ; Logical AND $88.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $87.b,X		; 15 87 ; OR accumulator with memory $87.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $88.b,X		; 15 88 ; OR accumulator with memory $88.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $1380.w,X		; FD 80 13 ; Subtract with carry $1380.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	ora $AE.b,X		; 15 AE ; OR accumulator with memory $AE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $A8.b,X		; 15 A8 ; OR accumulator with memory $A8.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AE.b,X		; 15 AE ; OR accumulator with memory $AE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $A8.b,X		; 15 A8 ; OR accumulator with memory $A8.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AE.b,X		; 15 AE ; OR accumulator with memory $AE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $A8.b,X		; 15 A8 ; OR accumulator with memory $A8.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AE.b,X		; 15 AE ; OR accumulator with memory $AE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $A8.b,X		; 15 A8 ; OR accumulator with memory $A8.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $AE.b,X		; 15 AE ; OR accumulator with memory $AE.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $13.b,X		; 15 13 ; OR accumulator with memory $13.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	jsl $973700.l		; 22 00 37 97 ; Jump to subroutine long $973700.l [Writes: Stack Pointer] [Flow: call]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $97.b,X		; 15 97 ; OR accumulator with memory $97.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $98.b,X		; 15 98 ; OR accumulator with memory $98.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $11.b,X		; 15 11 ; OR accumulator with memory $11.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $C0		; F0 C0 ; Branch if equal to $F0, $C0 [Flow: branch]
	ora ($8D.b)		; 12 8D ; OR accumulator with memory (indirect) ($8D.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $60.b,X		; 15 60 ; OR accumulator with memory $60.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldy $00.b		; A4 00 ; Load $00.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: NCZ]
	lda $182218.l		; AF 18 22 18 ; Load long $182218.l into accumulator [Writes: Accumulator] [Flags: NZ]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $2418.w		; 0E 18 24 ; Arithmetic shift left $2418.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $0018.w		; 0D 18 00 ; Logical OR $0018.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	tsb $0418.w		; 0C 18 04 ; Test and set bits $0418.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cpy $00.b		; C4 00 ; Compare $00.b with Y register [Reads: Direct Page, Y Index] [Flags: NCZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	asl $18.b,X		; 16 18 ; Arithmetic shift left $18.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda $183218.l,X		; BF 18 32 18 ; Load long $183218.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and ($18.b,S),Y		; 33 18 ; AND accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $3418.w,X		; 1E 18 34 ; Arithmetic shift left $3418.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $1018.w,X		; 1D 18 10 ; OR accumulator with memory $1018.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	trb $1418.w		; 1C 18 14 ; Test and reset bits $1418.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $02, $00		; 62 02 00 ; Push effective relative address $62, $02, $00 [Writes: Stack Pointer]
	and $1800.w,Y		; 39 00 18 ; AND accumulator with memory $1800.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($18.b,X)		; 01 18 ; Logical OR ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cop $18.b		; 02 18 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $18.b,S		; 03 18 ; OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $18.b		; 05 18 ; Logical OR $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	asl $18.b		; 06 18 ; Arithmetic shift left $18.b [Reads: Direct Page] [Flags: NCZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$18.b]		; 07 18 ; OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $18A918.l		; AF 18 A9 18 ; Load long $18A918.l into accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$18.b		; 09 18 ; Logical OR #$18.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $6218.w		; 2C 18 62 ; Test bits $6218.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	jsl $103900.l		; 22 00 39 10 ; Jump to subroutine long $103900.l [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($18.b),Y		; 11 18 ; OR accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($18.b)		; 12 18 ; OR accumulator with memory (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($18.b,S),Y		; 13 18 ; OR accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $18.b,X		; 15 18 ; OR accumulator with memory $18.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	asl $18.b,X		; 16 18 ; Arithmetic shift left $18.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$18.b],Y		; 17 18 ; OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $18A918.l,X		; BF 18 A9 18 ; Load long $18A918.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora $A918.w,Y		; 19 18 A9 ; OR accumulator with memory $A918.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	dec A		; 3A ; Decrement accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	bit $6218.w,X		; 3C 18 62 ; Test bits $6218.w,X [Reads: X Index] [Flags: NVZ] [Flow: branch]
	.db $42, $00		; 42 00 ; Reserved instruction
	and $180A.w,Y		; 39 0A 18 ; AND accumulator with memory $180A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $A918.w		; 0C 18 A9 ; Test and set bits $A918.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $A918.w		; 0D 18 A9 ; Logical OR $A918.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $A918.w		; 0E 18 A9 ; Arithmetic shift left $A918.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $18A918.l		; 0F 18 A9 18 ; OR accumulator with memory (long) $18A918.l [Writes: Accumulator] [Flags: NZ]
	jsr $A918.w		; 20 18 A9 ; Jump to subroutine at $A918.w [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	and ($18.b,X)		; 21 18 ; Logical AND ($18.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $18A918.l		; 22 18 A9 18 ; Jump to subroutine long $18A918.l [Writes: Stack Pointer] [Flow: call]
	and $18.b,S		; 23 18 ; AND accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	mvp $A9,$18		; 44 18 A9 ; Move block positive $A9,$18 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda $18A918.l		; AF 18 A9 18 ; Load long $18A918.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $18.b		; 46 18 ; Logical shift right $18.b [Reads: Direct Page] [Flags: NCZ]
	.db $62, $62, $00		; 62 62 00 ; Push effective relative address $62, $62, $00 [Writes: Stack Pointer]
	and $181A.w,Y		; 39 1A 18 ; AND accumulator with memory $181A.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	trb $A918.w		; 1C 18 A9 ; Test and reset bits $A918.w [Reads: Accumulator] [Flags: Z]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $A918.w,X		; 1D 18 A9 ; OR accumulator with memory $A918.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	asl $A918.w,X		; 1E 18 A9 ; Arithmetic shift left $A918.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ora $18A918.l,X		; 1F 18 A9 18 ; Logical OR long $18A918.l,X with accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $30, $18		; 30 18 ; Branch if minus to $30, $18 [Flow: branch]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($18.b),Y		; 31 18 ; AND accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($18.b)		; 32 18 ; AND accumulator with memory (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and ($18.b,S),Y		; 33 18 ; AND accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	mvn $A9,$18		; 54 18 A9 ; Move block negative $A9,$18 [Reads: Y Index, Accumulator, X Index] [Writes: Y Index, Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda $18A918.l,X		; BF 18 A9 18 ; Load long $18A918.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr $18.b,X		; 56 18 ; Logical shift right $18.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	.db $62, $82, $00		; 62 82 00 ; Push effective relative address $62, $82, $00 [Writes: Stack Pointer]
	and $1824.w,Y		; 39 24 18 ; AND accumulator with memory $1824.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and $18.b		; 25 18 ; Logical AND $18.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	rol $18.b		; 26 18 ; Rotate left $18.b [Reads: Direct Page] [Flags: NCZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and [$18.b]		; 27 18 ; AND accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$18.b		; 29 18 ; Logical AND #$18.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $18		; 80 18 ; Branch always to $80, $18 [Flow: branch]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($18.b,X)		; 81 18 ; Store accumulator ($18.b,X) [Reads: Direct Page, Accumulator, X Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $82, $18, $A9		; 82 18 A9 ; Branch always long to $82, $18, $A9 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $A918.w		; 4E 18 A9 ; Logical shift right $A918.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $18A918.l		; 4F 18 A9 18 ; Exclusive OR accumulator with memory (long) $18A918.l [Writes: Accumulator] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	.db $62, $A2, $00		; 62 A2 00 ; Push effective relative address $62, $A2, $00 [Writes: Stack Pointer]
	and $1834.w,Y		; 39 34 18 ; AND accumulator with memory $1834.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and $18.b,X		; 35 18 ; Logical AND $18.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	rol $18.b,X		; 36 18 ; Rotate left $18.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and [$18.b],Y		; 37 18 ; AND accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	and $A918.w,Y		; 39 18 A9 ; AND accumulator with memory $A918.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $90, $18		; 90 18 ; Branch if carry clear to $90, $18 [Flow: branch]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($18.b),Y		; 91 18 ; Store accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($18.b)		; 92 18 ; Store accumulator (indirect) ($18.b) [Reads: Direct Page, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr $A918.w,X		; 5E 18 A9 ; Logical shift right $A918.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $18A918.l,X		; 5F 18 A9 18 ; Exclusive OR accumulator with memory (long,X) $18A918.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $70, $18		; 70 18 ; Branch if overflow set to $70, $18 [Flow: branch]
	.db $62, $CC, $00		; 62 CC 00 ; Push effective relative address $62, $CC, $00 [Writes: Stack Pointer]
	ora ($AA.b),Y		; 11 AA ; OR accumulator with memory ($AA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sty $18.b		; 84 18 ; Store Y register to $18.b [Reads: Y Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	ora $0318.w		; 0D 18 03 ; Logical OR $0318.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $62, $EC, $00		; 62 EC 00 ; Push effective relative address $62, $EC, $00 [Writes: Stack Pointer]
	ora ($BA.b),Y		; 11 BA ; OR accumulator with memory ($BA.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sty $18.b,X		; 94 18 ; Store Y register $18.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	ora $1318.w,X		; 1D 18 13 ; OR accumulator with memory $1318.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $00.b		; 66 00 ; Rotate right $00.b [Reads: Direct Page] [Flags: NCZ]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $A918.w		; 2D 18 A9 ; Logical AND $A918.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $A918.w		; 2E 18 A9 ; Rotate left $A918.w [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $18A918.l		; 2F 18 A9 18 ; AND accumulator with memory (long) $18A918.l [Writes: Accumulator] [Flags: NZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($18.b,X)		; 41 18 ; Exclusive OR accumulator with memory ($18.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cpy #$18.b		; C0 18 ; Compare #$18.b with Y register [Reads: Y Index] [Flags: NCZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	eor $18.b,S		; 43 18 ; Exclusive OR accumulator with stack relative $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	inc $18.b		; E6 18 ; Increment $18.b [Reads: Direct Page] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc [$18.b]		; E7 18 ; Subtract with carry (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc #$18.b		; E9 18 ; Subtract #$18.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	nop		; EA ; No operation
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $20.b		; 66 20 ; Rotate right $20.b [Reads: Direct Page] [Flags: NCZ]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $A918.w,X		; 3D 18 A9 ; AND accumulator with memory $A918.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	rol $A918.w,X		; 3E 18 A9 ; Rotate left $A918.w,X [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	and $18A918.l,X		; 3F 18 A9 18 ; AND accumulator with memory (long,X) $18A918.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	.db $50, $18		; 50 18 ; Branch if overflow clear to $50, $18 [Flow: branch]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($18.b),Y		; 51 18 ; Exclusive OR accumulator with memory ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $18		; D0 18 ; Branch if not equal to $D0, $18 [Flow: branch]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	eor ($18.b,S),Y		; 53 18 ; XOR accumulator (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	inc $18.b,X		; F6 18 ; Increment memory $18.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc [$18.b],Y		; F7 18 ; Subtract with carry (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $A918.w,Y		; F9 18 A9 ; Subtract with carry $A918.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $40.b		; 66 40 ; Rotate right $40.b [Reads: Direct Page] [Flags: NCZ]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$18.b]		; 47 18 ; Exclusive OR accumulator with memory (long) [$18.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	eor #$18.b		; 49 18 ; Exclusive OR #$18.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $A918.w		; 4C 18 A9 ; Jump to $A918.w [Flow: jump]
	clc		; 18 ; Clear carry flag [Flags: C]
	eor $A918.w		; 4D 18 A9 ; Exclusive OR $A918.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cpx $A918.w		; EC 18 A9 ; Compare $A918.w with X register [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $A918.w		; ED 18 A9 ; Subtract $A918.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $A918.w		; EE 18 A9 ; Increment $A918.w [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $606618.l		; EF 18 66 60 ; Subtract with carry (long) $606618.l [Writes: Accumulator] [Flags: NCVZ]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	eor [$18.b],Y		; 57 18 ; Exclusive OR accumulator with memory (long indexed) [$18.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	eor $A918.w,Y		; 59 18 A9 ; Exclusive OR accumulator with memory $A918.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tad		; 5B ; Transfer 16-bit accumulator to direct page register [Reads: Accumulator] [Writes: Direct Page] [Flags: NZ] [SNES: Sets DP register from accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jmp $18A918.l		; 5C 18 A9 18 ; Jump long to $18A918.l [Flow: jump]
	eor $A918.w,X		; 5D 18 A9 ; Exclusive OR accumulator with memory $A918.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xce		; FB ; Exchange carry and emulation bits [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsr ($A918.w,X)		; FC 18 A9 ; Jump to subroutine indirect indexed ($A918.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $A918.w,X		; FD 18 A9 ; Subtract with carry $A918.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	inc $A918.w,X		; FE 18 A9 ; Increment memory $A918.w,X [Reads: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $806618.l,X		; FF 18 66 80 ; Subtract with carry (long,X) $806618.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($18.b,X)		; 61 18 ; Add with carry ($18.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $62, $18, $A9		; 62 18 A9 ; Push effective relative address $62, $18, $A9 [Writes: Stack Pointer]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $18.b,S		; 63 18 ; Add with carry (stack relative) $18.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $80, $18		; 80 18 ; Branch always to $80, $18 [Flow: branch]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($18.b,X)		; 81 18 ; Store accumulator ($18.b,X) [Reads: Direct Page, Accumulator, X Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $82, $18, $A9		; 82 18 A9 ; Branch always long to $82, $18, $A9 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($18.b,X)		; C1 18 ; Compare accumulator ($18.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $18A918.l		; 6F 18 A9 18 ; Add with carry (long) $18A918.l [Writes: Accumulator] [Flags: NCVZ]
	sta $18.b		; 85 18 ; Store accumulator to $18.b [Reads: Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	stx $18.b		; 86 18 ; Store X register to $18.b [Reads: X Index]
	ror $A0.b		; 66 A0 ; Rotate right $A0.b [Reads: Direct Page] [Flags: NCZ]
	brk $31.b		; 00 31 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($18.b),Y		; 71 18 ; Add with carry ($18.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($18.b)		; 72 18 ; Add with carry (indirect) ($18.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc ($18.b,S),Y		; 73 18 ; Add with carry (stack relative indirect indexed) ($18.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $90, $18		; 90 18 ; Branch if carry clear to $90, $18 [Flow: branch]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($18.b),Y		; 91 18 ; Store accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta ($18.b)		; 92 18 ; Store accumulator (indirect) ($18.b) [Reads: Direct Page, Accumulator]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp ($18.b),Y		; D1 18 ; Compare accumulator ($18.b),Y [Reads: Direct Page, Y Index, Accumulator] [Flags: NCZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	adc $18A918.l,X		; 7F 18 A9 18 ; Add long $18A918.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $18.b,X		; 95 18 ; Store accumulator to $18.b,X [Reads: Accumulator, X Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	stx $18.b,Y		; 96 18 ; Store X register $18.b,Y [Reads: Direct Page, Y Index] [Writes: X Index]
	ror $C4.b		; 66 C4 ; Rotate right $C4.b [Reads: Direct Page] [Flags: NCZ]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sty $18.b		; 84 18 ; Store Y register to $18.b [Reads: Y Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	ora $0318.w		; 0D 18 03 ; Logical OR $0318.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sty $18.b		; 84 18 ; Store Y register to $18.b [Reads: Y Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tsb $18.b		; 04 18 ; Test and set bits $18.b [Reads: Accumulator] [Flags: Z]
	ora $0318.w		; 0D 18 03 ; Logical OR $0318.w with accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	ror $E4.b		; 66 E4 ; Rotate right $E4.b [Reads: Direct Page] [Flags: NCZ]
	brk $2D.b		; 00 2D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sty $18.b,X		; 94 18 ; Store Y register $18.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	ora $1318.w,X		; 1D 18 13 ; OR accumulator with memory $1318.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sty $18.b,X		; 94 18 ; Store Y register $18.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda #$18.b		; A9 18 ; Load #$18.b into accumulator [Writes: Accumulator] [Flags: NZ]
	trb $18.b		; 14 18 ; Test and reset bits $18.b [Reads: Accumulator] [Flags: Z]
	ora $1318.w,X		; 1D 18 13 ; OR accumulator with memory $1318.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sbc $807060.l,X		; FF 60 70 80 ; Subtract with carry (long,X) $807060.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	adc #$6B.b		; 69 6B ; Add #$6B.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	adc $8B6E.w		; 6D 6E 8B ; Add $8B6E.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldy #$03.b		; A0 03 ; Load #$03.b into Y register [Writes: Y Index] [Flags: NZ]
	ldx #$0C.b		; A2 0C ; Load #$0C.b into X register [Writes: X Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0A20.w,Y		; 99 20 0A ; Store accumulator to $0A20.w,Y [Reads: Y Index, Accumulator]
	lda $ED7A.w,Y		; B9 7A ED ; Load $ED7A.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0800.w,X		; 9D 00 08 ; Store accumulator to $0800.w,X [Reads: Accumulator, X Index]
	lda #$68.b		; A9 68 ; Load #$68.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0801.w,X		; 9D 01 08 ; Store accumulator to $0801.w,X [Reads: Accumulator, X Index]
	lda $ED7E.w,Y		; B9 7E ED ; Load $ED7E.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0802.w,X		; 9D 02 08 ; Store accumulator to $0802.w,X [Reads: Accumulator, X Index]
	lda #$32.b		; A9 32 ; Load #$32.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0803.w,X		; 9D 03 08 ; Store accumulator to $0803.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $DE		; 10 DE ; Branch if plus to $10, $DE [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $13.b		; A5 13 ; Load $13.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $1A		; F0 1A ; Branch if equal to $F0, $1A [Flow: branch]
	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $16		; F0 16 ; Branch if equal to $F0, $16 [Flow: branch]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $12		; F0 12 ; Branch if equal to $F0, $12 [Flow: branch]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0A		; F0 0A ; Branch if equal to $F0, $0A [Flow: branch]
	lda $F4.b		; A5 F4 ; Load $F4.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$90.b		; 29 90 ; Logical AND #$90.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jmp ($EDD2.w,X)		; 7C D2 ED ; Jump indirect indexed to ($EDD2.w,X) [Reads: X Index] [Flow: jump]
	inc $ED.b		; E6 ED ; Increment $ED.b [Reads: Direct Page] [Flags: NZ]
	tsb $CBEE.w		; 0C EE CB ; Test and set bits $CBEE.w [Reads: Accumulator] [Flags: Z]
	inc $EEE5.w		; EE E5 EE ; Increment $EEE5.w [Flags: NZ]
	tsx		; BA ; Transfer stack pointer to X [Reads: Stack Pointer] [Writes: X Index] [Flags: NZ]
	inc $F115.w		; EE 15 F1 ; Increment $F115.w [Flags: NZ]
	wai		; CB ; Wait for interrupt
	inc $EEE5.w		; EE E5 EE ; Increment $EEE5.w [Flags: NZ]
	ora $F1.b,X		; [PATTERN: Memory clearing operation] 15 F1 ; OR accumulator with memory $F1.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	brk $F7.b		; 00 F7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $0CC404.l		; 22 04 C4 0C ; Jump to subroutine long $0CC404.l [Writes: Stack Pointer] [Flow: call]
	stz $1F00.w		; 9C 00 1F ; Store zero to $1F00.w
	stz $012A.w		; 9C 2A 01 ; Store zero to $012A.w
	jsr $FE56.w		; 20 56 FE ; Jump to subroutine at $FE56.w [Writes: Stack Pointer] [Flow: call]
	lda $13.b		; A5 13 ; Load $13.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	dec $13.b		; C6 13 ; Decrement $13.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $00893D.l		; [PATTERN: Memory clearing operation] 22 3D 89 00 ; Jump to subroutine long $00893D.l [Writes: Stack Pointer] [Flow: call]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0128.w		; 8D 28 01 ; Store accumulator to $0128.w [Reads: Accumulator]
	stz $012A.w		; 9C 2A 01 ; Store zero to $012A.w
	stz $1F0C.w		; 9C 0C 1F ; Store zero to $1F0C.w
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldx #$50.b		; A2 50 ; Load #$50.b into X register [Writes: X Index] [Flags: NZ]
	stz $20.b,X		; 74 20 ; Store zero to $20.b,X [Reads: X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $FB		; 10 FB ; Branch if plus to $10, $FB [Flow: branch]
	jsl $00834B.l		; 22 4B 83 00 ; Jump to subroutine long $00834B.l [Writes: Stack Pointer] [Flow: call]
	jsl $00E36D.l		; 22 6D E3 00 ; Jump to subroutine long $00E36D.l [Writes: Stack Pointer] [Flow: call]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AB3.w		; 8D B3 0A ; Store accumulator to $0AB3.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AB2.w		; 8D B2 0A ; Store accumulator to $0AB2.w [Reads: Accumulator]
	stz $0AA9.w		; 9C A9 0A ; Store zero to $0AA9.w
	jsl $1BEE52.l		; 22 52 EE 1B ; Jump to subroutine long $1BEE52.l [Writes: Stack Pointer] [Flow: call]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA9.w		; 8D A9 0A ; Store accumulator to $0AA9.w [Reads: Accumulator]
	jsl $1BEEC7.l		; 22 C7 EE 1B ; Jump to subroutine long $1BEEC7.l [Writes: Stack Pointer] [Flow: call]
	jsl $1BEE52.l		; 22 52 EE 1B ; Jump to subroutine long $1BEE52.l [Writes: Stack Pointer] [Flow: call]
	jsl $1BEDF9.l		; 22 F9 ED 1B ; Jump to subroutine long $1BEDF9.l [Writes: Stack Pointer] [Flow: call]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC53A.l		; 8F 3A C5 7E ; Store accumulator (long) $7EC53A.l [Reads: Accumulator]
	lda #$38.b		; A9 38 ; Load #$38.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC53B.l		; 8F 3B C5 7E ; Store accumulator (long) $7EC53B.l [Reads: Accumulator]
	inc $15.b		; E6 15 ; Increment $15.b [Reads: Direct Page] [Flags: NZ]
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $EA.b		; 85 EA ; Store accumulator to $EA.b [Reads: Accumulator]
	jsr $F7E6.w		; [PATTERN: Memory clearing operation] 20 E6 F7 ; Jump to subroutine at $F7E6.w [Writes: Stack Pointer] [Flow: call]
.INDEX 16
	rep #$10		; C2 10
	stz $1CD8.w		; 9C D8 1C ; Store zero to $1CD8.w
	ldx #$0112.w		; A2 12 01 ; Load #$0112.w into X register [Writes: X Index] [Flags: NZ]
	stx $1CF0.w		; 8E F0 1C ; Store X register to $1CF0.w [Reads: X Index]
	stz $E8.b		; 64 E8 ; Store zero to $E8.b
	stz $E9.b		; 64 E9 ; Store zero to $E9.b
	ldx #$1010.w		; A2 10 10 ; Load #$1010.w into X register [Writes: X Index] [Flags: NZ]
	stx $0200.w		; 8E 00 02 ; Store X register to $0200.w [Reads: X Index]
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	inc $22.b		; [PATTERN: Memory clearing operation] E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
.INDEX 8
	sep #$10		; E2 10
	jsr $FAA3.w		; 20 A3 FA ; Jump to subroutine at $FAA3.w [Writes: Stack Pointer] [Flow: call]
	stz $96.b		; 64 96 ; Store zero to $96.b
	stz $97.b		; 64 97 ; Store zero to $97.b
	lda #$B0.b		; A9 B0 ; Load #$B0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $98.b		; 85 98 ; Store accumulator to $98.b [Reads: Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1E.b		; 85 1E ; Store accumulator to $1E.b [Reads: Accumulator]
	stz $1F.b		; 64 1F ; Store zero to $1F.b
	lda #$25.b		; A9 25 ; Load #$25.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9C.b		; 85 9C ; Store accumulator to $9C.b [Reads: Accumulator]
	lda #$45.b		; A9 45 ; Load #$45.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9D.b		; 85 9D ; Store accumulator to $9D.b [Reads: Accumulator]
	lda #$85.b		; A9 85 ; Load #$85.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9E.b		; 85 9E ; Store accumulator to $9E.b [Reads: Accumulator]
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $99.b		; [PATTERN: Memory clearing operation] 85 99 ; Store accumulator to $99.b [Reads: Accumulator]
	lda #$A3.b		; A9 A3 ; Load #$A3.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9A.b		; 85 9A ; Store accumulator to $9A.b [Reads: Accumulator]
	stz WBGLOG.w		; 9C 2A 21 ; Store zero to WBGLOG.w
	stz WOBJLOG.w		; 9C 2B 21 ; Store zero to WOBJLOG.w
	lda #$C0.b		; A9 C0 ; Load #$C0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9B.b		; 85 9B ; Store accumulator to $9B.b [Reads: Accumulator]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	inc $27.b		; E6 27 ; Increment $27.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $13.b		; A5 13 ; Load $13.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	dec $5E.b		; C6 5E ; Decrement $5E.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	inc $13.b		; E6 13 ; Increment $13.b [Reads: Direct Page] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $5E.b		; 85 5E ; Store accumulator to $5E.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $5F.b		; E6 5F ; Increment $5F.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $13.b		; A5 13 ; Load $13.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $22		; F0 22 ; Branch if equal to $F0, $22 [Flow: branch]
	dec $5E.b		; C6 5E ; Decrement $5E.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	inc $13.b		; E6 13 ; Increment $13.b [Reads: Direct Page] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $5E.b		; 85 5E ; Store accumulator to $5E.b [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $13.b		; A5 13 ; Load $13.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $0B		; F0 0B ; Branch if equal to $F0, $0B [Flow: branch]
	dec $5E.b		; C6 5E ; Decrement $5E.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $06		; 10 06 ; Branch if plus to $10, $06 [Flow: branch]
	dec $13.b		; C6 13 ; Decrement $13.b [Reads: Direct Page] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $5E.b		; 85 5E ; Store accumulator to $5E.b [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $00893D.l		; 22 3D 89 00 ; Jump to subroutine long $00893D.l [Writes: Stack Pointer] [Flow: call]
	jsl $00834B.l		; 22 4B 83 00 ; Jump to subroutine long $00834B.l [Writes: Stack Pointer] [Flow: call]
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jmp ($EEEC.w,X)		; 7C EC EE ; Jump indirect indexed to ($EEEC.w,X) [Reads: X Index] [Flow: jump]
	sed		; F8 ; Set decimal flag [Flags: D]
	inc $EEFF.w		; EE FF EE ; Increment $EEFF.w [Flags: NZ]
	lsr $E3EF.w		; 4E EF E3 ; Logical shift right $E3EF.w [Flags: NCZ]
	sbc $DCF058.l		; EF 58 F0 DC ; Subtract with carry (long) $DCF058.l [Writes: Accumulator] [Flags: NCVZ]
	.db $F0, $64		; F0 64 ; Branch if equal to $F0, $64 [Flow: branch]
	rol $E6.b		; 26 E6 ; Rotate left $E6.b [Reads: Direct Page] [Flags: NCZ]
	jsl $6B1364.l		; 22 64 13 6B ; Jump to subroutine long $6B1364.l [Writes: Stack Pointer] [Flow: call]
	lda #$13.b		; A9 13 ; Load #$13.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta BG1SC.w		; 8D 07 21 ; Store accumulator to BG1SC.w [Reads: Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta BG2SC.w		; 8D 08 21 ; Store accumulator to BG2SC.w [Reads: Accumulator]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $99.b		; 85 99 ; Store accumulator to $99.b [Reads: Accumulator]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9A.b		; 85 9A ; Store accumulator to $9A.b [Reads: Accumulator]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta BGMODE.w		; 8D 05 21 ; Store accumulator to BGMODE.w [Reads: Accumulator]
	sta $94.b		; 85 94 ; Store accumulator to $94.b [Reads: Accumulator]
	lda #$80.b		; A9 80 ; Load #$80.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta M7SEL.w		; 8D 1A 21 ; Store accumulator to M7SEL.w [Reads: Accumulator]
	jsl $0ABA30.l		; 22 30 BA 0A ; Jump to subroutine long $0ABA30.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda #$00ED.w		; A9 ED 00 ; Load #$00ED.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $063A.w		; 8D 3A 06 ; Store accumulator to $063A.w [Reads: Accumulator]
	lda #$0100.w		; A9 00 01 ; Load #$0100.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0638.w		; 8D 38 06 ; Store accumulator to $0638.w [Reads: Accumulator]
	lda #$0080.w		; A9 80 00 ; Load #$0080.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0120.w		; 8D 20 01 ; Store accumulator to $0120.w [Reads: Accumulator]
	lda #$00C0.w		; A9 C0 00 ; Load #$00C0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0124.w		; 8D 24 01 ; Store accumulator to $0124.w [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0637.w		; 8D 37 06 ; Store accumulator to $0637.w [Reads: Accumulator]
	jsr $F783.w		; 20 83 F7 ; Jump to subroutine at $F783.w [Writes: Stack Pointer] [Flow: call]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $25.b		; [PATTERN: Memory clearing operation] 85 25 ; Store accumulator to $25.b [Reads: Accumulator]
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	stz $13.b		; 64 13 ; Store zero to $13.b
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz HDMAEN.w		; 9C 0C 42 ; Store zero to HDMAEN.w
	stz $9B.b		; 64 9B ; Store zero to $9B.b
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $99.b		; 85 99 ; Store accumulator to $99.b [Reads: Accumulator]
	lda #$20.b		; A9 20 ; Load #$20.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $9A.b		; 85 9A ; Store accumulator to $9A.b [Reads: Accumulator]
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AA4.w		; 8D A4 0A ; Store accumulator to $0AA4.w [Reads: Accumulator]
	jsl $00E384.l		; 22 84 E3 00 ; Jump to subroutine long $00E384.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
	sep #$20		; E2 20
	lda #$74.b		; A9 74 ; Load #$74.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $02C533.l		; 22 33 C5 02 ; Jump to subroutine long $02C533.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $22.b		; [PATTERN: Memory clearing operation] 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	stz $0AB6.w		; 9C B6 0A ; Store zero to $0AB6.w
	stz $0AAC.w		; 9C AC 0A ; Store zero to $0AAC.w
	lda #$0E.b		; A9 0E ; Load #$0E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AAD.w		; 8D AD 0A ; Store accumulator to $0AAD.w [Reads: Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AAE.w		; 8D AE 0A ; Store accumulator to $0AAE.w [Reads: Accumulator]
	ldx #$7E.b		; A2 7E ; Load #$7E.b into X register [Writes: X Index] [Flags: NZ]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $02C546.l		; 22 46 C5 02 ; Jump to subroutine long $02C546.l [Writes: Stack Pointer] [Flow: call]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC53A.l		; 8F 3A C5 7E ; Store accumulator (long) $7EC53A.l [Reads: Accumulator]
	lda #$38.b		; A9 38 ; Load #$38.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC53B.l		; 8F 3B C5 7E ; Store accumulator (long) $7EC53B.l [Reads: Accumulator]
	stz $1CD8.w		; 9C D8 1C ; Store zero to $1CD8.w
	lda #$13.b		; A9 13 ; Load #$13.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF0.w		; 8D F0 1C ; Store accumulator to $1CF0.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF1.w		; 8D F1 1C ; Store accumulator to $1CF1.w [Reads: Accumulator]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $25.b		; 85 25 ; Store accumulator to $25.b [Reads: Accumulator]
	lda #$E0.b		; A9 E0 ; Load #$E0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $2C.b		; 85 2C ; Store accumulator to $2C.b [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda #$0210.w		; [PATTERN: Memory clearing operation] A9 10 02 ; Load #$0210.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $64.b		; 85 64 ; Store accumulator to $64.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	stz $13.b		; 64 13 ; Store zero to $13.b
	stz $EA.b		; 64 EA ; Store zero to $EA.b
	lda $011F.w		; AD 1F 01 ; Load $011F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $011F.w		; 8D 1F 01 ; Store accumulator to $011F.w [Reads: Accumulator]
	lda $0123.w		; AD 23 01 ; Load $0123.w into accumulator [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0123.w		; 8D 23 01 ; Store accumulator to $0123.w [Reads: Accumulator]
	lda $E3.b		; A5 E3 ; Load $E3.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $E3.b		; 85 E3 ; Store accumulator to $E3.b [Reads: Accumulator]
	lda $E9.b		; A5 E9 ; Load $E9.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$01.b		; [PATTERN: Memory clearing operation] 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $E9.b		; 85 E9 ; Store accumulator to $E9.b [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	stz $99.b		; 64 99 ; Store zero to $99.b
	stz $9A.b		; 64 9A ; Store zero to $9A.b
.ACCU 16
	rep #$20		; C2 20
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
	sep #$20		; E2 20
	lda #$73.b		; A9 73 ; Load #$73.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $02C533.l		; 22 33 C5 02 ; Jump to subroutine long $02C533.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $22.b		; 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AB6.w		; 8D B6 0A ; Store accumulator to $0AB6.w [Reads: Accumulator]
	stz $0AAC.w		; 9C AC 0A ; Store zero to $0AAC.w
	lda #$0E.b		; A9 0E ; Load #$0E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AAD.w		; 8D AD 0A ; Store accumulator to $0AAD.w [Reads: Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AAE.w		; 8D AE 0A ; Store accumulator to $0AAE.w [Reads: Accumulator]
	ldx #$7F.b		; A2 7F ; Load #$7F.b into X register [Writes: X Index] [Flags: NZ]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $02C546.l		; 22 46 C5 02 ; Jump to subroutine long $02C546.l [Writes: Stack Pointer] [Flow: call]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC53A.l		; 8F 3A C5 7E ; Store accumulator (long) $7EC53A.l [Reads: Accumulator]
	lda #$38.b		; A9 38 ; Load #$38.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC53B.l		; 8F 3B C5 7E ; Store accumulator (long) $7EC53B.l [Reads: Accumulator]
	stz $1CD8.w		; 9C D8 1C ; Store zero to $1CD8.w
	lda #$14.b		; A9 14 ; Load #$14.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF0.w		; 8D F0 1C ; Store accumulator to $1CF0.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF1.w		; 8D F1 1C ; Store accumulator to $1CF1.w [Reads: Accumulator]
	lda #$94.b		; A9 94 ; Load #$94.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $2B.b		; [PATTERN: Memory clearing operation] 85 2B ; Store accumulator to $2B.b [Reads: Accumulator]
	lda #$68.b		; A9 68 ; Load #$68.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $30.b		; 85 30 ; Store accumulator to $30.b [Reads: Accumulator]
	stz $31.b		; 64 31 ; Store zero to $31.b
	stz $32.b		; 64 32 ; Store zero to $32.b
	stz $33.b		; [PATTERN: Memory clearing operation] 64 33 ; Store zero to $33.b
	stz $40.b		; 64 40 ; Store zero to $40.b
	stz $50.b		; 64 50 ; Store zero to $50.b
	stz $5F.b		; 64 5F ; Store zero to $5F.b
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $25.b		; 85 25 ; Store accumulator to $25.b [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda #$0240.w		; A9 40 02 ; Load #$0240.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $64.b		; 85 64 ; Store accumulator to $64.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	jmp $EFC0.w		; 4C C0 EF ; Jump to $EFC0.w [Flow: jump]
.ACCU 16
	rep #$20		; C2 20
	lda $20.b		; A5 20 ; Load $20.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
	lda $22.b		; A5 22 ; Load $22.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	pha		; 48 ; Push accumulator [Reads: Accumulator] [Writes: Stack Pointer]
.ACCU 8
	sep #$20		; E2 20
	lda #$75.b		; A9 75 ; Load #$75.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $02C533.l		; 22 33 C5 02 ; Jump to subroutine long $02C533.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $22.b		; [PATTERN: Memory clearing operation] 85 22 ; Store accumulator to $22.b [Reads: Accumulator]
	pla		; 68 ; Pull accumulator [Reads: Stack Pointer] [Writes: Stack Pointer, Accumulator] [Flags: NZ]
	sta $20.b		; 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	stz $0AB6.w		; 9C B6 0A ; Store zero to $0AB6.w
	stz $0AAC.w		; 9C AC 0A ; Store zero to $0AAC.w
	lda #$0E.b		; A9 0E ; Load #$0E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AAD.w		; 8D AD 0A ; Store accumulator to $0AAD.w [Reads: Accumulator]
	lda #$03.b		; A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0AAE.w		; 8D AE 0A ; Store accumulator to $0AAE.w [Reads: Accumulator]
	stz $0AA9.w		; 9C A9 0A ; Store zero to $0AA9.w
	jsl $02C55E.l		; 22 5E C5 02 ; Jump to subroutine long $02C55E.l [Writes: Stack Pointer] [Flow: call]
	ldx #$7F.b		; A2 7F ; Load #$7F.b into X register [Writes: X Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	jsl $02C546.l		; 22 46 C5 02 ; Jump to subroutine long $02C546.l [Writes: Stack Pointer] [Flow: call]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC33A.l		; 8F 3A C3 7E ; Store accumulator (long) $7EC33A.l [Reads: Accumulator]
	sta $7EC53A.l		; 8F 3A C5 7E ; Store accumulator (long) $7EC53A.l [Reads: Accumulator]
	lda #$38.b		; A9 38 ; Load #$38.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $7EC33B.l		; 8F 3B C3 7E ; Store accumulator (long) $7EC33B.l [Reads: Accumulator]
	sta $7EC53B.l		; 8F 3B C5 7E ; Store accumulator (long) $7EC53B.l [Reads: Accumulator]
	stz $1CD8.w		; 9C D8 1C ; Store zero to $1CD8.w
	lda #$15.b		; A9 15 ; Load #$15.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF0.w		; 8D F0 1C ; Store accumulator to $1CF0.w [Reads: Accumulator]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1CF1.w		; 8D F1 1C ; Store accumulator to $1CF1.w [Reads: Accumulator]
	lda #$FF.b		; A9 FF ; Load #$FF.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $25.b		; 85 25 ; Store accumulator to $25.b [Reads: Accumulator]
	lda #$70.b		; A9 70 ; Load #$70.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $30.b		; 85 30 ; Store accumulator to $30.b [Reads: Accumulator]
	sta $62.b		; 85 62 ; Store accumulator to $62.b [Reads: Accumulator]
	lda #$70.b		; A9 70 ; Load #$70.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $63.b		; [PATTERN: Memory clearing operation] 85 63 ; Store accumulator to $63.b [Reads: Accumulator]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $32.b		; 85 32 ; Store accumulator to $32.b [Reads: Accumulator]
	stz $50.b		; 64 50 ; Store zero to $50.b
	stz $51.b		; 64 51 ; Store zero to $51.b
	stz $52.b		; [PATTERN: Memory clearing operation] 64 52 ; Store zero to $52.b
	stz $5F.b		; 64 5F ; Store zero to $5F.b
	stz $60.b		; 64 60 ; Store zero to $60.b
	stz $61.b		; 64 61 ; Store zero to $61.b
.ACCU 16
	rep #$20		; C2 20
	lda #$00C0.w		; A9 C0 00 ; Load #$00C0.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $64.b		; 85 64 ; Store accumulator to $64.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	jmp $EFC0.w		; 4C C0 EF ; Jump to $EFC0.w [Flow: jump]
.ACCU 16
	rep #$20		; C2 20
	jsl $0ABC33.l		; 22 33 BC 0A ; Jump to subroutine long $0ABC33.l [Writes: Stack Pointer] [Flow: call]
	inc $0710.w		; [PATTERN: Memory clearing operation] EE 10 07 ; Increment $0710.w [Flags: NZ]
	jsl $0CC1F9.l		; 22 F9 C1 0C ; Jump to subroutine long $0CC1F9.l [Writes: Stack Pointer] [Flow: call]
	jsl $02811A.l		; 22 1A 81 02 ; Jump to subroutine long $02811A.l [Writes: Stack Pointer] [Flow: call]
	stz $EA.b		; 64 EA ; Store zero to $EA.b
.ACCU 16
	rep #$20		; C2 20
	stz $063A.w		; 9C 3A 06 ; Store zero to $063A.w
	stz $0638.w		; [PATTERN: Memory clearing operation] 9C 38 06 ; Store zero to $0638.w
	stz $0120.w		; 9C 20 01 ; Store zero to $0120.w
	stz $0124.w		; 9C 24 01 ; Store zero to $0124.w
	stz $011E.w		; 9C 1E 01 ; Store zero to $011E.w
	stz $0122.w		; 9C 22 01 ; Store zero to $0122.w
.ACCU 8
	sep #$20		; E2 20
	lda #$F1.b		; [PATTERN: Memory clearing operation] A9 F1 ; Load #$F1.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012C.w		; 8D 2C 01 ; Store accumulator to $012C.w [Reads: Accumulator]
	stz $23.b		; 64 23 ; Store zero to $23.b
	stz $10.b		; 64 10 ; Store zero to $10.b
	lda #$0A.b		; A9 0A ; Load #$0A.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $11.b		; 85 11 ; Store accumulator to $11.b [Reads: Accumulator]
	sta $B0.b		; 85 B0 ; Store accumulator to $B0.b [Reads: Accumulator]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $23.b		; A5 23 ; Load $23.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jmp ($F11C.w,X)		; 7C 1C F1 ; Jump indirect indexed to ($F11C.w,X) [Reads: X Index] [Flow: jump]
	rol $F1.b		; 26 F1 ; Rotate left $F1.b [Reads: Direct Page] [Flags: NCZ]
	ror $F1.b,X		; 76 F1 ; Rotate right $F1.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	sbc ($7A.b),Y		; F1 7A ; Subtract with carry ($7A.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($23.b)		; F2 23 ; Subtract with carry (indirect) ($23.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	pea $1AA5.w		; F4 A5 1A ; Push absolute address $1AA5.w to stack [Writes: Stack Pointer] [SNES: Pushes 16-bit address to stack]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	inc $0124.w		; EE 24 01 ; Increment $0124.w [Flags: NZ]
	inc $0120.w		; EE 20 01 ; Increment $0120.w [Flags: NZ]
	inc $0122.w		; EE 22 01 ; Increment $0122.w [Flags: NZ]
	dec $011E.w		; CE 1E 01 ; Decrement $011E.w [Flags: NZ]
	lda $27.b		; A5 27 ; Load $27.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	jsr $F73E.w		; [PATTERN: Memory clearing operation] 20 3E F7 ; Jump to subroutine at $F73E.w [Writes: Stack Pointer] [Flow: call]
	stz $27.b		; 64 27 ; Store zero to $27.b
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: NZ]
	inc $26.b		; E6 26 ; Increment $26.b [Reads: Direct Page] [Flags: NZ]
	stz $F2.b		; 64 F2 ; Store zero to $F2.b
	stz $F6.b		; [PATTERN: Memory clearing operation] 64 F6 ; Store zero to $F6.b
	stz $F4.b		; 64 F4 ; Store zero to $F4.b
	jsl $0EC440.l		; 22 40 C4 0E ; Jump to subroutine long $0EC440.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	dec $0200.w		; CE 00 02 ; Decrement $0200.w [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	inc $23.b		; E6 23 ; Increment $23.b [Reads: Direct Page] [Flags: NZ]
	dec $22.b		; C6 22 ; Decrement $22.b [Reads: Direct Page] [Flags: NZ]
	dec $22.b		; C6 22 ; Decrement $22.b [Reads: Direct Page] [Flags: NZ]
	dec $22.b		; C6 22 ; Decrement $22.b [Reads: Direct Page] [Flags: NZ]
	.db $80, $11		; 80 11 ; Branch always to $80, $11 [Flow: branch]
	lda $0200.w		; AD 00 02 ; Load $0200.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$18.b		; C9 18 ; Compare #$18.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	brk $B0.b		; 00 B0 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora #$29.b		; 09 29 ; Logical OR #$29.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	dec $13.b		; C6 13 ; Decrement $13.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $0637.w		; AD 37 06 ; Load $0637.w into accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$00.b		; C9 00 ; Compare #$00.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $1B		; F0 1B ; Branch if equal to $F0, $1B [Flow: branch]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	dec $13.b		; C6 13 ; Decrement $13.b [Reads: Direct Page] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	dec $25.b		; C6 25 ; Decrement $25.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $0E		; D0 0E ; Branch if not equal to $D0, $0E [Flow: branch]
	sty $25.b		; 84 25 ; Store Y register to $25.b [Reads: Y Index]
	lda $0637.w		; AD 37 06 ; Load $0637.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$01.b		; E9 01 ; Subtract #$01.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0637.w		; 8D 37 06 ; Store accumulator to $0637.w [Reads: Accumulator]
	jsr $F783.w		; 20 83 F7 ; Jump to subroutine at $F783.w [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsl $00893D.l		; 22 3D 89 00 ; Jump to subroutine long $00893D.l [Writes: Stack Pointer] [Flow: call]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta BGMODE.w		; 8D 05 21 ; Store accumulator to BGMODE.w [Reads: Accumulator]
	sta $94.b		; 85 94 ; Store accumulator to $94.b [Reads: Accumulator]
	jsl $00834B.l		; 22 4B 83 00 ; Jump to subroutine long $00834B.l [Writes: Stack Pointer] [Flow: call]
	inc $23.b		; E6 23 ; Increment $23.b [Reads: Direct Page] [Flags: NZ]
	dec $22.b		; C6 22 ; Decrement $22.b [Reads: Direct Page] [Flags: NZ]
	dec $22.b		; C6 22 ; Decrement $22.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda [$F8.b]		; A7 F8 ; Load accumulator (long) [$F8.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tyx		; BB ; Transfer Y to X [Reads: Y Index] [Writes: X Index] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp ($F8.b,X)		; C1 F8 ; Compare accumulator ($F8.b,X) [Reads: Direct Page, Accumulator, X Index] [Flags: NCZ]
	lda $F8C7F8.l		; AF F8 C7 F8 ; Load long $F8C7F8.l into accumulator [Writes: Accumulator] [Flags: NZ]
	lda ($F8.b,S),Y		; B3 F8 ; Load accumulator (stack relative indirect indexed) ($F8.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cmp $B7F8.w		; CD F8 B7 ; Compare $B7F8.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	cmp ($F8.b,S),Y		; D3 F8 ; Compare accumulator (stack relative indirect indexed) ($F8.b,S),Y [Reads: Y Index, Stack Pointer, Accumulator] [Flags: NCZ]
	.db $50, $68		; 50 68 ; Branch if overflow clear to $50, $68 [Flow: branch]
	cli		; 58 ; Clear interrupt disable flag [Flags: I]
	jsr $0503.w		; 20 03 05 ; Jump to subroutine at $0503.w [Writes: Stack Pointer] [Flow: call]
	stz $2A.b		; 64 2A ; Store zero to $2A.b
	lda $52.b		; A5 52 ; Load $52.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	lda $13.b		; A5 13 ; Load $13.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	inc $13.b		; E6 13 ; Increment $13.b [Reads: Direct Page] [Flags: NZ]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	inc $52.b		; E6 52 ; Increment $52.b [Reads: Direct Page] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $0122.w		; AD 22 01 ; Load $0122.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $22		; D0 22 ; Branch if not equal to $D0, $22 [Flow: branch]
.ACCU 8
	sep #$20		; E2 20
	jsr $F766.w		; 20 66 F7 ; Jump to subroutine at $F766.w [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda $64.b		; A5 64 ; Load $64.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	lda $2C.b		; A5 2C ; Load $2C.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$1F.b		; C9 1F ; Compare #$1F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	dec $13.b		; C6 13 ; Decrement $13.b [Reads: Direct Page] [Flags: NZ]
	dec $2C.b		; C6 2C ; Decrement $2C.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	inc $23.b		; E6 23 ; Increment $23.b [Reads: Direct Page] [Flags: NZ]
	inc $22.b		; E6 22 ; Increment $22.b [Reads: Direct Page] [Flags: NZ]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $0122.w		; CE 22 01 ; Decrement $0122.w [Flags: NZ]
	dec $0124.w		; CE 24 01 ; Decrement $0124.w [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	ldx #$02.b		; A2 02 ; Load #$02.b into X register [Writes: X Index] [Flags: NZ]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.ACCU 16
	rep #$20		; C2 20
	lda $0CF1AE.l,X		; BF AE F1 0C ; Load long $0CF1AE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $2D.b		; 85 2D ; Store accumulator to $2D.b [Reads: Accumulator]
	lda $0CF1B2.l,X		; BF B2 F1 0C ; Load long $0CF1B2.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0CF1B6.l,X		; BF B6 F1 0C ; Load long $0CF1B6.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0CF1BA.l,X		; BF BA F1 0C ; Load long $0CF1BA.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0CF1BE.l,X		; BF BE F1 0C ; Load long $0CF1BE.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0CF1C4.l,X		; BF C4 F1 0C ; Load long $0CF1C4.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc $0122.w		; ED 22 01 ; Subtract $0122.w from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	cmp #$FFE0.w		; C9 E0 FF ; Compare #$FFE0.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $30, $12		; 30 12 ; Branch if minus to $30, $12 [Flow: branch]
	lda $0CF1C2.l,X		; BF C2 F1 0C ; Load long $0CF1C2.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $29.b		; 85 29 ; Store accumulator to $29.b [Reads: Accumulator]
	lda $0CF1C6.l,X		; BF C6 F1 0C ; Load long $0CF1C6.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsr $F9B5.w		; 20 B5 F9 ; Jump to subroutine at $F9B5.w [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $AE		; 10 AE ; Branch if plus to $10, $AE [Flow: branch]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F400.w		; 20 00 F4 ; Jump to subroutine at $F400.w [Writes: Stack Pointer] [Flow: call]
	sbc $011818.l,X		; FF 18 18 01 ; Subtract with carry (long,X) $011818.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($09.b,X)		; 01 09 ; Logical OR ($09.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora [$00.b]		; 07 00 ; OR accumulator with memory (long) [$00.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($02.b,X)		; 01 02 ; Logical OR ($02.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $05.b		; 05 05 ; Logical OR $05.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora $04.b		; 05 04 ; Logical OR $04.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $03.b		; 04 03 ; Test and set bits $03.b [Reads: Accumulator] [Flags: Z]
	ora $02.b,S		; 03 02 ; OR accumulator with stack relative $02.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $01.b		; 02 01 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($64.b,X)		; 01 64 ; Logical OR ($64.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lda $5F.b		; A5 5F ; Load $5F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $EEA6.w		; 20 A6 EE ; Jump to subroutine at $EEA6.w [Writes: Stack Pointer] [Flow: call]
	lda #$38.b		; A9 38 ; Load #$38.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	jsr $F9E8.w		; 20 E8 F9 ; Jump to subroutine at $F9E8.w [Writes: Stack Pointer] [Flow: call]
	lda $25.b		; A5 25 ; Load $25.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $03		; B0 03 ; Branch if carry set to $B0, $03 [Flow: branch]
	jmp $F319.w		; 4C 19 F3 ; Jump to $F319.w [Flow: jump]
	lda #$70.b		; A9 70 ; Load #$70.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $29.b		; 85 29 ; Store accumulator to $29.b [Reads: Accumulator]
	dec $50.b		; C6 50 ; Decrement $50.b [Reads: Direct Page] [Flags: NZ]
	.db $10, $04		; 10 04 ; Branch if plus to $10, $04 [Flow: branch]
	lda #$0F.b		; A9 0F ; Load #$0F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $50.b		; 85 50 ; Store accumulator to $50.b [Reads: Accumulator]
	ldx $50.b		; A6 50 ; Load $50.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $31.b		; A5 31 ; Load $31.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $40.b		; 85 40 ; Store accumulator to $40.b [Reads: Accumulator]
	lda $30.b		; A5 30 ; Load $30.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0CF26A.l,X		; 7F 6A F2 0C ; Add long $0CF26A.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	inc $40.b		; E6 40 ; Increment $40.b [Reads: Direct Page] [Flags: NZ]
	jsr $FA30.w		; 20 30 FA ; Jump to subroutine at $FA30.w [Writes: Stack Pointer] [Flow: call]
	ldx #$01.b		; A2 01 ; Load #$01.b into X register [Writes: X Index] [Flags: NZ]
	stz $03.b		; 64 03 ; Store zero to $03.b
	lda $33.b		; A5 33 ; Load $33.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $29.b		; A5 29 ; Load $29.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0CF264.l,X		; 7F 64 F2 0C ; Add long $0CF264.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0CF266.l,X		; BF 66 F2 0C ; Load long $0CF266.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0CF268.l,X		; BF 68 F2 0C ; Load long $0CF268.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
.ACCU 16
	rep #$20		; C2 20
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $30.b		; A5 30 ; Load $30.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0100.w		; 69 00 01 ; Add #$0100.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0CF260.l,X		; 7F 60 F2 0C ; Add long $0CF260.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	sty $34.b		; 84 34 ; Store Y register to $34.b [Reads: Y Index]
.ACCU 8
	sep #$20		; E2 20
	jsl $0DB871.l		; 22 71 B8 0D ; Jump to subroutine long $0DB871.l [Writes: Stack Pointer] [Flow: call]
	jsl $1DEB84.l		; 22 84 EB 1D ; Jump to subroutine long $1DEB84.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $C1		; 10 C1 ; Branch if plus to $10, $C1 [Flow: branch]
	inc $32.b		; E6 32 ; Increment $32.b [Reads: Direct Page] [Flags: NZ]
	lda $32.b		; A5 32 ; Load $32.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	ldy #$FF.b		; A0 FF ; Load #$FF.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $33.b		; A5 33 ; Load $33.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$02.b		; C9 02 ; Compare #$02.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $11		; D0 11 ; Branch if not equal to $D0, $11 [Flow: branch]
	sty $33.b		; 84 33 ; Store Y register to $33.b [Reads: Y Index]
	lda $31.b		; A5 31 ; Load $31.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	lda $32.b		; A5 32 ; Load $32.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$08.b		; 29 08 ; Logical AND #$08.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	lda #$04.b		; A9 04 ; Load #$04.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012F.w		; 8D 2F 01 ; Store accumulator to $012F.w [Reads: Accumulator]
	inc $33.b		; E6 33 ; Increment $33.b [Reads: Direct Page] [Flags: NZ]
	lda $60.b		; A5 60 ; Load $60.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jmp ($F320.w,X)		; 7C 20 F3 ; Jump indirect indexed to ($F320.w,X) [Reads: X Index] [Flow: jump]
	pld		; 2B ; Pull direct page register from stack [Reads: Stack Pointer] [Writes: Direct Page, Stack Pointer] [Flags: NZ] [SNES: Stack operation: pulls DP register]
	sbc ($79.b,S),Y		; F3 79 ; Subtract with carry (stack relative indirect indexed) ($79.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($E6.b,S),Y		; F3 E6 ; Subtract with carry (stack relative indirect indexed) ($E6.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NCVZ]
	and $C6.b,S		; 23 C6 ; AND accumulator with stack relative $C6.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $6B22C6.l		; 22 C6 22 6B ; Jump to subroutine long $6B22C6.l [Writes: Stack Pointer] [Flow: call]
	lda $34.b		; A5 34 ; Load $34.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	inc $60.b		; E6 60 ; Increment $60.b [Reads: Direct Page] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0001.w		; 29 01 00 ; Logical AND #$0001.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	dec $30.b		; C6 30 ; Decrement $30.b [Reads: Direct Page] [Flags: NZ]
	lda #$F8D9.w		; A9 D9 F8 ; Load #$F8D9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $2D.b		; 85 2D ; Store accumulator to $2D.b [Reads: Accumulator]
	lda #$F8DF.w		; A9 DF F8 ; Load #$F8DF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda #$F8E5.w		; A9 E5 F8 ; Load #$F8E5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda #$F903.w		; A9 03 F9 ; Load #$F903.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda #$F915.w		; A9 15 F9 ; Load #$F915.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$58.b		; A9 58 ; Load #$58.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda $2B.b		; A5 2B ; Load $2B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $29.b		; 85 29 ; Store accumulator to $29.b [Reads: Accumulator]
	ldy #$05.b		; A0 05 ; Load #$05.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F9B5.w		; 20 B5 F9 ; Jump to subroutine at $F9B5.w [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $F9.b,S		; 03 F9 ; OR accumulator with stack relative $F9.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$F9.b		; 09 F9 ; Logical OR #$F9.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora $F8EBF9.l		; 0F F9 EB F8 ; OR accumulator with memory (long) $F8EBF9.l [Writes: Accumulator] [Flags: NZ]
	sbc $15F8.w,X		; FD F8 15 ; Subtract with carry $15F8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $F91B.w,Y		; F9 1B F9 ; Subtract with carry $F91B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($F9.b,X)		; 21 F9 ; Logical AND ($F9.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $F9.b,X		; 15 F9 ; OR accumulator with memory $F9.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $F9.b,X		; 15 F9 ; OR accumulator with memory $F9.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $25.b		; A5 25 ; Load $25.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$80.b		; C9 80 ; Compare #$80.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0F		; B0 0F ; Branch if carry set to $B0, $0F [Flow: branch]
	jsr $F766.w		; 20 66 F7 ; Jump to subroutine at $F766.w [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda $64.b		; A5 64 ; Load $64.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	ldx #$08.b		; A2 08 ; Load #$08.b into X register [Writes: X Index] [Flags: NZ]
	.db $80, $39		; 80 39 ; Branch always to $80, $39 [Flow: branch]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	lda $2B.b		; A5 2B ; Load $2B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$6E.b		; C9 6E ; Compare #$6E.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	dec $2B.b		; C6 2B ; Decrement $2B.b [Reads: Direct Page] [Flags: NZ]
	.db $80, $2D		; 80 2D ; Branch always to $80, $2D [Flow: branch]
	lda $25.b		; A5 25 ; Load $25.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$1F.b		; C9 1F ; Compare #$1F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	dec $13.b		; C6 13 ; Decrement $13.b [Reads: Direct Page] [Flags: NZ]
	dec $25.b		; C6 25 ; Decrement $25.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jmp $F324.w		; 4C 24 F3 ; Jump to $F324.w [Flow: jump]
	lda $25.b		; A5 25 ; Load $25.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$C0.b		; C9 C0 ; Compare #$C0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $14		; B0 14 ; Branch if carry set to $B0, $14 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp #$B8.b		; C9 B8 ; Compare #$B8.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $0E		; B0 0E ; Branch if carry set to $B0, $0E [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp #$B0.b		; C9 B0 ; Compare #$B0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $08		; B0 08 ; Branch if carry set to $B0, $08 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cmp #$A0.b		; C9 A0 ; Compare #$A0.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $02		; B0 02 ; Branch if carry set to $B0, $02 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda #$A8.b		; A9 A8 ; Load #$A8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$0001.w		; 29 01 00 ; Logical AND #$0001.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	dec $30.b		; C6 30 ; Decrement $30.b [Reads: Direct Page] [Flags: NZ]
	lda #$F8D9.w		; A9 D9 F8 ; Load #$F8D9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $2D.b		; 85 2D ; Store accumulator to $2D.b [Reads: Accumulator]
	lda #$F8DF.w		; A9 DF F8 ; Load #$F8DF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda #$F8E5.w		; A9 E5 F8 ; Load #$F8E5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0CF365.l,X		; BF 65 F3 0C ; Load long $0CF365.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0CF36F.l,X		; BF 6F F3 0C ; Load long $0CF36F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$58.b		; A9 58 ; Load #$58.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda $2B.b		; A5 2B ; Load $2B.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $29.b		; 85 29 ; Store accumulator to $29.b [Reads: Accumulator]
	ldy #$05.b		; A0 05 ; Load #$05.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F9B5.w		; 20 B5 F9 ; Jump to subroutine at $F9B5.w [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	.db $30, $C0		; 30 C0 ; Branch if minus to $30, $C0 [Flow: branch]
	.db $50, $A0		; 50 A0 ; Branch if overflow clear to $50, $A0 [Flow: branch]
	.db $70, $70		; 70 70 ; Branch if overflow set to $70, $70 [Flow: branch]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	cpy #$C0.b		; C0 C0 ; Compare #$C0.b with Y register [Reads: Y Index] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora #$09.b		; 09 09 ; Logical OR #$09.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora #$09.b		; 09 09 ; Logical OR #$09.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ora [$09.b]		; 07 09 ; OR accumulator with memory (long) [$09.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sbc $92.b,X		; F5 92 ; Subtract $92.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $13.b,X		; F5 13 ; Subtract $13.b,X from accumulator with borrow [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	inc $89.b,X		; F6 89 ; Increment memory $89.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $E2.b,X		; F6 E2 ; Increment memory $E2.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	inc $A5.b,X		; F6 A5 ; Increment memory $A5.b,X [Reads: Direct Page, X Index] [Flags: NZ]
	eor $03F0.w,X		; 5D F0 03 ; Exclusive OR accumulator with memory $03F0.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	jmp $F324.w		; 4C 24 F3 ; Jump to $F324.w [Flow: jump]
	stz $2A.b		; 64 2A ; Store zero to $2A.b
	jsl $1DE9B6.l		; 22 B6 E9 1D ; Jump to subroutine long $1DE9B6.l [Writes: Stack Pointer] [Flow: call]
	lda $5F.b		; A5 5F ; Load $5F.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $03		; D0 03 ; Branch if not equal to $D0, $03 [Flow: branch]
	jsr $EEA6.w		; 20 A6 EE ; Jump to subroutine at $EEA6.w [Writes: Stack Pointer] [Flow: call]
	lda $50.b		; A5 50 ; Load $50.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$FF.b		; C9 FF ; Compare #$FF.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	inc $50.b		; E6 50 ; Increment $50.b [Reads: Direct Page] [Flags: NZ]
	lda $0FF9.w		; AD F9 0F ; Load $0FF9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $09		; F0 09 ; Branch if equal to $F0, $09 [Flow: branch]
	and #$04.b		; 29 04 ; Logical AND #$04.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $05		; F0 05 ; Branch if equal to $F0, $05 [Flow: branch]
	ldx #$2B.b		; A2 2B ; Load #$2B.b into X register [Writes: X Index] [Flags: NZ]
	stx $012F.w		; 8E 2F 01 ; Store X register to $012F.w [Reads: X Index]
	lda $60.b		; A5 60 ; Load $60.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; [PATTERN: Memory clearing operation] AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	jsr ($F419.w,X)		; FC 19 F4 ; Jump to subroutine indirect indexed ($F419.w,X) [Reads: X Index] [Writes: Stack Pointer] [Flow: call]
	ldx #$05.b		; A2 05 ; Load #$05.b into X register [Writes: X Index] [Flags: NZ]
	stz $01.b		; 64 01 ; Store zero to $01.b
	stz $03.b		; 64 03 ; Store zero to $03.b
	stz $06.b		; 64 06 ; Store zero to $06.b
	lda $0CF401.l,X		; BF 01 F4 0C ; Load long $0CF401.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0CF407.l,X		; BF 07 F4 0C ; Load long $0CF407.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0CF40D.l,X		; BF 0D F4 0C ; Load long $0CF40D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0CF413.l,X		; BF 13 F4 0C ; Load long $0CF413.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $05.b		; 85 05 ; Store accumulator to $05.b [Reads: Accumulator]
	phx		; DA ; Push X register [Reads: X Index] [Writes: Stack Pointer]
	jsl $0DB871.l		; 22 71 B8 0D ; Jump to subroutine long $0DB871.l [Writes: Stack Pointer] [Flow: call]
	jsl $1DEB84.l		; 22 84 EB 1D ; Jump to subroutine long $1DEB84.l [Writes: Stack Pointer] [Flow: call]
	plx		; FA ; Pull X register [Reads: Stack Pointer] [Writes: Stack Pointer, X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $D5		; 10 D5 ; Branch if plus to $10, $D5 [Flow: branch]
	ldx $50.b		; A6 50 ; Load $50.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cpx #$A0.b		; E0 A0 ; Compare #$A0.b with X register [Reads: X Index] [Flags: NCZ]
	.db $90, $14		; 90 14 ; Branch if carry clear to $90, $14 [Flow: branch]
	lda $30.b		; A5 30 ; Load $30.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$60.b		; C9 60 ; Compare #$60.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	dec $32.b		; C6 32 ; Decrement $32.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	dec $30.b		; C6 30 ; Decrement $30.b [Reads: Direct Page] [Flags: NZ]
	lda #$08.b		; A9 08 ; Load #$08.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $32.b		; 85 32 ; Store accumulator to $32.b [Reads: Accumulator]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	inc $61.b		; E6 61 ; Increment $61.b [Reads: Direct Page] [Flags: NZ]
	lda $52.b		; A5 52 ; Load $52.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $7B		; D0 7B ; Branch if not equal to $D0, $7B [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda #$F927.w		; A9 27 F9 ; Load #$F927.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $2D.b		; 85 2D ; Store accumulator to $2D.b [Reads: Accumulator]
	lda #$F929.w		; A9 29 F9 ; Load #$F929.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda #$F92B.w		; A9 2B F9 ; Load #$F92B.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	lda $30.b		; A5 30 ; Load $30.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$00FF.w		; 29 FF 00 ; Logical AND #$00FF.w with accumulator [Writes: Accumulator] [Flags: NZ]
	cmp #$0070.w		; C9 70 00 ; Compare #$0070.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	lda $0CF567.l,X		; BF 67 F5 0C ; Load long $0CF567.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda #$F931.w		; A9 31 F9 ; Load #$F931.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$74.b		; A9 74 ; Load #$74.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda $30.b		; A5 30 ; Load $30.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $29.b		; 85 29 ; Store accumulator to $29.b [Reads: Accumulator]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F9B5.w		; 20 B5 F9 ; Jump to subroutine at $F9B5.w [Writes: Stack Pointer] [Flow: call]
	ldx #$0E.b		; A2 0E ; Load #$0E.b into X register [Writes: X Index] [Flags: NZ]
	lda $30.b		; A5 30 ; Load $30.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$68.b		; C9 68 ; Compare #$68.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $07		; B0 07 ; Branch if carry set to $B0, $07 [Flow: branch]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$68.b		; E9 68 ; Subtract #$68.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$0E.b		; 29 0E ; Logical AND #$0E.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda #$F933.w		; A9 33 F9 ; Load #$F933.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $2D.b		; 85 2D ; Store accumulator to $2D.b [Reads: Accumulator]
	lda $0CF54F.l,X		; BF 4F F5 0C ; Load long $0CF54F.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda #$F93F.w		; A9 3F F9 ; Load #$F93F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda #$F941.w		; A9 41 F9 ; Load #$F941.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda #$F943.w		; A9 43 F9 ; Load #$F943.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$74.b		; A9 74 ; Load #$74.b into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $0CF55F.l,X		; 7F 5F F5 0C ; Add long $0CF55F.l,X to accumulator with carry [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda #$76.b		; A9 76 ; Load #$76.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $29.b		; 85 29 ; Store accumulator to $29.b [Reads: Accumulator]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F9B5.w		; 20 B5 F9 ; Jump to subroutine at $F9B5.w [Writes: Stack Pointer] [Flow: call]
	lda $50.b		; A5 50 ; Load $50.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$0E.b		; 29 0E ; Logical AND #$0E.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda #$F8D9.w		; A9 D9 F8 ; Load #$F8D9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $2D.b		; 85 2D ; Store accumulator to $2D.b [Reads: Accumulator]
	lda #$F8DF.w		; A9 DF F8 ; Load #$F8DF.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda #$F8E5.w		; A9 E5 F8 ; Load #$F8E5.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0CF56B.l,X		; BF 6B F5 0C ; Load long $0CF56B.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda #$F915.w		; A9 15 F9 ; Load #$F915.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$70.b		; A9 70 ; Load #$70.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda #$46.b		; A9 46 ; Load #$46.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $29.b		; 85 29 ; Store accumulator to $29.b [Reads: Accumulator]
	ldy #$05.b		; A0 05 ; Load #$05.b into Y register [Writes: Y Index] [Flags: NZ]
	jsr $F9B5.w		; 20 B5 F9 ; Jump to subroutine at $F9B5.w [Writes: Stack Pointer] [Flow: call]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	and $3DF9.w,X		; 3D F9 3D ; AND accumulator with memory $3DF9.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F93B.w,Y		; F9 3B F9 ; Subtract with carry $F93B.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sbc $F939.w,Y		; F9 39 F9 ; Subtract with carry $F939.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and $37F9.w,Y		; 39 F9 37 ; AND accumulator with memory $37F9.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sbc $F935.w,Y		; F9 35 F9 ; Subtract with carry $F935.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($00.b,X)		; 01 00 ; Logical OR ($00.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	and $2FF9.w		; 2D F9 2F ; Logical AND $2FF9.w with accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $F8EB.w,Y		; F9 EB F8 ; Subtract with carry $F8EB.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc ($F8.b),Y		; F1 F8 ; Subtract with carry ($F8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc [$F8.b],Y		; F7 F8 ; Subtract with carry (long indexed) [$F8.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc ($F8.b),Y		; F1 F8 ; Subtract with carry ($F8.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sed		; F8 ; Set decimal flag [Flags: D]
	sbc $A5F8.w,X		; FD F8 A5 ; Subtract with carry $A5F8.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($F0.b,X)		; 61 F0 ; Add with carry ($F0.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cop $E6.b		; 02 E6 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc $F97DF9.l		; 6F F9 7D F9 ; Add with carry (long) $F97DF9.l [Writes: Accumulator] [Flags: NCVZ]
	phb		; 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	sbc $F999.w,Y		; F9 99 F9 ; Subtract with carry $F999.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ora ($01.b,X)		; 01 01 ; Logical OR ($01.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora ($05.b,X)		; 01 05 ; Logical OR ($05.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $09.b		; 05 09 ; Logical OR $09.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora #$0D.b		; 09 0D ; Logical OR #$0D.b with accumulator [Writes: Accumulator] [Flags: NZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda #$F945.w		; A9 45 F9 ; Load #$F945.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $2D.b		; 85 2D ; Store accumulator to $2D.b [Reads: Accumulator]
	lda #$F953.w		; A9 53 F9 ; Load #$F953.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda #$F961.w		; A9 61 F9 ; Load #$F961.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0CF582.l,X		; BF 82 F5 0C ; Load long $0CF582.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0CF586.l,X		; BF 86 F5 0C ; Load long $0CF586.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$6E.b		; A9 6E ; Load #$6E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda #$48.b		; A9 48 ; Load #$48.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $29.b		; 85 29 ; Store accumulator to $29.b [Reads: Accumulator]
	lda $51.b		; A5 51 ; Load $51.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0CF58A.l,X		; BF 8A F5 0C ; Load long $0CF58A.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsr $F9B5.w		; 20 B5 F9 ; Jump to subroutine at $F9B5.w [Writes: Stack Pointer] [Flow: call]
	lda $51.b		; A5 51 ; Load $51.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0B		; D0 0B ; Branch if not equal to $D0, $0B [Flow: branch]
	ldy $63.b		; A4 63 ; Load $63.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	cpy #$70.b		; C0 70 ; Compare #$70.b with Y register [Reads: Y Index] [Flags: NCZ]
	.db $D0, $05		; D0 05 ; Branch if not equal to $D0, $05 [Flow: branch]
	ldx #$27.b		; A2 27 ; Load #$27.b into X register [Writes: X Index] [Flags: NZ]
	stx $012F.w		; 8E 2F 01 ; Store X register to $012F.w [Reads: X Index]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0A		; D0 0A ; Branch if not equal to $D0, $0A [Flow: branch]
	ldx #$90.b		; A2 90 ; Load #$90.b into X register [Writes: X Index] [Flags: NZ]
	stx $0FF9.w		; 8E F9 0F ; Store X register to $0FF9.w [Reads: X Index]
	ldx #$2B.b		; A2 2B ; Load #$2B.b into X register [Writes: X Index] [Flags: NZ]
	stx $012F.w		; 8E 2F 01 ; Store X register to $012F.w [Reads: X Index]
	lda $63.b		; A5 63 ; Load $63.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	dec $63.b		; C6 63 ; Decrement $63.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $51.b		; E6 51 ; Increment $51.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	inc $60.b		; E6 60 ; Increment $60.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora [$07.b]		; 07 07 ; OR accumulator with memory (long) [$07.b] [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	ora $0A0D.w		; 0D 0D 0A ; Logical OR $0A0D.w with accumulator [Writes: Accumulator] [Flags: NZ]
	brk $0A.b		; 00 0A ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $8B.b		; 00 8B ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda $1A.b		; A5 1A ; Load $1A.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $51.b		; A5 51 ; Load $51.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$07.b		; 29 07 ; Logical AND #$07.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda #$F945.w		; A9 45 F9 ; Load #$F945.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $F603.w,Y		; 79 03 F6 ; Add $F603.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $2D.b		; 85 2D ; Store accumulator to $2D.b [Reads: Accumulator]
	lda #$F953.w		; A9 53 F9 ; Load #$F953.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $F603.w,Y		; 79 03 F6 ; Add $F603.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda #$F961.w		; A9 61 F9 ; Load #$F961.w into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $F603.w,Y		; 79 03 F6 ; Add $F603.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $F582.w,X		; BD 82 F5 ; Load $F582.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $F603.w,Y		; 79 03 F6 ; Add $F603.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $F586.w,X		; BD 86 F5 ; Load $F586.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $F603.w,Y		; 79 03 F6 ; Add $F603.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$6E.b		; A9 6E ; Load #$6E.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda #$48.b		; A9 48 ; Load #$48.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $29.b		; 85 29 ; Store accumulator to $29.b [Reads: Accumulator]
	ldx $00.b		; A6 00 ; Load $00.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $F5FB.w,X		; BD FB F5 ; Load $F5FB.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsr $F9B5.w		; 20 B5 F9 ; Jump to subroutine at $F9B5.w [Writes: Stack Pointer] [Flow: call]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda $51.b		; A5 51 ; Load $51.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	dec $62.b		; C6 62 ; Decrement $62.b [Reads: Direct Page] [Flags: NZ]
	.db $F0, $88		; F0 88 ; Branch if equal to $F0, $88 [Flow: branch]
	.db $80, $02		; 80 02 ; Branch always to $80, $02 [Flow: branch]
	dec $51.b		; C6 51 ; Decrement $51.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda #$F9.b		; A9 F9 ; Load #$F9.b into accumulator [Writes: Accumulator] [Flags: NZ]
	lda $AAF9.w		; AD F9 AA ; Load $AAF9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sbc $F9AF.w,Y		; F9 AF F9 ; Subtract with carry $F9AF.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	sbc $F9B1.w,Y		; F9 B1 F9 ; Subtract with carry $F9B1.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	ldy $B3F9.w		; AC F9 B3 ; Load $B3F9.w into Y register [Writes: Y Index] [Flags: NZ]
	sbc $7078.w,Y		; F9 78 70 ; Subtract with carry $7078.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda $51.b		; A5 51 ; Load $51.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$06.b		; C9 06 ; Compare #$06.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $07		; D0 07 ; Branch if not equal to $D0, $07 [Flow: branch]
	inc $52.b		; E6 52 ; Increment $52.b [Reads: Direct Page] [Flags: NZ]
	lda #$33.b		; A9 33 ; Load #$33.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $012E.w		; 8D 2E 01 ; Store accumulator to $012E.w [Reads: Accumulator]
	cmp #$40.b		; C9 40 ; Compare #$40.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $06		; D0 06 ; Branch if not equal to $D0, $06 [Flow: branch]
	lda #$E0.b		; A9 E0 ; Load #$E0.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $51.b		; 85 51 ; Store accumulator to $51.b [Reads: Accumulator]
	inc $60.b		; E6 60 ; Increment $60.b [Reads: Direct Page] [Flags: NZ]
	cmp #$0F.b		; C9 0F ; Compare #$0F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $3B		; B0 3B ; Branch if carry set to $B0, $3B [Flow: branch]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$02.b		; 29 02 ; Logical AND #$02.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda #$F9A7.w		; A9 A7 F9 ; Load #$F9A7.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $2D.b		; 85 2D ; Store accumulator to $2D.b [Reads: Accumulator]
	lda $0CF675.l,X		; BF 75 F6 0C ; Load long $0CF675.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	lda $0CF679.l,X		; BF 79 F6 0C ; Load long $0CF679.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $04.b		; 85 04 ; Store accumulator to $04.b [Reads: Accumulator]
	lda $0CF67D.l,X		; BF 7D F6 0C ; Load long $0CF67D.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $06.b		; 85 06 ; Store accumulator to $06.b [Reads: Accumulator]
	lda $0CF681.l,X		; BF 81 F6 0C ; Load long $0CF681.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $08.b		; 85 08 ; Store accumulator to $08.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $0CF685.l,X		; BF 85 F6 0C ; Load long $0CF685.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $28.b		; 85 28 ; Store accumulator to $28.b [Reads: Accumulator]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $29.b		; 85 29 ; Store accumulator to $29.b [Reads: Accumulator]
	lda $0CF687.l,X		; BF 87 F6 0C ; Load long $0CF687.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	jsr $F9B5.w		; 20 B5 F9 ; Jump to subroutine at $F9B5.w [Writes: Stack Pointer] [Flow: call]
	inc $51.b		; E6 51 ; Increment $51.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $F766.w		; 20 66 F7 ; Jump to subroutine at $F766.w [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda $64.b		; A5 64 ; Load $64.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	.db $D0, $12		; D0 12 ; Branch if not equal to $D0, $12 [Flow: branch]
	lda $51.b		; A5 51 ; Load $51.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$1F.b		; C9 1F ; Compare #$1F.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $B0, $06		; B0 06 ; Branch if carry set to $B0, $06 [Flow: branch]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	dec $13.b		; C6 13 ; Decrement $13.b [Reads: Direct Page] [Flags: NZ]
	dec $51.b		; C6 51 ; Decrement $51.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	inc $5D.b		; E6 5D ; Increment $5D.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	dec $13.b		; C6 13 ; Decrement $13.b [Reads: Direct Page] [Flags: NZ]
	.db $D0, $29		; D0 29 ; Branch if not equal to $D0, $29 [Flow: branch]
	jsl $00893D.l		; 22 3D 89 00 ; Jump to subroutine long $00893D.l [Writes: Stack Pointer] [Flow: call]
	lda #$13.b		; A9 13 ; Load #$13.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta BG1SC.w		; 8D 07 21 ; Store accumulator to BG1SC.w [Reads: Accumulator]
	lda #$03.b		; [PATTERN: Memory clearing operation] A9 03 ; Load #$03.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta BG2SC.w		; 8D 08 21 ; Store accumulator to BG2SC.w [Reads: Accumulator]
.ACCU 16
	rep #$20		; C2 20
	jsl $0ABC33.l		; 22 33 BC 0A ; Jump to subroutine long $0ABC33.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	stz $063A.w		; 9C 3A 06 ; Store zero to $063A.w
	stz $0638.w		; 9C 38 06 ; Store zero to $0638.w
	stz $0120.w		; [PATTERN: Memory clearing operation] 9C 20 01 ; Store zero to $0120.w
	stz $0124.w		; 9C 24 01 ; Store zero to $0124.w
	stz $EA.b		; 64 EA ; Store zero to $EA.b
.ACCU 8
	sep #$20		; E2 20
	jmp $C2F0.w		; 4C F0 C2 ; Jump to $C2F0.w [Flow: jump]
	rtl		; 6B ; Return from subroutine long [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.ACCU 16
.INDEX 16
	rep #$FA		; C2 FA
	eor $FC4CFB.l,X		; 5F FB 4C FC ; Exclusive OR accumulator with memory (long,X) $FC4CFB.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	ora ($FD.b,S),Y		; 13 FD ; OR accumulator (stack relative indirect indexed) ($FD.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	stz $EC00.w		; 9C 00 EC ; Store zero to $EC00.w
	brk $C6.b		; 00 C6 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($C2.b,X)		; 01 C2 ; Logical OR ($C2.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	jsr $26A6.w		; 20 A6 26 ; Jump to subroutine at $26A6.w [Writes: Stack Pointer] [Flow: call]
	lda $0CF736.l,X		; BF 36 F7 0C ; Load long $0CF736.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0CF72E.l,X		; BF 2E F7 0C ; Load long $0CF72E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $02.b		; 85 02 ; Store accumulator to $02.b [Reads: Accumulator]
	ldx #$860C.w		; A2 0C 86 ; Load #$860C.w into X register [Writes: X Index] [Flags: NZ]
	tsb $C2.b		; 04 C2 ; Test and set bits $C2.b [Reads: Accumulator] [Flags: Z]
	.db $10, $A4		; 10 A4 ; Branch if plus to $10, $A4 [Flow: branch]
	brk $B7.b		; 00 B7 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $99.b		; 02 99 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $10.b		; 02 10 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $F7		; 10 F7 ; Branch if plus to $10, $F7 [Flow: branch]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $14.b		; 85 14 ; Store accumulator to $14.b [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	lda $E8.b		; A5 E8 ; Load $E8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $20.b		; [PATTERN: Memory clearing operation] 85 20 ; Store accumulator to $20.b [Reads: Accumulator]
	lda $E9.b		; A5 E9 ; Load $E9.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $21.b		; 85 21 ; Store accumulator to $21.b [Reads: Accumulator]
	stz $F2.b		; 64 F2 ; Store zero to $F2.b
	stz $F6.b		; 64 F6 ; Store zero to $F6.b
	stz $F4.b		; 64 F4 ; Store zero to $F4.b
	jsl $0EC440.l		; 22 40 C4 0E ; Jump to subroutine long $0EC440.l [Writes: Stack Pointer] [Flow: call]
.ACCU 16
	rep #$20		; C2 20
	lda $64.b		; A5 64 ; Load $64.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	dec $64.b		; C6 64 ; Decrement $64.b [Reads: Direct Page] [Flags: NZ]
.ACCU 8
	sep #$20		; E2 20
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.INDEX 16
	rep #$10		; C2 10
	lda $0637.w		; AD 37 06 ; Load $0637.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta WRMPYA.w		; 8D 02 42 ; Store accumulator to WRMPYA.w [Reads: Accumulator]
	ldx #$01BE.w		; A2 BE 01 ; Load #$01BE.w into X register [Writes: X Index] [Flags: NZ]
	lda $0ADD27.l,X		; BF 27 DD 0A ; Load long $0ADD27.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	nop		; EA ; No operation
	nop		; EA ; No operation
	nop		; EA ; No operation
	nop		; EA ; No operation
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $00.b		; 85 00 ; Store accumulator to $00.b [Reads: Accumulator]
	lda $0ADD28.l,X		; BF 28 DD 0A ; Load long $0ADD28.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta WRMPYB.w		; 8D 03 42 ; Store accumulator to WRMPYB.w [Reads: Accumulator]
	nop		; EA ; No operation
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $4216.w		; 6D 16 42 ; Add $4216.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1B00.w,X		; 9D 00 1B ; Store accumulator to $1B00.w,X [Reads: Accumulator, X Index]
	lda RDMPYH.w		; AD 17 42 ; Load RDMPYH.w into accumulator [Writes: Accumulator] [Flags: NZ]
	adc #$00.b		; 69 00 ; Add #$00.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $1B01.w,X		; 9D 01 1B ; Store accumulator to $1B01.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $D3		; 10 D3 ; Branch if plus to $10, $D3 [Flow: branch]
.INDEX 8
	sep #$10		; E2 10
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	ldx $09.b		; A6 09 ; Load $09.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $89.b		; A5 89 ; Load $89.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $09.b		; A5 09 ; Load $09.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	ldx $89.b		; A6 89 ; Load $89.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $49.b		; A5 49 ; Load $49.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $49.b		; A5 49 ; Load $49.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda $89.b		; A5 89 ; Load $89.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lda $C9.b		; A5 C9 ; Load $C9.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	lda ($09.b,X)		; A1 09 ; Load accumulator ($09.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx #$09.b		; A2 09 ; Load #$09.b into X register [Writes: X Index] [Flags: NZ]
	lda $09.b,S		; A3 09 ; Load accumulator (stack relative) $09.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ldy $09.b		; A4 09 ; Load $09.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	lda #$09.b		; A9 09 ; Load #$09.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $94.b		; 85 94 ; Store accumulator to $94.b [Reads: Accumulator]
	lda #$17.b		; A9 17 ; Load #$17.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $1C.b		; 85 1C ; Store accumulator to $1C.b [Reads: Accumulator]
	stz $1D.b		; 64 1D ; Store zero to $1D.b
	lda #$10.b		; A9 10 ; Load #$10.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta BG1SC.w		; 8D 07 21 ; Store accumulator to BG1SC.w [Reads: Accumulator]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta BG2SC.w		; 8D 08 21 ; Store accumulator to BG2SC.w [Reads: Accumulator]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	ldx #$0000.w		; A2 00 00 ; Load #$0000.w into X register [Writes: X Index] [Flags: NZ]
	lda #$F7BE.w		; A9 BE F7 ; Load #$F7BE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $30.b		; 85 30 ; Store accumulator to $30.b [Reads: Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0007.w		; 29 07 00 ; Logical AND #$0007.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($30.b),Y		; B1 30 ; Load accumulator ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1006.w,X		; 9D 06 10 ; Store accumulator to $1006.w,X [Reads: Accumulator, X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$0007.w		; 29 07 00 ; Logical AND #$0007.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $F1		; D0 F1 ; Branch if not equal to $D0, $F1 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$003F.w		; 29 3F 00 ; Logical AND #$003F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $E6		; D0 E6 ; Branch if not equal to $D0, $E6 [Flow: branch]
	lda $30.b		; A5 30 ; Load $30.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0008.w		; 69 08 00 ; Add #$0008.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $30.b		; 85 30 ; Store accumulator to $30.b [Reads: Accumulator]
	cpx #$0100.w		; E0 00 01 ; Compare #$0100.w with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $D9		; D0 D9 ; Branch if not equal to $D0, $D9 [Flow: branch]
	lda #$1000.w		; A9 00 10 ; Load #$1000.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $30.b		; 85 30 ; Store accumulator to $30.b [Reads: Accumulator]
	jsr $F879.w		; 20 79 F8 ; Jump to subroutine at $F879.w [Writes: Stack Pointer] [Flow: call]
.ACCU 16
.INDEX 16
	rep #$30		; C2 30
	ldx #$0000.w		; A2 00 00 ; Load #$0000.w into X register [Writes: X Index] [Flags: NZ]
	lda #$F7DE.w		; A9 DE F7 ; Load #$F7DE.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $30.b		; 85 30 ; Store accumulator to $30.b [Reads: Accumulator]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0003.w		; 29 03 00 ; Logical AND #$0003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda ($30.b),Y		; B1 30 ; Load accumulator ($30.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $1006.w,X		; 9D 06 10 ; Store accumulator to $1006.w,X [Reads: Accumulator, X Index]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	iny		; C8 ; Increment Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	and #$0003.w		; 29 03 00 ; Logical AND #$0003.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $F1		; D0 F1 ; Branch if not equal to $D0, $F1 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$003F.w		; 29 3F 00 ; Logical AND #$003F.w with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $E6		; D0 E6 ; Branch if not equal to $D0, $E6 [Flow: branch]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	and #$0040.w		; 29 40 00 ; Logical AND #$0040.w with accumulator [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$F7DE.w		; 69 DE F7 ; Add #$F7DE.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $30.b		; 85 30 ; Store accumulator to $30.b [Reads: Accumulator]
	cpx #$0100.w		; E0 00 01 ; Compare #$0100.w with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $D3		; D0 D3 ; Branch if not equal to $D0, $D3 [Flow: branch]
	lda #$0000.w		; A9 00 00 ; Load #$0000.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $30.b		; 85 30 ; Store accumulator to $30.b [Reads: Accumulator]
	jsr $F879.w		; 20 79 F8 ; Jump to subroutine at $F879.w [Writes: Stack Pointer] [Flow: call]
.ACCU 8
.INDEX 8
	sep #$30		; E2 30
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

.INDEX 8
	sep #$10		; E2 10
	ldx #$07.b		; A2 07 ; Load #$07.b into X register [Writes: X Index] [Flags: NZ]
	lda $30.b		; A5 30 ; Load $30.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta VMADDL.w		; 8D 16 21 ; Store accumulator to VMADDL.w [Reads: Accumulator]
	ldy #$80.b		; A0 80 ; Load #$80.b into Y register [Writes: Y Index] [Flags: NZ]
	sty VMAIN.w		; 8C 15 21 ; Store Y register to VMAIN.w [Reads: Y Index]
	lda #$01.b		; A9 01 ; Load #$01.b into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	sta DMAP0.w		; 8D 00 43 ; Store accumulator to DMAP0.w [Reads: Accumulator]
	lda #$06.b		; A9 06 ; Load #$06.b into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $10, $8D		; 10 8D ; Branch if plus to $10, $8D [Flow: branch]
	cop $43.b		; 02 43 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ldy #$00.b		; A0 00 ; Load #$00.b into Y register [Writes: Y Index] [Flags: NZ]
	sty DMASRC0B.w		; 8C 04 43 ; Store Y register to DMASRC0B.w [Reads: Y Index]
	lda #$00.b		; A9 00 ; Load #$00.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora ($8D.b,X)		; 01 8D ; Logical OR ($8D.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $43.b		; 05 43 ; Logical OR $43.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	sty MDMAEN.w		; 8C 0B 42 ; Store Y register to MDMAEN.w [Reads: Y Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $DC		; 10 DC ; Branch if plus to $10, $DC [Flow: branch]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $1000.w		; 20 00 10 ; Jump to subroutine at $1000.w [Writes: Stack Pointer] [Flow: call]
	jsr $0000.w		; 20 00 00 ; Jump to subroutine at $0000.w [Writes: Stack Pointer] [Flow: call]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	tsb $0C0E.w		; 0C 0E 0C ; Test and set bits $0C0E.w [Reads: Accumulator] [Flags: Z]
	bit $2C2E.w		; 2C 2E 2C ; Test bits $2C2E.w with accumulator [Reads: Accumulator] [Flags: NVZ]
	and ($31.b),Y		; 31 31 ; AND accumulator with memory ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($31.b),Y		; 71 31 ; Add with carry ($31.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and ($71.b),Y		; 31 71 ; AND accumulator with memory ($71.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0B.b		; 05 0B ; Logical OR $0B.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $0019.w,Y		; 19 19 00 ; OR accumulator with memory $0019.w,Y [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $6C		; 10 6C ; Branch if plus to $10, $6C [Flow: branch]
	jmp ($8282.w)		; 6C 82 82 ; Jump indirect to ($8282.w) [Flow: jump]
	ldx #$A2.b		; A2 A2 ; Load #$A2.b into X register [Writes: X Index] [Flags: NZ]
	jmp ($806C.w)		; 6C 6C 80 ; Jump indirect to ($806C.w) [Flow: jump]
	.db $82, $A0, $A2		; 82 A0 A2 ; Branch always long to $82, $A0, $A2 [Flow: branch]
	jmp ($826C.w)		; 6C 6C 82 ; Jump indirect to ($826C.w) [Flow: jump]
	.db $80, $A2		; 80 A2 ; Branch always to $80, $A2 [Flow: branch]
	ldy #$6C.b		; A0 6C ; Load #$6C.b into Y register [Writes: Y Index] [Flags: NZ]
	jmp ($8080.w)		; 6C 80 80 ; Jump indirect to ($8080.w) [Flow: jump]
	ldy #$A0.b		; A0 A0 ; Load #$A0.b into Y register [Writes: Y Index] [Flags: NZ]
	jmp ($846C.w)		; 6C 6C 84 ; Jump indirect to ($846C.w) [Flow: jump]
	sty $A4.b		; 84 A4 ; Store Y register to $A4.b [Reads: Y Index]
	ldy $6C.b		; A4 6C ; Load $6C.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	jmp ($C2C4.w)		; 6C C4 C2 ; Jump indirect to ($C2C4.w) [Flow: jump]
	cpx $E6.b		; E4 E6 ; Compare $E6.b with X register [Reads: Direct Page, X Index] [Flags: NCZ]
	jmp ($886C.w)		; 6C 6C 88 ; Jump indirect to ($886C.w) [Flow: jump]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tda		; 7B ; Transfer direct page to C  [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sec		; 38 ; Set carry flag [Flags: C]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	tsa		; 3B ; Transfer stack pointer to C  [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $08.b		; 00 08 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $04.b,S		; 03 04 ; OR accumulator with stack relative $04.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $023D.w,X		; 3D 3D 02 ; AND accumulator with memory $023D.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	cop $00.b		; 02 00 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	php		; 08 ; Push processor status [Reads: Processor Status] [Writes: Stack Pointer]
	brk $06.b		; 00 06 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $04.b		; 00 04 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jmp ($386C.w)		; 6C 6C 38 ; Jump indirect to ($386C.w) [Flow: jump]
	sec		; 38 ; Set carry flag [Flags: C]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	inc $FE1E.w,X		; FE 1E FE ; Increment memory $FE1E.w,X [Reads: X Index] [Flags: NZ]
	asl $1C00.w,X		; 1E 00 1C ; Arithmetic shift left $1C00.w,X [Reads: X Index] [Flags: NCZ]
	brk $1C.b		; 00 1C ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	cop $12.b		; 02 12 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora $03.b,S		; 03 03 ; OR accumulator with stack relative $03.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	clc		; 18 ; Clear carry flag [Flags: C]
	clc		; 18 ; Clear carry flag [Flags: C]
	.db $10, $10		; 10 10 ; Branch if plus to $10, $10 [Flow: branch]
	jsr $CE20.w		; 20 20 CE ; Jump to subroutine at $CE20.w [Writes: Stack Pointer] [Flow: call]
	dec $2626.w		; CE 26 26 ; Decrement $2626.w [Flags: NZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsr $2020.w		; 20 20 20 ; Jump to subroutine at $2020.w [Writes: Stack Pointer] [Flow: call]
	jsr $CECE.w		; 20 CE CE ; Jump to subroutine at $CECE.w [Writes: Stack Pointer] [Flow: call]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	rol $26.b		; 26 26 ; Rotate left $26.b [Reads: Direct Page] [Flags: NCZ]
	rol $36.b,X		; 36 36 ; Rotate left $36.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	jsl $222222.l		; 22 22 22 22 ; Jump to subroutine long $222222.l [Writes: Stack Pointer] [Flow: call]
	and $35.b,X		; 35 35 ; Logical AND $35.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $35.b,X		; 75 35 ; Add $35.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $35.b,X		; 75 35 ; Add $35.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $35.b,X		; 75 35 ; Add $35.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $35.b,X		; 75 35 ; Add $35.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $75.b,X		; 35 75 ; Logical AND $75.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $F5.b,X		; B5 F5 ; Load $F5.b,X into accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and [$37.b],Y		; 37 37 ; AND accumulator with memory (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc [$37.b],Y		; 77 37 ; Add with carry (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$37.b],Y		; 77 37 ; Add with carry (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$37.b],Y		; 77 37 ; Add with carry (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	adc [$37.b],Y		; 77 37 ; Add with carry (long indexed) [$37.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NCVZ]
	and [$77.b],Y		; 37 77 ; AND accumulator with memory (long indexed) [$77.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda [$F7.b],Y		; B7 F7 ; Load accumulator (long indexed) [$F7.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	cop $02.b		; 02 02 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	dec $3D.b		; C6 3D ; Decrement $3D.b [Reads: Direct Page] [Flags: NZ]
	brk $10.b		; 00 10 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $24.b		; 24 24 ; Test bits $24.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $75.b,X		; 35 75 ; Logical AND $75.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	ldx $2A.b		; A6 2A ; Load $2A.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda ($2D.b),Y		; B1 2D ; Load accumulator ($2D.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0A60.w,X		; 9D 60 0A ; Store accumulator to $0A60.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda ($02.b),Y		; B1 02 ; Load accumulator ($02.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $28.b		; 65 28 ; Add $28.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0900.w,X		; 9D 00 09 ; Store accumulator to $0900.w,X [Reads: Accumulator, X Index]
	lda ($04.b),Y		; B1 04 ; Load accumulator ($04.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $29.b		; 65 29 ; Add $29.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	sta $0901.w,X		; 9D 01 09 ; Store accumulator to $0901.w,X [Reads: Accumulator, X Index]
	lda ($06.b),Y		; B1 06 ; Load accumulator ($06.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0902.w,X		; 9D 02 09 ; Store accumulator to $0902.w,X [Reads: Accumulator, X Index]
	lda ($08.b),Y		; B1 08 ; Load accumulator ($08.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0903.w,X		; 9D 03 09 ; Store accumulator to $0903.w,X [Reads: Accumulator, X Index]
	inc $2A.b		; E6 2A ; Increment $2A.b [Reads: Direct Page] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $D6		; 10 D6 ; Branch if plus to $10, $D6 [Flow: branch]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	rol A		; 2A ; Rotate left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$29.b		; 29 29 ; Logical AND #$29.b with accumulator [Writes: Accumulator] [Flags: NZ]
	ldx $2A.b		; A6 2A ; Load $2A.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0A60.w,X		; 9D 60 0A ; Store accumulator to $0A60.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$60.b		; A9 60 ; Load #$60.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0900.w,X		; 9D 00 09 ; Store accumulator to $0900.w,X [Reads: Accumulator, X Index]
	sta $0904.w,X		; 9D 04 09 ; Store accumulator to $0904.w,X [Reads: Accumulator, X Index]
	lda $28.b		; A5 28 ; Load $28.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0901.w,X		; 9D 01 09 ; Store accumulator to $0901.w,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0A.b		; 69 0A ; Add #$0A.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0905.w,X		; 9D 05 09 ; Store accumulator to $0905.w,X [Reads: Accumulator, X Index]
	lda $0CF9E4.l		; AF E4 F9 0C ; Load long $0CF9E4.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0902.w,X		; 9D 02 09 ; Store accumulator to $0902.w,X [Reads: Accumulator, X Index]
	lda $0CF9E5.l		; AF E5 F9 0C ; Load long $0CF9E5.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0906.w,X		; 9D 06 09 ; Store accumulator to $0906.w,X [Reads: Accumulator, X Index]
	lda $0CF9E6.l		; AF E6 F9 0C ; Load long $0CF9E6.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0903.w,X		; 9D 03 09 ; Store accumulator to $0903.w,X [Reads: Accumulator, X Index]
	lda $0CF9E7.l		; AF E7 F9 0C ; Load long $0CF9E7.l into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0907.w,X		; 9D 07 09 ; Store accumulator to $0907.w,X [Reads: Accumulator, X Index]
	inc $2A.b		; E6 2A ; Increment $2A.b [Reads: Direct Page] [Flags: NZ]
	inc $2A.b		; E6 2A ; Increment $2A.b [Reads: Direct Page] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	brk $01.b		; 00 01 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	ora #$3D.b		; 09 3D ; Logical OR #$3D.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $4B8B.w,X		; 3D 8B 4B ; AND accumulator with memory $4B8B.w,X [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	ldx $2A.b		; A6 2A ; Load $2A.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ldy $40.b		; A4 40 ; Load $40.b into Y register [Reads: Direct Page] [Writes: Y Index] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	ora #$01.b		; 09 01 ; Logical OR #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0A60.w,X		; 9D 60 0A ; Store accumulator to $0A60.w,X [Reads: Accumulator, X Index]
	sta $0A61.w,X		; 9D 61 0A ; Store accumulator to $0A61.w,X [Reads: Accumulator, X Index]
	txa		; 8A ; Transfer X to accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda $28.b		; A5 28 ; Load $28.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	sta $0900.w,X		; 9D 00 09 ; Store accumulator to $0900.w,X [Reads: Accumulator, X Index]
	sta $0904.w,X		; 9D 04 09 ; Store accumulator to $0904.w,X [Reads: Accumulator, X Index]
	lda $32.b		; A5 32 ; Load $32.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	lsr A		; 4A ; Logical shift right accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	and #$01.b		; 29 01 ; Logical AND #$01.b with accumulator [Writes: Accumulator] [Flags: NZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
	lda $29.b		; A5 29 ; Load $29.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $FA2A.w,Y		; 79 2A FA ; Add $FA2A.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0901.w,X		; 9D 01 09 ; Store accumulator to $0901.w,X [Reads: Accumulator, X Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $FA2C.w,Y		; 79 2C FA ; Add $FA2C.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $0905.w,X		; 9D 05 09 ; Store accumulator to $0905.w,X [Reads: Accumulator, X Index]
	lda $FA27.w		; AD 27 FA ; Load $FA27.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0902.w,X		; 9D 02 09 ; Store accumulator to $0902.w,X [Reads: Accumulator, X Index]
	lda $FA28.w,Y		; B9 28 FA ; Load $FA28.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0906.w,X		; 9D 06 09 ; Store accumulator to $0906.w,X [Reads: Accumulator, X Index]
	lda $FA2E.w		; AD 2E FA ; Load $FA2E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0903.w,X		; 9D 03 09 ; Store accumulator to $0903.w,X [Reads: Accumulator, X Index]
	lda $FA2F.w		; AD 2F FA ; Load $FA2F.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0907.w,X		; 9D 07 09 ; Store accumulator to $0907.w,X [Reads: Accumulator, X Index]
	inc $2A.b		; E6 2A ; Increment $2A.b [Reads: Direct Page] [Flags: NZ]
	inc $2A.b		; E6 2A ; Increment $2A.b [Reads: Direct Page] [Flags: NZ]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	jsr $00FF.w		; 20 FF 00 ; Jump to subroutine at $00FF.w [Writes: Stack Pointer] [Flow: call]
	.db $50, $18		; 50 18 ; Branch if overflow clear to $50, $18 [Flow: branch]
	cpx #$50.b		; E0 50 ; Compare #$50.b with X register [Reads: X Index] [Flags: NCZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	cpx #$01.b		; E0 01 ; Compare #$01.b with X register [Reads: X Index] [Flags: NCZ]
	sbc $480000.l,X		; FF 00 00 48 ; Subtract with carry (long,X) $480000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $303000.l,X		; FF 00 30 30 ; Subtract with carry (long,X) $303000.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	cld		; D8 ; Clear decimal flag [Flags: D]
	ora ($FF.b,X)		; 01 FF ; Logical OR ($FF.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	brk $00.b		; 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($26.b,X)		; 01 26 ; Logical OR ($26.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	sta [$FA.b]		; 87 FA ; Store accumulator (long) [$FA.b] [Reads: Direct Page, Accumulator]
	tsb $04A2.w		; 0C A2 04 ; Test and set bits $04A2.w [Reads: Accumulator] [Flags: Z]
	lda $0CFA9E.l,X		; BF 9E FA 0C ; Load long $0CFA9E.l,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $4360.w,X		; 9D 60 43 ; Store accumulator to $4360.w,X [Reads: Accumulator, X Index]
	sta $4370.w,X		; 9D 70 43 ; Store accumulator to $4370.w,X [Reads: Accumulator, X Index]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	.db $10, $F3		; 10 F3 ; Branch if plus to $10, $F3 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda #$FA94.w		; A9 94 FA ; Load #$FA94.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta DMASRC7L.w		; 8D 72 43 ; Store accumulator to DMASRC7L.w [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	lda #$28.b		; A9 28 ; Load #$28.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta DMADEST7.w		; 8D 71 43 ; Store accumulator to DMADEST7.w [Reads: Accumulator]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	adc ($65.b,X)		; 61 65 ; Add with carry ($65.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($85.b,X)		; 61 85 ; Add with carry ($85.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $35		; 10 35 ; Branch if plus to $10, $35 [Flow: branch]
	adc ($A5.b,X)		; 61 A5 ; Add with carry ($A5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $35.b		; 02 35 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $35.b		; 02 35 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $35.b		; 02 35 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $35.b		; 02 35 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	ora $31.b,S		; 03 31 ; OR accumulator with stack relative $31.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora $71.b,S		; 03 71 ; OR accumulator with stack relative $71.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	cop $35.b		; 02 35 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $35.b		; 02 35 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $35.b		; 02 35 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $35.b		; 02 35 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	cop $35.b		; 02 35 ; Coprocessor interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b,X)		; 01 35 ; Logical OR ($35.b,X) with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ] [SNES: Indexed indirect addressing]
	adc ($C5.b,X)		; 61 C5 ; Add with carry ($C5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b,S),Y		; 13 35 ; OR accumulator (stack relative indirect indexed) ($35.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($75.b,S),Y		; 13 75 ; OR accumulator (stack relative indirect indexed) ($75.b,S),Y [Reads: Y Index, Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b)		; 12 35 ; OR accumulator with memory (indirect) ($35.b) [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	ora ($35.b),Y		; 11 35 ; OR accumulator with memory ($35.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	adc ($E5.b,X)		; 61 E5 ; Add with carry ($E5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $2135.w		; 20 35 21 ; Jump to subroutine at $2135.w [Writes: Stack Pointer] [Flow: call]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $21.b,X		; 35 21 ; Logical AND $21.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $21.b,X		; 35 21 ; Logical AND $21.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $21.b,X		; 35 21 ; Logical AND $21.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $21.b,X		; 35 21 ; Logical AND $21.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $21.b,X		; 35 21 ; Logical AND $21.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $21.b,X		; 35 21 ; Logical AND $21.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $21.b,X		; 35 21 ; Logical AND $21.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $21.b,X		; 35 21 ; Logical AND $21.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $21.b,X		; 35 21 ; Logical AND $21.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $62.b,X		; 35 62 ; Logical AND $62.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $40.b		; 05 40 ; Logical OR $40.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $B5.b		; 00 B5 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	sbc $406561.l,X		; FF 61 65 40 ; Subtract with carry (long,X) $406561.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($85.b,X)		; 61 85 ; Add with carry ($85.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $13.b		; 00 13 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	.db $10, $35		; 10 35 ; Branch if plus to $10, $35 [Flow: branch]
	lsr $6E75.w		; 4E 75 6E ; Logical shift right $6E75.w [Flags: NCZ]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $4E.b,X		; 35 4E ; Logical AND $4E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $4C.b,X		; 35 4C ; Logical AND $4C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $4E.b,X		; 35 4E ; Logical AND $4E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $49.b,X		; 75 49 ; Add $49.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $61.b,X		; 35 61 ; Logical AND $61.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $100840.l		; 8F 40 08 10 ; Store accumulator (long) $100840.l [Reads: Accumulator]
	and $61.b,X		; 35 61 ; Logical AND $61.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sty $00.b,X		; 94 00 ; Store Y register $00.b,X [Reads: Direct Page, X Index] [Writes: Y Index]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	lsr $6E75.w		; 4E 75 6E ; Logical shift right $6E75.w [Flags: NCZ]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $4E.b,X		; 35 4E ; Logical AND $4E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $4C.b,X		; 35 4C ; Logical AND $4C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $61.b,X		; 35 61 ; Logical AND $61.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$5F.b		; 29 5F ; Logical AND #$5F.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $5E.b,X		; 75 5E ; Add $5E.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7E.b,X		; 75 7E ; Add $7E.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $7F.b,X		; 35 7F ; Logical AND $7F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $5E.b,X		; 35 5E ; Logical AND $5E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $5F.b,X		; 35 5F ; Logical AND $5F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $4D.b,X		; 35 4D ; Logical AND $4D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $5F.b,X		; 35 5F ; Logical AND $5F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $5E.b,X		; 75 5E ; Add $5E.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $4A.b,X		; 75 4A ; Add $4A.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $4B.b,X		; 35 4B ; Logical AND $4B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $49.b,X		; 35 49 ; Logical AND $49.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $10.b,X		; 75 10 ; Add $10.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $5F.b,X		; 35 5F ; Logical AND $5F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $5E.b,X		; 75 5E ; Add $5E.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $7E.b,X		; 75 7E ; Add $7E.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	and $7F.b,X		; 35 7F ; Logical AND $7F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $5E.b,X		; 35 5E ; Logical AND $5E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $5F.b,X		; 35 5F ; Logical AND $5F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $4D.b,X		; 35 4D ; Logical AND $4D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $61.b,X		; 35 61 ; Logical AND $61.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	cmp $00.b		; C5 00 ; Compare $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and #$50.b		; 29 50 ; Logical AND #$50.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $51.b,X		; 35 51 ; Logical AND $51.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $52.b,X		; 35 52 ; Logical AND $52.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $53.b,X		; 35 53 ; Logical AND $53.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $54.b,X		; 35 54 ; Logical AND $54.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $55.b,X		; 35 55 ; Logical AND $55.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $56.b,X		; 35 56 ; Logical AND $56.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $57.b,X		; 35 57 ; Logical AND $57.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $58.b,X		; 35 58 ; Logical AND $58.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $59.b,X		; 35 59 ; Logical AND $59.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $5A.b,X		; 35 5A ; Logical AND $5A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $5B.b,X		; 35 5B ; Logical AND $5B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $5C.b,X		; 35 5C ; Logical AND $5C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $5D.b,X		; 35 5D ; Logical AND $5D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $50.b,X		; 35 50 ; Logical AND $50.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $51.b,X		; 35 51 ; Logical AND $51.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $52.b,X		; 35 52 ; Logical AND $52.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $53.b,X		; 35 53 ; Logical AND $53.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $54.b,X		; 35 54 ; Logical AND $54.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $55.b,X		; 35 55 ; Logical AND $55.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $56.b,X		; 35 56 ; Logical AND $56.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $61.b,X		; 35 61 ; Logical AND $61.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sbc $00.b		; E5 00 ; Subtract $00.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and #$60.b		; 29 60 ; Logical AND #$60.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $61.b,X		; 35 61 ; Logical AND $61.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $62.b,X		; 35 62 ; Logical AND $62.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $63.b,X		; 35 63 ; Logical AND $63.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $64.b,X		; 35 64 ; Logical AND $64.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $65.b,X		; 35 65 ; Logical AND $65.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $66.b,X		; 35 66 ; Logical AND $66.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $67.b,X		; 35 67 ; Logical AND $67.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $68.b,X		; 35 68 ; Logical AND $68.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $69.b,X		; 35 69 ; Logical AND $69.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $6A.b,X		; 35 6A ; Logical AND $6A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $6B.b,X		; 35 6B ; Logical AND $6B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $6C.b,X		; 35 6C ; Logical AND $6C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $6D.b,X		; 35 6D ; Logical AND $6D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $60.b,X		; 35 60 ; Logical AND $60.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $61.b,X		; 35 61 ; Logical AND $61.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $62.b,X		; 35 62 ; Logical AND $62.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $63.b,X		; 35 63 ; Logical AND $63.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $64.b,X		; 35 64 ; Logical AND $64.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $65.b,X		; 35 65 ; Logical AND $65.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $66.b,X		; 35 66 ; Logical AND $66.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $62.b,X		; 35 62 ; Logical AND $62.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$70.b		; 29 70 ; Logical AND #$70.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $71.b,X		; 35 71 ; Logical AND $71.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $72.b,X		; 35 72 ; Logical AND $72.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $73.b,X		; 35 73 ; Logical AND $73.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $74.b,X		; 35 74 ; Logical AND $74.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $75.b,X		; 35 75 ; Logical AND $75.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $76.b,X		; 35 76 ; Logical AND $76.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $77.b,X		; 35 77 ; Logical AND $77.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $78.b,X		; 35 78 ; Logical AND $78.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $79.b,X		; 35 79 ; Logical AND $79.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $7A.b,X		; 35 7A ; Logical AND $7A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $7B.b,X		; 35 7B ; Logical AND $7B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $7C.b,X		; 35 7C ; Logical AND $7C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $7D.b,X		; 35 7D ; Logical AND $7D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $70.b,X		; 35 70 ; Logical AND $70.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $71.b,X		; 35 71 ; Logical AND $71.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $72.b,X		; 35 72 ; Logical AND $72.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $73.b,X		; 35 73 ; Logical AND $73.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $74.b,X		; 35 74 ; Logical AND $74.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $75.b,X		; 35 75 ; Logical AND $75.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $76.b,X		; 35 76 ; Logical AND $76.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $FF.b,X		; 35 FF ; Logical AND $FF.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc ($65.b,X)		; 61 65 ; Add with carry ($65.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	adc ($85.b,X)		; 61 85 ; Add with carry ($85.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	plp		; 28 ; Pull processor status [Reads: Stack Pointer] [Writes: Processor Status, Stack Pointer] [Flags: MXCZIDVN]
	.db $10, $35		; 10 35 ; Branch if plus to $10, $35 [Flow: branch]
	adc ($A5.b,X)		; 61 A5 ; Add with carry ($A5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $1D.b		; 00 1D ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsl $352335.l		; 22 35 23 35 ; Jump to subroutine long $352335.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $35		; 10 35 ; Branch if plus to $10, $35 [Flow: branch]
	jsl $352335.l		; 22 35 23 35 ; Jump to subroutine long $352335.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $35		; 10 35 ; Branch if plus to $10, $35 [Flow: branch]
	jsl $352335.l		; 22 35 23 35 ; Jump to subroutine long $352335.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $35		; 10 35 ; Branch if plus to $10, $35 [Flow: branch]
	jsl $352335.l		; 22 35 23 35 ; Jump to subroutine long $352335.l [Writes: Stack Pointer] [Flow: call]
	.db $10, $35		; 10 35 ; Branch if plus to $10, $35 [Flow: branch]
	.db $10, $75		; 10 75 ; Branch if plus to $10, $75 [Flow: branch]
	and $75.b,S		; 23 75 ; AND accumulator with stack relative $75.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $B46175.l		; 22 75 61 B4 ; Jump to subroutine long $B46175.l [Writes: Stack Pointer] [Flow: call]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	asl $10.b		; 06 10 ; Arithmetic shift left $10.b [Reads: Direct Page] [Flags: NCZ]
	and $61.b,X		; 35 61 ; Logical AND $61.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	clv		; B8 ; Clear overflow flag [Flags: V]
	brk $03.b		; 00 03 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	and $75.b,S		; 23 75 ; AND accumulator with stack relative $75.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $C56175.l		; 22 75 61 C5 ; Jump to subroutine long $C56175.l [Writes: Stack Pointer] [Flow: call]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tsb $35.b		; 04 35 ; Test and set bits $35.b [Reads: Accumulator] [Flags: Z]
	ora $35.b		; 05 35 ; Logical OR $35.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $35.b		; 06 35 ; Arithmetic shift left $35.b [Reads: Direct Page] [Flags: NCZ]
	tsb $35.b		; 04 35 ; Test and set bits $35.b [Reads: Accumulator] [Flags: Z]
	ora $35.b		; 05 35 ; Logical OR $35.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $35.b		; 06 35 ; Arithmetic shift left $35.b [Reads: Direct Page] [Flags: NCZ]
	tsb $35.b		; 04 35 ; Test and set bits $35.b [Reads: Accumulator] [Flags: Z]
	ora $35.b		; 05 35 ; Logical OR $35.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $35.b		; 06 35 ; Arithmetic shift left $35.b [Reads: Direct Page] [Flags: NCZ]
	tsb $35.b		; 04 35 ; Test and set bits $35.b [Reads: Accumulator] [Flags: Z]
	ora $35.b		; 05 35 ; Logical OR $35.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	asl $35.b		; 06 35 ; Arithmetic shift left $35.b [Reads: Direct Page] [Flags: NCZ]
	asl $75.b		; 06 75 ; Arithmetic shift left $75.b [Reads: Direct Page] [Flags: NCZ]
	ora $75.b		; 05 75 ; Logical OR $75.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $75.b		; 04 75 ; Test and set bits $75.b [Reads: Accumulator] [Flags: Z]
	.db $10, $75		; 10 75 ; Branch if plus to $10, $75 [Flow: branch]
	and $75.b,S		; 23 75 ; AND accumulator with stack relative $75.b,S [Reads: Stack Pointer] [Writes: Accumulator] [Flags: NZ]
	jsl $750675.l		; 22 75 06 75 ; Jump to subroutine long $750675.l [Writes: Stack Pointer] [Flow: call]
	ora $75.b		; 05 75 ; Logical OR $75.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $75.b		; 04 75 ; Test and set bits $75.b [Reads: Accumulator] [Flags: Z]
	adc ($E5.b,X)		; 61 E5 ; Add with carry ($E5.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	trb $35.b		; 14 35 ; Test and reset bits $35.b [Reads: Accumulator] [Flags: Z]
	ora $35.b,X		; 15 35 ; OR accumulator with memory $35.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $35.b,X		; 16 35 ; Arithmetic shift left $35.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $35.b		; 14 35 ; Test and reset bits $35.b [Reads: Accumulator] [Flags: Z]
	ora $35.b,X		; 15 35 ; OR accumulator with memory $35.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $35.b,X		; 16 35 ; Arithmetic shift left $35.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $35.b		; 14 35 ; Test and reset bits $35.b [Reads: Accumulator] [Flags: Z]
	ora $35.b,X		; 15 35 ; OR accumulator with memory $35.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $35.b,X		; 16 35 ; Arithmetic shift left $35.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	trb $35.b		; 14 35 ; Test and reset bits $35.b [Reads: Accumulator] [Flags: Z]
	ora $35.b,X		; 15 35 ; OR accumulator with memory $35.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	asl $35.b,X		; 16 35 ; Arithmetic shift left $35.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	asl $75.b,X		; 16 75 ; Arithmetic shift left $75.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $75.b,X		; 15 75 ; OR accumulator with memory $75.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $75.b		; 14 75 ; Test and reset bits $75.b [Reads: Accumulator] [Flags: Z]
	asl $75.b		; 06 75 ; Arithmetic shift left $75.b [Reads: Direct Page] [Flags: NCZ]
	ora $75.b		; 05 75 ; Logical OR $75.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	tsb $75.b		; 04 75 ; Test and set bits $75.b [Reads: Accumulator] [Flags: Z]
	asl $75.b,X		; 16 75 ; Arithmetic shift left $75.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	ora $75.b,X		; 15 75 ; OR accumulator with memory $75.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	trb $75.b		; 14 75 ; Test and reset bits $75.b [Reads: Accumulator] [Flags: Z]
	.db $62, $05, $00		; 62 05 00 ; Push effective relative address $62, $05, $00 [Writes: Stack Pointer]
	and #$24.b		; 29 24 ; Logical AND #$24.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $25.b,X		; 35 25 ; Logical AND $25.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $26.b,X		; 35 26 ; Logical AND $26.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $24.b,X		; 35 24 ; Logical AND $24.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $25.b,X		; 35 25 ; Logical AND $25.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $26.b,X		; 35 26 ; Logical AND $26.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $24.b,X		; 35 24 ; Logical AND $24.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $25.b,X		; 35 25 ; Logical AND $25.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $26.b,X		; 35 26 ; Logical AND $26.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $24.b,X		; 35 24 ; Logical AND $24.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $25.b,X		; 35 25 ; Logical AND $25.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $26.b,X		; 35 26 ; Logical AND $26.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $26.b,X		; 35 26 ; Logical AND $26.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $25.b,X		; 75 25 ; Add $25.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $24.b,X		; 75 24 ; Add $24.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $26.b,X		; 75 26 ; Add $26.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $25.b,X		; 75 25 ; Add $25.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $24.b,X		; 75 24 ; Add $24.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $26.b,X		; 75 26 ; Add $26.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $25.b,X		; 75 25 ; Add $25.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $24.b,X		; 75 24 ; Add $24.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FF.b,X		; 75 FF ; Add $FF.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc ($65.b,X)		; 61 65 ; Add with carry ($65.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $29.b		; 00 29 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $35.b		; 00 35 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	tas		; 1B ; Transfer C to stack pointer  [Reads: Accumulator] [Writes: Stack Pointer]
	and $30.b,X		; 35 30 ; Logical AND $30.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $31.b,X		; 35 31 ; Logical AND $31.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $32.b,X		; 35 32 ; Logical AND $32.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,X		; 35 00 ; Logical AND $00.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,X		; 35 00 ; Logical AND $00.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $00.b,X		; 35 00 ; Logical AND $00.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $33.b,X		; 35 33 ; Logical AND $33.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $41.b,X		; 35 41 ; Logical AND $41.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $41.b,X		; 35 41 ; Logical AND $41.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $33.b,X		; 75 33 ; Add $33.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $00.b,X		; 75 00 ; Add $00.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $00.b,X		; 75 00 ; Add $00.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $00.b,X		; 75 00 ; Add $00.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $32.b,X		; 75 32 ; Add $32.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $31.b,X		; 75 31 ; Add $31.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $30.b,X		; 75 30 ; Add $30.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $1B.b,X		; 75 1B ; Add $1B.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $00.b,X		; 75 00 ; Add $00.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $61.b,X		; 75 61 ; Add $61.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sta $40.b		; 85 40 ; Store accumulator to $40.b [Reads: Accumulator]
	asl $3510.w,X		; 1E 10 35 ; Arithmetic shift left $3510.w,X [Reads: X Index] [Flags: NCZ]
	adc ($86.b,X)		; 61 86 ; Add with carry ($86.b,X) [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $09.b		; 00 09 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	bit $35.b,X		; 34 35 ; Test bits $35.b,X [Reads: Direct Page, X Index] [Flags: NVZ] [Flow: branch]
	phd		; 0B ; Push direct page register  [Reads: Direct Page] [Writes: Stack Pointer]
	and $40.b,X		; 35 40 ; Logical AND $40.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $41.b,X		; 35 41 ; Logical AND $41.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $42.b,X		; 35 42 ; Logical AND $42.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $61.b,X		; 35 61 ; Logical AND $61.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $00.b,X		; 95 00 ; Store accumulator to $00.b,X [Reads: Accumulator, X Index]
	ora #$42.b		; 09 42 ; Logical OR #$42.b with accumulator [Writes: Accumulator] [Flags: NZ]
	adc $41.b,X		; 75 41 ; Add $41.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $40.b,X		; 75 40 ; Add $40.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0B.b,X		; 75 0B ; Add $0B.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $34.b,X		; 75 34 ; Add $34.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $61.b,X		; 75 61 ; Add $61.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	lda $00.b		; A5 00 ; Load $00.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$43.b		; 29 43 ; Logical AND #$43.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $44.b,X		; 35 44 ; Logical AND $44.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $07.b,X		; 35 07 ; Logical AND $07.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $08.b,X		; 35 08 ; Logical AND $08.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $09.b,X		; 35 09 ; Logical AND $09.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $0A.b,X		; 35 0A ; Logical AND $0A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $0C.b,X		; 35 0C ; Logical AND $0C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $0D.b,X		; 35 0D ; Logical AND $0D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $0E.b,X		; 35 0E ; Logical AND $0E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $0F.b,X		; 35 0F ; Logical AND $0F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $0F.b,X		; 35 0F ; Logical AND $0F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $0E.b,X		; 75 0E ; Add $0E.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0D.b,X		; 75 0D ; Add $0D.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0C.b,X		; 75 0C ; Add $0C.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $10.b,X		; 75 10 ; Add $10.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $0A.b,X		; 75 0A ; Add $0A.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $09.b,X		; 75 09 ; Add $09.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $08.b,X		; 75 08 ; Add $08.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $07.b,X		; 75 07 ; Add $07.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $44.b,X		; 75 44 ; Add $44.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $61.b,X		; 75 61 ; Add $61.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	cmp $00.b		; C5 00 ; Compare $00.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NCZ]
	and #$35.b		; 29 35 ; Logical AND #$35.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $36.b,X		; 35 36 ; Logical AND $36.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $17.b,X		; 35 17 ; Logical AND $17.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $18.b,X		; 35 18 ; Logical AND $18.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $19.b,X		; 35 19 ; Logical AND $19.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $1A.b,X		; 35 1A ; Logical AND $1A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $10.b,X		; 35 10 ; Logical AND $10.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $1C.b,X		; 35 1C ; Logical AND $1C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $1D.b,X		; 35 1D ; Logical AND $1D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $1E.b,X		; 35 1E ; Logical AND $1E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $1F.b,X		; 35 1F ; Logical AND $1F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $1F.b,X		; 35 1F ; Logical AND $1F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $1E.b,X		; 75 1E ; Add $1E.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $1D.b,X		; 75 1D ; Add $1D.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $1C.b,X		; 75 1C ; Add $1C.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $10.b,X		; 75 10 ; Add $10.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $1A.b,X		; 75 1A ; Add $1A.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $19.b,X		; 75 19 ; Add $19.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $18.b,X		; 75 18 ; Add $18.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $17.b,X		; 75 17 ; Add $17.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $36.b,X		; 75 36 ; Add $36.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $61.b,X		; 75 61 ; Add $61.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $00.b		; E5 00 ; Subtract $00.b from accumulator with borrow [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	and #$45.b		; 29 45 ; Logical AND #$45.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $46.b,X		; 35 46 ; Logical AND $46.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $27.b,X		; 35 27 ; Logical AND $27.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $28.b,X		; 35 28 ; Logical AND $28.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $29.b,X		; 35 29 ; Logical AND $29.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $2A.b,X		; 35 2A ; Logical AND $2A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $2B.b,X		; 35 2B ; Logical AND $2B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $2C.b,X		; 35 2C ; Logical AND $2C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $2D.b,X		; 35 2D ; Logical AND $2D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $2E.b,X		; 35 2E ; Logical AND $2E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $2F.b,X		; 35 2F ; Logical AND $2F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $2F.b,X		; 35 2F ; Logical AND $2F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $2E.b,X		; 75 2E ; Add $2E.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $2D.b,X		; 75 2D ; Add $2D.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $2C.b,X		; 75 2C ; Add $2C.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $2B.b,X		; 75 2B ; Add $2B.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $2A.b,X		; 75 2A ; Add $2A.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $29.b,X		; 75 29 ; Add $29.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $28.b,X		; 75 28 ; Add $28.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $27.b,X		; 75 27 ; Add $27.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $46.b,X		; 75 46 ; Add $46.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $62.b,X		; 75 62 ; Add $62.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	ora $00.b		; 05 00 ; Logical OR $00.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and #$47.b		; 29 47 ; Logical AND #$47.b with accumulator [Writes: Accumulator] [Flags: NZ]
	and $48.b,X		; 35 48 ; Logical AND $48.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $37.b,X		; 35 37 ; Logical AND $37.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $38.b,X		; 35 38 ; Logical AND $38.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $39.b,X		; 35 39 ; Logical AND $39.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $3A.b,X		; 35 3A ; Logical AND $3A.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $3B.b,X		; 35 3B ; Logical AND $3B.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $3C.b,X		; 35 3C ; Logical AND $3C.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $3D.b,X		; 35 3D ; Logical AND $3D.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $3E.b,X		; 35 3E ; Logical AND $3E.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $3F.b,X		; 35 3F ; Logical AND $3F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	and $3F.b,X		; 35 3F ; Logical AND $3F.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	adc $3E.b,X		; 75 3E ; Add $3E.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $3D.b,X		; 75 3D ; Add $3D.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $3C.b,X		; 75 3C ; Add $3C.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $3B.b,X		; 75 3B ; Add $3B.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $3A.b,X		; 75 3A ; Add $3A.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $39.b,X		; 75 39 ; Add $39.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $38.b,X		; 75 38 ; Add $38.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $37.b,X		; 75 37 ; Add $37.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $48.b,X		; 75 48 ; Add $48.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	adc $FF.b,X		; 75 FF ; Add $FF.b,X to accumulator with carry [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NCVZ]
	brk $02.b		; 00 02 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	jsr $0422.w		; 20 22 04 ; Jump to subroutine at $0422.w [Writes: Stack Pointer] [Flow: call]
	asl $08.b		; 06 08 ; Arithmetic shift left $08.b [Reads: Direct Page] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tsb $400E.w		; 0C 0E 40 ; Test and set bits $400E.w [Reads: Accumulator] [Flags: Z]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $30, $50		; 30 50 ; Branch if minus to $30, $50 [Flow: branch]
	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	rti		; 40 ; Return from interrupt [Reads: Stack Pointer] [Writes: Stack Pointer] [Flags: MXCZIDVN] [Flow: return]

	.db $10, $00		; 10 00 ; Branch if plus to $10, $00 [Flow: branch]
	jsr $2800.w		; 20 00 28 ; Jump to subroutine at $2800.w [Writes: Stack Pointer] [Flow: call]
	brk $28.b		; 00 28 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $30.b		; 00 30 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $40.b		; 00 40 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $50.b		; 00 50 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $60.b		; 00 60 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $70.b		; 00 70 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $80.b		; 00 80 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	brk $00.b		; [PATTERN: Memory clearing operation] 00 00 ; Software interrupt [Writes: Stack Pointer] [Flags: I] [Flow: interrupt]
	lda #$07.b		; A9 07 ; Load #$07.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $CB.b		; 85 CB ; Store accumulator to $CB.b [Reads: Accumulator]
	stz $CC.b		; 64 CC ; Store zero to $CC.b
	stz $CD.b		; 64 CD ; Store zero to $CD.b
.ACCU 16
	rep #$20		; C2 20
	lda #$FF7E.w		; A9 7E FF ; Load #$FF7E.w into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $C8.b		; 85 C8 ; Store accumulator to $C8.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	phb		; [PATTERN: Function entry: Data bank preservation prologue] 8B ; Push data bank register to stack [Reads: Data Bank] [Writes: Stack Pointer] [SNES: Stack operation: pushes DBR]
	phk		; 4B ; Push program bank register  [Reads: Program Bank] [Writes: Stack Pointer]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	lda $CA.b		; A5 CA ; Load $CA.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $02		; F0 02 ; Branch if equal to $F0, $02 [Flow: branch]
	dec $CA.b		; C6 CA ; Decrement $CA.b [Reads: Direct Page] [Flags: NZ]
	jsl $0ED60B.l		; 22 0B D6 0E ; Jump to subroutine long $0ED60B.l [Writes: Stack Pointer] [Flow: call]
	lda $0FF9.w		; AD F9 0F ; Load $0FF9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $18		; F0 18 ; Branch if equal to $F0, $18 [Flow: branch]
	and #$03.b		; 29 03 ; Logical AND #$03.b with accumulator [Writes: Accumulator] [Flags: NZ]
	.db $F0, $11		; F0 11 ; Branch if equal to $F0, $11 [Flow: branch]
	ldx $D0.b		; A6 D0 ; Load $D0.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda #$1F.b		; A9 1F ; Load #$1F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	ora $9C.b,X		; 15 9C ; OR accumulator with memory $9C.b,X [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	sta $9C.b,X		; 95 9C ; Store accumulator to $9C.b,X [Reads: Accumulator, X Index]
	inx		; E8 ; Increment X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	cpx #$03.b		; E0 03 ; Compare #$03.b with X register [Reads: X Index] [Flags: NCZ]
	.db $D0, $02		; D0 02 ; Branch if not equal to $D0, $02 [Flow: branch]
	ldx #$00.b		; A2 00 ; Load #$00.b into X register [Writes: X Index] [Flags: NZ]
	stx $D0.b		; 86 D0 ; Store X register to $D0.b [Reads: X Index]
	dec $0FF9.w		; CE F9 0F ; Decrement $0FF9.w [Flags: NZ]
	ldy #$09.b		; A0 09 ; Load #$09.b into Y register [Writes: Y Index] [Flags: NZ]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tax		; AA ; Transfer accumulator to X [Reads: Accumulator] [Writes: X Index] [Flags: NZ]
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0A72.w,Y		; 99 72 0A ; Store accumulator to $0A72.w,Y [Reads: Y Index, Accumulator]
	lda $FE1C.w,Y		; B9 1C FE ; Load $FE1C.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $094A.w,X		; 9D 4A 09 ; Store accumulator to $094A.w,X [Reads: Accumulator, X Index]
	lda #$21.b		; A9 21 ; Load #$21.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $094B.w,X		; 9D 4B 09 ; Store accumulator to $094B.w,X [Reads: Accumulator, X Index]
	lda $FE26.w,Y		; B9 26 FE ; Load $FE26.w,Y into accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	sta $0948.w,X		; 9D 48 09 ; Store accumulator to $0948.w,X [Reads: Accumulator, X Index]
	phy		; 5A ; Push Y register [Reads: Y Index] [Writes: Stack Pointer]
	tya		; 98 ; Transfer Y to accumulator [Reads: Y Index] [Writes: Accumulator] [Flags: NZ]
	asl A		; 0A ; Arithmetic shift left accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NCZ]
	tay		; A8 ; Transfer accumulator to Y [Reads: Accumulator] [Writes: Y Index] [Flags: NZ]
.ACCU 16
	rep #$20		; C2 20
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $FE30.w,Y		; 79 30 FE ; Add $FE30.w,Y to accumulator with carry [Reads: Y Index] [Writes: Accumulator] [Flags: NCVZ]
.ACCU 8
	sep #$20		; E2 20
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	.db $F0, $03		; F0 03 ; Branch if equal to $F0, $03 [Flow: branch]
	lda #$F8.b		; A9 F8 ; Load #$F8.b into accumulator [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	xba		; EB ; Exchange B and A accumulator [Reads: Accumulator] [Writes: Accumulator] [Flags: NZ]
	sec		; 38 ; Set carry flag [Flags: C]
	sbc #$08.b		; E9 08 ; Subtract #$08.b from accumulator with borrow [Writes: Accumulator] [Flags: NCVZ]
	sta $0949.w,X		; 9D 49 09 ; Store accumulator to $0949.w,X [Reads: Accumulator, X Index]
	ply		; 7A ; Pull Y register [Reads: Stack Pointer] [Writes: Y Index, Stack Pointer] [Flags: NZ]
	dey		; 88 ; Decrement Y register [Reads: Y Index] [Writes: Y Index] [Flags: NZ]
	.db $10, $C7		; 10 C7 ; Branch if plus to $10, $C7 [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$001E.w		; C9 1E 00 ; Compare #$001E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $1E		; F0 1E ; Branch if equal to $F0, $1E [Flow: branch]
	ldy #$01.b		; A0 01 ; Load #$01.b into Y register [Writes: Y Index] [Flags: NZ]
	cmp #$FFBE.w		; C9 BE FF ; Compare #$FFBE.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0E		; F0 0E ; Branch if equal to $F0, $0E [Flow: branch]
	cmp #$000E.w		; C9 0E 00 ; Compare #$000E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $0C		; D0 0C ; Branch if not equal to $D0, $0C [Flow: branch]
	stz $D0.b		; 64 D0 ; Store zero to $D0.b
	ldx #$20.b		; A2 20 ; Load #$20.b into X register [Writes: X Index] [Flags: NZ]
	stx $0FF9.w		; 8E F9 0F ; Store X register to $0FF9.w [Reads: X Index]
	ldy #$2C.b		; A0 2C ; Load #$2C.b into Y register [Writes: Y Index] [Flags: NZ]
	sty $012E.w		; 8C 2E 01 ; Store Y register to $012E.w [Reads: Y Index]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$0010.w		; 69 10 00 ; Add #$0010.w to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $C8.b		; 85 C8 ; Store accumulator to $C8.b [Reads: Accumulator]
.ACCU 8
	sep #$20		; E2 20
	ldx $CC.b		; A6 CC ; Load $CC.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	jmp ($FEE9.w,X)		; 7C E9 FE ; Jump indirect indexed to ($FEE9.w,X) [Reads: X Index] [Flow: jump]
	sbc $FF13FE.l		; EF FE 13 FF ; Subtract with carry (long) $FF13FE.l [Writes: Accumulator] [Flags: NCVZ]
	eor ($FF.b),Y		; 51 FF ; Exclusive OR accumulator with memory ($FF.b),Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	lda $0FF9.w		; AD F9 0F ; Load $0FF9.w into accumulator [Writes: Accumulator] [Flags: NZ]
	.db $D0, $0F		; D0 0F ; Branch if not equal to $D0, $0F [Flow: branch]
.ACCU 16
	rep #$20		; C2 20
	lda $C8.b		; A5 C8 ; Load $C8.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$001E.w		; C9 1E 00 ; Compare #$001E.w with accumulator [Reads: Accumulator] [Flags: NCZ]
.ACCU 8
	sep #$20		; E2 20
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	inc $CC.b		; E6 CC ; Increment $CC.b [Reads: Direct Page] [Flags: NZ]
	inc $CC.b		; E6 CC ; Increment $CC.b [Reads: Direct Page] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	tsb $04.b		; 04 04 ; Test and set bits $04.b [Reads: Accumulator] [Flags: Z]
	asl $06.b		; 06 06 ; Arithmetic shift left $06.b [Reads: Direct Page] [Flags: NCZ]
	asl $04.b		; 06 04 ; Arithmetic shift left $04.b [Reads: Direct Page] [Flags: NCZ]
	tsb $28.b		; 04 28 ; Test and set bits $28.b [Reads: Accumulator] [Flags: Z]
	and [$27.b],Y		; 37 27 ; AND accumulator with memory (long indexed) [$27.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	rol $27.b,X		; 36 27 ; Rotate left $27.b,X [Reads: Direct Page, X Index] [Flags: NCZ]
	and [$28.b],Y		; 37 28 ; AND accumulator with memory (long indexed) [$28.b],Y [Reads: Direct Page, Y Index] [Writes: Accumulator] [Flags: NZ]
	ldx $CB.b		; A6 CB ; Load $CB.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	lda $CA.b		; A5 CA ; Load $CA.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $16		; D0 16 ; Branch if not equal to $D0, $16 [Flow: branch]
	dex		; CA ; Decrement X register [Reads: X Index] [Writes: X Index] [Flags: NZ]
	stx $CB.b		; 86 CB ; Store X register to $CB.b [Reads: X Index]
	.db $10, $0C		; 10 0C ; Branch if plus to $10, $0C [Flow: branch]
	stz $CB.b		; 64 CB ; Store zero to $CB.b
	lda #$02.b		; A9 02 ; Load #$02.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $CA.b		; 85 CA ; Store accumulator to $CA.b [Reads: Accumulator]
	inc $CC.b		; E6 CC ; Increment $CC.b [Reads: Direct Page] [Flags: NZ]
	inc $CC.b		; E6 CC ; Increment $CC.b [Reads: Direct Page] [Flags: NZ]
	.db $80, $1D		; 80 1D ; Branch always to $80, $1D [Flow: branch]
	lda $FF05.w,X		; BD 05 FF ; Load $FF05.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $CA.b		; 85 CA ; Store accumulator to $CA.b [Reads: Accumulator]
	stz $0A70.w		; 9C 70 0A ; Store zero to $0A70.w
	lda #$44.b		; A9 44 ; Load #$44.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0940.w		; 8D 40 09 ; Store accumulator to $0940.w [Reads: Accumulator]
	lda #$43.b		; A9 43 ; Load #$43.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0941.w		; 8D 41 09 ; Store accumulator to $0941.w [Reads: Accumulator]
	lda #$25.b		; A9 25 ; Load #$25.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0943.w		; 8D 43 09 ; Store accumulator to $0943.w [Reads: Accumulator]
	lda $FF0C.w,X		; BD 0C FF ; Load $FF0C.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0942.w		; 8D 42 09 ; Store accumulator to $0942.w [Reads: Accumulator]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	rol $20.b		; 26 20 ; Rotate left $20.b [Reads: Direct Page] [Flags: NCZ]
	bit $34.b		; 24 34 ; Test bits $34.b with accumulator [Reads: Direct Page, Accumulator] [Flags: NVZ]
	and $20.b		; 25 20 ; Logical AND $20.b with accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	and $20.b,X		; 35 20 ; Logical AND $20.b,X with accumulator [Reads: Direct Page, X Index] [Writes: Accumulator] [Flags: NZ]
	ldx $CB.b		; [PATTERN: Memory clearing operation] A6 CB ; Load $CB.b into X register [Reads: Direct Page] [Writes: X Index] [Flags: NZ]
	cpx #$07.b		; E0 07 ; Compare #$07.b with X register [Reads: X Index] [Flags: NCZ]
	.db $B0, $58		; B0 58 ; Branch if carry set to $B0, $58 [Flow: branch]
	stz $0A70.w		; 9C 70 0A ; Store zero to $0A70.w
	stz $0A71.w		; 9C 71 0A ; Store zero to $0A71.w
	lda #$42.b		; A9 42 ; Load #$42.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0940.w		; 8D 40 09 ; Store accumulator to $0940.w [Reads: Accumulator]
	sta $0944.w		; 8D 44 09 ; Store accumulator to $0944.w [Reads: Accumulator]
	lda $CD.b		; A5 CD ; Load $CD.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	cmp #$50.b		; C9 50 ; Compare #$50.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $90, $02		; 90 02 ; Branch if carry clear to $90, $02 [Flow: branch]
	lda #$4F.b		; A9 4F ; Load #$4F.b into accumulator [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc $C8.b		; 65 C8 ; Add $C8.b to accumulator with carry [Reads: Direct Page] [Writes: Accumulator] [Flags: NCVZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$31.b		; 69 31 ; Add #$31.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0941.w		; 8D 41 09 ; Store accumulator to $0941.w [Reads: Accumulator]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$08.b		; 69 08 ; Add #$08.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $0945.w		; 8D 45 09 ; Store accumulator to $0945.w [Reads: Accumulator]
	lda #$23.b		; A9 23 ; Load #$23.b into accumulator [Writes: Accumulator] [Flags: NZ]
	sta $0943.w		; 8D 43 09 ; Store accumulator to $0943.w [Reads: Accumulator]
	sta $0947.w		; 8D 47 09 ; Store accumulator to $0947.w [Reads: Accumulator]
	lda $FF49.w,X		; BD 49 FF ; Load $FF49.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0942.w		; 8D 42 09 ; Store accumulator to $0942.w [Reads: Accumulator]
	lda $FF4A.w,X		; BD 4A FF ; Load $FF4A.w,X into accumulator [Reads: X Index] [Writes: Accumulator] [Flags: NZ]
	sta $0946.w		; 8D 46 09 ; Store accumulator to $0946.w [Reads: Accumulator]
	lda $CA.b		; A5 CA ; Load $CA.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	.db $D0, $1B		; D0 1B ; Branch if not equal to $D0, $1B [Flow: branch]
	lda $CD.b		; A5 CD ; Load $CD.b into accumulator [Reads: Direct Page] [Writes: Accumulator] [Flags: NZ]
	clc		; 18 ; Clear carry flag [Flags: C]
	adc #$04.b		; 69 04 ; Add #$04.b to accumulator with carry [Writes: Accumulator] [Flags: NCVZ]
	sta $CD.b		; 85 CD ; Store accumulator to $CD.b [Reads: Accumulator]
	cmp #$04.b		; C9 04 ; Compare #$04.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $0C		; F0 0C ; Branch if equal to $F0, $0C [Flow: branch]
	cmp #$48.b		; C9 48 ; Compare #$48.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $08		; F0 08 ; Branch if equal to $F0, $08 [Flow: branch]
	cmp #$4C.b		; C9 4C ; Compare #$4C.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $F0, $04		; F0 04 ; Branch if equal to $F0, $04 [Flow: branch]
	cmp #$58.b		; C9 58 ; Compare #$58.b with accumulator [Reads: Accumulator] [Flags: NCZ]
	.db $D0, $04		; D0 04 ; Branch if not equal to $D0, $04 [Flow: branch]
	inc $CB.b		; E6 CB ; Increment $CB.b [Reads: Direct Page] [Flags: NZ]
	inc $CB.b		; E6 CB ; Increment $CB.b [Reads: Direct Page] [Flags: NZ]
	plb		; AB ; Pull data bank register  [Reads: Stack Pointer] [Writes: Data Bank] [Flags: NZ]
	rts		; 60 ; Return from subroutine [Reads: Stack Pointer] [Writes: Stack Pointer] [Flow: return]

	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	sbc $FFFFFF.l,X		; FF FF FF FF ; Subtract with carry (long,X) $FFFFFF.l,X [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $FF		; Opcode FF overrunning bank boundry at 067FFD. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $FF		; Opcode FF overrunning bank boundry at 067FFE. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
	.db $FF		; Opcode FF overrunning bank boundry at 067FFF. Skipping. ; Subtract with carry (long,X) $FF [Reads: X Index] [Writes: Accumulator] [Flags: NCVZ]
.ENDS
